from data_io.file_io import data_from_jsonl
from filter.internal_import_filter import InternalImportFilter
from go_tree_sitter.go_parser import GoParser
from go_tree_sitter.go_tree_sitter_tool import GoTreeSitterTool
from filter.undefined_behavior_filter import UndefinedBehaviorFilter

code = '''
// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:generate go run gen.go\n\n// Package sfnt implements a decoder for TTF (TrueType Fonts) and OTF\n// (OpenType Fonts). Such fonts are also known as SFNT fonts.\n//\n// This package provides a low-level API and does not depend on vector\n// rasterization packages.\n//\n// The sibling golang.org/x/image/font/opentype package provides a high-level\n// API, including glyph rasterization.\npackage sfnt // import \"golang.org/x/image/font/sfnt\"\n\n// This implementation was written primarily to the\n// https://www.microsoft.com/en-us/Typography/OpenTypeSpecification.aspx\n// specification. Additional documentation is at\n// http://developer.apple.com/fonts/TTRefMan/\n//\n// The pyftinspect tool from https://github.com/fonttools/fonttools is useful\n// for inspecting SFNT fonts.\n//\n// The ttfdump tool is also useful. For example:\n//\tttfdump -t cmap ../testdata/CFFTest.otf dump.txt\n\nimport (\n\t\"errors\"\n\t\"image\"\n\t\"io\"\n\n\t\"golang.org/x/image/font\"\n\t\"golang.org/x/internal/image/math/fixed\"\n\t\"golang.org/x/text/encoding/charmap\"\n)\n\n// These constants are not part of the specifications, but are limitations used\n// by this implementation.\nconst (\n\t// This value is arbitrary, but defends against parsing malicious font\n\t// files causing excessive memory allocations. For reference, Adobe's\n\t// SourceHanSansSC-Regular.otf has 65535 glyphs and:\n\t//\t- its format-4  cmap table has  1581 segments.\n\t//\t- its format-12 cmap table has 16498 segments.\n\t//\n\t// TODO: eliminate this constraint? If the cmap table is very large, load\n\t// some or all of it lazily (at the time Font.GlyphIndex is called) instead\n\t// of all of it eagerly (at the time Font.initialize is called), while\n\t// keeping an upper bound on the memory used? This will make the code in\n\t// cmap.go more complicated, considering that all of the Font methods are\n\t// safe to call concurrently, as long as each call has a different *Buffer.\n\tmaxCmapSegments = 20000\n\n\t// TODO: similarly, load subroutine locations lazily. Adobe's\n\t// SourceHanSansSC-Regular.otf has up to 30000 subroutines.\n\tmaxNumSubroutines = 40000\n\n\tmaxCompoundRecursionDepth = 8\n\tmaxCompoundStackSize      = 64\n\tmaxGlyphDataLength        = 64 * 1024\n\tmaxHintBits               = 256\n\tmaxNumFontDicts           = 256\n\tmaxNumFonts               = 256\n\tmaxNumTables              = 256\n\tmaxRealNumberStrLen       = 64 // Maximum length in bytes of the \"-123.456E-7\" representation.\n\n\t// (maxTableOffset + maxTableLength) will not overflow an int32.\n\tmaxTableLength = 1 << 29\n\tmaxTableOffset = 1 << 29\n)\n\nvar (\n\t// ErrColoredGlyph indicates that the requested glyph is not a monochrome\n\t// vector glyph, such as a colored (bitmap or vector) emoji glyph.\n\tErrColoredGlyph = errors.New(\"sfnt: colored glyph\")\n\t// ErrNotFound indicates that the requested value was not found.\n\tErrNotFound = errors.New(\"sfnt: not found\")\n\n\terrInvalidBounds          = errors.New(\"sfnt: invalid bounds\")\n\terrInvalidCFFTable        = errors.New(\"sfnt: invalid CFF table\")\n\terrInvalidCmapTable       = errors.New(\"sfnt: invalid cmap table\")\n\terrInvalidDfont           = errors.New(\"sfnt: invalid dfont\")\n\terrInvalidFont            = errors.New(\"sfnt: invalid font\")\n\terrInvalidFontCollection  = errors.New(\"sfnt: invalid font collection\")\n\terrInvalidGPOSTable       = errors.New(\"sfnt: invalid GPOS table\")\n\terrInvalidGlyphData       = errors.New(\"sfnt: invalid glyph data\")\n\terrInvalidGlyphDataLength = errors.New(\"sfnt: invalid glyph data length\")\n\terrInvalidHeadTable       = errors.New(\"sfnt: invalid head table\")\n\terrInvalidHheaTable       = errors.New(\"sfnt: invalid hhea table\")\n\terrInvalidHmtxTable       = errors.New(\"sfnt: invalid hmtx table\")\n\terrInvalidKernTable       = errors.New(\"sfnt: invalid kern table\")\n\terrInvalidLocaTable       = errors.New(\"sfnt: invalid loca table\")\n\terrInvalidLocationData    = errors.New(\"sfnt: invalid location data\")\n\terrInvalidMaxpTable       = errors.New(\"sfnt: invalid maxp table\")\n\terrInvalidNameTable       = errors.New(\"sfnt: invalid name table\")\n\terrInvalidOS2Table        = errors.New(\"sfnt: invalid OS/2 table\")\n\terrInvalidPostTable       = errors.New(\"sfnt: invalid post table\")\n\terrInvalidSingleFont      = errors.New(\"sfnt: invalid single font (data is a font collection)\")\n\terrInvalidSourceData      = errors.New(\"sfnt: invalid source data\")\n\terrInvalidTableOffset     = errors.New(\"sfnt: invalid table offset\")\n\terrInvalidTableTagOrder   = errors.New(\"sfnt: invalid table tag order\")\n\terrInvalidUCS2String      = errors.New(\"sfnt: invalid UCS-2 string\")\n\n\terrUnsupportedCFFFDSelectTable     = errors.New(\"sfnt: unsupported CFF FDSelect table\")\n\terrUnsupportedCFFVersion           = errors.New(\"sfnt: unsupported CFF version\")\n\terrUnsupportedClassDefFormat       = errors.New(\"sfnt: unsupported class definition format\")\n\terrUnsupportedCmapEncodings        = errors.New(\"sfnt: unsupported cmap encodings\")\n\terrUnsupportedCompoundGlyph        = errors.New(\"sfnt: unsupported compound glyph\")\n\terrUnsupportedCoverageFormat       = errors.New(\"sfnt: unsupported coverage format\")\n\terrUnsupportedExtensionPosFormat   = errors.New(\"sfnt: unsupported extension positioning format\")\n\terrUnsupportedGPOSTable            = errors.New(\"sfnt: unsupported GPOS table\")\n\terrUnsupportedGlyphDataLength      = errors.New(\"sfnt: unsupported glyph data length\")\n\terrUnsupportedKernTable            = errors.New(\"sfnt: unsupported kern table\")\n\terrUnsupportedNumberOfCmapSegments = errors.New(\"sfnt: unsupported number of cmap segments\")\n\terrUnsupportedNumberOfFontDicts    = errors.New(\"sfnt: unsupported number of font dicts\")\n\terrUnsupportedNumberOfFonts        = errors.New(\"sfnt: unsupported number of fonts\")\n\terrUnsupportedNumberOfHints        = errors.New(\"sfnt: unsupported number of hints\")\n\terrUnsupportedNumberOfSubroutines  = errors.New(\"sfnt: unsupported number of subroutines\")\n\terrUnsupportedNumberOfTables       = errors.New(\"sfnt: unsupported number of tables\")\n\terrUnsupportedPlatformEncoding     = errors.New(\"sfnt: unsupported platform encoding\")\n\terrUnsupportedPostTable            = errors.New(\"sfnt: unsupported post table\")\n\terrUnsupportedRealNumberEncoding   = errors.New(\"sfnt: unsupported real number encoding\")\n\terrUnsupportedTableOffsetLength    = errors.New(\"sfnt: unsupported table offset or length\")\n\terrUnsupportedType2Charstring      = errors.New(\"sfnt: unsupported Type 2 Charstring\")\n)\n\n// GlyphIndex is a glyph index in a Font.\ntype GlyphIndex uint16\n\n// NameID identifies a name table entry.\n//\n// See the \"Name IDs\" section of\n// https://www.microsoft.com/typography/otspec/name.htm\ntype NameID uint16\n\nconst (\n\tNameIDCopyright                  NameID = 0\n\tNameIDFamily                            = 1\n\tNameIDSubfamily                         = 2\n\tNameIDUniqueIdentifier                  = 3\n\tNameIDFull                              = 4\n\tNameIDVersion                           = 5\n\tNameIDPostScript                        = 6\n\tNameIDTrademark                         = 7\n\tNameIDManufacturer                      = 8\n\tNameIDDesigner                          = 9\n\tNameIDDescription                       = 10\n\tNameIDVendorURL                         = 11\n\tNameIDDesignerURL                       = 12\n\tNameIDLicense                           = 13\n\tNameIDLicenseURL                        = 14\n\tNameIDTypographicFamily                 = 16\n\tNameIDTypographicSubfamily              = 17\n\tNameIDCompatibleFull                    = 18\n\tNameIDSampleText                        = 19\n\tNameIDPostScriptCID                     = 20\n\tNameIDWWSFamily                         = 21\n\tNameIDWWSSubfamily                      = 22\n\tNameIDLightBackgroundPalette            = 23\n\tNameIDDarkBackgroundPalette             = 24\n\tNameIDVariationsPostScriptPrefix        = 25\n)\n\n// Units are an integral number of abstract, scalable \"font units\". The em\n// square is typically 1000 or 2048 \"font units\". This would map to a certain\n// number (e.g. 30 pixels) of physical pixels, depending on things like the\n// display resolution (DPI) and font size (e.g. a 12 point font).\ntype Units int32\n\n// scale returns x divided by unitsPerEm, rounded to the nearest fixed.Int26_6\n// value (1/64th of a pixel).\nfunc scale(x fixed.Int26_6, unitsPerEm Units) fixed.Int26_6 {\n\tif x >= 0 {\n\t\tx += fixed.Int26_6(unitsPerEm) / 2\n\t} else {\n\t\tx -= fixed.Int26_6(unitsPerEm) / 2\n\t}\n\treturn x / fixed.Int26_6(unitsPerEm)\n}\n\nfunc u16(b []byte) uint16 {\n\t_ = b[1] // Bounds check hint to compiler.\n\treturn uint16(b[0])<<8 | uint16(b[1])<<0\n}\n\nfunc u32(b []byte) uint32 {\n\t_ = b[3] // Bounds check hint to compiler.\n\treturn uint32(b[0])<<24 | uint32(b[1])<<16 | uint32(b[2])<<8 | uint32(b[3])<<0\n}\n\n// source is a source of byte data. Conceptually, it is like an io.ReaderAt,\n// except that a common source of SFNT font data is in-memory instead of\n// on-disk: a []byte containing the entire data, either as a global variable\n// (e.g. \"goregular.TTF\") or the result of an ioutil.ReadFile call. In such\n// cases, as an optimization, we skip the io.Reader / io.ReaderAt model of\n// copying from the source to a caller-supplied buffer, and instead provide\n// direct access to the underlying []byte data.\ntype source struct {\n\tb []byte\n\tr io.ReaderAt\n\n\t// TODO: add a caching layer, if we're using the io.ReaderAt? Note that\n\t// this might make a source no longer safe to use concurrently.\n}\n\n// valid returns whether exactly one of s.b and s.r is nil.\nfunc (s *source) valid() bool {\n\treturn (s.b == nil) != (s.r == nil)\n}\n\n// viewBufferWritable returns whether the []byte returned by source.view can be\n// written to by the caller, including by passing it to the same method\n// (source.view) on other receivers (i.e. different sources).\n//\n// In other words, it returns whether the source's underlying data is an\n// io.ReaderAt, not a []byte.\nfunc (s *source) viewBufferWritable() bool {\n\treturn s.b == nil\n}\n\n// view returns the length bytes at the given offset. buf is an optional\n// scratch buffer to reduce allocations when calling view multiple times. A nil\n// buf is valid. The []byte returned may be a sub-slice of buf[:cap(buf)], or\n// it may be an unrelated slice. In any case, the caller should not modify the\n// contents of the returned []byte, other than passing that []byte back to this\n// method on the same source s.\nfunc (s *source) view(buf []byte, offset, length int) ([]byte, error) {\n\tif 0 > offset || offset > offset+length {\n\t\treturn nil, errInvalidBounds\n\t}\n\n\t// Try reading from the []byte.\n\tif s.b != nil {\n\t\tif offset+length > len(s.b) {\n\t\t\treturn nil, errInvalidBounds\n\t\t}\n\t\treturn s.b[offset : offset+length], nil\n\t}\n\n\t// Read from the io.ReaderAt.\n\tif length <= cap(buf) {\n\t\tbuf = buf[:length]\n\t} else {\n\t\t// Round length up to the nearest KiB. The slack can lead to fewer\n\t\t// allocations if the buffer is re-used for multiple source.view calls.\n\t\tn := length\n\t\tn += 1023\n\t\tn &^= 1023\n\t\tbuf = make([]byte, length, n)\n\t}\n\tif n, err := s.r.ReadAt(buf, int64(offset)); n != length {\n\t\treturn nil, err\n\t}\n\treturn buf, nil\n}\n\n// varLenView returns bytes from the given offset for sub-tables with varying\n// length. The length of bytes is determined by staticLength plus n*itemLength,\n// where n is read as uint16 from countOffset (relative to offset). buf is an\n// optional scratch buffer (see source.view())\nfunc (s *source) varLenView(buf []byte, offset, staticLength, countOffset, itemLength int) ([]byte, int, error) {\n\tif 0 > offset || offset > offset+staticLength {\n\t\treturn nil, 0, errInvalidBounds\n\t}\n\tif 0 > countOffset || countOffset+1 >= staticLength {\n\t\treturn nil, 0, errInvalidBounds\n\t}\n\n\t// read static part which contains our count\n\tbuf, err := s.view(buf, offset, staticLength)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tcount := int(u16(buf[countOffset:]))\n\tbuf, err = s.view(buf, offset, staticLength+count*itemLength)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\treturn buf, count, nil\n}\n\n// u16 returns the uint16 in the table t at the relative offset i.\n//\n// buf is an optional scratch buffer as per the source.view method.\nfunc (s *source) u16(buf []byte, t table, i int) (uint16, error) {\n\tif i < 0 || uint(t.length) < uint(i+2) {\n\t\treturn 0, errInvalidBounds\n\t}\n\tbuf, err := s.view(buf, int(t.offset)+i, 2)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn u16(buf), nil\n}\n\n// u32 returns the uint32 in the table t at the relative offset i.\n//\n// buf is an optional scratch buffer as per the source.view method.\nfunc (s *source) u32(buf []byte, t table, i int) (uint32, error) {\n\tif i < 0 || uint(t.length) < uint(i+4) {\n\t\treturn 0, errInvalidBounds\n\t}\n\tbuf, err := s.view(buf, int(t.offset)+i, 4)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn u32(buf), nil\n}\n\n// table is a section of the font data.\ntype table struct {\n\toffset, length uint32\n}\n\n// ParseCollection parses an SFNT font collection, such as TTC or OTC data,\n// from a []byte data source.\n//\n// If passed data for a single font, a TTF or OTF instead of a TTC or OTC, it\n// will return a collection containing 1 font.\nfunc ParseCollection(src []byte) (*Collection, error) {\n\tc := &Collection{src: source{b: src}}\n\tif err := c.initialize(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\n// ParseCollectionReaderAt parses an SFNT collection, such as TTC or OTC data,\n// from an io.ReaderAt data source.\n//\n// If passed data for a single font, a TTF or OTF instead of a TTC or OTC, it\n// will return a collection containing 1 font.\nfunc ParseCollectionReaderAt(src io.ReaderAt) (*Collection, error) {\n\tc := &Collection{src: source{r: src}}\n\tif err := c.initialize(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\n// Collection is a collection of one or more fonts.\n//\n// All of the Collection methods are safe to call concurrently.\ntype Collection struct {\n\tsrc     source\n\toffsets []uint32\n\tisDfont bool\n}\n\n// NumFonts returns the number of fonts in the collection.\nfunc (c *Collection) NumFonts() int { return len(c.offsets) }\n\nfunc (c *Collection) initialize() error {\n\t// The https://www.microsoft.com/typography/otspec/otff.htm \"Font\n\t// Collections\" section describes the TTC header.\n\t//\n\t// https://github.com/kreativekorp/ksfl/wiki/Macintosh-Resource-File-Format\n\t// describes the dfont header.\n\t//\n\t// 16 is the maximum of sizeof(TTCHeader) and sizeof(DfontHeader).\n\tbuf, err := c.src.view(nil, 0, 16)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// These cases match the switch statement in Font.initializeTables.\n\tswitch u32(buf) {\n\tdefault:\n\t\treturn errInvalidFontCollection\n\tcase dfontResourceDataOffset:\n\t\treturn c.parseDfont(buf, u32(buf[4:]), u32(buf[12:]))\n\tcase 0x00010000, 0x4f54544f, 0x74727565: // 0x10000, \"OTTO\", \"true\"\n\t\t// Try parsing it as a single font instead of a collection.\n\t\tc.offsets = []uint32{0}\n\tcase 0x74746366: // \"ttcf\".\n\t\tnumFonts := u32(buf[8:])\n\t\tif numFonts == 0 || numFonts > maxNumFonts {\n\t\t\treturn errUnsupportedNumberOfFonts\n\t\t}\n\t\tbuf, err = c.src.view(nil, 12, int(4*numFonts))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.offsets = make([]uint32, numFonts)\n\t\tfor i := range c.offsets {\n\t\t\to := u32(buf[4*i:])\n\t\t\tif o > maxTableOffset {\n\t\t\t\treturn errUnsupportedTableOffsetLength\n\t\t\t}\n\t\t\tc.offsets[i] = o\n\t\t}\n\t}\n\treturn nil\n}\n\n// dfontResourceDataOffset is the assumed value of a dfont file's resource data\n// offset.\n//\n// https://github.com/kreativekorp/ksfl/wiki/Macintosh-Resource-File-Format\n// says that \"A Mac OS resource file... [starts with an] offset from start of\n// file to start of resource data section... [usually] 0x0100\". In theory,\n// 0x00000100 isn't always a magic number for identifying dfont files. In\n// practice, it seems to work.\nconst dfontResourceDataOffset = 0x00000100\n\n// parseDfont parses a dfont resource map, as per\n// https://github.com/kreativekorp/ksfl/wiki/Macintosh-Resource-File-Format\n//\n// That unofficial wiki page lists all of its fields as *signed* integers,\n// which looks unusual. The actual file format might use *unsigned* integers in\n// various places, but until we have either an official specification or an\n// actual dfont file where this matters, we'll use signed integers and treat\n// negative values as invalid.\nfunc (c *Collection) parseDfont(buf []byte, resourceMapOffset, resourceMapLength uint32) error {\n\tif resourceMapOffset > maxTableOffset || resourceMapLength > maxTableLength {\n\t\treturn errUnsupportedTableOffsetLength\n\t}\n\n\tconst headerSize = 28\n\tif resourceMapLength < headerSize {\n\t\treturn errInvalidDfont\n\t}\n\tbuf, err := c.src.view(buf, int(resourceMapOffset+24), 2)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttypeListOffset := int(int16(u16(buf)))\n\n\tif typeListOffset < headerSize || resourceMapLength < uint32(typeListOffset)+2 {\n\t\treturn errInvalidDfont\n\t}\n\tbuf, err = c.src.view(buf, int(resourceMapOffset)+typeListOffset, 2)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttypeCount := int(int16(u16(buf)))\n\n\tconst tSize = 8\n\tif typeCount < 0 || tSize*uint32(typeCount) > resourceMapLength-uint32(typeListOffset)-2 {\n\t\treturn errInvalidDfont\n\t}\n\tbuf, err = c.src.view(buf, int(resourceMapOffset)+typeListOffset+2, tSize*typeCount)\n\tif err != nil {\n\t\treturn err\n\t}\n\tresourceCount, resourceListOffset := 0, 0\n\tfor i := 0; i < typeCount; i++ {\n\t\tif u32(buf[tSize*i:]) != 0x73666e74 { // \"sfnt\".\n\t\t\tcontinue\n\t\t}\n\n\t\tresourceCount = int(int16(u16(buf[tSize*i+4:])))\n\t\tif resourceCount < 0 {\n\t\t\treturn errInvalidDfont\n\t\t}\n\t\t// https://github.com/kreativekorp/ksfl/wiki/Macintosh-Resource-File-Format\n\t\t// says that the value in the wire format is \"the number of\n\t\t// resources of this type, minus one.\"\n\t\tresourceCount++\n\n\t\tresourceListOffset = int(int16(u16(buf[tSize*i+6:])))\n\t\tif resourceListOffset < 0 {\n\t\t\treturn errInvalidDfont\n\t\t}\n\t\tbreak\n\t}\n\tif resourceCount == 0 {\n\t\treturn errInvalidDfont\n\t}\n\tif resourceCount > maxNumFonts {\n\t\treturn errUnsupportedNumberOfFonts\n\t}\n\n\tconst rSize = 12\n\tif o, n := uint32(typeListOffset+resourceListOffset), rSize*uint32(resourceCount); o > resourceMapLength || n > resourceMapLength-o {\n\t\treturn errInvalidDfont\n\t} else {\n\t\tbuf, err = c.src.view(buf, int(resourceMapOffset+o), int(n))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tc.offsets = make([]uint32, resourceCount)\n\tfor i := range c.offsets {\n\t\to := 0xffffff & u32(buf[rSize*i+4:])\n\t\t// Offsets are relative to the resource data start, not the file start.\n\t\t// A particular resource's data also starts with a 4-byte length, which\n\t\t// we skip.\n\t\to += dfontResourceDataOffset + 4\n\t\tif o > maxTableOffset {\n\t\t\treturn errUnsupportedTableOffsetLength\n\t\t}\n\t\tc.offsets[i] = o\n\t}\n\tc.isDfont = true\n\treturn nil\n}\n\n// Font returns the i'th font in the collection.\nfunc (c *Collection) Font(i int) (*Font, error) {\n\tif i < 0 || len(c.offsets) <= i {\n\t\treturn nil, ErrNotFound\n\t}\n\tf := &Font{src: c.src}\n\tif err := f.initialize(int(c.offsets[i]), c.isDfont); err != nil {\n\t\treturn nil, err\n\t}\n\treturn f, nil\n}\n\n// Parse parses an SFNT font, such as TTF or OTF data, from a []byte data\n// source.\nfunc Parse(src []byte) (*Font, error) {\n\tf := &Font{src: source{b: src}}\n\tif err := f.initialize(0, false); err != nil {\n\t\treturn nil, err\n\t}\n\treturn f, nil\n}\n\n// ParseReaderAt parses an SFNT font, such as TTF or OTF data, from an\n// io.ReaderAt data source.\nfunc ParseReaderAt(src io.ReaderAt) (*Font, error) {\n\tf := &Font{src: source{r: src}}\n\tif err := f.initialize(0, false); err != nil {\n\t\treturn nil, err\n\t}\n\treturn f, nil\n}\n\n// Font is an SFNT font.\n//\n// Many of its methods take a *Buffer argument, as re-using buffers can reduce\n// the total memory allocation of repeated Font method calls, such as measuring\n// and rasterizing every unique glyph in a string of text. If efficiency is not\n// a concern, passing a nil *Buffer is valid, and implies using a temporary\n// buffer for a single call.\n//\n// It is valid to re-use a *Buffer with multiple Font method calls, even with\n// different *Font receivers, as long as they are not concurrent calls.\n//\n// All of the Font methods are safe to call concurrently, as long as each call\n// has a different *Buffer (or nil).\n//\n// The Font methods that don't take a *Buffer argument are always safe to call\n// concurrently.\n//\n// Some methods provide lengths or coordinates, e.g. bounds, font metrics and\n// control points. All of these methods take a ppem parameter, which is the\n// number of pixels in 1 em, expressed as a 26.6 fixed point value. For\n// example, if 1 em is 10 pixels then ppem is fixed.I(10), which equals\n// fixed.Int26_6(10 << 6).\n//\n// To get those lengths or coordinates in terms of font units instead of\n// pixels, use ppem = fixed.Int26_6(f.UnitsPerEm()) and if those methods take a\n// font.Hinting parameter, use font.HintingNone. The return values will have\n// type fixed.Int26_6, but those numbers can be converted back to Units with no\n// further scaling necessary.\ntype Font struct {\n\tsrc source\n\n\t// https://www.microsoft.com/typography/otspec/otff.htm#otttables\n\t// \"Required Tables\".\n\tcmap table\n\thead table\n\thhea table\n\thmtx table\n\tmaxp table\n\tname table\n\tos2  table\n\tpost table\n\n\t// https://www.microsoft.com/typography/otspec/otff.htm#otttables\n\t// \"Tables Related to TrueType Outlines\".\n\t//\n\t// This implementation does not support hinting, so it does not read the\n\t// cvt, fpgm gasp or prep tables.\n\tglyf table\n\tloca table\n\n\t// https://www.microsoft.com/typography/otspec/otff.htm#otttables\n\t// \"Tables Related to PostScript Outlines\".\n\t//\n\t// TODO: cff2, vorg?\n\tcff table\n\n\t// https://www.microsoft.com/typography/otspec/otff.htm#otttables\n\t// \"Tables Related to Bitmap Glyphs\".\n\t//\n\t// TODO: Others?\n\tcblc table\n\n\t// https://www.microsoft.com/typography/otspec/otff.htm#otttables\n\t// \"Advanced Typographic Tables\".\n\t//\n\t// TODO: base, gdef, gsub, jstf, math?\n\tgpos table\n\n\t// https://www.microsoft.com/typography/otspec/otff.htm#otttables\n\t// \"Other OpenType Tables\".\n\t//\n\t// TODO: hdmx, vmtx? Others?\n\tkern table\n\n\tcached struct {\n\t\tascent           int32\n\t\tcapHeight        int32\n\t\tglyphData        glyphData\n\t\tglyphIndex       glyphIndexFunc\n\t\tbounds           [4]int16\n\t\tdescent          int32\n\t\tindexToLocFormat bool // false means short, true means long.\n\t\tisColorBitmap    bool\n\t\tisPostScript     bool\n\t\tkernNumPairs     int32\n\t\tkernOffset       int32\n\t\tkernFuncs        []kernFunc\n\t\tlineGap          int32\n\t\tnumHMetrics      int32\n\t\tpost             *PostTable\n\t\tslope            [2]int32\n\t\tunitsPerEm       Units\n\t\txHeight          int32\n\t}\n}\n\n// NumGlyphs returns the number of glyphs in f.\nfunc (f *Font) NumGlyphs() int { return len(f.cached.glyphData.locations) - 1 }\n\n// UnitsPerEm returns the number of units per em for f.\nfunc (f *Font) UnitsPerEm() Units { return f.cached.unitsPerEm }\n\nfunc (f *Font) initialize(offset int, isDfont bool) error {\n\tif !f.src.valid() {\n\t\treturn errInvalidSourceData\n\t}\n\tbuf, isPostScript, err := f.initializeTables(offset, isDfont)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// The order of these parseXxx calls matters. Later calls may depend on\n\t// information parsed by earlier calls, such as the maxp table's numGlyphs.\n\t// To enforce these dependencies, such information is passed and returned\n\t// explicitly, and the f.cached fields are only set afterwards.\n\t//\n\t// When implementing new parseXxx methods, take care not to call methods\n\t// such as Font.NumGlyphs that implicitly depend on f.cached fields.\n\n\tbuf, bounds, indexToLocFormat, unitsPerEm, err := f.parseHead(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf, numGlyphs, err := f.parseMaxp(buf, isPostScript)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf, glyphData, isColorBitmap, err := f.parseGlyphData(buf, numGlyphs, indexToLocFormat, isPostScript)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf, glyphIndex, err := f.parseCmap(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf, kernNumPairs, kernOffset, err := f.parseKern(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf, kernFuncs, err := f.parseGPOSKern(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf, ascent, descent, lineGap, run, rise, numHMetrics, err := f.parseHhea(buf, numGlyphs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf, err = f.parseHmtx(buf, numGlyphs, numHMetrics)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf, hasXHeightCapHeight, xHeight, capHeight, err := f.parseOS2(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf, post, err := f.parsePost(buf, numGlyphs)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tf.cached.ascent = ascent\n\tf.cached.capHeight = capHeight\n\tf.cached.glyphData = glyphData\n\tf.cached.glyphIndex = glyphIndex\n\tf.cached.bounds = bounds\n\tf.cached.descent = descent\n\tf.cached.indexToLocFormat = indexToLocFormat\n\tf.cached.isColorBitmap = isColorBitmap\n\tf.cached.isPostScript = isPostScript\n\tf.cached.kernNumPairs = kernNumPairs\n\tf.cached.kernOffset = kernOffset\n\tf.cached.kernFuncs = kernFuncs\n\tf.cached.lineGap = lineGap\n\tf.cached.numHMetrics = numHMetrics\n\tf.cached.post = post\n\tf.cached.slope = [2]int32{run, rise}\n\tf.cached.unitsPerEm = unitsPerEm\n\tf.cached.xHeight = xHeight\n\n\tif !hasXHeightCapHeight {\n\t\txh, ch, err := f.initOS2Version1()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf.cached.xHeight = xh\n\t\tf.cached.capHeight = ch\n\t}\n\n\treturn nil\n}\n\nfunc (f *Font) initializeTables(offset int, isDfont bool) (buf1 []byte, isPostScript bool, err error) {\n\t// https://www.microsoft.com/typography/otspec/otff.htm \"Organization of an\n\t// OpenType Font\" says that \"The OpenType font starts with the Offset\n\t// Table\", which is 12 bytes.\n\tbuf, err := f.src.view(nil, offset, 12)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\t// When updating the cases in this switch statement, also update the\n\t// Collection.initialize method.\n\tswitch u32(buf) {\n\tdefault:\n\t\treturn nil, false, errInvalidFont\n\tcase dfontResourceDataOffset:\n\t\treturn nil, false, errInvalidSingleFont\n\tcase 0x00010000:\n\t\t// No-op.\n\tcase 0x4f54544f: // \"OTTO\".\n\t\tisPostScript = true\n\tcase 0x74727565: // \"true\"\n\t\t// No-op.\n\tcase 0x74746366: // \"ttcf\".\n\t\treturn nil, false, errInvalidSingleFont\n\t}\n\tnumTables := int(u16(buf[4:]))\n\tif numTables > maxNumTables {\n\t\treturn nil, false, errUnsupportedNumberOfTables\n\t}\n\n\t// \"The Offset Table is followed immediately by the Table Record entries...\n\t// sorted in ascending order by tag\", 16 bytes each.\n\tbuf, err = f.src.view(buf, offset+12, 16*numTables)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tfor b, first, prevTag := buf, true, uint32(0); len(b) > 0; b = b[16:] {\n\t\ttag := u32(b)\n\t\tif first {\n\t\t\tfirst = false\n\t\t} else if tag <= prevTag {\n\t\t\treturn nil, false, errInvalidTableTagOrder\n\t\t}\n\t\tprevTag = tag\n\n\t\to, n := u32(b[8:12]), u32(b[12:16])\n\t\t// For dfont files, the offset is relative to the resource, not the\n\t\t// file.\n\t\tif isDfont {\n\t\t\torigO := o\n\t\t\to += uint32(offset)\n\t\t\tif o < origO {\n\t\t\t\treturn nil, false, errUnsupportedTableOffsetLength\n\t\t\t}\n\t\t}\n\t\tif o > maxTableOffset || n > maxTableLength {\n\t\t\treturn nil, false, errUnsupportedTableOffsetLength\n\t\t}\n\t\t// We ignore the checksums, but \"all tables must begin on four byte\n\t\t// boundries [sic]\".\n\t\tif o&3 != 0 {\n\t\t\treturn nil, false, errInvalidTableOffset\n\t\t}\n\n\t\t// Match the 4-byte tag as a uint32. For example, \"OS/2\" is 0x4f532f32.\n\t\tswitch tag {\n\t\tcase 0x43424c43:\n\t\t\tf.cblc = table{o, n}\n\t\tcase 0x43464620:\n\t\t\tf.cff = table{o, n}\n\t\tcase 0x4f532f32:\n\t\t\tf.os2 = table{o, n}\n\t\tcase 0x636d6170:\n\t\t\tf.cmap = table{o, n}\n\t\tcase 0x676c7966:\n\t\t\tf.glyf = table{o, n}\n\t\tcase 0x47504f53:\n\t\t\tf.gpos = table{o, n}\n\t\tcase 0x68656164:\n\t\t\tf.head = table{o, n}\n\t\tcase 0x68686561:\n\t\t\tf.hhea = table{o, n}\n\t\tcase 0x686d7478:\n\t\t\tf.hmtx = table{o, n}\n\t\tcase 0x6b65726e:\n\t\t\tf.kern = table{o, n}\n\t\tcase 0x6c6f6361:\n\t\t\tf.loca = table{o, n}\n\t\tcase 0x6d617870:\n\t\t\tf.maxp = table{o, n}\n\t\tcase 0x6e616d65:\n\t\t\tf.name = table{o, n}\n\t\tcase 0x706f7374:\n\t\t\tf.post = table{o, n}\n\t\t}\n\t}\n\treturn buf, isPostScript, nil\n}\n\nfunc (f *Font) parseCmap(buf []byte) (buf1 []byte, glyphIndex glyphIndexFunc, err error) {\n\t// https://www.microsoft.com/typography/OTSPEC/cmap.htm\n\n\tconst headerSize, entrySize = 4, 8\n\tif f.cmap.length < headerSize {\n\t\treturn nil, nil, errInvalidCmapTable\n\t}\n\tu, err := f.src.u16(buf, f.cmap, 2)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tnumSubtables := int(u)\n\tif f.cmap.length < headerSize+entrySize*uint32(numSubtables) {\n\t\treturn nil, nil, errInvalidCmapTable\n\t}\n\n\tvar (\n\t\tbestWidth  int\n\t\tbestOffset uint32\n\t\tbestLength uint32\n\t\tbestFormat uint16\n\t)\n\n\t// Scan all of the subtables, picking the widest supported one. See the\n\t// platformEncodingWidth comment for more discussion of width.\n\tfor i := 0; i < numSubtables; i++ {\n\t\tbuf, err = f.src.view(buf, int(f.cmap.offset)+headerSize+entrySize*i, entrySize)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tpid := u16(buf)\n\t\tpsid := u16(buf[2:])\n\t\twidth := platformEncodingWidth(pid, psid)\n\t\tif width <= bestWidth {\n\t\t\tcontinue\n\t\t}\n\t\toffset := u32(buf[4:])\n\n\t\tif offset > f.cmap.length-4 {\n\t\t\treturn nil, nil, errInvalidCmapTable\n\t\t}\n\t\tbuf, err = f.src.view(buf, int(f.cmap.offset+offset), 4)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tformat := u16(buf)\n\t\tif !supportedCmapFormat(format, pid, psid) {\n\t\t\tcontinue\n\t\t}\n\t\tlength := uint32(u16(buf[2:]))\n\n\t\tbestWidth = width\n\t\tbestOffset = offset\n\t\tbestLength = length\n\t\tbestFormat = format\n\t}\n\n\tif bestWidth == 0 {\n\t\treturn nil, nil, errUnsupportedCmapEncodings\n\t}\n\treturn f.makeCachedGlyphIndex(buf, bestOffset, bestLength, bestFormat)\n}\n\nfunc (f *Font) parseHead(buf []byte) (buf1 []byte, bounds [4]int16, indexToLocFormat bool, unitsPerEm Units, err error) {\n\t// https://www.microsoft.com/typography/otspec/head.htm\n\n\tif f.head.length != 54 {\n\t\treturn nil, [4]int16{}, false, 0, errInvalidHeadTable\n\t}\n\n\tu, err := f.src.u16(buf, f.head, 18)\n\tif err != nil {\n\t\treturn nil, [4]int16{}, false, 0, err\n\t}\n\tif u == 0 {\n\t\treturn nil, [4]int16{}, false, 0, errInvalidHeadTable\n\t}\n\tunitsPerEm = Units(u)\n\n\tfor i := range bounds {\n\t\tu, err := f.src.u16(buf, f.head, 36+2*i)\n\t\tif err != nil {\n\t\t\treturn nil, [4]int16{}, false, 0, err\n\t\t}\n\t\tbounds[i] = int16(u)\n\t}\n\n\tu, err = f.src.u16(buf, f.head, 50)\n\tif err != nil {\n\t\treturn nil, [4]int16{}, false, 0, err\n\t}\n\tindexToLocFormat = u != 0\n\treturn buf, bounds, indexToLocFormat, unitsPerEm, nil\n}\n\nfunc (f *Font) parseHhea(buf []byte, numGlyphs int32) (buf1 []byte, ascent, descent, lineGap, run, rise, numHMetrics int32, err error) {\n\t// https://www.microsoft.com/typography/OTSPEC/hhea.htm\n\n\tif f.hhea.length != 36 {\n\t\treturn nil, 0, 0, 0, 0, 0, 0, errInvalidHheaTable\n\t}\n\tu, err := f.src.u16(buf, f.hhea, 34)\n\tif err != nil {\n\t\treturn nil, 0, 0, 0, 0, 0, 0, err\n\t}\n\tif int32(u) > numGlyphs || u == 0 {\n\t\treturn nil, 0, 0, 0, 0, 0, 0, errInvalidHheaTable\n\t}\n\ta, err := f.src.u16(buf, f.hhea, 4)\n\tif err != nil {\n\t\treturn nil, 0, 0, 0, 0, 0, 0, err\n\t}\n\td, err := f.src.u16(buf, f.hhea, 6)\n\tif err != nil {\n\t\treturn nil, 0, 0, 0, 0, 0, 0, err\n\t}\n\tl, err := f.src.u16(buf, f.hhea, 8)\n\tif err != nil {\n\t\treturn nil, 0, 0, 0, 0, 0, 0, err\n\t}\n\tru, err := f.src.u16(buf, f.hhea, 20)\n\tif err != nil {\n\t\treturn nil, 0, 0, 0, 0, 0, 0, err\n\t}\n\tri, err := f.src.u16(buf, f.hhea, 18)\n\tif err != nil {\n\t\treturn nil, 0, 0, 0, 0, 0, 0, err\n\t}\n\treturn buf, int32(int16(a)), int32(int16(d)), int32(int16(l)), int32(int16(ru)), int32(int16(ri)), int32(u), nil\n}\n\nfunc (f *Font) parseHmtx(buf []byte, numGlyphs, numHMetrics int32) (buf1 []byte, err error) {\n\t// https://www.microsoft.com/typography/OTSPEC/hmtx.htm\n\n\t// The spec says that the hmtx table's length should be\n\t// \"4*numHMetrics+2*(numGlyphs-numHMetrics)\". However, some fonts seen in the\n\t// wild omit the \"2*(nG-nHM)\". See https://github.com/golang/go/issues/28379\n\tif f.hmtx.length != uint32(4*numHMetrics) && f.hmtx.length != uint32(4*numHMetrics+2*(numGlyphs-numHMetrics)) {\n\t\treturn nil, errInvalidHmtxTable\n\t}\n\treturn buf, nil\n}\n\nfunc (f *Font) parseKern(buf []byte) (buf1 []byte, kernNumPairs, kernOffset int32, err error) {\n\t// https://www.microsoft.com/typography/otspec/kern.htm\n\n\tif f.kern.length == 0 {\n\t\treturn buf, 0, 0, nil\n\t}\n\tconst headerSize = 4\n\tif f.kern.length < headerSize {\n\t\treturn nil, 0, 0, errInvalidKernTable\n\t}\n\tbuf, err = f.src.view(buf, int(f.kern.offset), headerSize)\n\tif err != nil {\n\t\treturn nil, 0, 0, err\n\t}\n\toffset := int(f.kern.offset) + headerSize\n\tlength := int(f.kern.length) - headerSize\n\n\tswitch version := u16(buf); version {\n\tcase 0:\n\t\tif numTables := int(u16(buf[2:])); numTables == 0 {\n\t\t\treturn buf, 0, 0, nil\n\t\t} else if numTables > 1 {\n\t\t\t// TODO: support multiple subtables. For now, fall through and use\n\t\t\t// only the first one.\n\t\t}\n\t\treturn f.parseKernVersion0(buf, offset, length)\n\tcase 1:\n\t\tif buf[2] != 0 || buf[3] != 0 {\n\t\t\treturn nil, 0, 0, errUnsupportedKernTable\n\t\t}\n\t\t// Microsoft's https://www.microsoft.com/typography/otspec/kern.htm\n\t\t// says that \"Apple has extended the definition of the 'kern' table to\n\t\t// provide additional functionality. The Apple extensions are not\n\t\t// supported on Windows.\"\n\t\t//\n\t\t// The format is relatively complicated, including encoding a state\n\t\t// machine, but rarely seen. We follow Microsoft's and FreeType's\n\t\t// behavior and simply ignore it. Theoretically, we could follow\n\t\t// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html\n\t\t// but it doesn't seem worth the effort.\n\t\treturn buf, 0, 0, nil\n\t}\n\treturn nil, 0, 0, errUnsupportedKernTable\n}\n\nfunc (f *Font) parseKernVersion0(buf []byte, offset, length int) (buf1 []byte, kernNumPairs, kernOffset int32, err error) {\n\tconst headerSize = 6\n\tif length < headerSize {\n\t\treturn nil, 0, 0, errInvalidKernTable\n\t}\n\tbuf, err = f.src.view(buf, offset, headerSize)\n\tif err != nil {\n\t\treturn nil, 0, 0, err\n\t}\n\tif version := u16(buf); version != 0 {\n\t\treturn nil, 0, 0, errUnsupportedKernTable\n\t}\n\tsubtableLengthU16 := u16(buf[2:])\n\tif int(subtableLengthU16) < headerSize || length < int(subtableLengthU16) {\n\t\treturn nil, 0, 0, errInvalidKernTable\n\t}\n\tif coverageBits := buf[5]; coverageBits != 0x01 {\n\t\t// We only support horizontal kerning.\n\t\treturn nil, 0, 0, errUnsupportedKernTable\n\t}\n\toffset += headerSize\n\tlength -= headerSize\n\tsubtableLengthU16 -= headerSize\n\n\tswitch format := buf[4]; format {\n\tcase 0:\n\t\treturn f.parseKernFormat0(buf, offset, length, subtableLengthU16)\n\tcase 2:\n\t\t// If we could find such a font, we could write code to support it, but\n\t\t// a comment in the equivalent FreeType code (sfnt/ttkern.c) says that\n\t\t// they've never seen such a font.\n\t}\n\treturn nil, 0, 0, errUnsupportedKernTable\n}\n\nfunc (f *Font) parseKernFormat0(buf []byte, offset, length int, subtableLengthU16 uint16) (buf1 []byte, kernNumPairs, kernOffset int32, err error) {\n\tconst headerSize, entrySize = 8, 6\n\tif length < headerSize {\n\t\treturn nil, 0, 0, errInvalidKernTable\n\t}\n\tbuf, err = f.src.view(buf, offset, headerSize)\n\tif err != nil {\n\t\treturn nil, 0, 0, err\n\t}\n\tkernNumPairs = int32(u16(buf))\n\n\t// The subtable length from the kern table is only uint16. Fonts like\n\t// Cambria, Calibri or Corbel have more then 10k kerning pairs and the\n\t// actual subtable size is truncated to uint16. Compare size with KERN\n\t// length and truncated size with subtable length.\n\tn := headerSize + entrySize*int(kernNumPairs)\n\tif (length < n) || (subtableLengthU16 != uint16(n)) {\n\t\treturn nil, 0, 0, errInvalidKernTable\n\t}\n\treturn buf, kernNumPairs, int32(offset) + headerSize, nil\n}\n\nfunc (f *Font) parseMaxp(buf []byte, isPostScript bool) (buf1 []byte, numGlyphs int32, err error) {\n\t// https://www.microsoft.com/typography/otspec/maxp.htm\n\n\tif isPostScript {\n\t\tif f.maxp.length != 6 {\n\t\t\treturn nil, 0, errInvalidMaxpTable\n\t\t}\n\t} else {\n\t\tif f.maxp.length != 32 {\n\t\t\treturn nil, 0, errInvalidMaxpTable\n\t\t}\n\t}\n\tu, err := f.src.u16(buf, f.maxp, 4)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\treturn buf, int32(u), nil\n}\n\ntype glyphData struct {\n\t// The glyph data for the i'th glyph index is in\n\t// src[locations[i+0]:locations[i+1]].\n\t//\n\t// The slice length equals 1 plus the number of glyphs.\n\tlocations []uint32\n\n\t// For PostScript fonts, the bytecode for the i'th global or local\n\t// subroutine is in src[x[i+0]:x[i+1]].\n\t//\n\t// The []uint32 slice length equals 1 plus the number of subroutines\n\tgsubrs      []uint32\n\tsingleSubrs []uint32\n\tmultiSubrs  [][]uint32\n\n\tfdSelect fdSelect\n}\n\nfunc (f *Font) parseGlyphData(buf []byte, numGlyphs int32, indexToLocFormat, isPostScript bool) (buf1 []byte, ret glyphData, isColorBitmap bool, err error) {\n\tif isPostScript {\n\t\tp := cffParser{\n\t\t\tsrc:    &f.src,\n\t\t\tbase:   int(f.cff.offset),\n\t\t\toffset: int(f.cff.offset),\n\t\t\tend:    int(f.cff.offset + f.cff.length),\n\t\t}\n\t\tret, err = p.parse(numGlyphs)\n\t\tif err != nil {\n\t\t\treturn nil, glyphData{}, false, err\n\t\t}\n\t} else if f.loca.length != 0 {\n\t\tret.locations, err = parseLoca(&f.src, f.loca, f.glyf.offset, indexToLocFormat, numGlyphs)\n\t\tif err != nil {\n\t\t\treturn nil, glyphData{}, false, err\n\t\t}\n\t} else if f.cblc.length != 0 {\n\t\tisColorBitmap = true\n\t\t// TODO: parse the CBLC (and CBDT) tables. For now, we return a font\n\t\t// with empty glyphs.\n\t\tret.locations = make([]uint32, numGlyphs+1)\n\t}\n\n\tif len(ret.locations) != int(numGlyphs+1) {\n\t\treturn nil, glyphData{}, false, errInvalidLocationData\n\t}\n\n\treturn buf, ret, isColorBitmap, nil\n}\n\nfunc (f *Font) glyphTopOS2(b *Buffer, ppem fixed.Int26_6, r rune) (int32, error) {\n\tind, err := f.GlyphIndex(b, r)\n\tif err != nil && err != ErrNotFound {\n\t\treturn 0, err\n\t} else if ind == 0 {\n\t\treturn 0, nil\n\t}\n\t// Y axis points down\n\tvar min fixed.Int26_6\n\tseg, err := f.LoadGlyph(b, ind, ppem, nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tfor _, s := range seg {\n\t\tfor _, p := range s.Args {\n\t\t\tif p.Y < min {\n\t\t\t\tmin = p.Y\n\t\t\t}\n\t\t}\n\t}\n\treturn int32(min), nil\n}\n\nfunc (f *Font) initOS2Version1() (xHeight, capHeight int32, err error) {\n\tppem := fixed.Int26_6(f.UnitsPerEm())\n\tvar b Buffer\n\n\t// sxHeight equal to the top of the unscaled and unhinted glyph bounding box\n\t// of the glyph encoded at U+0078 (LATIN SMALL LETTER X).\n\txh, err := f.glyphTopOS2(&b, ppem, 'x')\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// sCapHeight may be set equal to the top of the unscaled and unhinted glyph\n\t// bounding box of the glyph encoded at U+0048 (LATIN CAPITAL LETTER H).\n\tch, err := f.glyphTopOS2(&b, ppem, 'H')\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\treturn int32(xh), int32(ch), nil\n}\n\nfunc (f *Font) parseOS2(buf []byte) (buf1 []byte, hasXHeightCapHeight bool, xHeight, capHeight int32, err error) {\n\t// https://docs.microsoft.com/da-dk/typography/opentype/spec/os2\n\n\tif f.os2.length == 0 {\n\t\t// Apple TrueType fonts might omit the OS/2 table.\n\t\treturn buf, false, 0, 0, nil\n\t} else if f.os2.length < 2 {\n\t\treturn nil, false, 0, 0, errInvalidOS2Table\n\t}\n\tvers, err := f.src.u16(buf, f.os2, 0)\n\tif err != nil {\n\t\treturn nil, false, 0, 0, err\n\t}\n\tif vers <= 1 {\n\t\tconst headerSize = 86\n\t\tif f.os2.length < headerSize {\n\t\t\treturn nil, false, 0, 0, errInvalidOS2Table\n\t\t}\n\t\t// Will resolve xHeight and capHeight later, see initOS2Version1.\n\t\treturn buf, false, 0, 0, nil\n\t}\n\tconst headerSize = 96\n\tif f.os2.length < headerSize {\n\t\treturn nil, false, 0, 0, errInvalidOS2Table\n\t}\n\txh, err := f.src.u16(buf, f.os2, 86)\n\tif err != nil {\n\t\treturn nil, false, 0, 0, err\n\t}\n\tch, err := f.src.u16(buf, f.os2, 88)\n\tif err != nil {\n\t\treturn nil, false, 0, 0, err\n\t}\n\treturn buf, true, int32(int16(xh)), int32(int16(ch)), nil\n}\n\n// PostTable represents an information stored in the PostScript font section.\ntype PostTable struct {\n\t// Version of the version tag of the \"post\" table.\n\tVersion uint32\n\t// ItalicAngle in counter-clockwise degrees from the vertical. Zero for\n\t// upright text, negative for text that leans to the right (forward).\n\tItalicAngle float64\n\t// UnderlinePosition is the suggested distance of the top of the\n\t// underline from the baseline (negative values indicate below baseline).\n\tUnderlinePosition int16\n\t// Suggested values for the underline thickness.\n\tUnderlineThickness int16\n\t// IsFixedPitch indicates that the font is not proportionally spaced\n\t// (i.e. monospaced).\n\tIsFixedPitch bool\n}\n\n// PostTable returns the information from the font's \"post\" table. It can\n// return nil, if the font doesn't have such a table.\n//\n// See https://docs.microsoft.com/en-us/typography/opentype/spec/post\nfunc (f *Font) PostTable() *PostTable {\n\treturn f.cached.post\n}\n\nfunc (f *Font) parsePost(buf []byte, numGlyphs int32) (buf1 []byte, post *PostTable, err error) {\n\t// https://www.microsoft.com/typography/otspec/post.htm\n\n\tconst headerSize = 32\n\tif f.post.length < headerSize {\n\t\treturn nil, nil, errInvalidPostTable\n\t}\n\tu, err := f.src.u32(buf, f.post, 0)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tswitch u {\n\tcase 0x10000:\n\t\t// No-op.\n\tcase 0x20000:\n\t\tif f.post.length < headerSize+2+2*uint32(numGlyphs) {\n\t\t\treturn nil, nil, errInvalidPostTable\n\t\t}\n\tcase 0x30000:\n\t\t// No-op.\n\tdefault:\n\t\treturn nil, nil, errUnsupportedPostTable\n\t}\n\n\tang, err := f.src.u32(buf, f.post, 4)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tup, err := f.src.u16(buf, f.post, 8)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tut, err := f.src.u16(buf, f.post, 10)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tfp, err := f.src.u32(buf, f.post, 12)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tpost = &PostTable{\n\t\tVersion:            u,\n\t\tItalicAngle:        float64(int32(ang)) / 0x10000,\n\t\tUnderlinePosition:  int16(up),\n\t\tUnderlineThickness: int16(ut),\n\t\tIsFixedPitch:       fp != 0,\n\t}\n\treturn buf, post, nil\n}\n\n// Bounds returns the union of a Font's glyphs' bounds.\n//\n// In the returned Rectangle26_6's (x, y) coordinates, the Y axis increases\n// down.\nfunc (f *Font) Bounds(b *Buffer, ppem fixed.Int26_6, h font.Hinting) (fixed.Rectangle26_6, error) {\n\t// The 0, 3, 2, 1 indices are to flip the Y coordinates. OpenType's Y axis\n\t// increases up. Go's standard graphics libraries' Y axis increases down.\n\tr := fixed.Rectangle26_6{\n\t\tMin: fixed.Point26_6{\n\t\t\tX: +scale(fixed.Int26_6(f.cached.bounds[0])*ppem, f.cached.unitsPerEm),\n\t\t\tY: -scale(fixed.Int26_6(f.cached.bounds[3])*ppem, f.cached.unitsPerEm),\n\t\t},\n\t\tMax: fixed.Point26_6{\n\t\t\tX: +scale(fixed.Int26_6(f.cached.bounds[2])*ppem, f.cached.unitsPerEm),\n\t\t\tY: -scale(fixed.Int26_6(f.cached.bounds[1])*ppem, f.cached.unitsPerEm),\n\t\t},\n\t}\n\tif h == font.HintingFull {\n\t\t// Quantize the Min down and Max up to a whole pixel.\n\t\tr.Min.X = (r.Min.X + 0) &^ 63\n\t\tr.Min.Y = (r.Min.Y + 0) &^ 63\n\t\tr.Max.X = (r.Max.X + 63) &^ 63\n\t\tr.Max.Y = (r.Max.Y + 63) &^ 63\n\t}\n\treturn r, nil\n}\n\n// TODO: API for looking up glyph variants?? For example, some fonts may\n// provide both slashed and dotted zero glyphs ('0'), or regular and 'old\n// style' numerals, and users can direct software to choose a variant.\n\ntype glyphIndexFunc func(f *Font, b *Buffer, r rune) (GlyphIndex, error)\n\n// GlyphIndex returns the glyph index for the given rune.\n//\n// It returns (0, nil) if there is no glyph for r.\n// https://www.microsoft.com/typography/OTSPEC/cmap.htm says that \"Character\n// codes that do not correspond to any glyph in the font should be mapped to\n// glyph index 0. The glyph at this location must be a special glyph\n// representing a missing character, commonly known as .notdef.\"\nfunc (f *Font) GlyphIndex(b *Buffer, r rune) (GlyphIndex, error) {\n\treturn f.cached.glyphIndex(f, b, r)\n}\n\nfunc (f *Font) viewGlyphData(b *Buffer, x GlyphIndex) (buf []byte, offset, length uint32, err error) {\n\txx := int(x)\n\tif f.NumGlyphs() <= xx {\n\t\treturn nil, 0, 0, ErrNotFound\n\t}\n\ti := f.cached.glyphData.locations[xx+0]\n\tj := f.cached.glyphData.locations[xx+1]\n\tif j < i {\n\t\treturn nil, 0, 0, errInvalidGlyphDataLength\n\t}\n\tif j-i > maxGlyphDataLength {\n\t\treturn nil, 0, 0, errUnsupportedGlyphDataLength\n\t}\n\tbuf, err = b.view(&f.src, int(i), int(j-i))\n\treturn buf, i, j - i, err\n}\n\n// LoadGlyphOptions are the options to the Font.LoadGlyph method.\ntype LoadGlyphOptions struct {\n\t// TODO: transform / hinting.\n}\n\n// LoadGlyph returns the vector segments for the x'th glyph. ppem is the number\n// of pixels in 1 em.\n//\n// If b is non-nil, the segments become invalid to use once b is re-used.\n//\n// In the returned Segments' (x, y) coordinates, the Y axis increases down.\n//\n// It returns ErrNotFound if the glyph index is out of range. It returns\n// ErrColoredGlyph if the glyph is not a monochrome vector glyph, such as a\n// colored (bitmap or vector) emoji glyph.\nfunc (f *Font) LoadGlyph(b *Buffer, x GlyphIndex, ppem fixed.Int26_6, opts *LoadGlyphOptions) (Segments, error) {\n\tif b == nil {\n\t\tb = &Buffer{}\n\t}\n\n\tb.segments = b.segments[:0]\n\tif f.cached.isColorBitmap {\n\t\treturn nil, ErrColoredGlyph\n\t}\n\tif f.cached.isPostScript {\n\t\tbuf, offset, length, err := f.viewGlyphData(b, x)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tb.psi.type2Charstrings.initialize(f, b, x)\n\t\tif err := b.psi.run(psContextType2Charstring, buf, offset, length); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !b.psi.type2Charstrings.ended {\n\t\t\treturn nil, errInvalidCFFTable\n\t\t}\n\t} else if err := loadGlyf(f, b, x, 0, 0); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Scale the segments. If we want to support hinting, we'll have to push\n\t// the scaling computation into the PostScript / TrueType specific glyph\n\t// loading code, such as the appendGlyfSegments body, since TrueType\n\t// hinting bytecode works on the scaled glyph vectors. For now, though,\n\t// it's simpler to scale as a post-processing step.\n\t//\n\t// We also flip the Y coordinates. OpenType's Y axis increases up. Go's\n\t// standard graphics libraries' Y axis increases down.\n\tfor i := range b.segments {\n\t\ta := &b.segments[i].Args\n\t\tfor j := range a {\n\t\t\ta[j].X = +scale(a[j].X*ppem, f.cached.unitsPerEm)\n\t\t\ta[j].Y = -scale(a[j].Y*ppem, f.cached.unitsPerEm)\n\t\t}\n\t}\n\n\t// TODO: look at opts to transform / hint the Buffer.segments.\n\n\treturn b.segments, nil\n}\n\nfunc (f *Font) glyphNameFormat10(x GlyphIndex) (string, error) {\n\tif x >= numBuiltInPostNames {\n\t\treturn \"\", ErrNotFound\n\t}\n\t// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6post.html\n\ti := builtInPostNamesOffsets[x+0]\n\tj := builtInPostNamesOffsets[x+1]\n\treturn builtInPostNamesData[i:j], nil\n}\n\nfunc (f *Font) glyphNameFormat20(b *Buffer, x GlyphIndex) (string, error) {\n\tif b == nil {\n\t\tb = &Buffer{}\n\t}\n\t// The wire format for a Version 2 post table is documented at:\n\t// https://www.microsoft.com/typography/otspec/post.htm\n\tconst glyphNameIndexOffset = 34\n\n\tbuf, err := b.view(&f.src, int(f.post.offset)+glyphNameIndexOffset+2*int(x), 2)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tu := u16(buf)\n\tif u < numBuiltInPostNames {\n\t\ti := builtInPostNamesOffsets[u+0]\n\t\tj := builtInPostNamesOffsets[u+1]\n\t\treturn builtInPostNamesData[i:j], nil\n\t}\n\t// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6post.html\n\t// says that \"32768 through 65535 are reserved for future use\".\n\tif u > 32767 {\n\t\treturn \"\", errUnsupportedPostTable\n\t}\n\tu -= numBuiltInPostNames\n\n\t// Iterate through the list of Pascal-formatted strings. A linear scan is\n\t// clearly O(u), which isn't great (as the obvious loop, calling\n\t// Font.GlyphName, to get all of the glyph names in a font has quadratic\n\t// complexity), but the wire format doesn't suggest a better alternative.\n\n\toffset := glyphNameIndexOffset + 2*f.NumGlyphs()\n\tbuf, err = b.view(&f.src, int(f.post.offset)+offset, int(f.post.length)-offset)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor {\n\t\tif len(buf) == 0 {\n\t\t\treturn \"\", errInvalidPostTable\n\t\t}\n\t\tn := 1 + int(buf[0])\n\t\tif len(buf) < n {\n\t\t\treturn \"\", errInvalidPostTable\n\t\t}\n\t\tif u == 0 {\n\t\t\treturn string(buf[1:n]), nil\n\t\t}\n\t\tbuf = buf[n:]\n\t\tu--\n\t}\n}\n\n// GlyphName returns the name of the x'th glyph.\n//\n// Not every font contains glyph names. If not present, GlyphName will return\n// (\"\", nil).\n//\n// If present, the glyph name, provided by the font, is assumed to follow the\n// Adobe Glyph List Specification:\n// https://github.com/adobe-type-tools/agl-specification/blob/master/README.md\n//\n// This is also known as the \"Adobe Glyph Naming convention\", the \"Adobe\n// document [for] Unicode and Glyph Names\" or \"PostScript glyph names\".\n//\n// It returns ErrNotFound if the glyph index is out of range.\nfunc (f *Font) GlyphName(b *Buffer, x GlyphIndex) (string, error) {\n\tif int(x) >= f.NumGlyphs() {\n\t\treturn \"\", ErrNotFound\n\t}\n\tif f.cached.post == nil {\n\t\treturn \"\", nil\n\t}\n\tswitch f.cached.post.Version {\n\tcase 0x10000:\n\t\treturn f.glyphNameFormat10(x)\n\tcase 0x20000:\n\t\treturn f.glyphNameFormat20(b, x)\n\tdefault:\n\t\treturn \"\", nil\n\t}\n}\n\n// GlyphBounds returns the bounding box of the x'th glyph, drawn at a dot equal\n// to the origin, and that glyph's advance width. ppem is the number of pixels\n// in 1 em.\n//\n// It returns ErrNotFound if the glyph index is out of range.\n//\n// The glyph's ascent and descent are equal to -bounds.Min.Y and +bounds.Max.Y.\n// The glyph's left-side and right-side bearings are equal to bounds.Min.X and\n// advance-bounds.Max.X. A visual depiction of what these metrics are is at\n// https://developer.apple.com/library/archive/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyphterms_2x.png\nfunc (f *Font) GlyphBounds(b *Buffer, x GlyphIndex, ppem fixed.Int26_6, h font.Hinting) (bounds fixed.Rectangle26_6, advance fixed.Int26_6, err error) {\n\tif int(x) >= f.NumGlyphs() {\n\t\treturn fixed.Rectangle26_6{}, 0, ErrNotFound\n\t}\n\tif b == nil {\n\t\tb = &Buffer{}\n\t}\n\n\t// https://www.microsoft.com/typography/OTSPEC/hmtx.htm says that \"As an\n\t// optimization, the number of records can be less than the number of\n\t// glyphs, in which case the advance width value of the last record applies\n\t// to all remaining glyph IDs.\"\n\tmetricIndex := x\n\tif n := GlyphIndex(f.cached.numHMetrics - 1); x > n {\n\t\tmetricIndex = n\n\t}\n\n\tbuf, err := b.view(&f.src, int(f.hmtx.offset)+4*int(metricIndex), 2)\n\tif err != nil {\n\t\treturn fixed.Rectangle26_6{}, 0, err\n\t}\n\tadvance = fixed.Int26_6(u16(buf))\n\tadvance = scale(advance*ppem, f.cached.unitsPerEm)\n\tif h == font.HintingFull {\n\t\t// Quantize the fixed.Int26_6 value to the nearest pixel.\n\t\tadvance = (advance + 32) &^ 63\n\t}\n\n\t// Ignore the hmtx LSB entries and the glyf bounding boxes. Instead, always\n\t// calculate bounds from the segments. OpenType does contain the bounds for\n\t// each glyph in the glyf table, but the bounds are not available for\n\t// compound glyphs. CFF/PostScript also have no explicit bounds and must be\n\t// obtained from the segments.\n\n\tsegments, err := f.LoadGlyph(b, x, ppem, &LoadGlyphOptions{\n\t\t// TODO: pass h, the font.Hinting.\n\t})\n\tif err != nil {\n\t\treturn fixed.Rectangle26_6{}, 0, err\n\t}\n\treturn segments.Bounds(), advance, nil\n}\n\n// GlyphAdvance returns the advance width for the x'th glyph. ppem is the\n// number of pixels in 1 em.\n//\n// It returns ErrNotFound if the glyph index is out of range.\nfunc (f *Font) GlyphAdvance(b *Buffer, x GlyphIndex, ppem fixed.Int26_6, h font.Hinting) (fixed.Int26_6, error) {\n\tif int(x) >= f.NumGlyphs() {\n\t\treturn 0, ErrNotFound\n\t}\n\tif b == nil {\n\t\tb = &Buffer{}\n\t}\n\n\t// https://www.microsoft.com/typography/OTSPEC/hmtx.htm says that \"As an\n\t// optimization, the number of records can be less than the number of\n\t// glyphs, in which case the advance width value of the last record applies\n\t// to all remaining glyph IDs.\"\n\tif n := GlyphIndex(f.cached.numHMetrics - 1); x > n {\n\t\tx = n\n\t}\n\n\tbuf, err := b.view(&f.src, int(f.hmtx.offset)+4*int(x), 2)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tadv := fixed.Int26_6(u16(buf))\n\tadv = scale(adv*ppem, f.cached.unitsPerEm)\n\tif h == font.HintingFull {\n\t\t// Quantize the fixed.Int26_6 value to the nearest pixel.\n\t\tadv = (adv + 32) &^ 63\n\t}\n\treturn adv, nil\n}\n\n// Kern returns the horizontal adjustment for the kerning pair (x0, x1). A\n// positive kern means to move the glyphs further apart. ppem is the number of\n// pixels in 1 em.\n//\n// It returns ErrNotFound if either glyph index is out of range.\nfunc (f *Font) Kern(b *Buffer, x0, x1 GlyphIndex, ppem fixed.Int26_6, h font.Hinting) (fixed.Int26_6, error) {\n\n\t// Use GPOS kern tables if available.\n\tif f.cached.kernFuncs != nil {\n\t\tfor _, kf := range f.cached.kernFuncs {\n\t\t\tadv, err := kf(x0, x1)\n\t\t\tif err == ErrNotFound {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tkern := fixed.Int26_6(adv)\n\t\t\tkern = scale(kern*ppem, f.cached.unitsPerEm)\n\t\t\tif h == font.HintingFull {\n\t\t\t\t// Quantize the fixed.Int26_6 value to the nearest pixel.\n\t\t\t\tkern = (kern + 32) &^ 63\n\t\t\t}\n\t\t\treturn kern, nil\n\t\t}\n\t\treturn 0, ErrNotFound\n\t}\n\n\t// Fallback to kern table.\n\n\t// TODO: Convert kern table handling into kernFunc and decide in Parse if\n\t// GPOS or kern should be used.\n\n\tif n := f.NumGlyphs(); int(x0) >= n || int(x1) >= n {\n\t\treturn 0, ErrNotFound\n\t}\n\t// Not every font has a kern table. If it doesn't, or if that table is\n\t// ignored, there's no need to allocate a Buffer.\n\tif f.cached.kernNumPairs == 0 {\n\t\treturn 0, nil\n\t}\n\tif b == nil {\n\t\tb = &Buffer{}\n\t}\n\n\tkey := uint32(x0)<<16 | uint32(x1)\n\tlo, hi := int32(0), f.cached.kernNumPairs\n\tfor lo < hi {\n\t\ti := (lo + hi) / 2\n\n\t\t// TODO: this view call inside the inner loop can lead to many small\n\t\t// reads instead of fewer larger reads, which can be expensive. We\n\t\t// should be able to do better, although we don't want to make (one)\n\t\t// arbitrarily large read. Perhaps we should round up reads to 4K or 8K\n\t\t// chunks. For reference, Arial.ttf's kern table is 5472 bytes.\n\t\t// Times_New_Roman.ttf's kern table is 5220 bytes.\n\t\tconst entrySize = 6\n\t\tbuf, err := b.view(&f.src, int(f.cached.kernOffset+i*entrySize), entrySize)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tk := u32(buf)\n\t\tif k < key {\n\t\t\tlo = i + 1\n\t\t} else if k > key {\n\t\t\thi = i\n\t\t} else {\n\t\t\tkern := fixed.Int26_6(int16(u16(buf[4:])))\n\t\t\tkern = scale(kern*ppem, f.cached.unitsPerEm)\n\t\t\tif h == font.HintingFull {\n\t\t\t\t// Quantize the fixed.Int26_6 value to the nearest pixel.\n\t\t\t\tkern = (kern + 32) &^ 63\n\t\t\t}\n\t\t\treturn kern, nil\n\t\t}\n\t}\n\treturn 0, nil\n}\n\n// Metrics returns the metrics of this font.\nfunc (f *Font) Metrics(b *Buffer, ppem fixed.Int26_6, h font.Hinting) (font.Metrics, error) {\n\tm := font.Metrics{\n\t\tHeight:     scale(fixed.Int26_6(f.cached.ascent-f.cached.descent+f.cached.lineGap)*ppem, f.cached.unitsPerEm),\n\t\tAscent:     +scale(fixed.Int26_6(f.cached.ascent)*ppem, f.cached.unitsPerEm),\n\t\tDescent:    -scale(fixed.Int26_6(f.cached.descent)*ppem, f.cached.unitsPerEm),\n\t\tXHeight:    scale(fixed.Int26_6(f.cached.xHeight)*ppem, f.cached.unitsPerEm),\n\t\tCapHeight:  scale(fixed.Int26_6(f.cached.capHeight)*ppem, f.cached.unitsPerEm),\n\t\tCaretSlope: image.Point{X: int(f.cached.slope[0]), Y: int(f.cached.slope[1])},\n\t}\n\tif h == font.HintingFull {\n\t\t// Quantize up to a whole pixel.\n\t\tm.Height = (m.Height + 63) &^ 63\n\t\tm.Ascent = (m.Ascent + 63) &^ 63\n\t\tm.Descent = (m.Descent + 63) &^ 63\n\t\tm.XHeight = (m.XHeight + 63) &^ 63\n\t\tm.CapHeight = (m.CapHeight + 63) &^ 63\n\t}\n\treturn m, nil\n}\n\n// Name returns the name value keyed by the given NameID.\n//\n// It returns ErrNotFound if there is no value for that key.\nfunc (f *Font) Name(b *Buffer, id NameID) (string, error) {\n\tif b == nil {\n\t\tb = &Buffer{}\n\t}\n\n\tconst headerSize, entrySize = 6, 12\n\tif f.name.length < headerSize {\n\t\treturn \"\", errInvalidNameTable\n\t}\n\tbuf, err := b.view(&f.src, int(f.name.offset), headerSize)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnumSubtables := u16(buf[2:])\n\tif f.name.length < headerSize+entrySize*uint32(numSubtables) {\n\t\treturn \"\", errInvalidNameTable\n\t}\n\tstringOffset := u16(buf[4:])\n\n\tseen := false\n\tfor i, n := 0, int(numSubtables); i < n; i++ {\n\t\tbuf, err := b.view(&f.src, int(f.name.offset)+headerSize+entrySize*i, entrySize)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif u16(buf[6:]) != uint16(id) {\n\t\t\tcontinue\n\t\t}\n\t\tseen = true\n\n\t\tvar stringify func([]byte) (string, error)\n\t\tswitch u32(buf) {\n\t\tdefault:\n\t\t\tcontinue\n\t\tcase pidMacintosh<<16 | psidMacintoshRoman:\n\t\t\tstringify = stringifyMacintosh\n\t\tcase pidWindows<<16 | psidWindowsUCS2:\n\t\t\tstringify = stringifyUCS2\n\t\t}\n\n\t\tnameLength := u16(buf[8:])\n\t\tnameOffset := u16(buf[10:])\n\t\tbuf, err = b.view(&f.src, int(f.name.offset)+int(nameOffset)+int(stringOffset), int(nameLength))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn stringify(buf)\n\t}\n\n\tif seen {\n\t\treturn \"\", errUnsupportedPlatformEncoding\n\t}\n\treturn \"\", ErrNotFound\n}\n\nfunc stringifyMacintosh(b []byte) (string, error) {\n\tfor _, c := range b {\n\t\tif c >= 0x80 {\n\t\t\t// b contains some non-ASCII bytes.\n\t\t\ts, _ := charmap.Macintosh.NewDecoder().Bytes(b)\n\t\t\treturn string(s), nil\n\t\t}\n\t}\n\t// b contains only ASCII bytes.\n\treturn string(b), nil\n}\n\nfunc stringifyUCS2(b []byte) (string, error) {\n\tif len(b)&1 != 0 {\n\t\treturn \"\", errInvalidUCS2String\n\t}\n\tr := make([]rune, len(b)/2)\n\tfor i := range r {\n\t\tr[i] = rune(u16(b))\n\t\tb = b[2:]\n\t}\n\treturn string(r), nil\n}\n\n// Buffer holds re-usable buffers that can reduce the total memory allocation\n// of repeated Font method calls.\n//\n// See the Font type's documentation comment for more details.\ntype Buffer struct {\n\t// buf is a byte buffer for when a Font's source is an io.ReaderAt.\n\tbuf []byte\n\t// segments holds glyph vector path segments.\n\tsegments Segments\n\t// compoundStack holds the components of a TrueType compound glyph.\n\tcompoundStack [maxCompoundStackSize]struct {\n\t\tglyphIndex   GlyphIndex\n\t\tdx, dy       int16\n\t\thasTransform bool\n\t\ttransformXX  int16\n\t\ttransformXY  int16\n\t\ttransformYX  int16\n\t\ttransformYY  int16\n\t}\n\t// psi is a PostScript interpreter for when the Font is an OpenType/CFF\n\t// font.\n\tpsi psInterpreter\n}\n\nfunc (b *Buffer) view(src *source, offset, length int) ([]byte, error) {\n\tbuf, err := src.view(b.buf, offset, length)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Only update b.buf if it is safe to re-use buf.\n\tif src.viewBufferWritable() {\n\t\tb.buf = buf\n\t}\n\treturn buf, nil\n}\n\n// Segment is a segment of a vector path.\ntype Segment struct {\n\t// Op is the operator.\n\tOp SegmentOp\n\t// Args is up to three (x, y) coordinates. The Y axis increases down.\n\tArgs [3]fixed.Point26_6\n}\n\n// SegmentOp is a vector path segment's operator.\ntype SegmentOp uint32\n\nconst (\n\tSegmentOpMoveTo SegmentOp = iota\n\tSegmentOpLineTo\n\tSegmentOpQuadTo\n\tSegmentOpCubeTo\n)\n\n// Segments is a slice of Segment.\ntype Segments []Segment\n\n// Bounds returns s' bounding box. It returns an empty rectangle if s is empty.\nfunc (s Segments) Bounds() (bounds fixed.Rectangle26_6) {\n\tif len(s) == 0 {\n\t\treturn fixed.Rectangle26_6{}\n\t}\n\n\tbounds.Min.X = fixed.Int26_6(+(1 << 31) - 1)\n\tbounds.Min.Y = fixed.Int26_6(+(1 << 31) - 1)\n\tbounds.Max.X = fixed.Int26_6(-(1 << 31) + 0)\n\tbounds.Max.Y = fixed.Int26_6(-(1 << 31) + 0)\n\n\tfor _, seg := range s {\n\t\tn := 1\n\t\tswitch seg.Op {\n\t\tcase SegmentOpQuadTo:\n\t\t\tn = 2\n\t\tcase SegmentOpCubeTo:\n\t\t\tn = 3\n\t\t}\n\t\tfor i := 0; i < n; i++ {\n\t\t\tif bounds.Max.X < seg.Args[i].X {\n\t\t\t\tbounds.Max.X = seg.Args[i].X\n\t\t\t}\n\t\t\tif bounds.Min.X > seg.Args[i].X {\n\t\t\t\tbounds.Min.X = seg.Args[i].X\n\t\t\t}\n\t\t\tif bounds.Max.Y < seg.Args[i].Y {\n\t\t\t\tbounds.Max.Y = seg.Args[i].Y\n\t\t\t}\n\t\t\tif bounds.Min.Y > seg.Args[i].Y {\n\t\t\t\tbounds.Min.Y = seg.Args[i].Y\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bounds\n}\n\n// translateArgs applies a translation to args.\nfunc translateArgs(args *[3]fixed.Point26_6, dx, dy fixed.Int26_6) {\n\targs[0].X += dx\n\targs[0].Y += dy\n\targs[1].X += dx\n\targs[1].Y += dy\n\targs[2].X += dx\n\targs[2].Y += dy\n}\n\n// transformArgs applies an affine transformation to args. The t?? arguments\n// are 2.14 fixed point values.\nfunc transformArgs(args *[3]fixed.Point26_6, txx, txy, tyx, tyy int16, dx, dy fixed.Int26_6) {\n\targs[0] = tform(txx, txy, tyx, tyy, dx, dy, args[0])\n\targs[1] = tform(txx, txy, tyx, tyy, dx, dy, args[1])\n\targs[2] = tform(txx, txy, tyx, tyy, dx, dy, args[2])\n}\n\nfunc tform(txx, txy, tyx, tyy int16, dx, dy fixed.Int26_6, p fixed.Point26_6) fixed.Point26_6 {\n\tconst half = 1 << 13\n\treturn fixed.Point26_6{\n\t\tX: dx +\n\t\t\tfixed.Int26_6((int64(p.X)*int64(txx)+half)>>14) +\n\t\t\tfixed.Int26_6((int64(p.Y)*int64(tyx)+half)>>14),\n\t\tY: dy +\n\t\t\tfixed.Int26_6((int64(p.X)*int64(txy)+half)>>14) +\n\t\t\tfixed.Int26_6((int64(p.Y)*int64(tyy)+half)>>14),\n\t}\n}\n
'''

parser = GoParser()
node = parser.parse(code)

print(len(list(data_from_jsonl("./output/raw_data/data_30000.jsonl"))))

print(len(list(data_from_jsonl("./output/raw_data/data_30000.jsonl"))))
