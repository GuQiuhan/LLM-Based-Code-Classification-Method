{"input": "package tfexec\n\nimport (\n\t\"context\"\n\t\"os/exec\"\n\n\ttfjson \"github.com/hashicorp/terraform-json\"\n)\n\n\n\n\nfunc (tf *Terraform) providersSchemaCmd(ctx context.Context, args ...string) *exec.Cmd {\n\tallArgs := []string{\"providers\", \"schema\", \"-json\", \"-no-color\"}\n\tallArgs = append(allArgs, args...)\n\n\treturn tf.buildTerraformCmd(ctx, nil, allArgs...)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providersSchemaCmd(ctx, []string{\"providers\", \"schema\"})\n}"}
{"input": "package tfexec\n\nimport (\n\t\"context\"\n\t\"os/exec\"\n\n\ttfjson \"github.com/hashicorp/terraform-json\"\n)\n\n\n\n\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tcmd := exec.Command(tf.config.ProviderSchemasPath)\n\tcmd.Env = tf.config.Env\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath\n\treturn cmd, nil\n}"}
{"input": "package tfexec\n\nimport (\n\t\"context\"\n\t\"os/exec\"\n\n\ttfjson \"github.com/hashicorp/terraform-json\"\n)\n\n\n\n\nfunc (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tcmd := exec.Command(tf.config.ProviderSchemasPath)\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env = tf.env.Env\n\tcmd.Env.Env\n\tcmd.Env.Env\n\tcmd.Env.Env.Env\n\tcmd.Env.Env.Env\n\tcmd.Env.Env.Env.Env.Env\n\tcmd.Env.Env.Env.Env.Env\n\tcmd.Env.Env.Env.Env.Env.Env.Env.Env\n\tcmd.Env.Env"}
{"input": "func (tf *Terraform) providersSchemaCmd(ctx context.Context, args ...string) *exec.Cmd {\n\tallArgs := []string{\"providers\", \"schema\", \"-json\", \"-no-color\"}\n\tallArgs = append(allArgs, args...)\n\n\treturn tf.buildTerraformCmd(ctx, nil, allArgs...)\n}\nfunc (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providersSchemaCmd(ctx, tf.providersSchemaCmdArgs...)\n}"}
{"input": "\nfunc (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "package tfexec\n\nimport (\n\t\"context\"\n\t\"os/exec\"\n\n\ttfjson \"github.com/hashicorp/terraform-json\"\n)\n\n\n\n\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tcmd := exec.Command(tf.config.ProviderSchemasPath)\n\tcmd.Env = tf.config.Env\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath\n\treturn cmd, nil\n}"}
{"input": "package tfexec\n\nimport (\n\t\"context\"\n\t\"os/exec\"\n\n\ttfjson \"github.com/hashicorp/terraform-json\"\n)\n\n\n\n\nfunc (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tcmd := exec.Command(tf.config.ProviderSchemasPath)\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdin = os.Stdin\n\treturn cmd, nil\n"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\nfunc (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (tf *Terraform) providersSchemaCmd(ctx context.Context, args ...string) *exec.Cmd {\n\tallArgs := []string{\"providers\", \"schema\", \"-json\", \"-no-color\"}\n\tallArgs = append(allArgs, args...)\n\n\treturn tf.buildTerraformCmd(ctx, nil, allArgs...)\n}\nfunc (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providersSchemaCmd(ctx, tf.args...)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\nfunc (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc (s *OSSuite) TearDownTest(c *C) {\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "package tfexec\n\nimport (\n\t\"context\"\n\t\"os/exec\"\n\n\ttfjson \"github.com/hashicorp/terraform-json\"\n)\n\n\n\n\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tcmd := exec.Command(tf.config.ProviderSchemasPath)\n\tcmd.Env = tf.config.Env\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath\n\treturn cmd, nil\n}"}
{"input": "package tfexec\n\nimport (\n\t\"context\"\n\t\"os/exec\"\n\n\ttfjson \"github.com/hashicorp/terraform-json\"\n)\n\n\n\n\nfunc (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tvar res []*tfjson.ProviderSchemas\n\terr := tf.Exec(ctx, \"providerschemas\", func(cmd *exec.Command, args []string) error {\n\t\tif err := tf.validateName(formats); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := tf.validateName(formats); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\n\treturn nil, nil\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\nfunc (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx).Do(func(ctx context.Context) (*tfjson.ProviderSchemas, error) {\n\t\treturn tf.client.ProvidersSchemas(ctx).(*tfjson.ProviderSchemas), nil\n\t})\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc RegisterForServer() error {\n\tfor _, c := range components {\n\t\tif err := c.registerForServer(); err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\tret := tf.ctrl.Call(ctx, \"ProvidersSchema\", tf.Name, tf.Name)\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\tvar ret *tfjson.ProviderSchemas\n\tret0, _ := tf.ctrl.Call(tf, \"ProvidersSchema\", ctx, tfjson.DefaultProviderSchemas)\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc CleanDatabase(db *sql.DB) (err error) {\n\n\ttables := []string{\"team\", \"advisory\", \"captured_flag\", \"flag\",\n\t\t\"service\", \"status\", \"round\", \"round_result\"}\n\n\tfor _, table := range tables {\n\n\t\t_, err = db.Exec(\"DELETE FROM \" + table)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = db.Exec(\"ALTER SEQUENCE \" + table + \"_id_seq RESTART WITH 1;\")\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc CleanDatabase(db *sql.DB) (err error) {\n\n\ttables := []string{\"team\", \"advisory\", \"captured_flag\", \"flag\",\n\t\t\"service\", \"status\", \"round\", \"round_result\"}\n\n\tfor _, table := range tables {\n\n\t\t_, err = db.Exec(\"DELETE FROM \" + table)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = db.Exec(\"ALTER SEQUENCE \" + table + \"_id_seq RESTART WITH 1;\")\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\tproviderSchemas := tfjson.ProviderSchemas{}\n\n\terr := tf.db.Exec(\"SELECT * FROM \" + tf.DBName + \" WHERE team =? AND advisory =?\", tf.DBName + \" WHERE flag =?\", tf.DBName + \" WHERE service =?\", tf.DBName + \" WHERE round_result =?\", tf.DBName + \" WHERE round_result =?\", tf.DBName + \" WHERE round_result =?\", tf.RoundResult)\n\n\treturn tfjson.ProviderSchemas{\n\t\tProviders: providers,\n\t}, nil\n}"}
{"input": "func (tf *Terraform) providersSchemaCmd(ctx context.Context, args ...string) *exec.Cmd {\n\tallArgs := []string{\"providers\", \"schema\", \"-json\", \"-no-color\"}\n\tallArgs = append(allArgs, args...)\n\n\treturn tf.buildTerraformCmd(ctx, nil, allArgs...)\n}\nfunc (f LimitFilter) Source() interface{} {\n    \n    \n    \n    \n    \n    source := make(map[string]interface{})\n    params := make(map[string]interface{})\n    source[\"limit\"] = params\n    params[\"value\"] = f.limit\n    return source\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n    \n    \n    \n    providerSchemas := tfjson.ProviderSchemas{}\n\n    err := tf.providerSchemas.Validate(ctx, &providerSchemas)\n\n    if err!= nil {\n        return nil, err\n    }\n\n    return providerSchemas, nil\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc (f LimitFilter) Source() interface{} {\n    \n    \n    \n    \n    \n    source := make(map[string]interface{})\n    params := make(map[string]interface{})\n    source[\"limit\"] = params\n    params[\"value\"] = f.limit\n    return source\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n    \n    \n    \n    providerSchemas := tf.client.ProvidersSchemas()\n    err := tf.client.ProvidersSchema(ctx, tf.config.ProviderSchemas)\n    if err!= nil {\n        return nil, err\n    }\n    return providerSchemas, nil\n}"}
{"input": "\nfunc (e cpiError) OkToRetry() bool {\n\treturn e.cmdError.OkToRetry\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (i *IngestsMethod) List() (*IngestsS, error) {\n\trel := \"ingests\"\n\n\tingests := new(IngestsS)\n\t_, err := i.client.Get(rel, ingests)\n\treturn ingests, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc (i *IngestsMethod) List() (*IngestsS, error) {\n\trel := \"ingests\"\n\n\tingests := new(IngestsS)\n\t_, err := i.client.Get(rel, ingests)\n\treturn ingests, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\nfunc (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.pltr().ProvidersSchema()\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (s *OSSuite) TearDownTest(c *C) {\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}\nfunc TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc init() {\n\tvar v TriggerType\n\tif _, ok := interface{}(v).(fmt.Stringer); ok {\n\t\t_TriggerTypeNameToValue = map[string]TriggerType{\n\t\t\tinterface{}(TriggerTypeDefault).(fmt.Stringer).String(): TriggerTypeDefault,\n\t\t\tinterface{}(TriggerTypePoll).(fmt.Stringer).String():    TriggerTypePoll,\n\t\t}\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tType: \"default\",\n\t\tType: \"Poll\",\n\t\tSchema: tfjson.NewProviderSchemas(),\n\t}, nil\n}"}
{"input": "package tfexec\n\nimport (\n\t\"context\"\n\t\"os/exec\"\n\n\ttfjson \"github.com/hashicorp/terraform-json\"\n)\n\n\n\n\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tcmd := exec.Command(tf.config.ProviderSchemasPath)\n\tcmd.Env = tf.config.Env\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.Env = tf.config.Env\n\tcmd.Env = tf.config.Env\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath = tf.config.EnvPath\n\tcmd.EnvPath\n\treturn cmd, nil\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc NewBlockingCallingContext(waiter WaitGroup) *BlockingCallingContext {\n\twaiter.Add(1)\n\treturn &BlockingCallingContext{Waiter: waiter}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\nfunc (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\nfunc serverMonitorInit() {\n\tgo startServerMonitor()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvider: &tfjson.ProviderSchemas{\n\t\t\tName: \"chroot\",\n\t\t\tPath: \"../../../config/config.json\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\nfunc RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providers\",\n\t\t\tType: \"application/json\",\n\t\t\tName: \"application/json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func RegisterForServer() error {\n\tfor _, c := range components {\n\t\tif err := c.registerForServer(); err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t}\n\treturn nil\n}\nfunc CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providers\",\n\t\t\tType: \"application/json\",\n\t\t\tName: \"application/json\",\n\t\t},\n\t}, nil\n}"}
{"input": "\nfunc Escape(s string) string {\n\treturn escaper.Replace(s)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.GetProvidersSchema(ctx)\n}"}
{"input": "\nfunc (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\tret := tf.ctrl.Call(ctx, \"ProvidersSchema\", tf.Name, tf.Name)\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (response DeleteStreamPoolResponse) String() string {\n\treturn common.PointerString(response)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tType: \"providerschemas\",\n\t\tType: \"providerschemas\",\n\t\tSchema: tfjson.Schema{\n\t\t\tDiscriminatorParam: \"ip_hash\",\n\t\t\tType: \"ip_hash\",\n\t\t\tType: \"string\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (m *unsupportedContainerManager) Start() error {\n\treturn fmt.Errorf(\"Container Manager is unsupported in this build\")\n}\nfunc CleanDatabase(db *sql.DB) (err error) {\n\n\ttables := []string{\"team\", \"advisory\", \"captured_flag\", \"flag\",\n\t\t\"service\", \"status\", \"round\", \"round_result\"}\n\n\tfor _, table := range tables {\n\n\t\t_, err = db.Exec(\"DELETE FROM \" + table)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = db.Exec(\"ALTER SEQUENCE \" + table + \"_id_seq RESTART WITH 1;\")\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tfjson.ProvidersSchema{\n\t\tProvider: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc (m *unsupportedContainerManager) Start() error {\n\treturn fmt.Errorf(\"Container Manager is unsupported in this build\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (e *AmbiguousResourceError) Error() string {\n\tswitch {\n\tcase len(e.MatchingKinds) > 0 && len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v and kinds %v\", e.PartialResource, e.MatchingResources, e.MatchingKinds)\n\tcase len(e.MatchingKinds) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple kinds %v\", e.PartialResource, e.MatchingKinds)\n\tcase len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v\", e.PartialResource, e.MatchingResources)\n\n\t}\n\n\treturn fmt.Sprintf(\"%v matches multiple resources or kinds\", e.PartialResource)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.Config())\n}"}
{"input": "func CleanDatabase(db *sql.DB) (err error) {\n\n\ttables := []string{\"team\", \"advisory\", \"captured_flag\", \"flag\",\n\t\t\"service\", \"status\", \"round\", \"round_result\"}\n\n\tfor _, table := range tables {\n\n\t\t_, err = db.Exec(\"DELETE FROM \" + table)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = db.Exec(\"ALTER SEQUENCE \" + table + \"_id_seq RESTART WITH 1;\")\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\nfunc (e *AmbiguousResourceError) Error() string {\n\tswitch {\n\tcase len(e.MatchingKinds) > 0 && len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v and kinds %v\", e.PartialResource, e.MatchingResources, e.MatchingKinds)\n\tcase len(e.MatchingKinds) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple kinds %v\", e.PartialResource, e.MatchingKinds)\n\tcase len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v\", e.PartialResource, e.MatchingResources)\n\n\t}\n\n\treturn fmt.Sprintf(\"%v matches multiple resources or kinds\", e.PartialResource)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\tschemas := tfjson.ProviderSchemas{}\n\n\terr := tf.db.Exec(\"SELECT * FROM \" + tf.Table)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn schemas, nil\n}"}
{"input": "func (tf *Terraform) providersSchemaCmd(ctx context.Context, args ...string) *exec.Cmd {\n\tallArgs := []string{\"providers\", \"schema\", \"-json\", \"-no-color\"}\n\tallArgs = append(allArgs, args...)\n\n\treturn tf.buildTerraformCmd(ctx, nil, allArgs...)\n}\nfunc TestValidationFactory_New(t *testing.T) {\n\tfactory := &token.ValidationFactory{}\n\tplugin := factory.New()\n\tassert.NotNil(t, plugin)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providersSchemaCmd(ctx, tf.providersSchemaCmdArgs...)\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc TestCreateBucketsIfNeededUsersBucketError(t *testing.T) {\n\ttx := new(txMock)\n\ttx.bucketToReject = \"users\"\n\texpectedErrorMsg := \"ERROR >> user bucket creation failed : some error\"\n\n\terr := createBucketsIfNeeded(tx)\n\n\tif err == nil {\n\t\tt.Error(\"expect to have an error, but got nil\")\n\t}\n\n\tif err.Error() != expectedErrorMsg {\n\t\tt.Errorf(\"expect to have an error with text %s, but got %s\", expectedErrorMsg, err.Error())\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc NewContainerManager(_ string, _ libdocker.Interface) ContainerManager {\n\treturn &unsupportedContainerManager{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "func (e cpiError) OkToRetry() bool {\n\treturn e.cmdError.OkToRetry\n}\nfunc NewContainerManager(_ string, _ libdocker.Interface) ContainerManager {\n\treturn &unsupportedContainerManager{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "\nfunc (k *MockK8sClient) UpdateConfigMap(namespace, configmap string, params map[string]string) (*apiv1.ConfigMap, error) {\n\treturn nil, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (i *IngestsMethod) List() (*IngestsS, error) {\n\trel := \"ingests\"\n\n\tingests := new(IngestsS)\n\t_, err := i.client.Get(rel, ingests)\n\treturn ingests, err\n}\nfunc myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"providerschemas\",\n\t\tType: \"providerschemas\",\n\t\tSchema: tfjson.Schema{\n\t\t\tType: \"providerschemas\",\n\t\t\tName: \"providerschemas\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc (o *ElcomdOptions) HasLogPath() bool {\n\treturn \"\" != o.LogPath\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (i *IngestsMethod) List() (*IngestsS, error) {\n\trel := \"ingests\"\n\n\tingests := new(IngestsS)\n\t_, err := i.client.Get(rel, ingests)\n\treturn ingests, err\n}\nfunc (o *ElcomdOptions) HasLogPath() bool {\n\treturn \"\" != o.LogPath\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (params *AdminParams) ValidateInviteKey(required bool) error { return nil }\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\nfunc (params *AdminParams) ValidateInviteKey(required bool) error { return nil }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\nfunc (p *paramHeader) marshal() ([]byte, error) {\n\tparamLengthPlusHeader := paramHeaderLength + len(p.raw)\n\n\trawParam := make([]byte, paramLengthPlusHeader)\n\tbinary.BigEndian.PutUint16(rawParam[0:], uint16(p.typ))\n\tbinary.BigEndian.PutUint16(rawParam[2:], uint16(paramLengthPlusHeader))\n\tcopy(rawParam[paramHeaderLength:], p.raw)\n\n\treturn rawParam, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\nfunc (p *paramHeader) marshal() ([]byte, error) {\n\tparamLengthPlusHeader := paramHeaderLength + len(p.raw)\n\n\trawParam := make([]byte, paramLengthPlusHeader)\n\tbinary.BigEndian.PutUint16(rawParam[0:], uint16(p.typ))\n\tbinary.BigEndian.PutUint16(rawParam[2:], uint16(paramLengthPlusHeader))\n\tcopy(rawParam[paramHeaderLength:], p.raw)\n\n\treturn rawParam, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.pltr().ProvidersSchema()\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc TestRenderFileSVGIsInImgTag(t *testing.T) {\n\tdefer prepareTestEnv(t)()\n\n\tsession := loginUser(t, \"user2\")\n\n\treq := NewRequest(t, \"GET\", \"/user2/repo2/src/branch/master/line.svg\")\n\tresp := session.MakeRequest(t, req, http.StatusOK)\n\n\tdoc := NewHTMLParser(t, resp.Body)\n\tsrc, exists := doc.doc.Find(\".file-view img\").Attr(\"src\")\n\tassert.True(t, exists, \"The SVG image should be in an <img> tag so that scripts in the SVG are not run\")\n\tassert.Equal(t, \"/user2/repo2/raw/branch/master/line.svg\", src)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\nfunc TestRenderFileSVGIsInImgTag(t *testing.T) {\n\tdefer prepareTestEnv(t)()\n\n\tsession := loginUser(t, \"user2\")\n\n\treq := NewRequest(t, \"GET\", \"/user2/repo2/src/branch/master/line.svg\")\n\tresp := session.MakeRequest(t, req, http.StatusOK)\n\n\tdoc := NewHTMLParser(t, resp.Body)\n\tsrc, exists := doc.doc.Find(\".file-view img\").Attr(\"src\")\n\tassert.True(t, exists, \"The SVG image should be in an <img> tag so that scripts in the SVG are not run\")\n\tassert.Equal(t, \"/user2/repo2/raw/branch/master/line.svg\", src)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.pltr().ProvidersSchema()\n}"}
{"input": "\nfunc parseARPEntries(data []byte) ([]ARPEntry, error) {\n\tlines := strings.Split(string(data), \"\\n\")\n\tentries := make([]ARPEntry, 0)\n\tvar err error\n\tconst (\n\t\texpectedDataWidth   = 6\n\t\texpectedHeaderWidth = 9\n\t)\n\tfor _, line := range lines {\n\t\tcolumns := strings.Fields(line)\n\t\twidth := len(columns)\n\n\t\tif width == expectedHeaderWidth || width == 0 {\n\t\t\tcontinue\n\t\t} else if width == expectedDataWidth {\n\t\t\tentry, err := parseARPEntry(columns)\n\t\t\tif err != nil {\n\t\t\t\treturn []ARPEntry{}, fmt.Errorf(\"failed to parse ARP entry: %s\", err)\n\t\t\t}\n\t\t\tentries = append(entries, entry)\n\t\t} else {\n\t\t\treturn []ARPEntry{}, fmt.Errorf(\"%d columns were detected, but %d were expected\", width, expectedDataWidth)\n\t\t}\n\n\t}\n\n\treturn entries, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tvar err error\n\tvar providerSchemas *tfjson.ProviderSchemas\n\tvar err error\n\tvar err error\n\tvar err error\n\tvar err error\n\tvar err error\n\tvar err error\n\tfor _, line := range strings.Fields(ctx).String() {\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err = tf.validate(ctx, line); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err = tf.validate(ctx, line); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err = tf.validate(ctx, line); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err := tf.validate(ctx, line); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tproviderSchemas = append(providerSchemas, tf.providerSchemas...)\n\t}\n\n\treturn providerSchemas, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (i *DefaultDecorator) ToString(field interface{}) (string, error) {\n\treturn fmt.Sprintf(\"%v\", field), nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{}, nil\n}"}
{"input": "func TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\nfunc (i *DefaultDecorator) ToString(field interface{}) (string, error) {\n\treturn fmt.Sprintf(\"%v\", field), nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (s *OSSuite) TearDownTest(c *C) {\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (s *OSSuite) TearDownTest(c *C) {\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}\nfunc (l *Login) Post(res http.ResponseWriter, req *http.Request, _ httprouter.Params) {\n\tinfo, err := l.Login.ParseBodyInfo(req)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t}\n\terr = l.Authentication.ValidateCredentials(info.Email, info.Password)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t} else {\n\t\tl.Authentication.LogInUser(info.Email, res)\n\t}\n\thttp.Redirect(res, req, \"/admin\", http.StatusFound)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providers\",\n\t\t\tPassword: \"Password\",\n\t\t\tName: \"Email\",\n\t\t\tName: \"Email\",\n\t\t\tName: \"Password\",\n\t\t},\n\t}, nil\n}"}
{"input": "func TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\nfunc (l *Login) Post(res http.ResponseWriter, req *http.Request, _ httprouter.Params) {\n\tinfo, err := l.Login.ParseBodyInfo(req)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t}\n\terr = l.Authentication.ValidateCredentials(info.Email, info.Password)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t} else {\n\t\tl.Authentication.LogInUser(info.Email, res)\n\t}\n\thttp.Redirect(res, req, \"/admin\", http.StatusFound)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providerschemas\",\n\t\t\tPassword: \"password\",\n\t\t},\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestManager(t *testing.T) {\n\tr := &fakereg{}\n\tmgrs := []aspectsupport.Manager{&fakemgr{kind: \"k1\"}, &fakemgr{kind: \"k2\"}}\n\tm := NewManager(r, mgrs)\n\tcfg := &aspectsupport.CombinedConfig{\n\t\tAspect:  &istioconfig.Aspect{},\n\t\tAdapter: &istioconfig.Adapter{},\n\t}\n\tattrs := &fakebag{}\n\tmapper := &fakeevaluator{}\n\tif _, err := m.Execute(cfg, attrs, mapper); err != nil {\n\t\tif !strings.Contains(err.Error(), \"could not find aspect manager\") {\n\t\t\tt.Error(\"excute errored out: \", err)\n\t\t}\n\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func init() {\n\tvar v TriggerType\n\tif _, ok := interface{}(v).(fmt.Stringer); ok {\n\t\t_TriggerTypeNameToValue = map[string]TriggerType{\n\t\t\tinterface{}(TriggerTypeDefault).(fmt.Stringer).String(): TriggerTypeDefault,\n\t\t\tinterface{}(TriggerTypePoll).(fmt.Stringer).String():    TriggerTypePoll,\n\t\t}\n\t}\n}\nfunc TestManager(t *testing.T) {\n\tr := &fakereg{}\n\tmgrs := []aspectsupport.Manager{&fakemgr{kind: \"k1\"}, &fakemgr{kind: \"k2\"}}\n\tm := NewManager(r, mgrs)\n\tcfg := &aspectsupport.CombinedConfig{\n\t\tAspect:  &istioconfig.Aspect{},\n\t\tAdapter: &istioconfig.Adapter{},\n\t}\n\tattrs := &fakebag{}\n\tmapper := &fakeevaluator{}\n\tif _, err := m.Execute(cfg, attrs, mapper); err != nil {\n\t\tif !strings.Contains(err.Error(), \"could not find aspect manager\") {\n\t\t\tt.Error(\"excute errored out: \", err)\n\t\t}\n\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (m *memconn) Close() error {\n\tm.Do(func() {\n\t\tclose(m.chcn)\n\t\tm.done()\n\t})\n\treturn http.ErrServerClosed\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc NewBlockingCallingContext(waiter WaitGroup) *BlockingCallingContext {\n\twaiter.Add(1)\n\treturn &BlockingCallingContext{Waiter: waiter}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func TestUsernamePasswordCredential_InvalidPasswordLive(t *testing.T) {\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, \"invalid password\", &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttk, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif tk != nil {\n\t\tt.Fatal(\"GetToken returned a token\")\n\t}\n\tvar e AuthenticationFailedError\n\tif !errors.As(err, &e) {\n\t\tt.Fatal(\"expected AuthenticationFailedError\")\n\t}\n\tif e.RawResponse == nil {\n\t\tt.Fatal(\"expected a non-nil RawResponse\")\n\t}\n}\nfunc NewBlockingCallingContext(waiter WaitGroup) *BlockingCallingContext {\n\twaiter.Add(1)\n\treturn &BlockingCallingContext{Waiter: waiter}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc TestUsernamePasswordCredential_InvalidPasswordLive(t *testing.T) {\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, \"invalid password\", &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttk, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif tk != nil {\n\t\tt.Fatal(\"GetToken returned a token\")\n\t}\n\tvar e AuthenticationFailedError\n\tif !errors.As(err, &e) {\n\t\tt.Fatal(\"expected AuthenticationFailedError\")\n\t}\n\tif e.RawResponse == nil {\n\t\tt.Fatal(\"expected a non-nil RawResponse\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc handleProfile(w http.ResponseWriter, r *http.Request) {\n\terr := views.Render(\"profile\", w, r)\n\tif err != nil {\n\t\tlog.Println(\"Error rendering dashboard view:\", err)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{}, nil\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc handleProfile(w http.ResponseWriter, r *http.Request) {\n\terr := views.Render(\"profile\", w, r)\n\tif err != nil {\n\t\tlog.Println(\"Error rendering dashboard view:\", err)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tfjson.ProvidersSchemas{}, nil\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc SetFileLabel(path string, label string) error {\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc SetFileLabel(path string, label string) error {\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\nfunc serverMonitorInit() {\n\tgo startServerMonitor()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func ExampleStart_withFlags() {\n\tmode := flag.String(\"profile.mode\", \"\", \"enable profiling mode, one of [cpu, mem, mutex, block]\")\n\tflag.Parse()\n\tswitch *mode {\n\tcase \"cpu\":\n\t\tdefer profile.Start(profile.CPUProfile).Stop()\n\tcase \"mem\":\n\t\tdefer profile.Start(profile.MemProfile).Stop()\n\tcase \"mutex\":\n\t\tdefer profile.Start(profile.MutexProfile).Stop()\n\tcase \"block\":\n\t\tdefer profile.Start(profile.BlockProfile).Stop()\n\tdefault:\n\t}\n}\nfunc serverMonitorInit() {\n\tgo startServerMonitor()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\nfunc ExampleStart_withFlags() {\n\tmode := flag.String(\"profile.mode\", \"\", \"enable profiling mode, one of [cpu, mem, mutex, block]\")\n\tflag.Parse()\n\tswitch *mode {\n\tcase \"cpu\":\n\t\tdefer profile.Start(profile.CPUProfile).Stop()\n\tcase \"mem\":\n\t\tdefer profile.Start(profile.MemProfile).Stop()\n\tcase \"mutex\":\n\t\tdefer profile.Start(profile.MutexProfile).Stop()\n\tcase \"block\":\n\t\tdefer profile.Start(profile.BlockProfile).Stop()\n\tdefault:\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"application/json\",\n\t\tSchema: tfjson.NewProviderSchemas(),\n\t}, nil\n}"}
{"input": "\nfunc indirect(v reflect.Value) reflect.Value {\n\tif v.Kind() == reflect.Ptr && v.Elem().Type() != big_t {\n\t\treturn indirect(v.Elem())\n\t}\n\treturn v\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (v Value) LessThanEq(w Value) bool {\n\tif v == w {\n\t\treturn true\n\t}\n\treturn v.LessThan(w)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\nfunc (v Value) LessThanEq(w Value) bool {\n\tif v == w {\n\t\treturn true\n\t}\n\treturn v.LessThan(w)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvider: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvider: &tfjson.ProviderSchemas{\n\t\t\tName: \"chroot\",\n\t\t\tPath: \"../../../config/config.json\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t},\n\t}, nil\n}"}
{"input": "func langByID(c *bm.Context) {\n\tv := &language.Param{}\n\tif err := c.Bind(v); err != nil {\n\t\treturn\n\t}\n\tc.JSON(langSvc.LangByID(c, v.ID))\n}\nfunc RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\nfunc langByID(c *bm.Context) {\n\tv := &language.Param{}\n\tif err := c.Bind(v); err != nil {\n\t\treturn\n\t}\n\tc.JSON(langSvc.LangByID(c, v.ID))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.JSON(tfjson.ProviderSchemas{\n\t\tName: \"providers\",\n\t\tType: \"JSON\",\n\t\tSchema: tfjson.SchemaSchema{\n\t\t\tName: \"providers\",\n\t\t\tType: \"JSON\",\n\t\t},\n\t})\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (i *Info) SetCommit(commit string) {\n\tif i == nil {\n\t\treturn\n\t}\n\ti.commit = commit\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (i *Info) SetCommit(commit string) {\n\tif i == nil {\n\t\treturn\n\t}\n\ti.commit = commit\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc ExampleNewStringSet() {\n\ta := NewStringSet()\n\ta.Add(\"a\")\n\ta.Add(\"b\")\n\n\tb := NewStringSet(\"b\", \"a\")\n\n\tfmt.Println(a.Equals(b))\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\nfunc ExampleNewStringSet() {\n\ta := NewStringSet()\n\ta.Add(\"a\")\n\ta.Add(\"b\")\n\n\tb := NewStringSet(\"b\", \"a\")\n\n\tfmt.Println(a.Equals(b))\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (km *hashedKeyMutex) UnlockKey(id string) error {\n\tkm.mutexes[km.hash(id)%len(km.mutexes)].Unlock()\n\treturn nil\n}\nfunc CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func RegisterForServer() error {\n\tfor _, c := range components {\n\t\tif err := c.registerForServer(); err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t}\n\treturn nil\n}\nfunc (km *hashedKeyMutex) UnlockKey(id string) error {\n\tkm.mutexes[km.hash(id)%len(km.mutexes)].Unlock()\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc init() {\n\thttp.Handle(\"/view\", appHandler(viewRecord))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func Escape(s string) string {\n\treturn escaper.Replace(s)\n}\nfunc init() {\n\thttp.Handle(\"/view\", appHandler(viewRecord))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc NewCustomLinks(links map[string]string) ([]CustomLink, error) {\n\tcustomLinks := make([]CustomLink, 0, len(links))\n\tfor name, link := range links {\n\t\tif name == \"\" {\n\t\t\treturn nil, errors.New(\"customLink missing key for Name\")\n\t\t}\n\t\tif link == \"\" {\n\t\t\treturn nil, errors.New(\"customLink missing value for URL\")\n\t\t}\n\t\t_, err := url.Parse(link)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcustomLink := CustomLink{\n\t\t\tName: name,\n\t\t\tURL:  link,\n\t\t}\n\t\tcustomLinks = append(customLinks, customLink)\n\t}\n\n\treturn customLinks, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (l SortMapLayersByWeight) Swap(i, j int) { l[i], l[j] = l[j], l[i] }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\nfunc (l SortMapLayersByWeight) Swap(i, j int) { l[i], l[j] = l[j], l[i] }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\tret := tf.ctrl.Call(ctx, \"ProvidersSchema\", tf.Name, tf.Name)\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc (p *pollster) StopWaiting(fd int, bits uint) {\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\treturn tf.ctrl.Call(tf, \"ProvidersSchema\", tf.GetProvidersSchema(), ctx)\n}"}
{"input": "func deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\nfunc (p *pollster) StopWaiting(fd int, bits uint) {\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestSchemaPrimitiveNullCodec(t *testing.T) {\n\ttestSchemaPrimativeCodec(t, `\"null\"`)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc TestSchemaPrimitiveNullCodec(t *testing.T) {\n\ttestSchemaPrimativeCodec(t, `\"null\"`)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\tret := tf.ctrl.Call(tf, \"ProvidersSchema\", ctx)\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc numTrees(n int) int {\n\tdp := make([]int, n + 1)\n\n\tdp[0] = 1\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tdp[i] += dp[j] * dp[i - 1 - j]\n\t\t}\n\t}\n\n\treturn dp[n]\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas := tfjson.ProviderSchemas{}\n\n\terr := tf.client.ProvidersSchema(ctx, tf.config.ProviderSchemas)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn providerSchemas, nil\n}"}
{"input": "func (response DeleteStreamPoolResponse) String() string {\n\treturn common.PointerString(response)\n}\nfunc numTrees(n int) int {\n\tdp := make([]int, n + 1)\n\n\tdp[0] = 1\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tdp[i] += dp[j] * dp[i - 1 - j]\n\t\t}\n\t}\n\n\treturn dp[n]\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\nfunc (data ServerNews) GetBlocks() []*block.Block {\n\tvar blocks []*block.Block\n\tblocks = append(blocks, block.GetBlocks(0x2009, block.Uint32{0})...)\n\tblocks = append(blocks, block.GetBlocks(0x200a, data.News)...)\n\tblocks = append(blocks, block.GetBlocks(0x200b, block.Uint32{0})...)\n\treturn blocks\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func NewService() *SomeService {\n\treturn &SomeService{}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\nfunc NewService() *SomeService {\n\treturn &SomeService{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"IpHashLoadBalancingMethod\",\n\t\tDiscriminatorParam: \"IP_HASH\",\n\t\tType: \"Ip_HASH\",\n\t}, nil\n}"}
{"input": "\nfunc (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func copyTableWithCMEK(projectID, datasetID, tableID string) error {\n\tctx := context.Background()\n\tclient, err := bigquery.NewClient(ctx, projectID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"bigquery.NewClient: %v\", err)\n\t}\n\tdefer client.Close()\n\n\tsrcTable := client.DatasetInProject(\"bigquery-public-data\", \"samples\").Table(\"shakespeare\")\n\tcopier := client.Dataset(datasetID).Table(tableID).CopierFrom(srcTable)\n\tcopier.DestinationEncryptionConfig = &bigquery.EncryptionConfig{\n\t\tKMSKeyName: \"projects/cloud-samples-tests/locations/us-central1/keyRings/test/cryptoKeys/test\",\n\t}\n\tjob, err := copier.Run(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tstatus, err := job.Wait(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := status.Err(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\nfunc (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.ProviderSchemas{\n\t\t\tName: \"providers\",\n\t\t\tType: \"application/json\",\n\t\t\tType: \"application/json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc copyTableWithCMEK(projectID, datasetID, tableID string) error {\n\tctx := context.Background()\n\tclient, err := bigquery.NewClient(ctx, projectID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"bigquery.NewClient: %v\", err)\n\t}\n\tdefer client.Close()\n\n\tsrcTable := client.DatasetInProject(\"bigquery-public-data\", \"samples\").Table(\"shakespeare\")\n\tcopier := client.Dataset(datasetID).Table(tableID).CopierFrom(srcTable)\n\tcopier.DestinationEncryptionConfig = &bigquery.EncryptionConfig{\n\t\tKMSKeyName: \"projects/cloud-samples-tests/locations/us-central1/keyRings/test/cryptoKeys/test\",\n\t}\n\tjob, err := copier.Run(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tstatus, err := job.Wait(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := status.Err(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (m *unsupportedContainerManager) Start() error {\n\treturn fmt.Errorf(\"Container Manager is unsupported in this build\")\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m *unsupportedContainerManager) Start() error {\n\treturn fmt.Errorf(\"Container Manager is unsupported in this build\")\n}\nfunc (s *structCacheMap) Get(key reflect.Type) (*cachedStruct, bool) {\n\ts.lock.RLock()\n\tvalue, ok := s.m[key]\n\ts.lock.RUnlock()\n\treturn value, ok\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func CleanDatabase(db *sql.DB) (err error) {\n\n\ttables := []string{\"team\", \"advisory\", \"captured_flag\", \"flag\",\n\t\t\"service\", \"status\", \"round\", \"round_result\"}\n\n\tfor _, table := range tables {\n\n\t\t_, err = db.Exec(\"DELETE FROM \" + table)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = db.Exec(\"ALTER SEQUENCE \" + table + \"_id_seq RESTART WITH 1;\")\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\nfunc (s *structCacheMap) Get(key reflect.Type) (*cachedStruct, bool) {\n\ts.lock.RLock()\n\tvalue, ok := s.m[key]\n\ts.lock.RUnlock()\n\treturn value, ok\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProviderSchemas)\n}"}
{"input": "\nfunc (m *unsupportedContainerManager) Start() error {\n\treturn fmt.Errorf(\"Container Manager is unsupported in this build\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (e *MilliSecondsEpochTime) UnmarshalJSON(b []byte) error {\n\tvar epoch int64\n\terr := json.Unmarshal(b, &epoch)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*e = MilliSecondsEpochTime{time.Unix(epoch/1000, (epoch%1000)*1000000)}\n\treturn nil\n}\nfunc (m *unsupportedContainerManager) Start() error {\n\treturn fmt.Errorf(\"Container Manager is unsupported in this build\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.GetProvidersSchema(ctx)\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc (e *MilliSecondsEpochTime) UnmarshalJSON(b []byte) error {\n\tvar epoch int64\n\terr := json.Unmarshal(b, &epoch)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*e = MilliSecondsEpochTime{time.Unix(epoch/1000, (epoch%1000)*1000000)}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (response GetMonitorResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (response GetMonitorResponse) String() string {\n\treturn common.PointerString(response)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc init() {\n\tcurrent.BasePath = \"./\"\n\tif len(os.Args) > 1 {\n\t\tcurrent.BasePath = os.Args[1]\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (e *AmbiguousResourceError) Error() string {\n\tswitch {\n\tcase len(e.MatchingKinds) > 0 && len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v and kinds %v\", e.PartialResource, e.MatchingResources, e.MatchingKinds)\n\tcase len(e.MatchingKinds) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple kinds %v\", e.PartialResource, e.MatchingKinds)\n\tcase len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v\", e.PartialResource, e.MatchingResources)\n\n\t}\n\n\treturn fmt.Sprintf(\"%v matches multiple resources or kinds\", e.PartialResource)\n}\nfunc init() {\n\tcurrent.BasePath = \"./\"\n\tif len(os.Args) > 1 {\n\t\tcurrent.BasePath = os.Args[1]\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (e *AmbiguousResourceError) Error() string {\n\tswitch {\n\tcase len(e.MatchingKinds) > 0 && len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v and kinds %v\", e.PartialResource, e.MatchingResources, e.MatchingKinds)\n\tcase len(e.MatchingKinds) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple kinds %v\", e.PartialResource, e.MatchingKinds)\n\tcase len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v\", e.PartialResource, e.MatchingResources)\n\n\t}\n\n\treturn fmt.Sprintf(\"%v matches multiple resources or kinds\", e.PartialResource)\n}\nfunc myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc TestValidationFactory_New(t *testing.T) {\n\tfactory := &token.ValidationFactory{}\n\tplugin := factory.New()\n\tassert.NotNil(t, plugin)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas := tfjson.ProviderSchemas{}\n\treturn providerSchemas, nil\n}"}
{"input": "func (stack *Stack) Push(x interface{}) {\n\t*stack = append(*stack, x)\n}\nfunc TestValidationFactory_New(t *testing.T) {\n\tfactory := &token.ValidationFactory{}\n\tplugin := factory.New()\n\tassert.NotNil(t, plugin)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (tf *Terraform) providersSchemaCmd(ctx context.Context, args ...string) *exec.Cmd {\n\tallArgs := []string{\"providers\", \"schema\", \"-json\", \"-no-color\"}\n\tallArgs = append(allArgs, args...)\n\n\treturn tf.buildTerraformCmd(ctx, nil, allArgs...)\n}\nfunc (stack *Stack) Push(x interface{}) {\n\t*stack = append(*stack, x)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providersSchemaCmd(ctx, tf.providersSchemaCmd, tf.noColor)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (request GetServiceRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc (request GetServiceRequest) String() string {\n\treturn common.PointerString(request)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc upload(c *echo.Context) error {\n\treq := c.Request()\n\treq.ParseMultipartForm(16 << 20) \n\n\tname := c.Form(\"name\")\n\temail := c.Form(\"email\")\n\n\tfiles := req.MultipartForm.File[\"files\"]\n\tfor _, f := range files {\n\t\tsrc, err := f.Open()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer src.Close()\n\n\t\tdst, err := os.Create(f.Filename)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn c.String(http.StatusOK, \"Thank You! %s <%s>, %d files uploaded successfully.\",\n\t\tname, email, len(files))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tName: tf.Form(\"name\"),\n\t\tEmail: tf.Form(\"email\"),\n\t\tProvidersSchema: tfjson.ProvidersSchema{\n\t\t\tName: tf.Form(\"name\"),\n\t\t\tEmail: tf.Form(\"email\"),\n\t\t},\n\t}, nil\n}"}
{"input": "func TestCreateBucketsIfNeededUsersBucketError(t *testing.T) {\n\ttx := new(txMock)\n\ttx.bucketToReject = \"users\"\n\texpectedErrorMsg := \"ERROR >> user bucket creation failed : some error\"\n\n\terr := createBucketsIfNeeded(tx)\n\n\tif err == nil {\n\t\tt.Error(\"expect to have an error, but got nil\")\n\t}\n\n\tif err.Error() != expectedErrorMsg {\n\t\tt.Errorf(\"expect to have an error with text %s, but got %s\", expectedErrorMsg, err.Error())\n\t}\n}\nfunc upload(c *echo.Context) error {\n\treq := c.Request()\n\treq.ParseMultipartForm(16 << 20) \n\n\tname := c.Form(\"name\")\n\temail := c.Form(\"email\")\n\n\tfiles := req.MultipartForm.File[\"files\"]\n\tfor _, f := range files {\n\t\tsrc, err := f.Open()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer src.Close()\n\n\t\tdst, err := os.Create(f.Filename)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn c.String(http.StatusOK, \"Thank You! %s <%s>, %d files uploaded successfully.\",\n\t\tname, email, len(files))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tName: \"users\",\n\t\tEmail: \"email\",\n\t\tProviders: []tfjson.ProviderSchema{\n\t\t\ttfjson.ProviderSchema{\n\t\t\t\tName: \"users\",\n\t\t\t\tEmail: \"email\",\n\t\t\t},\n\t\t\t},\n\t\t}, nil\n}"}
{"input": "\nfunc GetHomeDir() string {\n\treturn homedir.Get()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestSquareOfSum(t *testing.T) {\n\texpected := 3025\n\tactual := SquareOfSum(10)\n\tif expected != actual {\n\t\tt.Errorf(\"expected:%d - actual:%d\", expected, actual)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func NewContainerManager(_ string, _ libdocker.Interface) ContainerManager {\n\treturn &unsupportedContainerManager{}\n}\nfunc TestSquareOfSum(t *testing.T) {\n\texpected := 3025\n\tactual := SquareOfSum(10)\n\tif expected != actual {\n\t\tt.Errorf(\"expected:%d - actual:%d\", expected, actual)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc NewContainerManager(_ string, _ libdocker.Interface) ContainerManager {\n\treturn &unsupportedContainerManager{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "func (up *Upstream) Serve(rw http.ResponseWriter, req *http.Request) {\n\tserver := up.nextServer()\n\tif server == nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tserver.ServeHTTP(rw, req)\n}\nfunc NewContainerManager(_ string, _ libdocker.Interface) ContainerManager {\n\treturn &unsupportedContainerManager{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (e cpiError) OkToRetry() bool {\n\treturn e.cmdError.OkToRetry\n}\nfunc (up *Upstream) Serve(rw http.ResponseWriter, req *http.Request) {\n\tserver := up.nextServer()\n\tif server == nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tserver.ServeHTTP(rw, req)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (registry *pluginRegistry) RegisterUnique(plugin Plugin, ID string) {\n\tif _, exists := registry.plugins[ID]; !exists {\n\t\tregistry.plugins[ID] = plugin\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (k *MockK8sClient) UpdateConfigMap(namespace, configmap string, params map[string]string) (*apiv1.ConfigMap, error) {\n\treturn nil, nil\n}\nfunc (registry *pluginRegistry) RegisterUnique(plugin Plugin, ID string) {\n\tif _, exists := registry.plugins[ID]; !exists {\n\t\tregistry.plugins[ID] = plugin\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tName: \"providers\",\n\t\tConfigMap: tf.ConfigMap,\n\t\tConfigMap: tf.ConfigMap,\n\t\tConfigMapParams: tf.ConfigMapParams,\n\t}, nil\n}"}
{"input": "\nfunc TestMeta(t *testing.T) {\n\ttable := NewTable(\"users\")\n\ttable.SetMeta(\"primary_key\", \"user_id\")\n\tif table.MustGetMeta(\"primary_key\") != \"user_id\" {\n\t\tt.Error(\"expected primary_key meta field to be user_id\")\n\t}\n\n\tif table.meta.Name != \"users\" {\n\t\tt.Error(\"expected table name to be users\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc print_tb(x, y int, fg, bg termbox.Attribute, msg string) {\n\tfor _, c := range msg {\n\t\ttermbox.SetCell(x, y, c, fg, bg)\n\t\tx++\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\nfunc print_tb(x, y int, fg, bg termbox.Attribute, msg string) {\n\tfor _, c := range msg {\n\t\ttermbox.SetCell(x, y, c, fg, bg)\n\t\tx++\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func GetMountTargetSummaryLifecycleStateEnumValues() []MountTargetSummaryLifecycleStateEnum {\n\tvalues := make([]MountTargetSummaryLifecycleStateEnum, 0)\n\tfor _, v := range mappingMountTargetSummaryLifecycleState {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}\nfunc myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (i *IngestsMethod) List() (*IngestsS, error) {\n\trel := \"ingests\"\n\n\tingests := new(IngestsS)\n\t_, err := i.client.Get(rel, ingests)\n\treturn ingests, err\n}\nfunc GetMountTargetSummaryLifecycleStateEnumValues() []MountTargetSummaryLifecycleStateEnum {\n\tvalues := make([]MountTargetSummaryLifecycleStateEnum, 0)\n\tfor _, v := range mappingMountTargetSummaryLifecycleState {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"providerschemas\",\n\t\tSchema: tfjson.NewProviderSchemas(),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func getScopeFromKey(key string) string {\n\ts := strings.SplitN(key, \"/\", 5)\n\tif len(s) != 5 {\n\t\tif len(key) >= 12 {\n\t\t\treturn key[:12]\n\t\t}\n\t\treturn key\n\t}\n\treturn fmt.Sprintf(\"%s/%s\", s[2], s[3])\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc getScopeFromKey(key string) string {\n\ts := strings.SplitN(key, \"/\", 5)\n\tif len(s) != 5 {\n\t\tif len(key) >= 12 {\n\t\t\treturn key[:12]\n\t\t}\n\t\treturn key\n\t}\n\treturn fmt.Sprintf(\"%s/%s\", s[2], s[3])\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc (a *ATMEnvironment3) SetATMManagerIdentification(value string) {\n\ta.ATMManagerIdentification = (*Max35Text)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (o *ElcomdOptions) HasLogPath() bool {\n\treturn \"\" != o.LogPath\n}\nfunc (a *ATMEnvironment3) SetATMManagerIdentification(value string) {\n\ta.ATMManagerIdentification = (*Max35Text)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (i *IngestsMethod) List() (*IngestsS, error) {\n\trel := \"ingests\"\n\n\tingests := new(IngestsS)\n\t_, err := i.client.Get(rel, ingests)\n\treturn ingests, err\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (i *IngestsMethod) List() (*IngestsS, error) {\n\trel := \"ingests\"\n\n\tingests := new(IngestsS)\n\t_, err := i.client.Get(rel, ingests)\n\treturn ingests, err\n}\nfunc (u *UnaryExpression) StartPos() Position {\n\tif u.Postfix {\n\t\treturn u.Expression.StartPos()\n\t}\n\treturn StartPositionFromToken(u.Operator)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas(ctx, tf.client.ProvidersSchemaConfig(ctx))\n}"}
{"input": "func (o *ElcomdOptions) HasLogPath() bool {\n\treturn \"\" != o.LogPath\n}\nfunc (u *UnaryExpression) StartPos() Position {\n\tif u.Postfix {\n\t\treturn u.Expression.StartPos()\n\t}\n\treturn StartPositionFromToken(u.Operator)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc (ind *AvgPriceWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) {\n\n\tresult := (tickData.O() + tickData.H() + tickData.L() + tickData.C()) / float64(4.0)\n\n\tind.UpdateIndicatorWithNewValue(result, streamBarIndex)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tf.GetProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (s *sField) resolveTag() {\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\n\tif s.attr {\n\t\ts.Tag = \"`\" + `xml:\"` + s.Name + `,attr\"` + \"`\"\n\t\treturn\n\t}\n\n\ts.Tag = \"`\" + `xml:\"` + s.Name + `\"` + \"`\"\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (params *AdminParams) ValidateInviteKey(required bool) error { return nil }\nfunc (s *sField) resolveTag() {\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\n\tif s.attr {\n\t\ts.Tag = \"`\" + `xml:\"` + s.Name + `,attr\"` + \"`\"\n\t\treturn\n\t}\n\n\ts.Tag = \"`\" + `xml:\"` + s.Name + `\"` + \"`\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\nfunc (b StringCountList) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (params *AdminParams) ValidateInviteKey(required bool) error { return nil }\nfunc (b StringCountList) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (n networkRouter) Routes() []router.Route {\n\treturn n.routes\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\nfunc (n networkRouter) Routes() []router.Route {\n\treturn n.routes\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc (p *paramHeader) marshal() ([]byte, error) {\n\tparamLengthPlusHeader := paramHeaderLength + len(p.raw)\n\n\trawParam := make([]byte, paramLengthPlusHeader)\n\tbinary.BigEndian.PutUint16(rawParam[0:], uint16(p.typ))\n\tbinary.BigEndian.PutUint16(rawParam[2:], uint16(paramLengthPlusHeader))\n\tcopy(rawParam[paramHeaderLength:], p.raw)\n\n\treturn rawParam, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func BindNetworkArgs(args *NetworkArgs, flags *pflag.FlagSet, prefix string) {\n\tflags.StringVar(&args.NetworkPluginName, prefix+\"network-plugin\", args.NetworkPluginName, \"The name of the networking plugin to be used for networking.\")\n\tflags.StringVar(&args.ClusterNetworkCIDR, prefix+\"network-cidr\", args.ClusterNetworkCIDR, \"The CIDR string representing the network that all containers should belong to.\")\n\tflags.Uint32Var(&args.HostSubnetLength, prefix+\"host-subnet-length\", args.HostSubnetLength, \"The length of subnet each host is given from the network-cidr.\")\n\tflags.StringVar(&args.ServiceNetworkCIDR, prefix+\"portal-net\", args.ServiceNetworkCIDR, \"The CIDR string representing the network that portal/service IPs will be assigned from. This must not overlap with any IP ranges assigned to nodes for pods.\")\n}\nfunc (p *paramHeader) marshal() ([]byte, error) {\n\tparamLengthPlusHeader := paramHeaderLength + len(p.raw)\n\n\trawParam := make([]byte, paramLengthPlusHeader)\n\tbinary.BigEndian.PutUint16(rawParam[0:], uint16(p.typ))\n\tbinary.BigEndian.PutUint16(rawParam[2:], uint16(paramLengthPlusHeader))\n\tcopy(rawParam[paramHeaderLength:], p.raw)\n\n\treturn rawParam, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"network\",\n\t\tType: \"network\",\n\t\tType: \"network\",\n\t\tSchema: tfjson.Schema{\n\t\t\tType: \"network\",\n\t\t\tName: \"network\",\n\t\t\tDescription: \"The name of the network plugin to be used for networking.\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\nfunc BindNetworkArgs(args *NetworkArgs, flags *pflag.FlagSet, prefix string) {\n\tflags.StringVar(&args.NetworkPluginName, prefix+\"network-plugin\", args.NetworkPluginName, \"The name of the networking plugin to be used for networking.\")\n\tflags.StringVar(&args.ClusterNetworkCIDR, prefix+\"network-cidr\", args.ClusterNetworkCIDR, \"The CIDR string representing the network that all containers should belong to.\")\n\tflags.Uint32Var(&args.HostSubnetLength, prefix+\"host-subnet-length\", args.HostSubnetLength, \"The length of subnet each host is given from the network-cidr.\")\n\tflags.StringVar(&args.ServiceNetworkCIDR, prefix+\"portal-net\", args.ServiceNetworkCIDR, \"The CIDR string representing the network that portal/service IPs will be assigned from. This must not overlap with any IP ranges assigned to nodes for pods.\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (p *paramHeader) marshal() ([]byte, error) {\n\tparamLengthPlusHeader := paramHeaderLength + len(p.raw)\n\n\trawParam := make([]byte, paramLengthPlusHeader)\n\tbinary.BigEndian.PutUint16(rawParam[0:], uint16(p.typ))\n\tbinary.BigEndian.PutUint16(rawParam[2:], uint16(paramLengthPlusHeader))\n\tcopy(rawParam[paramHeaderLength:], p.raw)\n\n\treturn rawParam, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (cmd *StopPolicy) Metadata() command_metadata.CommandMetadata {\n\treturn command_metadata.CommandMetadata{\n\t\tName:        \"stop-policy\",\n\t\tDescription: \"Suspends a policy\",\n\t\tUsage:       \"BROOKLYN_NAME SCOPE stop-policy POLICY\",\n\t\tFlags:       []cli.Flag{},\n\t}\n}\nfunc (p *paramHeader) marshal() ([]byte, error) {\n\tparamLengthPlusHeader := paramHeaderLength + len(p.raw)\n\n\trawParam := make([]byte, paramLengthPlusHeader)\n\tbinary.BigEndian.PutUint16(rawParam[0:], uint16(p.typ))\n\tbinary.BigEndian.PutUint16(rawParam[2:], uint16(paramLengthPlusHeader))\n\tcopy(rawParam[paramHeaderLength:], p.raw)\n\n\treturn rawParam, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType:    tf.Type,\n\t\tType:    tf.Type,\n\t\tType:    tf.Type,\n\t\tType:    tf.Type,\n\t\tType:    tf.Type,\n\t\tType:    tf.Type,\n\t\tType:    tf.Type,\n\t\tType:    tf.Type,\n\t\tType:    tf.Type,\n\t\tType:    tf.Type,\n\t\tFlags:       tf.Flags,\n\t}\n}"}
{"input": "func (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\nfunc (cmd *StopPolicy) Metadata() command_metadata.CommandMetadata {\n\treturn command_metadata.CommandMetadata{\n\t\tName:        \"stop-policy\",\n\t\tDescription: \"Suspends a policy\",\n\t\tUsage:       \"BROOKLYN_NAME SCOPE stop-policy POLICY\",\n\t\tFlags:       []cli.Flag{},\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tType:    \"application/json\",\n\t\tSchema: tfjson.Schema{\n\t\t\tType:    \"application/json\",\n\t\t\tName:    \"providers-schema\",\n\t\t\tDescription: \"Schemas schema for the current platform\",\n\t\t\tUsage:       \"Providers schema for the current platform\",\n\t\t\tFlags:       []cli.Flag{},\n\t\t},\n\t}\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func transMatrixFromHPDFTransMatrix(transMatrix C.HPDF_TransMatrix) *TransMatrix {\n\treturn &TransMatrix{\n\t\tfloat32(transMatrix.a),\n\t\tfloat32(transMatrix.b),\n\t\tfloat32(transMatrix.c),\n\t\tfloat32(transMatrix.d),\n\t\tfloat32(transMatrix.x),\n\t\tfloat32(transMatrix.y),\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc transMatrixFromHPDFTransMatrix(transMatrix C.HPDF_TransMatrix) *TransMatrix {\n\treturn &TransMatrix{\n\t\tfloat32(transMatrix.a),\n\t\tfloat32(transMatrix.b),\n\t\tfloat32(transMatrix.c),\n\t\tfloat32(transMatrix.d),\n\t\tfloat32(transMatrix.x),\n\t\tfloat32(transMatrix.y),\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc Serve(addr string, data fs.FS) error {\n\tdata, err := fs.Sub(data, \"docs\")\n\tif err != nil {\n\t\treturn err\n\t}\n\thttp.Handle(\"/\", http.FileServer(http.FS(data)))\n\treturn http.ListenAndServe(addr, logRequest(http.DefaultServeMux))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.pltr().ProvidersSchema()\n}"}
{"input": "func (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\nfunc IsSquare(m Matrix) bool {\n\treturn m.Rows() == m.Columns()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.pltr().ProvidersSchema()\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc filterInLabels(filter, labels map[string]string) bool {\n\tfor k, v := range filter {\n\t\tif value, ok := labels[k]; ok {\n\t\t\tif value != v {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func parseARPEntries(data []byte) ([]ARPEntry, error) {\n\tlines := strings.Split(string(data), \"\\n\")\n\tentries := make([]ARPEntry, 0)\n\tvar err error\n\tconst (\n\t\texpectedDataWidth   = 6\n\t\texpectedHeaderWidth = 9\n\t)\n\tfor _, line := range lines {\n\t\tcolumns := strings.Fields(line)\n\t\twidth := len(columns)\n\n\t\tif width == expectedHeaderWidth || width == 0 {\n\t\t\tcontinue\n\t\t} else if width == expectedDataWidth {\n\t\t\tentry, err := parseARPEntry(columns)\n\t\t\tif err != nil {\n\t\t\t\treturn []ARPEntry{}, fmt.Errorf(\"failed to parse ARP entry: %s\", err)\n\t\t\t}\n\t\t\tentries = append(entries, entry)\n\t\t} else {\n\t\t\treturn []ARPEntry{}, fmt.Errorf(\"%d columns were detected, but %d were expected\", width, expectedDataWidth)\n\t\t}\n\n\t}\n\n\treturn entries, err\n}\nfunc filterInLabels(filter, labels map[string]string) bool {\n\tfor k, v := range filter {\n\t\tif value, ok := labels[k]; ok {\n\t\t\tif value != v {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\nfunc (r *AWSECSService_NetworkConfiguration) DependsOn() []string {\n\treturn r._dependsOn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProvidersSchema(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (msg *RtMsg) Serialize() []byte {\n\treturn (*(*[syscall.SizeofRtMsg]byte)(unsafe.Pointer(msg)))[:]\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (i *DefaultDecorator) ToString(field interface{}) (string, error) {\n\treturn fmt.Sprintf(\"%v\", field), nil\n}\nfunc (msg *RtMsg) Serialize() []byte {\n\treturn (*(*[syscall.SizeofRtMsg]byte)(unsafe.Pointer(msg)))[:]\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\nfunc (s *SettlementStatus10Choice) AddPending() *PendingStatus15Choice {\n\ts.Pending = new(PendingStatus15Choice)\n\treturn s.Pending\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (i *DefaultDecorator) ToString(field interface{}) (string, error) {\n\treturn fmt.Sprintf(\"%v\", field), nil\n}\nfunc (s *SettlementStatus10Choice) AddPending() *PendingStatus15Choice {\n\ts.Pending = new(PendingStatus15Choice)\n\treturn s.Pending\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func main() {\n\tfmt.Println(\"starting server\")\n\thttp.HandleFunc(\"/\", DoRequest)\n\thttp.ListenAndServe(\":9090\", nil)\n\tfmt.Println(\"ending server\")\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (s *OSSuite) TearDownTest(c *C) {\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}\nfunc main() {\n\tfmt.Println(\"starting server\")\n\thttp.HandleFunc(\"/\", DoRequest)\n\thttp.ListenAndServe(\":9090\", nil)\n\tfmt.Println(\"ending server\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tPath: tf.path,\n\t}, nil\n}"}
{"input": "func (s *OSSuite) TearDownTest(c *C) {\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (s *OSSuite) TearDownTest(c *C) {\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}\nfunc IfString(condition bool, trueVal, falseVal string) string {\n\tif condition {\n\t\treturn trueVal\n\t}\n\treturn falseVal\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (l *Login) Post(res http.ResponseWriter, req *http.Request, _ httprouter.Params) {\n\tinfo, err := l.Login.ParseBodyInfo(req)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t}\n\terr = l.Authentication.ValidateCredentials(info.Email, info.Password)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t} else {\n\t\tl.Authentication.LogInUser(info.Email, res)\n\t}\n\thttp.Redirect(res, req, \"/admin\", http.StatusFound)\n}\nfunc IfString(condition bool, trueVal, falseVal string) string {\n\tif condition {\n\t\treturn trueVal\n\t}\n\treturn falseVal\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providerschemas\",\n\t\t\tPassword: \"password\",\n\t\t},\n\t}, nil\n}"}
{"input": "\nfunc (l *Login) Post(res http.ResponseWriter, req *http.Request, _ httprouter.Params) {\n\tinfo, err := l.Login.ParseBodyInfo(req)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t}\n\terr = l.Authentication.ValidateCredentials(info.Email, info.Password)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t} else {\n\t\tl.Authentication.LogInUser(info.Email, res)\n\t}\n\thttp.Redirect(res, req, \"/admin\", http.StatusFound)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providerschemas\",\n\t\t\tPassword: \"password\",\n\t\t\tEmail: \"email\",\n\t\t\tPassword: \"password\",\n\t\t},\n\t}, nil\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc (l *Login) Post(res http.ResponseWriter, req *http.Request, _ httprouter.Params) {\n\tinfo, err := l.Login.ParseBodyInfo(req)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t}\n\terr = l.Authentication.ValidateCredentials(info.Email, info.Password)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t} else {\n\t\tl.Authentication.LogInUser(info.Email, res)\n\t}\n\thttp.Redirect(res, req, \"/admin\", http.StatusFound)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"provider\",\n\t\t\tPassword: \"password\",\n\t\t\tUsername: \"email\",\n\t\t\tPassword: \"password\",\n\t\t},\n\t}, nil\n}"}
{"input": "func TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\nfunc serverMonitorInit() {\n\tgo startServerMonitor()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc (s singularSecretary) CheckHolder(name string) error {\n\tif _, err := names.ParseMachineTag(name); err != nil {\n\t\treturn errors.New(\"expected machine tag\")\n\t}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc Every(duration time.Duration, job cron.Job) {\n\tMainCron.Schedule(cron.Every(duration), New(job))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestManager(t *testing.T) {\n\tr := &fakereg{}\n\tmgrs := []aspectsupport.Manager{&fakemgr{kind: \"k1\"}, &fakemgr{kind: \"k2\"}}\n\tm := NewManager(r, mgrs)\n\tcfg := &aspectsupport.CombinedConfig{\n\t\tAspect:  &istioconfig.Aspect{},\n\t\tAdapter: &istioconfig.Adapter{},\n\t}\n\tattrs := &fakebag{}\n\tmapper := &fakeevaluator{}\n\tif _, err := m.Execute(cfg, attrs, mapper); err != nil {\n\t\tif !strings.Contains(err.Error(), \"could not find aspect manager\") {\n\t\t\tt.Error(\"excute errored out: \", err)\n\t\t}\n\n\t}\n}\nfunc Every(duration time.Duration, job cron.Job) {\n\tMainCron.Schedule(cron.Every(duration), New(job))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProviderSchemas)\n}"}
{"input": "func init() {\n\tvar v TriggerType\n\tif _, ok := interface{}(v).(fmt.Stringer); ok {\n\t\t_TriggerTypeNameToValue = map[string]TriggerType{\n\t\t\tinterface{}(TriggerTypeDefault).(fmt.Stringer).String(): TriggerTypeDefault,\n\t\t\tinterface{}(TriggerTypePoll).(fmt.Stringer).String():    TriggerTypePoll,\n\t\t}\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tType: \"default\",\n\t\tType: \"default\",\n\t\tTypePoll:    \"Poll\",\n\t}, nil\n}"}
{"input": "func init() {\n\tvar v TriggerType\n\tif _, ok := interface{}(v).(fmt.Stringer); ok {\n\t\t_TriggerTypeNameToValue = map[string]TriggerType{\n\t\t\tinterface{}(TriggerTypeDefault).(fmt.Stringer).String(): TriggerTypeDefault,\n\t\t\tinterface{}(TriggerTypePoll).(fmt.Stringer).String():    TriggerTypePoll,\n\t\t}\n\t}\n}\nfunc keyFn(key beam.T, _ func(*int) bool) beam.T {\n\treturn key\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "func TestManager(t *testing.T) {\n\tr := &fakereg{}\n\tmgrs := []aspectsupport.Manager{&fakemgr{kind: \"k1\"}, &fakemgr{kind: \"k2\"}}\n\tm := NewManager(r, mgrs)\n\tcfg := &aspectsupport.CombinedConfig{\n\t\tAspect:  &istioconfig.Aspect{},\n\t\tAdapter: &istioconfig.Adapter{},\n\t}\n\tattrs := &fakebag{}\n\tmapper := &fakeevaluator{}\n\tif _, err := m.Execute(cfg, attrs, mapper); err != nil {\n\t\tif !strings.Contains(err.Error(), \"could not find aspect manager\") {\n\t\t\tt.Error(\"excute errored out: \", err)\n\t\t}\n\n\t}\n}\nfunc keyFn(key beam.T, _ func(*int) bool) beam.T {\n\treturn key\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc BuildSandboxName(metadata *runtimeapi.PodSandboxMetadata) string {\n\treturn fmt.Sprintf(\"%s_%s_%s_%d\", metadata.Name, metadata.Namespace, metadata.Uid, metadata.Attempt)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tName:    tf.Name,\n\t\tNamespace: tf.Namespace,\n\t\tUid: tf.Uid,\n\t\tAttempt: tf.Attempt,\n\t}, nil\n}"}
{"input": "func (m *memconn) Close() error {\n\tm.Do(func() {\n\t\tclose(m.chcn)\n\t\tm.done()\n\t})\n\treturn http.ErrServerClosed\n}\nfunc BuildSandboxName(metadata *runtimeapi.PodSandboxMetadata) string {\n\treturn fmt.Sprintf(\"%s_%s_%s_%d\", metadata.Name, metadata.Namespace, metadata.Uid, metadata.Attempt)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tName:    tf.Name,\n\t\tNamespace:    tf.Namespace,\n\t\tUid:  tf.Uid,\n\t\tAttempt: tf.Attempt,\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (u *UserSignup) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\tif err := utils.ValidatePassword(u.Passwd); err != nil {\n\t\terrs = append(errs, binding.Error{\n\t\t\tFieldNames:     []string{\"passwd\"},\n\t\t\tClassification: \"PasswdError\",\n\t\t\tMessage:        err.Error(),\n\t\t})\n\t}\n\n\tif u.Passwd != u.Confirm {\n\t\terrs = append(errs, binding.Error{\n\t\t\tFieldNames:     []string{\"passwd_confirm\"},\n\t\t\tClassification: \"PasswdConfirmError\",\n\t\t\tMessage:        \"Confirm password is not equal password\",\n\t\t})\n\t}\n\n\treturn errs\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tType:     tfjson.TypeProviderSchemas,\n\t\t\tSchema: tfjson.TypeProviderSchemas,\n\t\t},\n\t}\n}"}
{"input": "func NewBlockingCallingContext(waiter WaitGroup) *BlockingCallingContext {\n\twaiter.Add(1)\n\treturn &BlockingCallingContext{Waiter: waiter}\n}\nfunc (u *UserSignup) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\tif err := utils.ValidatePassword(u.Passwd); err != nil {\n\t\terrs = append(errs, binding.Error{\n\t\t\tFieldNames:     []string{\"passwd\"},\n\t\t\tClassification: \"PasswdError\",\n\t\t\tMessage:        err.Error(),\n\t\t})\n\t}\n\n\tif u.Passwd != u.Confirm {\n\t\terrs = append(errs, binding.Error{\n\t\t\tFieldNames:     []string{\"passwd_confirm\"},\n\t\t\tClassification: \"PasswdConfirmError\",\n\t\t\tMessage:        \"Confirm password is not equal password\",\n\t\t})\n\t}\n\n\treturn errs\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tType:     tfjson.TypeProviderSchemas,\n\t\t\tName:     tf.Name,\n\t\t\tDescription: \"Providers schema for this platform\",\n\t\t},\n\t}, nil\n}"}
{"input": "\nfunc NewBlockingCallingContext(waiter WaitGroup) *BlockingCallingContext {\n\twaiter.Add(1)\n\treturn &BlockingCallingContext{Waiter: waiter}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func getReferences(itr *git.ReferenceIterator) []*git.Reference {\n\tvar ref *git.Reference\n\tvar refs []*git.Reference\n\tvar err error\n\tfor {\n\t\tref, err = itr.Next()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\trefs = append(refs, ref)\n\t}\n\treturn refs\n}\nfunc NewBlockingCallingContext(waiter WaitGroup) *BlockingCallingContext {\n\twaiter.Add(1)\n\treturn &BlockingCallingContext{Waiter: waiter}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tvar providerSchemas tfjson.ProviderSchemas\n\terr := tf.client.ProvidersSchema(ctx, tf.config.ProviderSchemas)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn providerSchemas, nil\n}"}
{"input": "func TestUsernamePasswordCredential_InvalidPasswordLive(t *testing.T) {\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, \"invalid password\", &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttk, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif tk != nil {\n\t\tt.Fatal(\"GetToken returned a token\")\n\t}\n\tvar e AuthenticationFailedError\n\tif !errors.As(err, &e) {\n\t\tt.Fatal(\"expected AuthenticationFailedError\")\n\t}\n\tif e.RawResponse == nil {\n\t\tt.Fatal(\"expected a non-nil RawResponse\")\n\t}\n}\nfunc getReferences(itr *git.ReferenceIterator) []*git.Reference {\n\tvar ref *git.Reference\n\tvar refs []*git.Reference\n\tvar err error\n\tfor {\n\t\tref, err = itr.Next()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\trefs = append(refs, ref)\n\t}\n\treturn refs\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc TestUsernamePasswordCredential_InvalidPasswordLive(t *testing.T) {\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, \"invalid password\", &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttk, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif tk != nil {\n\t\tt.Fatal(\"GetToken returned a token\")\n\t}\n\tvar e AuthenticationFailedError\n\tif !errors.As(err, &e) {\n\t\tt.Fatal(\"expected AuthenticationFailedError\")\n\t}\n\tif e.RawResponse == nil {\n\t\tt.Fatal(\"expected a non-nil RawResponse\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (c *Clientset) Core() unversionedcore.CoreInterface {\n\treturn &fakeunversionedcore.FakeCore{&c.Fake}\n}\nfunc TestUsernamePasswordCredential_InvalidPasswordLive(t *testing.T) {\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, \"invalid password\", &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttk, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif tk != nil {\n\t\tt.Fatal(\"GetToken returned a token\")\n\t}\n\tvar e AuthenticationFailedError\n\tif !errors.As(err, &e) {\n\t\tt.Fatal(\"expected AuthenticationFailedError\")\n\t}\n\tif e.RawResponse == nil {\n\t\tt.Fatal(\"expected a non-nil RawResponse\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc (c *Clientset) Core() unversionedcore.CoreInterface {\n\treturn &fakeunversionedcore.FakeCore{&c.Fake}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tfjson.ProviderSchemas{\n\t\tProvidersSchema: tfjson.NewProviderSchemas(),\n\t}, nil\n}"}
{"input": "\nfunc Load() string {\n\tuptime_in_seconds := uptime_seconds.Load()\n\tuptimeInt, err := strconv.Atoi(uptime_in_seconds)\n\tuptime_in_minutes := (uptimeInt / 60)\n\tif err != nil {\n\t\treturn string(\"\")\n\t}\n\n\treturn strconv.Itoa(uptime_in_minutes)\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestLegacySelect(t *testing.T) {\n\n\tenv := adaptertest.NewEnv(t)\n\n\topts := Options{\n\t\tLegacyEndpoint:   true,\n\t\tBufferPath:       \"\",\n\t\tStagingFileLimit: 10,\n\t\tBaseURL:          &url.URL{},\n\t\tKey:              \"key\",\n\t\tSecret:           \"secret\",\n\t\tClient:           http.DefaultClient,\n\t\tnow:              time.Now,\n\t}\n\n\tm, err := NewManager(env, opts)\n\tm.Close()\n\tif err != nil {\n\t\tt.Fatalf(\"newManager: %s\", err)\n\t}\n\n\tif _, ok := m.(*legacyAnalytics); !ok {\n\t\tt.Errorf(\"want an *legacyAnalytics type, got: %#v\", m)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.Config.ProvidersSchema)\n}"}
{"input": "func handleProfile(w http.ResponseWriter, r *http.Request) {\n\terr := views.Render(\"profile\", w, r)\n\tif err != nil {\n\t\tlog.Println(\"Error rendering dashboard view:\", err)\n\t}\n}\nfunc TestLegacySelect(t *testing.T) {\n\n\tenv := adaptertest.NewEnv(t)\n\n\topts := Options{\n\t\tLegacyEndpoint:   true,\n\t\tBufferPath:       \"\",\n\t\tStagingFileLimit: 10,\n\t\tBaseURL:          &url.URL{},\n\t\tKey:              \"key\",\n\t\tSecret:           \"secret\",\n\t\tClient:           http.DefaultClient,\n\t\tnow:              time.Now,\n\t}\n\n\tm, err := NewManager(env, opts)\n\tm.Close()\n\tif err != nil {\n\t\tt.Fatalf(\"newManager: %s\", err)\n\t}\n\n\tif _, ok := m.(*legacyAnalytics); !ok {\n\t\tt.Errorf(\"want an *legacyAnalytics type, got: %#v\", m)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProvidersSchema: tfjson.ProvidersSchema{\n\t\t\tName: \"profile\",\n\t\t\tType: \"application/json\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc (self *Wind) Type() string {\n\treturn windTypes[self.typeId]\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\tschemas := tfjson.ProviderSchemas{}\n\n\terr := tf.client.ProvidersSchema(ctx, \"schemas\", nil, nil)\n\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn schemas, nil\n}"}
{"input": "func handleProfile(w http.ResponseWriter, r *http.Request) {\n\terr := views.Render(\"profile\", w, r)\n\tif err != nil {\n\t\tlog.Println(\"Error rendering dashboard view:\", err)\n\t}\n}\nfunc (self *Wind) Type() string {\n\treturn windTypes[self.typeId]\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tType: \"profile\",\n\t\tType: \"application/json\",\n\t\tType: \"application/json\",\n\t\tType: \"application/json\",\n\t\tType: \"application/json\",\n\t\tSchema: tfjson.Schema{\n\t\t\tType: \"application/json\",\n\t\t\tType: \"application/json\",\n\t\t},\n\t}\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (lv *PaginatedListView) SetCursor(cursor string) {\n\tlv.cursor = cursor\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc (lv *PaginatedListView) SetCursor(cursor string) {\n\tlv.cursor = cursor\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc SetFileLabel(path string, label string) error {\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func mapFn(elm beam.T) (beam.T, int) {\n\treturn elm, 1\n}\nfunc SetFileLabel(path string, label string) error {\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc mapFn(elm beam.T) (beam.T, int) {\n\treturn elm, 1\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc NewSDK(apiKey string) (sdk SDK) {\n\tvalidateApiKey(apiKey)\n\tconfig := getSDKConfig(apiKey)\n\tsdk = getSDK(config)\n\treturn sdk\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func SetFileLabel(path string, label string) error {\n\treturn nil\n}\nfunc NewSDK(apiKey string) (sdk SDK) {\n\tvalidateApiKey(apiKey)\n\tconfig := getSDKConfig(apiKey)\n\tsdk = getSDK(config)\n\treturn sdk\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestContainer(t *testing.T) {\n\tcontainer()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc TestContainer(t *testing.T) {\n\tcontainer()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc serverMonitorInit() {\n\tgo startServerMonitor()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (t *BasicExampleController) Routes() (http.Handler, error) {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(t.Base(), t.index)\n\trouter.HandleFunc(t.Base()+\"magic\", t.index)\n\treturn router, nil\n}\nfunc serverMonitorInit() {\n\tgo startServerMonitor()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func ExampleStart_withFlags() {\n\tmode := flag.String(\"profile.mode\", \"\", \"enable profiling mode, one of [cpu, mem, mutex, block]\")\n\tflag.Parse()\n\tswitch *mode {\n\tcase \"cpu\":\n\t\tdefer profile.Start(profile.CPUProfile).Stop()\n\tcase \"mem\":\n\t\tdefer profile.Start(profile.MemProfile).Stop()\n\tcase \"mutex\":\n\t\tdefer profile.Start(profile.MutexProfile).Stop()\n\tcase \"block\":\n\t\tdefer profile.Start(profile.BlockProfile).Stop()\n\tdefault:\n\t}\n}\nfunc (t *BasicExampleController) Routes() (http.Handler, error) {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(t.Base(), t.index)\n\trouter.HandleFunc(t.Base()+\"magic\", t.index)\n\treturn router, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "\nfunc ExampleStart_withFlags() {\n\tmode := flag.String(\"profile.mode\", \"\", \"enable profiling mode, one of [cpu, mem, mutex, block]\")\n\tflag.Parse()\n\tswitch *mode {\n\tcase \"cpu\":\n\t\tdefer profile.Start(profile.CPUProfile).Stop()\n\tcase \"mem\":\n\t\tdefer profile.Start(profile.MemProfile).Stop()\n\tcase \"mutex\":\n\t\tdefer profile.Start(profile.MutexProfile).Stop()\n\tcase \"block\":\n\t\tdefer profile.Start(profile.BlockProfile).Stop()\n\tdefault:\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "func (lb logBridge) Write(b []byte) (n int, err error) {\n\tvar text string\n\tif parts := bytes.SplitN(b, []byte{':'}, 3); len(parts) != 3 || len(parts[0]) < 1 || len(parts[2]) < 1 {\n\t\ttext = fmt.Sprintf(\"bad log format: %s\", b)\n\t} else {\n\t\ttext = string(parts[2][1:]) \n\t}\n\n\tswitch severity(lb) {\n\tcase infoLog:\n\t\tgolog.InfoDepth(logDepth, text)\n\tcase warningLog:\n\t\tgolog.WarningDepth(logDepth, text)\n\tcase errorLog:\n\t\tgolog.ErrorDepth(logDepth, text)\n\tcase fatalLog:\n\t\tgolog.FatalDepth(logDepth, text)\n\t}\n\tnotifyAirbrake(logDepth+1, severity(lb), text)\n\n\treturn len(b), nil\n}\nfunc ExampleStart_withFlags() {\n\tmode := flag.String(\"profile.mode\", \"\", \"enable profiling mode, one of [cpu, mem, mutex, block]\")\n\tflag.Parse()\n\tswitch *mode {\n\tcase \"cpu\":\n\t\tdefer profile.Start(profile.CPUProfile).Stop()\n\tcase \"mem\":\n\t\tdefer profile.Start(profile.MemProfile).Stop()\n\tcase \"mutex\":\n\t\tdefer profile.Start(profile.MutexProfile).Stop()\n\tcase \"block\":\n\t\tdefer profile.Start(profile.BlockProfile).Stop()\n\tdefault:\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\nfunc (lb logBridge) Write(b []byte) (n int, err error) {\n\tvar text string\n\tif parts := bytes.SplitN(b, []byte{':'}, 3); len(parts) != 3 || len(parts[0]) < 1 || len(parts[2]) < 1 {\n\t\ttext = fmt.Sprintf(\"bad log format: %s\", b)\n\t} else {\n\t\ttext = string(parts[2][1:]) \n\t}\n\n\tswitch severity(lb) {\n\tcase infoLog:\n\t\tgolog.InfoDepth(logDepth, text)\n\tcase warningLog:\n\t\tgolog.WarningDepth(logDepth, text)\n\tcase errorLog:\n\t\tgolog.ErrorDepth(logDepth, text)\n\tcase fatalLog:\n\t\tgolog.FatalDepth(logDepth, text)\n\t}\n\tnotifyAirbrake(logDepth+1, severity(lb), text)\n\n\treturn len(b), nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc LoadModule(x interface{}) {\n\tmsg.loadModule(x)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func indirect(v reflect.Value) reflect.Value {\n\tif v.Kind() == reflect.Ptr && v.Elem().Type() != big_t {\n\t\treturn indirect(v.Elem())\n\t}\n\treturn v\n}\nfunc LoadModule(x interface{}) {\n\tmsg.loadModule(x)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc (u *UDPServer) read(conn *net.UDPConn, buf []byte, last time.Time) (*ServerMeasure, error) {\n\terr := conn.SetDeadline(time.Now().Add(u.timeout))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"setting deadline for next read, %v\", err)\n\t}\n\n\tn, err := conn.Read(buf)\n\tnow := time.Now()\n\n\tm := &ServerMeasure{now, now.Sub(last), n, buf[:n], err}\n\n\tif err != nil && err != io.EOF {\n\t\treturn m, fmt.Errorf(\"reading, %v\", err)\n\t}\n\n\tif err == io.EOF && !u.gen.HasNext() {\n\t\treturn m, errors.New(\"expected next sequence but got EOF\")\n\t}\n\n\treturn m, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc New(subscriptionID string) ManagementClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (v Value) LessThanEq(w Value) bool {\n\tif v == w {\n\t\treturn true\n\t}\n\treturn v.LessThan(w)\n}\nfunc New(subscriptionID string) ManagementClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\nfunc runClient() {\n\ttime.Sleep(1 * time.Second)\n\tcfg := &sse.Config{\n\t\tURL: \"http://localhost:3000\",\n\t}\n\tclient, err := sse.New(cfg)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tclient.AddListener(\"ts\", func(e sse.Event) {\n\t\tfmt.Printf(\"%+v\\n\", e)\n\t})\n\tclient.AddListener(\"error\", func(e sse.Event) {\n\t\tfmt.Println(\"error \", e)\n\t})\n\tclient.AddListener(\"open\", func(e sse.Event) {\n\t\tfmt.Println(\"open \", e)\n\t})\n\tclient.Connect()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProvider: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (v Value) LessThanEq(w Value) bool {\n\tif v == w {\n\t\treturn true\n\t}\n\treturn v.LessThan(w)\n}\nfunc runClient() {\n\ttime.Sleep(1 * time.Second)\n\tcfg := &sse.Config{\n\t\tURL: \"http://localhost:3000\",\n\t}\n\tclient, err := sse.New(cfg)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tclient.AddListener(\"ts\", func(e sse.Event) {\n\t\tfmt.Printf(\"%+v\\n\", e)\n\t})\n\tclient.AddListener(\"error\", func(e sse.Event) {\n\t\tfmt.Println(\"error \", e)\n\t})\n\tclient.AddListener(\"open\", func(e sse.Event) {\n\t\tfmt.Println(\"open \", e)\n\t})\n\tclient.Connect()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (o *Offset) String() string {\n\treturn (*Size)(o).String()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\nfunc (o *Offset) String() string {\n\treturn (*Size)(o).String()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvider: &tfjson.ProviderSchemas{\n\t\t\tName: \"chroot\",\n\t\t\tPath: \"../../../config/config.json\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t},\n\t}, nil\n}"}
{"input": "func IsIdentity(m Matrix) bool {\n\tmatch := func(element float64, row, column int) bool {\n\t\tif row == column {\n\t\t\treturn element == 1\n\t\t} else {\n\t\t\treturn element == 0\n\t\t}\n\t}\n\n\treturn isSpecialDiagonal(m, match)\n}\nfunc RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func langByID(c *bm.Context) {\n\tv := &language.Param{}\n\tif err := c.Bind(v); err != nil {\n\t\treturn\n\t}\n\tc.JSON(langSvc.LangByID(c, v.ID))\n}\nfunc IsIdentity(m Matrix) bool {\n\tmatch := func(element float64, row, column int) bool {\n\t\tif row == column {\n\t\t\treturn element == 1\n\t\t} else {\n\t\t\treturn element == 0\n\t\t}\n\t}\n\n\treturn isSpecialDiagonal(m, match)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.JSON(tf.JSON(ctx))\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx).Do(func(ctx context.Context) (*tfjson.ProviderSchemas, error) {\n\t\treturn tf.client.ProvidersSchemas(ctx).(*tfjson.ProviderSchemas)\n\t})\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\nfunc TestJSON(t *testing.T) {\n\tcm := New()\n\tfor i := 0; i < 100; i++ {\n\t\tsi := strconv.Itoa(i)\n\t\tcm.Set(si, si)\n\t}\n\n\tj, err := json.Marshal(cm)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar mwj MapWithJSON\n\n\tif err = json.Unmarshal(j, &mwj); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tokeys, nkeys := cm.Keys(), mwj.Keys()\n\n\tsort.Strings(okeys)\n\tsort.Strings(nkeys)\n\n\tif !reflect.DeepEqual(okeys, nkeys) {\n\t\tt.Fatal(\"!reflect.DeepEqual(okeys, nkeys)\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func langByID(c *bm.Context) {\n\tv := &language.Param{}\n\tif err := c.Bind(v); err != nil {\n\t\treturn\n\t}\n\tc.JSON(langSvc.LangByID(c, v.ID))\n}\nfunc TestJSON(t *testing.T) {\n\tcm := New()\n\tfor i := 0; i < 100; i++ {\n\t\tsi := strconv.Itoa(i)\n\t\tcm.Set(si, si)\n\t}\n\n\tj, err := json.Marshal(cm)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar mwj MapWithJSON\n\n\tif err = json.Unmarshal(j, &mwj); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tokeys, nkeys := cm.Keys(), mwj.Keys()\n\n\tsort.Strings(okeys)\n\tsort.Strings(nkeys)\n\n\tif !reflect.DeepEqual(okeys, nkeys) {\n\t\tt.Fatal(\"!reflect.DeepEqual(okeys, nkeys)\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "\nfunc (s *Stack) Clear() {\n\t*s = Stack{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func Example() {\n\tbuffer := SetupBuffer()\n\tdefer buffer.DumpToStdout()\n\n\n\tbuffer.Clear()\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (i *Info) SetCommit(commit string) {\n\tif i == nil {\n\t\treturn\n\t}\n\ti.commit = commit\n}\nfunc Example() {\n\tbuffer := SetupBuffer()\n\tdefer buffer.DumpToStdout()\n\n\n\tbuffer.Clear()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc (i *Info) SetCommit(commit string) {\n\tif i == nil {\n\t\treturn\n\t}\n\ti.commit = commit\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (_m *MockTopologyWatcherInterface) WaitForInitialTopology() error {\n\tret := _m.ctrl.Call(_m, \"WaitForInitialTopology\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc (i *Info) SetCommit(commit string) {\n\tif i == nil {\n\t\treturn\n\t}\n\ti.commit = commit\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tret := tf.ctrl.Call(_tf, \"ProvidersSchema\")\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (_m *MockTopologyWatcherInterface) WaitForInitialTopology() error {\n\tret := _m.ctrl.Call(_m, \"WaitForInitialTopology\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tret := tf.ctrl.Call(ctx, \"ProvidersSchema\")\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func PutReader(c context.Context, path string, r io.Reader) error {\n\treturn FromContext(c).PutReader(path, r)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc PutReader(c context.Context, path string, r io.Reader) error {\n\treturn FromContext(c).PutReader(path, r)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (S) Init() {}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func ExampleNewStringSet() {\n\ta := NewStringSet()\n\ta.Add(\"a\")\n\ta.Add(\"b\")\n\n\tb := NewStringSet(\"b\", \"a\")\n\n\tfmt.Println(a.Equals(b))\n\n}\nfunc (S) Init() {}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\nfunc ReadJsonConfFileServiceTest(t *testing.T) {\n\n\tconfFilename := \"../testdata/fixtures/system.json\"\n\tf, _ := ReadJsonConfFileService(confFilename)\n\n\tif len(f.Files) < 1 {\n\t\tt.Fatal(\"no Files found in \" + confFilename)\n\t}\n\n\tvar actual string = \"\"\n\tfor i := 0; i < len(f.Files); i++ {\n\t\tactual = f.Files[i].Pattern\t\n\t\tbreak\n\t}\n\texpected := \"installed.*\"\n\n\tassert.Equal(t, expected, actual, \"unexpected config pattern\")\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "func ExampleNewStringSet() {\n\ta := NewStringSet()\n\ta.Add(\"a\")\n\ta.Add(\"b\")\n\n\tb := NewStringSet(\"b\", \"a\")\n\n\tfmt.Println(a.Equals(b))\n\n}\nfunc ReadJsonConfFileServiceTest(t *testing.T) {\n\n\tconfFilename := \"../testdata/fixtures/system.json\"\n\tf, _ := ReadJsonConfFileService(confFilename)\n\n\tif len(f.Files) < 1 {\n\t\tt.Fatal(\"no Files found in \" + confFilename)\n\t}\n\n\tvar actual string = \"\"\n\tfor i := 0; i < len(f.Files); i++ {\n\t\tactual = f.Files[i].Pattern\t\n\t\tbreak\n\t}\n\texpected := \"installed.*\"\n\n\tassert.Equal(t, expected, actual, \"unexpected config pattern\")\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc ContextWithTokenManager(ctx context.Context, tm interface{}) context.Context {\n\treturn context.WithValue(ctx, contextTokenManagerKey, tm)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\nfunc ContextWithTokenManager(ctx context.Context, tm interface{}) context.Context {\n\treturn context.WithValue(ctx, contextTokenManagerKey, tm)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas(ctx)\n}"}
{"input": "\nfunc CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (r *LimitRset) Plan(ctx context.Context) (plan.Plan, error) {\n\treturn &plans.LimitDefaultPlan{Count: r.Count, Src: r.Src, Fields: r.Src.GetFields()}, nil\n}\nfunc CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn &tfjson.ProviderSchemas{\n\t\tProviders: tf.Providers,\n\t}, nil\n}"}
{"input": "func (km *hashedKeyMutex) UnlockKey(id string) error {\n\tkm.mutexes[km.hash(id)%len(km.mutexes)].Unlock()\n\treturn nil\n}\nfunc (r *LimitRset) Plan(ctx context.Context) (plan.Plan, error) {\n\treturn &plans.LimitDefaultPlan{Count: r.Count, Src: r.Src, Fields: r.Src.GetFields()}, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviders: tf.Providers,\n\t}, nil\n}"}
{"input": "func RegisterForServer() error {\n\tfor _, c := range components {\n\t\tif err := c.registerForServer(); err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: []tfjson.ProviderSchema{\n\t\t\t{\n\t\t\t\tType:     tfjson.TypeProviderSchemas,\n\t\t\t\tName: \"providers\",\n\t\t\t\tDescription: \"The provider schema for this provider\",\n\t\t\t\tSchema: tfjson.SchemaSchema{\n\t\t\t\t\tName: \"provider\",\n\t\t\t\t\tType:     tfjson.TypeProviderSchemas,\n\t\t\t\t\tType:     tfjson.TypeProviderSchemas,\n\t\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n}"}
{"input": "func RegisterForServer() error {\n\tfor _, c := range components {\n\t\tif err := c.registerForServer(); err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t}\n\treturn nil\n}\nfunc (format *Base64Encode) getEncodedContent(content []byte) []byte {\n\tencodedLen := format.dictionary.EncodedLen(len(content))\n\tencoded := make([]byte, encodedLen)\n\n\tformat.dictionary.Encode(encoded, content)\n\treturn encoded\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (km *hashedKeyMutex) UnlockKey(id string) error {\n\tkm.mutexes[km.hash(id)%len(km.mutexes)].Unlock()\n\treturn nil\n}\nfunc (format *Base64Encode) getEncodedContent(content []byte) []byte {\n\tencodedLen := format.dictionary.EncodedLen(len(content))\n\tencoded := make([]byte, encodedLen)\n\n\tformat.dictionary.Encode(encoded, content)\n\treturn encoded\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.getProvidersSchema(ctx)\n}"}
{"input": "\nfunc (o *GetDebuginfoOK) SetPayload(payload *models.DebugInfo) {\n\to.Payload = payload\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc Version2_12() APIVersion {\n\treturn APIVersion{label: internalAPIVersion2_12, order: 1}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func init() {\n\thttp.Handle(\"/view\", appHandler(viewRecord))\n}\nfunc Version2_12() APIVersion {\n\treturn APIVersion{label: internalAPIVersion2_12, order: 1}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tName: \"providers\",\n\t\tType: \"application/json\",\n\t\tSchema: tfjson.Schema{\n\t\t\tName: \"application/json\",\n\t\t\tDescription: \"API version 2_12\",\n\t\t\tSchema: tfjson.Schema{\n\t\t\t\tName: \"API Version 2_12\",\n\t\t\t\tDescription: \"API Version 2_12\",\n\t\t\t},\n\t\t},\n\t}, nil\n}"}
{"input": "func Escape(s string) string {\n\treturn escaper.Replace(s)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func Escape(s string) string {\n\treturn escaper.Replace(s)\n}\nfunc (o DeleteServerMetadataResponse) String() string {\n\tdata, err := utils.Marshal(o)\n\tif err != nil {\n\t\treturn \"DeleteServerMetadataResponse struct{}\"\n\t}\n\n\treturn strings.Join([]string{\"DeleteServerMetadataResponse\", string(data)}, \" \")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func init() {\n\thttp.Handle(\"/view\", appHandler(viewRecord))\n}\nfunc (o DeleteServerMetadataResponse) String() string {\n\tdata, err := utils.Marshal(o)\n\tif err != nil {\n\t\treturn \"DeleteServerMetadataResponse struct{}\"\n\t}\n\n\treturn strings.Join([]string{\"DeleteServerMetadataResponse\", string(data)}, \" \")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: []*tfjson.ProviderSchema{\n\t\t\t{\n\t\t\t\tType: \"application/json\",\n\t\t\t\tName: \"application/json\",\n\t\t\t\tDescription: \"Application/json\",\n\t\t\t\tDescription: \"Application/json\",\n\t\t\t},\n\t\t\t},\n\t\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc CreateFromFolder(folder string) (d *Design, err error) {\n\td = NewDesign()\n\terr = d.ImportDesignFolder(folder, \"\")\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"in design.CreateFromFolder: \"+folder+\"\\n\")\n\t}\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func NewCustomLinks(links map[string]string) ([]CustomLink, error) {\n\tcustomLinks := make([]CustomLink, 0, len(links))\n\tfor name, link := range links {\n\t\tif name == \"\" {\n\t\t\treturn nil, errors.New(\"customLink missing key for Name\")\n\t\t}\n\t\tif link == \"\" {\n\t\t\treturn nil, errors.New(\"customLink missing value for URL\")\n\t\t}\n\t\t_, err := url.Parse(link)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcustomLink := CustomLink{\n\t\t\tName: name,\n\t\t\tURL:  link,\n\t\t}\n\t\tcustomLinks = append(customLinks, customLink)\n\t}\n\n\treturn customLinks, nil\n}\nfunc CreateFromFolder(folder string) (d *Design, err error) {\n\td = NewDesign()\n\terr = d.ImportDesignFolder(folder, \"\")\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"in design.CreateFromFolder: \"+folder+\"\\n\")\n\t}\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (ft *fakeTicker) Stop() {\n\tft.timer.Stop()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc Ttf(buf []byte) bool {\n\treturn len(buf) > 4 &&\n\t\tbuf[0] == 0x00 && buf[1] == 0x01 &&\n\t\tbuf[2] == 0x00 && buf[3] == 0x00 &&\n\t\tbuf[4] == 0x00\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (l SortMapLayersByWeight) Swap(i, j int) { l[i], l[j] = l[j], l[i] }\nfunc Ttf(buf []byte) bool {\n\treturn len(buf) > 4 &&\n\t\tbuf[0] == 0x00 && buf[1] == 0x01 &&\n\t\tbuf[2] == 0x00 && buf[3] == 0x00 &&\n\t\tbuf[4] == 0x00\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\nfunc setVersionPalette(style string) {\n\tconsole.SetCustomPalette(map[string]*color.Color{\n\t\t\"Version\": color.New(color.FgGreen, color.Bold),\n\t})\n\tif style == \"light\" {\n\t\tconsole.SetCustomPalette(map[string]*color.Color{\n\t\t\t\"Version\": color.New(color.FgWhite, color.Bold),\n\t\t})\n\t\treturn\n\t}\n\tif style == \"nocolor\" {\n\t\tconsole.SetNoColor()\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (l SortMapLayersByWeight) Swap(i, j int) { l[i], l[j] = l[j], l[i] }\nfunc setVersionPalette(style string) {\n\tconsole.SetCustomPalette(map[string]*color.Color{\n\t\t\"Version\": color.New(color.FgGreen, color.Bold),\n\t})\n\tif style == \"light\" {\n\t\tconsole.SetCustomPalette(map[string]*color.Color{\n\t\t\t\"Version\": color.New(color.FgWhite, color.Bold),\n\t\t})\n\t\treturn\n\t}\n\tif style == \"nocolor\" {\n\t\tconsole.SetNoColor()\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func ExampleNewRandom() {\n\tfor i := 0; i < 100; i++ {\n\t\tprintln(i, \":\", NewRandom())\n\t}\n\n\tprintln(\"======================================\")\n\n\tfor i := 0; i < 100; i++ {\n\t\tprintln(i, \":\", NewRangeRandom(1000000))\n\t}\n\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc ExampleNewRandom() {\n\tfor i := 0; i < 100; i++ {\n\t\tprintln(i, \":\", NewRandom())\n\t}\n\n\tprintln(\"======================================\")\n\n\tfor i := 0; i < 100; i++ {\n\t\tprintln(i, \":\", NewRangeRandom(1000000))\n\t}\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\tret := tf.ctrl.Call(tf, \"ProvidersSchema\", ctx)\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "\nfunc (p *pollster) StopWaiting(fd int, bits uint) {\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func outputFunc(in worker.Worker, out interface{}) error {\n\tinWorker, _ := in.(*apiConnWorker)\n\toutPointer, _ := out.(*base.APICaller)\n\tif inWorker == nil || outPointer == nil {\n\t\treturn errors.Errorf(\"expected %T->%T; got %T->%T\", inWorker, outPointer, in, out)\n\t}\n\t*outPointer = inWorker.conn\n\treturn nil\n}\nfunc (p *pollster) StopWaiting(fd int, bits uint) {\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc outputFunc(in worker.Worker, out interface{}) error {\n\tinWorker, _ := in.(*apiConnWorker)\n\toutPointer, _ := out.(*base.APICaller)\n\tif inWorker == nil || outPointer == nil {\n\t\treturn errors.Errorf(\"expected %T->%T; got %T->%T\", inWorker, outPointer, in, out)\n\t}\n\t*outPointer = inWorker.conn\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "\nfunc (p *pollster) StopWaiting(fd int, bits uint) {\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m *OpenpitrixCeaseClustersResponse) UnmarshalBinary(b []byte) error {\n\tvar res OpenpitrixCeaseClustersResponse\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\nfunc (p *pollster) StopWaiting(fd int, bits uint) {\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.GetProvidersSchema(ctx)\n}"}
{"input": "func deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\nfunc (m *OpenpitrixCeaseClustersResponse) UnmarshalBinary(b []byte) error {\n\tvar res OpenpitrixCeaseClustersResponse\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc XORBytes(a, b []byte) ([]byte, error) {\n\tif len(a) != len(b) {\n\t\treturn nil, fmt.Errorf(\"length of byte slices is not equivalent: %d != %d\", len(a), len(b))\n\t}\n\n\tbuf := make([]byte, len(a))\n\n\tfor i, _ := range a {\n\t\tbuf[i] = a[i] ^ b[i]\n\t}\n\n\treturn buf, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (v *styleContext) GetScreen() (gdki.Screen, error) {\n\treturn gdka.WrapScreen(v.internal.GetScreen())\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.internal.ProvidersSchema(ctx)\n}"}
{"input": "func TestSchemaPrimitiveNullCodec(t *testing.T) {\n\ttestSchemaPrimativeCodec(t, `\"null\"`)\n}\nfunc (v *styleContext) GetScreen() (gdki.Screen, error) {\n\treturn gdka.WrapScreen(v.internal.GetScreen())\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.internal.ProvidersSchema(ctx)\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\tret := tf.ctrl.Call(ctx, \"ProvidersSchema\", tf.Name, tf.Name)\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc f(n int) {\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(n, \":\", i)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\tret := tf.ctrl.Call(ctx, \"ProvidersSchema\", tf.Name, tf.Name)\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func TestSchemaPrimitiveNullCodec(t *testing.T) {\n\ttestSchemaPrimativeCodec(t, `\"null\"`)\n}\nfunc f(n int) {\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(n, \":\", i)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (e errBadDependency) Error() string {\n\treturn fmt.Sprintf(\"unresolved dependency: class=%s name=%s\", types.Dependency(e).Class, types.Dependency(e).Name)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (e errBadDependency) Error() string {\n\treturn fmt.Sprintf(\"unresolved dependency: class=%s name=%s\", types.Dependency(e).Class, types.Dependency(e).Name)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (field *FieldDescriptorProto) IsScalar() bool {\n\tif field.Type == nil {\n\t\treturn false\n\t}\n\tswitch *field.Type {\n\tcase FieldDescriptorProto_TYPE_DOUBLE,\n\t\tFieldDescriptorProto_TYPE_FLOAT,\n\t\tFieldDescriptorProto_TYPE_INT64,\n\t\tFieldDescriptorProto_TYPE_UINT64,\n\t\tFieldDescriptorProto_TYPE_INT32,\n\t\tFieldDescriptorProto_TYPE_FIXED64,\n\t\tFieldDescriptorProto_TYPE_FIXED32,\n\t\tFieldDescriptorProto_TYPE_BOOL,\n\t\tFieldDescriptorProto_TYPE_UINT32,\n\t\tFieldDescriptorProto_TYPE_ENUM,\n\t\tFieldDescriptorProto_TYPE_SFIXED32,\n\t\tFieldDescriptorProto_TYPE_SFIXED64,\n\t\tFieldDescriptorProto_TYPE_SINT32,\n\t\tFieldDescriptorProto_TYPE_SINT64:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func numTrees(n int) int {\n\tdp := make([]int, n + 1)\n\n\tdp[0] = 1\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tdp[i] += dp[j] * dp[i - 1 - j]\n\t\t}\n\t}\n\n\treturn dp[n]\n}\nfunc (field *FieldDescriptorProto) IsScalar() bool {\n\tif field.Type == nil {\n\t\treturn false\n\t}\n\tswitch *field.Type {\n\tcase FieldDescriptorProto_TYPE_DOUBLE,\n\t\tFieldDescriptorProto_TYPE_FLOAT,\n\t\tFieldDescriptorProto_TYPE_INT64,\n\t\tFieldDescriptorProto_TYPE_UINT64,\n\t\tFieldDescriptorProto_TYPE_INT32,\n\t\tFieldDescriptorProto_TYPE_FIXED64,\n\t\tFieldDescriptorProto_TYPE_FIXED32,\n\t\tFieldDescriptorProto_TYPE_BOOL,\n\t\tFieldDescriptorProto_TYPE_UINT32,\n\t\tFieldDescriptorProto_TYPE_ENUM,\n\t\tFieldDescriptorProto_TYPE_SFIXED32,\n\t\tFieldDescriptorProto_TYPE_SFIXED64,\n\t\tFieldDescriptorProto_TYPE_SINT32,\n\t\tFieldDescriptorProto_TYPE_SINT64:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (response DeleteStreamPoolResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (response DeleteStreamPoolResponse) String() string {\n\treturn common.PointerString(response)\n}\nfunc (f *singleFactory) New() interface{} {\n\treturn f.v\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.v.ProvidersSchemas(ctx)\n}"}
{"input": "func numTrees(n int) int {\n\tdp := make([]int, n + 1)\n\n\tdp[0] = 1\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tdp[i] += dp[j] * dp[i - 1 - j]\n\t\t}\n\t}\n\n\treturn dp[n]\n}\nfunc (f *singleFactory) New() interface{} {\n\treturn f.v\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (s *Service) RankCard(plat int8) (ranks []*rank.Rank, aids []int64) {\n\tvar limit int\n\tif !model.IsIPad(plat) {\n\t\tlimit = 3\n\t} else {\n\t\tlimit = 4\n\t}\n\tranks = make([]*rank.Rank, 0, limit)\n\taids = make([]int64, 0, limit)\n\tfor _, rank := range s.rankCache {\n\t\tranks = append(ranks, rank)\n\t\taids = append(aids, rank.Aid)\n\t\tif len(ranks) == limit {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (data ServerNews) GetBlocks() []*block.Block {\n\tvar blocks []*block.Block\n\tblocks = append(blocks, block.GetBlocks(0x2009, block.Uint32{0})...)\n\tblocks = append(blocks, block.GetBlocks(0x200a, data.News)...)\n\tblocks = append(blocks, block.GetBlocks(0x200b, block.Uint32{0})...)\n\treturn blocks\n}\nfunc (s *Service) RankCard(plat int8) (ranks []*rank.Rank, aids []int64) {\n\tvar limit int\n\tif !model.IsIPad(plat) {\n\t\tlimit = 3\n\t} else {\n\t\tlimit = 4\n\t}\n\tranks = make([]*rank.Rank, 0, limit)\n\taids = make([]int64, 0, limit)\n\tfor _, rank := range s.rankCache {\n\t\tranks = append(ranks, rank)\n\t\taids = append(aids, rank.Aid)\n\t\tif len(ranks) == limit {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"providerschemas\",\n\t\tSchema: tfjson.NewProviderSchemas(),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (s *sField) resolveTag() {\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\n\tif s.attr {\n\t\ts.Tag = \"`\" + `xml:\"` + s.Name + `,attr\"` + \"`\"\n\t\treturn\n\t}\n\n\ts.Tag = \"`\" + `xml:\"` + s.Name + `\"` + \"`\"\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func NewService() *SomeService {\n\treturn &SomeService{}\n}\nfunc (s *sField) resolveTag() {\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\n\tif s.attr {\n\t\ts.Tag = \"`\" + `xml:\"` + s.Name + `,attr\"` + \"`\"\n\t\treturn\n\t}\n\n\ts.Tag = \"`\" + `xml:\"` + s.Name + `\"` + \"`\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc NewService() *SomeService {\n\treturn &SomeService{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestFileTreeIntegrate(t *testing.T) {\n\texpect := assert.New(t)\n\tfileTree := sftpd.NewFileTree(\"data/fixtures\")\n\texpect.NotNil(fileTree)\n\n}\nfunc NewService() *SomeService {\n\treturn &SomeService{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\nfunc TestFileTreeIntegrate(t *testing.T) {\n\texpect := assert.New(t)\n\tfileTree := sftpd.NewFileTree(\"data/fixtures\")\n\texpect.NotNil(fileTree)\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tType: \"ip_hash\",\n\t\tDiscriminatorParam: \"ip_hash\",\n\t\tType: \"ip_hash\",\n\t\tSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\nfunc (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\nfunc init() {\n\tproviders.AddProvider(\"bing\", &BingProvider{})\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"IpHashLoadBalancingMethod\",\n\t\tDiscriminatorParam: \"ip_hash\",\n\t\tType: \"Ip_HASH\",\n\t\tSchema: tfjson.Schema{\n\t\t\tType: \"Ip_HASH\",\n\t\t\tType: \"Ip_HASH\",\n\t\t},\n\t}, nil\n}"}
{"input": "func init() {\n       supported = true\n}\nfunc copyTableWithCMEK(projectID, datasetID, tableID string) error {\n\tctx := context.Background()\n\tclient, err := bigquery.NewClient(ctx, projectID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"bigquery.NewClient: %v\", err)\n\t}\n\tdefer client.Close()\n\n\tsrcTable := client.DatasetInProject(\"bigquery-public-data\", \"samples\").Table(\"shakespeare\")\n\tcopier := client.Dataset(datasetID).Table(tableID).CopierFrom(srcTable)\n\tcopier.DestinationEncryptionConfig = &bigquery.EncryptionConfig{\n\t\tKMSKeyName: \"projects/cloud-samples-tests/locations/us-central1/keyRings/test/cryptoKeys/test\",\n\t}\n\tjob, err := copier.Run(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tstatus, err := job.Wait(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := status.Err(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc init() {\n       supported = true\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func networkAsChild(arg interface{}) interface{} {\n\tnetwork := arg.(models.Network)\n\treturn networkIdxElem{Network: network}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (m *unsupportedContainerManager) Start() error {\n\treturn fmt.Errorf(\"Container Manager is unsupported in this build\")\n}\nfunc networkAsChild(arg interface{}) interface{} {\n\tnetwork := arg.(models.Network)\n\treturn networkIdxElem{Network: network}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvider: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (s *structCacheMap) Get(key reflect.Type) (*cachedStruct, bool) {\n\ts.lock.RLock()\n\tvalue, ok := s.m[key]\n\ts.lock.RUnlock()\n\treturn value, ok\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ts := tf.Get(ctx)\n\ts.lock.RLock()\n\ts.m = make(map[string]struct{})\n\ts.lock.RUnlock()\n\treturn s, nil\n}"}
{"input": "func UintPtrTo64(ptr interface{}) (value uint64) {\n\tif v := reflect.ValueOf(ptr); v.Kind() == reflect.Ptr {\n\t\tp := v.Elem()\n\t\tswitch p.Kind() {\n\t\tcase reflect.Uint:\n\t\t\tvalue = uint64(*ptr.(*uint))\n\t\tcase reflect.Uint8:\n\t\t\tvalue = uint64(*ptr.(*uint8))\n\t\tcase reflect.Uint16:\n\t\t\tvalue = uint64(*ptr.(*uint16))\n\t\tcase reflect.Uint32:\n\t\t\tvalue = uint64(*ptr.(*uint32))\n\t\tcase reflect.Uint64:\n\t\t\tvalue = *ptr.(*uint64)\n\t\t}\n\t}\n\treturn\n}\nfunc (s *structCacheMap) Get(key reflect.Type) (*cachedStruct, bool) {\n\ts.lock.RLock()\n\tvalue, ok := s.m[key]\n\ts.lock.RUnlock()\n\treturn value, ok\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m *unsupportedContainerManager) Start() error {\n\treturn fmt.Errorf(\"Container Manager is unsupported in this build\")\n}\nfunc UintPtrTo64(ptr interface{}) (value uint64) {\n\tif v := reflect.ValueOf(ptr); v.Kind() == reflect.Ptr {\n\t\tp := v.Elem()\n\t\tswitch p.Kind() {\n\t\tcase reflect.Uint:\n\t\t\tvalue = uint64(*ptr.(*uint))\n\t\tcase reflect.Uint8:\n\t\t\tvalue = uint64(*ptr.(*uint8))\n\t\tcase reflect.Uint16:\n\t\t\tvalue = uint64(*ptr.(*uint16))\n\t\tcase reflect.Uint32:\n\t\t\tvalue = uint64(*ptr.(*uint32))\n\t\tcase reflect.Uint64:\n\t\t\tvalue = *ptr.(*uint64)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (s *structCacheMap) Get(key reflect.Type) (*cachedStruct, bool) {\n\ts.lock.RLock()\n\tvalue, ok := s.m[key]\n\ts.lock.RUnlock()\n\treturn value, ok\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ts := tf.Get(ctx)\n\ts.lock.RLock()\n\ts.m = make(map[string]struct{})\n\ts.lock.RUnlock()\n\treturn s, nil\n}"}
{"input": "func (r *Response) Status() int {\n\treturn r.status\n}\nfunc (s *structCacheMap) Get(key reflect.Type) (*cachedStruct, bool) {\n\ts.lock.RLock()\n\tvalue, ok := s.m[key]\n\ts.lock.RUnlock()\n\treturn value, ok\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (db Database) getConnection() (*sql.DB, error) {\n\tcon, err := sql.Open(\"mysql\", fmt.Sprintf(\"%v:%v@tcp(%v:3306)/%v?parseTime=true\", db.user, db.password, db.host, db.database))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn con, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (m *unsupportedContainerManager) Start() error {\n\treturn fmt.Errorf(\"Container Manager is unsupported in this build\")\n}\nfunc (db Database) getConnection() (*sql.DB, error) {\n\tcon, err := sql.Open(\"mysql\", fmt.Sprintf(\"%v:%v@tcp(%v:3306)/%v?parseTime=true\", db.user, db.password, db.host, db.database))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn con, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvider: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (e *MilliSecondsEpochTime) UnmarshalJSON(b []byte) error {\n\tvar epoch int64\n\terr := json.Unmarshal(b, &epoch)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*e = MilliSecondsEpochTime{time.Unix(epoch/1000, (epoch%1000)*1000000)}\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (e *MilliSecondsEpochTime) UnmarshalJSON(b []byte) error {\n\tvar epoch int64\n\terr := json.Unmarshal(b, &epoch)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*e = MilliSecondsEpochTime{time.Unix(epoch/1000, (epoch%1000)*1000000)}\n\treturn nil\n}\nfunc (s *StructTypeSpecTestSuite) TestName() {\n\tspec, err := FindJSONStructFor(\"github.com/marcel/jitjson/fixtures/media\", \"Album\")\n\ts.Nil(err)\n\n\ts.Equal(\"Album\", spec.Name())\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas := tfjson.ProviderSchemas{}\n\terr := tf.ProviderSchemas.Validate(ctx, &providerSchemas)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn providerSchemas, nil\n}"}
{"input": "func (m *unsupportedContainerManager) Start() error {\n\treturn fmt.Errorf(\"Container Manager is unsupported in this build\")\n}\nfunc (s *StructTypeSpecTestSuite) TestName() {\n\tspec, err := FindJSONStructFor(\"github.com/marcel/jitjson/fixtures/media\", \"Album\")\n\ts.Nil(err)\n\n\ts.Equal(\"Album\", spec.Name())\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc Execute() {\n\tif err := goSubtitleCmd.Execute(); err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(-1)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (e *MilliSecondsEpochTime) UnmarshalJSON(b []byte) error {\n\tvar epoch int64\n\terr := json.Unmarshal(b, &epoch)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*e = MilliSecondsEpochTime{time.Unix(epoch/1000, (epoch%1000)*1000000)}\n\treturn nil\n}\nfunc Execute() {\n\tif err := goSubtitleCmd.Execute(); err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(-1)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc (s *stepCreateVM) Cleanup(state multistep.StateBag) {\n\tif s.vmName == \"\" {\n\t\treturn\n\t}\n\n\tdriver := state.Get(\"driver\").(parallelscommon.Driver)\n\tui := state.Get(\"ui\").(packer.Ui)\n\n\tui.Say(\"Unregistering virtual machine...\")\n\tif err := driver.Prlctl(\"unregister\", s.vmName); err != nil {\n\t\tui.Error(fmt.Sprintf(\"Error unregistering virtual machine: %s\", err))\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"vm\",\n\t\t\tType: \"vm\",\n\t\t\tName: \"vm\",\n\t\t},\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (r *Response) Status() int {\n\treturn r.status\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProvidersSchema(ctx)\n}"}
{"input": "func (response GetMonitorResponse) String() string {\n\treturn common.PointerString(response)\n}\nfunc (r *Response) Status() int {\n\treturn r.status\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc BenchmarkCrypto_box_keypair(*testing.B) {\n\tpk := make([]byte, 32)\n\tsk := make([]byte, 32)\n\n\tcrypto_box_keypair(pk, sk)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas := tf.GetProvidersSchema(ctx)\n\treturn providerSchemas, nil\n}"}
{"input": "func (response GetMonitorResponse) String() string {\n\treturn common.PointerString(response)\n}\nfunc BenchmarkCrypto_box_keypair(*testing.B) {\n\tpk := make([]byte, 32)\n\tsk := make([]byte, 32)\n\n\tcrypto_box_keypair(pk, sk)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func GetDetachServerVolumeRequestDeleteFlagEnum() DetachServerVolumeRequestDeleteFlagEnum {\n\treturn DetachServerVolumeRequestDeleteFlagEnum{\n\t\tE_0: DetachServerVolumeRequestDeleteFlag{\n\t\t\tvalue: \"0\",\n\t\t},\n\t\tE_1: DetachServerVolumeRequestDeleteFlag{\n\t\t\tvalue: \"1\",\n\t\t},\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc GetDetachServerVolumeRequestDeleteFlagEnum() DetachServerVolumeRequestDeleteFlagEnum {\n\treturn DetachServerVolumeRequestDeleteFlagEnum{\n\t\tE_0: DetachServerVolumeRequestDeleteFlag{\n\t\t\tvalue: \"0\",\n\t\t},\n\t\tE_1: DetachServerVolumeRequestDeleteFlag{\n\t\t\tvalue: \"1\",\n\t\t},\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc FileWriter(ch <-chan Res, wg *sync.WaitGroup, filename string) error {\n\tf, err := os.Create(filename)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer f.Close()\n\n\twriter := csv.NewWriter(f)\n\tif err = writer.Write(Config.ResultHeads); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor data := range ch {\n\t\tvalues := make([]string, 0, len(Config.ResultHeads))\n\t\tfor _, k := range Config.ResultHeads {\n\t\t\tif v, ok := data[k]; ok {\n\t\t\t\tvalues = append(values, fmt.Sprintf(\"%v\", v))\n\t\t\t} else {\n\t\t\t\tvalues = append(values, \"\")\n\t\t\t}\n\t\t}\n\t\tif err = writer.Write(values); err != nil {\n\t\t\tlog.Printf(\"csv: %v\\n\", values)\n\t\t}\n\t}\n\tdefer wg.Done()\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func init() {\n\tcurrent.BasePath = \"./\"\n\tif len(os.Args) > 1 {\n\t\tcurrent.BasePath = os.Args[1]\n\t}\n}\nfunc FileWriter(ch <-chan Res, wg *sync.WaitGroup, filename string) error {\n\tf, err := os.Create(filename)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer f.Close()\n\n\twriter := csv.NewWriter(f)\n\tif err = writer.Write(Config.ResultHeads); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor data := range ch {\n\t\tvalues := make([]string, 0, len(Config.ResultHeads))\n\t\tfor _, k := range Config.ResultHeads {\n\t\t\tif v, ok := data[k]; ok {\n\t\t\t\tvalues = append(values, fmt.Sprintf(\"%v\", v))\n\t\t\t} else {\n\t\t\t\tvalues = append(values, \"\")\n\t\t\t}\n\t\t}\n\t\tif err = writer.Write(values); err != nil {\n\t\t\tlog.Printf(\"csv: %v\\n\", values)\n\t\t}\n\t}\n\tdefer wg.Done()\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc init() {\n\tcurrent.BasePath = \"./\"\n\tif len(os.Args) > 1 {\n\t\tcurrent.BasePath = os.Args[1]\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (pn *peernet) Adapter(p testutil.Identity) bsnet.BitSwapNetwork {\n\tclient, err := pn.Mocknet.AddPeer(p.PrivateKey(), p.Address())\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\trouting := pn.routingserver.ClientWithDatastore(context.TODO(), p, ds.NewMapDatastore())\n\treturn bsnet.NewFromIpfsHost(client, routing)\n}\nfunc init() {\n\tcurrent.BasePath = \"./\"\n\tif len(os.Args) > 1 {\n\t\tcurrent.BasePath = os.Args[1]\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (e *AmbiguousResourceError) Error() string {\n\tswitch {\n\tcase len(e.MatchingKinds) > 0 && len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v and kinds %v\", e.PartialResource, e.MatchingResources, e.MatchingKinds)\n\tcase len(e.MatchingKinds) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple kinds %v\", e.PartialResource, e.MatchingKinds)\n\tcase len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v\", e.PartialResource, e.MatchingResources)\n\n\t}\n\n\treturn fmt.Sprintf(\"%v matches multiple resources or kinds\", e.PartialResource)\n}\nfunc (pn *peernet) Adapter(p testutil.Identity) bsnet.BitSwapNetwork {\n\tclient, err := pn.Mocknet.AddPeer(p.PrivateKey(), p.Address())\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\trouting := pn.routingserver.ClientWithDatastore(context.TODO(), p, ds.NewMapDatastore())\n\treturn bsnet.NewFromIpfsHost(client, routing)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (e *AmbiguousResourceError) Error() string {\n\tswitch {\n\tcase len(e.MatchingKinds) > 0 && len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v and kinds %v\", e.PartialResource, e.MatchingResources, e.MatchingKinds)\n\tcase len(e.MatchingKinds) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple kinds %v\", e.PartialResource, e.MatchingKinds)\n\tcase len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v\", e.PartialResource, e.MatchingResources)\n\n\t}\n\n\treturn fmt.Sprintf(\"%v matches multiple resources or kinds\", e.PartialResource)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\nfunc (app *beaconD) createSinks() (err error) {\n\tif app.config.enableFileSink() {\n\t\tfs, err := sinks.NewFileSink(app.config.SinksFileLog, app.config.SinksFileMaxSize, app.config.SinksFileMaxAge)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tapp.sinks = append(app.sinks, fs)\n\t}\n\n\tif app.config.enableSyslog() {\n\t\tss, err := sinks.NewSyslogSink()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tapp.sinks = append(app.sinks, ss)\n\t}\n\n\tif app.config.enableRSyslog() {\n\t\tss, err := sinks.NewRemoteSyslogSink(app.config.syslogAddress())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tapp.sinks = append(app.sinks, ss)\n\t}\n\n\treturn err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.config.ProvidersSchema(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (s *Service) RankCard(plat int8) (ranks []*rank.Rank, aids []int64) {\n\tvar limit int\n\tif !model.IsIPad(plat) {\n\t\tlimit = 3\n\t} else {\n\t\tlimit = 4\n\t}\n\tranks = make([]*rank.Rank, 0, limit)\n\taids = make([]int64, 0, limit)\n\tfor _, rank := range s.rankCache {\n\t\tranks = append(ranks, rank)\n\t\taids = append(aids, rank.Aid)\n\t\tif len(ranks) == limit {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func TestValidationFactory_New(t *testing.T) {\n\tfactory := &token.ValidationFactory{}\n\tplugin := factory.New()\n\tassert.NotNil(t, plugin)\n}\nfunc (s *Service) RankCard(plat int8) (ranks []*rank.Rank, aids []int64) {\n\tvar limit int\n\tif !model.IsIPad(plat) {\n\t\tlimit = 3\n\t} else {\n\t\tlimit = 4\n\t}\n\tranks = make([]*rank.Rank, 0, limit)\n\taids = make([]int64, 0, limit)\n\tfor _, rank := range s.rankCache {\n\t\tranks = append(ranks, rank)\n\t\taids = append(aids, rank.Aid)\n\t\tif len(ranks) == limit {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc TestValidationFactory_New(t *testing.T) {\n\tfactory := &token.ValidationFactory{}\n\tplugin := factory.New()\n\tassert.NotNil(t, plugin)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas := tfjson.ProviderSchemas{}\n\treturn providerSchemas, nil\n}"}
{"input": "func (c ConvertAlign) convertFlag() []string { return intFlag(\"align\", int(c)) }\nfunc TestValidationFactory_New(t *testing.T) {\n\tfactory := &token.ValidationFactory{}\n\tplugin := factory.New()\n\tassert.NotNil(t, plugin)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas := tf.ProviderSchemas()\n\treturn providerSchemas, nil\n}"}
{"input": "func (stack *Stack) Push(x interface{}) {\n\t*stack = append(*stack, x)\n}\nfunc (c ConvertAlign) convertFlag() []string { return intFlag(\"align\", int(c)) }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc (stack *Stack) Push(x interface{}) {\n\t*stack = append(*stack, x)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func init() {\n\tdefdb := dbobj.GetDefaultName()\n\tif \"oracle\" == defdb {\n\t\thauth_service_001 = `insert into sys_handle_logs(uuid,user_id,handle_time,client_ip,status_code,method,url,domain_id,data) values(sys_guid(),:1,sysdate,:2,:3,:4,:5,:6,:7)`\n\t}\n}\nfunc (stack *Stack) Push(x interface{}) {\n\t*stack = append(*stack, x)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (tf *Terraform) providersSchemaCmd(ctx context.Context, args ...string) *exec.Cmd {\n\tallArgs := []string{\"providers\", \"schema\", \"-json\", \"-no-color\"}\n\tallArgs = append(allArgs, args...)\n\n\treturn tf.buildTerraformCmd(ctx, nil, allArgs...)\n}\nfunc init() {\n\tdefdb := dbobj.GetDefaultName()\n\tif \"oracle\" == defdb {\n\t\thauth_service_001 = `insert into sys_handle_logs(uuid,user_id,handle_time,client_ip,status_code,method,url,domain_id,data) values(sys_guid(),:1,sysdate,:2,:3,:4,:5,:6,:7)`\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providersSchemaCmd(ctx, tf.args...)\n}"}
{"input": "\nfunc (request GetCrossConnectRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func main(){\n  player00 := Human{HumanPlayer: new(Man)}\n  player01 := Human{HumanPlayer: new(Woman)}\n\n  player00.HumanPlayer.MyName()\n  fmt.Scanf(\"%s\", &player00.Name)\n\n  player01.HumanPlayer.TheirName()\n  fmt.Scanf(\"%s\", &player01.Name)\n\n  fmt.Printf(\"MortalKombat: %s vs. %s\\n\", player00.Name, player01.Name)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n  providerSchemas := tfjson.ProviderSchemas{}\n  err := tf.client.ProvidersSchema(ctx)\n  if err!= nil {\n    return nil, err\n  }\n\n  return providerSchemas, nil\n}"}
{"input": "func (request GetServiceRequest) String() string {\n\treturn common.PointerString(request)\n}\nfunc main(){\n  player00 := Human{HumanPlayer: new(Man)}\n  player01 := Human{HumanPlayer: new(Woman)}\n\n  player00.HumanPlayer.MyName()\n  fmt.Scanf(\"%s\", &player00.Name)\n\n  player01.HumanPlayer.TheirName()\n  fmt.Scanf(\"%s\", &player01.Name)\n\n  fmt.Printf(\"MortalKombat: %s vs. %s\\n\", player00.Name, player01.Name)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"application/json\",\n\t\tSchema: tfjson.NewProviderSchemas(),\n\t}, nil\n}"}
{"input": "\nfunc (request GetServiceRequest) String() string {\n\treturn common.PointerString(request)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (p *BaseProvider) getBasicAuth() string {\n\treturn \"Basic \" + base64.StdEncoding.EncodeToString([]byte(p.ClientId+\":\"+p.ClientSecret))\n}\nfunc (request GetServiceRequest) String() string {\n\treturn common.PointerString(request)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc (p *BaseProvider) getBasicAuth() string {\n\treturn \"Basic \" + base64.StdEncoding.EncodeToString([]byte(p.ClientId+\":\"+p.ClientSecret))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (t *BasicExampleController) Routes() (http.Handler, error) {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(t.Base(), t.index)\n\trouter.HandleFunc(t.Base()+\"magic\", t.index)\n\treturn router, nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc (t *BasicExampleController) Routes() (http.Handler, error) {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(t.Base(), t.index)\n\trouter.HandleFunc(t.Base()+\"magic\", t.index)\n\treturn router, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\nfunc NewCounter(name string, v float64, ls ...*dto.LabelPair) *dto.MetricFamily {\n\tm := &dto.Metric{\n\t\tLabel: ls,\n\t\tCounter: &dto.Counter{\n\t\t\tValue: &v,\n\t\t},\n\t}\n\treturn &dto.MetricFamily{\n\t\tName:   proto.String(name),\n\t\tType:   dto.MetricType_COUNTER.Enum(),\n\t\tMetric: []*dto.Metric{m},\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.ProviderSchemas{\n\t\t\tName:   tf.Config.Name,\n\t\t\tType:   tf.Config.Type,\n\t\t\tMetric: []*dto.Metric{tf.Config.Name},\n\t\t},\n\t}, nil\n}"}
{"input": "func upload(c *echo.Context) error {\n\treq := c.Request()\n\treq.ParseMultipartForm(16 << 20) \n\n\tname := c.Form(\"name\")\n\temail := c.Form(\"email\")\n\n\tfiles := req.MultipartForm.File[\"files\"]\n\tfor _, f := range files {\n\t\tsrc, err := f.Open()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer src.Close()\n\n\t\tdst, err := os.Create(f.Filename)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn c.String(http.StatusOK, \"Thank You! %s <%s>, %d files uploaded successfully.\",\n\t\tname, email, len(files))\n}\nfunc NewCounter(name string, v float64, ls ...*dto.LabelPair) *dto.MetricFamily {\n\tm := &dto.Metric{\n\t\tLabel: ls,\n\t\tCounter: &dto.Counter{\n\t\t\tValue: &v,\n\t\t},\n\t}\n\treturn &dto.MetricFamily{\n\t\tName:   proto.String(name),\n\t\tType:   dto.MetricType_COUNTER.Enum(),\n\t\tMetric: []*dto.Metric{m},\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func TestCreateBucketsIfNeededUsersBucketError(t *testing.T) {\n\ttx := new(txMock)\n\ttx.bucketToReject = \"users\"\n\texpectedErrorMsg := \"ERROR >> user bucket creation failed : some error\"\n\n\terr := createBucketsIfNeeded(tx)\n\n\tif err == nil {\n\t\tt.Error(\"expect to have an error, but got nil\")\n\t}\n\n\tif err.Error() != expectedErrorMsg {\n\t\tt.Errorf(\"expect to have an error with text %s, but got %s\", expectedErrorMsg, err.Error())\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestCreateBucketsIfNeededUsersBucketError(t *testing.T) {\n\ttx := new(txMock)\n\ttx.bucketToReject = \"users\"\n\texpectedErrorMsg := \"ERROR >> user bucket creation failed : some error\"\n\n\terr := createBucketsIfNeeded(tx)\n\n\tif err == nil {\n\t\tt.Error(\"expect to have an error, but got nil\")\n\t}\n\n\tif err.Error() != expectedErrorMsg {\n\t\tt.Errorf(\"expect to have an error with text %s, but got %s\", expectedErrorMsg, err.Error())\n\t}\n}\nfunc NewNatGateways(client natGatewaysClient, logger logger) NatGateways {\n\treturn NatGateways{\n\t\tclient: client,\n\t\tlogger: logger,\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func upload(c *echo.Context) error {\n\treq := c.Request()\n\treq.ParseMultipartForm(16 << 20) \n\n\tname := c.Form(\"name\")\n\temail := c.Form(\"email\")\n\n\tfiles := req.MultipartForm.File[\"files\"]\n\tfor _, f := range files {\n\t\tsrc, err := f.Open()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer src.Close()\n\n\t\tdst, err := os.Create(f.Filename)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn c.String(http.StatusOK, \"Thank You! %s <%s>, %d files uploaded successfully.\",\n\t\tname, email, len(files))\n}\nfunc NewNatGateways(client natGatewaysClient, logger logger) NatGateways {\n\treturn NatGateways{\n\t\tclient: client,\n\t\tlogger: logger,\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tType: \"application/json\",\n\t\tName: \"name\",\n\t\tEmail: \"email\",\n\t\tProviders: []tfjson.ProviderSchema{\n\t\t\ttfjson.ProviderSchema{\n\t\t\t\tName: \"name\",\n\t\t\t\tEmail: \"email\",\n\t\t\t\tEmail: \"email\",\n\t\t\t},\n\t\t\t},\n\t\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc LoadJSON(path string, data interface{}) (result interface{}, err error) {\n\tj, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer j.Close()\n\terr = json.NewDecoder(j).Decode(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func GetHomeDir() string {\n\treturn homedir.Get()\n}\nfunc LoadJSON(path string, data interface{}) (result interface{}, err error) {\n\tj, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer j.Close()\n\terr = json.NewDecoder(j).Decode(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (o *ActionsDelete) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n\troute, rCtx, _ := o.Context.RouteInfo(r)\n\tif rCtx != nil {\n\t\tr = rCtx\n\t}\n\tvar Params = NewActionsDeleteParams()\n\n\tuprinc, aCtx, err := o.Context.Authorize(r, route)\n\tif err != nil {\n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\tif aCtx != nil {\n\t\tr = aCtx\n\t}\n\tvar principal *models.Principal\n\tif uprinc != nil {\n\t\tprincipal = uprinc.(*models.Principal) \n\t}\n\n\tif err := o.Context.BindValidRequest(r, route, &Params); err != nil { \n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\n\tres := o.Handler.Handle(Params, principal) \n\n\to.Context.Respond(rw, r, route.Produces, route, res)\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: tf.Name,\n\t\t\tName: tf.Name,\n\t\t\tType:  tfjson.TypeSchema,\n\t\t},\n\t}\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc getHomePath() (string, error) {\n\tu, err := user.Current()\n\tif nil == err {\n\t\treturn u.HomeDir, nil\n\t}\n\tif \"windows\" == runtime.GOOS {\n\t\treturn homeWindows()\n\t}\n\treturn homeUnix()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProvider: &tfjson.ProviderSchemas{\n\t\t\tName: \"providers\",\n\t\t\tType: \"application/json\",\n\t\t\tName: \"application/json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func TestSquareOfSum(t *testing.T) {\n\texpected := 3025\n\tactual := SquareOfSum(10)\n\tif expected != actual {\n\t\tt.Errorf(\"expected:%d - actual:%d\", expected, actual)\n\t}\n}\nfunc getHomePath() (string, error) {\n\tu, err := user.Current()\n\tif nil == err {\n\t\treturn u.HomeDir, nil\n\t}\n\tif \"windows\" == runtime.GOOS {\n\t\treturn homeWindows()\n\t}\n\treturn homeUnix()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc TestSquareOfSum(t *testing.T) {\n\texpected := 3025\n\tactual := SquareOfSum(10)\n\tif expected != actual {\n\t\tt.Errorf(\"expected:%d - actual:%d\", expected, actual)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestClient(t *testing.T) {\n\n\tr, _, err := Get(\"http://www.google.com/robots.txt\")\n\tvar b []byte\n\tif err == nil {\n\t\tb, err = ioutil.ReadAll(r.Body)\n\t\tr.Body.Close()\n\t}\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if s := string(b); !strings.HasPrefix(s, \"User-agent:\") {\n\t\tt.Errorf(\"Incorrect page body (did not begin with User-agent): %q\", s)\n\t}\n}\nfunc TestSquareOfSum(t *testing.T) {\n\texpected := 3025\n\tactual := SquareOfSum(10)\n\tif expected != actual {\n\t\tt.Errorf(\"expected:%d - actual:%d\", expected, actual)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.Client(ctx)\n}"}
{"input": "func NewContainerManager(_ string, _ libdocker.Interface) ContainerManager {\n\treturn &unsupportedContainerManager{}\n}\nfunc TestClient(t *testing.T) {\n\n\tr, _, err := Get(\"http://www.google.com/robots.txt\")\n\tvar b []byte\n\tif err == nil {\n\t\tb, err = ioutil.ReadAll(r.Body)\n\t\tr.Body.Close()\n\t}\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if s := string(b); !strings.HasPrefix(s, \"User-agent:\") {\n\t\tt.Errorf(\"Incorrect page body (did not begin with User-agent): %q\", s)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviders: tfjson.NewProvidersSchema(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc Find(_ *Node, _ string) []*Node {\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func NewContainerManager(_ string, _ libdocker.Interface) ContainerManager {\n\treturn &unsupportedContainerManager{}\n}\nfunc Find(_ *Node, _ string) []*Node {\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (up *Upstream) Serve(rw http.ResponseWriter, req *http.Request) {\n\tserver := up.nextServer()\n\tif server == nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tserver.ServeHTTP(rw, req)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (up *Upstream) Serve(rw http.ResponseWriter, req *http.Request) {\n\tserver := up.nextServer()\n\tif server == nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tserver.ServeHTTP(rw, req)\n}\nfunc (s *Server) CreatePipe(w http.ResponseWriter, r *http.Request) {\n\tguid, err := uuid.NewV4()\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\terr = s.db.CreatePipe(guid.String(), s.url)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tpr, pw := io.Pipe()\n\n\tpipeResource := atc.Pipe{\n\t\tID: guid.String(),\n\t}\n\n\tpipe := pipe{\n\t\tresource: pipeResource,\n\n\t\tread:  pr,\n\t\twrite: pw,\n\t}\n\n\ts.pipesL.Lock()\n\ts.pipes[pipeResource.ID] = pipe\n\ts.pipesL.Unlock()\n\n\tw.WriteHeader(http.StatusCreated)\n\n\tjson.NewEncoder(w).Encode(pipeResource)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tType: tfjson.TypeProviderSchemas,\n\t\t},\n\t}\n}"}
{"input": "func NewContainerManager(_ string, _ libdocker.Interface) ContainerManager {\n\treturn &unsupportedContainerManager{}\n}\nfunc (s *Server) CreatePipe(w http.ResponseWriter, r *http.Request) {\n\tguid, err := uuid.NewV4()\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\terr = s.db.CreatePipe(guid.String(), s.url)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tpr, pw := io.Pipe()\n\n\tpipeResource := atc.Pipe{\n\t\tID: guid.String(),\n\t}\n\n\tpipe := pipe{\n\t\tresource: pipeResource,\n\n\t\tread:  pr,\n\t\twrite: pw,\n\t}\n\n\ts.pipesL.Lock()\n\ts.pipes[pipeResource.ID] = pipe\n\ts.pipesL.Unlock()\n\n\tw.WriteHeader(http.StatusCreated)\n\n\tjson.NewEncoder(w).Encode(pipeResource)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tType:  tfjson.TypeProviderSchemas,\n\t\t},\n\t}\n}"}
{"input": "func (e cpiError) OkToRetry() bool {\n\treturn e.cmdError.OkToRetry\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (e cpiError) OkToRetry() bool {\n\treturn e.cmdError.OkToRetry\n}\nfunc (m Memstore) UpdateCollection(slug, name string) error {\n\tif c, ok := m[slug]; !ok {\n\t\treturn CollectionNotFoundError\n\t} else {\n\t\tc.Name = name\n\t}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas, nil\n}"}
{"input": "func (up *Upstream) Serve(rw http.ResponseWriter, req *http.Request) {\n\tserver := up.nextServer()\n\tif server == nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tserver.ServeHTTP(rw, req)\n}\nfunc (m Memstore) UpdateCollection(slug, name string) error {\n\tif c, ok := m[slug]; !ok {\n\t\treturn CollectionNotFoundError\n\t} else {\n\t\tc.Name = name\n\t}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (p *Params) String() string {\n\treturn fmt.Sprintf(\"[EpochLimit: %d, EpochMillis: %d, WindowSize: %d]\",\n\t\tp.EpochLimit, p.EpochMillis, p.WindowSize)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc GetMountRootEntries(mountRoot string) ([]string, error) {\n\tvar vols []string\n\tvolumes, err := ioutil.ReadDir(mountRoot)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to read entries from %s (%v)\", mountRoot, err)\n\t\treturn vols, err\n\t}\n\n\tfor _, vol := range volumes {\n\t\tvols = append(vols, vol.Name())\n\t}\n\treturn vols, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (registry *pluginRegistry) RegisterUnique(plugin Plugin, ID string) {\n\tif _, exists := registry.plugins[ID]; !exists {\n\t\tregistry.plugins[ID] = plugin\n\t}\n}\nfunc GetMountRootEntries(mountRoot string) ([]string, error) {\n\tvar vols []string\n\tvolumes, err := ioutil.ReadDir(mountRoot)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to read entries from %s (%v)\", mountRoot, err)\n\t\treturn vols, err\n\t}\n\n\tfor _, vol := range volumes {\n\t\tvols = append(vols, vol.Name())\n\t}\n\treturn vols, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (k *MockK8sClient) UpdateConfigMap(namespace, configmap string, params map[string]string) (*apiv1.ConfigMap, error) {\n\treturn nil, nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func (k *MockK8sClient) UpdateConfigMap(namespace, configmap string, params map[string]string) (*apiv1.ConfigMap, error) {\n\treturn nil, nil\n}\nfunc TestPercentiles(t *testing.T) {\n\tnums := make([]float64, 100)\n\tnums[99] = 1 \n\tdata := percentiles(nums)\n\tif data[len(pctls)-2] != 1 {\n\t\tt.Fatalf(\"99-percentile expected 1, got %f\", data[len(pctls)-2])\n\t}\n\n\tnums = make([]float64, 1000)\n\tnums[999] = 1 \n\tdata = percentiles(nums)\n\tif data[len(pctls)-1] != 1 {\n\t\tt.Fatalf(\"99.9-percentile expected 1, got %f\", data[len(pctls)-1])\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func (registry *pluginRegistry) RegisterUnique(plugin Plugin, ID string) {\n\tif _, exists := registry.plugins[ID]; !exists {\n\t\tregistry.plugins[ID] = plugin\n\t}\n}\nfunc TestPercentiles(t *testing.T) {\n\tnums := make([]float64, 100)\n\tnums[99] = 1 \n\tdata := percentiles(nums)\n\tif data[len(pctls)-2] != 1 {\n\t\tt.Fatalf(\"99-percentile expected 1, got %f\", data[len(pctls)-2])\n\t}\n\n\tnums = make([]float64, 1000)\n\tnums[999] = 1 \n\tdata = percentiles(nums)\n\tif data[len(pctls)-1] != 1 {\n\t\tt.Fatalf(\"99.9-percentile expected 1, got %f\", data[len(pctls)-1])\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (e Event) String() string {\n\tinputs := make([]string, len(e.Inputs))\n\tfor i, input := range e.Inputs {\n\t\tinputs[i] = fmt.Sprintf(\"%v %v\", input.Type, input.Name)\n\t\tif input.Indexed {\n\t\t\tinputs[i] = fmt.Sprintf(\"%v indexed %v\", input.Type, input.Name)\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"event %v(%v)\", e.Name, strings.Join(inputs, \", \"))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func TestMeta(t *testing.T) {\n\ttable := NewTable(\"users\")\n\ttable.SetMeta(\"primary_key\", \"user_id\")\n\tif table.MustGetMeta(\"primary_key\") != \"user_id\" {\n\t\tt.Error(\"expected primary_key meta field to be user_id\")\n\t}\n\n\tif table.meta.Name != \"users\" {\n\t\tt.Error(\"expected table name to be users\")\n\t}\n}\nfunc (e Event) String() string {\n\tinputs := make([]string, len(e.Inputs))\n\tfor i, input := range e.Inputs {\n\t\tinputs[i] = fmt.Sprintf(\"%v %v\", input.Type, input.Name)\n\t\tif input.Indexed {\n\t\t\tinputs[i] = fmt.Sprintf(\"%v indexed %v\", input.Type, input.Name)\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"event %v(%v)\", e.Name, strings.Join(inputs, \", \"))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProviderSchemas)\n}"}
{"input": "\nfunc TestSagaStateFactory(t *testing.T) {\n\n\tsagaId := \"testSaga\"\n\tjob := []byte{0, 1, 2, 3, 4, 5}\n\n\tstate, _ := makeSagaState(\"testSaga\", job)\n\tif state.sagaId != sagaId {\n\t\tt.Error(fmt.Sprintf(\"SagaState SagaId should be the same as the SagaId passed to Factory Method\"))\n\t}\n\n\tif !bytes.Equal(state.job, job) {\n\t\tt.Error(fmt.Sprintf(\"SagaState Job should be the same as the supplied Job passed to Factory Method\"))\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas := tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}\n\n\treturn providerSchemas, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (s *Statement55) SetStatementIdentification(value string) {\n\ts.StatementIdentification = (*RestrictedFINXMax16Text)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func print_tb(x, y int, fg, bg termbox.Attribute, msg string) {\n\tfor _, c := range msg {\n\t\ttermbox.SetCell(x, y, c, fg, bg)\n\t\tx++\n\t}\n}\nfunc (s *Statement55) SetStatementIdentification(value string) {\n\ts.StatementIdentification = (*RestrictedFINXMax16Text)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\nfunc (a *AccountManagementConfirmation2) SetConfirmationType(value string) {\n\ta.ConfirmationType = (*AccountManagementType2Code)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func print_tb(x, y int, fg, bg termbox.Attribute, msg string) {\n\tfor _, c := range msg {\n\t\ttermbox.SetCell(x, y, c, fg, bg)\n\t\tx++\n\t}\n}\nfunc (a *AccountManagementConfirmation2) SetConfirmationType(value string) {\n\ta.ConfirmationType = (*AccountManagementType2Code)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc NewServerNews(info []*block.News) ServerNews {\n\treturn ServerNews{info}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\nfunc NewServerNews(info []*block.News) ServerNews {\n\treturn ServerNews{info}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProvidersSchema: tfjson.ProvidersSchema{\n\t\t\tName: \"providerschemas\",\n\t\t\tType: \"string\",\n\t\t\tType: \"string\",\n\t\t},\n\t}, nil\n}"}
{"input": "\nfunc myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func logRequest(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlog.Printf(\"%s %s %s\\n\", r.RemoteAddr, r.Method, r.URL)\n\t\thandler.ServeHTTP(w, r)\n\t})\n}\nfunc myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func GetMountTargetSummaryLifecycleStateEnumValues() []MountTargetSummaryLifecycleStateEnum {\n\tvalues := make([]MountTargetSummaryLifecycleStateEnum, 0)\n\tfor _, v := range mappingMountTargetSummaryLifecycleState {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}\nfunc logRequest(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlog.Printf(\"%s %s %s\\n\", r.RemoteAddr, r.Method, r.URL)\n\t\thandler.ServeHTTP(w, r)\n\t})\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tType: \"json\",\n\t\tProviderSchema: tfjson.ProviderSchemas{\n\t\t\tName: \"providers\",\n\t\t\tType: \"json\",\n\t\t\tType: \"json\",\n\t\t},\n\t}, nil\n}"}
{"input": "\nfunc GetMountTargetSummaryLifecycleStateEnumValues() []MountTargetSummaryLifecycleStateEnum {\n\tvalues := make([]MountTargetSummaryLifecycleStateEnum, 0)\n\tfor _, v := range mappingMountTargetSummaryLifecycleState {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func TestFGaugeDeltaUpdateNegative(t *testing.T) {\n\te1 := &FGaugeDelta{Name: \"test\", Value: float64(-15.1)}\n\te2 := &FGaugeDelta{Name: \"test\", Value: float64(10.0)}\n\te3 := &FGaugeDelta{Name: \"test\", Value: float64(-15.1)}\n\terr := e1.Update(e2)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\terr = e1.Update(e3)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\n\texpected := []string{\"test:-20.2|g\"}\n\tactual := e1.Stats()\n\tif !reflect.DeepEqual(expected, actual) {\n\t\tt.Errorf(\"did not receive all metrics: Expected: %T %v, Actual: %T %v \", expected, expected, actual, actual)\n\t}\n}\nfunc GetMountTargetSummaryLifecycleStateEnumValues() []MountTargetSummaryLifecycleStateEnum {\n\tvalues := make([]MountTargetSummaryLifecycleStateEnum, 0)\n\tfor _, v := range mappingMountTargetSummaryLifecycleState {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (i *IngestsMethod) List() (*IngestsS, error) {\n\trel := \"ingests\"\n\n\tingests := new(IngestsS)\n\t_, err := i.client.Get(rel, ingests)\n\treturn ingests, err\n}\nfunc TestFGaugeDeltaUpdateNegative(t *testing.T) {\n\te1 := &FGaugeDelta{Name: \"test\", Value: float64(-15.1)}\n\te2 := &FGaugeDelta{Name: \"test\", Value: float64(10.0)}\n\te3 := &FGaugeDelta{Name: \"test\", Value: float64(-15.1)}\n\terr := e1.Update(e2)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\terr = e1.Update(e3)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\n\texpected := []string{\"test:-20.2|g\"}\n\tactual := e1.Stats()\n\tif !reflect.DeepEqual(expected, actual) {\n\t\tt.Errorf(\"did not receive all metrics: Expected: %T %v, Actual: %T %v \", expected, expected, actual, actual)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"json\",\n\t\tSchema: tfjson.Schema{\n\t\t\tType: \"json\",\n\t\t\tName: \"providerschemas\",\n\t\t\tType: \"json\",\n\t\t},\n\t}, nil\n}"}
{"input": "\nfunc (data ServerNews) GetBlocks() []*block.Block {\n\tvar blocks []*block.Block\n\tblocks = append(blocks, block.GetBlocks(0x2009, block.Uint32{0})...)\n\tblocks = append(blocks, block.GetBlocks(0x200a, data.News)...)\n\tblocks = append(blocks, block.GetBlocks(0x200b, block.Uint32{0})...)\n\treturn blocks\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (sb *sandbox) populateLoadbalancers(ep *endpoint) {\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "func getScopeFromKey(key string) string {\n\ts := strings.SplitN(key, \"/\", 5)\n\tif len(s) != 5 {\n\t\tif len(key) >= 12 {\n\t\t\treturn key[:12]\n\t\t}\n\t\treturn key\n\t}\n\treturn fmt.Sprintf(\"%s/%s\", s[2], s[3])\n}\nfunc (sb *sandbox) populateLoadbalancers(ep *endpoint) {\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvider: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc getScopeFromKey(key string) string {\n\ts := strings.SplitN(key, \"/\", 5)\n\tif len(s) != 5 {\n\t\tif len(key) >= 12 {\n\t\t\treturn key[:12]\n\t\t}\n\t\treturn key\n\t}\n\treturn fmt.Sprintf(\"%s/%s\", s[2], s[3])\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (l SortMapLayersByWeight) Swap(i, j int) { l[i], l[j] = l[j], l[i] }\nfunc getScopeFromKey(key string) string {\n\ts := strings.SplitN(key, \"/\", 5)\n\tif len(s) != 5 {\n\t\tif len(key) >= 12 {\n\t\t\treturn key[:12]\n\t\t}\n\t\treturn key\n\t}\n\treturn fmt.Sprintf(\"%s/%s\", s[2], s[3])\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc (l SortMapLayersByWeight) Swap(i, j int) { l[i], l[j] = l[j], l[i] }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func _() {\n\tvar x [1]struct{}\n\t_ = x[Unknown-0]\n\t_ = x[AnnotationsTransformer-1]\n\t_ = x[ConfigMapGenerator-2]\n\t_ = x[HashTransformer-3]\n\t_ = x[ImageTagTransformer-4]\n\t_ = x[LabelTransformer-5]\n\t_ = x[LegacyOrderTransformer-6]\n\t_ = x[NamespaceTransformer-7]\n\t_ = x[PatchJson6902Transformer-8]\n\t_ = x[PatchStrategicMergeTransformer-9]\n\t_ = x[PatchTransformer-10]\n\t_ = x[PrefixSuffixTransformer-11]\n\t_ = x[ReplicaCountTransformer-12]\n\t_ = x[SecretGenerator-13]\n\t_ = x[ValueAddTransformer-14]\n\t_ = x[HelmChartInflationGenerator-15]\n\t_ = x[ReplacementTransformer-16]\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc _() {\n\tvar x [1]struct{}\n\t_ = x[Unknown-0]\n\t_ = x[AnnotationsTransformer-1]\n\t_ = x[ConfigMapGenerator-2]\n\t_ = x[HashTransformer-3]\n\t_ = x[ImageTagTransformer-4]\n\t_ = x[LabelTransformer-5]\n\t_ = x[LegacyOrderTransformer-6]\n\t_ = x[NamespaceTransformer-7]\n\t_ = x[PatchJson6902Transformer-8]\n\t_ = x[PatchStrategicMergeTransformer-9]\n\t_ = x[PatchTransformer-10]\n\t_ = x[PrefixSuffixTransformer-11]\n\t_ = x[ReplicaCountTransformer-12]\n\t_ = x[SecretGenerator-13]\n\t_ = x[ValueAddTransformer-14]\n\t_ = x[HelmChartInflationGenerator-15]\n\t_ = x[ReplacementTransformer-16]\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc NewBall(pos Point) *Ball {\n    return &Ball{pos.X, pos.Y, 5, 5}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n    return tfjson.ProvidersSchemas{\n        ProviderSchemas: tfjson.NewProviderSchemas(ctx),\n        ProviderSchemas: tfjson.NewProviderSchemas(ctx),\n        ProviderSchemas: tfjson.NewProviderSchemas(ctx),\n        ProviderSchemas: tfjson.NewProviderSchemas(ctx),\n        ProviderSchemas: tfjson.NewProviderSchemas(ctx),\n        ProviderSchemas: tfjson.NewProviderSchemas(ctx),\n        ProviderSchemas: tfjson.NewProviderSchemas(ctx),\n    }, nil\n}"}
{"input": "func (a *ATMEnvironment3) SetATMManagerIdentification(value string) {\n\ta.ATMManagerIdentification = (*Max35Text)(&value)\n}\nfunc NewBall(pos Point) *Ball {\n    return &Ball{pos.X, pos.Y, 5, 5}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n    return tf.Client.ProvidersSchemas(ctx)\n}"}
{"input": "func (o *ElcomdOptions) HasLogPath() bool {\n\treturn \"\" != o.LogPath\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (o *ElcomdOptions) HasLogPath() bool {\n\treturn \"\" != o.LogPath\n}\nfunc (db *SqlxMixin) InitSqlxMixin(sqldb *sqlx.DB) {\n\tdb.sqlxPreparedStmtCache = make(map[string]*sqlx.Stmt)\n\tdb.DB = sqldb\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func (a *ATMEnvironment3) SetATMManagerIdentification(value string) {\n\ta.ATMManagerIdentification = (*Max35Text)(&value)\n}\nfunc (db *SqlxMixin) InitSqlxMixin(sqldb *sqlx.DB) {\n\tdb.sqlxPreparedStmtCache = make(map[string]*sqlx.Stmt)\n\tdb.DB = sqldb\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func AllMigrations() migration.Migrations {\n\tmigs := make(migration.Migrations, len(migrationsRegistry))\n\tfor i, mig := range migrationsRegistry {\n\t\trt := reflect.TypeOf(mig)\n\t\tif rt.Kind() == reflect.Ptr {\n\t\t\trt = rt.Elem()\n\t\t}\n\t\tmigs[i] = reflect.New(rt).Interface().(migration.Migration)\n\t}\n\treturn migs\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (i *IngestsMethod) List() (*IngestsS, error) {\n\trel := \"ingests\"\n\n\tingests := new(IngestsS)\n\t_, err := i.client.Get(rel, ingests)\n\treturn ingests, err\n}\nfunc AllMigrations() migration.Migrations {\n\tmigs := make(migration.Migrations, len(migrationsRegistry))\n\tfor i, mig := range migrationsRegistry {\n\t\trt := reflect.TypeOf(mig)\n\t\tif rt.Kind() == reflect.Ptr {\n\t\t\trt = rt.Elem()\n\t\t}\n\t\tmigs[i] = reflect.New(rt).Interface().(migration.Migration)\n\t}\n\treturn migs\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"application/json\",\n\t\tSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (u *UnaryExpression) StartPos() Position {\n\tif u.Postfix {\n\t\treturn u.Expression.StartPos()\n\t}\n\treturn StartPositionFromToken(u.Operator)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func NewPreloadForLink(link *httplink.Link) *Preload {\n\tr := resource.NewResource(link.URL)\n\treturn &Preload{link, []*resource.Resource{r}}\n}\nfunc (u *UnaryExpression) StartPos() Position {\n\tif u.Postfix {\n\t\treturn u.Expression.StartPos()\n\t}\n\treturn StartPositionFromToken(u.Operator)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas(ctx, tf.resource.Get(\"ProvidersSchema\"))\n}"}
{"input": "func (i *IngestsMethod) List() (*IngestsS, error) {\n\trel := \"ingests\"\n\n\tingests := new(IngestsS)\n\t_, err := i.client.Get(rel, ingests)\n\treturn ingests, err\n}\nfunc NewPreloadForLink(link *httplink.Link) *Preload {\n\tr := resource.NewResource(link.URL)\n\treturn &Preload{link, []*resource.Resource{r}}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"application/json\",\n\t\tSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (o *ElcomdOptions) HasLogPath() bool {\n\treturn \"\" != o.LogPath\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (o *ElcomdOptions) HasLogPath() bool {\n\treturn \"\" != o.LogPath\n}\nfunc (pkg *Package) SetImports(list []*Package) { pkg.imports = list }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (u *UnaryExpression) StartPos() Position {\n\tif u.Postfix {\n\t\treturn u.Expression.StartPos()\n\t}\n\treturn StartPositionFromToken(u.Operator)\n}\nfunc (pkg *Package) SetImports(list []*Package) { pkg.imports = list }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (self *Thread) PopFrame() *Frame {\n\treturn self.stack.pop()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (ind *AvgPriceWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) {\n\n\tresult := (tickData.O() + tickData.H() + tickData.L() + tickData.C()) / float64(4.0)\n\n\tind.UpdateIndicatorWithNewValue(result, streamBarIndex)\n}\nfunc (self *Thread) PopFrame() *Frame {\n\treturn self.stack.pop()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc init() {\n\tcachegoclient = cache2go.Cache(\"mycache\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (c *Conf) LoadConf() *Conf {\n\tpath := \"/etc/fastforward/fastforward.conf\"\n\tconf, err := configparser.Read(path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tDefaultSection, err := conf.Section(\"DEFAULT\")\n\tcheckErr(err)\n\n\tPlaybackSection, err := conf.Section(\"PLAYBACK\")\n\tcheckErr(err)\n\n\tFFconf := &Conf{\n\t\tDEFAULT: map[string]string{\"provisioning_driver\": DefaultSection.Options()[\"provisioning_driver\"],\n\t\t\t\"orchestration_driver\": DefaultSection.Options()[\"orchestration_driver\"],\n\t\t\t\"monitoring_driver\":    DefaultSection.Options()[\"monitoring_driver\"]},\n\t\tPLAYBACK: map[string]string{\"use_ansible\": PlaybackSection.Options()[\"use_ansible\"],\n\t\t\t\"ansible_cfg\": PlaybackSection.Options()[\"ansible_cfg\"],\n\t\t\t\"private_key\": PlaybackSection.Options()[\"private_key\"]},\n\t}\n\treturn FFconf\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tProvider: tfjson.NewProviderSchemas(ctx),\n\t\t},\n\t}, nil\n}"}
{"input": "func (s *sField) resolveTag() {\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\n\tif s.attr {\n\t\ts.Tag = \"`\" + `xml:\"` + s.Name + `,attr\"` + \"`\"\n\t\treturn\n\t}\n\n\ts.Tag = \"`\" + `xml:\"` + s.Name + `\"` + \"`\"\n}\nfunc (c *Conf) LoadConf() *Conf {\n\tpath := \"/etc/fastforward/fastforward.conf\"\n\tconf, err := configparser.Read(path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tDefaultSection, err := conf.Section(\"DEFAULT\")\n\tcheckErr(err)\n\n\tPlaybackSection, err := conf.Section(\"PLAYBACK\")\n\tcheckErr(err)\n\n\tFFconf := &Conf{\n\t\tDEFAULT: map[string]string{\"provisioning_driver\": DefaultSection.Options()[\"provisioning_driver\"],\n\t\t\t\"orchestration_driver\": DefaultSection.Options()[\"orchestration_driver\"],\n\t\t\t\"monitoring_driver\":    DefaultSection.Options()[\"monitoring_driver\"]},\n\t\tPLAYBACK: map[string]string{\"use_ansible\": PlaybackSection.Options()[\"use_ansible\"],\n\t\t\t\"ansible_cfg\": PlaybackSection.Options()[\"ansible_cfg\"],\n\t\t\t\"private_key\": PlaybackSection.Options()[\"private_key\"]},\n\t}\n\treturn FFconf\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (s *sField) resolveTag() {\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\n\tif s.attr {\n\t\ts.Tag = \"`\" + `xml:\"` + s.Name + `,attr\"` + \"`\"\n\t\treturn\n\t}\n\n\ts.Tag = \"`\" + `xml:\"` + s.Name + `\"` + \"`\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (t T) Foo () {\n  fmt.Println (t.i)\n}\nfunc (s *sField) resolveTag() {\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\n\tif s.attr {\n\t\ts.Tag = \"`\" + `xml:\"` + s.Name + `,attr\"` + \"`\"\n\t\treturn\n\t}\n\n\ts.Tag = \"`\" + `xml:\"` + s.Name + `\"` + \"`\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n  return tf.providerSchemas, nil\n}"}
{"input": "func (params *AdminParams) ValidateInviteKey(required bool) error { return nil }\nfunc (t T) Foo () {\n  fmt.Println (t.i)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n  return nil, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func trimEmpty(s []string) []string {\n\tvar r = make([]string, 0)\n\tfor _, str := range s {\n\t\tif str != \"\" {\n\t\t\tr = append(r, str)\n\t\t}\n\t}\n\treturn r\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tvar s []string\n\tif err := tf.client.Get(ctx, tf.ProviderSchemaPath, &s); err!= nil {\n\t\treturn nil, err\n\t}\n\treturn &tfjson.ProviderSchemas{\n\t\tProvidersSchema: s,\n\t}, nil\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\nfunc trimEmpty(s []string) []string {\n\tvar r = make([]string, 0)\n\tfor _, str := range s {\n\t\tif str != \"\" {\n\t\t\tr = append(r, str)\n\t\t}\n\t}\n\treturn r\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ts := tf.client.ProvidersSchema(ctx)\n\tif len(s) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn trimEmpty(s)\n}"}
{"input": "\nfunc (b StringCountList) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (instr *LDC_W) Execute(frame *rtda.Frame) {\n\t_ldc(frame, instr.Index)\n}\nfunc (b StringCountList) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\nfunc (instr *LDC_W) Execute(frame *rtda.Frame) {\n\t_ldc(frame, instr.Index)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\nfunc (b StringCountList) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (f *FutureTask) IsDone() bool {\n\treturn f.done\n}\nfunc (b StringCountList) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (params *AdminParams) ValidateInviteKey(required bool) error { return nil }\nfunc (f *FutureTask) IsDone() bool {\n\treturn f.done\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (s3File *S3File) DeleteAttempted() bool {\n\treturn s3File.ErrorMessage != \"\" || s3File.DeletedAt.IsZero() == false\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func NewSetCommand() ReplCommand {\n\treturn ReplCommand{\n\t\tName:  \"set\",\n\t\tUsage: \"set key value\",\n\t\tFlags: []ReplFlag{\n\t\t\tReplFlag{\"ttl\", \"t\", false, true},\n\t\t},\n\t\tAction: func(r *ReplYell) {\n\t\t\tsetCommand(r)\n\t\t},\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{}, nil\n}"}
{"input": "func (n networkRouter) Routes() []router.Route {\n\treturn n.routes\n}\nfunc NewSetCommand() ReplCommand {\n\treturn ReplCommand{\n\t\tName:  \"set\",\n\t\tUsage: \"set key value\",\n\t\tFlags: []ReplFlag{\n\t\t\tReplFlag{\"ttl\", \"t\", false, true},\n\t\t},\n\t\tAction: func(r *ReplYell) {\n\t\t\tsetCommand(r)\n\t\t},\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (n networkRouter) Routes() []router.Route {\n\treturn n.routes\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func IncrAppendInt(slice []int, s int) []int {\n\tl := len(slice)\n\tnewslice := make([]int, l+1)\n\tcopy(newslice, slice)\n\tnewslice[l] = s\n\n\treturn newslice\n}\nfunc (n networkRouter) Routes() []router.Route {\n\treturn n.routes\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\nfunc IncrAppendInt(slice []int, s int) []int {\n\tl := len(slice)\n\tnewslice := make([]int, l+1)\n\tcopy(newslice, slice)\n\tnewslice[l] = s\n\n\treturn newslice\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc installCron(ctx Context) (err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = fmt.Errorf(\"installCron() -> %v\", e)\n\t\t}\n\t\tctx.Channels.Log <- mig.Log{Desc: \"leaving installCron()\"}.Debug()\n\t}()\n\tpanic(\"mig-agent doesn't have a cronjob for darwin.\")\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviders: []tfjson.ProviderSchema{\n\t\t\ttfjson.ProviderSchema{\n\t\t\t\tName: \"darwin\",\n\t\t\t\tType: \"darwin\",\n\t\t\t\tName: \"darwin\",\n\t\t\t\tDescription: \"Install cron job\",\n\t\t\t},\n\t\t\t},\n\t\t}, nil\n}"}
{"input": "func BindNetworkArgs(args *NetworkArgs, flags *pflag.FlagSet, prefix string) {\n\tflags.StringVar(&args.NetworkPluginName, prefix+\"network-plugin\", args.NetworkPluginName, \"The name of the networking plugin to be used for networking.\")\n\tflags.StringVar(&args.ClusterNetworkCIDR, prefix+\"network-cidr\", args.ClusterNetworkCIDR, \"The CIDR string representing the network that all containers should belong to.\")\n\tflags.Uint32Var(&args.HostSubnetLength, prefix+\"host-subnet-length\", args.HostSubnetLength, \"The length of subnet each host is given from the network-cidr.\")\n\tflags.StringVar(&args.ServiceNetworkCIDR, prefix+\"portal-net\", args.ServiceNetworkCIDR, \"The CIDR string representing the network that portal/service IPs will be assigned from. This must not overlap with any IP ranges assigned to nodes for pods.\")\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func BindNetworkArgs(args *NetworkArgs, flags *pflag.FlagSet, prefix string) {\n\tflags.StringVar(&args.NetworkPluginName, prefix+\"network-plugin\", args.NetworkPluginName, \"The name of the networking plugin to be used for networking.\")\n\tflags.StringVar(&args.ClusterNetworkCIDR, prefix+\"network-cidr\", args.ClusterNetworkCIDR, \"The CIDR string representing the network that all containers should belong to.\")\n\tflags.Uint32Var(&args.HostSubnetLength, prefix+\"host-subnet-length\", args.HostSubnetLength, \"The length of subnet each host is given from the network-cidr.\")\n\tflags.StringVar(&args.ServiceNetworkCIDR, prefix+\"portal-net\", args.ServiceNetworkCIDR, \"The CIDR string representing the network that portal/service IPs will be assigned from. This must not overlap with any IP ranges assigned to nodes for pods.\")\n}\nfunc (s *CloneREST) New() runtime.Object {\n\treturn &buildapi.BuildRequest{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (p *paramHeader) marshal() ([]byte, error) {\n\tparamLengthPlusHeader := paramHeaderLength + len(p.raw)\n\n\trawParam := make([]byte, paramLengthPlusHeader)\n\tbinary.BigEndian.PutUint16(rawParam[0:], uint16(p.typ))\n\tbinary.BigEndian.PutUint16(rawParam[2:], uint16(paramLengthPlusHeader))\n\tcopy(rawParam[paramHeaderLength:], p.raw)\n\n\treturn rawParam, nil\n}\nfunc (s *CloneREST) New() runtime.Object {\n\treturn &buildapi.BuildRequest{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: tf.Type,\n\t\tType: tf.Type,\n\t\tType: tf.Type,\n\t\tType: tf.Type,\n\t\tType: tf.Type,\n\t\tType: tf.Type,\n\t\tType: tf.Type,\n\t\tType: tf.Type,\n\t\tType: tf.Type,\n\t\tType: tf.Type,\n\t\tType:  tf.Type,\n\t}\n}"}
{"input": "\nfunc BindNetworkArgs(args *NetworkArgs, flags *pflag.FlagSet, prefix string) {\n\tflags.StringVar(&args.NetworkPluginName, prefix+\"network-plugin\", args.NetworkPluginName, \"The name of the networking plugin to be used for networking.\")\n\tflags.StringVar(&args.ClusterNetworkCIDR, prefix+\"network-cidr\", args.ClusterNetworkCIDR, \"The CIDR string representing the network that all containers should belong to.\")\n\tflags.Uint32Var(&args.HostSubnetLength, prefix+\"host-subnet-length\", args.HostSubnetLength, \"The length of subnet each host is given from the network-cidr.\")\n\tflags.StringVar(&args.ServiceNetworkCIDR, prefix+\"portal-net\", args.ServiceNetworkCIDR, \"The CIDR string representing the network that portal/service IPs will be assigned from. This must not overlap with any IP ranges assigned to nodes for pods.\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func qsortInt(nums []int) []int {\n\tif len(nums) <= 1 {\n\t\treturn nums\n\t}\n\n\thead, tail := 0, len(nums)-1\n\tidx, mid := 1, nums[0]\n\tfor head < tail {\n\t\tif nums[idx] > mid {\n\t\t\tnums[idx], nums[tail] = nums[tail], nums[idx]\n\t\t\ttail--\n\t\t} else {\n\t\t\tnums[idx], nums[head] = nums[head], nums[idx]\n\t\t\thead++\n\t\t\tidx++\n\t\t}\n\t}\n\tnums[head] = mid\n\tqsortInt(nums[:head])\n\tqsortInt(nums[head+1:])\n\treturn nums\n}\nfunc BindNetworkArgs(args *NetworkArgs, flags *pflag.FlagSet, prefix string) {\n\tflags.StringVar(&args.NetworkPluginName, prefix+\"network-plugin\", args.NetworkPluginName, \"The name of the networking plugin to be used for networking.\")\n\tflags.StringVar(&args.ClusterNetworkCIDR, prefix+\"network-cidr\", args.ClusterNetworkCIDR, \"The CIDR string representing the network that all containers should belong to.\")\n\tflags.Uint32Var(&args.HostSubnetLength, prefix+\"host-subnet-length\", args.HostSubnetLength, \"The length of subnet each host is given from the network-cidr.\")\n\tflags.StringVar(&args.ServiceNetworkCIDR, prefix+\"portal-net\", args.ServiceNetworkCIDR, \"The CIDR string representing the network that portal/service IPs will be assigned from. This must not overlap with any IP ranges assigned to nodes for pods.\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (b NDPNeighborSolicit) TargetAddress() tcpip.Address {\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}\nfunc qsortInt(nums []int) []int {\n\tif len(nums) <= 1 {\n\t\treturn nums\n\t}\n\n\thead, tail := 0, len(nums)-1\n\tidx, mid := 1, nums[0]\n\tfor head < tail {\n\t\tif nums[idx] > mid {\n\t\t\tnums[idx], nums[tail] = nums[tail], nums[idx]\n\t\t\ttail--\n\t\t} else {\n\t\t\tnums[idx], nums[head] = nums[head], nums[idx]\n\t\t\thead++\n\t\t\tidx++\n\t\t}\n\t}\n\tnums[head] = mid\n\tqsortInt(nums[:head])\n\tqsortInt(nums[head+1:])\n\treturn nums\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (p *paramHeader) marshal() ([]byte, error) {\n\tparamLengthPlusHeader := paramHeaderLength + len(p.raw)\n\n\trawParam := make([]byte, paramLengthPlusHeader)\n\tbinary.BigEndian.PutUint16(rawParam[0:], uint16(p.typ))\n\tbinary.BigEndian.PutUint16(rawParam[2:], uint16(paramLengthPlusHeader))\n\tcopy(rawParam[paramHeaderLength:], p.raw)\n\n\treturn rawParam, nil\n}\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\nfunc (p *paramHeader) marshal() ([]byte, error) {\n\tparamLengthPlusHeader := paramHeaderLength + len(p.raw)\n\n\trawParam := make([]byte, paramLengthPlusHeader)\n\tbinary.BigEndian.PutUint16(rawParam[0:], uint16(p.typ))\n\tbinary.BigEndian.PutUint16(rawParam[2:], uint16(paramLengthPlusHeader))\n\tcopy(rawParam[paramHeaderLength:], p.raw)\n\n\treturn rawParam, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (this *SubjectParser) Parse() (sh header.Header, ParseException error) {\n\tsubject := header.NewSubject()\n\n\tlexer := this.GetLexer()\n\tthis.HeaderName(TokenTypes_SUBJECT)\n\n\tlexer.SPorHT()\n\n\ts := lexer.GetRest()\n\tsubject.SetSubject(strings.TrimSpace(s))\n\n\treturn subject, nil\n}\nfunc (p *paramHeader) marshal() ([]byte, error) {\n\tparamLengthPlusHeader := paramHeaderLength + len(p.raw)\n\n\trawParam := make([]byte, paramLengthPlusHeader)\n\tbinary.BigEndian.PutUint16(rawParam[0:], uint16(p.typ))\n\tbinary.BigEndian.PutUint16(rawParam[2:], uint16(paramLengthPlusHeader))\n\tcopy(rawParam[paramHeaderLength:], p.raw)\n\n\treturn rawParam, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (cmd *StopPolicy) Metadata() command_metadata.CommandMetadata {\n\treturn command_metadata.CommandMetadata{\n\t\tName:        \"stop-policy\",\n\t\tDescription: \"Suspends a policy\",\n\t\tUsage:       \"BROOKLYN_NAME SCOPE stop-policy POLICY\",\n\t\tFlags:       []cli.Flag{},\n\t}\n}\nfunc (this *SubjectParser) Parse() (sh header.Header, ParseException error) {\n\tsubject := header.NewSubject()\n\n\tlexer := this.GetLexer()\n\tthis.HeaderName(TokenTypes_SUBJECT)\n\n\tlexer.SPorHT()\n\n\ts := lexer.GetRest()\n\tsubject.SetSubject(strings.TrimSpace(s))\n\n\treturn subject, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas := tfjson.ProviderSchemas{\n\t\tType:    tfjson.TypeProviderSchemas,\n\t\tSchema: tfjson.TypeProviderSchemas,\n\t}\n\n\treturn providerSchemas, nil\n}"}
{"input": "\nfunc (cmd *StopPolicy) Metadata() command_metadata.CommandMetadata {\n\treturn command_metadata.CommandMetadata{\n\t\tName:        \"stop-policy\",\n\t\tDescription: \"Suspends a policy\",\n\t\tUsage:       \"BROOKLYN_NAME SCOPE stop-policy POLICY\",\n\t\tFlags:       []cli.Flag{},\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tType:    tfjson.TypeStopPolicy,\n\t\tSchema: tfjson.TypeProviderSchemas,\n\t}, nil\n}"}
{"input": "func (m *CommandUsage) getUsage(cargo interface{}) statemachiner.StateFn {\n\to := cloudsigma.NewUsage()\n\targs := o.NewList()\n\tm.channels.MessageChan <- fmt.Sprintf(\"Using username: %s\", session.Username)\n\targs.Username = session.Username\n\targs.Password = session.Password\n\targs.Location = session.Location\n\t_ = sendRequest(m.channels, args)\n\treturn nil\n}\nfunc (cmd *StopPolicy) Metadata() command_metadata.CommandMetadata {\n\treturn command_metadata.CommandMetadata{\n\t\tName:        \"stop-policy\",\n\t\tDescription: \"Suspends a policy\",\n\t\tUsage:       \"BROOKLYN_NAME SCOPE stop-policy POLICY\",\n\t\tFlags:       []cli.Flag{},\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\nfunc (m *CommandUsage) getUsage(cargo interface{}) statemachiner.StateFn {\n\to := cloudsigma.NewUsage()\n\targs := o.NewList()\n\tm.channels.MessageChan <- fmt.Sprintf(\"Using username: %s\", session.Username)\n\targs.Username = session.Username\n\targs.Password = session.Password\n\targs.Location = session.Location\n\t_ = sendRequest(m.channels, args)\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc (a *Iterator) Size() int {\n\treturn len(*a.data)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (v *Variable) String() string {\n\tif !v.IsSystem {\n\t\treturn \"@\" + v.Name\n\t}\n\tif v.IsGlobal {\n\t\treturn \"@@GLOBAL.\" + v.Name\n\t}\n\treturn \"@@\" + v.Name\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func transMatrixFromHPDFTransMatrix(transMatrix C.HPDF_TransMatrix) *TransMatrix {\n\treturn &TransMatrix{\n\t\tfloat32(transMatrix.a),\n\t\tfloat32(transMatrix.b),\n\t\tfloat32(transMatrix.c),\n\t\tfloat32(transMatrix.d),\n\t\tfloat32(transMatrix.x),\n\t\tfloat32(transMatrix.y),\n\t}\n}\nfunc (v *Variable) String() string {\n\tif !v.IsSystem {\n\t\treturn \"@\" + v.Name\n\t}\n\tif v.IsGlobal {\n\t\treturn \"@@GLOBAL.\" + v.Name\n\t}\n\treturn \"@@\" + v.Name\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tType:  tfjson.TypeProviderSchemas,\n\t\tSchema: tfjson.TypeProviderSchemas,\n\t}, nil\n}"}
{"input": "\nfunc transMatrixFromHPDFTransMatrix(transMatrix C.HPDF_TransMatrix) *TransMatrix {\n\treturn &TransMatrix{\n\t\tfloat32(transMatrix.a),\n\t\tfloat32(transMatrix.b),\n\t\tfloat32(transMatrix.c),\n\t\tfloat32(transMatrix.d),\n\t\tfloat32(transMatrix.x),\n\t\tfloat32(transMatrix.y),\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (u *Up) Ingest() error {\n\treturn filepath.Walk(u.SourceDirectory, u.IngestFile)\n}\nfunc transMatrixFromHPDFTransMatrix(transMatrix C.HPDF_TransMatrix) *TransMatrix {\n\treturn &TransMatrix{\n\t\tfloat32(transMatrix.a),\n\t\tfloat32(transMatrix.b),\n\t\tfloat32(transMatrix.c),\n\t\tfloat32(transMatrix.d),\n\t\tfloat32(transMatrix.x),\n\t\tfloat32(transMatrix.y),\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tSourceDirectory: filepath.Join(tf.SourceDirectory, tf.ProviderDirectory),\n\t\tSourceDirectory: filepath.Join(tf.SourceDirectory, tf.ProviderDirectory),\n\t\tSourceDirectory: filepath.Join(tf.SourceDirectory, tf.ProviderDirectory),\n\t\tSourceDirectory: filepath.Join(tf.SourceDirectory, tf.ProviderDirectory),\n\t\tSourceDirectory: filepath.Join(tf.SourceDirectory, tf.ProviderDirectory),\n\t\tSourceDirectory: filepath.Join(tf.SourceDirectory, tf.ProviderDirectory),\n\t\tSourceDirectory: filepath.Join(tf.SourceDirectory, tf.ProviderDirectory),\n\t\tSourceDirectory: filepath.Join(tf.SourceDirectory, tf.ProviderDirectory),\n\t\tSourceDirectory: filepath.Join(tf.SourceDirectory, tf.ProviderDirectory),\n\t\tSourceDirectory: filepath.Join(tf.SourceDirectory, tf.ProviderDirectory),\n\t\tSourceDirectory: filepath.Join(tf.SourceDirectory, tf.ProviderDirectory),\n\t}\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc (u *Up) Ingest() error {\n\treturn filepath.Walk(u.SourceDirectory, u.IngestFile)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvider: &tfjson.ProviderSchemas{\n\t\t\tDigest: tf.Digest,\n\t\t\tDigest: tf.Digest,\n\t\t\tDigest: tf.Digest,\n\t\t},\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (b *BaseController) display(tpl ...string) {\n\tvar tplname string\n\tif len(tpl) > 0 {\n\t\ttplname = tpl[0] + \".html\"\n\t} else {\n\t\ttplname = b.controllerName + \"/\" + b.actionName + \".html\"\n\t}\n\tb.Layout = \"layout.html\"\n\tb.TplName = tplname\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProvidersSchema(ctx)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc (b *BaseController) display(tpl ...string) {\n\tvar tplname string\n\tif len(tpl) > 0 {\n\t\ttplname = tpl[0] + \".html\"\n\t} else {\n\t\ttplname = b.controllerName + \"/\" + b.actionName + \".html\"\n\t}\n\tb.Layout = \"layout.html\"\n\tb.TplName = tplname\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc Serve(addr string, data fs.FS) error {\n\tdata, err := fs.Sub(data, \"docs\")\n\tif err != nil {\n\t\treturn err\n\t}\n\thttp.Handle(\"/\", http.FileServer(http.FS(data)))\n\treturn http.ListenAndServe(addr, logRequest(http.DefaultServeMux))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func (s *SourceSelector) String() string {\n\tif s == nil {\n\t\treturn \"\"\n\t}\n\tresult := []string{s.ResId.String()}\n\tif s.FieldPath != \"\" {\n\t\tresult = append(result, s.FieldPath)\n\t}\n\tif opts := s.Options.String(); opts != \"\" {\n\t\tresult = append(result, opts)\n\t}\n\treturn strings.Join(result, \":\")\n}\nfunc Serve(addr string, data fs.FS) error {\n\tdata, err := fs.Sub(data, \"docs\")\n\tif err != nil {\n\t\treturn err\n\t}\n\thttp.Handle(\"/\", http.FileServer(http.FS(data)))\n\treturn http.ListenAndServe(addr, logRequest(http.DefaultServeMux))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.Config.ProvidersSchema)\n}"}
{"input": "func (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\nfunc (s *SourceSelector) String() string {\n\tif s == nil {\n\t\treturn \"\"\n\t}\n\tresult := []string{s.ResId.String()}\n\tif s.FieldPath != \"\" {\n\t\tresult = append(result, s.FieldPath)\n\t}\n\tif opts := s.Options.String(); opts != \"\" {\n\t\tresult = append(result, opts)\n\t}\n\treturn strings.Join(result, \":\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func limitRelease() {\n\tselect {\n\tcase <-limitSem:\n\tdefault:\n\t\tlog.Print(\"appengine: unbalanced limitSem release!\")\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\nfunc limitRelease() {\n\tselect {\n\tcase <-limitSem:\n\tdefault:\n\t\tlog.Print(\"appengine: unbalanced limitSem release!\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.pltr().ProvidersSchema()\n}"}
{"input": "\nfunc IsSquare(m Matrix) bool {\n\treturn m.Rows() == m.Columns()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (shape *Shape) AABB() AABB {\n\treturn shape.BB\n}\nfunc IsSquare(m Matrix) bool {\n\treturn m.Rows() == m.Columns()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\nfunc (shape *Shape) AABB() AABB {\n\treturn shape.BB\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.pltr().ProvidersSchema()\n}"}
{"input": "\nfunc (n NatGateways) List(filter string) ([]common.Deletable, error) {\n\tnatGateways, err := n.client.DescribeNatGateways(&awsec2.DescribeNatGatewaysInput{\n\t\tFilter: []*awsec2.Filter{{\n\t\t\tName:   aws.String(\"state\"),\n\t\t\tValues: []*string{aws.String(\"pending\"), aws.String(\"available\")},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Describing EC2 Nat Gateways: %s\", err)\n\t}\n\n\tvar resources []common.Deletable\n\tfor _, g := range natGateways.NatGateways {\n\t\tr := NewNatGateway(n.client, n.logger, g.NatGatewayId, g.Tags)\n\n\t\tif !strings.Contains(r.Name(), filter) {\n\t\t\tcontinue\n\t\t}\n\n\t\tproceed := n.logger.PromptWithDetails(r.Type(), r.Name())\n\t\tif !proceed {\n\t\t\tcontinue\n\t\t}\n\n\t\tresources = append(resources, r)\n\t}\n\n\treturn resources, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc LabelAsManagedConfigMap(config *v1.ConfigMap, certificateType CertificateType) {\n\tif config.Labels == nil {\n\t\tconfig.Labels = map[string]string{}\n\t}\n\tconfig.Labels[ManagedCertificateTypeLabelName] = string(certificateType)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func filterInLabels(filter, labels map[string]string) bool {\n\tfor k, v := range filter {\n\t\tif value, ok := labels[k]; ok {\n\t\t\tif value != v {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\nfunc LabelAsManagedConfigMap(config *v1.ConfigMap, certificateType CertificateType) {\n\tif config.Labels == nil {\n\t\tconfig.Labels = map[string]string{}\n\t}\n\tconfig.Labels[ManagedCertificateTypeLabelName] = string(certificateType)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc filterInLabels(filter, labels map[string]string) bool {\n\tfor k, v := range filter {\n\t\tif value, ok := labels[k]; ok {\n\t\t\tif value != v {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (c *userIdentityMappings) Delete(name string) (err error) {\n\terr = c.r.Delete().Resource(\"userIdentityMappings\").Name(name).Do().Error()\n\treturn\n}\nfunc filterInLabels(filter, labels map[string]string) bool {\n\tfor k, v := range filter {\n\t\tif value, ok := labels[k]; ok {\n\t\t\tif value != v {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.r.ProvidersSchema(ctx)\n}"}
{"input": "func parseARPEntries(data []byte) ([]ARPEntry, error) {\n\tlines := strings.Split(string(data), \"\\n\")\n\tentries := make([]ARPEntry, 0)\n\tvar err error\n\tconst (\n\t\texpectedDataWidth   = 6\n\t\texpectedHeaderWidth = 9\n\t)\n\tfor _, line := range lines {\n\t\tcolumns := strings.Fields(line)\n\t\twidth := len(columns)\n\n\t\tif width == expectedHeaderWidth || width == 0 {\n\t\t\tcontinue\n\t\t} else if width == expectedDataWidth {\n\t\t\tentry, err := parseARPEntry(columns)\n\t\t\tif err != nil {\n\t\t\t\treturn []ARPEntry{}, fmt.Errorf(\"failed to parse ARP entry: %s\", err)\n\t\t\t}\n\t\t\tentries = append(entries, entry)\n\t\t} else {\n\t\t\treturn []ARPEntry{}, fmt.Errorf(\"%d columns were detected, but %d were expected\", width, expectedDataWidth)\n\t\t}\n\n\t}\n\n\treturn entries, err\n}\nfunc (c *userIdentityMappings) Delete(name string) (err error) {\n\terr = c.r.Delete().Resource(\"userIdentityMappings\").Name(name).Do().Error()\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.r.ProvidersSchema(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc init() {\n\texec := func() {\n\t\tdefer libvirt.CleanupLibvirtConnections()\n\n\t\tplugin.Serve(&plugin.ServeOpts{\n\t\t\tProviderFunc: libvirt.Provider,\n\t\t})\n\t}\n\tKnownPlugins[\"terraform-provider-libvirt\"] = exec\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderFunc: tf.ProviderFunc,\n\t}, nil\n}"}
{"input": "func (r *AWSECSService_NetworkConfiguration) DependsOn() []string {\n\treturn r._dependsOn\n}\nfunc init() {\n\texec := func() {\n\t\tdefer libvirt.CleanupLibvirtConnections()\n\n\t\tplugin.Serve(&plugin.ServeOpts{\n\t\t\tProviderFunc: libvirt.Provider,\n\t\t})\n\t}\n\tKnownPlugins[\"terraform-provider-libvirt\"] = exec\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc wrapApplicationSimple(v *gtk.Application) *application {\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn &application{gliba.WrapApplicationSimple(&v.Application), v}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc unescape(encoding string) {\n\tswitch {\n\tcase strings.HasPrefix(\"query\", encoding):\n\t\tb, err := ioutil.ReadAll(os.Stdin)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\ts, err := url.QueryUnescape(string(b))\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tos.Stdout.Write([]byte(s))\n\tcase strings.HasPrefix(\"b32\", encoding):\n\t\td := base32.NewDecoder(base32.StdEncoding, os.Stdin)\n\t\tio.Copy(os.Stdout, d)\n\tdefault:\n\t\tfmt.Fprintf(os.Stderr, \"unknown unescape encoding: %q\\n\", encoding)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (msg *RtMsg) Serialize() []byte {\n\treturn (*(*[syscall.SizeofRtMsg]byte)(unsafe.Pointer(msg)))[:]\n}\nfunc unescape(encoding string) {\n\tswitch {\n\tcase strings.HasPrefix(\"query\", encoding):\n\t\tb, err := ioutil.ReadAll(os.Stdin)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\ts, err := url.QueryUnescape(string(b))\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tos.Stdout.Write([]byte(s))\n\tcase strings.HasPrefix(\"b32\", encoding):\n\t\td := base32.NewDecoder(base32.StdEncoding, os.Stdin)\n\t\tio.Copy(os.Stdout, d)\n\tdefault:\n\t\tfmt.Fprintf(os.Stderr, \"unknown unescape encoding: %q\\n\", encoding)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (msg *RtMsg) Serialize() []byte {\n\treturn (*(*[syscall.SizeofRtMsg]byte)(unsafe.Pointer(msg)))[:]\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func Parse(rules string) (*Policy, error) {\n\tp := &Policy{Raw: rules}\n\tif err := hcl.Decode(p, rules); err != nil {\n\t\treturn nil, fmt.Errorf(\"Failed to parse ACL rules: %v\", err)\n\t}\n\n\tfor _, pp := range p.Paths {\n\t\tswitch pp.Policy {\n\t\tcase PathPolicyDeny:\n\t\tcase PathPolicyRead:\n\t\tcase PathPolicyWrite:\n\t\tcase PathPolicySudo:\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Invalid path policy: %#v\", pp)\n\t\t}\n\t}\n\treturn p, nil\n}\nfunc (msg *RtMsg) Serialize() []byte {\n\treturn (*(*[syscall.SizeofRtMsg]byte)(unsafe.Pointer(msg)))[:]\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"providerschemas\",\n\t\tSchema: tfjson.NewSchema(ctx),\n\t}, nil\n}"}
{"input": "func (i *DefaultDecorator) ToString(field interface{}) (string, error) {\n\treturn fmt.Sprintf(\"%v\", field), nil\n}\nfunc Parse(rules string) (*Policy, error) {\n\tp := &Policy{Raw: rules}\n\tif err := hcl.Decode(p, rules); err != nil {\n\t\treturn nil, fmt.Errorf(\"Failed to parse ACL rules: %v\", err)\n\t}\n\n\tfor _, pp := range p.Paths {\n\t\tswitch pp.Policy {\n\t\tcase PathPolicyDeny:\n\t\tcase PathPolicyRead:\n\t\tcase PathPolicyWrite:\n\t\tcase PathPolicySudo:\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Invalid path policy: %#v\", pp)\n\t\t}\n\t}\n\treturn p, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviders: tfjson.NewProvidersSchema(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func NewListUsersParams() ListUsersParams {\n\n\treturn ListUsersParams{}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\nfunc NewListUsersParams() ListUsersParams {\n\n\treturn ListUsersParams{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc (s *SettlementStatus10Choice) AddPending() *PendingStatus15Choice {\n\ts.Pending = new(PendingStatus15Choice)\n\treturn s.Pending\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (r *Response) Written() bool {\n\treturn r.status != 0 || r.size != 0\n}\nfunc (s *SettlementStatus10Choice) AddPending() *PendingStatus15Choice {\n\ts.Pending = new(PendingStatus15Choice)\n\treturn s.Pending\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\nfunc (r *Response) Written() bool {\n\treturn r.status != 0 || r.size != 0\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc (s *SettlementStatus10Choice) AddPending() *PendingStatus15Choice {\n\ts.Pending = new(PendingStatus15Choice)\n\treturn s.Pending\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func Connection(settings ElasticSettings) *elastigo.Conn {\n\tc := elastigo.NewConn()\n\tc.Domain = settings.Host\n\tc.Port = string(settings.Port)\n\treturn c\n}\nfunc (s *SettlementStatus10Choice) AddPending() *PendingStatus15Choice {\n\ts.Pending = new(PendingStatus15Choice)\n\treturn s.Pending\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (i *DefaultDecorator) ToString(field interface{}) (string, error) {\n\treturn fmt.Sprintf(\"%v\", field), nil\n}\nfunc Connection(settings ElasticSettings) *elastigo.Conn {\n\tc := elastigo.NewConn()\n\tc.Domain = settings.Host\n\tc.Port = string(settings.Port)\n\treturn c\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc findLongestChain(pairs [][]int) int {\n\tvar p segList\n\tn := len(pairs)\n\tfor i := 0; i < n; i++ {\n\t\tp = append(p, Seg{pairs[i][0], pairs[i][1]})\n\t}\n\tsort.Sort(p)\n\tr := p[0].r\n\tans := 1\n\tfor i := 1; i < n; i++ {\n\t\tif p[i].l > r {\n\t\t\tr = p[i].r\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (o beforeCall) before(c *callInfo) error { return o(c) }\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func main() {\n\tfmt.Println(\"starting server\")\n\thttp.HandleFunc(\"/\", DoRequest)\n\thttp.ListenAndServe(\":9090\", nil)\n\tfmt.Println(\"ending server\")\n}\nfunc (o beforeCall) before(c *callInfo) error { return o(c) }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc main() {\n\tfmt.Println(\"starting server\")\n\thttp.HandleFunc(\"/\", DoRequest)\n\thttp.ListenAndServe(\":9090\", nil)\n\tfmt.Println(\"ending server\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m LocVelDistTraveledMessage) Type() uint {\n\treturn LocVelDistTraveledMessageType\n}\nfunc main() {\n\tfmt.Println(\"starting server\")\n\thttp.HandleFunc(\"/\", DoRequest)\n\thttp.ListenAndServe(\":9090\", nil)\n\tfmt.Println(\"ending server\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (s *OSSuite) TearDownTest(c *C) {\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}\nfunc (m LocVelDistTraveledMessage) Type() uint {\n\treturn LocVelDistTraveledMessageType\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func MarkControlPlane(client clientset.Interface, controlPlaneName string, taints []v1.Taint) error {\n\n\tfmt.Printf(\"[mark-control-plane] Marking the node %s as control-plane by adding the label \\\"%s=''\\\"\\n\", controlPlaneName, constants.LabelNodeRoleMaster)\n\n\tif taints != nil && len(taints) > 0 {\n\t\ttaintStrs := []string{}\n\t\tfor _, taint := range taints {\n\t\t\ttaintStrs = append(taintStrs, taint.ToString())\n\t\t}\n\t\tfmt.Printf(\"[mark-control-plane] Marking the node %s as control-plane by adding the taints %v\\n\", controlPlaneName, taintStrs)\n\t}\n\n\treturn apiclient.PatchNode(client, controlPlaneName, func(n *v1.Node) {\n\t\tmarkControlPlaneNode(n, taints)\n\t})\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"provider\",\n\t\tName: \"provider\",\n\t\tDescription: \"The provider schema for the given node\",\n\t\tSchema: tfjson.Schema{\n\t\t\tName: \"provider\",\n\t\t\tType: \"provider\",\n\t\t\tDescription: \"The provider schema for the given node\",\n\t\t\tType: \"provider\",\n\t\t\tType: \"provider\",\n\t\t\tType: \"provider\",\n\t\t\tType: \"provider\",\n\t\t\tName: \"provider\",\n\t\t\tType: \"provider\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (s *OSSuite) TearDownTest(c *C) {\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}\nfunc MarkControlPlane(client clientset.Interface, controlPlaneName string, taints []v1.Taint) error {\n\n\tfmt.Printf(\"[mark-control-plane] Marking the node %s as control-plane by adding the label \\\"%s=''\\\"\\n\", controlPlaneName, constants.LabelNodeRoleMaster)\n\n\tif taints != nil && len(taints) > 0 {\n\t\ttaintStrs := []string{}\n\t\tfor _, taint := range taints {\n\t\t\ttaintStrs = append(taintStrs, taint.ToString())\n\t\t}\n\t\tfmt.Printf(\"[mark-control-plane] Marking the node %s as control-plane by adding the taints %v\\n\", controlPlaneName, taintStrs)\n\t}\n\n\treturn apiclient.PatchNode(client, controlPlaneName, func(n *v1.Node) {\n\t\tmarkControlPlaneNode(n, taints)\n\t})\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"providerschemas\",\n\t\tName: \"providers\",\n\t\tType: \"provider\",\n\t\tDescription: \"The provider schemas for the given node\",\n\t\tSchema: tfjson.Schema{\n\t\t\tName: \"providers\",\n\t\t\tType: \"provider\",\n\t\t\tName: \"providers\",\n\t\t\tDescription: \"The provider schemas for the given node\",\n\t\t\tDescription: \"The provider schemas for the given node\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (s *OSSuite) TearDownTest(c *C) {\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (s *OSSuite) TearDownTest(c *C) {\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}\nfunc runAboutDialog(res *gui.Resource, parent winapi.HWND) {\n\tvar dlg aboutDialog\n\tdlg.Reg()\n\tdlg.DlgBox(res.Get(), \"AboutDlg\", parent)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providers\",\n\t\t\tType: \"application/json\",\n\t\t\tName: \"application/json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func IfString(condition bool, trueVal, falseVal string) string {\n\tif condition {\n\t\treturn trueVal\n\t}\n\treturn falseVal\n}\nfunc runAboutDialog(res *gui.Resource, parent winapi.HWND) {\n\tvar dlg aboutDialog\n\tdlg.Reg()\n\tdlg.DlgBox(res.Get(), \"AboutDlg\", parent)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc IfString(condition bool, trueVal, falseVal string) string {\n\tif condition {\n\t\treturn trueVal\n\t}\n\treturn falseVal\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func Version() string {\n\treturn \"v10.3.0-beta\"\n}\nfunc IfString(condition bool, trueVal, falseVal string) string {\n\tif condition {\n\t\treturn trueVal\n\t}\n\treturn falseVal\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (l *Login) Post(res http.ResponseWriter, req *http.Request, _ httprouter.Params) {\n\tinfo, err := l.Login.ParseBodyInfo(req)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t}\n\terr = l.Authentication.ValidateCredentials(info.Email, info.Password)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t} else {\n\t\tl.Authentication.LogInUser(info.Email, res)\n\t}\n\thttp.Redirect(res, req, \"/admin\", http.StatusFound)\n}\nfunc Version() string {\n\treturn \"v10.3.0-beta\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providers\",\n\t\t\tPassword: \"Password\",\n\t\t\tEmail: \"email\",\n\t\t\tPassword: \"Password\",\n\t\t},\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc RegisterInitializer(initializer Initializer) {\n\tinitializerList = append(initializerList, initializer)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (l *Login) Post(res http.ResponseWriter, req *http.Request, _ httprouter.Params) {\n\tinfo, err := l.Login.ParseBodyInfo(req)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t}\n\terr = l.Authentication.ValidateCredentials(info.Email, info.Password)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t} else {\n\t\tl.Authentication.LogInUser(info.Email, res)\n\t}\n\thttp.Redirect(res, req, \"/admin\", http.StatusFound)\n}\nfunc RegisterInitializer(initializer Initializer) {\n\tinitializerList = append(initializerList, initializer)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tschemas, err := tf.ProviderSchemas(ctx)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn schemas, nil\n}"}
{"input": "\nfunc (l *Login) Post(res http.ResponseWriter, req *http.Request, _ httprouter.Params) {\n\tinfo, err := l.Login.ParseBodyInfo(req)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t}\n\terr = l.Authentication.ValidateCredentials(info.Email, info.Password)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t} else {\n\t\tl.Authentication.LogInUser(info.Email, res)\n\t}\n\thttp.Redirect(res, req, \"/admin\", http.StatusFound)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providerschemas\",\n\t\t\tPassword: \"password\",\n\t\t\tEmail: \"email\",\n\t\t\tPassword: \"password\",\n\t\t},\n\t}, nil\n}"}
{"input": "func hashSha512(data []byte) string {\n\tsum := sha512.Sum512(data)\n\treturn base64.StdEncoding.EncodeToString(sum[:])\n}\nfunc (l *Login) Post(res http.ResponseWriter, req *http.Request, _ httprouter.Params) {\n\tinfo, err := l.Login.ParseBodyInfo(req)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t}\n\terr = l.Authentication.ValidateCredentials(info.Email, info.Password)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t} else {\n\t\tl.Authentication.LogInUser(info.Email, res)\n\t}\n\thttp.Redirect(res, req, \"/admin\", http.StatusFound)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providerschemas\",\n\t\t\tPassword: \"password\",\n\t\t},\n\t}, nil\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc hashSha512(data []byte) string {\n\tsum := sha512.Sum512(data)\n\treturn base64.StdEncoding.EncodeToString(sum[:])\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProvider: &tfjson.ProviderSchemas{\n\t\t\tName: \"provider\",\n\t\t\tType: \"json\",\n\t\t\tName: \"provider\",\n\t\t\tType: \"json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\nfunc (col *StatusesCollection) List(params interface{}) (*Statuses, *http.Response, []byte, error) {\n\tvar statuses Statuses\n\tresp, body, err := col.client.List(col.url, params, &statuses)\n\treturn &statuses, resp, body, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProvidersSchema(ctx)\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc (col *StatusesCollection) List(params interface{}) (*Statuses, *http.Response, []byte, error) {\n\tvar statuses Statuses\n\tresp, body, err := col.client.List(col.url, params, &statuses)\n\treturn &statuses, resp, body, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (s segList) Less(i, j int) bool { return s[i].r < s[j].r }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (s singularSecretary) CheckHolder(name string) error {\n\tif _, err := names.ParseMachineTag(name); err != nil {\n\t\treturn errors.New(\"expected machine tag\")\n\t}\n\treturn nil\n}\nfunc (s segList) Less(i, j int) bool { return s[i].r < s[j].r }\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc cloneParameter(src, dest interface{}) error {\n\treturn mapconvDecoder.ConvertTo(src, dest)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (m secretrule) String() string {\n\treturn common.PointerString(m)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func Every(duration time.Duration, job cron.Job) {\n\tMainCron.Schedule(cron.Every(duration), New(job))\n}\nfunc (m secretrule) String() string {\n\treturn common.PointerString(m)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestManager(t *testing.T) {\n\tr := &fakereg{}\n\tmgrs := []aspectsupport.Manager{&fakemgr{kind: \"k1\"}, &fakemgr{kind: \"k2\"}}\n\tm := NewManager(r, mgrs)\n\tcfg := &aspectsupport.CombinedConfig{\n\t\tAspect:  &istioconfig.Aspect{},\n\t\tAdapter: &istioconfig.Adapter{},\n\t}\n\tattrs := &fakebag{}\n\tmapper := &fakeevaluator{}\n\tif _, err := m.Execute(cfg, attrs, mapper); err != nil {\n\t\tif !strings.Contains(err.Error(), \"could not find aspect manager\") {\n\t\t\tt.Error(\"excute errored out: \", err)\n\t\t}\n\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func TestManager(t *testing.T) {\n\tr := &fakereg{}\n\tmgrs := []aspectsupport.Manager{&fakemgr{kind: \"k1\"}, &fakemgr{kind: \"k2\"}}\n\tm := NewManager(r, mgrs)\n\tcfg := &aspectsupport.CombinedConfig{\n\t\tAspect:  &istioconfig.Aspect{},\n\t\tAdapter: &istioconfig.Adapter{},\n\t}\n\tattrs := &fakebag{}\n\tmapper := &fakeevaluator{}\n\tif _, err := m.Execute(cfg, attrs, mapper); err != nil {\n\t\tif !strings.Contains(err.Error(), \"could not find aspect manager\") {\n\t\t\tt.Error(\"excute errored out: \", err)\n\t\t}\n\n\t}\n}\nfunc (a *Account20) SetIdentification(value string) {\n\ta.Identification = (*Max35Text)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func Every(duration time.Duration, job cron.Job) {\n\tMainCron.Schedule(cron.Every(duration), New(job))\n}\nfunc (a *Account20) SetIdentification(value string) {\n\ta.Identification = (*Max35Text)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (m *MiddlewareContextVars) ProcessRequest(w http.ResponseWriter, r *http.Request, _ interface{}) (error, int) {\n\n\tif !m.Spec.EnableContextVars {\n\t\treturn nil, 200\n\t}\n\n\tcopiedRequest := CopyHttpRequest(r)\n\tcontextDataObject := make(map[string]interface{})\n\n\tcopiedRequest.ParseForm()\n\n\tcontextDataObject[\"request_data\"] = copiedRequest.Form\n\n\tcontextDataObject[\"headers\"] = map[string][]string(copiedRequest.Header)\n\n\tfor hname, vals := range copiedRequest.Header {\n\t\tn := \"headers_\" + strings.Replace(hname, \"-\", \"_\", -1)\n\t\tcontextDataObject[n] = vals[0]\n\t}\n\n\tsegmentedPathArray := strings.Split(copiedRequest.URL.Path, \"/\")\n\tcontextDataObject[\"path_parts\"] = segmentedPathArray\n\n\tcontextDataObject[\"path\"] = copiedRequest.URL.Path\n\n\tcontextDataObject[\"remote_addr\"] = copiedRequest.RemoteAddr\n\n\tcontextDataObject[\"request_id\"] = uuid.NewV4().String()\n\n\tctxSetData(r, contextDataObject)\n\n\treturn nil, 200\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func init() {\n\tvar v TriggerType\n\tif _, ok := interface{}(v).(fmt.Stringer); ok {\n\t\t_TriggerTypeNameToValue = map[string]TriggerType{\n\t\t\tinterface{}(TriggerTypeDefault).(fmt.Stringer).String(): TriggerTypeDefault,\n\t\t\tinterface{}(TriggerTypePoll).(fmt.Stringer).String():    TriggerTypePoll,\n\t\t}\n\t}\n}\nfunc (m *MiddlewareContextVars) ProcessRequest(w http.ResponseWriter, r *http.Request, _ interface{}) (error, int) {\n\n\tif !m.Spec.EnableContextVars {\n\t\treturn nil, 200\n\t}\n\n\tcopiedRequest := CopyHttpRequest(r)\n\tcontextDataObject := make(map[string]interface{})\n\n\tcopiedRequest.ParseForm()\n\n\tcontextDataObject[\"request_data\"] = copiedRequest.Form\n\n\tcontextDataObject[\"headers\"] = map[string][]string(copiedRequest.Header)\n\n\tfor hname, vals := range copiedRequest.Header {\n\t\tn := \"headers_\" + strings.Replace(hname, \"-\", \"_\", -1)\n\t\tcontextDataObject[n] = vals[0]\n\t}\n\n\tsegmentedPathArray := strings.Split(copiedRequest.URL.Path, \"/\")\n\tcontextDataObject[\"path_parts\"] = segmentedPathArray\n\n\tcontextDataObject[\"path\"] = copiedRequest.URL.Path\n\n\tcontextDataObject[\"remote_addr\"] = copiedRequest.RemoteAddr\n\n\tcontextDataObject[\"request_id\"] = uuid.NewV4().String()\n\n\tctxSetData(r, contextDataObject)\n\n\treturn nil, 200\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc keyFn(key beam.T, _ func(*int) bool) beam.T {\n\treturn key\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (thread *Thread) PC() (uint64, error) {\n\tregs, err := thread.Registers()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn regs.PC(), nil\n}\nfunc keyFn(key beam.T, _ func(*int) bool) beam.T {\n\treturn key\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProvidersSchema(ctx)\n}"}
{"input": "func init() {\n\tvar v TriggerType\n\tif _, ok := interface{}(v).(fmt.Stringer); ok {\n\t\t_TriggerTypeNameToValue = map[string]TriggerType{\n\t\t\tinterface{}(TriggerTypeDefault).(fmt.Stringer).String(): TriggerTypeDefault,\n\t\t\tinterface{}(TriggerTypePoll).(fmt.Stringer).String():    TriggerTypePoll,\n\t\t}\n\t}\n}\nfunc (thread *Thread) PC() (uint64, error) {\n\tregs, err := thread.Registers()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn regs.PC(), nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProvidersSchema(ctx)\n}"}
{"input": "func TestManager(t *testing.T) {\n\tr := &fakereg{}\n\tmgrs := []aspectsupport.Manager{&fakemgr{kind: \"k1\"}, &fakemgr{kind: \"k2\"}}\n\tm := NewManager(r, mgrs)\n\tcfg := &aspectsupport.CombinedConfig{\n\t\tAspect:  &istioconfig.Aspect{},\n\t\tAdapter: &istioconfig.Adapter{},\n\t}\n\tattrs := &fakebag{}\n\tmapper := &fakeevaluator{}\n\tif _, err := m.Execute(cfg, attrs, mapper); err != nil {\n\t\tif !strings.Contains(err.Error(), \"could not find aspect manager\") {\n\t\t\tt.Error(\"excute errored out: \", err)\n\t\t}\n\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func TestManager(t *testing.T) {\n\tr := &fakereg{}\n\tmgrs := []aspectsupport.Manager{&fakemgr{kind: \"k1\"}, &fakemgr{kind: \"k2\"}}\n\tm := NewManager(r, mgrs)\n\tcfg := &aspectsupport.CombinedConfig{\n\t\tAspect:  &istioconfig.Aspect{},\n\t\tAdapter: &istioconfig.Adapter{},\n\t}\n\tattrs := &fakebag{}\n\tmapper := &fakeevaluator{}\n\tif _, err := m.Execute(cfg, attrs, mapper); err != nil {\n\t\tif !strings.Contains(err.Error(), \"could not find aspect manager\") {\n\t\t\tt.Error(\"excute errored out: \", err)\n\t\t}\n\n\t}\n}\nfunc (jbobject *CustomExtendedModifyListener) ModifyText(a CustomExtendedModifyEventInterface)  {\n\tconv_a := javabind.NewGoToJavaCallable()\n\tif err := conv_a.Convert(a); err != nil {\n\t\tpanic(err)\n\t}\n\t_, err := jbobject.CallMethod(javabind.GetEnv(), \"modifyText\", javabind.Void, conv_a.Value().Cast(\"org/eclipse/swt/custom/ExtendedModifyEvent\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tconv_a.CleanUp()\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.Env)\n}"}
{"input": "func keyFn(key beam.T, _ func(*int) bool) beam.T {\n\treturn key\n}\nfunc (jbobject *CustomExtendedModifyListener) ModifyText(a CustomExtendedModifyEventInterface)  {\n\tconv_a := javabind.NewGoToJavaCallable()\n\tif err := conv_a.Convert(a); err != nil {\n\t\tpanic(err)\n\t}\n\t_, err := jbobject.CallMethod(javabind.GetEnv(), \"modifyText\", javabind.Void, conv_a.Value().Cast(\"org/eclipse/swt/custom/ExtendedModifyEvent\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tconv_a.CleanUp()\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas(ctx)\n}"}
{"input": "\nfunc (p *ConfigParser) GetInterpolatedWithVars(section, option string, v Dict) (string, error) {\n\to, err := p.Items(section)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tc := chainmap.New(chainmap.Dict(p.Defaults()), chainmap.Dict(o), chainmap.Dict(v))\n\treturn p.getInterpolated(section, option, c)\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProvidersSchema(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (F *FP) Mul(b *FP) {\n\tF.mul(b)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func BuildSandboxName(metadata *runtimeapi.PodSandboxMetadata) string {\n\treturn fmt.Sprintf(\"%s_%s_%s_%d\", metadata.Name, metadata.Namespace, metadata.Uid, metadata.Attempt)\n}\nfunc (F *FP) Mul(b *FP) {\n\tF.mul(b)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc BuildSandboxName(metadata *runtimeapi.PodSandboxMetadata) string {\n\treturn fmt.Sprintf(\"%s_%s_%s_%d\", metadata.Name, metadata.Namespace, metadata.Uid, metadata.Attempt)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tName:    tf.Name,\n\t\tNamespace: tf.Namespace,\n\t\tUid: tf.Uid,\n\t\tAttempt: tf.Attempt,\n\t}, nil\n}"}
{"input": "func NewHttpServer(setting *util.Settings, handler Http.Handler) *HttpServer {\n\tport := strconv.Itoa(setting.HttpPort)\n\thttpServer := &HttpServer{\n\t\tHttp.Server{\n\t\t\tAddr:    \":\" + port,\n\t\t\tHandler: handler,\n\t\t},\n\t}\n\treturn httpServer\n}\nfunc BuildSandboxName(metadata *runtimeapi.PodSandboxMetadata) string {\n\treturn fmt.Sprintf(\"%s_%s_%s_%d\", metadata.Name, metadata.Namespace, metadata.Uid, metadata.Attempt)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName:    tf.Name,\n\t\t\tUid: tf.Uid,\n\t\t\tAttempt: tf.Attempt,\n\t\t},\n\t}, nil\n}"}
{"input": "func (m *memconn) Close() error {\n\tm.Do(func() {\n\t\tclose(m.chcn)\n\t\tm.done()\n\t})\n\treturn http.ErrServerClosed\n}\nfunc NewHttpServer(setting *util.Settings, handler Http.Handler) *HttpServer {\n\tport := strconv.Itoa(setting.HttpPort)\n\thttpServer := &HttpServer{\n\t\tHttp.Server{\n\t\t\tAddr:    \":\" + port,\n\t\t\tHandler: handler,\n\t\t},\n\t}\n\treturn httpServer\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc NewActionsDelete(ctx *middleware.Context, handler ActionsDeleteHandler) *ActionsDelete {\n\treturn &ActionsDelete{Context: ctx, Handler: handler}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestReduce(t *testing.T) {\n\tv := Reduce([]int{ 1, 2 }, func (memo []int, n, _ int) []int {\n\t\tmemo = append(memo, n)\n\t\tmemo = append(memo, n + 10)\n\t\treturn memo\n\t}, make([]int, 0))\n\tres, ok := v.([]int)\n\tif !(ok && len(res) == 4) {\n\t\tt.Error(\"wrong length\")\n\t}\n\n\tif !(res[0] == 1 && res[1] == 11 && res[2] == 2 && res[3] == 12) {\n\t\tt.Error(\"wrong result\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (u *UserSignup) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\tif err := utils.ValidatePassword(u.Passwd); err != nil {\n\t\terrs = append(errs, binding.Error{\n\t\t\tFieldNames:     []string{\"passwd\"},\n\t\t\tClassification: \"PasswdError\",\n\t\t\tMessage:        err.Error(),\n\t\t})\n\t}\n\n\tif u.Passwd != u.Confirm {\n\t\terrs = append(errs, binding.Error{\n\t\t\tFieldNames:     []string{\"passwd_confirm\"},\n\t\t\tClassification: \"PasswdConfirmError\",\n\t\t\tMessage:        \"Confirm password is not equal password\",\n\t\t})\n\t}\n\n\treturn errs\n}\nfunc TestReduce(t *testing.T) {\n\tv := Reduce([]int{ 1, 2 }, func (memo []int, n, _ int) []int {\n\t\tmemo = append(memo, n)\n\t\tmemo = append(memo, n + 10)\n\t\treturn memo\n\t}, make([]int, 0))\n\tres, ok := v.([]int)\n\tif !(ok && len(res) == 4) {\n\t\tt.Error(\"wrong length\")\n\t}\n\n\tif !(res[0] == 1 && res[1] == 11 && res[2] == 2 && res[3] == 12) {\n\t\tt.Error(\"wrong result\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func NewBlockingCallingContext(waiter WaitGroup) *BlockingCallingContext {\n\twaiter.Add(1)\n\treturn &BlockingCallingContext{Waiter: waiter}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func NewBlockingCallingContext(waiter WaitGroup) *BlockingCallingContext {\n\twaiter.Add(1)\n\treturn &BlockingCallingContext{Waiter: waiter}\n}\nfunc NewQueryService(s *platform.Source) (query.ProxyQueryService, error) {\n\tswitch s.Type {\n\tcase platform.SelfSourceType:\n\t\treturn nil, fmt.Errorf(\"self source type not implemented\")\n\tcase platform.V2SourceType:\n\t\treturn &http.SourceProxyQueryService{\n\t\t\tInsecureSkipVerify: s.InsecureSkipVerify,\n\t\t\tAddr:               s.URL,\n\t\t\tSourceFields:       s.SourceFields,\n\t\t}, nil\n\tcase platform.V1SourceType:\n\t\treturn &influxdb.SourceProxyQueryService{\n\t\t\tInsecureSkipVerify: s.InsecureSkipVerify,\n\t\t\tURL:                s.URL,\n\t\t\tSourceFields:       s.SourceFields,\n\t\t\tV1SourceFields:     s.V1SourceFields,\n\t\t\tOrganizationID:     s.OrganizationID,\n\t\t}, nil\n\t}\n\treturn nil, fmt.Errorf(\"unsupported source type %s\", s.Type)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (u *UserSignup) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors {\n\tif err := utils.ValidatePassword(u.Passwd); err != nil {\n\t\terrs = append(errs, binding.Error{\n\t\t\tFieldNames:     []string{\"passwd\"},\n\t\t\tClassification: \"PasswdError\",\n\t\t\tMessage:        err.Error(),\n\t\t})\n\t}\n\n\tif u.Passwd != u.Confirm {\n\t\terrs = append(errs, binding.Error{\n\t\t\tFieldNames:     []string{\"passwd_confirm\"},\n\t\t\tClassification: \"PasswdConfirmError\",\n\t\t\tMessage:        \"Confirm password is not equal password\",\n\t\t})\n\t}\n\n\treturn errs\n}\nfunc NewQueryService(s *platform.Source) (query.ProxyQueryService, error) {\n\tswitch s.Type {\n\tcase platform.SelfSourceType:\n\t\treturn nil, fmt.Errorf(\"self source type not implemented\")\n\tcase platform.V2SourceType:\n\t\treturn &http.SourceProxyQueryService{\n\t\t\tInsecureSkipVerify: s.InsecureSkipVerify,\n\t\t\tAddr:               s.URL,\n\t\t\tSourceFields:       s.SourceFields,\n\t\t}, nil\n\tcase platform.V1SourceType:\n\t\treturn &influxdb.SourceProxyQueryService{\n\t\t\tInsecureSkipVerify: s.InsecureSkipVerify,\n\t\t\tURL:                s.URL,\n\t\t\tSourceFields:       s.SourceFields,\n\t\t\tV1SourceFields:     s.V1SourceFields,\n\t\t\tOrganizationID:     s.OrganizationID,\n\t\t}, nil\n\t}\n\treturn nil, fmt.Errorf(\"unsupported source type %s\", s.Type)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc Benchmark_koalanet_send(b *testing.B) {\n\tRegActor(\"TestKoalanetMain\", func() IActor {\n\t\tactor := &TestKoalanetMain{}\n\t\tactor.InitActor()\n\t\tactor.RegMethod(\"Init\", actor.Init)\n\t\tactor.RegMethod(\"SendTest\", actor.SendTest)\n\t\treturn actor\n\t})\n\n\thTKM := NewActor(\"TestKoalanetMain\", nil)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tSend(hTKM, \"SendTest\", nil)\n\t}\n\n\tKillActor(hTKM, false)\n\n\tWaitActorQuit(hTKM)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.GetProvidersSchema(ctx)\n}"}
{"input": "func NewBlockingCallingContext(waiter WaitGroup) *BlockingCallingContext {\n\twaiter.Add(1)\n\treturn &BlockingCallingContext{Waiter: waiter}\n}\nfunc Benchmark_koalanet_send(b *testing.B) {\n\tRegActor(\"TestKoalanetMain\", func() IActor {\n\t\tactor := &TestKoalanetMain{}\n\t\tactor.InitActor()\n\t\tactor.RegMethod(\"Init\", actor.Init)\n\t\tactor.RegMethod(\"SendTest\", actor.SendTest)\n\t\treturn actor\n\t})\n\n\thTKM := NewActor(\"TestKoalanetMain\", nil)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tSend(hTKM, \"SendTest\", nil)\n\t}\n\n\tKillActor(hTKM, false)\n\n\tWaitActorQuit(hTKM)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func getReferences(itr *git.ReferenceIterator) []*git.Reference {\n\tvar ref *git.Reference\n\tvar refs []*git.Reference\n\tvar err error\n\tfor {\n\t\tref, err = itr.Next()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\trefs = append(refs, ref)\n\t}\n\treturn refs\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tvar providerSchemas tfjson.ProviderSchemas\n\tvar err error\n\tvar refs []*git.Reference\n\tvar err error\n\tvar err error\n\tfor {\n\t\tref, err = tf.ReferenceIterator.Next()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trefs = append(refs, ref)\n\t}\n\treturn &tfjson.ProviderSchemas{\n\t\tProviders: providers,\n\t}, nil\n}"}
{"input": "func getReferences(itr *git.ReferenceIterator) []*git.Reference {\n\tvar ref *git.Reference\n\tvar refs []*git.Reference\n\tvar err error\n\tfor {\n\t\tref, err = itr.Next()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\trefs = append(refs, ref)\n\t}\n\treturn refs\n}\nfunc TestCubbyholeGet(t *testing.T) {\n\tc := Cubbyhole{}\n\n\tif message := c.Get(); message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Get didn't return an empty message: %s`, message)\n\t}\n\n\tc.Message = \"NPA\"\n\tif message := c.Get(); message != \"NPA\" {\n\t\tt.Errorf(`Cubbyhole.Look didn't return the correct message \"NPA\" != %s`, message)\n\t}\n\n\tif message := c.Get(); message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Get didn't return an empty message: %s`, message)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tvar providerSchemas tfjson.ProviderSchemas\n\tvar err error\n\tfor {\n\t\tref, err = tf.ReferenceIterator().Next()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tproviderSchemas = append(providerSchemas, &tfjson.ProviderSchemas{\n\t\t\tName: \"providers\",\n\t\t\tDescription: \"The provider schema for the given reference\",\n\t\t\tSource: tf.Source,\n\t\t\tSource: tf.Source,\n\t\t})\n\t}\n\treturn providerSchemas, nil\n}"}
{"input": "func NewBlockingCallingContext(waiter WaitGroup) *BlockingCallingContext {\n\twaiter.Add(1)\n\treturn &BlockingCallingContext{Waiter: waiter}\n}\nfunc TestCubbyholeGet(t *testing.T) {\n\tc := Cubbyhole{}\n\n\tif message := c.Get(); message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Get didn't return an empty message: %s`, message)\n\t}\n\n\tc.Message = \"NPA\"\n\tif message := c.Get(); message != \"NPA\" {\n\t\tt.Errorf(`Cubbyhole.Look didn't return the correct message \"NPA\" != %s`, message)\n\t}\n\n\tif message := c.Get(); message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Get didn't return an empty message: %s`, message)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestUsernamePasswordCredential_InvalidPasswordLive(t *testing.T) {\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, \"invalid password\", &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttk, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif tk != nil {\n\t\tt.Fatal(\"GetToken returned a token\")\n\t}\n\tvar e AuthenticationFailedError\n\tif !errors.As(err, &e) {\n\t\tt.Fatal(\"expected AuthenticationFailedError\")\n\t}\n\tif e.RawResponse == nil {\n\t\tt.Fatal(\"expected a non-nil RawResponse\")\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func TestUsernamePasswordCredential_InvalidPasswordLive(t *testing.T) {\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, \"invalid password\", &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttk, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif tk != nil {\n\t\tt.Fatal(\"GetToken returned a token\")\n\t}\n\tvar e AuthenticationFailedError\n\tif !errors.As(err, &e) {\n\t\tt.Fatal(\"expected AuthenticationFailedError\")\n\t}\n\tif e.RawResponse == nil {\n\t\tt.Fatal(\"expected a non-nil RawResponse\")\n\t}\n}\nfunc LeaveMessageAPI(c *air.Context) error {\n\tvar msg models.Message\n\tmsg.From_name = c.FormValue(\"from\")\n\tmsg.Email = c.FormValue(\"email\")\n\tusername := c.FormValue(\"to\")\n\tuser, _, err := models.GetUserInfoByUsername(username)\n\tif err != nil {\n\t\treturn utils.ErrorResponse(c, \"\")\n\t}\n\tmsg.To_id = user.ID\n\tmsg.Content = c.FormValue(\"content\")\n\tif err = models.CreateMessage(&msg); err != nil {\n\t\treturn utils.ErrorResponse(c, \" 222 \")\n\t}\n\treturn utils.SuccessResponse(c, \"\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.ProvidersSchema{\n\t\t\tName: \"providerschemas\",\n\t\t\tName: \"providerschemas\",\n\t\t\tType: \"json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func getReferences(itr *git.ReferenceIterator) []*git.Reference {\n\tvar ref *git.Reference\n\tvar refs []*git.Reference\n\tvar err error\n\tfor {\n\t\tref, err = itr.Next()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\trefs = append(refs, ref)\n\t}\n\treturn refs\n}\nfunc LeaveMessageAPI(c *air.Context) error {\n\tvar msg models.Message\n\tmsg.From_name = c.FormValue(\"from\")\n\tmsg.Email = c.FormValue(\"email\")\n\tusername := c.FormValue(\"to\")\n\tuser, _, err := models.GetUserInfoByUsername(username)\n\tif err != nil {\n\t\treturn utils.ErrorResponse(c, \"\")\n\t}\n\tmsg.To_id = user.ID\n\tmsg.Content = c.FormValue(\"content\")\n\tif err = models.CreateMessage(&msg); err != nil {\n\t\treturn utils.ErrorResponse(c, \" 222 \")\n\t}\n\treturn utils.SuccessResponse(c, \"\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tvar providerSchemas tfjson.ProviderSchemas\n\terr := tf.client.ProvidersSchema(ctx, tf.Config.ProviderSchemas)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn providerSchemas, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (this *StateInMemory) Trap(message string, args ...interface{}) error {\n\treturn ParsexError{(*this).pos,\n\t\tfmt.Sprintf(message, args...)}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestUsernamePasswordCredential_InvalidPasswordLive(t *testing.T) {\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, \"invalid password\", &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttk, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif tk != nil {\n\t\tt.Fatal(\"GetToken returned a token\")\n\t}\n\tvar e AuthenticationFailedError\n\tif !errors.As(err, &e) {\n\t\tt.Fatal(\"expected AuthenticationFailedError\")\n\t}\n\tif e.RawResponse == nil {\n\t\tt.Fatal(\"expected a non-nil RawResponse\")\n\t}\n}\nfunc (this *StateInMemory) Trap(message string, args ...interface{}) error {\n\treturn ParsexError{(*this).pos,\n\t\tfmt.Sprintf(message, args...)}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tScopes: []string{liveTestScope},\n\t\t},\n\t}, nil\n}"}
{"input": "\nfunc TestUsernamePasswordCredential_InvalidPasswordLive(t *testing.T) {\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, \"invalid password\", &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttk, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif tk != nil {\n\t\tt.Fatal(\"GetToken returned a token\")\n\t}\n\tvar e AuthenticationFailedError\n\tif !errors.As(err, &e) {\n\t\tt.Fatal(\"expected AuthenticationFailedError\")\n\t}\n\tif e.RawResponse == nil {\n\t\tt.Fatal(\"expected a non-nil RawResponse\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func transportList() []string {\n\tvar transports = make([]string, 0, len(transporter))\n\tfor id := range transporter {\n\t\ttransports = append(transports, id)\n\t}\n\tsort.StringSlice(transports).Sort()\n\treturn transports\n}\nfunc TestUsernamePasswordCredential_InvalidPasswordLive(t *testing.T) {\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, \"invalid password\", &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttk, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif tk != nil {\n\t\tt.Fatal(\"GetToken returned a token\")\n\t}\n\tvar e AuthenticationFailedError\n\tif !errors.As(err, &e) {\n\t\tt.Fatal(\"expected AuthenticationFailedError\")\n\t}\n\tif e.RawResponse == nil {\n\t\tt.Fatal(\"expected a non-nil RawResponse\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (c *Clientset) Core() unversionedcore.CoreInterface {\n\treturn &fakeunversionedcore.FakeCore{&c.Fake}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.NewProvidersSchema(ctx),\n\t}, nil\n}"}
{"input": "func (s *FakeSender) Send(cmd, fprms, prms string) {\n\ts.SendCalls += 1\n\ts.SendArgs = append(s.SendArgs, []string{cmd, fprms, prms})\n}\nfunc (c *Clientset) Core() unversionedcore.CoreInterface {\n\treturn &fakeunversionedcore.FakeCore{&c.Fake}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc (s *FakeSender) Send(cmd, fprms, prms string) {\n\ts.SendCalls += 1\n\ts.SendArgs = append(s.SendArgs, []string{cmd, fprms, prms})\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestLogMessagePanicking(t *testing.T) {\n\tlog, ctrl := NewLogSinkSpy(true)\n\n\tassert.NotPanics(t, func() {\n\t\tDeliver(log, terribadLogMessage{})\n\t})\n\n\tcalls := ctrl.CallsTo(\"Fields\")\n\tif assert.Len(t, calls, 2) {\n\t\tfields := calls[1].PassedArgs().Get(0).([]EachFielder)\n\t\tassert.IsType(t, &silentMessageError{}, fields[2])\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func Load() string {\n\tuptime_in_seconds := uptime_seconds.Load()\n\tuptimeInt, err := strconv.Atoi(uptime_in_seconds)\n\tuptime_in_minutes := (uptimeInt / 60)\n\tif err != nil {\n\t\treturn string(\"\")\n\t}\n\n\treturn strconv.Itoa(uptime_in_minutes)\n\n}\nfunc TestLogMessagePanicking(t *testing.T) {\n\tlog, ctrl := NewLogSinkSpy(true)\n\n\tassert.NotPanics(t, func() {\n\t\tDeliver(log, terribadLogMessage{})\n\t})\n\n\tcalls := ctrl.CallsTo(\"Fields\")\n\tif assert.Len(t, calls, 2) {\n\t\tfields := calls[1].PassedArgs().Get(0).([]EachFielder)\n\t\tassert.IsType(t, &silentMessageError{}, fields[2])\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providers_schema\",\n\t\t\tType: \"string\",\n\t\t\tName: \"provider_schemas\",\n\t\t},\n\t}, nil\n}"}
{"input": "\nfunc (r *Passthrough) Finish(outputChan chan data.JSON, killChan chan error) {\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (plugin *Plugin) read_auth_result(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "func TestLegacySelect(t *testing.T) {\n\n\tenv := adaptertest.NewEnv(t)\n\n\topts := Options{\n\t\tLegacyEndpoint:   true,\n\t\tBufferPath:       \"\",\n\t\tStagingFileLimit: 10,\n\t\tBaseURL:          &url.URL{},\n\t\tKey:              \"key\",\n\t\tSecret:           \"secret\",\n\t\tClient:           http.DefaultClient,\n\t\tnow:              time.Now,\n\t}\n\n\tm, err := NewManager(env, opts)\n\tm.Close()\n\tif err != nil {\n\t\tt.Fatalf(\"newManager: %s\", err)\n\t}\n\n\tif _, ok := m.(*legacyAnalytics); !ok {\n\t\tt.Errorf(\"want an *legacyAnalytics type, got: %#v\", m)\n\t}\n}\nfunc (plugin *Plugin) read_auth_result(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProvidersSchema: tfjson.ProvidersSchema{\n\t\t\tType: \"json\",\n\t\t\tName: \"providersSchema\",\n\t\t\tType: \"json\",\n\t\t},\n\t}\n}"}
{"input": "\nfunc TestLegacySelect(t *testing.T) {\n\n\tenv := adaptertest.NewEnv(t)\n\n\topts := Options{\n\t\tLegacyEndpoint:   true,\n\t\tBufferPath:       \"\",\n\t\tStagingFileLimit: 10,\n\t\tBaseURL:          &url.URL{},\n\t\tKey:              \"key\",\n\t\tSecret:           \"secret\",\n\t\tClient:           http.DefaultClient,\n\t\tnow:              time.Now,\n\t}\n\n\tm, err := NewManager(env, opts)\n\tm.Close()\n\tif err != nil {\n\t\tt.Fatalf(\"newManager: %s\", err)\n\t}\n\n\tif _, ok := m.(*legacyAnalytics); !ok {\n\t\tt.Errorf(\"want an *legacyAnalytics type, got: %#v\", m)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.Config.ProvidersSchema)\n}"}
{"input": "func (request CreatePublicationRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\nfunc TestLegacySelect(t *testing.T) {\n\n\tenv := adaptertest.NewEnv(t)\n\n\topts := Options{\n\t\tLegacyEndpoint:   true,\n\t\tBufferPath:       \"\",\n\t\tStagingFileLimit: 10,\n\t\tBaseURL:          &url.URL{},\n\t\tKey:              \"key\",\n\t\tSecret:           \"secret\",\n\t\tClient:           http.DefaultClient,\n\t\tnow:              time.Now,\n\t}\n\n\tm, err := NewManager(env, opts)\n\tm.Close()\n\tif err != nil {\n\t\tt.Fatalf(\"newManager: %s\", err)\n\t}\n\n\tif _, ok := m.(*legacyAnalytics); !ok {\n\t\tt.Errorf(\"want an *legacyAnalytics type, got: %#v\", m)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvidersSchema: tfjson.NewProvidersSchema(ctx),\n\t}, nil\n}"}
{"input": "func handleProfile(w http.ResponseWriter, r *http.Request) {\n\terr := views.Render(\"profile\", w, r)\n\tif err != nil {\n\t\tlog.Println(\"Error rendering dashboard view:\", err)\n\t}\n}\nfunc (request CreatePublicationRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func LoadFile(configPath string) (*Config, error) {\n\tvar config Config\n\t_, err := toml.DecodeFile(configPath, &config)\n\treturn &config, err\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tvar providerSchemas *tfjson.ProviderSchemas\n\terr := tf.LoadFile(ctx, tf.Config.ProvidersSchemaPath)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn providerSchemas, nil\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc LoadFile(configPath string) (*Config, error) {\n\tvar config Config\n\t_, err := toml.DecodeFile(configPath, &config)\n\treturn &config, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tvar providerSchemas tfjson.ProviderSchemas\n\terr := tf.ReadFile(ctx, tf.Config.ProvidersSchemaPath)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn &providerSchemas, nil\n}"}
{"input": "\nfunc (self *Wind) Type() string {\n\treturn windTypes[self.typeId]\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (jbobject *CustomExtendedModifyListener) ModifyText(a CustomExtendedModifyEventInterface)  {\n\tconv_a := javabind.NewGoToJavaCallable()\n\tif err := conv_a.Convert(a); err != nil {\n\t\tpanic(err)\n\t}\n\t_, err := jbobject.CallMethod(javabind.GetEnv(), \"modifyText\", javabind.Void, conv_a.Value().Cast(\"org/eclipse/swt/custom/ExtendedModifyEvent\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tconv_a.CleanUp()\n\n}\nfunc (self *Wind) Type() string {\n\treturn windTypes[self.typeId]\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType:     tf.Type(),\n\t\tType:     tf.Type(),\n\t\tType:     tf.Type(),\n\t}, nil\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc (jbobject *CustomExtendedModifyListener) ModifyText(a CustomExtendedModifyEventInterface)  {\n\tconv_a := javabind.NewGoToJavaCallable()\n\tif err := conv_a.Convert(a); err != nil {\n\t\tpanic(err)\n\t}\n\t_, err := jbobject.CallMethod(javabind.GetEnv(), \"modifyText\", javabind.Void, conv_a.Value().Cast(\"org/eclipse/swt/custom/ExtendedModifyEvent\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tconv_a.CleanUp()\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.GetEnv().ProvidersSchema(ctx)\n}"}
{"input": "func handleProfile(w http.ResponseWriter, r *http.Request) {\n\terr := views.Render(\"profile\", w, r)\n\tif err != nil {\n\t\tlog.Println(\"Error rendering dashboard view:\", err)\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{}, nil\n}"}
{"input": "func handleProfile(w http.ResponseWriter, r *http.Request) {\n\terr := views.Render(\"profile\", w, r)\n\tif err != nil {\n\t\tlog.Println(\"Error rendering dashboard view:\", err)\n\t}\n}\nfunc UIntPtr(p uintptr) uint32 {\n\tswitch unsafe.Sizeof(p) {\n\tcase 4:\n\t\treturn UInt32(uint32(p))\n\tcase 8:\n\t\treturn UInt64(uint64(p))\n\tdefault:\n\t\tpanic(\"unhandled pointer size\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"profile\",\n\t\t\tType: \"application/json\",\n\t\t\tName: \"profile\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (self *Wind) Type() string {\n\treturn windTypes[self.typeId]\n}\nfunc UIntPtr(p uintptr) uint32 {\n\tswitch unsafe.Sizeof(p) {\n\tcase 4:\n\t\treturn UInt32(uint32(p))\n\tcase 8:\n\t\treturn UInt64(uint64(p))\n\tdefault:\n\t\tpanic(\"unhandled pointer size\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc makeGolden(t *testing.T, p string) *os.File {\n\tt.Helper()\n\tif os.Getenv(\"GOLDEN\") == \"\" {\n\t\treturn nil\n\t}\n\tf, err := os.OpenFile(p, os.O_CREATE|os.O_WRONLY, 0600)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn f\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func NewServo(pin int) *Servo {\n\treturn &Servo{Pin: pin}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (lv *PaginatedListView) SetCursor(cursor string) {\n\tlv.cursor = cursor\n}\nfunc NewServo(pin int) *Servo {\n\treturn &Servo{Pin: pin}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc insert(t *Tree, v int) *Tree {\n\tif t == nil {\n\t\treturn &Tree{nil, v, nil}\n\t}\n\tif v < t.Value {\n\t\tt.Left = insert(t.Left, v)\n\t\treturn t\n\t}\n\tt.Right = insert(t.Right, v)\n\treturn t\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (lv *PaginatedListView) SetCursor(cursor string) {\n\tlv.cursor = cursor\n}\nfunc insert(t *Tree, v int) *Tree {\n\tif t == nil {\n\t\treturn &Tree{nil, v, nil}\n\t}\n\tif v < t.Value {\n\t\tt.Left = insert(t.Left, v)\n\t\treturn t\n\t}\n\tt.Right = insert(t.Right, v)\n\treturn t\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc BenchmarkInsert1Record(b *testing.B) {\n\tinsertRecord(b)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func SetFileLabel(path string, label string) error {\n\treturn nil\n}\nfunc BenchmarkInsert1Record(b *testing.B) {\n\tinsertRecord(b)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func mapFn(elm beam.T) (beam.T, int) {\n\treturn elm, 1\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func mapFn(elm beam.T) (beam.T, int) {\n\treturn elm, 1\n}\nfunc (_m *MockContainerInstanceLoader) EXPECT() *_MockContainerInstanceLoaderRecorder {\n\treturn _m.recorder\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func SetFileLabel(path string, label string) error {\n\treturn nil\n}\nfunc (_m *MockContainerInstanceLoader) EXPECT() *_MockContainerInstanceLoaderRecorder {\n\treturn _m.recorder\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc New(subscriptionID string) BaseClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func mapFn(elm beam.T) (beam.T, int) {\n\treturn elm, 1\n}\nfunc New(subscriptionID string) BaseClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func TestContainer(t *testing.T) {\n\tcontainer()\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc TestContainer(t *testing.T) {\n\tcontainer()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tf.GetProvidersSchema(ctx)\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc CreateAlgorithm(algType string) (Algorithm, error) {\n\tswitch algType {\n\tcase AlgorithmTypeUnset, AlgorithmTypeAES256CFB:\n\t\treturn aes.NewAES(AlgorithmTypeAES256CFB)\n\tcase AlgorithmTypeAES128CFB, AlgorithmTypeAES192CFB:\n\t\treturn aes.NewAES(algType)\n\tcase AlgorithmTypeDESCFB:\n\t\treturn des.NewDes(algType)\n\tcase AlgorithmTypeBFCFB:\n\t\treturn blowfish.NewBFCFB(algType)\n\tcase AlgorithmTypeCAST5CFB:\n\t\treturn cast5.NewCast5cfb(algType)\n\tcase AlgorithmTypeRC4MD5:\n\t\treturn rc4md5.NewRC4MD5(algType)\n\tcase AlgorithmTypeCHACHA20:\n\t\treturn chacha20.NewChaCha20(algType)\n\tcase AlgorithmTypeSALSA20:\n\t\treturn salsa20.NewSalsa20(algType)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"not support type %s\\r\\n\", algType)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"providers\",\n\t\tSchema: tfjson.NewProviderSchemas(ctx),\n\t}\n}"}
{"input": "func SetFileLabel(path string, label string) error {\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func SetFileLabel(path string, label string) error {\n\treturn nil\n}\nfunc GetUriFilteringTelemetryPreMitigationByCuid(engine *xorm.Engine, customerId int, cuid string) ([]UriFilteringTelemetryPreMitigation, error) {\n\ttelePreMitigation := []UriFilteringTelemetryPreMitigation{}\n\terr := engine.Where(\"customer_id = ? AND cuid = ?\", customerId, cuid).Find(&telePreMitigation)\n\treturn telePreMitigation, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "func NewSDK(apiKey string) (sdk SDK) {\n\tvalidateApiKey(apiKey)\n\tconfig := getSDKConfig(apiKey)\n\tsdk = getSDK(config)\n\treturn sdk\n}\nfunc GetUriFilteringTelemetryPreMitigationByCuid(engine *xorm.Engine, customerId int, cuid string) ([]UriFilteringTelemetryPreMitigation, error) {\n\ttelePreMitigation := []UriFilteringTelemetryPreMitigation{}\n\terr := engine.Where(\"customer_id = ? AND cuid = ?\", customerId, cuid).Find(&telePreMitigation)\n\treturn telePreMitigation, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas, err := tf.GetProvidersSchema(ctx)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn &tfjson.ProviderSchemas{\n\t\tProviders: providerSchemas,\n\t}, nil\n}"}
{"input": "\nfunc (s *scopePool) Get() *Scope {\n\treturn s.pool.Get().(*Scope)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestRemoveDuplicates(t *testing.T) {\n\tnums := []int{1, 2, 3, 3, 5, 7, 7, 7, 11, 15}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{1, 1, 2}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{1}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{}\n\tfmt.Println(removeDuplicates(nums), nums)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestContainer(t *testing.T) {\n\tcontainer()\n}\nfunc TestRemoveDuplicates(t *testing.T) {\n\tnums := []int{1, 2, 3, 3, 5, 7, 7, 7, 11, 15}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{1, 1, 2}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{1}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{}\n\tfmt.Println(removeDuplicates(nums), nums)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc NewHistory(capacity int) *History {\n\treturn &History{ring.New(capacity)}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestContainer(t *testing.T) {\n\tcontainer()\n}\nfunc NewHistory(capacity int) *History {\n\treturn &History{ring.New(capacity)}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc NewContainerManager(_ string, _ libdocker.Interface) ContainerManager {\n\treturn &unsupportedContainerManager{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc NewContainerManager(_ string, _ libdocker.Interface) ContainerManager {\n\treturn &unsupportedContainerManager{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "func (t *BasicExampleController) Routes() (http.Handler, error) {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(t.Base(), t.index)\n\trouter.HandleFunc(t.Base()+\"magic\", t.index)\n\treturn router, nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func (t *BasicExampleController) Routes() (http.Handler, error) {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(t.Base(), t.index)\n\trouter.HandleFunc(t.Base()+\"magic\", t.index)\n\treturn router, nil\n}\nfunc Test_Action(t *testing.T) {\n\tvar (\n\t\tmid int64 = 14771787\n\t\taid int64 = 4052445\n\t\ttid int64 = 10176\n\t\tnow       = time.Now()\n\t)\n\tConvey(\"testLike service\", t, WithService(func(s *Service) {\n\t\ttestSvc.Like(context.Background(), mid, aid, tid, now)\n\t}))\n\tConvey(\"testHate service\", t, WithService(func(s *Service) {\n\t\ttestSvc.Hate(context.Background(), mid, aid, tid, now)\n\t}))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func serverMonitorInit() {\n\tgo startServerMonitor()\n}\nfunc Test_Action(t *testing.T) {\n\tvar (\n\t\tmid int64 = 14771787\n\t\taid int64 = 4052445\n\t\ttid int64 = 10176\n\t\tnow       = time.Now()\n\t)\n\tConvey(\"testLike service\", t, WithService(func(s *Service) {\n\t\ttestSvc.Like(context.Background(), mid, aid, tid, now)\n\t}))\n\tConvey(\"testHate service\", t, WithService(func(s *Service) {\n\t\ttestSvc.Hate(context.Background(), mid, aid, tid, now)\n\t}))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func ExampleStart_withFlags() {\n\tmode := flag.String(\"profile.mode\", \"\", \"enable profiling mode, one of [cpu, mem, mutex, block]\")\n\tflag.Parse()\n\tswitch *mode {\n\tcase \"cpu\":\n\t\tdefer profile.Start(profile.CPUProfile).Stop()\n\tcase \"mem\":\n\t\tdefer profile.Start(profile.MemProfile).Stop()\n\tcase \"mutex\":\n\t\tdefer profile.Start(profile.MutexProfile).Stop()\n\tcase \"block\":\n\t\tdefer profile.Start(profile.BlockProfile).Stop()\n\tdefault:\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "func ExampleStart_withFlags() {\n\tmode := flag.String(\"profile.mode\", \"\", \"enable profiling mode, one of [cpu, mem, mutex, block]\")\n\tflag.Parse()\n\tswitch *mode {\n\tcase \"cpu\":\n\t\tdefer profile.Start(profile.CPUProfile).Stop()\n\tcase \"mem\":\n\t\tdefer profile.Start(profile.MemProfile).Stop()\n\tcase \"mutex\":\n\t\tdefer profile.Start(profile.MutexProfile).Stop()\n\tcase \"block\":\n\t\tdefer profile.Start(profile.BlockProfile).Stop()\n\tdefault:\n\t}\n}\nfunc (m *secretrule) UnmarshalPolymorphicJSON(data []byte) (interface{}, error) {\n\n\tif data == nil || string(data) == \"null\" {\n\t\treturn nil, nil\n\t}\n\n\tvar err error\n\tswitch m.RuleType {\n\tcase \"SECRET_EXPIRY_RULE\":\n\t\tmm := SecretExpiryRule{}\n\t\terr = json.Unmarshal(data, &mm)\n\t\treturn mm, err\n\tcase \"SECRET_REUSE_RULE\":\n\t\tmm := SecretReuseRule{}\n\t\terr = json.Unmarshal(data, &mm)\n\t\treturn mm, err\n\tdefault:\n\t\treturn *m, nil\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "func (t *BasicExampleController) Routes() (http.Handler, error) {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(t.Base(), t.index)\n\trouter.HandleFunc(t.Base()+\"magic\", t.index)\n\treturn router, nil\n}\nfunc (m *secretrule) UnmarshalPolymorphicJSON(data []byte) (interface{}, error) {\n\n\tif data == nil || string(data) == \"null\" {\n\t\treturn nil, nil\n\t}\n\n\tvar err error\n\tswitch m.RuleType {\n\tcase \"SECRET_EXPIRY_RULE\":\n\t\tmm := SecretExpiryRule{}\n\t\terr = json.Unmarshal(data, &mm)\n\t\treturn mm, err\n\tcase \"SECRET_REUSE_RULE\":\n\t\tmm := SecretReuseRule{}\n\t\terr = json.Unmarshal(data, &mm)\n\t\treturn mm, err\n\tdefault:\n\t\treturn *m, nil\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func ExampleStart_withFlags() {\n\tmode := flag.String(\"profile.mode\", \"\", \"enable profiling mode, one of [cpu, mem, mutex, block]\")\n\tflag.Parse()\n\tswitch *mode {\n\tcase \"cpu\":\n\t\tdefer profile.Start(profile.CPUProfile).Stop()\n\tcase \"mem\":\n\t\tdefer profile.Start(profile.MemProfile).Stop()\n\tcase \"mutex\":\n\t\tdefer profile.Start(profile.MutexProfile).Stop()\n\tcase \"block\":\n\t\tdefer profile.Start(profile.BlockProfile).Stop()\n\tdefault:\n\t}\n}\nfunc InitLogDestination() error {\n\tdest := strings.ToLower(config.GetConfig().Logging.Destination)\n\tif dest != core && dest != stdout {\n\t\treturn fmt.Errorf(\"This log destination is not supported. Supported are: %s %s\", core, stdout)\n\t}\n\n\tneb.CoreFLog(\"Logging from now on to: %s\", dest)\n\tdestination = dest\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.GetConfig().ProvidersSchema.Name)\n}"}
{"input": "func (lb logBridge) Write(b []byte) (n int, err error) {\n\tvar text string\n\tif parts := bytes.SplitN(b, []byte{':'}, 3); len(parts) != 3 || len(parts[0]) < 1 || len(parts[2]) < 1 {\n\t\ttext = fmt.Sprintf(\"bad log format: %s\", b)\n\t} else {\n\t\ttext = string(parts[2][1:]) \n\t}\n\n\tswitch severity(lb) {\n\tcase infoLog:\n\t\tgolog.InfoDepth(logDepth, text)\n\tcase warningLog:\n\t\tgolog.WarningDepth(logDepth, text)\n\tcase errorLog:\n\t\tgolog.ErrorDepth(logDepth, text)\n\tcase fatalLog:\n\t\tgolog.FatalDepth(logDepth, text)\n\t}\n\tnotifyAirbrake(logDepth+1, severity(lb), text)\n\n\treturn len(b), nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (lb logBridge) Write(b []byte) (n int, err error) {\n\tvar text string\n\tif parts := bytes.SplitN(b, []byte{':'}, 3); len(parts) != 3 || len(parts[0]) < 1 || len(parts[2]) < 1 {\n\t\ttext = fmt.Sprintf(\"bad log format: %s\", b)\n\t} else {\n\t\ttext = string(parts[2][1:]) \n\t}\n\n\tswitch severity(lb) {\n\tcase infoLog:\n\t\tgolog.InfoDepth(logDepth, text)\n\tcase warningLog:\n\t\tgolog.WarningDepth(logDepth, text)\n\tcase errorLog:\n\t\tgolog.ErrorDepth(logDepth, text)\n\tcase fatalLog:\n\t\tgolog.FatalDepth(logDepth, text)\n\t}\n\tnotifyAirbrake(logDepth+1, severity(lb), text)\n\n\treturn len(b), nil\n}\nfunc LogAsJson(object interface{}) {\n\ttest, _ := json.Marshal(object)\n\tlog.Printf(string(test))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func ExampleStart_withFlags() {\n\tmode := flag.String(\"profile.mode\", \"\", \"enable profiling mode, one of [cpu, mem, mutex, block]\")\n\tflag.Parse()\n\tswitch *mode {\n\tcase \"cpu\":\n\t\tdefer profile.Start(profile.CPUProfile).Stop()\n\tcase \"mem\":\n\t\tdefer profile.Start(profile.MemProfile).Stop()\n\tcase \"mutex\":\n\t\tdefer profile.Start(profile.MutexProfile).Stop()\n\tcase \"block\":\n\t\tdefer profile.Start(profile.BlockProfile).Stop()\n\tdefault:\n\t}\n}\nfunc LogAsJson(object interface{}) {\n\ttest, _ := json.Marshal(object)\n\tlog.Printf(string(test))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "\nfunc (lb logBridge) Write(b []byte) (n int, err error) {\n\tvar text string\n\tif parts := bytes.SplitN(b, []byte{':'}, 3); len(parts) != 3 || len(parts[0]) < 1 || len(parts[2]) < 1 {\n\t\ttext = fmt.Sprintf(\"bad log format: %s\", b)\n\t} else {\n\t\ttext = string(parts[2][1:]) \n\t}\n\n\tswitch severity(lb) {\n\tcase infoLog:\n\t\tgolog.InfoDepth(logDepth, text)\n\tcase warningLog:\n\t\tgolog.WarningDepth(logDepth, text)\n\tcase errorLog:\n\t\tgolog.ErrorDepth(logDepth, text)\n\tcase fatalLog:\n\t\tgolog.FatalDepth(logDepth, text)\n\t}\n\tnotifyAirbrake(logDepth+1, severity(lb), text)\n\n\treturn len(b), nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func NewActor(config Config) *Actor {\n\tvar authActor AuthActor = NewDefaultAuthActor(config)\n\tif config.IsCFOnK8s() {\n\t\tauthActor = NewK8sAuthActor(config)\n\t}\n\n\treturn &Actor{\n\t\tAuthActor: authActor,\n\t\tConfig:    config,\n\t}\n}\nfunc (lb logBridge) Write(b []byte) (n int, err error) {\n\tvar text string\n\tif parts := bytes.SplitN(b, []byte{':'}, 3); len(parts) != 3 || len(parts[0]) < 1 || len(parts[2]) < 1 {\n\t\ttext = fmt.Sprintf(\"bad log format: %s\", b)\n\t} else {\n\t\ttext = string(parts[2][1:]) \n\t}\n\n\tswitch severity(lb) {\n\tcase infoLog:\n\t\tgolog.InfoDepth(logDepth, text)\n\tcase warningLog:\n\t\tgolog.WarningDepth(logDepth, text)\n\tcase errorLog:\n\t\tgolog.ErrorDepth(logDepth, text)\n\tcase fatalLog:\n\t\tgolog.FatalDepth(logDepth, text)\n\t}\n\tnotifyAirbrake(logDepth+1, severity(lb), text)\n\n\treturn len(b), nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\nfunc NewActor(config Config) *Actor {\n\tvar authActor AuthActor = NewDefaultAuthActor(config)\n\tif config.IsCFOnK8s() {\n\t\tauthActor = NewK8sAuthActor(config)\n\t}\n\n\treturn &Actor{\n\t\tAuthActor: authActor,\n\t\tConfig:    config,\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\nfunc TestStateHook(t *testing.T) {\n\tis := &state.InmemState{}\n\tvar hook terraform.Hook = &StateHook{State: is}\n\n\ts := state.TestStateInitial()\n\taction, err := hook.PostStateUpdate(s)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\tif action != terraform.HookActionContinue {\n\t\tt.Fatalf(\"bad: %v\", action)\n\t}\n\tif !is.State().Equal(s) {\n\t\tt.Fatalf(\"bad state: %#v\", is.State())\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (k *SSHKey) JSONPrint() {\n\toutput, err := json.MarshalIndent(k, \"\", \"    \")\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing to JSON\")\n\t}\n\tos.Stdout.Write(output)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func LoadModule(x interface{}) {\n\tmsg.loadModule(x)\n}\nfunc (k *SSHKey) JSONPrint() {\n\toutput, err := json.MarshalIndent(k, \"\", \"    \")\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing to JSON\")\n\t}\n\tos.Stdout.Write(output)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc LoadModule(x interface{}) {\n\tmsg.loadModule(x)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func main() {\n\tf, err := os.Create(\"irelate.cpu.pprof\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tpprof.StartCPUProfile(f)\n\tdefer pprof.StopCPUProfile()\n\tfiles := os.Args[1:]\n\tbuf := bufio.NewWriter(os.Stdout)\n\tb, err := bix.New(files[0], 1)\n\tcheck(err)\n\tbx, err := b.Query(nil)\n\tcheck(err)\n\n\tqueryables := make([]I.Queryable, len(files)-1)\n\tfor i, f := range files[1:] {\n\t\tq, err := bix.New(f, 1)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tqueryables[i] = q\n\t}\n\n\tfor interval := range irelate.PIRelate(4000, 25000, bx, false, nil, queryables...) {\n\t\tfmt.Fprintf(buf, \"%s\\t%d\\t%d\\t%d\\n\", interval.Chrom(), interval.Start(), interval.End(), len(interval.Related()))\n\t}\n\tbuf.Flush()\n}\nfunc LoadModule(x interface{}) {\n\tmsg.loadModule(x)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "func indirect(v reflect.Value) reflect.Value {\n\tif v.Kind() == reflect.Ptr && v.Elem().Type() != big_t {\n\t\treturn indirect(v.Elem())\n\t}\n\treturn v\n}\nfunc main() {\n\tf, err := os.Create(\"irelate.cpu.pprof\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tpprof.StartCPUProfile(f)\n\tdefer pprof.StopCPUProfile()\n\tfiles := os.Args[1:]\n\tbuf := bufio.NewWriter(os.Stdout)\n\tb, err := bix.New(files[0], 1)\n\tcheck(err)\n\tbx, err := b.Query(nil)\n\tcheck(err)\n\n\tqueryables := make([]I.Queryable, len(files)-1)\n\tfor i, f := range files[1:] {\n\t\tq, err := bix.New(f, 1)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tqueryables[i] = q\n\t}\n\n\tfor interval := range irelate.PIRelate(4000, 25000, bx, false, nil, queryables...) {\n\t\tfmt.Fprintf(buf, \"%s\\t%d\\t%d\\t%d\\n\", interval.Chrom(), interval.Start(), interval.End(), len(interval.Related()))\n\t}\n\tbuf.Flush()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (Generator PrimaryStarGenerator) GetName() string {\n\treturn \"PrimaryStarGenerator\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (u *UDPServer) read(conn *net.UDPConn, buf []byte, last time.Time) (*ServerMeasure, error) {\n\terr := conn.SetDeadline(time.Now().Add(u.timeout))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"setting deadline for next read, %v\", err)\n\t}\n\n\tn, err := conn.Read(buf)\n\tnow := time.Now()\n\n\tm := &ServerMeasure{now, now.Sub(last), n, buf[:n], err}\n\n\tif err != nil && err != io.EOF {\n\t\treturn m, fmt.Errorf(\"reading, %v\", err)\n\t}\n\n\tif err == io.EOF && !u.gen.HasNext() {\n\t\treturn m, errors.New(\"expected next sequence but got EOF\")\n\t}\n\n\treturn m, nil\n}\nfunc (Generator PrimaryStarGenerator) GetName() string {\n\treturn \"PrimaryStarGenerator\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc TemplateBatchSize(batchSize *ab.BatchSize) *cb.ConfigGroup {\n\treturn ordererConfigGroup(BatchSizeKey, utils.MarshalOrPanic(batchSize))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (s *InvGroup) GetName(lang string) string {\n\tfor _, lt := range s.Names {\n\t\tif *lt.Lang == lang {\n\t\t\treturn *lt.Text\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func New(subscriptionID string) ManagementClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\nfunc (s *InvGroup) GetName(lang string) string {\n\tfor _, lt := range s.Names {\n\t\tif *lt.Lang == lang {\n\t\t\treturn *lt.Text\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "\nfunc New(subscriptionID string) ManagementClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (f *fileAdapter) Level() level.LogLevel {\n\treturn f.logLevel\n}\nfunc New(subscriptionID string) ManagementClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProvidersSchema(ctx)\n}"}
{"input": "func (v Value) LessThanEq(w Value) bool {\n\tif v == w {\n\t\treturn true\n\t}\n\treturn v.LessThan(w)\n}\nfunc (f *fileAdapter) Level() level.LogLevel {\n\treturn f.logLevel\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func TestIntSetSize(t *testing.T) {\n\tis := NewIntSet()\n\tassert.Equal(t, 0, is.Size())\n\tis.Add(42)\n\tassert.Equal(t, 1, is.Size())\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\nfunc TestIntSetSize(t *testing.T) {\n\tis := NewIntSet()\n\tassert.Equal(t, 0, is.Size())\n\tis.Add(42)\n\tassert.Equal(t, 1, is.Size())\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc runClient() {\n\ttime.Sleep(1 * time.Second)\n\tcfg := &sse.Config{\n\t\tURL: \"http://localhost:3000\",\n\t}\n\tclient, err := sse.New(cfg)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tclient.AddListener(\"ts\", func(e sse.Event) {\n\t\tfmt.Printf(\"%+v\\n\", e)\n\t})\n\tclient.AddListener(\"error\", func(e sse.Event) {\n\t\tfmt.Println(\"error \", e)\n\t})\n\tclient.AddListener(\"open\", func(e sse.Event) {\n\t\tfmt.Println(\"open \", e)\n\t})\n\tclient.Connect()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (h *MappedAddressAttribute) Decode(data []byte, _ uint16, _ *stun.Parser) error {\n\tif data[0] != 0 && data[1] != 1 && data[0] != 2 {\n\t\treturn errors.New(\"Incorrect Mapped Address Family.\")\n\t}\n\th.Family = uint16(data[1])\n\tif (h.Family == 1 && len(data) < 8) || (h.Family == 2 && len(data) < 20) {\n\t\treturn errors.New(\"Mapped Address Attribute unexpectedly Truncated.\")\n\t}\n\th.Port = uint16(data[2])<<8 + uint16(data[3])\n\tif h.Family == 1 {\n\t\th.Address = data[4:8]\n\t} else {\n\t\th.Address = data[4:20]\n\t}\n\treturn nil\n}\nfunc runClient() {\n\ttime.Sleep(1 * time.Second)\n\tcfg := &sse.Config{\n\t\tURL: \"http://localhost:3000\",\n\t}\n\tclient, err := sse.New(cfg)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tclient.AddListener(\"ts\", func(e sse.Event) {\n\t\tfmt.Printf(\"%+v\\n\", e)\n\t})\n\tclient.AddListener(\"error\", func(e sse.Event) {\n\t\tfmt.Println(\"error \", e)\n\t})\n\tclient.AddListener(\"open\", func(e sse.Event) {\n\t\tfmt.Println(\"open \", e)\n\t})\n\tclient.Connect()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tType: \"application/json\",\n\t\tSchema: tfjson.NewProviderSchemas(),\n\t}, nil\n}"}
{"input": "func RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\nfunc (h *MappedAddressAttribute) Decode(data []byte, _ uint16, _ *stun.Parser) error {\n\tif data[0] != 0 && data[1] != 1 && data[0] != 2 {\n\t\treturn errors.New(\"Incorrect Mapped Address Family.\")\n\t}\n\th.Family = uint16(data[1])\n\tif (h.Family == 1 && len(data) < 8) || (h.Family == 2 && len(data) < 20) {\n\t\treturn errors.New(\"Mapped Address Attribute unexpectedly Truncated.\")\n\t}\n\th.Port = uint16(data[2])<<8 + uint16(data[3])\n\tif h.Family == 1 {\n\t\th.Address = data[4:8]\n\t} else {\n\t\th.Address = data[4:20]\n\t}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc runClient() {\n\ttime.Sleep(1 * time.Second)\n\tcfg := &sse.Config{\n\t\tURL: \"http://localhost:3000\",\n\t}\n\tclient, err := sse.New(cfg)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tclient.AddListener(\"ts\", func(e sse.Event) {\n\t\tfmt.Printf(\"%+v\\n\", e)\n\t})\n\tclient.AddListener(\"error\", func(e sse.Event) {\n\t\tfmt.Println(\"error \", e)\n\t})\n\tclient.AddListener(\"open\", func(e sse.Event) {\n\t\tfmt.Println(\"open \", e)\n\t})\n\tclient.Connect()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func NewStubWorker(id string, options ...Option) (WiFi, error) {\n\treturn &StubWorker{ID: id, Options: options}, nil\n}\nfunc runClient() {\n\ttime.Sleep(1 * time.Second)\n\tcfg := &sse.Config{\n\t\tURL: \"http://localhost:3000\",\n\t}\n\tclient, err := sse.New(cfg)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tclient.AddListener(\"ts\", func(e sse.Event) {\n\t\tfmt.Printf(\"%+v\\n\", e)\n\t})\n\tclient.AddListener(\"error\", func(e sse.Event) {\n\t\tfmt.Println(\"error \", e)\n\t})\n\tclient.AddListener(\"open\", func(e sse.Event) {\n\t\tfmt.Println(\"open \", e)\n\t})\n\tclient.Connect()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.ID)\n}"}
{"input": "func (v Value) LessThanEq(w Value) bool {\n\tif v == w {\n\t\treturn true\n\t}\n\treturn v.LessThan(w)\n}\nfunc NewStubWorker(id string, options ...Option) (WiFi, error) {\n\treturn &StubWorker{ID: id, Options: options}, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc TestRemoveDuplicates(t *testing.T) {\n\tnums := []int{1, 2, 3, 3, 5, 7, 7, 7, 11, 15}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{1, 1, 2}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{1}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{}\n\tfmt.Println(removeDuplicates(nums), nums)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestRPCDownload(t *testing.T) {\n\tif testing.Short() {\n\t\tt.SkipNow()\n\t}\n\tht, err := newHostTester(\"TestRPCDownload\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tnickname := \"TestRPCDownload1\"\n\tuploadData, err := ht.uploadFile(nickname, renewDisabled)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdownloadPath := filepath.Join(ht.persistDir, nickname+\".download\")\n\terr = ht.renter.Download(nickname, downloadPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdownloadData, err := ioutil.ReadFile(downloadPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(uploadData, downloadData) {\n\t\tt.Error(\"uploaded and downloaded file do not match\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tName: \"ProvidersSchema\",\n\t\tType: \"application/json\",\n\t\tSchema: tfjson.Schema{\n\t\t\tName: \"application/json\",\n\t\t\tType: \"application/json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (o *Offset) String() string {\n\treturn (*Size)(o).String()\n}\nfunc TestRPCDownload(t *testing.T) {\n\tif testing.Short() {\n\t\tt.SkipNow()\n\t}\n\tht, err := newHostTester(\"TestRPCDownload\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tnickname := \"TestRPCDownload1\"\n\tuploadData, err := ht.uploadFile(nickname, renewDisabled)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdownloadPath := filepath.Join(ht.persistDir, nickname+\".download\")\n\terr = ht.renter.Download(nickname, downloadPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdownloadData, err := ioutil.ReadFile(downloadPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(uploadData, downloadData) {\n\t\tt.Error(\"uploaded and downloaded file do not match\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tName: \"ProvidersSchema\",\n\t\tType: \"application/json\",\n\t\tSchema: tfjson.Schema{\n\t\t\tName: \"application/json\",\n\t\t\tType: \"application/json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\nfunc main() {\n\ta1 := make([]int, 100000000)\n\n\tfor i := 0; i < 100000000; i++ {\n\t\ta1[i] = rand.Int()\n\t}\n\n\tfmt.Printf(\"a1[0]: %d, a1[1]: %d, a1[2]: %d\\n\", a1[0], a1[1], a1[2])\n\n\tt0 := time.Now()\n\tquicksort(a1, 0, 100000000-1)\n\tt1 := time.Now()\n\tfmt.Printf(\"n of %v took %v to run.\\n\", len(a1), t1.Sub(t0))\n\tfmt.Printf(\"a1[0]: %d, a1[1]: %d, a1[2]: %d\\n\", a1[0], a1[1], a1[2])\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (o *Offset) String() string {\n\treturn (*Size)(o).String()\n}\nfunc main() {\n\ta1 := make([]int, 100000000)\n\n\tfor i := 0; i < 100000000; i++ {\n\t\ta1[i] = rand.Int()\n\t}\n\n\tfmt.Printf(\"a1[0]: %d, a1[1]: %d, a1[2]: %d\\n\", a1[0], a1[1], a1[2])\n\n\tt0 := time.Now()\n\tquicksort(a1, 0, 100000000-1)\n\tt1 := time.Now()\n\tfmt.Printf(\"n of %v took %v to run.\\n\", len(a1), t1.Sub(t0))\n\tfmt.Printf(\"a1[0]: %d, a1[1]: %d, a1[2]: %d\\n\", a1[0], a1[1], a1[2])\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (rest AdminController) add() Result{\n\treturn &JSONResult{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{}, nil\n}"}
{"input": "func RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\nfunc (rest AdminController) add() Result{\n\treturn &JSONResult{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "\nfunc RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvider: &tfjson.ProviderSchemas{\n\t\t\tName: \"chroot\",\n\t\t\tPath: \"../../../config/config.json\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t\tVersion: \"1.0\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (custom Custom) ID() string {\n\treturn custom.I()\n}\nfunc RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{}, nil\n}"}
{"input": "func IsIdentity(m Matrix) bool {\n\tmatch := func(element float64, row, column int) bool {\n\t\tif row == column {\n\t\t\treturn element == 1\n\t\t} else {\n\t\t\treturn element == 0\n\t\t}\n\t}\n\n\treturn isSpecialDiagonal(m, match)\n}\nfunc (custom Custom) ID() string {\n\treturn custom.I()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc IsIdentity(m Matrix) bool {\n\tmatch := func(element float64, row, column int) bool {\n\t\tif row == column {\n\t\t\treturn element == 1\n\t\t} else {\n\t\t\treturn element == 0\n\t\t}\n\t}\n\n\treturn isSpecialDiagonal(m, match)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func TestList_Exec(t *testing.T) {\n\tqtr_endtoend.TestRecipe(t, &List{})\n}\nfunc IsIdentity(m Matrix) bool {\n\tmatch := func(element float64, row, column int) bool {\n\t\tif row == column {\n\t\t\treturn element == 1\n\t\t} else {\n\t\t\treturn element == 0\n\t\t}\n\t}\n\n\treturn isSpecialDiagonal(m, match)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func langByID(c *bm.Context) {\n\tv := &language.Param{}\n\tif err := c.Bind(v); err != nil {\n\t\treturn\n\t}\n\tc.JSON(langSvc.LangByID(c, v.ID))\n}\nfunc TestList_Exec(t *testing.T) {\n\tqtr_endtoend.TestRecipe(t, &List{})\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.JSON(tf.JSON(ctx))\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func String(s string) uint32 {\n\th := DJBInit\n\tfor i := 0; i < len(s); i++ {\n\t\th = DJBCombine(h, uint32(s[i]))\n\t}\n\treturn h\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\nfunc String(s string) uint32 {\n\th := DJBInit\n\tfor i := 0; i < len(s); i++ {\n\t\th = DJBCombine(h, uint32(s[i]))\n\t}\n\treturn h\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx).Do(func(ctx context.Context) (*tfjson.ProviderSchemas, error) {\n\t\treturn tf.client.ProvidersSchemas(ctx).(*tfjson.ProviderSchemas)\n\t})\n}"}
{"input": "func (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\nfunc (s *Spark) request(req *http.Request) ([]byte, error) {\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", s.token))\n\treq.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\n\tres, err := httpClient.Do(req)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\tbs, err := ioutil.ReadAll(res.Body)\n\n\tif res.StatusCode != http.StatusOK {\n\t\tif res.StatusCode != 204 {\n\t\t\te := fmt.Sprintf(\"HTTP Status Code: %d\\n%s\", res.StatusCode, string(bs))\n\t\t\treturn nil, errors.New(e)\n\t\t}\n\t}\n\n\treturn bs, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func TestJSON(t *testing.T) {\n\tcm := New()\n\tfor i := 0; i < 100; i++ {\n\t\tsi := strconv.Itoa(i)\n\t\tcm.Set(si, si)\n\t}\n\n\tj, err := json.Marshal(cm)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar mwj MapWithJSON\n\n\tif err = json.Unmarshal(j, &mwj); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tokeys, nkeys := cm.Keys(), mwj.Keys()\n\n\tsort.Strings(okeys)\n\tsort.Strings(nkeys)\n\n\tif !reflect.DeepEqual(okeys, nkeys) {\n\t\tt.Fatal(\"!reflect.DeepEqual(okeys, nkeys)\")\n\t}\n}\nfunc (s *Spark) request(req *http.Request) ([]byte, error) {\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", s.token))\n\treq.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\n\tres, err := httpClient.Do(req)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\tbs, err := ioutil.ReadAll(res.Body)\n\n\tif res.StatusCode != http.StatusOK {\n\t\tif res.StatusCode != 204 {\n\t\t\te := fmt.Sprintf(\"HTTP Status Code: %d\\n%s\", res.StatusCode, string(bs))\n\t\t\treturn nil, errors.New(e)\n\t\t}\n\t}\n\n\treturn bs, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func langByID(c *bm.Context) {\n\tv := &language.Param{}\n\tif err := c.Bind(v); err != nil {\n\t\treturn\n\t}\n\tc.JSON(langSvc.LangByID(c, v.ID))\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.JSON(tf.config.ProvidersSchema)\n}"}
{"input": "func langByID(c *bm.Context) {\n\tv := &language.Param{}\n\tif err := c.Bind(v); err != nil {\n\t\treturn\n\t}\n\tc.JSON(langSvc.LangByID(c, v.ID))\n}\nfunc NewComponentsService(sling *sling.Sling) *ComponentService {\n\treturn &ComponentService{\n\t\tsling:    sling,\n\t\tendpoint: \"components\",\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.JSON(tf.config.ProvidersSchema)\n}"}
{"input": "func TestJSON(t *testing.T) {\n\tcm := New()\n\tfor i := 0; i < 100; i++ {\n\t\tsi := strconv.Itoa(i)\n\t\tcm.Set(si, si)\n\t}\n\n\tj, err := json.Marshal(cm)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar mwj MapWithJSON\n\n\tif err = json.Unmarshal(j, &mwj); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tokeys, nkeys := cm.Keys(), mwj.Keys()\n\n\tsort.Strings(okeys)\n\tsort.Strings(nkeys)\n\n\tif !reflect.DeepEqual(okeys, nkeys) {\n\t\tt.Fatal(\"!reflect.DeepEqual(okeys, nkeys)\")\n\t}\n}\nfunc NewComponentsService(sling *sling.Sling) *ComponentService {\n\treturn &ComponentService{\n\t\tsling:    sling,\n\t\tendpoint: \"components\",\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.sling.Endpoint)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestGetVersion(t *testing.T) {\n\ttc := &Toolchain{GoTool: filepath.Join(os.Getenv(\"DATA\"), \"bin/go\")}\n\n\tver, err := tc.GoMinorVersion()\n\trequire.NoError(t, err)\n\trequire.Equal(t, 17, ver)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (s *Stack) Clear() {\n\t*s = Stack{}\n}\nfunc TestGetVersion(t *testing.T) {\n\ttc := &Toolchain{GoTool: filepath.Join(os.Getenv(\"DATA\"), \"bin/go\")}\n\n\tver, err := tc.GoMinorVersion()\n\trequire.NoError(t, err)\n\trequire.Equal(t, 17, ver)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{}, nil\n}"}
{"input": "\nfunc TestCredentialsGetWithProviderName(t *testing.T) {\n\tstub := &stubProvider{}\n\n\tc := NewCredentials(stub)\n\n\tcreds, err := c.Get()\n\tassert.Nil(t, err, \"Expected no error\")\n\tassert.Equal(t, creds.ProviderName, \"stubProvider\", \"Expected provider name to match\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tProviderName: tf.ProviderName,\n\t\t\tProvider: tf.Provider,\n\t\t}, nil\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (c currencyInfo) decimals() int {\n\treturn int(c & curDigitMask)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func Example() {\n\tbuffer := SetupBuffer()\n\tdefer buffer.DumpToStdout()\n\n\n\tbuffer.Clear()\n}\nfunc (c currencyInfo) decimals() int {\n\treturn int(c & curDigitMask)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc Example() {\n\tbuffer := SetupBuffer()\n\tdefer buffer.DumpToStdout()\n\n\n\tbuffer.Clear()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (F *FP) Mul(b *FP) {\n\tF.mul(b)\n}\nfunc Example() {\n\tbuffer := SetupBuffer()\n\tdefer buffer.DumpToStdout()\n\n\n\tbuffer.Clear()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (i *Info) SetCommit(commit string) {\n\tif i == nil {\n\t\treturn\n\t}\n\ti.commit = commit\n}\nfunc (F *FP) Mul(b *FP) {\n\tF.mul(b)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (m Move) Valid(table Table) bool {\n\tfor x := m.Src.X; x <= m.Dest.X; x++ {\n\t\tfor y := m.Src.Y; y <= m.Dest.Y; y++ {\n\t\t\tcell := table[y][x]\n\t\t\tswitch cell {\n\t\t\tcase HOLLOW, LAND:\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (i *Info) SetCommit(commit string) {\n\tif i == nil {\n\t\treturn\n\t}\n\ti.commit = commit\n}\nfunc (m Move) Valid(table Table) bool {\n\tfor x := m.Src.X; x <= m.Dest.X; x++ {\n\t\tfor y := m.Src.Y; y <= m.Dest.Y; y++ {\n\t\t\tcell := table[y][x]\n\t\t\tswitch cell {\n\t\t\tcase HOLLOW, LAND:\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (_m *MockTopologyWatcherInterface) WaitForInitialTopology() error {\n\tret := _m.ctrl.Call(_m, \"WaitForInitialTopology\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tret := tf.ctrl.Call(_tf, \"ProvidersSchema\")\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func (_m *MockTopologyWatcherInterface) WaitForInitialTopology() error {\n\tret := _m.ctrl.Call(_m, \"WaitForInitialTopology\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc (u *UnitOrFaceAmountOrCode1Choice) SetUnit(value string) {\n\tu.Unit = (*DecimalNumber)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tret := tf.ctrl.Call(_tf, \"ProvidersSchema\")\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func (i *Info) SetCommit(commit string) {\n\tif i == nil {\n\t\treturn\n\t}\n\ti.commit = commit\n}\nfunc (u *UnitOrFaceAmountOrCode1Choice) SetUnit(value string) {\n\tu.Unit = (*DecimalNumber)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (request CreateBootVolumeRequest) String() string {\n\treturn common.PointerString(request)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (_m *MockTopologyWatcherInterface) WaitForInitialTopology() error {\n\tret := _m.ctrl.Call(_m, \"WaitForInitialTopology\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc (request CreateBootVolumeRequest) String() string {\n\treturn common.PointerString(request)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tret := tf.ctrl.Call(_tf, \"ProvidersSchema\")\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "\nfunc networkAsChild(arg interface{}) interface{} {\n\tnetwork := arg.(models.Network)\n\treturn networkIdxElem{Network: network}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func init() {\n\tapp.RegisterComponent(&MenuWindow{})\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func PutReader(c context.Context, path string, r io.Reader) error {\n\treturn FromContext(c).PutReader(path, r)\n}\nfunc init() {\n\tapp.RegisterComponent(&MenuWindow{})\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc mangoEdit(c *bm.Context) {\n\tparam := new(model.ReqMangoEdit)\n\tif err := c.Bind(param); err != nil {\n\t\treturn\n\t}\n\tc.JSON(nil, tvSrv.MangoEdit(c, param))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.GetProvidersSchema(ctx)\n}"}
{"input": "func PutReader(c context.Context, path string, r io.Reader) error {\n\treturn FromContext(c).PutReader(path, r)\n}\nfunc mangoEdit(c *bm.Context) {\n\tparam := new(model.ReqMangoEdit)\n\tif err := c.Bind(param); err != nil {\n\t\treturn\n\t}\n\tc.JSON(nil, tvSrv.MangoEdit(c, param))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (v *filesystemVolume) Setup() (*libvirtxml.DomainDisk, *libvirtxml.DomainFilesystem, error) {\n\tfsys := v.owner.FileSystem()\n\terr := os.MkdirAll(v.volumeMountPoint, 0777)\n\tif err == nil {\n\t\terr = fsys.ChownForEmulator(v.volumeMountPoint, false)\n\t}\n\tif err == nil {\n\t\terr = fsys.Mount(v.mount.HostPath, v.volumeMountPoint, \"bind\", true)\n\t}\n\tif err == nil {\n\t\terr = fsys.ChownForEmulator(v.volumeMountPoint, v.chownRecursively)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to create vm pod path %q: %v\", v.volumeMountPoint, err)\n\t}\n\n\tfsDef := &libvirtxml.DomainFilesystem{\n\t\tAccessMode: \"squash\",\n\t\tSource:     &libvirtxml.DomainFilesystemSource{Mount: &libvirtxml.DomainFilesystemSourceMount{Dir: v.volumeMountPoint}},\n\t\tTarget:     &libvirtxml.DomainFilesystemTarget{Dir: path.Base(v.mount.ContainerPath)},\n\t}\n\n\treturn nil, fsDef, nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (v *filesystemVolume) Setup() (*libvirtxml.DomainDisk, *libvirtxml.DomainFilesystem, error) {\n\tfsys := v.owner.FileSystem()\n\terr := os.MkdirAll(v.volumeMountPoint, 0777)\n\tif err == nil {\n\t\terr = fsys.ChownForEmulator(v.volumeMountPoint, false)\n\t}\n\tif err == nil {\n\t\terr = fsys.Mount(v.mount.HostPath, v.volumeMountPoint, \"bind\", true)\n\t}\n\tif err == nil {\n\t\terr = fsys.ChownForEmulator(v.volumeMountPoint, v.chownRecursively)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to create vm pod path %q: %v\", v.volumeMountPoint, err)\n\t}\n\n\tfsDef := &libvirtxml.DomainFilesystem{\n\t\tAccessMode: \"squash\",\n\t\tSource:     &libvirtxml.DomainFilesystemSource{Mount: &libvirtxml.DomainFilesystemSourceMount{Dir: v.volumeMountPoint}},\n\t\tTarget:     &libvirtxml.DomainFilesystemTarget{Dir: path.Base(v.mount.ContainerPath)},\n\t}\n\n\treturn nil, fsDef, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (S) Init() {}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func exitWithError(err error) {\n\tfmt.Fprintln(os.Stderr, err)\n\tos.Exit(1)\n}\nfunc (S) Init() {}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc exitWithError(err error) {\n\tfmt.Fprintln(os.Stderr, err)\n\tos.Exit(1)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, exitWithError(exitWithError)\n}"}
{"input": "\nfunc (S) Init() {}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (c Config) Host() string {\n\treturn c.Hostname\n}\nfunc (S) Init() {}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProvidersSchema(ctx)\n}"}
{"input": "func ExampleNewStringSet() {\n\ta := NewStringSet()\n\ta.Add(\"a\")\n\ta.Add(\"b\")\n\n\tb := NewStringSet(\"b\", \"a\")\n\n\tfmt.Println(a.Equals(b))\n\n}\nfunc (c Config) Host() string {\n\treturn c.Hostname\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func NewCommand(name string) *CleanCommand {\n\treturn &CleanCommand{flags: flag.NewFlagSet(name, flag.ExitOnError)}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\nfunc NewCommand(name string) *CleanCommand {\n\treturn &CleanCommand{flags: flag.NewFlagSet(name, flag.ExitOnError)}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc ReadJsonConfFileServiceTest(t *testing.T) {\n\n\tconfFilename := \"../testdata/fixtures/system.json\"\n\tf, _ := ReadJsonConfFileService(confFilename)\n\n\tif len(f.Files) < 1 {\n\t\tt.Fatal(\"no Files found in \" + confFilename)\n\t}\n\n\tvar actual string = \"\"\n\tfor i := 0; i < len(f.Files); i++ {\n\t\tactual = f.Files[i].Pattern\t\n\t\tbreak\n\t}\n\texpected := \"installed.*\"\n\n\tassert.Equal(t, expected, actual, \"unexpected config pattern\")\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"system.json\",\n\t\t\tType: \"system.json\",\n\t\t\tName: \"system.json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (e ExceededValueLengthLimit) Error() string {\n\treturn \"value length (\" + strconv.Itoa(int(e)) + \") exceeded maxiumum allowed (\" + strconv.Itoa(valueLimit) + \")\"\n}\nfunc ReadJsonConfFileServiceTest(t *testing.T) {\n\n\tconfFilename := \"../testdata/fixtures/system.json\"\n\tf, _ := ReadJsonConfFileService(confFilename)\n\n\tif len(f.Files) < 1 {\n\t\tt.Fatal(\"no Files found in \" + confFilename)\n\t}\n\n\tvar actual string = \"\"\n\tfor i := 0; i < len(f.Files); i++ {\n\t\tactual = f.Files[i].Pattern\t\n\t\tbreak\n\t}\n\texpected := \"installed.*\"\n\n\tassert.Equal(t, expected, actual, \"unexpected config pattern\")\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providers\",\n\t\t\tMaxSize:  float64(valueLimit),\n\t\t}, nil\n\t}, nil\n}"}
{"input": "func CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\nfunc (e ExceededValueLengthLimit) Error() string {\n\treturn \"value length (\" + strconv.Itoa(int(e)) + \") exceeded maxiumum allowed (\" + strconv.Itoa(valueLimit) + \")\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func ExampleNewStringSet() {\n\ta := NewStringSet()\n\ta.Add(\"a\")\n\ta.Add(\"b\")\n\n\tb := NewStringSet(\"b\", \"a\")\n\n\tfmt.Println(a.Equals(b))\n\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func ExampleNewStringSet() {\n\ta := NewStringSet()\n\ta.Add(\"a\")\n\ta.Add(\"b\")\n\n\tb := NewStringSet(\"b\", \"a\")\n\n\tfmt.Println(a.Equals(b))\n\n}\nfunc RandHit(b1, b2 int32) bool {\n\tif b1 >= b2 {\n\t\treturn true\n\t}\n\tif b1 <= 0 {\n\t\treturn false\n\t}\n\tb3 := RandInterval(1, b2)\n\tif b3 <= b1 {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func ReadJsonConfFileServiceTest(t *testing.T) {\n\n\tconfFilename := \"../testdata/fixtures/system.json\"\n\tf, _ := ReadJsonConfFileService(confFilename)\n\n\tif len(f.Files) < 1 {\n\t\tt.Fatal(\"no Files found in \" + confFilename)\n\t}\n\n\tvar actual string = \"\"\n\tfor i := 0; i < len(f.Files); i++ {\n\t\tactual = f.Files[i].Pattern\t\n\t\tbreak\n\t}\n\texpected := \"installed.*\"\n\n\tassert.Equal(t, expected, actual, \"unexpected config pattern\")\n\n}\nfunc RandHit(b1, b2 int32) bool {\n\tif b1 >= b2 {\n\t\treturn true\n\t}\n\tif b1 <= 0 {\n\t\treturn false\n\t}\n\tb3 := RandInterval(1, b2)\n\tif b3 <= b1 {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"system.json\",\n\t\t\tName: \"system.json\",\n\t\t\tType: \"system.json\",\n\t\t},\n\t}, nil\n}"}
{"input": "\nfunc (c *Client) InspectTask(id string) (*swarm.Task, error) {\n\tresp, err := c.do(http.MethodGet, \"/tasks/\"+id, doOptions{})\n\tif err != nil {\n\t\tif e, ok := err.(*Error); ok && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchTask{ID: id}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar task swarm.Task\n\tif err := json.NewDecoder(resp.Body).Decode(&task); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &task, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc NewRepositoryWithDefaults() core_config.Repository {\n\tconfigRepo := NewRepositoryWithAccessToken(core_config.TokenInfo{\n\t\tUserGuid: \"my-user-guid\",\n\t\tUsername: \"my-user\",\n\t\tEmail:    \"my-user-email\",\n\t})\n\n\tconfigRepo.SetSpaceFields(models.SpaceFields{\n\t\tName: \"my-space\",\n\t\tGuid: \"my-space-guid\",\n\t})\n\tconfigRepo.SetOrganizationFields(models.OrganizationFields{\n\t\tName: \"my-org\",\n\t\tGuid: \"my-org-guid\",\n\t})\n\n\treturn configRepo\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func ContextWithTokenManager(ctx context.Context, tm interface{}) context.Context {\n\treturn context.WithValue(ctx, contextTokenManagerKey, tm)\n}\nfunc NewRepositoryWithDefaults() core_config.Repository {\n\tconfigRepo := NewRepositoryWithAccessToken(core_config.TokenInfo{\n\t\tUserGuid: \"my-user-guid\",\n\t\tUsername: \"my-user\",\n\t\tEmail:    \"my-user-email\",\n\t})\n\n\tconfigRepo.SetSpaceFields(models.SpaceFields{\n\t\tName: \"my-space\",\n\t\tGuid: \"my-space-guid\",\n\t})\n\tconfigRepo.SetOrganizationFields(models.OrganizationFields{\n\t\tName: \"my-org\",\n\t\tGuid: \"my-org-guid\",\n\t})\n\n\treturn configRepo\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc ContextWithTokenManager(ctx context.Context, tm interface{}) context.Context {\n\treturn context.WithValue(ctx, contextTokenManagerKey, tm)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func TestInsertData(t *testing.T) {\n\tstats := make(Stats, 0, 3)\n\tstats.InsertData(0)\n\tstats.InsertData(1)\n\tstats.InsertData(2)\n\tstats.InsertData(3)\n\tfor i, s := range stats {\n\t\tif int64(i) != s {\n\t\t\tt.Fatal(\"numbers don't match\", i , s, []int64(stats))\n\t\t}\n\t}\n}\nfunc ContextWithTokenManager(ctx context.Context, tm interface{}) context.Context {\n\treturn context.WithValue(ctx, contextTokenManagerKey, tm)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\nfunc TestInsertData(t *testing.T) {\n\tstats := make(Stats, 0, 3)\n\tstats.InsertData(0)\n\tstats.InsertData(1)\n\tstats.InsertData(2)\n\tstats.InsertData(3)\n\tfor i, s := range stats {\n\t\tif int64(i) != s {\n\t\t\tt.Fatal(\"numbers don't match\", i , s, []int64(stats))\n\t\t}\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (fn ActionsDeleteHandlerFunc) Handle(params ActionsDeleteParams, principal *models.Principal) middleware.Responder {\n\treturn fn(params, principal)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\nfunc (fn ActionsDeleteHandlerFunc) Handle(params ActionsDeleteParams, principal *models.Principal) middleware.Responder {\n\treturn fn(params, principal)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.config.ProvidersSchema)\n}"}
{"input": "func (r *LimitRset) Plan(ctx context.Context) (plan.Plan, error) {\n\treturn &plans.LimitDefaultPlan{Count: r.Count, Src: r.Src, Fields: r.Src.GetFields()}, nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn &tfjson.ProviderSchemas{\n\t\tProviders: tf.Providers,\n\t}, nil\n}"}
{"input": "func (r *LimitRset) Plan(ctx context.Context) (plan.Plan, error) {\n\treturn &plans.LimitDefaultPlan{Count: r.Count, Src: r.Src, Fields: r.Src.GetFields()}, nil\n}\nfunc toMessage(resp *pb.ReceivedMessage) (*Message, error) {\n\tif resp.Message == nil {\n\t\treturn &Message{ackID: resp.AckId}, nil\n\t}\n\n\tpubTime, err := ptypes.Timestamp(resp.Message.PublishTime)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Message{\n\t\tackID:       resp.AckId,\n\t\tData:        resp.Message.Data,\n\t\tAttributes:  resp.Message.Attributes,\n\t\tID:          resp.Message.MessageId,\n\t\tPublishTime: pubTime,\n\t}, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn &tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(),\n\t}, nil\n}"}
{"input": "func CurrentExecutable() (string, error) {\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}\nfunc toMessage(resp *pb.ReceivedMessage) (*Message, error) {\n\tif resp.Message == nil {\n\t\treturn &Message{ackID: resp.AckId}, nil\n\t}\n\n\tpubTime, err := ptypes.Timestamp(resp.Message.PublishTime)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Message{\n\t\tackID:       resp.AckId,\n\t\tData:        resp.Message.Data,\n\t\tAttributes:  resp.Message.Attributes,\n\t\tID:          resp.Message.MessageId,\n\t\tPublishTime: pubTime,\n\t}, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (r *LimitRset) Plan(ctx context.Context) (plan.Plan, error) {\n\treturn &plans.LimitDefaultPlan{Count: r.Count, Src: r.Src, Fields: r.Src.GetFields()}, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn &tfjson.ProviderSchemas{\n\t\tProviders: tf.Providers,\n\t}, nil\n}"}
{"input": "func journal_seek_tail() int {\n\n\treturn int(C.journal_seek_tail())\n}\nfunc (r *LimitRset) Plan(ctx context.Context) (plan.Plan, error) {\n\treturn &plans.LimitDefaultPlan{Count: r.Count, Src: r.Src, Fields: r.Src.GetFields()}, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn &tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (km *hashedKeyMutex) UnlockKey(id string) error {\n\tkm.mutexes[km.hash(id)%len(km.mutexes)].Unlock()\n\treturn nil\n}\nfunc journal_seek_tail() int {\n\n\treturn int(C.journal_seek_tail())\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func NewFakeHost(kubeClient clientset.Interface) *fakeNetworkHost {\n\thost := &fakeNetworkHost{kubeClient: kubeClient, Legacy: true, Runtime: &containertest.FakeRuntime{}}\n\treturn host\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.kubeClient.ProvidersSchemas(ctx)\n}"}
{"input": "func RegisterForServer() error {\n\tfor _, c := range components {\n\t\tif err := c.registerForServer(); err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t}\n\treturn nil\n}\nfunc NewFakeHost(kubeClient clientset.Interface) *fakeNetworkHost {\n\thost := &fakeNetworkHost{kubeClient: kubeClient, Legacy: true, Runtime: &containertest.FakeRuntime{}}\n\treturn host\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func RegisterForServer() error {\n\tfor _, c := range components {\n\t\tif err := c.registerForServer(); err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviders: []tfjson.ProviderSchema{\n\t\t\t{\n\t\t\t\tType:     tfjson.TypeProviderSchemas,\n\t\t\t\tName: \"providers\",\n\t\t\t\tDescription: \"The provider schema for this provider\",\n\t\t\t\tSchema: tfjson.SchemaSchema{\n\t\t\t\t\tName: \"provider\",\n\t\t\t\t\tType:     tfjson.TypeProviderSchemas,\n\t\t\t\t\tType:     tfjson.TypeProviderSchemas,\n\t\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n}"}
{"input": "func RegisterForServer() error {\n\tfor _, c := range components {\n\t\tif err := c.registerForServer(); err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t}\n\treturn nil\n}\nfunc Test_unix_oc_path(t *testing.T) {\n\tapi := libmachine.NewClient(\"foo\", \"foo\")\n\tdefer api.Close()\n\tshellConfig, err := getOcShellConfig(api, \"/Users/john/.minishift/cache/oc/v1.5.0/oc\", \"bash\", false)\n\n\tassert.NoError(t, err)\n\texpectedOcDirPath := \"/Users/john/.minishift/cache/oc/v1.5.0\"\n\tassert.Equal(t, shellConfig.OcDirPath, expectedOcDirPath)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providers\",\n\t\t\tType: \"application/json\",\n\t\t\tType: \"application/json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func (format *Base64Encode) getEncodedContent(content []byte) []byte {\n\tencodedLen := format.dictionary.EncodedLen(len(content))\n\tencoded := make([]byte, encodedLen)\n\n\tformat.dictionary.Encode(encoded, content)\n\treturn encoded\n}\nfunc Test_unix_oc_path(t *testing.T) {\n\tapi := libmachine.NewClient(\"foo\", \"foo\")\n\tdefer api.Close()\n\tshellConfig, err := getOcShellConfig(api, \"/Users/john/.minishift/cache/oc/v1.5.0/oc\", \"bash\", false)\n\n\tassert.NoError(t, err)\n\texpectedOcDirPath := \"/Users/john/.minishift/cache/oc/v1.5.0\"\n\tassert.Equal(t, shellConfig.OcDirPath, expectedOcDirPath)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (format *Base64Encode) getEncodedContent(content []byte) []byte {\n\tencodedLen := format.dictionary.EncodedLen(len(content))\n\tencoded := make([]byte, encodedLen)\n\n\tformat.dictionary.Encode(encoded, content)\n\treturn encoded\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.getProvidersSchema(ctx)\n}"}
{"input": "func (response ListCrossConnectLocationsResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\nfunc (format *Base64Encode) getEncodedContent(content []byte) []byte {\n\tencodedLen := format.dictionary.EncodedLen(len(content))\n\tencoded := make([]byte, encodedLen)\n\n\tformat.dictionary.Encode(encoded, content)\n\treturn encoded\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.getProvidersSchema(ctx)\n}"}
{"input": "func (km *hashedKeyMutex) UnlockKey(id string) error {\n\tkm.mutexes[km.hash(id)%len(km.mutexes)].Unlock()\n\treturn nil\n}\nfunc (response ListCrossConnectLocationsResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc Build(r *request.Request) {\n\tbody := url.Values{\n\t\t\"Action\":  {r.Operation.Name},\n\t\t\"Version\": {r.Metadata.APIVersion},\n\t}\n\tif err := queryutil.Parse(body, r.Params, false); err != nil {\n\t\tr.Error = awserr.New(\"SerializationError\", \"failed encoding Query request\", err)\n\t\treturn\n\t}\n\n\tif r.ExpireTime == 0 {\n\t\tr.HTTPRequest.Method = \"POST\"\n\t\tr.HTTPRequest.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded; charset=utf-8\")\n\t\tr.SetBufferBody([]byte(body.Encode()))\n\t} else { \n\t\tr.HTTPRequest.Method = \"GET\"\n\t\tr.HTTPRequest.URL.RawQuery = body.Encode()\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tMetadata: tf.Metadata,\n\t}, nil\n}"}
{"input": "func (o *GetDebuginfoOK) SetPayload(payload *models.DebugInfo) {\n\to.Payload = payload\n}\nfunc Build(r *request.Request) {\n\tbody := url.Values{\n\t\t\"Action\":  {r.Operation.Name},\n\t\t\"Version\": {r.Metadata.APIVersion},\n\t}\n\tif err := queryutil.Parse(body, r.Params, false); err != nil {\n\t\tr.Error = awserr.New(\"SerializationError\", \"failed encoding Query request\", err)\n\t\treturn\n\t}\n\n\tif r.ExpireTime == 0 {\n\t\tr.HTTPRequest.Method = \"POST\"\n\t\tr.HTTPRequest.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded; charset=utf-8\")\n\t\tr.SetBufferBody([]byte(body.Encode()))\n\t} else { \n\t\tr.HTTPRequest.Method = \"GET\"\n\t\tr.HTTPRequest.URL.RawQuery = body.Encode()\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc (s *scopePool) Get() *Scope {\n\treturn s.pool.Get().(*Scope)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc ListWAL(ctx context.Context, s logical.Storage) ([]string, error) {\n\tkeys, err := s.List(ctx, WALPrefix)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i, k := range keys {\n\t\tkeys[i] = strings.TrimPrefix(k, WALPrefix)\n\t}\n\n\treturn keys, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"wal\",\n\t\tSchema: tfjson.Schema{\n\t\t\tType: \"wal\",\n\t\t\tName: \"WAL\",\n\t\t\tType: \"wal\",\n\t\t\tSchema: tfjson.Schema{\n\t\t\t\tType: \"wal\",\n\t\t\t\tName: \"WAL\",\n\t\t\t\tName: \"WAL\",\n\t\t\t\tType: \"wal\",\n\t\t\t\tType: \"wal\",\n\t\t\t},\n\t\t\t},\n\t\t}, nil\n}"}
{"input": "func Version2_12() APIVersion {\n\treturn APIVersion{label: internalAPIVersion2_12, order: 1}\n}\nfunc ListWAL(ctx context.Context, s logical.Storage) ([]string, error) {\n\tkeys, err := s.List(ctx, WALPrefix)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i, k := range keys {\n\t\tkeys[i] = strings.TrimPrefix(k, WALPrefix)\n\t}\n\n\treturn keys, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tName: \"schemas\",\n\t\tType: \"application/json\",\n\t\tSchema: tfjson.Schema{\n\t\t\tName: \"schemas\",\n\t\t\tType: \"application/json\",\n\t\t\tDescription: \"API Version 2_12\",\n\t\t},\n\t}, nil\n}"}
{"input": "func init() {\n\thttp.Handle(\"/view\", appHandler(viewRecord))\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func init() {\n\thttp.Handle(\"/view\", appHandler(viewRecord))\n}\nfunc (i *DefaultDecorator) FromString(field string) (interface{}, error) {\n\treturn field, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func Version2_12() APIVersion {\n\treturn APIVersion{label: internalAPIVersion2_12, order: 1}\n}\nfunc (i *DefaultDecorator) FromString(field string) (interface{}, error) {\n\treturn field, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func init() {\n\thttp.HandleFunc(\"/\", root)\n\thttp.HandleFunc(\"/subpkga\", subpkga.Root)\n\tutil.Log(\"aesample init()\")\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func Escape(s string) string {\n\treturn escaper.Replace(s)\n}\nfunc init() {\n\thttp.HandleFunc(\"/\", root)\n\thttp.HandleFunc(\"/subpkga\", subpkga.Root)\n\tutil.Log(\"aesample init()\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func Escape(s string) string {\n\treturn escaper.Replace(s)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func Escape(s string) string {\n\treturn escaper.Replace(s)\n}\nfunc (r *ConsumerMetadataResponse) encode(pe packetEncoder) error {\n\tif r.Coordinator == nil {\n\t\tr.Coordinator = new(Broker)\n\t\tr.Coordinator.id = r.CoordinatorID\n\t\tr.Coordinator.addr = net.JoinHostPort(r.CoordinatorHost, strconv.Itoa(int(r.CoordinatorPort)))\n\t}\n\n\ttmp := &FindCoordinatorResponse{\n\t\tVersion:     0,\n\t\tErr:         r.Err,\n\t\tCoordinator: r.Coordinator,\n\t}\n\n\tif err := tmp.encode(pe); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (o DeleteServerMetadataResponse) String() string {\n\tdata, err := utils.Marshal(o)\n\tif err != nil {\n\t\treturn \"DeleteServerMetadataResponse struct{}\"\n\t}\n\n\treturn strings.Join([]string{\"DeleteServerMetadataResponse\", string(data)}, \" \")\n}\nfunc (r *ConsumerMetadataResponse) encode(pe packetEncoder) error {\n\tif r.Coordinator == nil {\n\t\tr.Coordinator = new(Broker)\n\t\tr.Coordinator.id = r.CoordinatorID\n\t\tr.Coordinator.addr = net.JoinHostPort(r.CoordinatorHost, strconv.Itoa(int(r.CoordinatorPort)))\n\t}\n\n\ttmp := &FindCoordinatorResponse{\n\t\tVersion:     0,\n\t\tErr:         r.Err,\n\t\tCoordinator: r.Coordinator,\n\t}\n\n\tif err := tmp.encode(pe); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"application/json\",\n\t\tSchema: tfjson.NewProviderSchemas(),\n\t}, nil\n}"}
{"input": "\nfunc (o DeleteServerMetadataResponse) String() string {\n\tdata, err := utils.Marshal(o)\n\tif err != nil {\n\t\treturn \"DeleteServerMetadataResponse struct{}\"\n\t}\n\n\treturn strings.Join([]string{\"DeleteServerMetadataResponse\", string(data)}, \" \")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (carPlatform *Platform) WritePackage(spec *pb.ChaincodeSpec, tw *tar.Writer) error {\n\n\tpath, err := download(spec.ChaincodeID.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tspec.ChaincodeID.Name, err = generateHashcode(spec, path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error generating hashcode: %s\", err)\n\t}\n\n\tvar buf []string\n\n\tbuf = append(buf, viper.GetString(\"chaincode.car.Dockerfile\"))\n\tbuf = append(buf, \"COPY package.car /tmp/package.car\")\n\tbuf = append(buf, fmt.Sprintf(\"RUN chaintool buildcar /tmp/package.car -o $GOPATH/bin/%s && rm /tmp/package.car\", spec.ChaincodeID.Name))\n\n\tdockerFileContents := strings.Join(buf, \"\\n\")\n\tdockerFileSize := int64(len([]byte(dockerFileContents)))\n\n\tvar zeroTime time.Time\n\ttw.WriteHeader(&tar.Header{Name: \"Dockerfile\", Size: dockerFileSize, ModTime: zeroTime, AccessTime: zeroTime, ChangeTime: zeroTime})\n\ttw.Write([]byte(dockerFileContents))\n\n\terr = cutil.WriteFileToPackage(path, \"package.car\", tw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\nfunc (o DeleteServerMetadataResponse) String() string {\n\tdata, err := utils.Marshal(o)\n\tif err != nil {\n\t\treturn \"DeleteServerMetadataResponse struct{}\"\n\t}\n\n\treturn strings.Join([]string{\"DeleteServerMetadataResponse\", string(data)}, \" \")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\n\tvar providerSchemas tfjson.ProviderSchemas\n\n\tif err := tf.GetProviderSchemas(ctx); err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn &providerSchemas, nil\n}"}
{"input": "func init() {\n\thttp.Handle(\"/view\", appHandler(viewRecord))\n}\nfunc (carPlatform *Platform) WritePackage(spec *pb.ChaincodeSpec, tw *tar.Writer) error {\n\n\tpath, err := download(spec.ChaincodeID.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tspec.ChaincodeID.Name, err = generateHashcode(spec, path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error generating hashcode: %s\", err)\n\t}\n\n\tvar buf []string\n\n\tbuf = append(buf, viper.GetString(\"chaincode.car.Dockerfile\"))\n\tbuf = append(buf, \"COPY package.car /tmp/package.car\")\n\tbuf = append(buf, fmt.Sprintf(\"RUN chaintool buildcar /tmp/package.car -o $GOPATH/bin/%s && rm /tmp/package.car\", spec.ChaincodeID.Name))\n\n\tdockerFileContents := strings.Join(buf, \"\\n\")\n\tdockerFileSize := int64(len([]byte(dockerFileContents)))\n\n\tvar zeroTime time.Time\n\ttw.WriteHeader(&tar.Header{Name: \"Dockerfile\", Size: dockerFileSize, ModTime: zeroTime, AccessTime: zeroTime, ChangeTime: zeroTime})\n\ttw.Write([]byte(dockerFileContents))\n\n\terr = cutil.WriteFileToPackage(path, \"package.car\", tw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc Test(t *testing.T) {\n\tsetupToolsTests()\n\tsetupSimpleStreamsTests(t)\n\tgc.TestingT(t)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc TestRuntimeemitter(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Runtime Emitter Suite\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func CreateFromFolder(folder string) (d *Design, err error) {\n\td = NewDesign()\n\terr = d.ImportDesignFolder(folder, \"\")\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"in design.CreateFromFolder: \"+folder+\"\\n\")\n\t}\n\treturn\n}\nfunc TestRuntimeemitter(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Runtime Emitter Suite\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "func NewCustomLinks(links map[string]string) ([]CustomLink, error) {\n\tcustomLinks := make([]CustomLink, 0, len(links))\n\tfor name, link := range links {\n\t\tif name == \"\" {\n\t\t\treturn nil, errors.New(\"customLink missing key for Name\")\n\t\t}\n\t\tif link == \"\" {\n\t\t\treturn nil, errors.New(\"customLink missing value for URL\")\n\t\t}\n\t\t_, err := url.Parse(link)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcustomLink := CustomLink{\n\t\t\tName: name,\n\t\t\tURL:  link,\n\t\t}\n\t\tcustomLinks = append(customLinks, customLink)\n\t}\n\n\treturn customLinks, nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func NewCustomLinks(links map[string]string) ([]CustomLink, error) {\n\tcustomLinks := make([]CustomLink, 0, len(links))\n\tfor name, link := range links {\n\t\tif name == \"\" {\n\t\t\treturn nil, errors.New(\"customLink missing key for Name\")\n\t\t}\n\t\tif link == \"\" {\n\t\t\treturn nil, errors.New(\"customLink missing value for URL\")\n\t\t}\n\t\t_, err := url.Parse(link)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcustomLink := CustomLink{\n\t\t\tName: name,\n\t\t\tURL:  link,\n\t\t}\n\t\tcustomLinks = append(customLinks, customLink)\n\t}\n\n\treturn customLinks, nil\n}\nfunc (err *UserError) Cause() error {\n\treturn err.error\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func CreateFromFolder(folder string) (d *Design, err error) {\n\td = NewDesign()\n\terr = d.ImportDesignFolder(folder, \"\")\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"in design.CreateFromFolder: \"+folder+\"\\n\")\n\t}\n\treturn\n}\nfunc (err *UserError) Cause() error {\n\treturn err.error\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (m *CT_Markup) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n\tfor _, attr := range start.Attr {\n\t\tif attr.Name.Local == \"id\" {\n\t\t\tparsed, err := strconv.ParseInt(attr.Value, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tm.IdAttr = parsed\n\t\t}\n\t}\n\tfor {\n\t\ttok, err := d.Token()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing CT_Markup: %s\", err)\n\t\t}\n\t\tif el, ok := tok.(xml.EndElement); ok && el.Name == start.Name {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (ft *fakeTicker) Stop() {\n\tft.timer.Stop()\n}\nfunc (m *CT_Markup) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n\tfor _, attr := range start.Attr {\n\t\tif attr.Name.Local == \"id\" {\n\t\t\tparsed, err := strconv.ParseInt(attr.Value, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tm.IdAttr = parsed\n\t\t}\n\t}\n\tfor {\n\t\ttok, err := d.Token()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing CT_Markup: %s\", err)\n\t\t}\n\t\tif el, ok := tok.(xml.EndElement); ok && el.Name == start.Name {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc NewSamplesBuffer(size int) *SamplesBuffer {\n\treturn &SamplesBuffer{\n\t\tindex:   -1,\n\t\tmaxSize: size,\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc LogHttpRequest(r *http.Request, v ...string) {\n\tserializedHeaders := bytes.Buffer{}\n\tr.Header.Write(&serializedHeaders)\n\n\tprintf := log.Printf\n\tif Logger != nil {\n\t\tprintf = Logger.Printf\n\t}\n\n\tprintf(\n\t\tLogRequestTemplate,\n\t\tstrings.Join(v, \" \"),\n\t\tr.URL.String(),\n\t\tr.Method,\n\t\ttime.Now(),\n\t\tserializedHeaders.String(),\n\t\t\"<hidden>\",\n\t\tdebug.Stack(),\n\t)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func Ttf(buf []byte) bool {\n\treturn len(buf) > 4 &&\n\t\tbuf[0] == 0x00 && buf[1] == 0x01 &&\n\t\tbuf[2] == 0x00 && buf[3] == 0x00 &&\n\t\tbuf[4] == 0x00\n}\nfunc LogHttpRequest(r *http.Request, v ...string) {\n\tserializedHeaders := bytes.Buffer{}\n\tr.Header.Write(&serializedHeaders)\n\n\tprintf := log.Printf\n\tif Logger != nil {\n\t\tprintf = Logger.Printf\n\t}\n\n\tprintf(\n\t\tLogRequestTemplate,\n\t\tstrings.Join(v, \" \"),\n\t\tr.URL.String(),\n\t\tr.Method,\n\t\ttime.Now(),\n\t\tserializedHeaders.String(),\n\t\t\"<hidden>\",\n\t\tdebug.Stack(),\n\t)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (l SortMapLayersByWeight) Swap(i, j int) { l[i], l[j] = l[j], l[i] }\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (l SortMapLayersByWeight) Swap(i, j int) { l[i], l[j] = l[j], l[i] }\nfunc readRequest(r *http.Request, obj interface{}) error {\n\tif r.Header.Get(\"Content-Type\") != \"application/json\" {\n\t\treturn errors.New(\"error: invalid content-type\")\n\t}\n\n\treturn json.NewDecoder(r.Body).Decode(&obj)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func Ttf(buf []byte) bool {\n\treturn len(buf) > 4 &&\n\t\tbuf[0] == 0x00 && buf[1] == 0x01 &&\n\t\tbuf[2] == 0x00 && buf[3] == 0x00 &&\n\t\tbuf[4] == 0x00\n}\nfunc readRequest(r *http.Request, obj interface{}) error {\n\tif r.Header.Get(\"Content-Type\") != \"application/json\" {\n\t\treturn errors.New(\"error: invalid content-type\")\n\t}\n\n\treturn json.NewDecoder(r.Body).Decode(&obj)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func root(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Hello, you've reached aesample, the root package does nothing\")\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\nfunc root(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Hello, you've reached aesample, the root package does nothing\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"providers\",\n\t\t\tType: \"json\",\n\t\t\tName: \"providers\",\n\t\t\tType: \"json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\nfunc debug(format string, args ...interface{}) {\n\tif false {\n\t\tfmt.Printf(format, args...)\n\t\tfmt.Println()\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviders: tfjson.ProvidersSchema{\n\t\t\tName: \"monitor\",\n\t\t\tType: \"monitor\",\n\t\t\tName: \"monitor\",\n\t\t},\n\t}, nil\n}"}
{"input": "func setVersionPalette(style string) {\n\tconsole.SetCustomPalette(map[string]*color.Color{\n\t\t\"Version\": color.New(color.FgGreen, color.Bold),\n\t})\n\tif style == \"light\" {\n\t\tconsole.SetCustomPalette(map[string]*color.Color{\n\t\t\t\"Version\": color.New(color.FgWhite, color.Bold),\n\t\t})\n\t\treturn\n\t}\n\tif style == \"nocolor\" {\n\t\tconsole.SetNoColor()\n\t}\n}\nfunc debug(format string, args ...interface{}) {\n\tif false {\n\t\tfmt.Printf(format, args...)\n\t\tfmt.Println()\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (l SortMapLayersByWeight) Swap(i, j int) { l[i], l[j] = l[j], l[i] }\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (l SortMapLayersByWeight) Swap(i, j int) { l[i], l[j] = l[j], l[i] }\nfunc (t Test) Collect() {\n\tmetric := metric.New(\"TestMetric\")\n\tmetric.Value = rand.Float64()\n\tmetric.AddDimension(\"testing\", \"yes\")\n\tt.Channel() <- metric\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func setVersionPalette(style string) {\n\tconsole.SetCustomPalette(map[string]*color.Color{\n\t\t\"Version\": color.New(color.FgGreen, color.Bold),\n\t})\n\tif style == \"light\" {\n\t\tconsole.SetCustomPalette(map[string]*color.Color{\n\t\t\t\"Version\": color.New(color.FgWhite, color.Bold),\n\t\t})\n\t\treturn\n\t}\n\tif style == \"nocolor\" {\n\t\tconsole.SetNoColor()\n\t}\n}\nfunc (t Test) Collect() {\n\tmetric := metric.New(\"TestMetric\")\n\tmetric.Value = rand.Float64()\n\tmetric.AddDimension(\"testing\", \"yes\")\n\tt.Channel() <- metric\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc BenchmarkWriterAwait(b *testing.B) {\n\twritten, read := NewCursor(), NewCursor()\n\twriter := NewWriter(written, read, 1024*64)\n\titerations := int64(b.N)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor i := int64(0); i < iterations; i++ {\n\t\twriter.Await(i)\n\t\tread.Store(i)\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (r *Resource) EnsureDeleted(ctx context.Context, obj interface{}) error {\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func ExampleNewRandom() {\n\tfor i := 0; i < 100; i++ {\n\t\tprintln(i, \":\", NewRandom())\n\t}\n\n\tprintln(\"======================================\")\n\n\tfor i := 0; i < 100; i++ {\n\t\tprintln(i, \":\", NewRangeRandom(1000000))\n\t}\n\n}\nfunc (r *Resource) EnsureDeleted(ctx context.Context, obj interface{}) error {\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\tret := tf.ctrl.Call(ctx, \"ProvidersSchema\", tf.Name, tf.Name)\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc GetUriFilteringTelemetryPreMitigationByTmid(engine *xorm.Engine, customerId int, cuid string, tmid int) ([]UriFilteringTelemetryPreMitigation, error) {\n\ttelePreMitigation := []UriFilteringTelemetryPreMitigation{}\n\terr := engine.Where(\"customer_id = ? AND cuid = ? AND tmid = ?\", customerId, cuid, tmid).Find(&telePreMitigation)\n\treturn telePreMitigation, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{}, tf.GetProviderSchemas(ctx)\n}"}
{"input": "func ExampleNewRandom() {\n\tfor i := 0; i < 100; i++ {\n\t\tprintln(i, \":\", NewRandom())\n\t}\n\n\tprintln(\"======================================\")\n\n\tfor i := 0; i < 100; i++ {\n\t\tprintln(i, \":\", NewRangeRandom(1000000))\n\t}\n\n}\nfunc GetUriFilteringTelemetryPreMitigationByTmid(engine *xorm.Engine, customerId int, cuid string, tmid int) ([]UriFilteringTelemetryPreMitigation, error) {\n\ttelePreMitigation := []UriFilteringTelemetryPreMitigation{}\n\terr := engine.Where(\"customer_id = ? AND cuid = ? AND tmid = ?\", customerId, cuid, tmid).Find(&telePreMitigation)\n\treturn telePreMitigation, err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas, err := tf.GetProvidersSchemas(ctx)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\treturn &tfjson.ProviderSchemas{\n\t\tProviders: providerSchemas,\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc GetHomeDir() string {\n\treturn homedir.Get()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *pollster) StopWaiting(fd int, bits uint) {\n}\nfunc GetHomeDir() string {\n\treturn homedir.Get()\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProvider: &tfjson.ProviderSchemas{\n\t\t\tName: \"providers\",\n\t\t\tType: \"json\",\n\t\t\tName: \"providers\",\n\t\t\tType: \"json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func outputFunc(in worker.Worker, out interface{}) error {\n\tinWorker, _ := in.(*apiConnWorker)\n\toutPointer, _ := out.(*base.APICaller)\n\tif inWorker == nil || outPointer == nil {\n\t\treturn errors.Errorf(\"expected %T->%T; got %T->%T\", inWorker, outPointer, in, out)\n\t}\n\t*outPointer = inWorker.conn\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvider: &tfjson.ProviderSchemas{\n\t\t\tName: \"providerschemas\",\n\t\t\tType: \"application/json\",\n\t\t\tName: \"providerschemas\",\n\t\t\tType: \"application/json\",\n\t\t},\n\t}, nil\n}"}
{"input": "func outputFunc(in worker.Worker, out interface{}) error {\n\tinWorker, _ := in.(*apiConnWorker)\n\toutPointer, _ := out.(*base.APICaller)\n\tif inWorker == nil || outPointer == nil {\n\t\treturn errors.Errorf(\"expected %T->%T; got %T->%T\", inWorker, outPointer, in, out)\n\t}\n\t*outPointer = inWorker.conn\n\treturn nil\n}\nfunc CBCEncrypt(content string, password string) (string, error) {\n\tkey := passwordHash(password)\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tpadded := pad(content)\n\tciphertext := make([]byte, aes.BlockSize+len(padded))\n\tiv := ciphertext[:aes.BlockSize]\n\t_, err = io.ReadFull(rand.Reader, iv)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tmode := cipher.NewCBCEncrypter(block, iv)\n\tmode.CryptBlocks(ciphertext[aes.BlockSize:], []byte(padded))\n\treturn base64.StdEncoding.EncodeToString(ciphertext), nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (p *pollster) StopWaiting(fd int, bits uint) {\n}\nfunc CBCEncrypt(content string, password string) (string, error) {\n\tkey := passwordHash(password)\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tpadded := pad(content)\n\tciphertext := make([]byte, aes.BlockSize+len(padded))\n\tiv := ciphertext[:aes.BlockSize]\n\t_, err = io.ReadFull(rand.Reader, iv)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tmode := cipher.NewCBCEncrypter(block, iv)\n\tmode.CryptBlocks(ciphertext[aes.BlockSize:], []byte(padded))\n\treturn base64.StdEncoding.EncodeToString(ciphertext), nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc outputFunc(in worker.Worker, out interface{}) error {\n\tinWorker, _ := in.(*apiConnWorker)\n\toutPointer, _ := out.(*base.APICaller)\n\tif inWorker == nil || outPointer == nil {\n\t\treturn errors.Errorf(\"expected %T->%T; got %T->%T\", inWorker, outPointer, in, out)\n\t}\n\t*outPointer = inWorker.conn\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvider: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func Rules(track *spotify.FullTrack, device string) bool {\n\tif track != nil && rule.Explicit && track.Explicit && !ignored(device) {\n\t\treturn true\n\t}\n\treturn false\n}\nfunc outputFunc(in worker.Worker, out interface{}) error {\n\tinWorker, _ := in.(*apiConnWorker)\n\toutPointer, _ := out.(*base.APICaller)\n\tif inWorker == nil || outPointer == nil {\n\t\treturn errors.Errorf(\"expected %T->%T; got %T->%T\", inWorker, outPointer, in, out)\n\t}\n\t*outPointer = inWorker.conn\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc Rules(track *spotify.FullTrack, device string) bool {\n\tif track != nil && rule.Explicit && track.Explicit && !ignored(device) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\tret := tf.ctrl.Call(ctx, \"ProvidersSchema\", tf.Name, tf.Name)\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc aggregator_transfer(messages <-chan Message) {\n\tt := NewTransaction(\"_CatMergeTree\", \"_CatMergeTree\", nil)\n\tfor message := range messages {\n\t\tt.AddChild(message)\n\t}\n\tt.SetStatus(\"0\")\n\tt.Complete()\n\tsender_transaction_channel <- t\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (p *pollster) StopWaiting(fd int, bits uint) {\n}\nfunc aggregator_transfer(messages <-chan Message) {\n\tt := NewTransaction(\"_CatMergeTree\", \"_CatMergeTree\", nil)\n\tfor message := range messages {\n\t\tt.AddChild(message)\n\t}\n\tt.SetStatus(\"0\")\n\tt.Complete()\n\tsender_transaction_channel <- t\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchema: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (m *OpenpitrixCeaseClustersResponse) UnmarshalBinary(b []byte) error {\n\tvar res OpenpitrixCeaseClustersResponse\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (m *OpenpitrixCeaseClustersResponse) UnmarshalBinary(b []byte) error {\n\tvar res OpenpitrixCeaseClustersResponse\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\nfunc NewHasherWriters(hashes []string, target io.Writer) (io.Writer, []*Hasher, error) {\n\thashers := []*Hasher{}\n\twriters := []io.Writer{}\n\n\tfor _, hash := range hashes {\n\t\thw, err := NewHasher(hash)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\thashers = append(hashers, hw)\n\t\twriters = append(writers, hw)\n\t}\n\n\tendWriter := io.MultiWriter(append(writers, target)...)\n\treturn endWriter, hashers, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func (p *pollster) StopWaiting(fd int, bits uint) {\n}\nfunc NewHasherWriters(hashes []string, target io.Writer) (io.Writer, []*Hasher, error) {\n\thashers := []*Hasher{}\n\twriters := []io.Writer{}\n\n\tfor _, hash := range hashes {\n\t\thw, err := NewHasher(hash)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\thashers = append(hashers, hw)\n\t\twriters = append(writers, hw)\n\t}\n\n\tendWriter := io.MultiWriter(append(writers, target)...)\n\treturn endWriter, hashers, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{}, nil\n}"}
{"input": "\nfunc (m *OpenpitrixCeaseClustersResponse) UnmarshalBinary(b []byte) error {\n\tvar res OpenpitrixCeaseClustersResponse\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (o *GetPetByIDOK) WriteResponse(rw http.ResponseWriter, producer httpkit.Producer) {\n\n\trw.WriteHeader(200)\n\tif o.Payload != nil {\n\t\tif err := producer.Produce(rw, o.Payload); err != nil {\n\t\t\tpanic(err) \n\t\t}\n\t}\n}\nfunc (m *OpenpitrixCeaseClustersResponse) UnmarshalBinary(b []byte) error {\n\tvar res OpenpitrixCeaseClustersResponse\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "func deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\nfunc (o *GetPetByIDOK) WriteResponse(rw http.ResponseWriter, producer httpkit.Producer) {\n\n\trw.WriteHeader(200)\n\tif o.Payload != nil {\n\t\tif err := producer.Produce(rw, o.Payload); err != nil {\n\t\t\tpanic(err) \n\t\t}\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.ProviderSchemas{\n\t\t\tName: \"monitor\",\n\t\t\tType: \"monitor\",\n\t\t\tName: \"monitor\",\n\t\t},\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (NullNetworkOverlay) InvalidateRoutes() {\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func XORBytes(a, b []byte) ([]byte, error) {\n\tif len(a) != len(b) {\n\t\treturn nil, fmt.Errorf(\"length of byte slices is not equivalent: %d != %d\", len(a), len(b))\n\t}\n\n\tbuf := make([]byte, len(a))\n\n\tfor i, _ := range a {\n\t\tbuf[i] = a[i] ^ b[i]\n\t}\n\n\treturn buf, nil\n}\nfunc (NullNetworkOverlay) InvalidateRoutes() {\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc testAccPreCheck(t *testing.T) {\n\tif v := os.Getenv(\"MAILGUN_API_KEY\"); v == \"\" {\n\t\tt.Fatal(\"MAILGUN_API_KEY must be set for acceptance tests\")\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (e ServiceOfferingNameAmbiguityError) Error() string {\n\tconst msg = \"Service '%s' is provided by multiple service brokers%s\"\n\tswitch len(e.ServiceBrokerNames) {\n\tcase 0:\n\t\treturn fmt.Sprintf(msg, e.ServiceOfferingName, \".\")\n\tdefault:\n\t\treturn fmt.Sprintf(msg, e.ServiceOfferingName, \": \"+strings.Join(e.ServiceBrokerNames, \", \"))\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (v *styleContext) GetScreen() (gdki.Screen, error) {\n\treturn gdka.WrapScreen(v.internal.GetScreen())\n}\nfunc (e ServiceOfferingNameAmbiguityError) Error() string {\n\tconst msg = \"Service '%s' is provided by multiple service brokers%s\"\n\tswitch len(e.ServiceBrokerNames) {\n\tcase 0:\n\t\treturn fmt.Sprintf(msg, e.ServiceOfferingName, \".\")\n\tdefault:\n\t\treturn fmt.Sprintf(msg, e.ServiceOfferingName, \": \"+strings.Join(e.ServiceBrokerNames, \", \"))\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.internal.ProvidersSchema)\n}"}
{"input": "func TestSchemaPrimitiveNullCodec(t *testing.T) {\n\ttestSchemaPrimativeCodec(t, `\"null\"`)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestSchemaPrimitiveNullCodec(t *testing.T) {\n\ttestSchemaPrimativeCodec(t, `\"null\"`)\n}\nfunc GetNodeByName(nodes []api.Node, nodeName string) *api.Node {\n\tfor _, node := range nodes {\n\t\tif node.ObjectMeta.Name == nodeName {\n\t\t\treturn &node\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (v *styleContext) GetScreen() (gdki.Screen, error) {\n\treturn gdka.WrapScreen(v.internal.GetScreen())\n}\nfunc GetNodeByName(nodes []api.Node, nodeName string) *api.Node {\n\tfor _, node := range nodes {\n\t\tif node.ObjectMeta.Name == nodeName {\n\t\t\treturn &node\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (m mutaterMock) Mutate(individual Individual, p float64) (Individual, error) {\n\treturn individual, nil\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc (m mutaterMock) Mutate(individual Individual, p float64) (Individual, error) {\n\treturn individual, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\treturn tf.ctrl.Call(ctx, \"ProvidersSchema\", tf.Name, tf.Name, tf.Type)\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttf.ctrl.T.Helper()\n\tret := tf.ctrl.Call(ctx, \"ProvidersSchema\", tf.Name, tf.Name)\n\tret0, _ := ret[0].(error)\n\treturn ret0, ret0\n}"}
{"input": "func (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\nfunc a(s string) F {\n\tlog += \"a(\" + s + \")\"\n\treturn F(a)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\ttfjson.ProviderSchemas = tfjson.ProvidersSchema{}\n\treturn tfjson.ProvidersSchemas{}, nil\n}"}
{"input": "func f(n int) {\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(n, \":\", i)\n\t}\n}\nfunc a(s string) F {\n\tlog += \"a(\" + s + \")\"\n\treturn F(a)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestSchemaPrimitiveNullCodec(t *testing.T) {\n\ttestSchemaPrimativeCodec(t, `\"null\"`)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func TestSchemaPrimitiveNullCodec(t *testing.T) {\n\ttestSchemaPrimativeCodec(t, `\"null\"`)\n}\nfunc (s *Server) HandleHistory(w http.ResponseWriter, r *http.Request) {\n\ttype HistoryData struct {\n\t\tClock      int32\n\t\tTotalHits  uint64\n\t\tDirections []interface{}\n\t}\n\n\tdata := HistoryData{\n\t\tClock:      s.counter.Clock.GetTime(),\n\t\tTotalHits:  s.counter.Count.Count(),\n\t\tDirections: make([]interface{}, 0, len(s.counter.Directions)),\n\t}\n\n\tfor _, direction := range s.counter.Directions {\n\t\tdirection.Store.CleanUp(data.Clock)\n\n\t\tdirData := map[string]interface{}{\n\t\t\t\"name\":           direction.Name,\n\t\t\t\"blocked-values\": direction.BlockedValues(),\n\t\t}\n\n\t\tdata.Directions = append(data.Directions, dirData)\n\t}\n\n\tjson, _ := json.Marshal(data)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write(json)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas := tfjson.ProviderSchemas{}\n\terr := tf.ProviderSchemas.Validate(ctx)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn providerSchemas, nil\n}"}
{"input": "func f(n int) {\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(n, \":\", i)\n\t}\n}\nfunc (s *Server) HandleHistory(w http.ResponseWriter, r *http.Request) {\n\ttype HistoryData struct {\n\t\tClock      int32\n\t\tTotalHits  uint64\n\t\tDirections []interface{}\n\t}\n\n\tdata := HistoryData{\n\t\tClock:      s.counter.Clock.GetTime(),\n\t\tTotalHits:  s.counter.Count.Count(),\n\t\tDirections: make([]interface{}, 0, len(s.counter.Directions)),\n\t}\n\n\tfor _, direction := range s.counter.Directions {\n\t\tdirection.Store.CleanUp(data.Clock)\n\n\t\tdirData := map[string]interface{}{\n\t\t\t\"name\":           direction.Name,\n\t\t\t\"blocked-values\": direction.BlockedValues(),\n\t\t}\n\n\t\tdata.Directions = append(data.Directions, dirData)\n\t}\n\n\tjson, _ := json.Marshal(data)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write(json)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchemas{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
{"input": "\nfunc Register(name string, sms ShortMessagingService) {\n\tif sms == nil {\n\t\tpanic(\"[SMS]: Register channel is nil\")\n\t}\n\tif _, ok := channels[name]; ok {\n\t\tpanic(\"[SMS]: Register called teice for channel \" + name)\n\t}\n\tchannels[name] = sms\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func createServiceAccountDef(spec app.Spec) *v1.ServiceAccount {\n\treturn &v1.ServiceAccount{\n\t\tTypeMeta: k8smeta.TypeMeta{\n\t\t\tKind:       \"ServiceAccount\",\n\t\t\tAPIVersion: \"v1\",\n\t\t},\n\t\tObjectMeta: generateObjectMeta(spec),\n\t}\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tproviderSchemas := tfjson.ProviderSchemas{\n\t\tTypeMeta: k8smeta.TypeMeta{\n\t\t\tKind:       \"Provider\",\n\t\t\tAPIVersion: \"v1\",\n\t\t},\n\t\tObjectMeta: generateObjectMeta(spec),\n\t}\n\treturn providerSchemas, nil\n}"}
{"input": "func (e errBadDependency) Error() string {\n\treturn fmt.Sprintf(\"unresolved dependency: class=%s name=%s\", types.Dependency(e).Class, types.Dependency(e).Name)\n}\nfunc createServiceAccountDef(spec app.Spec) *v1.ServiceAccount {\n\treturn &v1.ServiceAccount{\n\t\tTypeMeta: k8smeta.TypeMeta{\n\t\t\tKind:       \"ServiceAccount\",\n\t\t\tAPIVersion: \"v1\",\n\t\t},\n\t\tObjectMeta: generateObjectMeta(spec),\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tTypeMeta: k8smeta.TypeMeta{\n\t\t\tKind:       \"Provider\",\n\t\t\tAPIVersion: \"v1\",\n\t\t},\n\t\tObjectMeta: generateObjectMeta(tf),\n\t}\n}"}
{"input": "\nfunc (e errBadDependency) Error() string {\n\treturn fmt.Sprintf(\"unresolved dependency: class=%s name=%s\", types.Dependency(e).Class, types.Dependency(e).Name)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (fn ActionsDeleteHandlerFunc) Handle(params ActionsDeleteParams, principal *models.Principal) middleware.Responder {\n\treturn fn(params, principal)\n}\nfunc (e errBadDependency) Error() string {\n\treturn fmt.Sprintf(\"unresolved dependency: class=%s name=%s\", types.Dependency(e).Class, types.Dependency(e).Name)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (fn ActionsDeleteHandlerFunc) Handle(params ActionsDeleteParams, principal *models.Principal) middleware.Responder {\n\treturn fn(params, principal)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.GetProvidersSchema(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (a *AccountManagementConfirmation3) SetConfirmationType(value string) {\n\ta.ConfirmationType = (*AccountManagementType2Code)(&value)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (a *AccountManagementConfirmation3) SetConfirmationType(value string) {\n\ta.ConfirmationType = (*AccountManagementType2Code)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.GetProvidersSchema(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\nfunc (r *LimitRset) Plan(ctx context.Context) (plan.Plan, error) {\n\treturn &plans.LimitDefaultPlan{Count: r.Count, Src: r.Src, Fields: r.Src.GetFields()}, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvidersSchema: tf.ProvidersSchema,\n\t}, nil\n}"}
{"input": "func (field *FieldDescriptorProto) IsScalar() bool {\n\tif field.Type == nil {\n\t\treturn false\n\t}\n\tswitch *field.Type {\n\tcase FieldDescriptorProto_TYPE_DOUBLE,\n\t\tFieldDescriptorProto_TYPE_FLOAT,\n\t\tFieldDescriptorProto_TYPE_INT64,\n\t\tFieldDescriptorProto_TYPE_UINT64,\n\t\tFieldDescriptorProto_TYPE_INT32,\n\t\tFieldDescriptorProto_TYPE_FIXED64,\n\t\tFieldDescriptorProto_TYPE_FIXED32,\n\t\tFieldDescriptorProto_TYPE_BOOL,\n\t\tFieldDescriptorProto_TYPE_UINT32,\n\t\tFieldDescriptorProto_TYPE_ENUM,\n\t\tFieldDescriptorProto_TYPE_SFIXED32,\n\t\tFieldDescriptorProto_TYPE_SFIXED64,\n\t\tFieldDescriptorProto_TYPE_SINT32,\n\t\tFieldDescriptorProto_TYPE_SINT64:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\nfunc (r *LimitRset) Plan(ctx context.Context) (plan.Plan, error) {\n\treturn &plans.LimitDefaultPlan{Count: r.Count, Src: r.Src, Fields: r.Src.GetFields()}, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tProvidersSchema: tfjson.ProvidersSchema{\n\t\t\tType:     tf.Type,\n\t\t\tType:     tf.Type,\n\t\t\tType:     tf.Type,\n\t\t\tType:     tf.Type,\n\t\t}, nil\n\t}\n}"}
{"input": "func numTrees(n int) int {\n\tdp := make([]int, n + 1)\n\n\tdp[0] = 1\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tdp[i] += dp[j] * dp[i - 1 - j]\n\t\t}\n\t}\n\n\treturn dp[n]\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func numTrees(n int) int {\n\tdp := make([]int, n + 1)\n\n\tdp[0] = 1\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tdp[i] += dp[j] * dp[i - 1 - j]\n\t\t}\n\t}\n\n\treturn dp[n]\n}\nfunc (observers *Observable) Attach(observer Observer) {\n\t*observers = append(*observers, observer)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (field *FieldDescriptorProto) IsScalar() bool {\n\tif field.Type == nil {\n\t\treturn false\n\t}\n\tswitch *field.Type {\n\tcase FieldDescriptorProto_TYPE_DOUBLE,\n\t\tFieldDescriptorProto_TYPE_FLOAT,\n\t\tFieldDescriptorProto_TYPE_INT64,\n\t\tFieldDescriptorProto_TYPE_UINT64,\n\t\tFieldDescriptorProto_TYPE_INT32,\n\t\tFieldDescriptorProto_TYPE_FIXED64,\n\t\tFieldDescriptorProto_TYPE_FIXED32,\n\t\tFieldDescriptorProto_TYPE_BOOL,\n\t\tFieldDescriptorProto_TYPE_UINT32,\n\t\tFieldDescriptorProto_TYPE_ENUM,\n\t\tFieldDescriptorProto_TYPE_SFIXED32,\n\t\tFieldDescriptorProto_TYPE_SFIXED64,\n\t\tFieldDescriptorProto_TYPE_SINT32,\n\t\tFieldDescriptorProto_TYPE_SINT64:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\nfunc (observers *Observable) Attach(observer Observer) {\n\t*observers = append(*observers, observer)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (iotDaemonSetList *IotDaemonSetList) GetListMeta() metav1.List {\n\treturn &iotDaemonSetList.Metadata\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func (response DeleteStreamPoolResponse) String() string {\n\treturn common.PointerString(response)\n}\nfunc (iotDaemonSetList *IotDaemonSetList) GetListMeta() metav1.List {\n\treturn &iotDaemonSetList.Metadata\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"IotDaemonSetList\",\n\t\tResource: \"iot-daemon-set\",\n\t\tResource: \"iot-daemon-set\",\n\t\tResource: \"iot-daemon-set\",\n\t}, nil\n}"}
{"input": "\nfunc (f *singleFactory) New() interface{} {\n\treturn f.v\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.v.ProvidersSchemas(ctx)\n}"}
{"input": "func main() {\n\tdata := []byte(\"Hello World!\")\n\tfmt.Println(\"hashSha1:\", hashSha1(data))\n\tfmt.Println(\"hashSha256:\", hashSha256(data))\n\tfmt.Println(\"hashSha512:\", hashSha512(data))\n\tfmt.Println(\"hashMd5:\", hashMd5(data))\n}\nfunc (f *singleFactory) New() interface{} {\n\treturn f.v\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (response DeleteStreamPoolResponse) String() string {\n\treturn common.PointerString(response)\n}\nfunc main() {\n\tdata := []byte(\"Hello World!\")\n\tfmt.Println(\"hashSha1:\", hashSha1(data))\n\tfmt.Println(\"hashSha256:\", hashSha256(data))\n\tfmt.Println(\"hashSha512:\", hashSha512(data))\n\tfmt.Println(\"hashMd5:\", hashMd5(data))\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchemas(ctx)\n}"}
{"input": "func numTrees(n int) int {\n\tdp := make([]int, n + 1)\n\n\tdp[0] = 1\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tdp[i] += dp[j] * dp[i - 1 - j]\n\t\t}\n\t}\n\n\treturn dp[n]\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func numTrees(n int) int {\n\tdp := make([]int, n + 1)\n\n\tdp[0] = 1\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tdp[i] += dp[j] * dp[i - 1 - j]\n\t\t}\n\t}\n\n\treturn dp[n]\n}\nfunc (m IpHashLoadBalancingMethod) String() string {\n\treturn common.PointerString(m)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (f *singleFactory) New() interface{} {\n\treturn f.v\n}\nfunc (m IpHashLoadBalancingMethod) String() string {\n\treturn common.PointerString(m)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc cgoLookupHost(name string) (addrs []string, err error, completed bool) {\n\treturn nil, nil, false\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc (a *ATMContext4) SetSessionReference(value string) {\n\ta.SessionReference = (*Max35Text)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProvidersSchema(ctx)\n}"}
{"input": "func (s *Service) RankCard(plat int8) (ranks []*rank.Rank, aids []int64) {\n\tvar limit int\n\tif !model.IsIPad(plat) {\n\t\tlimit = 3\n\t} else {\n\t\tlimit = 4\n\t}\n\tranks = make([]*rank.Rank, 0, limit)\n\taids = make([]int64, 0, limit)\n\tfor _, rank := range s.rankCache {\n\t\tranks = append(ranks, rank)\n\t\taids = append(aids, rank.Aid)\n\t\tif len(ranks) == limit {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\nfunc (a *ATMContext4) SetSessionReference(value string) {\n\ta.SessionReference = (*Max35Text)(&value)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc (s *Service) RankCard(plat int8) (ranks []*rank.Rank, aids []int64) {\n\tvar limit int\n\tif !model.IsIPad(plat) {\n\t\tlimit = 3\n\t} else {\n\t\tlimit = 4\n\t}\n\tranks = make([]*rank.Rank, 0, limit)\n\taids = make([]int64, 0, limit)\n\tfor _, rank := range s.rankCache {\n\t\tranks = append(ranks, rank)\n\t\taids = append(aids, rank.Aid)\n\t\tif len(ranks) == limit {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (qs Questions) GetRandomQuestion() (Question, error) {\n\tsize := len(qs)\n\tif size <= 0 {\n\t\treturn Question{}, errors.New(\"No questions found.\")\n\t}\n\tindex := rand.Intn(size)\n\treturn qs[index], nil\n\n}\nfunc (s *Service) RankCard(plat int8) (ranks []*rank.Rank, aids []int64) {\n\tvar limit int\n\tif !model.IsIPad(plat) {\n\t\tlimit = 3\n\t} else {\n\t\tlimit = 4\n\t}\n\tranks = make([]*rank.Rank, 0, limit)\n\taids = make([]int64, 0, limit)\n\tfor _, rank := range s.rankCache {\n\t\tranks = append(ranks, rank)\n\t\taids = append(aids, rank.Aid)\n\t\tif len(ranks) == limit {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (data ServerNews) GetBlocks() []*block.Block {\n\tvar blocks []*block.Block\n\tblocks = append(blocks, block.GetBlocks(0x2009, block.Uint32{0})...)\n\tblocks = append(blocks, block.GetBlocks(0x200a, data.News)...)\n\tblocks = append(blocks, block.GetBlocks(0x200b, block.Uint32{0})...)\n\treturn blocks\n}\nfunc (qs Questions) GetRandomQuestion() (Question, error) {\n\tsize := len(qs)\n\tif size <= 0 {\n\t\treturn Question{}, errors.New(\"No questions found.\")\n\t}\n\tindex := rand.Intn(size)\n\treturn qs[index], nil\n\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "\nfunc (d *DeadlineCode4Choice) AddProprietary() *GenericIdentification47 {\n\td.Proprietary = new(GenericIdentification47)\n\treturn d.Proprietary\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "func (client *Client) SkipHealthchecks(requestId string, body *dtos.SingularitySkipHealthchecksRequest) (response *dtos.SingularityRequestParent, err error) {\n\tpathParamMap := map[string]interface{}{\n\t\t\"requestId\": requestId,\n\t}\n\n\tqueryParamMap := map[string]interface{}{}\n\n\tresponse = new(dtos.SingularityRequestParent)\n\terr = client.DTORequest(response, \"PUT\", \"/api/requests/request/{requestId}/skip-healthchecks\", pathParamMap, queryParamMap, body)\n\n\treturn\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tpathParamMap := map[string]interface{}{\n\t\t\"providerSchemas\": tf.ProviderSchemas,\n\t}\n\n\tqueryParamMap := map[string]interface{}{\n\t\t\"providerSchemas\": tf.ProviderSchemas,\n\t}\n\n\tresponse := new(tfjson.ProviderSchemas)\n\terr = client.DTORequest(response, \"GET\", \"/api/requests/request/{requestId}/providersSchemas\", pathParamMap, queryParamMap, body)\n\n\treturn\n}"}
{"input": "func (s *sField) resolveTag() {\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\n\tif s.attr {\n\t\ts.Tag = \"`\" + `xml:\"` + s.Name + `,attr\"` + \"`\"\n\t\treturn\n\t}\n\n\ts.Tag = \"`\" + `xml:\"` + s.Name + `\"` + \"`\"\n}\nfunc (client *Client) SkipHealthchecks(requestId string, body *dtos.SingularitySkipHealthchecksRequest) (response *dtos.SingularityRequestParent, err error) {\n\tpathParamMap := map[string]interface{}{\n\t\t\"requestId\": requestId,\n\t}\n\n\tqueryParamMap := map[string]interface{}{}\n\n\tresponse = new(dtos.SingularityRequestParent)\n\terr = client.DTORequest(response, \"PUT\", \"/api/requests/request/{requestId}/skip-healthchecks\", pathParamMap, queryParamMap, body)\n\n\treturn\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc (s *sField) resolveTag() {\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\n\tif s.attr {\n\t\ts.Tag = \"`\" + `xml:\"` + s.Name + `,attr\"` + \"`\"\n\t\treturn\n\t}\n\n\ts.Tag = \"`\" + `xml:\"` + s.Name + `\"` + \"`\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func encodeUnicode(content string, ecl ErrorCorrectionLevel) (*utils.BitList, *versionInfo, error) {\n\tdata := []byte(content)\n\n\tvi := findSmallestVersionInfo(ecl, byteMode, len(data)*8)\n\tif vi == nil {\n\t\treturn nil, nil, errors.New(\"To much data to encode\")\n\t}\n\n\tres := new(utils.BitList)\n\tres.AddBits(int(byteMode), 4)\n\tres.AddBits(len(content), vi.charCountBits(byteMode))\n\tfor _, b := range data {\n\t\tres.AddByte(b)\n\t}\n\taddPaddingAndTerminator(res, vi)\n\treturn res, vi, nil\n}\nfunc (s *sField) resolveTag() {\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\n\tif s.attr {\n\t\ts.Tag = \"`\" + `xml:\"` + s.Name + `,attr\"` + \"`\"\n\t\treturn\n\t}\n\n\ts.Tag = \"`\" + `xml:\"` + s.Name + `\"` + \"`\"\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"json\",\n\t\tType: \"string\",\n\t\tType: \"string\",\n\t\tType: \"string\",\n\t\tType: \"string\",\n\t\tFormat: \"utf-8\",\n\t\tFormat: \"utf-8\",\n\t\tFormat: \"utf-8\",\n\t\tFormat: \"utf-8\",\n\t\tFormat: \"utf-8\",\n\t\tFormat: \"utf-8\",\n\t\tFormat: \"utf-8\",\n\t}, nil\n}"}
{"input": "func NewService() *SomeService {\n\treturn &SomeService{}\n}\nfunc encodeUnicode(content string, ecl ErrorCorrectionLevel) (*utils.BitList, *versionInfo, error) {\n\tdata := []byte(content)\n\n\tvi := findSmallestVersionInfo(ecl, byteMode, len(data)*8)\n\tif vi == nil {\n\t\treturn nil, nil, errors.New(\"To much data to encode\")\n\t}\n\n\tres := new(utils.BitList)\n\tres.AddBits(int(byteMode), 4)\n\tres.AddBits(len(content), vi.charCountBits(byteMode))\n\tfor _, b := range data {\n\t\tres.AddByte(b)\n\t}\n\taddPaddingAndTerminator(res, vi)\n\treturn res, vi, nil\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"json\",\n\t\tType: \"string\",\n\t\tEncoding: \"utf8\",\n\t\tEncoding: \"utf8\",\n\t\tEncoding: \"utf8\",\n\t\tEncoding: \"utf8\",\n\t\tEncoding: \"utf8\",\n\t\tEncoding: \"utf8\",\n\t\tEncoding: \"utf8\",\n\t\tEncoding: \"utf8\",\n\t}, nil\n}"}
{"input": "\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.client.ProvidersSchema(ctx)\n}"}
{"input": "\nfunc Answer() interface{} {\n\n\n\th := 143 + 1 \n\tp := 165\n\n\tfor {\n\t\thexa := h * (2*h - 1)\n\t\tpent := p * (3*p - 1) / 2\n\t\tif hexa < pent {\n\t\t\th++\n\t\t} else if pent < hexa {\n\t\t\tp++\n\t\t} else {\n\t\t\treturn pent\n\t\t}\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func NewService() *SomeService {\n\treturn &SomeService{}\n}\nfunc Answer() interface{} {\n\n\n\th := 143 + 1 \n\tp := 165\n\n\tfor {\n\t\thexa := h * (2*h - 1)\n\t\tpent := p * (3*p - 1) / 2\n\t\tif hexa < pent {\n\t\t\th++\n\t\t} else if pent < hexa {\n\t\t\tp++\n\t\t} else {\n\t\t\treturn pent\n\t\t}\n\t}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "\nfunc NewService() *SomeService {\n\treturn &SomeService{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.ProviderSchemas(ctx)\n}"}
{"input": "func (c *FakeUsers) Create(inObj *userapi.User) (*userapi.User, error) {\n\tobj, err := c.Fake.Invokes(ktestclient.NewRootCreateAction(\"users\", inObj), inObj)\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*userapi.User), err\n}\nfunc NewService() *SomeService {\n\treturn &SomeService{}\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.Config.ProvidersSchema)\n}"}
{"input": "func TestFileTreeIntegrate(t *testing.T) {\n\texpect := assert.New(t)\n\tfileTree := sftpd.NewFileTree(\"data/fixtures\")\n\texpect.NotNil(fileTree)\n\n}\nfunc (c *FakeUsers) Create(inObj *userapi.User) (*userapi.User, error) {\n\tobj, err := c.Fake.Invokes(ktestclient.NewRootCreateAction(\"users\", inObj), inObj)\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*userapi.User), err\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema(ctx, tf.Config.ProvidersSchema)\n}"}
{"input": "func (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tf.providerSchemas(ctx)\n}"}
{"input": "func (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\nfunc RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProviderSchemas{\n\t\tType: \"IP_HASH\",\n\t\tType: \"IP_HASH\",\n\t\tType: \"IP_HASH\",\n\t\tSchema: tfjson.NewProviderSchemas(),\n\t}, nil\n}"}
{"input": "func TestFileTreeIntegrate(t *testing.T) {\n\texpect := assert.New(t)\n\tfileTree := sftpd.NewFileTree(\"data/fixtures\")\n\texpect.NotNil(fileTree)\n\n}\nfunc RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) {\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\treturn tfjson.ProvidersSchema{\n\t\tProviderSchemas: tfjson.NewProviderSchemas(ctx),\n\t}, nil\n}"}
