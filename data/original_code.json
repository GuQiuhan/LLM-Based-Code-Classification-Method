{"input": "package filesystem\n\nimport (\n\tkeystore2 \"github.com/cossacklabs/acra/keystore\"\n)\n\nfunc getSymmetricKeyName(id string) string {\n\treturn id + `_sym`\n}\n\n\n\nfunc getClientIDSymmetricKeyName(id []byte) string {\n\treturn getSymmetricKeyName(GetServerDecryptionKeyFilename(id))\n}\n\nfunc getZoneIDSymmetricKeyName(id []byte) string {\n\treturn getSymmetricKeyName(GetZoneKeyFilename(id))\n}\n\nfunc getTokenSymmetricKeyName(id []byte, ownerType keystore2.KeyOwnerType) string ", "output": "{\n\tvar name string\n\tswitch ownerType {\n\tcase keystore2.KeyOwnerTypeClient:\n\t\tname = getClientIDSymmetricKeyName(id)\n\tcase keystore2.KeyOwnerTypeZone:\n\t\tname = getZoneIDSymmetricKeyName(id)\n\tdefault:\n\t\tname = string(id)\n\t}\n\treturn name + \".token\"\n}"}
{"input": "package gobot_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gobot.io/x/gobot\"\n\t\"gobot.io/x/gobot/gobottest\"\n)\n\nfunc ExampleEvery() {\n\tgobot.Every(1*time.Second, func() {\n\t\tfmt.Println(\"Hello\")\n\t})\n}\n\nfunc ExampleAfter() {\n\tgobot.After(1*time.Second, func() {\n\t\tfmt.Println(\"Hello\")\n\t})\n}\n\nfunc ExampleRand() {\n\ti := gobot.Rand(100)\n\tfmt.Printf(\"%v is > 0 && < 100\", i)\n}\n\nfunc ExampleFromScale() {\n\tfmt.Println(gobot.FromScale(5, 0, 10))\n}\n\n\n\nfunc ExampleAssert() {\n\tt := &testing.T{}\n\tvar a int = 100\n\tvar b int = 100\n\tgobottest.Assert(t, a, b)\n}\n\nfunc ExampleRefute() {\n\tt := &testing.T{}\n\tvar a int = 100\n\tvar b int = 200\n\tgobottest.Refute(t, a, b)\n}\n\nfunc ExampleToScale() ", "output": "{\n\tfmt.Println(gobot.ToScale(500, 0, 10))\n}"}
{"input": "package domain\n\n\nfunc MathPaymentMethodFlag(methods []int) int {\n\tf := 0\n\tfor _, v := range methods {\n\t\tf |= 1 << uint(v-1)\n\t}\n\treturn f\n}\n\n\n\n\nfunc AndPayMethod(payFlag int, method int) bool ", "output": "{\n\tf := 1 << uint(method-1)\n\treturn payFlag&f == f\n}"}
{"input": "package main\n\nvar accessControlInterfaces = map[string]func() AccessControlInterface{}\n\ntype AccessControlInterface interface {\n\tInit(*configuration, AuthenticationInterface, EchoMiddlewareUser) error\n\tCan(EchoStasher) error\n}\n\n\n\nfunc GetAccessControlInterface(name string) (accessControlInterface AccessControlInterface) {\n\tif accessControlInterfacef, ok := accessControlInterfaces[name]; ok {\n\t\taccessControlInterface = accessControlInterfacef()\n\t}\n\treturn\n}\n\nfunc RegisterAccessControlInterface(name string, f func() AccessControlInterface) ", "output": "{\n\taccessControlInterfaces[name] = f\n}"}
{"input": "package cm\n\nimport (\n\t\"fmt\"\n\n\t\"k8s.io/kubernetes/pkg/kubelet/dockershim/libdocker\"\n)\n\ntype unsupportedContainerManager struct {\n}\n\n\nfunc NewContainerManager(_ string, _ libdocker.Interface) ContainerManager {\n\treturn &unsupportedContainerManager{}\n}\n\n\n\nfunc (m *unsupportedContainerManager) Start() error ", "output": "{\n\treturn fmt.Errorf(\"Container Manager is unsupported in this build\")\n}"}
{"input": "package library\n\nimport (\n\t\"github.com/hyperledger/fabric/core/handlers/auth\"\n\t\"github.com/hyperledger/fabric/core/handlers/auth/filter\"\n\t\"github.com/hyperledger/fabric/core/handlers/decoration\"\n\t\"github.com/hyperledger/fabric/core/handlers/decoration/decorator\"\n\tendorsement \"github.com/hyperledger/fabric/core/handlers/endorsement/api\"\n\t\"github.com/hyperledger/fabric/core/handlers/endorsement/builtin\"\n\tvalidation \"github.com/hyperledger/fabric/core/handlers/validation/api\"\n\t. \"github.com/hyperledger/fabric/core/handlers/validation/builtin\"\n)\n\n\n\ntype HandlerLibrary struct {\n}\n\n\n\n\n\n\nfunc (r *HandlerLibrary) DefaultAuth() auth.Filter {\n\treturn filter.NewFilter()\n}\n\n\n\nfunc (r *HandlerLibrary) ExpirationCheck() auth.Filter {\n\treturn filter.NewExpirationCheckFilter()\n}\n\n\n\n\nfunc (r *HandlerLibrary) DefaultDecorator() decoration.Decorator {\n\treturn decorator.NewDecorator()\n}\n\nfunc (r *HandlerLibrary) DefaultEndorsement() endorsement.PluginFactory {\n\treturn &builtin.DefaultEndorsementFactory{}\n}\n\n\n\nfunc (r *HandlerLibrary) DefaultValidation() validation.PluginFactory ", "output": "{\n\treturn &DefaultValidationFactory{}\n}"}
{"input": "package versioned\n\nimport (\n\t\"fmt\"\n\n\tdiscovery \"k8s.io/client-go/discovery\"\n\trest \"k8s.io/client-go/rest\"\n\tflowcontrol \"k8s.io/client-go/util/flowcontrol\"\n\tsourcesv1alpha1 \"knative.dev/eventing-camel/pkg/client/clientset/versioned/typed/sources/v1alpha1\"\n)\n\ntype Interface interface {\n\tDiscovery() discovery.DiscoveryInterface\n\tSourcesV1alpha1() sourcesv1alpha1.SourcesV1alpha1Interface\n}\n\n\n\ntype Clientset struct {\n\t*discovery.DiscoveryClient\n\tsourcesV1alpha1 *sourcesv1alpha1.SourcesV1alpha1Client\n}\n\n\nfunc (c *Clientset) SourcesV1alpha1() sourcesv1alpha1.SourcesV1alpha1Interface {\n\treturn c.sourcesV1alpha1\n}\n\n\nfunc (c *Clientset) Discovery() discovery.DiscoveryInterface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.DiscoveryClient\n}\n\n\n\n\n\n\n\n\nfunc NewForConfigOrDie(c *rest.Config) *Clientset {\n\tvar cs Clientset\n\tcs.sourcesV1alpha1 = sourcesv1alpha1.NewForConfigOrDie(c)\n\n\tcs.DiscoveryClient = discovery.NewDiscoveryClientForConfigOrDie(c)\n\treturn &cs\n}\n\n\nfunc New(c rest.Interface) *Clientset {\n\tvar cs Clientset\n\tcs.sourcesV1alpha1 = sourcesv1alpha1.New(c)\n\n\tcs.DiscoveryClient = discovery.NewDiscoveryClient(c)\n\treturn &cs\n}\n\nfunc NewForConfig(c *rest.Config) (*Clientset, error) ", "output": "{\n\tconfigShallowCopy := *c\n\tif configShallowCopy.RateLimiter == nil && configShallowCopy.QPS > 0 {\n\t\tif configShallowCopy.Burst <= 0 {\n\t\t\treturn nil, fmt.Errorf(\"burst is required to be greater than 0 when RateLimiter is not set and QPS is set to greater than 0\")\n\t\t}\n\t\tconfigShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)\n\t}\n\tvar cs Clientset\n\tvar err error\n\tcs.sourcesV1alpha1, err = sourcesv1alpha1.NewForConfig(&configShallowCopy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcs.DiscoveryClient, err = discovery.NewDiscoveryClientForConfig(&configShallowCopy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &cs, nil\n}"}
{"input": "package identity\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n\t\"net/http\"\n)\n\n\ntype GetUserGroupMembershipRequest struct {\n\n\tUserGroupMembershipId *string `mandatory:\"true\" contributesTo:\"path\" name:\"userGroupMembershipId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetUserGroupMembershipRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request GetUserGroupMembershipRequest) HTTPRequest(method, path string) (http.Request, error) {\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request GetUserGroupMembershipRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetUserGroupMembershipResponse struct {\n\n\tRawResponse *http.Response\n\n\tUserGroupMembership `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n}\n\n\n\n\nfunc (response GetUserGroupMembershipResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response GetUserGroupMembershipResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package authy\n\nimport (\n\t\"github.com/tg123/sshpiper/sshpiperd/challenger\"\n)\n\nfunc (authyClient) GetName() string {\n\treturn \"authy\"\n}\n\nfunc (a *authyClient) GetOpts() interface{} {\n\treturn &a.Config\n}\n\n\n\nfunc init() {\n\tchallenger.Register(\"authy\", &authyClient{})\n}\n\nfunc (a *authyClient) GetHandler() challenger.Handler ", "output": "{\n\treturn a.challenge\n}"}
{"input": "package api\n\n\ntype UserInfo interface {\n\tGetName() string\n\tGetUID() string\n\tGetScope() string\n\tGetExtra() map[string]string\n}\n\n\n\ntype UserIdentityInfo interface {\n\tGetUserName() string\n\tGetProviderName() string\n\tGetExtra() map[string]string\n}\n\n\ntype UserIdentityMapper interface {\n\tUserFor(identityInfo UserIdentityInfo) (UserInfo, error)\n}\n\ntype Client interface {\n\tGetId() string\n\tGetSecret() string\n\tGetRedirectUri() string\n\tGetUserData() interface{}\n}\n\ntype Grant struct {\n\tClient      Client\n\tScope       string\n\tExpiration  int64\n\tRedirectURI string\n}\n\ntype DefaultUserInfo struct {\n\tName  string\n\tUID   string\n\tScope string\n\tExtra map[string]string\n}\n\nfunc (i *DefaultUserInfo) GetName() string {\n\treturn i.Name\n}\n\nfunc (i *DefaultUserInfo) GetUID() string {\n\treturn i.UID\n}\n\nfunc (i *DefaultUserInfo) GetScope() string {\n\treturn i.Scope\n}\n\n\n\ntype DefaultUserIdentityInfo struct {\n\tUserName     string\n\tProviderName string\n\tExtra        map[string]string\n}\n\n\nfunc NewDefaultUserIdentityInfo(username string) DefaultUserIdentityInfo {\n\treturn DefaultUserIdentityInfo{\n\t\tUserName: username,\n\t\tExtra:    make(map[string]string),\n\t}\n}\n\nfunc (i *DefaultUserIdentityInfo) GetUserName() string {\n\treturn i.UserName\n}\n\nfunc (i *DefaultUserIdentityInfo) GetProviderName() string {\n\treturn i.ProviderName\n}\n\nfunc (i *DefaultUserIdentityInfo) GetExtra() map[string]string {\n\treturn i.Extra\n}\n\nfunc (i *DefaultUserInfo) GetExtra() map[string]string ", "output": "{\n\treturn i.Extra\n}"}
{"input": "package tracers\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/vm\"\n)\n\n\n\ntype Context struct {\n\tBlockHash common.Hash \n\tTxIndex   int         \n\tTxHash    common.Hash \n}\n\n\n\ntype Tracer interface {\n\tvm.EVMLogger\n\tGetResult() (json.RawMessage, error)\n\tStop(err error)\n}\n\ntype lookupFunc func(string, *Context) (Tracer, error)\n\nvar (\n\tlookups []lookupFunc\n)\n\n\n\n\n\nfunc RegisterLookup(wildcard bool, lookup lookupFunc) {\n\tif wildcard {\n\t\tlookups = append(lookups, lookup)\n\t} else {\n\t\tlookups = append([]lookupFunc{lookup}, lookups...)\n\t}\n}\n\n\n\n\n\nfunc New(code string, ctx *Context) (Tracer, error) ", "output": "{\n\tfor _, lookup := range lookups {\n\t\tif tracer, err := lookup(code, ctx); err == nil {\n\t\t\treturn tracer, nil\n\t\t}\n\t}\n\treturn nil, errors.New(\"tracer not found\")\n}"}
{"input": "package summary\n\nimport (\n\tinfo \"github.com/Clever/cadvisor/info/v2\"\n)\n\n\n\n\n\ntype SamplesBuffer struct {\n\tsamples []info.Usage\n\tmaxSize int\n\tindex int\n}\n\n\nfunc NewSamplesBuffer(size int) *SamplesBuffer {\n\treturn &SamplesBuffer{\n\t\tindex:   -1,\n\t\tmaxSize: size,\n\t}\n}\n\n\nfunc (s *SamplesBuffer) Size() int {\n\treturn len(s.samples)\n}\n\n\nfunc (s *SamplesBuffer) Add(stat info.Usage) {\n\tif len(s.samples) < s.maxSize {\n\t\ts.samples = append(s.samples, stat)\n\t\ts.index++\n\t\treturn\n\t}\n\ts.index = (s.index + 1) % s.maxSize\n\ts.samples[s.index] = stat\n}\n\n\n\n\nfunc (s *SamplesBuffer) RecentStats(n int) []*info.Usage ", "output": "{\n\tif n > len(s.samples) {\n\t\tn = len(s.samples)\n\t}\n\tstart := s.index - (n - 1)\n\tif start < 0 {\n\t\tstart += len(s.samples)\n\t}\n\n\tout := make([]*info.Usage, n)\n\tfor i := 0; i < n; i++ {\n\t\tindex := (start + i) % len(s.samples)\n\t\tout[i] = &s.samples[index]\n\t}\n\treturn out\n}"}
{"input": "package atc\n\nimport (\n\t\"fmt\"\n)\n\ntype MalformedConfigError struct {\n\tUnmarshalError error\n}\n\nfunc (err MalformedConfigError) Error() string {\n\treturn fmt.Sprintf(\"malformed config: %s\", err.UnmarshalError.Error())\n}\n\ntype MalformedStepError struct {\n\tStepType string\n\tErr      error\n}\n\nfunc (err MalformedStepError) Error() string {\n\treturn fmt.Sprintf(\"malformed %s step: %s\", err.StepType, err.Err)\n}\n\n\n\nfunc (err MalformedStepError) Unwrap() error ", "output": "{\n\treturn err.Err\n}"}
{"input": "package command_factory\n\nimport (\n\t\"time\"\n\n\t\"github.com/cloudfoundry-incubator/ltc/cluster_test\"\n\t\"github.com/codegangsta/cli\"\n)\n\ntype ClusterTestCommandFactory struct {\n\tclusterTestRunner cluster_test.ClusterTestRunner\n}\n\nfunc NewClusterTestCommandFactory(testRunner cluster_test.ClusterTestRunner) *ClusterTestCommandFactory {\n\treturn &ClusterTestCommandFactory{testRunner}\n}\n\nfunc (factory *ClusterTestCommandFactory) MakeClusterTestCommand() cli.Command {\n\n\ttestFlags := []cli.Flag{\n\t\tcli.DurationFlag{\n\t\t\tName:  \"timeout, t\",\n\t\t\tUsage: \"Duration of time tests will wait for lattice to respond\",\n\t\t\tValue: time.Minute * 5,\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"verbose, v\",\n\t\t\tUsage: \"Verbose mode\",\n\t\t},\n\t}\n\n\tcliCommand := cli.Command{\n\t\tName:        \"test\",\n\t\tAliases:     []string{\"te\"},\n\t\tUsage:       \"Runs test suite against targeted lattice cluster\",\n\t\tDescription: \"ltc test [-v] [--timeout=<timeout>] [--cli-help]\",\n\t\tAction:      factory.runIntegrationTests,\n\t\tFlags:       testFlags,\n\t}\n\n\treturn cliCommand\n}\n\n\n\nfunc (factory *ClusterTestCommandFactory) runIntegrationTests(context *cli.Context) ", "output": "{\n\tfactory.clusterTestRunner.Run(context.Duration(\"timeout\"), context.Bool(\"verbose\"))\n}"}
{"input": "package cors\n\n\n\n\nfunc stringInSlice(target string, list []string) bool ", "output": "{\n\tfor _, value := range list {\n\t\tif target == value {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}"}
{"input": "package mlock\n\nimport (\n       \"syscall\"\n       \"golang.org/x/sys/unix\"\n)\n\n\n\nfunc lockMemory() error {\n       \n       return unix.Mlockall(syscall.MCL_CURRENT | syscall.MCL_FUTURE)\n}\n\nfunc init() ", "output": "{\n       supported = true\n}"}
{"input": "package vm\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc newStack() *stack {\n\treturn &stack{}\n}\n\ntype stack struct {\n\tdata []*big.Int\n\tptr  int\n}\n\nfunc (st *stack) push(d *big.Int) {\n\tstackItem := new(big.Int).Set(d)\n\tif len(st.data) > st.ptr {\n\t\tst.data[st.ptr] = stackItem\n\t} else {\n\t\tst.data = append(st.data, stackItem)\n\t}\n\tst.ptr++\n}\n\nfunc (st *stack) pop() (ret *big.Int) {\n\tst.ptr--\n\tret = st.data[st.ptr]\n\treturn\n}\n\nfunc (st *stack) len() int {\n\treturn st.ptr\n}\n\nfunc (st *stack) swap(n int) {\n\tst.data[st.len()-n], st.data[st.len()-1] = st.data[st.len()-1], st.data[st.len()-n]\n}\n\n\n\nfunc (st *stack) peek() *big.Int {\n\treturn st.data[st.len()-1]\n}\n\nfunc (st *stack) require(n int) error {\n\tif st.len() < n {\n\t\treturn fmt.Errorf(\"stack underflow (%d <=> %d)\", len(st.data), n)\n\t}\n\treturn nil\n}\n\nfunc (st *stack) Print() {\n\tfmt.Println(\"### stack ###\")\n\tif len(st.data) > 0 {\n\t\tfor i, val := range st.data {\n\t\t\tfmt.Printf(\"%-3d  %v\\n\", i, val)\n\t\t}\n\t} else {\n\t\tfmt.Println(\"-- empty --\")\n\t}\n\tfmt.Println(\"#############\")\n}\n\nfunc (st *stack) dup(n int) ", "output": "{\n\tst.push(st.data[st.len()-n])\n}"}
{"input": "package runtime\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n)\n\n\n\n\n\nfunc JSONProducer() Producer {\n\treturn ProducerFunc(func(writer io.Writer, data interface{}) error {\n\t\tenc := json.NewEncoder(writer)\n\t\tenc.SetEscapeHTML(false)\n\t\treturn enc.Encode(data)\n\t})\n}\n\nfunc JSONConsumer() Consumer ", "output": "{\n\treturn ConsumerFunc(func(reader io.Reader, data interface{}) error {\n\t\tdec := json.NewDecoder(reader)\n\t\tdec.UseNumber() \n\t\treturn dec.Decode(data)\n\t})\n}"}
{"input": "package gwu_test\n\nimport (\n\t\"github.com/sinni800/gowut/gwu\"\n)\n\n\nfunc ExampleButton() {\n\tb := gwu.NewButton(\"Click me\")\n\tb.AddEHandlerFunc(func(e gwu.Event) {\n\t\tif e.MouseBtn() == gwu.MOUSE_BTN_MIDDLE {\n\t\t}\n\t}, gwu.ETYPE_CLICK)\n}\n\n\n\n\nfunc ExampleTextBox() ", "output": "{\n\tb := gwu.NewTextBox(\"\")\n\tb.AddSyncOnETypes(gwu.ETYPE_KEY_UP) \n\tb.AddEHandlerFunc(func(e gwu.Event) {\n\t\tif e.ModKey(gwu.MOD_KEY_SHIFT) {\n\t\t}\n\n\t\tc := e.KeyCode()\n\t\tswitch {\n\t\tcase c == gwu.KEY_ENTER: \n\t\tcase c >= gwu.KEY_0 && c <= gwu.KEY_9:\n\t\t\tfallthrough\n\t\tcase c >= gwu.KEY_NUMPAD_0 && c <= gwu.KEY_NUMPAD_9: \n\t\tcase c >= gwu.KEY_A && c <= gwu.KEY_Z: \n\t\tcase c >= gwu.KEY_F1 && c <= gwu.KEY_F12: \n\t\t}\n\t}, gwu.ETYPE_KEY_UP)\n}"}
{"input": "package ipc\n\nimport (\n\t\"testing\"\n)\n\ntype EchoServer struct {\n}\n\nfunc (server *EchoServer) Handle(request string) string {\n\treturn \"ECHO:\" + request\n}\n\n\n\nfunc TestIpc(t *testing.T) {\n\tserver := NewIpcServer(&EchoServer{})\n\n\tclient1 := NewIpcClient(server)\n\tclient2 := NewIpcClient(server)\n\n\tresp1 := client1.Call(\"From Client1\")\n\tresp2 := client1.Call(\"From Client2\")\n\n\tif resp1 != \"ECHO:From Client1\" || resp2 != \"ECHO:From Client2\" {\n\t\tt.Error(\"IpcClient.Call failed. resp1:\", resp1, \"resp2:\", resp2)\n\t}\n\tclient1.Close()\n\tclient2.Close()\n}\n\nfunc (server *EchoServer) Name() string ", "output": "{\n\treturn \"EchoServer\"\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n)\n\n\ntype Tree struct {\n\tLeft  *Tree\n\tValue int\n\tRight *Tree\n}\n\n\n\nfunc Walk(t *Tree, ch chan int) {\n\tif t == nil {\n\t\treturn\n\t}\n\tWalk(t.Left, ch)\n\tch <- t.Value\n\tWalk(t.Right, ch)\n}\n\n\n\n\n\n\n\n\nfunc Compare(t1, t2 *Tree) bool {\n\tc1, c2 := Walker(t1), Walker(t2)\n\tfor {\n\t\tv1, ok1 := <-c1\n\t\tv2, ok2 := <-c2\n\t\tif !ok1 || !ok2 {\n\t\t\treturn ok1 == ok2\n\t\t}\n\t\tif v1 != v2 {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn false\n}\n\n\n\nfunc New(n, k int) *Tree {\n\tvar t *Tree\n\tfor _, v := range rand.Perm(n) {\n\t\tt = insert(t, (1+v)*k)\n\t}\n\treturn t\n}\n\nfunc insert(t *Tree, v int) *Tree {\n\tif t == nil {\n\t\treturn &Tree{nil, v, nil}\n\t}\n\tif v < t.Value {\n\t\tt.Left = insert(t.Left, v)\n\t\treturn t\n\t}\n\tt.Right = insert(t.Right, v)\n\treturn t\n}\n\nfunc main() {\n\tt1 := New(100, 1)\n\tfmt.Println(Compare(t1, New(100, 1)), \"Same Contents\")\n\tfmt.Println(Compare(t1, New(99, 1)), \"Differing Sizes\")\n\tfmt.Println(Compare(t1, New(100, 2)), \"Differing Values\")\n\tfmt.Println(Compare(t1, New(101, 2)), \"Dissimilar\")\n}\n\nfunc Walker(t *Tree) <-chan int ", "output": "{\n\tch := make(chan int)\n\tgo func() {\n\t\tWalk(t, ch)\n\t\tclose(ch)\n\t}()\n\treturn ch\n}"}
{"input": "package cairo\n\ntype TextCluster struct {\n\tNumBytes  int\n\tNumGlyphs int\n}\n\nvar (\n\tTextClusterAllocate func(numClusters int) *TextCluster\n\n\tTextClusterFree func(t *TextCluster)\n)\n\n\n\ntype TextClusterFlags Enum\n\nconst (\n\tTEXT_CLUSTER_FLAG_BACKWARD TextClusterFlags = 1 << iota\n)\n\ntype TextExtents struct {\n\tXBearing float64\n\tYBearing float64\n\tWidth    float64\n\tHeight   float64\n\tXAdvance float64\n\tYAdvance float64\n}\n\nfunc (t *TextCluster) Free() ", "output": "{ TextClusterFree(t) }"}
{"input": "package gtka\n\nimport (\n\t\"github.com/gotk3/gotk3/gtk\"\n\t\"github.com/coyim/gotk3adapter/gliba\"\n\t\"github.com/coyim/gotk3adapter/gtki\"\n)\n\ntype application struct {\n\t*gliba.Application\n\tinternal *gtk.Application\n}\n\n\n\nfunc wrapApplication(v *gtk.Application, e error) (*application, error) {\n\treturn wrapApplicationSimple(v), e\n}\n\nfunc unwrapApplication(v gtki.Application) *gtk.Application {\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn v.(*application).internal\n}\n\nfunc (v *application) GetActiveWindow() gtki.Window {\n\tret := wrapWindowSimple(v.internal.GetActiveWindow())\n\tif ret == nil {\n\t\treturn nil\n\t}\n\treturn ret\n}\n\nfunc wrapApplicationSimple(v *gtk.Application) *application ", "output": "{\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn &application{gliba.WrapApplicationSimple(&v.Application), v}\n}"}
{"input": "package resolve\n\nimport (\n\t\"github.com/google/gapid/core/data/id\"\n\t\"github.com/google/gapid/core/memory/arena\"\n\t\"github.com/google/gapid/gapis/api\"\n\t\"github.com/google/gapid/gapis/service\"\n\t\"github.com/google/gapid/gapis/service/box\"\n\t\"github.com/google/gapid/gapis/service/path\"\n)\n\nfunc internalToService(v interface{}) (interface{}, error) {\n\tswitch v := v.(type) {\n\tcase api.Cmd:\n\t\treturn api.CmdToService(v)\n\tcase []*api.ContextInfo:\n\t\tout := &service.Contexts{List: make([]*path.Context, len(v))}\n\t\tfor i, c := range v {\n\t\t\tout.List[i] = c.Path\n\t\t}\n\t\treturn out, nil\n\tcase *api.ContextInfo:\n\t\treturn &service.Context{\n\t\t\tName:     v.Name,\n\t\t\tAPI:      path.NewAPI(id.ID(v.API)),\n\t\t\tPriority: uint32(v.Priority),\n\t\t}, nil\n\tdefault:\n\t\treturn v, nil\n\t}\n}\n\n\n\nfunc serviceToInternal(a arena.Arena, v interface{}) (interface{}, error) ", "output": "{\n\tswitch v := v.(type) {\n\tcase *api.Command:\n\t\treturn api.ServiceToCmd(a, v)\n\tcase *box.Value:\n\t\treturn v.Get(), nil\n\tdefault:\n\t\treturn v, nil\n\t}\n}"}
{"input": "package logs\n\nconst (\n\tErrorLevel = iota\n\tWarnLevel\n\tInfoLevel\n\tDebugLevel\n)\n\ntype Level uint32\n\nfunc (l Level) EQ(lv Level) bool {\n\tif l == lv {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (l Level) LTE(lv Level) bool {\n\tif l <= lv {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (l Level) LT(lv Level) bool {\n\tif l < lv {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (l Level) GTE(lv Level) bool {\n\tif l >= lv {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n\nfunc (l Level) Color() int {\n\tvar levelColor int\n\tswitch l {\n\tcase DebugLevel:\n\t\tlevelColor = 32\n\tcase InfoLevel:\n\t\tlevelColor = 36\n\tcase WarnLevel:\n\t\tlevelColor = 33\n\tcase ErrorLevel:\n\t\tlevelColor = 31\n\tdefault:\n\t\tlevelColor = 0\n\t}\n\treturn levelColor\n}\n\nfunc (l Level) String() string {\n\tswitch l {\n\tcase DebugLevel:\n\t\treturn \"DEBU\"\n\tcase InfoLevel:\n\t\treturn \"INFO\"\n\tcase WarnLevel:\n\t\treturn \"WARN\"\n\tcase ErrorLevel:\n\t\treturn \"ERRO\"\n\t}\n\treturn \"    \"\n}\n\nfunc (l Level) GT(lv Level) bool ", "output": "{\n\tif l > lv {\n\t\treturn true\n\t}\n\treturn false\n}"}
{"input": "package models\n\n\n\n\nimport (\n\t\"context\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\n\ntype ErrorArguments struct {\n\n\tCode string `json:\"code,omitempty\"`\n\n\tMessage string `json:\"message,omitempty\"`\n}\n\n\nfunc (m *ErrorArguments) Validate(formats strfmt.Registry) error {\n\treturn nil\n}\n\n\nfunc (m *ErrorArguments) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.contextValidateCode(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.contextValidateMessage(ctx, formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *ErrorArguments) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {\n\n\tif err := validate.ReadOnly(ctx, \"code\", \"body\", string(m.Code)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\n\nfunc (m *ErrorArguments) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\nfunc (m *ErrorArguments) UnmarshalBinary(b []byte) error {\n\tvar res ErrorArguments\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *ErrorArguments) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error ", "output": "{\n\n\tif err := validate.ReadOnly(ctx, \"message\", \"body\", string(m.Message)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package group\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/openshift/origin/pkg/auth/authenticator\"\n\t\"k8s.io/kubernetes/pkg/auth/user\"\n)\n\n\ntype GroupAdder struct {\n\tAuthenticator authenticator.Request\n\tGroups        []string\n}\n\nfunc (g *GroupAdder) AuthenticateRequest(req *http.Request) (user.Info, bool, error) {\n\tu, ok, err := g.Authenticator.AuthenticateRequest(req)\n\tif err != nil || !ok {\n\t\treturn nil, ok, err\n\t}\n\treturn &user.DefaultInfo{\n\t\tName:   u.GetName(),\n\t\tUID:    u.GetUID(),\n\t\tGroups: append(u.GetGroups(), g.Groups...),\n\t}, true, nil\n}\n\n\n\nfunc NewGroupAdder(auth authenticator.Request, groups []string) *GroupAdder ", "output": "{\n\treturn &GroupAdder{auth, groups}\n}"}
{"input": "package gomega\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"time\"\n)\n\ntype asyncActual struct {\n\tactualInput     interface{}\n\ttimeoutInterval time.Duration\n\tpollingInterval time.Duration\n\tfail            OmegaFailHandler\n}\n\nfunc newAsyncActual(actualInput interface{}, fail OmegaFailHandler, timeoutInterval time.Duration, pollingInterval time.Duration) *asyncActual {\n\tactualType := reflect.TypeOf(actualInput)\n\tif actualType.Kind() == reflect.Func {\n\t\tif actualType.NumIn() != 0 || actualType.NumOut() != 1 {\n\t\t\tpanic(\"Expected a function with no arguments and one return value.\")\n\t\t}\n\t}\n\n\treturn &asyncActual{\n\t\tactualInput:     actualInput,\n\t\tfail:            fail,\n\t\ttimeoutInterval: timeoutInterval,\n\t\tpollingInterval: pollingInterval,\n\t}\n}\n\nfunc (actual *asyncActual) Should(matcher OmegaMatcher, optionalDescription ...interface{}) bool {\n\treturn actual.match(matcher, true, optionalDescription...)\n}\n\nfunc (actual *asyncActual) ShouldNot(matcher OmegaMatcher, optionalDescription ...interface{}) bool {\n\treturn actual.match(matcher, false, optionalDescription...)\n}\n\nfunc (actual *asyncActual) buildDescription(optionalDescription ...interface{}) string {\n\tswitch len(optionalDescription) {\n\tcase 0:\n\t\treturn \"\"\n\tdefault:\n\t\treturn fmt.Sprintf(optionalDescription[0].(string), optionalDescription[1:]...) + \"\\n\"\n\t}\n}\nfunc (actual *asyncActual) pollActual() interface{} {\n\tactualType := reflect.TypeOf(actual.actualInput)\n\n\tif actualType.Kind() == reflect.Func && actualType.NumIn() == 0 && actualType.NumOut() == 1 {\n\t\treturn reflect.ValueOf(actual.actualInput).Call([]reflect.Value{})[0].Interface()\n\t}\n\n\treturn actual.actualInput\n}\n\n\n\nfunc (actual *asyncActual) match(matcher OmegaMatcher, desiredMatch bool, optionalDescription ...interface{}) bool ", "output": "{\n\ttimer := time.Now()\n\ttimeout := time.After(actual.timeoutInterval)\n\n\tdescription := actual.buildDescription(optionalDescription...)\n\tmatches, message, err := matcher.Match(actual.pollActual())\n\n\tfor {\n\t\tif err == nil && matches == desiredMatch {\n\t\t\treturn true\n\t\t}\n\n\t\tselect {\n\t\tcase <-time.After(actual.pollingInterval):\n\t\t\tmatches, message, err = matcher.Match(actual.pollActual())\n\t\tcase <-timeout:\n\t\t\terrMsg := \"\"\n\t\t\tif err != nil {\n\t\t\t\terrMsg = \"Error: \" + err.Error()\n\t\t\t}\n\t\t\tactual.fail(fmt.Sprintf(\"Timed out after %.3fs.\\n%s%s%s\", time.Since(timer).Seconds(), description, message, errMsg), 2)\n\t\t\treturn false\n\t\t}\n\t}\n}"}
{"input": "package control\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\nvar (\n\tBuildSessionConfigs     = buildSessionConfigs\n\tComputeDiff             = computeDiff\n\tNewPathPolForEnteringAS = newPathPolForEnteringAS\n\tNewPrefixWatcher        = newPrefixWatcher\n\n\tCopyPathPolicy     = copyPathPolicy\n\tBuildRoutingChains = buildRoutingChains\n)\n\ntype ConjunctionPathPol = conjuctionPathPol\ntype Diff = diff\n\n\n\nfunc (w *GatewayWatcher) RunAllPrefixWatchersOnceForTest(ctx context.Context) {\n\tvar wg sync.WaitGroup\n\tfor _, wi := range w.currentWatchers {\n\t\twi := wi\n\t\twi.prefixWatcher.resetRunMarker()\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\twi.prefixWatcher.Run(ctx)\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc (w *prefixWatcher) resetRunMarker() {\n\tw.runMarkerLock.Lock()\n\tdefer w.runMarkerLock.Unlock()\n\tw.runMarker = false\n}\n\nfunc (w *GatewayWatcher) RunOnce(ctx context.Context) ", "output": "{\n\tw.run(ctx)\n}"}
{"input": "package kodingcontext\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\n\t\"github.com/hashicorp/terraform/terraform\"\n\t\"github.com/mitchellh/cli\"\n)\n\n\n\n\n\ntype KodingContext struct {\n\tcontext\n\n\tBuffer       *bytes.Buffer\n\tui           *cli.PrefixedUi\n\tVariables    map[string]string\n\tShutdownChan <-chan struct{}\n\tContentID    string\n\n\tdebug bool\n}\n\n\nfunc (c *KodingContext) TerraformContextOpts() *terraform.ContextOpts {\n\treturn c.TerraformContextOptsWithPlan(nil)\n}\n\n\nfunc (c *KodingContext) TerraformContextOptsWithPlan(p *terraform.Plan) *terraform.ContextOpts {\n\tif p == nil {\n\t\tp = &terraform.Plan{}\n\t}\n\n\treturn &terraform.ContextOpts{\n\t\tDestroy:     false,\n\t\tParallelism: 0,\n\n\t\tHooks: nil,\n\n\t\tModule: p.Module,\n\t\tState:  p.State,\n\t\tDiff:   p.Diff,\n\n\t\tProviders:    c.Providers,\n\t\tProvisioners: c.Provisioners,\n\t\tVariables:    c.Variables,\n\t}\n}\n\n\nfunc (c *KodingContext) Close() error {\n\tif c.ContentID == \"\" {\n\t\treturn errors.New(\"contentID is nil\")\n\t}\n\n\tshutdownChansMu.Lock()\n\tdelete(shutdownChans, c.ContentID)\n\tshutdownChansWG.Done()\n\tshutdownChansMu.Unlock()\n\n\tif c.debug {\n\t\treturn nil \n\t}\n\n\treturn c.LocalStorage.Remove(c.ContentID)\n}\n\nfunc (c *context) newKodingContext(sc <-chan struct{}, contentID, traceID string) *KodingContext ", "output": "{\n\terrorBuf := new(bytes.Buffer)\n\n\tkc := &KodingContext{\n\t\tcontext: context{\n\t\t\tProviders:     c.Providers,\n\t\t\tProvisioners:  c.Provisioners,\n\t\t\tLocalStorage:  c.LocalStorage,\n\t\t\tRemoteStorage: c.RemoteStorage,\n\t\t\tlog:           c.log,\n\t\t},\n\t\tContentID:    contentID,\n\t\tBuffer:       errorBuf,\n\t\tui:           NewUI(errorBuf, traceID),\n\t\tShutdownChan: sc,\n\t\tdebug:        c.debug,\n\t}\n\n\treturn kc\n}"}
{"input": "package send\n\nimport (\n\t\"bytes\"\n\n\t\"github.com/webx-top/echo/param\"\n)\n\n\nfunc NewContent() *Content {\n\treturn &Content{}\n}\n\n\ntype Content struct {\n\temailContent    []byte\n\tmarkdownContent []byte\n}\n\n\n\n\n\nfunc (c *Content) MarkdownContent(params param.Store) []byte {\n\tif c.markdownContent == nil {\n\t\tb := new(bytes.Buffer)\n\t\tMarkdownTmpl().Execute(b, params)\n\t\tc.markdownContent = b.Bytes()\n\t}\n\treturn c.markdownContent\n}\n\nfunc (c *Content) EmailContent(params param.Store) []byte ", "output": "{\n\tif c.emailContent == nil {\n\t\tb := new(bytes.Buffer)\n\t\tMailTpl().Execute(b, params)\n\t\tc.emailContent = b.Bytes()\n\t}\n\treturn c.emailContent\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n)\n\nconst VERSION = \"0.0.4\"\n\n\n\nfunc usage() ", "output": "{\n\tfmt.Printf(\"DryDock %s\\n\", VERSION)\n\tfmt.Printf(\"usage: drydock [options]\\n\\n\")\n\n\tfmt.Printf(\"Options:\\n\")\n\tfmt.Printf(\"  --dry-run                          don't delete images\\n\")\n\tfmt.Printf(\"  --age      <48h>                   delete images older than age\\n\")\n\tfmt.Printf(\"  --keep     <10>                    keep at least this many images\\n\")\n\tfmt.Printf(\"  --pattern  <^.*$>                  pattern for images to be deleted\\n\")\n\tfmt.Printf(\"  --docker   <tcp://127.0.0.1:2375>  docker host endpoint\\n\")\n}"}
{"input": "package credential\n\nimport (\n\t\"pharmer.dev/cloud/apis\"\n\tv1 \"pharmer.dev/cloud/apis/cloud/v1\"\n\n\t\"github.com/spf13/pflag\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\ntype Linode struct {\n\tCommonSpec\n\n\ttoken string\n}\n\nfunc (c Linode) APIToken() string { return get(c.Data, LinodeAPIToken, c.token) }\n\nfunc (c *Linode) LoadFromEnv() {\n\tc.CommonSpec.LoadFromEnv(c.Format())\n}\n\nfunc (c Linode) IsValid() (bool, error) {\n\treturn c.CommonSpec.IsValid(c.Format())\n}\n\nfunc (c *Linode) AddFlags(fs *pflag.FlagSet) {\n\tfs.StringVar(&c.token, apis.Linode+\".\"+LinodeAPIToken, c.token, \"Linode api token\")\n}\n\n\n\nfunc (_ Linode) Format() v1.CredentialFormat {\n\treturn v1.CredentialFormat{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: apis.Linode,\n\t\t\tAnnotations: map[string]string{\n\t\t\t\tapis.KeyClusterCredential: \"\",\n\t\t\t\tapis.KeyDNSCredential:     \"\",\n\t\t\t},\n\t\t},\n\t\tSpec: v1.CredentialFormatSpec{\n\t\t\tProvider:      apis.Linode,\n\t\t\tDisplayFormat: \"field\",\n\t\t\tFields: []v1.CredentialField{\n\t\t\t\t{\n\t\t\t\t\tEnvconfig: \"LINODE_TOKEN\",\n\t\t\t\t\tForm:      \"linode_token\",\n\t\t\t\t\tJSON:      LinodeAPIToken,\n\t\t\t\t\tLabel:     \"Token\",\n\t\t\t\t\tInput:     \"password\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc (_ Linode) RequiredFlags() []string ", "output": "{\n\treturn []string{apis.Linode + \".\" + LinodeAPIToken}\n}"}
{"input": "package pdf417\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\n\t\"github.com/boombuler/barcode\"\n\t\"github.com/boombuler/barcode/utils\"\n)\n\ntype pdfBarcode struct {\n\tdata  string\n\twidth int\n\tcode  *utils.BitList\n}\n\n\n\nfunc (c *pdfBarcode) Content() string {\n\treturn c.data\n}\n\nfunc (c *pdfBarcode) ColorModel() color.Model {\n\treturn color.Gray16Model\n}\n\nfunc (c *pdfBarcode) Bounds() image.Rectangle {\n\theight := c.code.Len() / c.width\n\n\treturn image.Rect(0, 0, c.width, height*moduleHeight)\n}\n\nfunc (c *pdfBarcode) At(x, y int) color.Color {\n\tif c.code.GetBit((y/moduleHeight)*c.width + x) {\n\t\treturn color.Black\n\t}\n\treturn color.White\n}\n\nfunc (c *pdfBarcode) Metadata() barcode.Metadata ", "output": "{\n\treturn barcode.Metadata{barcode.TypePDF, 2}\n}"}
{"input": "package plugins\n\nimport (\n\t\"github.com/dmacvicar/terraform-provider-libvirt/libvirt\"\n\t\"github.com/hashicorp/terraform/plugin\"\n)\n\n\n\nfunc init() ", "output": "{\n\texec := func() {\n\t\tdefer libvirt.CleanupLibvirtConnections()\n\n\t\tplugin.Serve(&plugin.ServeOpts{\n\t\t\tProviderFunc: libvirt.Provider,\n\t\t})\n\t}\n\tKnownPlugins[\"terraform-provider-libvirt\"] = exec\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi\"\n)\n\ntype todosResource struct{}\n\n\nfunc (rs todosResource) Routes() chi.Router {\n\tr := chi.NewRouter()\n\n\tr.Get(\"/\", rs.List)    \n\tr.Post(\"/\", rs.Create) \n\tr.Put(\"/\", rs.Delete)\n\n\tr.Route(\"/{id}\", func(r chi.Router) {\n\t\tr.Get(\"/\", rs.Get)       \n\t\tr.Put(\"/\", rs.Update)    \n\t\tr.Delete(\"/\", rs.Delete) \n\t\tr.Get(\"/sync\", rs.Sync)\n\t})\n\n\treturn r\n}\n\nfunc (rs todosResource) List(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todos list of stuff..\"))\n}\n\n\n\nfunc (rs todosResource) Get(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todo get\"))\n}\n\nfunc (rs todosResource) Update(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todo update\"))\n}\n\nfunc (rs todosResource) Delete(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todo delete\"))\n}\n\nfunc (rs todosResource) Sync(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todo sync\"))\n}\n\nfunc (rs todosResource) Create(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tw.Write([]byte(\"todos create\"))\n}"}
{"input": "package frala\n\n\nfunc GetValue(termName, language string) string {\n\tif language != \"\" { \n\t\tlanguage = Sanitize(language) \n\t} else { \n\t\tlanguage = Config.DefaultLanguage \n\t}\n\n\tSetTerm(termName)                                 \n\tvalue, exists := Config.Terms[termName][language] \n\n\tif !exists { \n\t\tvalue = \"Term \" + termName + \" is not translated into \" + language\n\t}\n\n\treturn value\n}\n\n\nfunc SetTerm(termName string) {\n\tif termName != \"\" { \n\t\tif _, exists := Config.Terms[termName]; !exists { \n\t\t\tConfig.Terms[termName] = Term{} \n\t\t}\n\t}\n}\n\n\nfunc SetValue(termName, language, value string) {\n\tSetTerm(termName)                 \n\tterm, _ := Config.Terms[termName] \n\tlanguage = Sanitize(language)     \n\n\tterm[language] = value        \n\tConfig.Terms[termName] = term \n}\n\n\n\n\n\nfunc DeleteValue(termName, language string) {\n\tterm, exists := Config.Terms[termName] \n\n\tif exists { \n\t\tdelete(term, language)        \n\t\tConfig.Terms[termName] = term \n\t}\n}\n\nfunc DeleteTerm(termName string) ", "output": "{\n\tdelete(Config.Terms, termName) \n}"}
{"input": "package mtlsfirstpartyjwt\n\nimport (\n\t\"testing\"\n\n\t\"istio.io/istio/pkg/test/framework\"\n\t\"istio.io/istio/pkg/test/framework/components/istio\"\n\t\"istio.io/istio/pkg/test/framework/components/pilot\"\n\t\"istio.io/istio/pkg/test/framework/label\"\n\t\"istio.io/istio/pkg/test/framework/resource\"\n\t\"istio.io/istio/pkg/test/framework/resource/environment\"\n)\n\nvar (\n\tinst istio.Instance\n\tp    pilot.Instance\n)\n\nfunc TestMain(m *testing.M) {\n\tframework.\n\t\tNewSuite(\"mtls_first_party_jwt\", m).\n\t\tRequireEnvironment(environment.Kube).\n\t\tRequireSingleCluster().\n\t\tLabel(label.CustomSetup).\n\t\tSetupOnEnv(environment.Kube, istio.Setup(&inst, setupConfig)).\n\t\tSetup(func(ctx resource.Context) (err error) {\n\t\t\tif p, err = pilot.New(ctx, pilot.Config{}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}).\n\t\tRun()\n}\n\n\n\nfunc setupConfig(cfg *istio.Config) ", "output": "{\n\tif cfg == nil {\n\t\treturn\n\t}\n\tcfg.Values[\"global.jwtPolicy\"] = \"first-party-jwt\"\n\tcfg.Values[\"global.mtls.auto\"] = \"true\"\n}"}
{"input": "package state\n\nimport \"context\"\n\n\n\n\nfunc Processor(ctx context.Context, in chan *WorkRequest, out chan *WorkResponse) ", "output": "{\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase wr := <-in:\n\t\t\tout <- Process(wr)\n\t\t}\n\t}\n}"}
{"input": "package irc\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"sync\"\n)\n\ntype Decoder struct {\n\trdr *bufio.Reader\n\t*sync.Mutex\n}\n\n\n\n\nfunc (d *Decoder) Decode(msg *Msg) (err error) {\n\td.Lock()\n\tdefer d.Unlock()\n\n\tvar line []byte\n\tline, _, err = d.rdr.ReadLine()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tmsg.Reset()\n\tmsg.Data = line[:]\n\treturn msg.PeekCmd()\n}\n\nfunc NewDecoder(r io.Reader) *Decoder ", "output": "{\n\trdr := bufio.NewReader(r)\n\treturn &Decoder{rdr, &sync.Mutex{}}\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n\t\"net/http\"\n)\n\n\ntype GetCrossConnectStatusRequest struct {\n\n\tCrossConnectId *string `mandatory:\"true\" contributesTo:\"path\" name:\"crossConnectId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetCrossConnectStatusRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request GetCrossConnectStatusRequest) HTTPRequest(method, path string) (http.Request, error) {\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request GetCrossConnectStatusRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetCrossConnectStatusResponse struct {\n\n\tRawResponse *http.Response\n\n\tCrossConnectStatus `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\n\n\n\nfunc (response GetCrossConnectStatusResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response GetCrossConnectStatusResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package service\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc TestService_SettingInfo(t *testing.T) {\n\tConvey(\"test setting info\", t, WithService(func(s *Service) {\n\t\tmid := int64(88889018)\n\t\tdata, err := s.SettingInfo(context.Background(), mid)\n\t\tSo(err, ShouldBeNil)\n\t\tvar str []byte\n\t\tstr, err = json.Marshal(data)\n\t\tSo(err, ShouldBeNil)\n\t\tPrintf(\"%+v\", string(str))\n\t}))\n}\n\n\n\nfunc TestService_PrivacyModify(t *testing.T) {\n\tConvey(\"test index order modify\", t, WithService(func(s *Service) {\n\t\tmid := int64(88889018)\n\t\tfield := \"bangumi\"\n\t\tvalue := 0\n\t\terr := s.PrivacyModify(context.Background(), mid, field, value)\n\t\tSo(err, ShouldBeNil)\n\t}))\n}\n\nfunc TestService_fixIndexOrder(t *testing.T) {\n\tConvey(\"test fixIndexOrder\", t, WithService(func(s *Service) {\n\t\tmid := int64(88889018)\n\t\tindexOrder := `[\"1\",\"3\",\"2\",\"5\",\"6\",\"4\",7,21,22,23,24,25]`\n\t\ts.fixIndexOrder(context.Background(), mid, indexOrder)\n\t}))\n}\n\nfunc TestService_IndexOrderModify(t *testing.T) ", "output": "{\n\tConvey(\"test index order modify\", t, WithService(func(s *Service) {\n\t\tmid := int64(88889018)\n\t\torderNum := []string{\"1\", \"8\", \"7\", \"2\", \"3\", \"4\", \"5\", \"6\", \"9\", \"21\", \"22\", \"23\", \"24\", \"25\"}\n\t\terr := s.IndexOrderModify(context.Background(), mid, orderNum)\n\t\tSo(err, ShouldBeNil)\n\t}))\n}"}
{"input": "package aws\n\nimport (\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n\t\"github.com/aws/aws-sdk-go/service/elbv2\"\n\t\"github.com/aws/aws-sdk-go/service/elbv2/elbv2iface\"\n\t\"github.com/stelligent/mu/common\"\n)\n\ntype elbv2Manager struct {\n\telbAPI elbv2iface.ELBV2API\n}\n\n\n\n\nfunc (elbMgr *elbv2Manager) ListRules(listenerArn string) ([]common.ElbRule, error) {\n\telbAPI := elbMgr.elbAPI\n\n\tparams := &elbv2.DescribeRulesInput{\n\t\tListenerArn: aws.String(listenerArn),\n\t}\n\n\tlog.Debugf(\"Searching for elb rules for ARN '%s'\", listenerArn)\n\n\toutput, err := elbAPI.DescribeRules(params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trules := make([]common.ElbRule, len(output.Rules))\n\tfor i, rule := range output.Rules {\n\t\trules[i] = rule\n\t}\n\n\treturn rules, nil\n}\n\nfunc newElbv2Manager(sess *session.Session) (common.ElbManager, error) ", "output": "{\n\tlog.Debug(\"Connecting to ELBv2 service\")\n\telbAPI := elbv2.New(sess)\n\n\treturn &elbv2Manager{\n\t\telbAPI: elbAPI,\n\t}, nil\n}"}
{"input": "package vim25\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/vmware/govmomi/vim25/soap\"\n)\n\ntype RetryFunc func(err error) (retry bool, delay time.Duration)\n\n\n\n\nfunc TemporaryNetworkError(n int) RetryFunc {\n\treturn func(err error) (retry bool, delay time.Duration) {\n\t\tvar nerr net.Error\n\t\tvar ok bool\n\n\t\tswitch rerr := err.(type) {\n\t\tcase *url.Error:\n\t\t\tif nerr, ok = rerr.Err.(net.Error); !ok {\n\t\t\t\treturn false, 0\n\t\t\t}\n\t\tcase net.Error:\n\t\t\tnerr = rerr\n\t\tdefault:\n\t\t\treturn false, 0\n\t\t}\n\n\t\tif !nerr.Temporary() {\n\t\t\treturn false, 0\n\t\t}\n\n\t\tif n--; n <= 0 {\n\t\t\treturn false, 0\n\t\t}\n\n\t\treturn true, 0\n\t}\n}\n\ntype retry struct {\n\troundTripper soap.RoundTripper\n\n\tfn RetryFunc\n}\n\n\n\n\n\n\nfunc Retry(roundTripper soap.RoundTripper, fn RetryFunc) soap.RoundTripper {\n\tr := &retry{\n\t\troundTripper: roundTripper,\n\t\tfn:           fn,\n\t}\n\n\treturn r\n}\n\n\n\nfunc (r *retry) RoundTrip(ctx context.Context, req, res soap.HasFault) error ", "output": "{\n\tvar err error\n\n\tfor {\n\t\terr = r.roundTripper.RoundTrip(ctx, req, res)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif retry, delay := r.fn(err); retry {\n\t\t\ttime.Sleep(delay)\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n\n\treturn err\n}"}
{"input": "package sw\n\nimport (\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/hyperledger/fabric/bccsp\"\n)\n\n\n\n\n\n\ntype rsaPublicKey struct{ pubKey *rsa.PublicKey }\n\nfunc (k *rsaPublicKey) Symmetric() bool               { return false }\nfunc (k *rsaPublicKey) Private() bool                 { return false }\n\n\n\nfunc (k *rsaPublicKey) Bytes() (raw []byte, err error) {\n\tif k.pubKey == nil {\n\t\treturn nil, errors.New(\"Failed marshalling key. Key is nil.\")\n\t}\n\traw, err = x509.MarshalPKIXPublicKey(k.pubKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Failed marshalling key [%s]\", err)\n\t}\n\treturn\n}\n\n\nfunc (k *rsaPublicKey) SKI() []byte {\n\tif k.pubKey == nil {\n\t\treturn nil\n\t}\n\n\traw := x509.MarshalPKCS1PublicKey(k.pubKey)\n\thash := sha256.Sum256(raw)\n\treturn hash[:]\n}\n\nfunc (k *rsaPublicKey) PublicKey() (bccsp.Key, error) ", "output": "{ return k, nil }"}
{"input": "package geo\n\n\n\ntype Polygon [][]Point\n\n\nfunc NewPolygon(points ...Point) Polygon {\n\tp1, p2 := points[0], points[len(points)-1]\n\tif p1.Longitude() != p2.Longitude() || p1.Latitude() != p2.Latitude() {\n\t\tpoints = append(points, p1)\n\t}\n\treturn Polygon{points}\n}\n\n\n\n\nfunc (p *Polygon) Exclude(points ...Point) {\n\tif p == nil {\n\t\treturn\n\t}\n\tp1, p2 := points[0], points[len(points)-1]\n\tif p1.Longitude() != p2.Longitude() || p1.Latitude() != p2.Latitude() {\n\t\tpoints = append(points, p1)\n\t}\n\t*p = append(*p, points)\n}\n\n\n\n\nfunc (p Polygon) Geo() *GeoJSON ", "output": "{\n\tif len(p) == 0 {\n\t\treturn nil\n\t}\n\treturn &GeoJSON{\n\t\tType:        \"Polygon\",\n\t\tCoordinates: p,\n\t}\n}"}
{"input": "package runtime\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"code.cloudfoundry.org/garden\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc propertiesToLabels(properties garden.Properties) (map[string]string, error) {\n\tconst maxLabelLen = 4096\n\n\tconst maxKeyLen = maxLabelLen / 2\n\n\tlabelSet := map[string]string{}\n\tfor key, value := range properties {\n\t\tsequenceNum := 0\n\t\tif len(key) > maxKeyLen {\n\t\t\treturn nil, fmt.Errorf(\"property name %q is too long\", key[:32]+\"...\")\n\t\t}\n\t\tfor {\n\t\t\tchunkKey := key + \".\" + strconv.Itoa(sequenceNum)\n\t\t\tvalueLen := maxLabelLen - len(chunkKey)\n\t\t\tif valueLen > len(value) {\n\t\t\t\tvalueLen = len(value)\n\t\t\t}\n\n\t\t\tlabelSet[chunkKey] = value[:valueLen]\n\t\t\tvalue = value[valueLen:]\n\n\t\t\tif len(value) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tsequenceNum++\n\t\t}\n\t}\n\treturn labelSet, nil\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc propertiesToFilterList(properties garden.Properties) ([]string, error) {\n\tfor k, v := range properties {\n\t\tif k == \"\" || v == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"key or value must not be empty\")\n\t\t}\n\t}\n\n\tlabels, err := propertiesToLabels(properties)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfilters := make([]string, 0, len(labels))\n\n\tfor k, v := range labels {\n\t\tfilters = append(filters, \"labels.\"+k+\"==\"+v)\n\t}\n\n\treturn filters, nil\n}\n\nfunc labelsToProperties(labels map[string]string) garden.Properties ", "output": "{\n\tproperties := garden.Properties{}\n\tfor len(labels) > 0 {\n\t\tvar key string\n\t\tfor k := range labels {\n\t\t\tkey = k\n\t\t\tbreak\n\t\t}\n\n\t\tchunkSequenceStart := strings.LastIndexByte(key, '.')\n\t\tif chunkSequenceStart < 0 {\n\t\t\tdelete(labels, key)\n\t\t\tcontinue\n\t\t}\n\n\t\tpropertyName := key[:chunkSequenceStart]\n\n\t\tvar property strings.Builder\n\t\tfor sequenceNum := 0; ; sequenceNum++ {\n\t\t\tchunkKey := propertyName + \".\" + strconv.Itoa(sequenceNum)\n\t\t\tchunkValue, ok := labels[chunkKey]\n\t\t\tif !ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdelete(labels, chunkKey)\n\t\t\tproperty.WriteString(chunkValue)\n\t\t}\n\n\t\tif property.Len() == 0 {\n\t\t\tdelete(labels, key)\n\t\t\tcontinue\n\t\t}\n\n\t\tproperties[propertyName] = property.String()\n\t}\n\n\treturn properties\n}"}
{"input": "package exec\n\nimport (\n\t\"os/exec\"\n\t\"strings\"\n)\n\n\nfunc Exec(cmd, strParam string) error {\n\tparams := strings.Split(strParam, \" \")\n\n\n\terr := exec.Command(cmd, params...).Run()\n\treturn err\n}\n\n\n\n\n\nfunc AsyncExec(cmd, strParam string) error {\n\tparams := strings.Split(strParam, \" \")\n\n\terr := exec.Command(cmd, params...).Start()\n\treturn err\n}\n\nfunc GetExec(cmd, strParam string) (string, error) ", "output": "{\n\tparams := strings.Split(strParam, \" \")\n\n\tout, err := exec.Command(cmd, params...).Output()\n\treturn string(out), err\n}"}
{"input": "package common\n\nimport \"math/big\"\n\ntype _N_ [_S_]byte\n\nfunc BytesTo_N_(b []byte) _N_ {\n\tvar h _N_\n\th.SetBytes(b)\n\treturn h\n}\nfunc StringTo_N_(s string) _N_ { return BytesTo_N_([]byte(s)) }\nfunc BigTo_N_(b *big.Int) _N_  { return BytesTo_N_(b.Bytes()) }\nfunc HexTo_N_(s string) _N_    { return BytesTo_N_(FromHex(s)) }\n\n\n\n\nfunc (h _N_) Str() string   { return string(h[:]) }\nfunc (h _N_) Bytes() []byte { return h[:] }\nfunc (h _N_) Big() *big.Int { return Bytes2Big(h[:]) }\nfunc (h _N_) Hex() string   { return \"0x\" + Bytes2Hex(h[:]) }\n\n\nfunc (h *_N_) SetBytes(b []byte) {\n\tif len(b) > len(h) {\n\t\tb = b[len(b)-_S_:]\n\t}\n\n\tfor i := len(b) - 1; i >= 0; i-- {\n\t\th[_S_-len(b)+i] = b[i]\n\t}\n}\n\n\n\n\n\nfunc (h *_N_) Set(other _N_) {\n\tfor i, v := range other {\n\t\th[i] = v\n\t}\n}\n\nfunc (h *_N_) SetString(s string) ", "output": "{ h.SetBytes([]byte(s)) }"}
{"input": "package models\n\n\n\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\n\n\ntype RdmaProtocol string\n\nconst (\n\n\tRdmaProtocolRoce RdmaProtocol = \"roce\"\n)\n\n\nvar rdmaProtocolEnum []interface{}\n\nfunc init() {\n\tvar res []RdmaProtocol\n\tif err := json.Unmarshal([]byte(`[\"roce\"]`), &res); err != nil {\n\t\tpanic(err)\n\t}\n\tfor _, v := range res {\n\t\trdmaProtocolEnum = append(rdmaProtocolEnum, v)\n\t}\n}\n\nfunc (m RdmaProtocol) validateRdmaProtocolEnum(path, location string, value RdmaProtocol) error {\n\tif err := validate.EnumCase(path, location, value, rdmaProtocolEnum, true); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\nfunc (m RdmaProtocol) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateRdmaProtocolEnum(\"\", \"body\", m); err != nil {\n\t\treturn err\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n\n\n\nfunc (m RdmaProtocol) ContextValidate(ctx context.Context, formats strfmt.Registry) error ", "output": "{\n\treturn nil\n}"}
{"input": "package shell_local\n\nimport (\n\t\"bytes\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/hashicorp/packer/packer\"\n)\n\n\n\nfunc TestCommunicator(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"windows not supported for this test\")\n\t\treturn\n\t}\n\n\tc := &Communicator{\n\t\tExecuteCommand: []string{\"/bin/sh\", \"-c\", \"echo foo\"},\n\t}\n\n\tvar buf bytes.Buffer\n\tcmd := &packer.RemoteCmd{\n\t\tStdout: &buf,\n\t}\n\n\tif err := c.Start(cmd); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tcmd.Wait()\n\n\tif cmd.ExitStatus != 0 {\n\t\tt.Fatalf(\"err bad exit status: %d\", cmd.ExitStatus)\n\t}\n\n\tif strings.TrimSpace(buf.String()) != \"foo\" {\n\t\tt.Fatalf(\"bad: %s\", buf.String())\n\t}\n}\n\nfunc TestCommunicator_impl(t *testing.T) ", "output": "{\n\tvar _ packer.Communicator = new(Communicator)\n}"}
{"input": "package handlers\n\ntype BlockingCallingContext struct {\n\tResult interface{}\n\tWaiter WaitGroup\n}\n\n\n\nfunc (this *BlockingCallingContext) Complete(result interface{}) {\n\tthis.Result = result\n\tthis.Waiter.Done()\n}\n\nfunc NewBlockingCallingContext(waiter WaitGroup) *BlockingCallingContext ", "output": "{\n\twaiter.Add(1)\n\treturn &BlockingCallingContext{Waiter: waiter}\n}"}
{"input": "package volume\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"time\"\n\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/api/resource\"\n\t\"k8s.io/kubernetes/pkg/util/mount\"\n)\n\n\n\ntype Volume interface {\n\tGetPath() string\n\n\tMetricsProvider\n}\n\n\n\ntype MetricsProvider interface {\n\tGetMetrics() (*Metrics, error)\n}\n\n\ntype Metrics struct {\n\tUsed *resource.Quantity\n\n\tCapacity *resource.Quantity\n\n\tAvailable *resource.Quantity\n}\n\n\ntype Attributes struct {\n\tReadOnly        bool\n\tManaged         bool\n\tSupportsSELinux bool\n}\n\n\ntype Mounter interface {\n\tVolume\n\tSetUp(fsGroup *int64) error\n\tSetUpAt(dir string, fsGroup *int64) error\n\tGetAttributes() Attributes\n}\n\n\ntype Unmounter interface {\n\tVolume\n\tTearDown() error\n\tTearDownAt(dir string) error\n}\n\n\ntype Recycler interface {\n\tVolume\n\tRecycle() error\n}\n\n\n\ntype Provisioner interface {\n\tProvision() (*api.PersistentVolume, error)\n}\n\n\n\n\n\ntype Deleter interface {\n\tVolume\n\tDelete() error\n}\n\n\ntype Attacher interface {\n\tAttach(spec *Spec, hostName string) error\n\n\tWaitForAttach(spec *Spec, timeout time.Duration) (string, error)\n\n\tGetDeviceMountPath(spec *Spec) string\n\n\tMountDevice(spec *Spec, devicePath string, deviceMountPath string, mounter mount.Interface) error\n}\n\n\ntype Detacher interface {\n\tDetach(deviceName, hostName string) error\n\n\tWaitForDetach(devicePath string, timeout time.Duration) error\n\n\tUnmountDevice(deviceMountPath string, mounter mount.Interface) error\n}\n\n\n\nfunc RenameDirectory(oldPath, newName string) (string, error) ", "output": "{\n\tnewPath, err := ioutil.TempDir(path.Dir(oldPath), newName)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\terr = os.Rename(oldPath, newPath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn newPath, nil\n}"}
{"input": "package internal\n\nimport (\n\t\"context\"\n\t\"github.com/prometheus/prometheus/pkg/labels\"\n\t\"github.com/prometheus/prometheus/scrape\"\n\t\"testing\"\n)\n\n\n\nfunc TestNoopAppender(t *testing.T) {\n\tif _, err := noop.Add(labels.FromStrings(\"t\", \"v\"), 1, 1); err == nil {\n\t\tt.Error(\"expecting error from Add method of noopApender\")\n\t}\n\tif _, err := noop.Add(labels.FromStrings(\"t\", \"v\"), 1, 1); err == nil {\n\t\tt.Error(\"expecting error from Add method of noopApender\")\n\t}\n\n\tif err := noop.AddFast(labels.FromStrings(\"t\", \"v\"), 0, 1, 1); err == nil {\n\t\tt.Error(\"expecting error from AddFast method of noopApender\")\n\t}\n\n\tif err := noop.Commit(); err == nil {\n\t\tt.Error(\"expecting error from Commit method of noopApender\")\n\t}\n\n\tif err := noop.Rollback(); err != nil {\n\t\tt.Error(\"expecting no error from Rollback method of noopApender\")\n\t}\n\n}\n\nfunc TestOcaStore(t *testing.T) ", "output": "{\n\n\to := NewOcaStore(context.Background(), nil, nil, nil)\n\n\t_, err := o.Appender()\n\tif err == nil {\n\t\tt.Fatal(\"expecting error, but get nil\")\n\t}\n\n\to.SetScrapeManager(nil)\n\t_, err = o.Appender()\n\tif err == nil {\n\t\tt.Fatal(\"expecting error when ScrapeManager is not set, but get nil\")\n\t}\n\n\to.SetScrapeManager(&scrape.Manager{})\n\n\tapp, err := o.Appender()\n\tif app == nil {\n\t\tt.Fatalf(\"expecting app, but got error %v\\n\", err)\n\t}\n\n\t_ = o.Close()\n\n\tapp, err = o.Appender()\n\tif app != noop || err != nil {\n\t\tt.Fatalf(\"expect app!=nil and err==nil, got app=%v and err=%v\", app, err)\n\t}\n}"}
{"input": "package gensupport\n\nimport (\n\t\"io\"\n\t\"time\"\n)\n\n\ntype errReader struct {\n\tbuf []byte\n\terr error\n}\n\nfunc (er *errReader) Read(p []byte) (int, error) {\n\tif len(er.buf) == 0 {\n\t\tif er.err == nil {\n\t\t\treturn 0, io.EOF\n\t\t}\n\t\treturn 0, er.err\n\t}\n\tn := copy(p, er.buf)\n\ter.buf = er.buf[n:]\n\treturn n, nil\n}\n\n\ntype UniformPauseStrategy time.Duration\n\nfunc (p UniformPauseStrategy) Pause() (time.Duration, bool) { return time.Duration(p), true }\nfunc (p UniformPauseStrategy) Reset()                       {}\n\n\nconst NoPauseStrategy = UniformPauseStrategy(0)\n\n\ntype LimitRetryStrategy struct {\n\tMax      int\n\tStrategy BackoffStrategy\n\tn        int\n}\n\n\n\nfunc (l *LimitRetryStrategy) Reset() {\n\tl.n = 0\n\tl.Strategy.Reset()\n}\n\nfunc (l *LimitRetryStrategy) Pause() (time.Duration, bool) ", "output": "{\n\tl.n++\n\tif l.n > l.Max {\n\t\treturn 0, false\n\t}\n\treturn l.Strategy.Pause()\n}"}
{"input": "package v1\n\nimport (\n\t\"k8s.io/kubernetes/pkg/api/v1\"\n\t\"k8s.io/kubernetes/pkg/runtime\"\n)\n\n\n\nfunc addDefaultingFuncs(scheme *runtime.Scheme) error ", "output": "{\n\tv1.RegisterDefaults(scheme)\n\treturn scheme.AddDefaultingFuncs(\n\t\tv1.SetDefaults_Secret,\n\t\tv1.SetDefaults_ServiceSpec,\n\t\tv1.SetDefaults_NamespaceStatus,\n\t)\n}"}
{"input": "package config\n\nimport (\n\t\"os\"\n)\n\ntype config struct {\n\tBasePath string\n\tDestPath string\n}\n\nvar current = config{}\n\n\nfunc GetBasePath() string {\n\treturn current.BasePath\n}\n\n\nfunc GetDestPath() string {\n\treturn current.DestPath\n}\n\n\n\nfunc init() ", "output": "{\n\tcurrent.BasePath = \"./\"\n\tif len(os.Args) > 1 {\n\t\tcurrent.BasePath = os.Args[1]\n\t}\n}"}
{"input": "package state\n\nimport (\n\t\"time\"\n\n\t\"github.com/juju/errors\"\n\t\"gopkg.in/juju/names.v2\"\n\n\t\"github.com/juju/juju/core/lease\"\n)\n\n\n\n\n\n\n\n\n\ntype singularSecretary struct {\n\tuuid string\n}\n\n\nfunc (s singularSecretary) CheckLease(name string) error {\n\tif name != s.uuid {\n\t\treturn errors.New(\"expected environ UUID\")\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc (s singularSecretary) CheckDuration(duration time.Duration) error {\n\tif duration <= 0 {\n\t\treturn errors.NewNotValid(nil, \"non-positive\")\n\t}\n\treturn nil\n}\n\n\n\nfunc (st *State) SingularClaimer() lease.Claimer {\n\treturn st.workers.singularManager()\n}\n\nfunc (s singularSecretary) CheckHolder(name string) error ", "output": "{\n\tif _, err := names.ParseMachineTag(name); err != nil {\n\t\treturn errors.New(\"expected machine tag\")\n\t}\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\telastigo \"github.com/mattbaird/elastigo/lib\"\n\t\"log\"\n)\n\ntype ElasticSettings struct {\n\tHost string\n\tPort int\n}\n\n\n\nfunc DeleteIndex(index string, settings ElasticSettings) {\n\tc := Connection(settings)\n\tc.DeleteIndex(index)\n}\n\nfunc load(json string, settings ElasticSettings) {\n\tDeleteIndex(\"census\", settings)\n\tc := elastigo.NewConn()\n\tc.Domain = settings.Host\n\n\t_, err := c.Index(\"census\", \"addrfeat\", \"\", nil, json)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n}\n\nfunc Connection(settings ElasticSettings) *elastigo.Conn ", "output": "{\n\tc := elastigo.NewConn()\n\tc.Domain = settings.Host\n\tc.Port = string(settings.Port)\n\treturn c\n}"}
{"input": "package main\n\nimport (\n\t\"time\"\n)\n\n\ntype TimeTeller interface {\n\tNow() time.Time\n\tAfter(time.Duration) <-chan time.Time\n}\n\ntype RealTime struct{}\n\nfunc (r *RealTime) Now() time.Time {\n\treturn time.Now()\n}\n\n\n\nfunc (r *RealTime) After(d time.Duration) <-chan time.Time ", "output": "{\n\treturn time.After(d)\n}"}
{"input": "package operations\n\n\n\n\nimport (\n\t\"net/http\"\n\n\tmiddleware \"github.com/go-openapi/runtime/middleware\"\n)\n\n\ntype DecommissionSiteHandlerFunc func(DecommissionSiteParams) middleware.Responder\n\n\nfunc (fn DecommissionSiteHandlerFunc) Handle(params DecommissionSiteParams) middleware.Responder {\n\treturn fn(params)\n}\n\n\ntype DecommissionSiteHandler interface {\n\tHandle(DecommissionSiteParams) middleware.Responder\n}\n\n\nfunc NewDecommissionSite(ctx *middleware.Context, handler DecommissionSiteHandler) *DecommissionSite {\n\treturn &DecommissionSite{Context: ctx, Handler: handler}\n}\n\n\ntype DecommissionSite struct {\n\tContext *middleware.Context\n\tHandler DecommissionSiteHandler\n}\n\n\n\nfunc (o *DecommissionSite) ServeHTTP(rw http.ResponseWriter, r *http.Request) ", "output": "{\n\troute, rCtx, _ := o.Context.RouteInfo(r)\n\tif rCtx != nil {\n\t\tr = rCtx\n\t}\n\tvar Params = NewDecommissionSiteParams()\n\n\tif err := o.Context.BindValidRequest(r, route, &Params); err != nil { \n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\n\tres := o.Handler.Handle(Params) \n\n\to.Context.Respond(rw, r, route.Produces, route, res)\n\n}"}
{"input": "package common\n\nimport (\n\t\"github.com/pkg/errors\"\n)\n\ntype Backend interface {\n\tRenderAllScrolls() (numScrolls int, errors []error)\n\n\tRenderScrollsByID(ids []ID) (renderedScrollIDs []ID, errors []error)\n\n\tParse(id, doc string) Scroll\n}\n\n\n\n\n\n\n\nfunc UpdateIndex(b Backend) error {\n\treturn updateIndex(b)\n}\n\nfunc ComputeStatistics() (Statistics, error) {\n\treturn computeStatistics()\n}\n\nfunc LoadScrolls(b Backend, ids []ID) ([]Scroll, error) {\n\tresult := make([]Scroll, len(ids))\n\tfor i, id := range ids {\n\t\tscroll, err := loadAndParseScrollContentByID(b, id)\n\t\tif err != nil {\n\t\t\treturn result, err\n\t\t}\n\t\tresult[i] = scroll\n\t}\n\treturn result, nil\n}\n\nfunc FindMatchingScrolls(query string) ([]ID, int, error) ", "output": "{\n\tindex, err := OpenExistingIndex()\n\tif err != nil {\n\t\treturn []ID{}, 0, err\n\t}\n\tdefer index.Close()\n\n\tnewQuery := translatePlusMinusTildePrefixes(query)\n\tsearchResults, err := performQuery(index, newQuery)\n\ttotalMatches := int(searchResults.Total)\n\tif err != nil {\n\t\tif err.Error() == \"syntax error\" {\n\t\t\terr = errors.Wrapf(err, \"invalid query string: '%v'\", newQuery)\n\t\t} else {\n\t\t\terr = errors.Wrap(err, \"perform query\")\n\t\t}\n\t\treturn []ID{}, totalMatches, err\n\t}\n\n\tvar ids []ID\n\tfor _, match := range searchResults.Hits {\n\t\tid := ID(match.ID)\n\t\tids = append(ids, id)\n\t}\n\n\treturn ids, totalMatches, nil\n}"}
{"input": "package isbn\n\nimport (\n\t\"errors\"\n\t\"math\"\n\t\"strconv\"\n\t\"unicode\"\n)\n\nfunc IsValidISBN(isbn string) bool {\n\n\tisbn = dropHyphen(isbn)\n\n\tary, err := strToSlice(isbn)\n\tif len(ary) != 10 || err != nil {\n\t\treturn false\n\t}\n\n\treturn calcCheckDigit(ary)\n}\n\nfunc dropHyphen(isbn string) string {\n\tvar result string\n\tfor _, char := range isbn {\n\t\tif char == '-' {\n\t\t\tcontinue\n\t\t}\n\t\tresult += string(char)\n\t}\n\treturn result\n}\n\nfunc strToSlice(isbn string) (result []int, err error) {\n\n\tfor pos, char := range isbn {\n\t\tif unicode.IsLetter(char) && (char != 'X' || pos != 9) {\n\t\t\terr = errors.New(\"invalid character\")\n\t\t\treturn\n\t\t} else if char == 'X' {\n\t\t\tresult = append(result, 10)\n\t\t} else {\n\t\t\ti, _ := strconv.Atoi(string(char))\n\t\t\tresult = append(result, i)\n\t\t}\n\t}\n\treturn\n}\n\n\n\nfunc calcCheckDigit(isbn []int) bool ", "output": "{\n\tvar pool int\n\tfor idx, value := range isbn {\n\t\tpool += int(math.Abs(float64(idx)-10)) * value\n\t}\n\tresult := pool % 11\n\n\treturn result == 0\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n)\n\nvar initialString string\nvar finalString string\nvar stringLength int\n\n\n\nfunc capitalize(letterChannel chan string, currentLetter string, wg *sync.WaitGroup) {\n\tthisLetter := strings.ToUpper(currentLetter)\n\twg.Done()\n\tletterChannel <- thisLetter\n}\n\nfunc main() {\n\truntime.GOMAXPROCS(2)\n\tvar wg sync.WaitGroup\n\n\tinitialString = \"Awesome Go Audio and Music Authentication and OAuth Command Line Configuration Continuous Integration\tCSS Preprocessors Data Structures Database \tDatabase Drivers Date and Time\"\n\tinitialBytes := []byte(initialString)\n\tvar letterChannel chan string = make(chan string)\n\tstringLength = len(initialBytes)\n\tfor i := 0; i < stringLength; i++ {\n\t\twg.Add(2)\n\t\tgo capitalize(letterChannel, string(initialBytes[i]), &wg)\n\t\tgo addToFinalStack(letterChannel, &wg)\n\t\twg.Wait()\n\t}\n\tfmt.Println(initialString)\n\tfmt.Println(finalString)\n}\n\nfunc addToFinalStack(letterChannel chan string, wg *sync.WaitGroup) ", "output": "{\n\tletter := <-letterChannel\n\tfinalString += letter\n\twg.Done()\n}"}
{"input": "package k1\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os/exec\"\n\t\"strings\"\n\n\t\"github.com/songgao/water\"\n)\n\nfunc execCommand(name, sargs string) error {\n\targs := strings.Split(sargs, \" \")\n\tcmd := exec.Command(name, args...)\n\tlogger.Infof(\"exec command: %s %s\", name, sargs)\n\treturn cmd.Run()\n}\n\n\n\nfunc addRoute(tun string, subnet *net.IPNet) error {\n\tip := subnet.IP\n\tmaskIP := net.IP(subnet.Mask)\n\tsargs := fmt.Sprintf(\"-n add -net %s -netmask %s -interface %s\", ip.String(), maskIP.String(), tun)\n\treturn execCommand(\"route\", sargs)\n}\n\nfunc createTun(ip net.IP, mask net.IPMask) (*water.Interface, error) {\n\tifce, err := water.New(water.Config{\n\t\tDeviceType: water.TUN,\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlogger.Infof(\"create %s\", ifce.Name())\n\n\tipNet := &net.IPNet{\n\t\tIP:   ip,\n\t\tMask: mask,\n\t}\n\n\tif err := initTun(ifce.Name(), ipNet, MTU); err != nil {\n\t\treturn nil, err\n\t}\n\treturn ifce, nil\n}\n\n\nfunc fixTunIP(ip net.IP) net.IP {\n\treturn net.IPv4zero\n}\n\nfunc initTun(tun string, ipNet *net.IPNet, mtu int) error ", "output": "{\n\tip := ipNet.IP\n\tmaskIP := net.IP(ipNet.Mask)\n\tsargs := fmt.Sprintf(\"%s %s %s mtu %d netmask %s up\", tun, ip.String(), ip.String(), mtu, maskIP.String())\n\tif err := execCommand(\"ifconfig\", sargs); err != nil {\n\t\treturn err\n\t}\n\treturn addRoute(tun, ipNet)\n}"}
{"input": "package conversions\n\nimport \"jvmgo/ch11/instructions/base\"\nimport \"jvmgo/ch11/rtda\"\n\n\ntype L2D struct{ base.NoOperandsInstruction }\n\nfunc (self *L2D) Execute(frame *rtda.Frame) {\n\tstack := frame.OperandStack()\n\tl := stack.PopLong()\n\td := float64(l)\n\tstack.PushDouble(d)\n}\n\n\ntype L2F struct{ base.NoOperandsInstruction }\n\n\n\n\ntype L2I struct{ base.NoOperandsInstruction }\n\nfunc (self *L2I) Execute(frame *rtda.Frame) {\n\tstack := frame.OperandStack()\n\tl := stack.PopLong()\n\ti := int32(l)\n\tstack.PushInt(i)\n}\n\nfunc (self *L2F) Execute(frame *rtda.Frame) ", "output": "{\n\tstack := frame.OperandStack()\n\tl := stack.PopLong()\n\tf := float32(l)\n\tstack.PushFloat(f)\n}"}
{"input": "package fake\n\nimport (\n\tv1 \"github.com/openshift/origin/pkg/authorization/client/clientset_generated/release_v1_4/typed/core/v1\"\n\trestclient \"k8s.io/kubernetes/pkg/client/restclient\"\n\tcore \"k8s.io/kubernetes/pkg/client/testing/core\"\n)\n\ntype FakeCore struct {\n\t*core.Fake\n}\n\n\n\n\n\nfunc (c *FakeCore) GetRESTClient() *restclient.RESTClient {\n\treturn nil\n}\n\nfunc (c *FakeCore) Policies(namespace string) v1.PolicyInterface ", "output": "{\n\treturn &FakePolicies{c, namespace}\n}"}
{"input": "package upgrade\n\n\n\nfunc upgradeToURL(binary, url string) error {\n\treturn ErrUpgradeUnsupported\n}\n\nfunc LatestRelease(prerelease bool) (Release, error) {\n\treturn Release{}, ErrUpgradeUnsupported\n}\n\nfunc upgradeTo(binary string, rel Release) error ", "output": "{\n\treturn ErrUpgradeUnsupported\n}"}
{"input": "package cmd\n\n\nimport (\n\t\"fmt\"\n\t\"github.com/madhusudhancs/redis/cache\"\n\t\"strings\"\n)\n\nvar (\n\tcommands map[string]RunFunc\n)\n\nfunc init() {\n\tcommands = make(map[string]RunFunc)\n}\n\n\ntype Command struct {\n\tName    string\n\tOptions []string\n}\n\n\n\n\ntype RunFunc func(options []string, cache *cache.Cache) ([]byte, bool)\n\n\nfunc Register(cmdName string, runFunc RunFunc) error {\n\tif _, ok := commands[cmdName]; ok {\n\t\treturn fmt.Errorf(\"command with name %s already registered\", cmdName)\n\t}\n\n\tcommands[cmdName] = runFunc\n\treturn nil\n}\n\n\nfunc ExecuteCmd(cmd Command, cache *cache.Cache) ([]byte, bool) {\n\trunFunc, ok := commands[cmd.Name]\n\tif !ok {\n\t\treturn GetErrMsg(fmt.Sprintf(\"ERR unknown command '%s'\", cmd.Name)), false\n\t}\n\n\treturn runFunc(cmd.Options, cache)\n}\n\nfunc NewCommand(req string) (Command, error) ", "output": "{\n\tfields := strings.Fields(req)\n\n\tif len(fields) == 0 {\n\t\treturn Command{}, fmt.Errorf(\"Invalid command\")\n\t}\n\n\tcommand := Command{}\n\tcommand.Name = strings.ToUpper(fields[0])\n\tcommand.Options = fields[1:]\n\n\tfor i, option := range command.Options {\n\t\tcommand.Options[i] = strings.Replace(option, `\"`, \"\", -1)\n\t}\n\n\treturn command, nil\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/wrouesnel/tailio\"\n\t\"os\"\n)\n\nfunc args2config() (tailio.Config, int64) {\n\tconfig := tailio.Config{Follow: true}\n\tn := int64(0)\n\tmaxlinesize := int(0)\n\tflag.Int64Var(&n, \"n\", 0, \"tail from the last Nth location\")\n\tflag.IntVar(&maxlinesize, \"max\", 0, \"max line size\")\n\tflag.BoolVar(&config.Follow, \"f\", false, \"wait for additional data to be appended to the file\")\n\tflag.BoolVar(&config.ReOpen, \"F\", false, \"follow, and track file rename/rotation\")\n\tflag.BoolVar(&config.Poll, \"p\", false, \"use polling, instead of inotify\")\n\tflag.Parse()\n\tif config.ReOpen {\n\t\tconfig.Follow = true\n\t}\n\tconfig.MaxLineSize = maxlinesize\n\treturn config, n\n}\n\nfunc main() {\n\tconfig, n := args2config()\n\tif flag.NFlag() < 1 {\n\t\tfmt.Println(\"need one or more files as arguments\")\n\t\tos.Exit(1)\n\t}\n\n\tif n != 0 {\n\t\tconfig.Location = &tailio.SeekInfo{-n, os.SEEK_END}\n\t}\n\n\tdone := make(chan bool)\n\tfor _, filename := range flag.Args() {\n\t\tgo tailFile(filename, config, done)\n\t}\n\n\tfor _, _ = range flag.Args() {\n\t\t<-done\n\t}\n}\n\n\n\nfunc tailFile(filename string, config tailio.Config, done chan bool) ", "output": "{\n\tdefer func() { done <- true }()\n\tt, err := tailio.TailFile(filename, config)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfor line := range t.Lines {\n\t\tfmt.Println(line.Text)\n\t}\n\terr = t.Wait()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}"}
{"input": "package dep\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"github.com/go-kit/kit/endpoint\"\n\n\t\"github.com/micromdm/micromdm/dep\"\n\t\"github.com/micromdm/micromdm/pkg/httputil\"\n)\n\nfunc (svc *DEPService) DefineProfile(ctx context.Context, p *dep.Profile) (*dep.ProfileResponse, error) {\n\tif svc.client == nil {\n\t\treturn nil, errors.New(\"DEP not configured yet. add a DEP token to enable DEP\")\n\t}\n\treturn svc.client.DefineProfile(p)\n}\n\ntype defineProfileRequest struct{ *dep.Profile }\ntype defineProfileResponse struct {\n\t*dep.ProfileResponse\n\tErr error `json:\"err,omitempty\"`\n}\n\nfunc (r defineProfileResponse) Failed() error { return r.Err }\n\nfunc decodeDefineProfileRequest(ctx context.Context, r *http.Request) (interface{}, error) {\n\tvar req defineProfileRequest\n\terr := httputil.DecodeJSONRequest(r, &req)\n\treturn req, err\n}\n\nfunc decodeDefineProfileResponse(_ context.Context, r *http.Response) (interface{}, error) {\n\tvar resp defineProfileResponse\n\terr := httputil.DecodeJSONResponse(r, &resp)\n\treturn resp, err\n}\n\n\n\nfunc (e Endpoints) DefineProfile(ctx context.Context, p *dep.Profile) (*dep.ProfileResponse, error) {\n\trequest := defineProfileRequest{Profile: p}\n\tresp, err := e.DefineProfileEndpoint(ctx, request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresponse := resp.(defineProfileResponse)\n\treturn response.ProfileResponse, response.Err\n}\n\nfunc MakeDefineProfileEndpoint(svc Service) endpoint.Endpoint ", "output": "{\n\treturn func(ctx context.Context, request interface{}) (response interface{}, err error) {\n\t\treq := request.(defineProfileRequest)\n\t\tresp, err := svc.DefineProfile(ctx, req.Profile)\n\t\treturn &defineProfileResponse{\n\t\t\tProfileResponse: resp,\n\t\t\tErr:             err,\n\t\t}, nil\n\t}\n}"}
{"input": "package policy\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"istio.io/istio/pkg/test/framework/label\"\n\n\t\"istio.io/istio/pkg/test/framework\"\n\t\"istio.io/istio/pkg/test/framework/components/bookinfo\"\n\tutil \"istio.io/istio/tests/integration/mixer\"\n)\n\n\n\nfunc TestWhiteListing(t *testing.T) ", "output": "{\n\tframework.NewTest(t).Label(label.Flaky).Run(func(ctx framework.TestContext) {\n\t\tutil.SendTrafficAndWaitForExpectedStatus(ing, t, \"Sending traffic...\", \"\", 2, http.StatusOK)\n\n\t\tg.ApplyConfigOrFail(\n\t\t\tt,\n\t\t\tbookinfoNs,\n\t\t\tbookinfo.PolicyDenyIPRule.LoadWithNamespaceOrFail(t, bookinfoNs.Name()))\n\t\tdefer g.DeleteConfigOrFail(\n\t\t\tt,\n\t\t\tbookinfoNs,\n\t\t\tbookinfo.PolicyDenyIPRule.LoadWithNamespaceOrFail(t, bookinfoNs.Name()))\n\t\tutil.AllowRuleSync(t)\n\n\t\tutil.SendTrafficAndWaitForExpectedStatus(ing, t, \"Sending traffic...\", \"\", 30, http.StatusForbidden)\n\t})\n}"}
{"input": "package network\n\nimport (\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/docker/docker/cli\"\n\t\"github.com/docker/docker/cli/command\"\n\t\"github.com/docker/docker/cli/command/inspect\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype inspectOptions struct {\n\tformat string\n\tnames  []string\n}\n\n\n\nfunc runInspect(dockerCli *command.DockerCli, opts inspectOptions) error {\n\tclient := dockerCli.Client()\n\n\tctx := context.Background()\n\n\tgetNetFunc := func(name string) (interface{}, []byte, error) {\n\t\treturn client.NetworkInspectWithRaw(ctx, name)\n\t}\n\n\treturn inspect.Inspect(dockerCli.Out(), opts.names, opts.format, getNetFunc)\n}\n\nfunc newInspectCommand(dockerCli *command.DockerCli) *cobra.Command ", "output": "{\n\tvar opts inspectOptions\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"inspect [OPTIONS] NETWORK [NETWORK...]\",\n\t\tShort: \"Display detailed information on one or more networks\",\n\t\tArgs:  cli.RequiresMinArgs(1),\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\topts.names = args\n\t\t\treturn runInspect(dockerCli, opts)\n\t\t},\n\t}\n\n\tcmd.Flags().StringVarP(&opts.format, \"format\", \"f\", \"\", \"Format the output using the given Go template\")\n\n\treturn cmd\n}"}
{"input": "package metadata\n\nimport \"testing\"\n\nfunc TestGetLanguage(t *testing.T) {\n\tfor _, l := range AllowedLanguages {\n\t\tif g, ok := GetLanguage(l.Name); !ok {\n\t\t\tt.Errorf(\"language defined but not found: %s\", l.Name)\n\t\t} else if g != l {\n\t\t\tt.Errorf(\"found wrong language, expected %v, found %v\", l, g)\n\t\t}\n\t}\n}\n\nfunc TestNoLanguage(t *testing.T) {\n\tlangs := [...]string{\"foobar language\"}\n\tfor _, l := range langs {\n\t\tif _, exist := GetLanguage(l); exist {\n\t\t\tt.Errorf(\"language found but should not exist: %s\", l)\n\t\t}\n\t}\n}\n\n\n\nfunc TestGetLanguageFromExt(t *testing.T) {\n\tfor _, l := range AllowedLanguages {\n\t\tif g, ok := GetLanguageFromExt(l.Ext); !ok {\n\t\t\tt.Errorf(\"cannot look up extension: %s\", l.Ext)\n\t\t} else if l != g {\n\t\t\tt.Errorf(\"language different from definition: %s\", l.Name)\n\t\t}\n\t}\n}\n\nfunc TestNoLanguageFromExt(t *testing.T) {\n\tlangs := [...]string{\"foo\", \"bar\"}\n\tfor _, l := range langs {\n\t\tif _, exist := GetLanguageFromExt(l); exist {\n\t\t\tt.Errorf(\"language found but should not exist: %s\", l)\n\t\t}\n\t}\n}\n\nfunc TestRequiredLanguages(t *testing.T) ", "output": "{\n\tfor _, l := range RequiredLanguages {\n\t\tif !l.Required {\n\t\t\tt.Errorf(\"language is required but not marked required: %s\", l.Name)\n\t\t}\n\t\tif g, ok := GetLanguage(l.Name); !ok {\n\t\t\tt.Errorf(\"language required but not defined: %s\", l.Name)\n\t\t} else if l != g {\n\t\t\tt.Errorf(\"required language different from the definition: %s\", l.Name)\n\t\t}\n\t}\n\n\tfor _, l := range AllowedLanguages {\n\t\tfound := false\n\t\tfor _, r := range RequiredLanguages {\n\t\t\tif l.Name == r.Name {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif l.Required && !found {\n\t\t\tt.Errorf(\"language marked required but not in RequiredLanguages: %s\", l.Name)\n\t\t}\n\t}\n}"}
{"input": "package topology\n\nimport (\n\t\"github.com/skydive-project/skydive/graffiti/getter\"\n\t\"strings\"\n)\n\nfunc (obj *NextHop) GetFieldBool(key string) (bool, error) {\n\treturn false, getter.ErrFieldNotFound\n}\n\nfunc (obj *NextHop) GetFieldInt64(key string) (int64, error) {\n\tswitch key {\n\tcase \"Priority\":\n\t\treturn int64(obj.Priority), nil\n\tcase \"IfIndex\":\n\t\treturn int64(obj.IfIndex), nil\n\t}\n\treturn 0, getter.ErrFieldNotFound\n}\n\nfunc (obj *NextHop) GetFieldString(key string) (string, error) {\n\tswitch key {\n\tcase \"IP\":\n\t\treturn obj.IP.String(), nil\n\tcase \"MAC\":\n\t\treturn string(obj.MAC), nil\n\t}\n\treturn \"\", getter.ErrFieldNotFound\n}\n\n\n\nfunc (obj *NextHop) MatchBool(key string, predicate getter.BoolPredicate) bool {\n\treturn false\n}\n\nfunc (obj *NextHop) MatchInt64(key string, predicate getter.Int64Predicate) bool {\n\tif b, err := obj.GetFieldInt64(key); err == nil {\n\t\treturn predicate(b)\n\t}\n\treturn false\n}\n\nfunc (obj *NextHop) MatchString(key string, predicate getter.StringPredicate) bool {\n\tif b, err := obj.GetFieldString(key); err == nil {\n\t\treturn predicate(b)\n\t}\n\treturn false\n}\n\nfunc (obj *NextHop) GetField(key string) (interface{}, error) {\n\tif s, err := obj.GetFieldString(key); err == nil {\n\t\treturn s, nil\n\t}\n\n\tif i, err := obj.GetFieldInt64(key); err == nil {\n\t\treturn i, nil\n\t}\n\treturn nil, getter.ErrFieldNotFound\n}\n\nfunc init() {\n\tstrings.Index(\"\", \".\")\n}\n\nfunc (obj *NextHop) GetFieldKeys() []string ", "output": "{\n\treturn []string{\n\t\t\"Priority\",\n\t\t\"IP\",\n\t\t\"MAC\",\n\t\t\"IfIndex\",\n\t}\n}"}
{"input": "package inmem\n\nimport (\n\t\"github.com/blevesearch/bleve/index/store\"\n)\n\ntype Reader struct {\n\tstore *Store\n}\n\nfunc newReader(store *Store) (*Reader, error) {\n\treturn &Reader{\n\t\tstore: store,\n\t}, nil\n}\n\nfunc (r *Reader) BytesSafeAfterClose() bool {\n\treturn false\n}\n\nfunc (r *Reader) Get(key []byte) ([]byte, error) {\n\treturn r.store.get(key)\n}\n\nfunc (r *Reader) Iterator(key []byte) store.KVIterator {\n\treturn r.store.iterator(key)\n}\n\n\n\nfunc (r *Reader) Close() error ", "output": "{\n\treturn nil\n}"}
{"input": "package xml\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/xml\"\n\t\"github.com/graniticio/granitic/v2/ws\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestMarshallAndWrite(t *testing.T) {\n\n\tmw := new(MarshalingWriter)\n\trw := new(resWriter)\n\n\tmw.MarshalAndWrite(target{A: 1}, rw)\n\n\tif rw.sw.String() != \"<content><a>1</a></content>\" {\n\t\tt.Fail()\n\t}\n\n}\n\n\n\ntype target struct {\n\tXMLName xml.Name `xml:\"content\"`\n\tA       int64    `xml:\"a\"`\n}\n\ntype resWriter struct {\n\tsw bytes.Buffer\n}\n\nfunc (rw *resWriter) Header() http.Header {\n\treturn nil\n}\n\nfunc (rw *resWriter) Write(b []byte) (int, error) {\n\treturn rw.sw.Write(b)\n}\n\nfunc (rw *resWriter) WriteHeader(statusCode int) {\n\n}\n\nfunc TestUnmarshalling(t *testing.T) ", "output": "{\n\n\tr := new(http.Request)\n\tsr := strings.NewReader(\"<content><a>1</a></content>\")\n\n\trc := ioutil.NopCloser(sr)\n\n\tr.Body = rc\n\n\tum := new(Unmarshaller)\n\n\twsr := new(ws.Request)\n\twsr.RequestBody = new(target)\n\n\tum.Unmarshall(context.Background(), r, wsr)\n\n\ttar := wsr.RequestBody.(*target)\n\n\tif tar.A != 1 {\n\t\tt.Fail()\n\t}\n\n}"}
{"input": "package api\n\nimport (\n\t\"net/http\"\n\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"github.com/labstack/echo\"\n)\n\n\ntype Error struct {\n\tMessage string `json:\"message\"`\n}\n\n\nfunc OK(c echo.Context, payload interface{}) error {\n\treturn c.JSON(http.StatusOK, payload)\n}\n\n\nfunc Created(c echo.Context, payload interface{}) error {\n\treturn c.JSON(http.StatusCreated, payload)\n}\n\n\n\n\n\nfunc BadRequest(c echo.Context, msg string) error {\n\treturn c.JSON(http.StatusBadRequest, Error{msg})\n}\n\n\nfunc NotFound(c echo.Context) error {\n\treturn c.JSON(http.StatusNotFound, Error{\"Resource not found\"})\n}\n\n\nfunc Conflict(c echo.Context, msg string) error {\n\treturn c.JSON(http.StatusConflict, Error{msg})\n}\n\n\nfunc Invalid(c echo.Context, msg string) error {\n\treturn c.JSON(422, Error{msg})\n}\n\n\n\nfunc InternalServerError(c echo.Context, err error) error {\n\tlog.WithFields(log.Fields{\n\t\t\"request_id\": RequestID(c),\n\t}).Error(err)\n\n\treturn c.JSON(http.StatusInternalServerError, Error{\"Oops! Something went wrong\"})\n}\n\nfunc NoContent(c echo.Context) error ", "output": "{\n\treturn c.NoContent(http.StatusNoContent)\n}"}
{"input": "package actor\n\nimport (\n\t\"github.com/AsynkronIT/protoactor-go/eventstream\"\n\t\"github.com/AsynkronIT/protoactor-go/log\"\n)\n\ntype deadLetterProcess struct{}\n\nvar (\n\tdeadLetter           Process = &deadLetterProcess{}\n\tdeadLetterSubscriber *eventstream.Subscription\n)\n\nfunc init() {\n\tdeadLetterSubscriber = eventstream.Subscribe(func(msg interface{}) {\n\t\tif deadLetter, ok := msg.(*DeadLetterEvent); ok {\n\t\t\tplog.Debug(\"[DeadLetter]\", log.Stringer(\"pid\", deadLetter.PID), log.Message(deadLetter.Message), log.Stringer(\"sender\", deadLetter.Sender))\n\t\t}\n\t})\n\n\teventstream.Subscribe(func(msg interface{}) {\n\t\tif deadLetter, ok := msg.(*DeadLetterEvent); ok {\n\t\t\tif m, ok := deadLetter.Message.(*Watch); ok {\n\t\t\t\tm.Watcher.sendSystemMessage(&Terminated{AddressTerminated: false, Who: deadLetter.PID})\n\t\t\t}\n\t\t}\n\t})\n}\n\n\ntype DeadLetterEvent struct {\n\tPID     *PID        \n\tMessage interface{} \n\tSender  *PID        \n}\n\n\n\nfunc (*deadLetterProcess) SendSystemMessage(pid *PID, message interface{}) {\n\teventstream.Publish(&DeadLetterEvent{\n\t\tPID:     pid,\n\t\tMessage: message,\n\t})\n}\n\nfunc (ref *deadLetterProcess) Stop(pid *PID) {\n\tref.SendSystemMessage(pid, stopMessage)\n}\n\nfunc (*deadLetterProcess) SendUserMessage(pid *PID, message interface{}) ", "output": "{\n\tmsg, sender := UnwrapEnvelope(message)\n\teventstream.Publish(&DeadLetterEvent{\n\t\tPID:     pid,\n\t\tMessage: msg,\n\t\tSender:  sender,\n\t})\n}"}
{"input": "package http\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nconst (\n\tHTTP_BODY_MAX_LENGTH = 1048576\n\tStatusUnprocessableEntity = 422\n)\n\n\n\nfunc JsonWrite(w http.ResponseWriter, status int, content interface{}) {\n\tHttpHeader_ContentType_Json().SetWriter(w.Header())\n\tw.WriteHeader(status)\n\tif content != nil {\n\t\tjson.NewEncoder(w).Encode(content)\n\t}\n}\n\n\n\n\n\nfunc JsonRead(body io.ReadCloser, obj interface{}, w http.ResponseWriter) bool ", "output": "{\n\tcontent, err := ioutil.ReadAll(io.LimitReader(body, HTTP_BODY_MAX_LENGTH))\n\tif err != nil {\n\t\tjerr := NewJsonErrorFromError(http.StatusInternalServerError, err)\n\t\tJsonWrite(w, jerr.Status, jerr)\n\t\treturn false\n\t}\n\n\tif err := body.Close(); err != nil {\n\t\tjerr := NewJsonErrorFromError(http.StatusInternalServerError, err)\n\t\tJsonWrite(w, jerr.Status, jerr)\n\t\treturn false\n\t}\n\n\tif err := json.Unmarshal(content, obj); err != nil {\n\t\tjerr := NewJsonErrorFromError(StatusUnprocessableEntity, err)\n\t\tJsonWrite(w, jerr.Status, jerr)\n\t\treturn false\n\t}\n\n\treturn true\n}"}
{"input": "package db_models\n\nimport \"time\"\nimport \"github.com/go-xorm/xorm\"\n\ntype UriFilteringTelemetryPreMitigation struct {\n\tId             int64     `xorm:\"'id' pk autoincr\"`\n\tCustomerId     int       `xorm:\"'customer_id' not null\"`\n\tCuid           string    `xorm:\"'cuid' not null\"`\n\tCdid           string    `xorm:\"'cdid'\"`\n\tTmid           int       `xorm:\"'tmid' not null\"`\n\tTargetPrefix   string    `xorm:\"target_prefix\"`\n\tLowerPort      int       `xorm:\"lower_port\"`\n\tUpperPort      int       `xorm:\"upper_port\"`\n\tTargetProtocol int       `xorm:\"target_protocol\"`\n\tTargetFqdn     string    `xorm:\"target_fqdn\"`\n\tAliasName      string    `xorm:\"alias_name\"`\n\tCreated        time.Time `xorm:\"created\"`\n\tUpdated        time.Time `xorm:\"updated\"`\n}\n\n\n\n\n\nfunc GetUriFilteringTelemetryPreMitigationByCuid(engine *xorm.Engine, customerId int, cuid string) ([]UriFilteringTelemetryPreMitigation, error) {\n\ttelePreMitigation := []UriFilteringTelemetryPreMitigation{}\n\terr := engine.Where(\"customer_id = ? AND cuid = ?\", customerId, cuid).Find(&telePreMitigation)\n\treturn telePreMitigation, err\n}\n\n\nfunc DeleteUriFilteringTelemetryPreMitigationByTmid(session *xorm.Session, tmid int) (err error) {\n\t_, err = session.Delete(&UriFilteringTelemetryPreMitigation{Tmid: tmid})\n\treturn\n}\n\nfunc GetUriFilteringTelemetryPreMitigationByTmid(engine *xorm.Engine, customerId int, cuid string, tmid int) ([]UriFilteringTelemetryPreMitigation, error) ", "output": "{\n\ttelePreMitigation := []UriFilteringTelemetryPreMitigation{}\n\terr := engine.Where(\"customer_id = ? AND cuid = ? AND tmid = ?\", customerId, cuid, tmid).Find(&telePreMitigation)\n\treturn telePreMitigation, err\n}"}
{"input": "package antlr\n\nimport \"fmt\"\n\ntype TraceListener struct {\n\tparser *BaseParser\n}\n\nfunc NewTraceListener(parser *BaseParser) *TraceListener {\n\ttl := new(TraceListener)\n\ttl.parser = parser\n\treturn tl\n}\n\nfunc (t *TraceListener) VisitErrorNode(_ ErrorNode) {\n}\n\n\n\nfunc (t *TraceListener) VisitTerminal(node TerminalNode) {\n\tfmt.Println(\"consume \" + fmt.Sprint(node.GetSymbol()) + \" rule \" + t.parser.GetRuleNames()[t.parser.ctx.GetRuleIndex()])\n}\n\nfunc (t *TraceListener) ExitEveryRule(ctx ParserRuleContext) {\n\tfmt.Println(\"exit    \" + t.parser.GetRuleNames()[ctx.GetRuleIndex()] + \", LT(1)=\" + t.parser.input.LT(1).GetText())\n}\n\nfunc (t *TraceListener) EnterEveryRule(ctx ParserRuleContext) ", "output": "{\n\tfmt.Println(\"enter   \" + t.parser.GetRuleNames()[ctx.GetRuleIndex()] + \", LT(1)=\" + t.parser.input.LT(1).GetText())\n}"}
{"input": "package gorand\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"io\"\n)\n\n\ntype UUID [16]byte\n\n\n\n\n\n\nfunc UnmarshalUUID(s string) (uuid UUID, err error) {\n\tif len(s) != 36 {\n\t\terr = errors.New(\"Invalid UUID length\")\n\t\treturn\n\t}\n\tif s[8:9] != \"-\" || s[13:14] != \"-\" || s[18:19] != \"-\" || s[23:24] != \"-\" {\n\t\terr = errors.New(\"Invalid UUID format\")\n\t\treturn\n\t}\n\n\tb, err := hex.DecodeString(s[0:8] + s[9:13] + s[14:18] + s[19:23] + s[24:])\n\tif err != nil {\n\t\treturn\n\t}\n\n\t_, err = io.ReadFull(bytes.NewBuffer(b), uuid[:])\n\treturn\n}\n\n\n\nfunc MarshalUUID(uuid UUID) (s string, err error) {\n\tvar b [16]byte\n\n\t_, err = io.ReadFull(bytes.NewBuffer(uuid[:]), b[:])\n\tif err != nil {\n\t\treturn\n\t}\n\n\tbin := hex.EncodeToString(b[:])\n\ts = bin[0:8] + \"-\" + bin[8:12] + \"-\" + bin[12:16] + \"-\" + bin[16:20] + \"-\" + bin[20:]\n\n\treturn\n}\n\nfunc UUIDv4() (uuid UUID, err error) ", "output": "{\n\tb, err := GetBytes(16)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t_, err = io.ReadFull(bytes.NewBuffer(b), uuid[:])\n\tif err != nil {\n\t\treturn\n\t}\n\n\tuuid[6] = (uuid[6] & 0x0f) | 0x40 \n\tuuid[8] = (uuid[8] & 0x3f) | 0x80 \n\n\treturn\n}"}
{"input": "package upgrade\n\nfunc upgradeTo(binary string, rel Release) error {\n\treturn ErrUpgradeUnsupported\n}\n\nfunc upgradeToURL(binary, url string) error {\n\treturn ErrUpgradeUnsupported\n}\n\n\n\nfunc LatestRelease(prerelease bool) (Release, error) ", "output": "{\n\treturn Release{}, ErrUpgradeUnsupported\n}"}
{"input": "package operations\n\n\n\n\nimport (\n\t\"net/http\"\n\n\tmiddleware \"github.com/go-openapi/runtime/middleware\"\n)\n\n\ntype DecommissionSiteHandlerFunc func(DecommissionSiteParams) middleware.Responder\n\n\n\n\n\ntype DecommissionSiteHandler interface {\n\tHandle(DecommissionSiteParams) middleware.Responder\n}\n\n\nfunc NewDecommissionSite(ctx *middleware.Context, handler DecommissionSiteHandler) *DecommissionSite {\n\treturn &DecommissionSite{Context: ctx, Handler: handler}\n}\n\n\ntype DecommissionSite struct {\n\tContext *middleware.Context\n\tHandler DecommissionSiteHandler\n}\n\nfunc (o *DecommissionSite) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n\troute, rCtx, _ := o.Context.RouteInfo(r)\n\tif rCtx != nil {\n\t\tr = rCtx\n\t}\n\tvar Params = NewDecommissionSiteParams()\n\n\tif err := o.Context.BindValidRequest(r, route, &Params); err != nil { \n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\n\tres := o.Handler.Handle(Params) \n\n\to.Context.Respond(rw, r, route.Produces, route, res)\n\n}\n\nfunc (fn DecommissionSiteHandlerFunc) Handle(params DecommissionSiteParams) middleware.Responder ", "output": "{\n\treturn fn(params)\n}"}
{"input": "package simulation\n\nimport \"encoding/json\"\n\n\ntype TrainType struct {\n\tcode         string\n\tDescription  string   `json:\"description\"`\n\tEmergBraking float64  `json:\"emergBraking\"`\n\tLength       float64  `json:\"length\"`\n\tMaxSpeed     float64  `json:\"maxSpeed\"`\n\tStdAccel     float64  `json:\"stdAccel\"`\n\tStdBraking   float64  `json:\"stdBraking\"`\n\tElementsStr  []string `json:\"elements\"`\n\n\tsimulation *Simulation\n}\n\n\nfunc (tt *TrainType) ID() string {\n\treturn tt.code\n}\n\n\nfunc (tt *TrainType) setSimulation(sim *Simulation) {\n\ttt.simulation = sim\n}\n\n\nfunc (tt *TrainType) initialize(code string) {\n\ttt.code = code\n}\n\n\n\n\n\nfunc (tt *TrainType) MarshalJSON() ([]byte, error) {\n\ttype auxTT struct {\n\t\tID           string   `json:\"id\"`\n\t\tDescription  string   `json:\"description\"`\n\t\tEmergBraking float64  `json:\"emergBraking\"`\n\t\tLength       float64  `json:\"length\"`\n\t\tMaxSpeed     float64  `json:\"maxSpeed\"`\n\t\tStdAccel     float64  `json:\"stdAccel\"`\n\t\tStdBraking   float64  `json:\"stdBraking\"`\n\t\tElementsStr  []string `json:\"elements\"`\n\t}\n\tatt := auxTT{\n\t\tID:           tt.ID(),\n\t\tDescription:  tt.Description,\n\t\tEmergBraking: tt.EmergBraking,\n\t\tLength:       tt.Length,\n\t\tMaxSpeed:     tt.MaxSpeed,\n\t\tStdAccel:     tt.StdAccel,\n\t\tStdBraking:   tt.StdBraking,\n\t\tElementsStr:  tt.ElementsStr,\n\t}\n\treturn json.Marshal(att)\n}\n\nfunc (tt *TrainType) Elements() []*TrainType ", "output": "{\n\tres := make([]*TrainType, 0)\n\tfor _, code := range tt.ElementsStr {\n\t\tres = append(res, tt.simulation.TrainTypes[code])\n\t}\n\treturn res\n}"}
{"input": "package tags\n\nimport (\n\t\"github.com/karlseguin/gspec\"\n\t\"github.com/karlseguin/liquid/core\"\n\t\"testing\"\n)\n\n\n\nfunc TestCommentFactoryForNestedComment(t *testing.T) {\n\tspec := gspec.New(t)\n\tparser := newParser(\" %} ha {%comment%} {%if%} ck {%endcomment%} {%  endcomment  %}XZ \")\n\ttag, err := CommentFactory(parser, nil)\n\tspec.Expect(err).ToBeNil()\n\tspec.Expect(tag.Name()).ToEqual(\"comment\")\n\tspec.Expect(parser.Current()).ToEqual(byte('X'))\n}\n\nfunc TestCommentFactoryHandlesUnclosedComment(t *testing.T) {\n\tspec := gspec.New(t)\n\tparser := newParser(\" %} ouch \")\n\ttag, err := CommentFactory(parser, nil)\n\tspec.Expect(err).ToBeNil()\n\tspec.Expect(tag.Name()).ToEqual(\"comment\")\n\tspec.Expect(parser.HasMore()).ToEqual(false)\n}\n\nfunc newParser(s string) *core.Parser {\n\treturn core.NewParser([]byte(s))\n}\n\nfunc TestCommentFactoryForNormalComment(t *testing.T) ", "output": "{\n\tspec := gspec.New(t)\n\tparser := newParser(\" %} hack {%endcomment%}Z\")\n\ttag, err := CommentFactory(parser, nil)\n\tspec.Expect(err).ToBeNil()\n\tspec.Expect(tag.Name()).ToEqual(\"comment\")\n\tspec.Expect(parser.Current()).ToEqual(byte('Z'))\n}"}
{"input": "package amcl\n\n\n\n\nfunc (F *FP) Zero() {\n\tF.zero()\n}\n\nfunc (F *FP) One() {\n\tF.one()\n}\n\nfunc (F *FP) Mul(b *FP) {\n\tF.mul(b)\n}\n\nfunc (F *FP) Neg() {\n\tF.neg()\n}\n\nfunc (F *FP) Add(b *FP) {\n\tF.add(b)\n}\n\nfunc (F *FP) Sub(b *FP) {\n\tF.sub(b)\n}\n\nfunc (F *FP) Inverse() {\n\tF.inverse()\n}\n\nfunc (F *FP) Equals(a *FP) bool {\n\treturn F.equals(a)\n}\n\nfunc (F *FP) Pow(e *BIG) *FP {\n\treturn F.pow(e)\n}\n\nfunc (F *FP) ToString() string ", "output": "{\n\treturn F.toString()\n}"}
{"input": "package sharedaction\n\ntype AuthActor interface {\n\tIsLoggedIn() bool\n}\n\n\ntype Actor struct {\n\tConfig Config\n\tAuthActor\n}\n\n\n\n\nfunc NewActor(config Config) *Actor ", "output": "{\n\tvar authActor AuthActor = NewDefaultAuthActor(config)\n\tif config.IsCFOnK8s() {\n\t\tauthActor = NewK8sAuthActor(config)\n\t}\n\n\treturn &Actor{\n\t\tAuthActor: authActor,\n\t\tConfig:    config,\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/coscms/webx\"\n)\n\ntype MainAction struct {\n\t*webx.Action\n\n\tstart time.Time\n\n\thello webx.Mapper `webx:\"/(.*)\"`\n}\n\n\n\nfunc (c *MainAction) Before(structName, actionName string) bool {\n\tc.start = time.Now()\n\tfmt.Println(\"before\", c.start)\n\treturn true\n}\n\nfunc (c *MainAction) After(structName, actionName string, actionResult interface{}) bool {\n\tfmt.Println(\"after\", time.Now().Sub(c.start))\n\treturn true\n}\n\nfunc main() {\n\twebx.AddRouter(\"/\", &MainAction{})\n\twebx.Run(\"0.0.0.0:9999\")\n}\n\nfunc (c *MainAction) Hello(world string) bool ", "output": "{\n\tc.Write(\"hello %v\", world)\n\treturn true\n}"}
{"input": "package iso20022\n\n\ntype PartyAndAuthorisation3 struct {\n\n\tModificationCode *Modification1Code `xml:\"ModCd,omitempty\"`\n\n\tPartyOrGroup *PartyOrGroup1Choice `xml:\"PtyOrGrp\"`\n\n\tSignatureOrder *Max15PlusSignedNumericText `xml:\"SgntrOrdr,omitempty\"`\n\n\tAuthorisation *Authorisation2 `xml:\"Authstn\"`\n}\n\nfunc (p *PartyAndAuthorisation3) SetModificationCode(value string) {\n\tp.ModificationCode = (*Modification1Code)(&value)\n}\n\n\n\nfunc (p *PartyAndAuthorisation3) SetSignatureOrder(value string) {\n\tp.SignatureOrder = (*Max15PlusSignedNumericText)(&value)\n}\n\nfunc (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 {\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}\n\nfunc (p *PartyAndAuthorisation3) AddPartyOrGroup() *PartyOrGroup1Choice ", "output": "{\n\tp.PartyOrGroup = new(PartyOrGroup1Choice)\n\treturn p.PartyOrGroup\n}"}
{"input": "package syscall\n\nimport \"unsafe\"\n\nfunc setTimespec(sec, nsec int64) Timespec {\n\treturn Timespec{Sec: sec, Nsec: nsec}\n}\n\n\n\nfunc SetKevent(k *Kevent_t, fd, mode, flags int) {\n\tk.Ident = uint64(fd)\n\tk.Filter = int16(mode)\n\tk.Flags = uint16(flags)\n}\n\nfunc (iov *Iovec) SetLen(length int) {\n\tiov.Len = uint64(length)\n}\n\nfunc (msghdr *Msghdr) SetControllen(length int) {\n\tmsghdr.Controllen = uint32(length)\n}\n\nfunc (cmsg *Cmsghdr) SetLen(length int) {\n\tcmsg.Len = uint32(length)\n}\n\nfunc setTimeval(sec, usec int64) Timeval ", "output": "{\n\treturn Timeval{Sec: sec, Usec: usec}\n}"}
{"input": "package cli_test\n\nimport (\n\t\"flag\"\n\t\"testing\"\n\n\t\"github.com/tendermint/tendermint/Godeps/_workspace/src/github.com/codegangsta/cli\"\n)\n\n\n\nfunc TestCommandIgnoreFlags(t *testing.T) {\n\tapp := cli.NewApp()\n\tset := flag.NewFlagSet(\"test\", 0)\n\ttest := []string{\"blah\", \"blah\"}\n\tset.Parse(test)\n\n\tc := cli.NewContext(app, set, set)\n\n\tcommand := cli.Command{\n\t\tName:            \"test-cmd\",\n\t\tAliases:         []string{\"tc\"},\n\t\tUsage:           \"this is for testing\",\n\t\tDescription:     \"testing\",\n\t\tAction:          func(_ *cli.Context) {},\n\t\tSkipFlagParsing: true,\n\t}\n\terr := command.Run(c)\n\n\texpect(t, err, nil)\n}\n\nfunc TestCommandDoNotIgnoreFlags(t *testing.T) ", "output": "{\n\tapp := cli.NewApp()\n\tset := flag.NewFlagSet(\"test\", 0)\n\ttest := []string{\"blah\", \"blah\", \"-break\"}\n\tset.Parse(test)\n\n\tc := cli.NewContext(app, set, set)\n\n\tcommand := cli.Command{\n\t\tName:        \"test-cmd\",\n\t\tAliases:     []string{\"tc\"},\n\t\tUsage:       \"this is for testing\",\n\t\tDescription: \"testing\",\n\t\tAction:      func(_ *cli.Context) {},\n\t}\n\terr := command.Run(c)\n\n\texpect(t, err.Error(), \"flag provided but not defined: -break\")\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/russmack/cloudsigma\"\n\t\"github.com/russmack/replizer\"\n\t\"github.com/russmack/statemachiner\"\n)\n\ntype CommandBalance struct {\n\tchannels *replizer.Channels\n}\n\n\n\nfunc (m *CommandBalance) Start(channels *replizer.Channels) {\n\tm.channels = channels\n\tstateMachine := &statemachiner.StateMachine{}\n\tstateMachine.StartState = m.getBalance\n\tcargo := CommandBalance{}\n\tstateMachine.Start(cargo)\n}\n\nfunc (m *CommandBalance) getBalance(cargo interface{}) statemachiner.StateFn {\n\to := cloudsigma.NewBalance()\n\targs := o.NewList()\n\tm.channels.MessageChan <- fmt.Sprintf(\"Using username: %s\", session.Username)\n\targs.Username = session.Username\n\targs.Password = session.Password\n\targs.Location = session.Location\n\t_ = sendRequest(m.channels, args)\n\treturn nil\n}\n\nfunc NewBalance() *CommandBalance ", "output": "{\n\treturn &CommandBalance{}\n}"}
{"input": "package todolist\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/user\"\n)\n\ntype FileStore struct {\n\tFileLocation string\n\tLoaded       bool\n}\n\nfunc NewFileStore() *FileStore {\n\treturn &FileStore{FileLocation: \"\", Loaded: false}\n}\n\nfunc getLocation() string {\n\tlocalrepo := \".todos.json\"\n\tusr, _ := user.Current()\n\thomerepo := fmt.Sprintf(\"%s/.todos.json\", usr.HomeDir)\n\t_, ferr := os.Stat(localrepo)\n\n\tif ferr == nil {\n\t\treturn localrepo\n\t} else {\n\t\treturn homerepo\n\t}\n}\n\n\n\nfunc (f *FileStore) Initialize() {\n\tif f.FileLocation == \"\" {\n\t\tf.FileLocation = \".todos.json\"\n\t}\n\n\t_, err := ioutil.ReadFile(f.FileLocation)\n\tif err == nil {\n\t\tfmt.Println(\"It looks like a .todos.json file already exists!  Doing nothing.\")\n\t\tos.Exit(0)\n\t}\n\tif err := ioutil.WriteFile(f.FileLocation, []byte(\"[]\"), 0644); err != nil {\n\t\tfmt.Println(\"Error writing json file\", err)\n\t\tos.Exit(1)\n\t}\n\tfmt.Println(\"Todo repo initialized.\")\n}\n\nfunc (f *FileStore) Save(todos []*Todo) {\n\tdata, _ := json.Marshal(todos)\n\tif err := ioutil.WriteFile(f.FileLocation, []byte(data), 0644); err != nil {\n\t\tfmt.Println(\"Error writing json file\", err)\n\t}\n}\n\nfunc (f *FileStore) Load() ([]*Todo, error) ", "output": "{\n\tif f.FileLocation == \"\" {\n\t\tf.FileLocation = getLocation()\n\t}\n\n\tdata, err := ioutil.ReadFile(f.FileLocation)\n\tif err != nil {\n\t\tfmt.Println(\"No todo file found!\")\n\t\tfmt.Println(\"Initialize a new todo repo by running 'todo init'\")\n\t\treturn nil, err\n\t\tos.Exit(0)\n\t}\n\n\tvar todos []*Todo\n\tjerr := json.Unmarshal(data, &todos)\n\tif jerr != nil {\n\t\tfmt.Println(\"Error reading json data\", jerr)\n\t\treturn nil, jerr\n\t\tos.Exit(1)\n\t}\n\tf.Loaded = true\n\n\treturn todos, nil\n}"}
{"input": "package command\n\nimport (\n\t\"testing\"\n\n\t\"github.com/hashicorp/terraform/state\"\n\t\"github.com/hashicorp/terraform/terraform\"\n)\n\n\n\nfunc TestStateHook(t *testing.T) {\n\tis := &state.InmemState{}\n\tvar hook terraform.Hook = &StateHook{State: is}\n\n\ts := state.TestStateInitial()\n\taction, err := hook.PostStateUpdate(s)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\tif action != terraform.HookActionContinue {\n\t\tt.Fatalf(\"bad: %v\", action)\n\t}\n\tif !is.State().Equal(s) {\n\t\tt.Fatalf(\"bad state: %#v\", is.State())\n\t}\n}\n\nfunc TestStateHook_impl(t *testing.T) ", "output": "{\n\tvar _ terraform.Hook = new(StateHook)\n}"}
{"input": "package msp\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"testing\"\n)\n\n\n\nfunc TestFieldElemMultiplicationZero(t *testing.T) {\n\tx := FieldElem(make([]byte, ModulusSize))\n\trand.Read(x)\n\n\txy, yx := x.Mul(Zero), Zero.Mul(x)\n\n\tif !Zero.IsZero() {\n\t\tt.Fatalf(\"Zero is not zero?\")\n\t}\n\n\tif !xy.IsZero() || !yx.IsZero() {\n\t\tt.Fatalf(\"Multiplication by 0 failed!\\nx = %x\\n0*x = %x\\nx*0 = %x\", x, yx, xy)\n\t}\n}\n\nfunc TestFieldElemInvert(t *testing.T) {\n\tx := FieldElem(make([]byte, ModulusSize))\n\trand.Read(x)\n\n\txInv := x.Invert()\n\n\txy, yx := x.Mul(xInv), xInv.Mul(x)\n\n\tif !xy.IsOne() || !yx.IsOne() {\n\t\tt.Fatalf(\"Multiplication by inverse failed!\\nx = %x\\nxInv = %x\\nxInv*x = %x\\nx*xInv = %x\", x, xInv, yx, xy)\n\t}\n}\n\nfunc TestFieldElemMultiplicationOne(t *testing.T) ", "output": "{\n\tx := FieldElem(make([]byte, ModulusSize))\n\trand.Read(x)\n\n\txy, yx := x.Mul(One), One.Mul(x)\n\n\tif !One.IsOne() {\n\t\tt.Fatalf(\"One is not one?\")\n\t}\n\n\tif bytes.Compare(xy, x) != 0 || bytes.Compare(yx, x) != 0 {\n\t\tt.Fatalf(\"Multiplication by 1 failed!\\nx = %x\\n1*x = %x\\nx*1 = %x\", x, yx, xy)\n\t}\n}"}
{"input": "package client\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/getcarina/carina/common\"\n)\n\n\ntype UserError struct {\n\terror\n\tContext map[string]interface{}\n}\n\nfunc newClientError(err error) *UserError {\n\treturn &UserError{\n\t\terror:   err,\n\t\tContext: common.Log.ErrorContext,\n\t}\n}\n\n\nfunc (err *UserError) Cause() error {\n\treturn err.error\n}\n\nfunc (err *UserError) Error() string {\n\tvar hint string\n\tif !common.Log.DebugEnabled() {\n\t\thint = \"\\n\\nFor additional troubleshooting, re-run the command with --debug specified.\"\n\t}\n\treturn fmt.Sprintf(\"%s%s%s\", err.error.Error(), err.formatContext(), hint)\n}\n\n\n\nfunc (err *UserError) formatContext() string ", "output": "{\n\tif len(err.Context) == 0 {\n\t\treturn \"\"\n\t}\n\n\tvar context string\n\tresult, jsonErr := json.MarshalIndent(err.Context, \"\", \"\\t\")\n\tif jsonErr == nil {\n\t\tcontext = string(result)\n\t} else {\n\t\tcontext = common.Log.SDump(err.Context)\n\t}\n\n\treturn fmt.Sprintf(\"\\nContext:\\n%s\", context)\n}"}
{"input": "package handlers\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/exercism/cli/api\"\n)\n\n\n\n\ntype Item struct {\n\t*api.Problem\n\tdir       string\n\tisNew     bool\n\tisUpdated bool\n}\n\n\n\n\n\nfunc (it *Item) Matches(filter HWFilter) bool {\n\tswitch filter {\n\tcase HWNew:\n\t\treturn it.isNew\n\tcase HWUpdated:\n\t\treturn it.isUpdated\n\t}\n\treturn true\n}\n\n\nfunc (it *Item) Save() error {\n\tif _, err := os.Stat(it.Path()); err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn err\n\t\t}\n\t\tit.isNew = true\n\t}\n\n\tfor name, text := range it.Files {\n\t\tfile := filepath.Join(it.Path(), name)\n\n\t\terr := os.MkdirAll(filepath.Dir(file), 0755)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := os.Stat(file); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif !it.isNew {\n\t\t\t\tit.isUpdated = true\n\t\t\t}\n\n\t\t\terr = ioutil.WriteFile(file, []byte(text), 0644)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (it *Item) Path() string ", "output": "{\n\treturn filepath.Join(it.dir, it.TrackID, it.Slug)\n}"}
{"input": "package util\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestCacheFile(t *testing.T) ", "output": "{\n\tCacheFile()\n}"}
{"input": "package httplog\n\n\nimport (\n\t\"net/http\"\n)\n\n\n\n\nfunc (httpLogger *internalHttpLogger) RequestedRangeNotSatisfiable(w http.ResponseWriter, cascade ...interface{}) ", "output": "{\n\n\thttpStatusCode := http.StatusRequestedRangeNotSatisfiable\n\thttpStatusName :=  StatusNameRequestedRangeNotSatisfiable\n\n\thttpLogger.jsonHttpResponse(w, httpStatusCode, httpStatusName, cascade...)\n}"}
{"input": "package cases\n\nimport \"github.com/insionng/yougam/libraries/x/text/transform\"\n\ntype caseFolder struct{ transform.NopResetter }\n\n\n\n\nfunc makeFold(o options) transform.Transformer {\n\treturn &caseFolder{}\n}\n\nfunc (t *caseFolder) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) ", "output": "{\n\tc := context{dst: dst, src: src, atEOF: atEOF}\n\tfor c.next() {\n\t\tfoldFull(&c)\n\t\tc.checkpoint()\n\t}\n\treturn c.ret()\n}"}
{"input": "package client\n\nimport (\n\t\"github.com/Cloud-Foundations/Dominator/lib/srpc\"\n\tproto \"github.com/Cloud-Foundations/Dominator/proto/imageunpacker\"\n)\n\nfunc AddDevice(client *srpc.Client, deviceId string, adder func() error) error {\n\treturn addDevice(client, deviceId, adder)\n}\n\nfunc AssociateStreamWithDevice(srpcClient *srpc.Client, streamName string,\n\tdeviceId string) error {\n\treturn associateStreamWithDevice(srpcClient, streamName, deviceId)\n}\n\nfunc ExportImage(srpcClient *srpc.Client, streamName,\n\texportType, exportDestination string) error {\n\treturn exportImage(srpcClient, streamName, exportType, exportDestination)\n}\n\nfunc GetStatus(srpcClient *srpc.Client) (proto.GetStatusResponse, error) {\n\treturn getStatus(srpcClient)\n}\n\n\n\nfunc PrepareForCopy(srpcClient *srpc.Client, streamName string) error {\n\treturn prepareForCopy(srpcClient, streamName)\n}\n\nfunc PrepareForUnpack(srpcClient *srpc.Client, streamName string,\n\tskipIfPrepared bool, doNotWaitForResult bool) error {\n\treturn prepareForUnpack(srpcClient, streamName, skipIfPrepared,\n\t\tdoNotWaitForResult)\n}\n\nfunc RemoveDevice(client *srpc.Client, deviceId string) error {\n\treturn removeDevice(client, deviceId)\n}\n\nfunc UnpackImage(srpcClient *srpc.Client, streamName,\n\timageLeafName string) error {\n\treturn unpackImage(srpcClient, streamName, imageLeafName)\n}\n\nfunc PrepareForCapture(srpcClient *srpc.Client, streamName string) error ", "output": "{\n\treturn prepareForCapture(srpcClient, streamName)\n}"}
{"input": "package builds\n\nimport (\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/pivotal-golang/clock\"\n)\n\n\n\ntype BuildTracker interface {\n\tTrack()\n}\n\ntype TrackerRunner struct {\n\tTracker  BuildTracker\n\tInterval time.Duration\n\tClock    clock.Clock\n}\n\n\n\nfunc (runner TrackerRunner) Run(signals <-chan os.Signal, ready chan<- struct{}) error ", "output": "{\n\tticker := runner.Clock.NewTicker(runner.Interval)\n\n\tclose(ready)\n\n\trunner.Tracker.Track()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C():\n\t\t\trunner.Tracker.Track()\n\t\tcase <-signals:\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tpanic(\"unreachable\")\n}"}
{"input": "package http\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/Cepave/open-falcon-backend/modules/transfer/g\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"net/http\"\n\t_ \"net/http/pprof\"\n)\n\ntype Dto struct {\n\tMsg  string      `json:\"msg\"`\n\tData interface{} `json:\"data\"`\n}\n\nfunc Start() {\n\tgo startHttpServer()\n}\nfunc startHttpServer() {\n\tif !g.Config().Http.Enabled {\n\t\treturn\n\t}\n\n\taddr := g.Config().Http.Listen\n\tif addr == \"\" {\n\t\treturn\n\t}\n\n\tconfigCommonRoutes()\n\tconfigProcHttpRoutes()\n\tconfigDebugHttpRoutes()\n\tconfigApiHttpRoutes()\n\n\ts := &http.Server{\n\t\tAddr:           addr,\n\t\tMaxHeaderBytes: 1 << 30,\n\t}\n\n\tlog.Println(\"http.startHttpServer ok, listening\", addr)\n\tlog.Fatalln(s.ListenAndServe())\n}\n\n\n\nfunc RenderDataJson(w http.ResponseWriter, data interface{}) {\n\tRenderJson(w, Dto{Msg: \"success\", Data: data})\n}\n\nfunc RenderMsgJson(w http.ResponseWriter, msg string) {\n\tRenderJson(w, map[string]string{\"msg\": msg})\n}\n\nfunc AutoRender(w http.ResponseWriter, data interface{}, err error) {\n\tif err != nil {\n\t\tRenderMsgJson(w, err.Error())\n\t\treturn\n\t}\n\tRenderDataJson(w, data)\n}\n\nfunc RenderJson(w http.ResponseWriter, v interface{}) ", "output": "{\n\tbs, err := json.Marshal(v)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json; charset=UTF-8\")\n\tw.Write(bs)\n}"}
{"input": "package admit\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestAdmission(t *testing.T) ", "output": "{\n\thandler := NewAlwaysAdmit()\n\terr := handler.Admit(nil)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error returned from admission handler\")\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"text/tabwriter\"\n\n\t\"github.com/zerobotlabs/nestor-cli/Godeps/_workspace/src/github.com/BurntSushi/toml\"\n)\n\nvar (\n\tflagTypes = false\n)\n\n\n\nfunc usage() {\n\tlog.Printf(\"Usage: %s toml-file [ toml-file ... ]\\n\",\n\t\tpath.Base(os.Args[0]))\n\tflag.PrintDefaults()\n\n\tos.Exit(1)\n}\n\nfunc main() {\n\tif flag.NArg() < 1 {\n\t\tflag.Usage()\n\t}\n\tfor _, f := range flag.Args() {\n\t\tvar tmp interface{}\n\t\tmd, err := toml.DecodeFile(f, &tmp)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Error in '%s': %s\", f, err)\n\t\t}\n\t\tif flagTypes {\n\t\t\tprintTypes(md)\n\t\t}\n\t}\n}\n\nfunc printTypes(md toml.MetaData) {\n\ttabw := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)\n\tfor _, key := range md.Keys() {\n\t\tfmt.Fprintf(tabw, \"%s%s\\t%s\\n\",\n\t\t\tstrings.Repeat(\"    \", len(key)-1), key, md.Type(key...))\n\t}\n\ttabw.Flush()\n}\n\nfunc init() ", "output": "{\n\tlog.SetFlags(0)\n\n\tflag.BoolVar(&flagTypes, \"types\", flagTypes,\n\t\t\"When set, the types of every defined key will be shown.\")\n\n\tflag.Usage = usage\n\tflag.Parse()\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/base32\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc escape(encoding string) {\n\tswitch {\n\tcase strings.HasPrefix(\"query\", encoding):\n\t\tb, err := ioutil.ReadAll(os.Stdin)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tos.Stdout.Write([]byte(url.QueryEscape(string(b))))\n\tcase strings.HasPrefix(\"hex\", encoding):\n\t\tb, err := ioutil.ReadAll(os.Stdin)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tos.Stdout.Write([]byte(hex.EncodeToString(b)))\n\tdefault:\n\t\tfmt.Fprintf(os.Stderr, \"unknown escape encoding: %q\\n\", encoding)\n\t\tos.Exit(2)\n\t}\n}\n\n\n\nfunc main() {\n\tif len(os.Args) != 3 {\n\t\tfmt.Fprintf(os.Stderr, \"expected two arguments: <mode> <encoding>: got %d\\n\", len(os.Args)-1)\n\t\tos.Exit(2)\n\t}\n\tmode := os.Args[1]\n\tswitch {\n\tcase strings.HasPrefix(\"escape\", mode):\n\t\tescape(os.Args[2])\n\tcase strings.HasPrefix(\"unescape\", mode) || strings.HasPrefix(\"decode\", mode):\n\t\tunescape(os.Args[2])\n\tdefault:\n\t\tfmt.Fprintf(os.Stderr, \"unknown mode: %q\\n\", mode)\n\t\tos.Exit(2)\n\t}\n}\n\nfunc unescape(encoding string) ", "output": "{\n\tswitch {\n\tcase strings.HasPrefix(\"query\", encoding):\n\t\tb, err := ioutil.ReadAll(os.Stdin)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\ts, err := url.QueryUnescape(string(b))\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tos.Stdout.Write([]byte(s))\n\tcase strings.HasPrefix(\"b32\", encoding):\n\t\td := base32.NewDecoder(base32.StdEncoding, os.Stdin)\n\t\tio.Copy(os.Stdout, d)\n\tdefault:\n\t\tfmt.Fprintf(os.Stderr, \"unknown unescape encoding: %q\\n\", encoding)\n\t}\n}"}
{"input": "package mountinfo\n\n\ntype Mount struct {\n\tID         int\n\tParent     int\n\tMajor      int\n\tMinor      int\n\tRoot       string\n\tMountPoint string\n\tOpts       map[string]struct{}\n}\n\n\ntype FilterFunc func(m *Mount) bool\n\n\n\n\nfunc (m *Mount) NeedsRemountPrivate() bool {\n\tfor _, key := range []string{\n\t\t\"shared\",\n\t\t\"master\",\n\t} {\n\t\tif _, needsRemount := m.Opts[key]; needsRemount {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\n\ntype Mounts []*Mount\n\n\nfunc (ms Mounts) Filter(f FilterFunc) Mounts {\n\tfiltered := make([]*Mount, 0, len(ms))\n\n\tfor _, m := range ms {\n\t\tif f(m) {\n\t\t\tfiltered = append(filtered, m)\n\t\t}\n\t}\n\n\treturn Mounts(filtered)\n}\n\n\n\n\n\nfunc (ms Mounts) Len() int { return len(ms) }\n\nfunc (ms Mounts) Swap(i, j int) { ms[i], ms[j] = ms[j], ms[i] }\n\n\nfunc (ms Mounts) mountDepth(i int) int {\n\tancestorCount := 0\n\tcurrent := ms[i]\n\tfor found := true; found; {\n\t\tfound = false\n\t\tfor _, mnt := range ms {\n\t\t\tif mnt.ID == current.Parent {\n\t\t\t\tancestorCount++\n\t\t\t\tcurrent = mnt\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn ancestorCount\n}\n\nfunc (ms Mounts) Less(i, j int) (result bool) ", "output": "{ return ms.mountDepth(i) >= ms.mountDepth(j) }"}
{"input": "package main\n\nimport . \"g2d\"\n\nvar screen = Point{480, 360}\nvar size = Point{20, 20}\n\ntype Ball struct {\n    x, y   int\n    dx, dy int\n}\n\nfunc NewBall(pos Point) *Ball {\n    return &Ball{pos.X, pos.Y, 5, 5}\n}\n\n\n\nfunc (b *Ball) Position() Point {\n    return Point{b.x, b.y}\n}\n\n\nvar b1 = NewBall(Point{40, 80})\nvar b2 = NewBall(Point{80, 40})\n\nfunc mainConsole() {\n    for i := 0; i < 25; i++ {\n        Println(\"Ball 1 @\", b1.Position())\n        Println(\"Ball 2 @\", b2.Position())\n        b1.Move()\n        b2.Move()\n    }\n}\n\nfunc tick() {\n    ClearCanvas()  \n    b1.Move()\n    b2.Move()\n    DrawImage(\"ball.png\", b1.Position())  \n    DrawImage(\"ball.png\", b2.Position())  \n}\n\nfunc main() {\n    \n    InitCanvas(screen)\n    MainLoop(tick)\n}\n\nfunc (b *Ball) Move() ", "output": "{\n    if !(0 <= b.x+b.dx && b.x+b.dx <= screen.X-size.X) {\n        b.dx = -b.dx\n    }\n    if !(0 <= b.y+b.dy && b.y+b.dy <= screen.Y-size.Y) {\n        b.dy = -b.dy\n    }\n    b.x += b.dx\n    b.y += b.dy\n}"}
{"input": "package v1\n\nimport (\n\t\"gopkg.in/guregu/null.v3\"\n\n\t\"go.k6.io/k6/core\"\n\t\"go.k6.io/k6/lib\"\n)\n\ntype Status struct {\n\tStatus lib.ExecutionStatus `json:\"status\" yaml:\"status\"`\n\n\tPaused  null.Bool `json:\"paused\" yaml:\"paused\"`\n\tVUs     null.Int  `json:\"vus\" yaml:\"vus\"`\n\tVUsMax  null.Int  `json:\"vus-max\" yaml:\"vus-max\"`\n\tStopped bool      `json:\"stopped\" yaml:\"stopped\"`\n\tRunning bool      `json:\"running\" yaml:\"running\"`\n\tTainted bool      `json:\"tainted\" yaml:\"tainted\"`\n}\n\n\n\nfunc (s Status) GetName() string {\n\treturn \"status\"\n}\n\nfunc (s Status) GetID() string {\n\treturn \"default\"\n}\n\nfunc (s Status) SetID(id string) error {\n\treturn nil\n}\n\nfunc NewStatus(engine *core.Engine) Status ", "output": "{\n\texecutionState := engine.ExecutionScheduler.GetState()\n\treturn Status{\n\t\tStatus:  executionState.GetCurrentExecutionStatus(),\n\t\tRunning: executionState.HasStarted() && !executionState.HasEnded(),\n\t\tPaused:  null.BoolFrom(executionState.IsPaused()),\n\t\tStopped: engine.IsStopped(),\n\t\tVUs:     null.IntFrom(executionState.GetCurrentlyActiveVUsCount()),\n\t\tVUsMax:  null.IntFrom(executionState.GetInitializedVUsCount()),\n\t\tTainted: engine.IsTainted(),\n\t}\n}"}
{"input": "package shutdown\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"sync\"\n\t\"syscall\"\n)\n\nvar (\n\tsigch = make(chan os.Signal, 1)\n\n\tc = make(chan struct{})\n)\n\n\nvar C <-chan struct{} = c\n\n\nvar Wg = &sync.WaitGroup{}\n\n\n\n\nfunc InitiateManual() {\n\tlog.Println(\"Manual shutdown initiated...\")\n\tselect {\n\tcase sigch <- syscall.SIGTERM:\n\tdefault:\n\t}\n}\n\nfunc init() ", "output": "{\n\tsignal.Notify(sigch, syscall.SIGTERM, syscall.SIGINT)\n\n\tgo func() {\n\t\tdefer signal.Stop(sigch)\n\n\t\ts := <-sigch\n\t\tlog.Printf(\"Received '%v' signal, broadcasting shutdown...\", s)\n\t\tclose(c)\n\t}()\n}"}
{"input": "package iso20022\n\n\ntype Statement55 struct {\n\n\tReportNumber *Number3Choice `xml:\"RptNb,omitempty\"`\n\n\tQueryReference *RestrictedFINXMax16Text `xml:\"QryRef,omitempty\"`\n\n\tStatementIdentification *RestrictedFINXMax16Text `xml:\"StmtId,omitempty\"`\n\n\tStatementDateTime *DateAndDateTimeChoice `xml:\"StmtDtTm\"`\n\n\tFrequency *Frequency26Choice `xml:\"Frqcy,omitempty\"`\n\n\tUpdateType *UpdateType16Choice `xml:\"UpdTp,omitempty\"`\n\n\tStatementStructure *StatementStructure1Code `xml:\"StmtStr\"`\n\n\tActivityIndicator *YesNoIndicator `xml:\"ActvtyInd\"`\n}\n\nfunc (s *Statement55) AddReportNumber() *Number3Choice {\n\ts.ReportNumber = new(Number3Choice)\n\treturn s.ReportNumber\n}\n\nfunc (s *Statement55) SetQueryReference(value string) {\n\ts.QueryReference = (*RestrictedFINXMax16Text)(&value)\n}\n\nfunc (s *Statement55) SetStatementIdentification(value string) {\n\ts.StatementIdentification = (*RestrictedFINXMax16Text)(&value)\n}\n\n\n\nfunc (s *Statement55) AddFrequency() *Frequency26Choice {\n\ts.Frequency = new(Frequency26Choice)\n\treturn s.Frequency\n}\n\nfunc (s *Statement55) AddUpdateType() *UpdateType16Choice {\n\ts.UpdateType = new(UpdateType16Choice)\n\treturn s.UpdateType\n}\n\nfunc (s *Statement55) SetStatementStructure(value string) {\n\ts.StatementStructure = (*StatementStructure1Code)(&value)\n}\n\nfunc (s *Statement55) SetActivityIndicator(value string) {\n\ts.ActivityIndicator = (*YesNoIndicator)(&value)\n}\n\nfunc (s *Statement55) AddStatementDateTime() *DateAndDateTimeChoice ", "output": "{\n\ts.StatementDateTime = new(DateAndDateTimeChoice)\n\treturn s.StatementDateTime\n}"}
{"input": "package tricorder\n\nimport (\n\t\"github.com/Symantec/tricorder/go/tricorder/messages\"\n\t\"net/rpc\"\n)\n\n\n\ntype rpcMetricsCollector messages.MetricList\n\nfunc (c *rpcMetricsCollector) Collect(m *metric, s *session) (err error) {\n\t*c = append(*c, rpcAsMetric(m, s))\n\treturn nil\n}\n\ntype rpcType int\n\nfunc (t *rpcType) ListMetrics(path string, response *messages.MetricList) error {\n\treturn root.GetAllMetricsByPath(\n\t\tpath, (*rpcMetricsCollector)(response), nil)\n}\n\nfunc (t *rpcType) GetMetric(path string, response *messages.Metric) error {\n\tm := root.GetMetric(path)\n\tif m == nil {\n\t\treturn messages.ErrMetricNotFound\n\t}\n\t*response = *rpcAsMetric(m, nil)\n\treturn nil\n}\n\nfunc initRpcHandlers() {\n\trpc.RegisterName(\"MetricsServer\", new(rpcType))\n}\n\nfunc rpcAsMetric(m *metric, s *session) *messages.Metric ", "output": "{\n\tvar result messages.Metric\n\tm.InitRpcMetric(s, &result)\n\treturn &result\n}"}
{"input": "package config\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\t\"gopkg.in/gcfg.v1\"\n)\n\nconst (\n\tdefaultContent = `[global]\nport = 8189\nhost = 127.0.0.1\nallowFrom = 127.0.0.1\ndebug = false\nlog = /var/log/gitlabHooks.log\n`\n)\n\ntype GitConfig struct {\n\tPublicKey  string\n\tPrivateKey string\n\tUser       string\n\tPassphrase string\n}\n\ntype GitRepository struct {\n\tPath          string\n\tBranch        string\n\tRemote        string\n\tPushRequests  bool\n\tMergeRequests bool\n\tNotifications bool\n}\n\ntype GitLab struct {\n\tHost   string\n\tScheme string\n\tUser   string\n\tToken  string\n}\n\ntype LogConfig struct {\n\tLog              string\n\tSkypeUrl         string\n\tSkypeDistination string\n\tSlackUrl         string\n\tSlackToken       string\n\tSlackChannel     string\n}\n\ntype WebConfig struct {\n\tApi        string\n\tManagement string\n\tTemplates  string\n}\n\ntype Config struct {\n\tGlobal struct {\n\t\tPort      string\n\t\tHost      string\n\t\tAllowFrom string\n\t\tDebug     bool\n\t\tPidFile   string\n\t\tUser      string\n\t}\n\tWeb        WebConfig\n\tLogger     LogConfig\n\tGitlab     GitLab\n\tGit        GitConfig\n\tRepository map[string]*GitRepository\n}\n\nfunc (self *Config) ParseConfig(file string) error {\n\tif _, err := os.Stat(file); os.IsNotExist(err) {\n\t\tlog.Printf(\"Creating default config file %s\", file)\n\t\tif err = createDefault(file); err != nil {\n\t\t\tlog.Fatalln(\"Couldn't create config file \", file, err.Error())\n\t\t}\n\t}\n\tif err := gcfg.ReadFileInto(self, file); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\n\nfunc createDefault(file string) error ", "output": "{\n\terr := ioutil.WriteFile(file, []byte(defaultContent), 0700)\n\treturn err\n}"}
{"input": "package sort\n\nimport (\n\t\"math/rand\"\n\t\"sort\"\n\t\"testing\"\n)\n\nconst mainConst = 42\n\ntype SortFunction func([]int) []int\n\nfunc init() {\n\trand.Seed(mainConst)\n}\n\nfunc MakeRandArray() []int {\n\treturn rand.Perm(mainConst)\n}\n\nfunc MakeSortedArray() []int {\n\tsortedArray := make([]int, mainConst)\n\tfor i := 0; i < mainConst; i++ {\n\t\tsortedArray[i] = i\n\t}\n\treturn sortedArray\n}\n\nfunc MakeReversedArray() []int {\n\treversedArray := make([]int, mainConst)\n\tfor i := 0; i < mainConst; i++ {\n\t\treversedArray[mainConst-i-1] = i\n\t}\n\treturn reversedArray\n}\n\n\n\nfunc TestSort(t *testing.T, sortFn SortFunction) ", "output": "{\n\tsorted := MakeSortedArray()\n\trandom := MakeRandArray()\n\treversed := MakeReversedArray()\n\n\tsorted = sortFn(sorted)\n\trandom = sortFn(random)\n\treversed = sortFn(reversed)\n\n\tif !(sort.IntsAreSorted(sorted) && sort.IntsAreSorted(random) && sort.IntsAreSorted(reversed)) {\n\t\tt.Errorf(\"Wrong behavior:\\n%v\\n%v\\n%v\", sorted, random, reversed)\n\t}\n}"}
{"input": "package users\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/runtime/middleware\"\n)\n\n\n\nfunc NewListUsersParams() ListUsersParams {\n\n\treturn ListUsersParams{}\n}\n\n\n\n\n\ntype ListUsersParams struct {\n\n\tHTTPRequest *http.Request `json:\"-\"`\n}\n\n\n\n\n\n\n\nfunc (o *ListUsersParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error ", "output": "{\n\tvar res []error\n\n\to.HTTPRequest = r\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package docker\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n)\n\n\ntype NoSuchTask struct {\n\tID  string\n\tErr error\n}\n\n\n\n\n\n\ntype ListTasksOptions struct {\n\tFilters map[string][]string\n\tContext context.Context\n}\n\n\n\n\nfunc (c *Client) ListTasks(opts ListTasksOptions) ([]swarm.Task, error) {\n\tpath := \"/tasks?\" + queryString(opts)\n\tresp, err := c.do(http.MethodGet, path, doOptions{context: opts.Context})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar tasks []swarm.Task\n\tif err := json.NewDecoder(resp.Body).Decode(&tasks); err != nil {\n\t\treturn nil, err\n\t}\n\treturn tasks, nil\n}\n\n\n\n\nfunc (c *Client) InspectTask(id string) (*swarm.Task, error) {\n\tresp, err := c.do(http.MethodGet, \"/tasks/\"+id, doOptions{})\n\tif err != nil {\n\t\tif e, ok := err.(*Error); ok && e.Status == http.StatusNotFound {\n\t\t\treturn nil, &NoSuchTask{ID: id}\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar task swarm.Task\n\tif err := json.NewDecoder(resp.Body).Decode(&task); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &task, nil\n}\n\nfunc (err *NoSuchTask) Error() string ", "output": "{\n\tif err.Err != nil {\n\t\treturn err.Err.Error()\n\t}\n\treturn \"No such task: \" + err.ID\n}"}
{"input": "package actualstatelisteners\n\nimport (\n\t\"os\"\n\n\t\"code.cloudfoundry.org/lager\"\n\t\"github.com/cloudfoundry/hm9000/config\"\n\t\"github.com/cloudfoundry/hm9000/models\"\n\t\"github.com/nats-io/nats\"\n\n\t\"github.com/cloudfoundry/yagnats\"\n)\n\ntype NatsListener struct {\n\tlogger     lager.Logger\n\tconfig     *config.Config\n\tmessageBus yagnats.NATSConn\n\tsyncer     Syncer\n}\n\nfunc NewNatsListener(logger lager.Logger,\n\tconfig *config.Config,\n\tmessageBus yagnats.NATSConn,\n\tsyncer Syncer) *NatsListener {\n\n\treturn &NatsListener{\n\t\tlogger:     logger,\n\t\tconfig:     config,\n\t\tmessageBus: messageBus,\n\t\tsyncer:     syncer,\n\t}\n}\n\n\n\nfunc (listener *NatsListener) Run(signals <-chan os.Signal, ready chan<- struct{}) error ", "output": "{\n\tsub, _ := listener.messageBus.Subscribe(\"dea.heartbeat\", func(message *nats.Msg) {\n\t\tlistener.logger.Debug(\"Got a nats heartbeat\")\n\t\theartbeat, err := models.NewHeartbeatFromJSON(message.Data)\n\t\tif err != nil {\n\t\t\tlistener.logger.Error(\"Failed to unmarshal dea heartbeat\", err,\n\t\t\t\tlager.Data{\n\t\t\t\t\t\"MessageBody\": string(message.Data),\n\t\t\t\t})\n\t\t\treturn\n\t\t}\n\t\tlistener.logger.Debug(\"Decoded the nats heartbeat\")\n\t\tlistener.syncer.Heartbeat(heartbeat)\n\t})\n\n\tclose(ready)\n\n\tselect {\n\tcase <-signals:\n\t\tlistener.messageBus.Unsubscribe(sub)\n\t\treturn nil\n\t}\n}"}
{"input": "package systemd\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/google/cadvisor/container\"\n\t\"github.com/google/cadvisor/fs\"\n\tinfo \"github.com/google/cadvisor/info/v1\"\n\t\"github.com/google/cadvisor/watcher\"\n\n\t\"k8s.io/klog/v2\"\n)\n\ntype systemdFactory struct{}\n\nfunc (f *systemdFactory) String() string {\n\treturn \"systemd\"\n}\n\nfunc (f *systemdFactory) NewContainerHandler(name string, inHostNamespace bool) (container.ContainerHandler, error) {\n\treturn nil, fmt.Errorf(\"Not yet supported\")\n}\n\n\n\nfunc (f *systemdFactory) DebugInfo() map[string][]string {\n\treturn map[string][]string{}\n}\n\n\nfunc Register(machineInfoFactory info.MachineInfoFactory, fsInfo fs.FsInfo, includedMetrics container.MetricSet) error {\n\tklog.V(1).Infof(\"Registering systemd factory\")\n\tfactory := &systemdFactory{}\n\tcontainer.RegisterContainerHandlerFactory(factory, []watcher.ContainerWatchSource{watcher.Raw})\n\treturn nil\n}\n\nfunc (f *systemdFactory) CanHandleAndAccept(name string) (bool, bool, error) ", "output": "{\n\tif strings.HasSuffix(name, \".mount\") {\n\t\treturn true, false, nil\n\t}\n\tklog.V(5).Infof(\"%s not handled by systemd handler\", name)\n\treturn false, false, nil\n}"}
{"input": "package model\n\n\ntype Sample struct {\n\tMetric    Metric\n\tValue     SampleValue\n\tTimestamp Timestamp\n}\n\n\nfunc (s *Sample) Equal(o *Sample) bool {\n\tif s == o {\n\t\treturn true\n\t}\n\n\tif !s.Metric.Equal(o.Metric) {\n\t\treturn false\n\t}\n\tif !s.Timestamp.Equal(o.Timestamp) {\n\t\treturn false\n\t}\n\tif !s.Value.Equal(o.Value) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n\ntype Samples []*Sample\n\nfunc (s Samples) Len() int {\n\treturn len(s)\n}\n\n\n\n\nfunc (s Samples) Swap(i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\n\nfunc (s Samples) Equal(o Samples) bool {\n\tif len(s) != len(o) {\n\t\treturn false\n\t}\n\n\tfor i, sample := range s {\n\t\tif !sample.Equal(o[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (s Samples) Less(i, j int) bool ", "output": "{\n\tswitch {\n\tcase s[i].Metric.Before(s[j].Metric):\n\t\treturn true\n\tcase s[j].Metric.Before(s[i].Metric):\n\t\treturn false\n\tcase s[i].Timestamp.Before(s[j].Timestamp):\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}"}
{"input": "package daemon\n\nimport (\n\t\"fmt\"\n\n\tnetworktypes \"github.com/docker/docker/api/types/network\"\n\t\"github.com/docker/docker/container\"\n)\n\nfunc (daemon *Daemon) setupLinkedContainers(container *container.Container) ([]string, error) {\n\treturn nil, nil\n}\n\n\nfunc (daemon *Daemon) ConnectToNetwork(container *container.Container, idOrName string, endpointConfig *networktypes.EndpointSettings) error {\n\treturn fmt.Errorf(\"Solaris does not support connecting a running container to a network\")\n}\n\n\nfunc (daemon *Daemon) getSize(container *container.Container) (int64, int64) {\n\treturn 0, 0\n}\n\n\nfunc (daemon *Daemon) DisconnectFromNetwork(container *container.Container, networkName string, force bool) error {\n\treturn fmt.Errorf(\"Solaris does not support disconnecting a running container from a network\")\n}\n\nfunc (daemon *Daemon) setupIpcDirs(container *container.Container) error {\n\treturn nil\n}\n\nfunc (daemon *Daemon) mountVolumes(container *container.Container) error {\n\treturn nil\n}\n\nfunc killProcessDirectly(container *container.Container) error {\n\treturn nil\n}\n\n\n\nfunc isLinkable(child *container.Container) bool {\n\treturn false\n}\n\nfunc detachMounted(path string) error ", "output": "{\n\treturn nil\n}"}
{"input": "package model\n\nimport \"time\"\n\n\ntype UserPeer interface {\n\tGetByID(id string) (*User, error)\n\tGetByOAuthID(id string) (*User, error)\n\tUpdateLastLogin(id string) error\n\tNewUser() *User\n\tSaveNew(user *User) error\n}\n\n\ntype User struct {\n\tID        string\n\tOAuthID   string\n\tEmail     string\n\tUsername  string\n\tPeer      UserPeer\n\tCreatedAt time.Time\n\tLastLogin time.Time\n}\n\n\n\n\nfunc (u *User) SaveNew() error ", "output": "{\n\treturn u.Peer.SaveNew(u)\n}"}
{"input": "package procfs\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"strings\"\n)\n\n\n\ntype ARPEntry struct {\n\tIPAddr net.IP\n\tHWAddr net.HardwareAddr\n\tDevice string\n}\n\n\n\nfunc (fs FS) GatherARPEntries() ([]ARPEntry, error) {\n\tdata, err := ioutil.ReadFile(fs.proc.Path(\"net/arp\"))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading arp %s: %s\", fs.proc.Path(\"net/arp\"), err)\n\t}\n\n\treturn parseARPEntries(data)\n}\n\nfunc parseARPEntries(data []byte) ([]ARPEntry, error) {\n\tlines := strings.Split(string(data), \"\\n\")\n\tentries := make([]ARPEntry, 0)\n\tvar err error\n\tconst (\n\t\texpectedDataWidth   = 6\n\t\texpectedHeaderWidth = 9\n\t)\n\tfor _, line := range lines {\n\t\tcolumns := strings.Fields(line)\n\t\twidth := len(columns)\n\n\t\tif width == expectedHeaderWidth || width == 0 {\n\t\t\tcontinue\n\t\t} else if width == expectedDataWidth {\n\t\t\tentry, err := parseARPEntry(columns)\n\t\t\tif err != nil {\n\t\t\t\treturn []ARPEntry{}, fmt.Errorf(\"failed to parse ARP entry: %s\", err)\n\t\t\t}\n\t\t\tentries = append(entries, entry)\n\t\t} else {\n\t\t\treturn []ARPEntry{}, fmt.Errorf(\"%d columns were detected, but %d were expected\", width, expectedDataWidth)\n\t\t}\n\n\t}\n\n\treturn entries, err\n}\n\n\n\nfunc parseARPEntry(columns []string) (ARPEntry, error) ", "output": "{\n\tip := net.ParseIP(columns[0])\n\tmac := net.HardwareAddr(columns[3])\n\n\tentry := ARPEntry{\n\t\tIPAddr: ip,\n\t\tHWAddr: mac,\n\t\tDevice: columns[5],\n\t}\n\n\treturn entry, nil\n}"}
{"input": "package markcontrolplane\n\nimport (\n\t\"fmt\"\n\n\t\"k8s.io/api/core/v1\"\n\tclientset \"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/kubernetes/cmd/kubeadm/app/constants\"\n\t\"k8s.io/kubernetes/cmd/kubeadm/app/util/apiclient\"\n)\n\n\nfunc MarkControlPlane(client clientset.Interface, controlPlaneName string, taints []v1.Taint) error {\n\n\tfmt.Printf(\"[mark-control-plane] Marking the node %s as control-plane by adding the label \\\"%s=''\\\"\\n\", controlPlaneName, constants.LabelNodeRoleMaster)\n\n\tif taints != nil && len(taints) > 0 {\n\t\ttaintStrs := []string{}\n\t\tfor _, taint := range taints {\n\t\t\ttaintStrs = append(taintStrs, taint.ToString())\n\t\t}\n\t\tfmt.Printf(\"[mark-control-plane] Marking the node %s as control-plane by adding the taints %v\\n\", controlPlaneName, taintStrs)\n\t}\n\n\treturn apiclient.PatchNode(client, controlPlaneName, func(n *v1.Node) {\n\t\tmarkControlPlaneNode(n, taints)\n\t})\n}\n\nfunc taintExists(taint v1.Taint, taints []v1.Taint) bool {\n\tfor _, t := range taints {\n\t\tif t == taint {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n\n\nfunc markControlPlaneNode(n *v1.Node, taints []v1.Taint) ", "output": "{\n\tn.ObjectMeta.Labels[constants.LabelNodeRoleMaster] = \"\"\n\n\tfor _, nt := range n.Spec.Taints {\n\t\tif !taintExists(nt, taints) {\n\t\t\ttaints = append(taints, nt)\n\t\t}\n\t}\n\n\tn.Spec.Taints = taints\n}"}
{"input": "package random\n\nimport (\n\t\"math/rand\"\n\n\t\"github.com/micro/go-micro/v3/selector\"\n)\n\ntype random struct{}\n\n\n\nfunc (r *random) Record(addr string, err error) error {\n\treturn nil\n}\n\nfunc (r *random) Reset() error {\n\treturn nil\n}\n\nfunc (r *random) String() string {\n\treturn \"random\"\n}\n\n\nfunc NewSelector(opts ...selector.Option) selector.Selector {\n\treturn new(random)\n}\n\nfunc (r *random) Select(routes []string, opts ...selector.SelectOption) (selector.Next, error) ", "output": "{\n\tif len(routes) == 0 {\n\t\treturn nil, selector.ErrNoneAvailable\n\t}\n\n\treturn func() string {\n\t\tif len(routes) == 1 {\n\t\t\treturn routes[0]\n\t\t}\n\n\t\treturn routes[rand.Intn(len(routes)-1)]\n\t}, nil\n}"}
{"input": "package gtka\n\nimport (\n\t\"github.com/coyim/gotk3adapter/gdka\"\n\t\"github.com/coyim/gotk3adapter/gdki\"\n\t\"github.com/coyim/gotk3adapter/gliba\"\n\t\"github.com/coyim/gotk3adapter/gtki\"\n\t\"github.com/gotk3/gotk3/gtk\"\n)\n\ntype styleContext struct {\n\t*gliba.Object\n\tinternal *gtk.StyleContext\n}\n\nfunc WrapStyleContextSimple(v *gtk.StyleContext) gtki.StyleContext {\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn &styleContext{gliba.WrapObjectSimple(v.Object), v}\n}\n\nfunc WrapStyleContext(v *gtk.StyleContext, e error) (gtki.StyleContext, error) {\n\treturn WrapStyleContextSimple(v), e\n}\n\nfunc UnwrapStyleContext(v gtki.StyleContext) *gtk.StyleContext {\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn v.(*styleContext).internal\n}\n\n\n\nfunc (v *styleContext) RemoveClass(v1 string) {\n\tv.internal.RemoveClass(v1)\n}\n\nfunc (v *styleContext) AddProvider(v1 gtki.StyleProvider, v2 uint) {\n\tv.internal.AddProvider(UnwrapStyleProvider(v1), v2)\n}\n\nfunc (v *styleContext) GetScreen() (gdki.Screen, error) {\n\treturn gdka.WrapScreen(v.internal.GetScreen())\n}\n\nfunc (v *styleContext) GetProperty2(v1 string, v2 gtki.StateFlags) (interface{}, error) {\n\tvx1, vx2 := v.internal.GetProperty(v1, gtk.StateFlags(v2))\n\treturn gliba.WrapAllGuard(vx1), vx2\n}\n\nfunc (v *styleContext) AddClass(v1 string) ", "output": "{\n\tv.internal.AddClass(v1)\n}"}
{"input": "package helm\n\nimport (\n\trls \"k8s.io/helm/pkg/proto/hapi/services\"\n)\n\n\n\n\n\nvar Config struct {\n\tServAddr string\n}\n\n\n\n\nfunc ListReleases(limit int, offset string, sort rls.ListSort_SortBy, order rls.ListSort_SortOrder, filter string) (*rls.ListReleasesResponse, error) {\n\topts := []ReleaseListOption{\n\t\tReleaseListLimit(limit),\n\t\tReleaseListOffset(offset),\n\t\tReleaseListFilter(filter),\n\t\tReleaseListSort(int32(sort)),\n\t\tReleaseListOrder(int32(order)),\n\t}\n\treturn NewClient(HelmHost(Config.ServAddr)).ListReleases(opts...)\n}\n\n\n\n\n\n\n\n\nfunc GetReleaseContent(rlsName string) (*rls.GetReleaseContentResponse, error) {\n\treturn NewClient(HelmHost(Config.ServAddr)).ReleaseContent(rlsName)\n}\n\n\n\nfunc UpdateRelease(rlsName string) (*rls.UpdateReleaseResponse, error) {\n\treturn NewClient(HelmHost(Config.ServAddr)).UpdateRelease(rlsName)\n}\n\n\n\nfunc InstallRelease(vals []byte, rlsName, chStr string, dryRun bool) (*rls.InstallReleaseResponse, error) {\n\tclient := NewClient(HelmHost(Config.ServAddr))\n\tif dryRun {\n\t\tclient.Option(DryRun())\n\t}\n\treturn client.InstallRelease(chStr, ValueOverrides(vals), ReleaseName(rlsName))\n}\n\n\n\nfunc UninstallRelease(rlsName string, dryRun bool) (*rls.UninstallReleaseResponse, error) {\n\tclient := NewClient(HelmHost(Config.ServAddr))\n\tif dryRun {\n\t\tclient.Option(DryRun())\n\t}\n\treturn client.DeleteRelease(rlsName)\n}\n\nfunc GetReleaseStatus(rlsName string) (*rls.GetReleaseStatusResponse, error) ", "output": "{\n\treturn NewClient(HelmHost(Config.ServAddr)).ReleaseStatus(rlsName)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n)\n\n\ntype Player struct {\n\tID             string\n\tName           string\n\tHealth         int\n\tHunger         int\n\tCriticalHunger bool\n\tNextAction     int\n\tDead           bool\n}\n\n\nfunc NewPlayer(ID, name string) *Player {\n\treturn &Player{ID, name, 100, 0, false, 0, false}\n}\n\nfunc (p *Player) String() string {\n\treturn fmt.Sprintf(\"[%-12s](HP: %3d)<Hunger: %3d>\", p.Name, p.Health, p.Hunger)\n}\n\n\n\n\n\nfunc (p *Player) AddHunger(amount int) int {\n\tp.Hunger += amount\n\tif p.Hunger >= 100 {\n\t\tp.Hunger = 100\n\t\tif p.CriticalHunger {\n\t\t\treturn 2\n\t\t}\n\t\tp.CriticalHunger = true\n\t\treturn 1\n\t}\n\tif p.Hunger <= 0 {\n\t\tp.Hunger = 0\n\t}\n\treturn 0\n}\n\nfunc (p *Player) AddHealth(amount int) bool ", "output": "{\n\tp.Health += amount\n\tif p.Health > 100 {\n\t\tp.Health = 100\n\t}\n\tif p.Health <= 0 {\n\t\tp.Health = 0\n\t\tp.Dead = true\n\t\treturn true\n\t}\n\treturn false\n}"}
{"input": "package common\n\nimport (\n  . \"launchpad.net/gocheck\"\n  \"sync\"\n)\n\ntype HealthzSuite struct {\n}\n\nvar _ = Suite(&HealthzSuite{})\n\nfunc (s *HealthzSuite) SetUpTest(c *C) {\n  Component = VcapComponent{\n    Config:      map[string]interface{}{\"ip\": \"localhost\", \"port\": 8080},\n  }\n}\n\n\n\nfunc (s *HealthzSuite) TestJsonMarshal(c *C) {\n  healthz := &Healthz{\n    LockableObject: &sync.Mutex{},\n  }\n  bytes, _ := healthz.MarshalJSON()\n  c.Assert(string(bytes), Equals, \"{\\\"health\\\":\\\"ok\\\"}\")\n}\n\nfunc (s *HealthzSuite) TearDownTest(c *C) ", "output": "{\n  Component = VcapComponent{}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\tprimes \"github.com/whatever/math/primes\"\n\t_ \"math\"\n\t\"sort\"\n)\n\n\n\nfunc SortedString(s string) string {\n\n\tintArray := make([]int, len(s))\n\n\tfor i, letter := range s {\n\t\tintArray[i] = int(letter)\n\t}\n\n\tsort.Ints(intArray)\n\n\tnewString := \"\"\n\n\tfor _, digit := range intArray {\n\t\tnewString += fmt.Sprintf(\"%s\", string(digit))\n\t}\n\n\treturn newString\n}\n\nfunc IsPermutation(lhs, rhs int) bool {\n\treturn SortedString(fmt.Sprintf(\"%d\", lhs)) == SortedString(fmt.Sprintf(\"%d\", rhs))\n}\n\nfunc main() {\n\tlimit := 1000000\n\ts := primes.NewNaiveSieve(limit)\n\thits := make(map[int]float64)\n\n\tminIndex := 200000000\n\tminValue := float64(limit + 1)\n\n\tfor i := 2; i <= limit; i++ {\n\t\tif i%(limit/100) == 0 {\n\t\t\tfmt.Println(i)\n\t\t}\n\n\t\ttotient := s.Totient(i)\n\t\tt := float64(i) / float64(totient)\n\t\thits[i] = t\n\n\t\tif !IsPermutation(totient, i) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif t < minValue {\n\t\t\tminValue = t\n\t\t\tminIndex = i\n\t\t\tfmt.Println(minIndex, minValue, i, totient)\n\t\t}\n\t}\n\n\tfmt.Println(minIndex, minValue)\n}\n\nfunc Factorial(n int) int ", "output": "{\n\tresult := 1\n\tfor n > 0 {\n\t\tresult *= n\n\t\tn--\n\t}\n\treturn result\n}"}
{"input": "package message\n\nimport (\n\t\"github.com/pinfake/pes6go/data/block\"\n)\n\ntype ServerNews struct {\n\tNews []*block.News\n}\n\n\n\nfunc NewServerNews(info []*block.News) ServerNews {\n\treturn ServerNews{info}\n}\n\nfunc (data ServerNews) GetBlocks() []*block.Block ", "output": "{\n\tvar blocks []*block.Block\n\tblocks = append(blocks, block.GetBlocks(0x2009, block.Uint32{0})...)\n\tblocks = append(blocks, block.GetBlocks(0x200a, data.News)...)\n\tblocks = append(blocks, block.GetBlocks(0x200b, block.Uint32{0})...)\n\treturn blocks\n}"}
{"input": "package generator\n\nimport (\n\tkapi \"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/api/rest\"\n\t\"k8s.io/kubernetes/pkg/runtime\"\n\n\tbuildapi \"github.com/openshift/origin/pkg/build/api\"\n\t\"github.com/openshift/origin/pkg/build/generator\"\n\t\"github.com/openshift/origin/pkg/build/registry/clone\"\n)\n\n\nfunc NewStorage(generator *generator.BuildGenerator) *CloneREST {\n\treturn &CloneREST{generator: generator}\n}\n\n\n\ntype CloneREST struct {\n\tgenerator *generator.BuildGenerator\n}\n\n\n\n\n\nfunc (s *CloneREST) Create(ctx kapi.Context, obj runtime.Object) (runtime.Object, error) {\n\tif err := rest.BeforeCreate(clone.Strategy, ctx, obj); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.generator.Clone(ctx, obj.(*buildapi.BuildRequest))\n}\n\nfunc (s *CloneREST) New() runtime.Object ", "output": "{\n\treturn &buildapi.BuildRequest{}\n}"}
{"input": "package v1\n\n\n\ntype PodAffinityApplyConfiguration struct {\n\tRequiredDuringSchedulingIgnoredDuringExecution  []PodAffinityTermApplyConfiguration         `json:\"requiredDuringSchedulingIgnoredDuringExecution,omitempty\"`\n\tPreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTermApplyConfiguration `json:\"preferredDuringSchedulingIgnoredDuringExecution,omitempty\"`\n}\n\n\n\nfunc PodAffinity() *PodAffinityApplyConfiguration {\n\treturn &PodAffinityApplyConfiguration{}\n}\n\n\n\n\nfunc (b *PodAffinityApplyConfiguration) WithRequiredDuringSchedulingIgnoredDuringExecution(values ...*PodAffinityTermApplyConfiguration) *PodAffinityApplyConfiguration {\n\tfor i := range values {\n\t\tif values[i] == nil {\n\t\t\tpanic(\"nil value passed to WithRequiredDuringSchedulingIgnoredDuringExecution\")\n\t\t}\n\t\tb.RequiredDuringSchedulingIgnoredDuringExecution = append(b.RequiredDuringSchedulingIgnoredDuringExecution, *values[i])\n\t}\n\treturn b\n}\n\n\n\n\n\n\nfunc (b *PodAffinityApplyConfiguration) WithPreferredDuringSchedulingIgnoredDuringExecution(values ...*WeightedPodAffinityTermApplyConfiguration) *PodAffinityApplyConfiguration ", "output": "{\n\tfor i := range values {\n\t\tif values[i] == nil {\n\t\t\tpanic(\"nil value passed to WithPreferredDuringSchedulingIgnoredDuringExecution\")\n\t\t}\n\t\tb.PreferredDuringSchedulingIgnoredDuringExecution = append(b.PreferredDuringSchedulingIgnoredDuringExecution, *values[i])\n\t}\n\treturn b\n}"}
{"input": "package sessions\n\n\nconst (\n\tExpirationAuth = 30 \n\tExpirationDefault = 60 * 60 * 24 \n\n\tValues = \"values\"\n\tMaxAge = \"max_age\"\n)\n\n\ntype Session struct {\n\tID     string                 \n\tMaxAge int64                  \n\tValues map[string]interface{} \n\tCache  map[string]interface{} \n\n\tstore Store\n}\n\n\nfunc New(store Store, id string) *Session {\n\treturn &Session{\n\t\tID:     id,\n\t\tValues: make(map[string]interface{}),\n\t\tCache:  make(map[string]interface{}),\n\t\tstore:  store,\n\t}\n}\n\n\n\n\n\nfunc (s *Session) SetExpiration(d int64) {\n\ts.MaxAge = d\n}\n\nfunc (s *Session) Save() error ", "output": "{\n\treturn s.store.Save(s.ID, s)\n}"}
{"input": "package state\n\nimport (\n\t\"time\"\n\n\t\"github.com/juju/errors\"\n\t\"gopkg.in/juju/names.v2\"\n\n\t\"github.com/juju/juju/core/lease\"\n)\n\n\n\n\n\n\n\n\n\ntype singularSecretary struct {\n\tuuid string\n}\n\n\nfunc (s singularSecretary) CheckLease(name string) error {\n\tif name != s.uuid {\n\t\treturn errors.New(\"expected environ UUID\")\n\t}\n\treturn nil\n}\n\n\nfunc (s singularSecretary) CheckHolder(name string) error {\n\tif _, err := names.ParseMachineTag(name); err != nil {\n\t\treturn errors.New(\"expected machine tag\")\n\t}\n\treturn nil\n}\n\n\n\n\n\n\nfunc (st *State) SingularClaimer() lease.Claimer {\n\treturn st.workers.singularManager()\n}\n\nfunc (s singularSecretary) CheckDuration(duration time.Duration) error ", "output": "{\n\tif duration <= 0 {\n\t\treturn errors.NewNotValid(nil, \"non-positive\")\n\t}\n\treturn nil\n}"}
{"input": "package debug\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\n\nfunc Configure(active bool) {\n\tisActive = active\n}\n\n\nfunc Printf(format string, args ...interface{}) {\n\tif isActive {\n\t\tlogger.Printf(format, args...)\n\t}\n}\n\n\nfunc Active() bool {\n\treturn isActive\n}\n\n\n\n\n\nvar (\n\tisActive bool\n\tlogger   *log.Logger\n)\n\n\n\nfunc init() ", "output": "{\n\tlogger = log.New(os.Stderr, \"\", 0)\n}"}
{"input": "package database\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype UpdateCloudVmClusterRequest struct {\n\n\tCloudVmClusterId *string `mandatory:\"true\" contributesTo:\"path\" name:\"cloudVmClusterId\"`\n\n\tUpdateCloudVmClusterDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request UpdateCloudVmClusterRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request UpdateCloudVmClusterRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request UpdateCloudVmClusterRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request UpdateCloudVmClusterRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype UpdateCloudVmClusterResponse struct {\n\n\tRawResponse *http.Response\n\n\tCloudVmCluster `presentIn:\"body\"`\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response UpdateCloudVmClusterResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\n\n\nfunc (response UpdateCloudVmClusterResponse) HTTPResponse() *http.Response ", "output": "{\n\treturn response.RawResponse\n}"}
{"input": "package test_helpers\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\tdatatypes \"github.com/maximilien/softlayer-go/data_types\"\n)\n\ntype MockProductPackageService struct{}\n\nfunc (mock *MockProductPackageService) GetName() string {\n\treturn \"Mock_Product_Package_Service\"\n}\n\nfunc (mock *MockProductPackageService) GetItemsByType(packageType string) ([]datatypes.SoftLayer_Product_Item, error) {\n\tresponse, _ := ReadJsonTestFixtures(\"services\", \"SoftLayer_Product_Package_getItemsByType_virtual_server.json\")\n\n\tproductItems := []datatypes.SoftLayer_Product_Item{}\n\tjson.Unmarshal(response, &productItems)\n\n\treturn productItems, nil\n}\n\nfunc (mock *MockProductPackageService) GetItemPrices(packageId int) ([]datatypes.SoftLayer_Product_Item_Price, error) {\n\treturn []datatypes.SoftLayer_Product_Item_Price{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetItemPricesBySize(packageId int, size int) ([]datatypes.SoftLayer_Product_Item_Price, error) {\n\treturn []datatypes.SoftLayer_Product_Item_Price{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetItems(packageId int) ([]datatypes.SoftLayer_Product_Item, error) {\n\treturn []datatypes.SoftLayer_Product_Item{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetPackagesByType(packageType string) ([]datatypes.Softlayer_Product_Package, error) {\n\treturn []datatypes.Softlayer_Product_Package{}, errors.New(\"Not supported\")\n}\n\n\n\nfunc (mock *MockProductPackageService) GetOnePackageByType(packageType string) (datatypes.Softlayer_Product_Package, error) ", "output": "{\n\treturn datatypes.Softlayer_Product_Package{}, errors.New(\"Not supported\")\n}"}
{"input": "package indicators\n\nimport (\n\t\"github.com/thetruetrade/gotrade\"\n)\n\n\ntype AvgPriceWithoutStorage struct {\n\t*baseIndicatorWithFloatBounds\n}\n\n\nfunc NewAvgPriceWithoutStorage(valueAvailableAction ValueAvailableActionFloat) (indicator *AvgPriceWithoutStorage, err error) {\n\n\tif valueAvailableAction == nil {\n\t\treturn nil, ErrValueAvailableActionIsNil\n\t}\n\n\tlookback := 0\n\tind := AvgPriceWithoutStorage{\n\t\tbaseIndicatorWithFloatBounds: newBaseIndicatorWithFloatBounds(lookback, valueAvailableAction),\n\t}\n\n\treturn &ind, nil\n}\n\n\ntype AvgPrice struct {\n\t*AvgPriceWithoutStorage\n\n\tData []float64\n}\n\n\nfunc NewAvgPrice() (indicator *AvgPrice, err error) {\n\tind := AvgPrice{}\n\tind.AvgPriceWithoutStorage, err = NewAvgPriceWithoutStorage(func(dataItem float64, streamBarIndex int) {\n\t\tind.Data = append(ind.Data, dataItem)\n\t})\n\n\treturn &ind, err\n}\n\n\nfunc NewAvgPriceWithSrcLen(sourceLength uint) (indicator *AvgPrice, err error) {\n\tind, err := NewAvgPrice()\n\tind.Data = make([]float64, 0, sourceLength)\n\n\treturn ind, err\n}\n\n\nfunc NewAvgPriceForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *AvgPrice, err error) {\n\tind, err := NewAvgPrice()\n\tpriceStream.AddTickSubscription(ind)\n\treturn ind, err\n}\n\n\n\n\n\nfunc (ind *AvgPriceWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) {\n\n\tresult := (tickData.O() + tickData.H() + tickData.L() + tickData.C()) / float64(4.0)\n\n\tind.UpdateIndicatorWithNewValue(result, streamBarIndex)\n}\n\nfunc NewAvgPriceForStreamWithSrcLen(sourceLength uint, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *AvgPrice, err error) ", "output": "{\n\tind, err := NewAvgPriceWithSrcLen(sourceLength)\n\tpriceStream.AddTickSubscription(ind)\n\treturn ind, err\n}"}
{"input": "package app\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/urfave/cli\"\n)\n\n\nfunc GenerateCommandsHelp(cmds []cli.Command) string {\n\tcommandsUsage := make([]string, 0, len(cmds))\n\tfor _, cmd := range cmds {\n\t\tcommandsUsage = append(commandsUsage, GenerateSubcommandsUsage(cmd, \"\")...)\n\t}\n\n\tsort.Strings(commandsUsage)\n\n\treturn \"   \" + strings.Join(commandsUsage, \"\\r\\n   \")\n}\n\n\n\n\nfunc GenerateSubcommandsUsage(cmd cli.Command, prefix string) (commandsUsage []string) ", "output": "{\n\tif cmd.Subcommands == nil || len(cmd.Subcommands) == 0 {\n\t\tfullName := prefix + cmd.Name\n\n\t\treturn []string{fullName + \": \" + cmd.Usage}\n\t}\n\tcommandsUsage = make([]string, 0, len(cmd.Subcommands))\n\tfor _, subcmd := range cmd.Subcommands {\n\t\tcommandsUsage = append(commandsUsage, GenerateSubcommandsUsage(subcmd, prefix+cmd.Name+\" \")...)\n\t}\n\treturn\n}"}
{"input": "package bleve\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n)\n\nfunc lookupPropertyPath(data interface{}, path string) interface{} {\n\tpathParts := decodePath(path)\n\n\tcurrent := data\n\tfor _, part := range pathParts {\n\t\tcurrent = lookupProptyPathPart(current, part)\n\t\tif current == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn current\n}\n\nfunc lookupProptyPathPart(data interface{}, part string) interface{} {\n\tval := reflect.ValueOf(data)\n\ttyp := val.Type()\n\tswitch typ.Kind() {\n\tcase reflect.Map:\n\t\tif typ.Key().Kind() == reflect.String {\n\t\t\tkey := reflect.ValueOf(part)\n\t\t\tentry := val.MapIndex(key)\n\t\t\tif entry.IsValid() {\n\t\t\t\treturn entry.Interface()\n\t\t\t}\n\t\t}\n\tcase reflect.Struct:\n\t\tfield := val.FieldByName(part)\n\t\tif field.IsValid() && field.CanInterface() {\n\t\t\treturn field.Interface()\n\t\t}\n\t}\n\treturn nil\n}\n\nconst pathSeparator = \".\"\n\nfunc decodePath(path string) []string {\n\treturn strings.Split(path, pathSeparator)\n}\n\nfunc encodePath(pathElements []string) string {\n\treturn strings.Join(pathElements, pathSeparator)\n}\n\n\n\n\nfunc parseJSONTagName(tag string) string {\n\tif idx := strings.Index(tag, \",\"); idx != -1 {\n\t\treturn tag[:idx]\n\t}\n\treturn tag\n}\n\nfunc mustString(data interface{}) (string, bool) ", "output": "{\n\tif data != nil {\n\t\tstr, ok := data.(string)\n\t\tif ok {\n\t\t\treturn str, true\n\t\t}\n\t}\n\treturn \"\", false\n}"}
{"input": "package extensions\n\nimport (\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/api/unversioned\"\n)\n\n\nvar SchemeGroupVersion = unversioned.GroupVersion{Group: \"extensions\", Version: \"\"}\n\n\n\n\nfunc addKnownTypes() {\n\tapi.Scheme.AddKnownTypes(SchemeGroupVersion,\n\t\t&ClusterAutoscaler{},\n\t\t&ClusterAutoscalerList{},\n\t\t&Deployment{},\n\t\t&DeploymentList{},\n\t\t&HorizontalPodAutoscaler{},\n\t\t&HorizontalPodAutoscalerList{},\n\t\t&Job{},\n\t\t&JobList{},\n\t\t&ReplicationControllerDummy{},\n\t\t&Scale{},\n\t\t&ThirdPartyResource{},\n\t\t&ThirdPartyResourceList{},\n\t\t&DaemonSetList{},\n\t\t&DaemonSet{},\n\t\t&ThirdPartyResourceData{},\n\t\t&ThirdPartyResourceDataList{},\n\t\t&Ingress{},\n\t\t&IngressList{},\n\t)\n}\n\nfunc (*ClusterAutoscaler) IsAnAPIObject()           {}\nfunc (*ClusterAutoscalerList) IsAnAPIObject()       {}\nfunc (*Deployment) IsAnAPIObject()                  {}\nfunc (*DeploymentList) IsAnAPIObject()              {}\nfunc (*HorizontalPodAutoscaler) IsAnAPIObject()     {}\nfunc (*HorizontalPodAutoscalerList) IsAnAPIObject() {}\nfunc (*Job) IsAnAPIObject()                         {}\nfunc (*JobList) IsAnAPIObject()                     {}\nfunc (*ReplicationControllerDummy) IsAnAPIObject()  {}\nfunc (*Scale) IsAnAPIObject()                       {}\nfunc (*ThirdPartyResource) IsAnAPIObject()          {}\nfunc (*ThirdPartyResourceList) IsAnAPIObject()      {}\nfunc (*DaemonSet) IsAnAPIObject()                   {}\nfunc (*DaemonSetList) IsAnAPIObject()               {}\nfunc (*ThirdPartyResourceData) IsAnAPIObject()      {}\nfunc (*ThirdPartyResourceDataList) IsAnAPIObject()  {}\nfunc (*Ingress) IsAnAPIObject()                     {}\nfunc (*IngressList) IsAnAPIObject()                 {}\n\nfunc init() ", "output": "{\n\taddKnownTypes()\n}"}
{"input": "package utils\n\nimport (\n\t\"bufio\"\n\t\"flag\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar path string\n\nfunc init() {\n\tflag.StringVar(&path, \"path\", \"\", \"Path to the inputfile\")\n\tflag.Parse()\n}\n\ntype Input struct {\n\t*bufio.Scanner\n}\n\n\nfunc GetInput() (*Input, error) {\n\tif len(path) > 0 {\n\t\tfile, err := os.Open(path)\n\t\tif err != nil {\n\t\t\treturn &Input{}, err\n\t\t}\n\n\t\treturn &Input{bufio.NewScanner(file)}, nil\n\t}\n\treturn &Input{bufio.NewScanner(os.Stdin)}, nil\n}\n\nfunc (input *Input) ReadInt() int {\n\tinput.Split(bufio.ScanWords)\n\n\tif input.Scan() {\n\t\tresult, err := strconv.Atoi(input.Text())\n\t\tif err == nil {\n\t\t\treturn result\n\t\t}\n\t}\n\n\treturn 3\n}\n\nfunc (input *Input) ReadInts(size int) []int {\n\tinput.Split(bufio.ScanWords)\n\tints := make([]int, size)\n\n\tfor i := 0; i < size && input.Scan(); i++ {\n\t\tresult, err := strconv.Atoi(input.Text())\n\t\tif err == nil {\n\t\t\tints[i] = result\n\t\t}\n\t}\n\n\treturn ints\n}\n\nfunc (input *Input) ReadString() string {\n\tinput.Split(bufio.ScanWords)\n\n\tif input.Scan() {\n\t\treturn input.Text()\n\t}\n\n\treturn \"\"\n}\n\n\n\nfunc (input *Input) ReadStrings(size int) []string ", "output": "{\n\tinput.Split(bufio.ScanWords)\n\n\tstrings := make([]string, size)\n\n\tfor i := 0; i < size && input.Scan(); i++ {\n\t\tstrings[i] = input.Text()\n\t}\n\n\treturn strings\n}"}
{"input": "package journal\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\nconst (\n\tInternalPrefix = \"/ctl\"\n\n\tEntryEnd = \"\\n\"\n\n\tFieldSeparator string = \"|\"\n)\n\n\ntype Journal struct {\n\twriter io.Writer\n}\n\n\nfunc New(w io.Writer) *Journal {\n\treturn &Journal{\n\t\twriter: w,\n\t}\n}\n\n\n\n\nfunc (j *Journal) Append(entry *Entry) error ", "output": "{\n\tif !strings.HasPrefix(entry.Path, InternalPrefix) {\n\t\tpayload, err := Marshal(entry)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tline := fmt.Sprintf(\"%08d %s%s\", len(payload), payload, EntryEnd)\n\n\t\t_, err = j.writer.Write([]byte(line))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Unable to append '%s' to journal: %s\", string(payload), err)\n\t\t}\n\t}\n\n\treturn nil\n}"}
{"input": "package build\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestVersionCmp(t *testing.T) {\n\tversionTests := []struct {\n\t\ta, b string\n\t\texp  int\n\t}{\n\t\t{\"0.1\", \"0.0.9\", 1},\n\t\t{\"0.1\", \"0.1\", 0},\n\t\t{\"0.1\", \"0.1.1\", -1},\n\t\t{\"0.1\", \"0.1.0\", -1},\n\t\t{\"0.1\", \"1.1\", -1},\n\t\t{\"0.1.1.0\", \"0.1.1\", 1},\n\t}\n\n\tfor _, test := range versionTests {\n\t\tif actual := VersionCmp(test.a, test.b); actual != test.exp {\n\t\t\tt.Errorf(\"Comparing %v to %v should return %v (got %v)\", test.a, test.b, test.exp, actual)\n\t\t}\n\t}\n}\n\n\n\n\nfunc TestIsVersion(t *testing.T) ", "output": "{\n\tversionTests := []struct {\n\t\tstr string\n\t\texp bool\n\t}{\n\t\t{\"1.0\", true},\n\t\t{\"1\", true},\n\t\t{\"0.1.2.3.4.5\", true},\n\n\t\t{\"foo\", false},\n\t\t{\".1\", false},\n\t\t{\"1.\", false},\n\t\t{\"a.b\", false},\n\t\t{\"1.o\", false},\n\t\t{\".\", false},\n\t\t{\"\", false},\n\t}\n\n\tfor _, test := range versionTests {\n\t\tif IsVersion(test.str) != test.exp {\n\t\t\tt.Errorf(\"IsVersion(%v) should return %v\", test.str, test.exp)\n\t\t}\n\t}\n}"}
{"input": "package cli\n\nimport (\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n)\n\n\n\nfunc Test_Run(t *testing.T) ", "output": "{\n\tcmd := strings.Fields(\"test render -a ~/memorybox -l ../../../goingslowly/templates -l ../../../goingslowly/resources -o ../../../goingslowly/build/goingslowly.com website/content/v1/domain/goingslowly\")\n\tstdin, err := os.Open(\"../../../goingslowly/build/index\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif code := Run(cmd, stdin, os.Stdout, os.Stderr); code != 0 {\n\t\tt.Fatalf(\"exited with %d\", code)\n\t}\n}"}
{"input": "package ora\n\nimport \"github.com/rainycape/dl\"\n\nvar (\n\tociLibrary = NewLazyDLL(\"libclntsh.so\")\n)\n\n\ntype Library struct {\n\tdll *dl.DL\n}\n\n\nfunc NewLazyDLL(name string) (dll *Library) {\n\tdll = new(Library)\n\tvar err error\n\tif dll.dll, err = dl.Open(name, dl.RTLD_LAZY); err != nil {\n\t\tpanic(err)\n\t}\n\treturn\n}\n\n\n\n\n\ntype LibraryProc struct {\n\terr error\n\tfn  func(...uintptr) uintptr\n}\n\n\nfunc (lib LibraryProc) Call(args ...uintptr) (r1 uintptr, r2 uintptr, err error) {\n\terr = lib.err\n\tr1 = lib.fn(args...)\n\treturn\n}\n\nfunc (lib *Library) NewProc(name string) *LibraryProc ", "output": "{\n\tcallee := new(LibraryProc)\n\tcallee.err = lib.dll.Sym(name, &callee.fn)\n\treturn callee\n}"}
{"input": "package balanced\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\n\ntype Credit struct {\n\tAmount               int               `json:\"amount,omitempty\"`\n\tAppearsOnStatementAs string            `json:\"appears_on_statement_as,omitempty\"`\n\tCreatedAt            time.Time         `json:\"created_at,omitempty\"`\n\tCurrency             string            `json:\"currency,omitempty\"`\n\tDescription          string            `json:\"description,omitempty\"`\n\tExpiresAt            time.Time         `json:\"expires_at,omitempty\"`\n\tFailureReason        string            `json:\"failure_reason,omitempty\"`\n\tFailureReasonCode    int               `json:\"failure_reason_code,omitempty\"`\n\tID                   string            `json:\"id,omitempty\"`\n\tMeta                 map[string]string `json:\"meta,omitempty\"`\n\tStatus               string            `json:\"status,omitempty\"`\n\tTransactionNumber    string            `json:\"transaction_number,omitempty\"`\n\tUpdatedAt            time.Time         `json:\"updated_at,omitempty\"`\n\tOwner                Resourcer         `json:\"-\"`\n}\n\ntype creditResponse struct {\n\tCredits []*Credit `json:\"credits\"`\n}\n\nfunc (c *Credit) path() string {\n\treturn \"/credits\"\n}\n\nfunc (c *Credit) getID() string {\n\treturn c.ID\n}\n\n\n\nfunc (c *Credit) singleResponse(data []byte) {\n\tparsedResponse := new(creditResponse)\n\tjson.Unmarshal(data, &parsedResponse)\n\t*c = *parsedResponse.Credits[0]\n}\n\nfunc (c *Credit) getOwnerPath() string ", "output": "{\n\tif c.Owner == nil {\n\t\treturn \"\"\n\t}\n\treturn c.Owner.path() + \"/\" + c.Owner.getID()\n}"}
{"input": "package utils\n\nimport \"time\"\n\n\n\n\n\n\nfunc GetUnixEpoch() int64 {\n\treturn GetUnixEpochFrom(time.Now())\n}\n\nfunc GetUnixEpochFrom(now time.Time) int64 ", "output": "{\n\treturn now.UnixNano()\n}"}
{"input": "package data\n\ntype info struct {\n\ttag, unit string \n\tmesh Mesh\n}\n\n\nfunc (i *info) Tag() string { return i.tag }\n\n\nfunc (i *info) Unit() string { return i.unit }\n\n\n\n\nfunc (i *info) Mesh() *Mesh ", "output": "{ return &(i.mesh) }"}
{"input": "package cache\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestWithCache(t *testing.T) {\n\tctx := WithCache(context.Background(), Null)\n\n\tgot := ctx.Value(ctxKey)\n\n\tassert.Equal(t, Null, got)\n}\n\nfunc TestFromContext(t *testing.T) {\n\tctx := context.WithValue(context.Background(), ctxKey, Null)\n\n\tgot, ok := FromContext(ctx)\n\n\tassert.True(t, ok)\n\tassert.Equal(t, Null, got)\n}\n\nfunc TestFromContext_NotSet(t *testing.T) {\n\tctx := context.Background()\n\n\tgot, ok := FromContext(ctx)\n\n\tassert.False(t, ok)\n\tassert.Nil(t, got)\n}\n\n\n\nfunc TestGetCache(t *testing.T) ", "output": "{\n\ttests := []struct {\n\t\tctx    context.Context\n\t\texpect Cache\n\t}{\n\t\t{context.Background(), Null},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := getCache(tt.ctx)\n\n\t\tassert.Equal(t, tt.expect, got)\n\t}\n}"}
{"input": "package daemon\n\nimport (\n\tcontainertypes \"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/container\"\n\t\"github.com/docker/docker/libcontainerd\"\n\t\"github.com/docker/docker/oci\"\n)\n\n\n\n\n\nfunc (daemon *Daemon) mergeUlimits(c *containertypes.HostConfig) {\n\treturn\n}\n\nfunc (daemon *Daemon) createSpec(c *container.Container) (*libcontainerd.Spec, error) ", "output": "{\n\ts := oci.DefaultSpec()\n\treturn (*libcontainerd.Spec)(&s), nil\n}"}
{"input": "package models\n\nimport (\n\t\"fmt\"\n\t\"github.com/APTrust/exchange/util\"\n\t\"github.com/APTrust/exchange/util/s3util\"\n\t\"github.com/crowdmob/goamz/s3\"\n\t\"time\"\n)\n\n\n\n\n\n\n\n\n\n\ntype S3File struct {\n\tBucketName string\n\n\tKey s3.Key\n\n\tErrorMessage string\n\n\tDeletedAt time.Time\n\n\tDeleteSkippedPerConfig bool\n}\n\n\n\nfunc NewS3FileWithName(bucketName, keyName string) *S3File {\n\treturn &S3File{\n\t\tBucketName: bucketName,\n\t\tKey:        s3.Key{Key: keyName},\n\t}\n}\n\n\n\n\n\n\n\nfunc (s3File *S3File) ObjectName() (string, error) {\n\tinstitution := util.OwnerOf(s3File.BucketName)\n\tcleanBagName := util.CleanBagName(s3File.Key.Key)\n\treturn fmt.Sprintf(\"%s/%s\", institution, cleanBagName), nil\n}\n\n\n\n\nfunc (s3File *S3File) BagName() string {\n\treturn fmt.Sprintf(\"%s/%s\", util.OwnerOf(s3File.BucketName), s3File.Key.Key)\n}\n\n\nfunc (s3File *S3File) DeleteAttempted() bool {\n\treturn s3File.ErrorMessage != \"\" || s3File.DeletedAt.IsZero() == false\n}\n\n\n\nfunc (s3File *S3File) KeyIsComplete() bool {\n\treturn s3util.KeyIsComplete(s3File.Key)\n}\n\nfunc NewS3FileWithKey(bucketName string, key s3.Key) *S3File ", "output": "{\n\treturn &S3File{\n\t\tBucketName: bucketName,\n\t\tKey:        key,\n\t}\n}"}
{"input": "package kata\n\n\n\nfunc Number(busStops [][]int) int ", "output": "{\n  totalPeople := 0\n  \n  for _, stop := range busStops {\n    totalPeople += stop[0]\n    totalPeople -= stop[1]\n  }\n  \n  return totalPeople\n}"}
{"input": "package state\n\nimport (\n\t\"strconv\"\n\t. \"bugnuts/maps\"\n\t. \"bugnuts/torus\"\n\t. \"bugnuts/util\"\n)\n\nfunc (s *State) FoodLocations() (l []Location) {\n\tfor loc := range s.Food {\n\t\tl = append(l, Location(loc))\n\t}\n\n\treturn l\n}\n\nfunc (s *State) HillLocations(player int) (l []Location) {\n\tfor loc, hill := range s.Hills {\n\t\tif hill.Player == player && hill.Killed == 0 {\n\t\t\tl = append(l, Location(loc))\n\t\t}\n\t}\n\n\treturn l\n}\n\nfunc (s *State) EnemyHillLocations(player int) (l []Location) {\n\tfor loc, hill := range s.Hills {\n\t\tif hill.Player != player && hill.Killed == 0 {\n\t\t\tl = append(l, Location(loc))\n\t\t}\n\t}\n\n\treturn l\n}\n\n\n\nfunc (s *State) Stepable(loc Location) bool {\n\ti := s.Map.Grid[loc]\n\n\treturn i != WATER && i != BLOCK && i != FOOD\n}\n\nfunc (m *Metrics) DumpSeen() string {\n\tmax := Max(m.Seen)\n\tstr := \"\"\n\n\tfor r := 0; r < m.Rows; r++ {\n\t\tfor c := 0; c < m.Cols; c++ {\n\t\t\tstr += strconv.Itoa(m.Seen[r*m.Cols+c] * 10 / (max + 1))\n\t\t}\n\t\tstr += \"\\n\"\n\t}\n\n\treturn str\n}\n\nfunc (s *State) ValidStep(loc Location) bool ", "output": "{\n\ti := s.Map.Grid[loc]\n\n\treturn i != WATER && i != BLOCK && i != OCCUPIED && i != FOOD && i != MY_ANT && i != MY_HILLANT\n}"}
{"input": "package daemon\n\nimport derr \"github.com/docker/docker/errors\"\n\n\n\n\n\n\n\n\nfunc (daemon *Daemon) ContainerExecResize(name string, height, width int) error {\n\tExecConfig, err := daemon.getExecConfig(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ExecConfig.Resize(height, width)\n}\n\nfunc (daemon *Daemon) ContainerResize(name string, height, width int) error ", "output": "{\n\tcontainer, err := daemon.GetContainer(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !container.IsRunning() {\n\t\treturn derr.ErrorCodeNotRunning.WithArgs(container.ID)\n\t}\n\n\tif err = container.Resize(height, width); err == nil {\n\t\tdaemon.LogContainerEvent(container, \"resize\")\n\t}\n\treturn err\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/spf13/cobra\"\n)\n\nvar (\n\tcmdSetName = &cobra.Command{\n\t\tUse:     \"set-name ACI_NAME\",\n\t\tShort:   \"Set the image name\",\n\t\tLong:    \"Sets the name of the ACI in the manifest\",\n\t\tExample: \"acbuild set-name quay.io/coreos/etcd\",\n\t\tRun:     runWrapper(runSetName),\n\t}\n)\n\nfunc init() {\n\tcmdAcbuild.AddCommand(cmdSetName)\n}\n\n\n\nfunc runSetName(cmd *cobra.Command, args []string) (exit int) ", "output": "{\n\tif len(args) > 1 {\n\t\tstderr(\"set-name: incorrect number of arguments\")\n\t\treturn 1\n\t}\n\tif len(args) == 0 {\n\t\tcmd.Usage()\n\t\treturn 1\n\t}\n\n\tif debug {\n\t\tstderr(\"Setting name of ACI to %s\", args[0])\n\t}\n\n\terr := newACBuild().SetName(args[0])\n\n\tif err != nil {\n\t\tstderr(\"set-name: %v\", err)\n\t\treturn getErrorCode(err)\n\t}\n\n\treturn 0\n}"}
{"input": "package ast\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype StructTypeSpecTestSuite struct {\n\tsuite.Suite\n}\n\n\n\nfunc (s *StructTypeSpecTestSuite) TestName() {\n\tspec, err := FindJSONStructFor(\"github.com/marcel/jitjson/fixtures/media\", \"Album\")\n\ts.Nil(err)\n\n\ts.Equal(\"Album\", spec.Name())\n}\n\nfunc TestStructTypeSpecTestSuite(t *testing.T) ", "output": "{\n\tsuite.Run(t, new(StructTypeSpecTestSuite))\n}"}
{"input": "package perftests\n\nimport (\n\t\"testing\"\n\n\t\"istio.io/istio/mixer/pkg/perf\"\n)\n\n\n\n\n\nvar baseSingleReportSetup = perf.Setup{\n\tConfig: perf.Config{\n\t\tGlobal:         minimalServiceConfig,\n\t\tService:        joinConfigs(h1Noop, i1ReportNothing, r1UsingH1AndI1),\n\t\tSingleThreaded: true,\n\t},\n\n\tLoads: []perf.Load{{\n\t\tMultiplier: 1,\n\t\tRequests: []perf.Request{\n\t\t\tperf.BasicReport{\n\t\t\t\tAttributes: map[string]interface{}{\n\t\t\t\t\t\"attr.bool\":   false,\n\t\t\t\t\t\"attr.string\": \"str1\",\n\t\t\t\t\t\"attr.double\": float64(23.45),\n\t\t\t\t\t\"attr.int64\":  int64(42),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}},\n}\n\nfunc Benchmark_Single_Report(b *testing.B) {\n\tsettings := baseSettings\n\tsettings.RunMode = perf.InProcessBypassGrpc\n\n\tsetup := baseSingleReportSetup\n\tperf.Run(b, &setup, settings)\n}\n\nfunc Benchmark_Single_Report_Rpc(b *testing.B) {\n\tsettings := baseSettings\n\tsettings.RunMode = perf.InProcess\n\n\tsetup := baseSingleReportSetup\n\n\tperf.Run(b, &setup, settings)\n}\n\n\n\nfunc Benchmark_Single_Report_SuccessCondition_Rpc(b *testing.B) {\n\tsettings := baseSettings\n\tsettings.RunMode = perf.InProcess\n\n\tsetup := baseSingleReportSetup\n\tsetup.Config.Global = joinConfigs(h1Noop, i1ReportNothing, r3UsingH1AndI1Conditional)\n\n\tperf.Run(b, &setup, settings)\n}\n\nfunc Benchmark_Single_Report_SuccessCondition(b *testing.B) ", "output": "{\n\tsettings := baseSettings\n\tsettings.RunMode = perf.InProcessBypassGrpc\n\n\tsetup := baseSingleReportSetup\n\tsetup.Config.Global = joinConfigs(h1Noop, i1ReportNothing, r3UsingH1AndI1Conditional)\n\n\tperf.Run(b, &setup, settings)\n}"}
{"input": "package calendar\n\nimport (\n\t\"time\"\n)\n\nvar (\n\tentries = make(map[int]Entry)\n\tindex   int\n)\n\ntype Entry struct {\n\tID       int\n\tTitle    string\n\tStarts   time.Time\n\tFinishes time.Time\n}\n\nfunc (e Entry) Duration() time.Duration {\n\treturn e.Finishes.Sub(e.Starts)\n}\n\nfunc Lookup(id int) (Entry, bool) {\n\te, isPresent := entries[id]\n\treturn e, isPresent\n}\n\n\n\nfunc Update(e Entry) {\n\tentries[e.ID] = e\n}\n\nfunc Remove(id int) {\n\tdelete(entries, id)\n}\n\nfunc Count() int {\n\treturn len(entries)\n}\n\nfunc All() []Entry {\n\tall := []Entry{}\n\tfor _, e := range entries {\n\t\tall = append(all, e)\n\t}\n\treturn all\n}\n\nfunc Add(e Entry) Entry ", "output": "{\n\tindex++\n\te.ID = index\n\tUpdate(e)\n\treturn e\n}"}
{"input": "package luhn\n\nimport \"testing\"\n\nvar validTests = []struct {\n\tn  string\n\tok bool\n}{\n\t{\"738\", false},\n\t{\"8739567\", true},\n\t{\"1111\", false},\n\t{\"8763\", true},\n\t{\"    \", false},\n\t{\"\", false},\n\t{\"2323 2005 7766 3554\", true},\n}\n\nvar addTests = []struct{ raw, luhn string }{\n\t{\"123\", \"1230\"},\n\t{\"873956\", \"8739567\"},\n\t{\"837263756\", \"8372637564\"},\n\t{\"2323 2005 7766 355\", \"2323 2005 7766 3554\"},\n}\n\nfunc TestValid(t *testing.T) {\n\tfor _, test := range validTests {\n\t\tif ok := Valid(test.n); ok != test.ok {\n\t\t\tt.Fatalf(\"Valid(%s) = %t, want %t.\", test.n, ok, test.ok)\n\t\t}\n\t}\n}\n\n\n\nfunc BenchmarkValid(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tValid(\"2323 2005 7766 3554\")\n\t}\n}\n\nfunc BenchmarkAddCheck(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tAddCheck(\"2323 2005 7766 355\")\n\t}\n}\n\nfunc TestAddCheck(t *testing.T) ", "output": "{\n\tfor _, test := range addTests {\n\t\tif luhn := AddCheck(test.raw); luhn != test.luhn {\n\t\t\tt.Fatalf(\"AddCheck(%s) = %s, want %s.\", test.raw, luhn, test.luhn)\n\t\t}\n\t}\n}"}
{"input": "package gocd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestAuthentication(t *testing.T) {\n\tsetup()\n\tdefer teardown()\n\n\tt.Run(\"Login\", testAuthenticationLogin)\n\tt.Run(\"LoginFail\", testAuthenticationLoginFail)\n}\n\n\n\nfunc testAuthenticationLogin(t *testing.T) {\n\n\tmockCookie := \"JSESSIONID=hash;Path=/go;Expires=Mon, 15-Jun-2015 10:16:20 GMT\"\n\n\tmux.HandleFunc(\"/api/api/agents\", func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Contains(t, r.Header[\"Accept\"], \"application/vnd.go.cd.v2+json\")\n\t\tassert.Equal(t, r.Method, \"GET\", \"Unexpected HTTP method\")\n\t\ttestAuth(t, r, mockAuthorization)\n\n\t\tw.Header().Set(\"Set-Cookie\", mockCookie)\n\n\t\tj, _ := ioutil.ReadFile(\"test/resources/agents.0.json\")\n\t\tfmt.Fprint(w, string(j))\n\t})\n\n\tclient.Login(context.Background())\n\n\tassert.Equal(t, client.cookie, mockCookie)\n\n}\n\nfunc testAuthenticationLoginFail(t *testing.T) ", "output": "{\n\tenv := os.Getenv(\"GOCD_RAISE_ERROR_NEW_REQUEST\")\n\tos.Setenv(\"GOCD_RAISE_ERROR_NEW_REQUEST\", \"yes\")\n\n\terr := client.Login(context.Background())\n\tassert.EqualError(t, err, \"Mock Testing Error\")\n\n\tos.Setenv(\"GOCD_RAISE_ERROR_NEW_REQUEST\", env)\n}"}
{"input": "package sortedmap\n\nimport (\n\t\"testing\"\n\n\t\"github.com/umpc/go-sortedmap/asc\"\n)\n\nfunc insertRecord(b *testing.B) {\n\trecords := randRecords(1)\n\tsm := New(0, asc.Time)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsm.Insert(records[0].Key, records[0].Val)\n\n\t\tb.StopTimer()\n\t\trecords = randRecords(1)\n\t\tsm = New(0, asc.Time)\n\t\tb.StartTimer()\n\t}\n}\n\nfunc batchInsertRecords(b *testing.B, n int) {\n\trecords := randRecords(n)\n\tsm := New(0, asc.Time)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsm.BatchInsert(records)\n\n\t\tb.StopTimer()\n\t\trecords = randRecords(n)\n\t\tsm = New(0, asc.Time)\n\t\tb.StartTimer()\n\t}\n}\n\nfunc BenchmarkInsert1Record(b *testing.B) {\n\tinsertRecord(b)\n}\n\nfunc BenchmarkBatchInsert10Records(b *testing.B) {\n\tbatchInsertRecords(b, 10)\n}\n\n\n\nfunc BenchmarkBatchInsert1000Records(b *testing.B) {\n\tbatchInsertRecords(b, 1000)\n}\n\nfunc BenchmarkBatchInsert10000Records(b *testing.B) {\n\tbatchInsertRecords(b, 10000)\n}\n\nfunc BenchmarkBatchInsert100Records(b *testing.B) ", "output": "{\n\tbatchInsertRecords(b, 100)\n}"}
{"input": "package main\n\nimport (\n\t. \"github.com/conclave/pcduino/core\"\n)\n\n\n\nfunc main() {\n\tfor {\n\t\tloop()\n\t}\n}\n\nfunc setup() {\n}\n\nfunc loop() {\n\tDelay(100)\n}\n\nfunc init() ", "output": "{\n\tInit()\n\tsetup()\n}"}
{"input": "package model\n\nimport (\n\t\"database/sql\"\n)\n\n\ntype User struct {\n\tID string\n}\n\n\nfunc NewUser() *User {\n\treturn &User{\n\t\tID: NewULID(),\n\t}\n}\n\n\nfunc FindUser(db *sql.DB, id string) (*User, error) {\n\trow := db.QueryRow(\"SELECT * FROM users WHERE id = $1\", id)\n\tvar ID string\n\terr := row.Scan(&ID)\n\treturn &User{ID}, err\n}\n\n\n\nfunc UserExists(db *sql.DB, id string) (bool, error) {\n\trow := db.QueryRow(\n\t\t\"SELECT EXISTS(SELECT 1 FROM users WHERE id = $1)\",\n\t\tid,\n\t)\n\tvar exists bool\n\terr := row.Scan(&exists)\n\treturn exists, err\n}\n\n\n\n\n\nfunc (u *User) Delete(db *sql.DB) error {\n\t_, err := db.Exec(\n\t\t\"DELETE FROM users WHERE id = $1\",\n\t\tu.ID,\n\t)\n\treturn err\n}\n\nfunc (u *User) Save(db *sql.DB) error ", "output": "{\n\t_, err := db.Exec(\n\t\t\"INSERT INTO users VALUES ($1)\",\n\t\tu.ID,\n\t)\n\treturn err\n}"}
{"input": "package http2\n\nimport \"testing\"\n\nfunc TestFlow(t *testing.T) {\n\tvar st flow\n\tvar conn flow\n\tst.add(3)\n\tconn.add(2)\n\n\tif got, want := st.available(), int32(3); got != want {\n\t\tt.Errorf(\"available = %d; want %d\", got, want)\n\t}\n\tst.setConnFlow(&conn)\n\tif got, want := st.available(), int32(2); got != want {\n\t\tt.Errorf(\"after parent setup, available = %d; want %d\", got, want)\n\t}\n\n\tst.take(2)\n\tif got, want := conn.available(), int32(0); got != want {\n\t\tt.Errorf(\"after taking 2, conn = %d; want %d\", got, want)\n\t}\n\tif got, want := st.available(), int32(0); got != want {\n\t\tt.Errorf(\"after taking 2, stream = %d; want %d\", got, want)\n\t}\n}\n\n\n\nfunc TestFlowAdd(t *testing.T) ", "output": "{\n\tvar f flow\n\tif !f.add(1) {\n\t\tt.Fatal(\"failed to add 1\")\n\t}\n\tif !f.add(-1) {\n\t\tt.Fatal(\"failed to add -1\")\n\t}\n\tif got, want := f.available(), int32(0); got != want {\n\t\tt.Fatalf(\"size = %d; want %d\", got, want)\n\t}\n\tif !f.add(1<<31 - 1) {\n\t\tt.Fatal(\"failed to add 2^31-1\")\n\t}\n\tif got, want := f.available(), int32(1<<31-1); got != want {\n\t\tt.Fatalf(\"size = %d; want %d\", got, want)\n\t}\n\tif f.add(1) {\n\t\tt.Fatal(\"adding 1 to max shouldn't be allowed\")\n\t}\n\n}"}
{"input": "package _9_queue\n\nimport \"fmt\"\n\ntype CircularQueue struct {\n\tq        []interface{}\n\tcapacity int\n\thead     int\n\ttail     int\n}\n\nfunc NewCircularQueue(n int) *CircularQueue {\n\tif n == 0 {\n\t\treturn nil\n\t}\n\treturn &CircularQueue{make([]interface{}, n), n, 0, 0}\n}\n\n\nfunc (this *CircularQueue) IsEmpty() bool {\n\tif this.head == this.tail {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\nfunc (this *CircularQueue) IsFull() bool {\n\tif this.head == (this.tail+1)%this.capacity {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (this *CircularQueue) EnQueue(v interface{}) bool {\n\tif this.IsFull() {\n\t\treturn false\n\t}\n\tthis.q[this.tail] = v\n\tthis.tail = (this.tail + 1) % this.capacity\n\treturn true\n}\n\n\n\nfunc (this *CircularQueue) String() string {\n\tif this.IsEmpty() {\n\t\treturn \"empty queue\"\n\t}\n\tresult := \"head\"\n\tvar i = this.head\n\tfor true {\n\t\tresult += fmt.Sprintf(\"<-%+v\", this.q[i])\n\t\ti = (i + 1) % this.capacity\n\t\tif i == this.tail {\n\t\t\tbreak\n\t\t}\n\t}\n\tresult += \"<-tail\"\n\treturn result\n}\n\nfunc (this *CircularQueue) DeQueue() interface{} ", "output": "{\n\tif this.IsEmpty() {\n\t\treturn nil\n\t}\n\tv := this.q[this.head]\n\tthis.head = (this.head + 1) % this.capacity\n\treturn v\n}"}
{"input": "package core\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\ntype recorder struct {\n\tfileName string\n\tinnerWriter io.WriteCloser\n}\n\n\nfunc newRecorder(fileName string) *recorder {\n\tr := recorder{}\n\tr.fileName = fileName\n\treturn &r\n}\n\n\nfunc (this *recorder) createFile() (e error) {\n\tfolder, _ := filepath.Split(this.fileName)\n\tif 0 != len(folder) {\n\t\te = os.MkdirAll(folder, 0767)\n\t\tif e != nil {\n\t\t\treturn e\n\t\t}\n\t}\n\tthis.innerWriter, e = os.OpenFile(this.fileName, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0666)\n\tif e != nil {\n\t\treturn e\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc (this *recorder) Close() (e error) {\n\treturn this.innerWriter.Close()\n}\n\nfunc (this *recorder) Write(data []byte) (int, error) ", "output": "{\n\tif this.innerWriter == nil {\n\t\tif e := this.createFile(); e != nil {\n\t\t\treturn 0, e\n\t\t}\n\t}\n\treturn this.innerWriter.Write(data)\n}"}
{"input": "package challenge\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-acme/lego/acme\"\n)\n\n\ntype Type string\n\nconst (\n\tHTTP01 = Type(\"http-01\")\n\n\tDNS01 = Type(\"dns-01\")\n\n\tTLSALPN01 = Type(\"tls-alpn-01\")\n)\n\nfunc (t Type) String() string {\n\treturn string(t)\n}\n\nfunc FindChallenge(chlgType Type, authz acme.Authorization) (acme.Challenge, error) {\n\tfor _, chlg := range authz.Challenges {\n\t\tif chlg.Type == string(chlgType) {\n\t\t\treturn chlg, nil\n\t\t}\n\t}\n\n\treturn acme.Challenge{}, fmt.Errorf(\"[%s] acme: unable to find challenge %s\", GetTargetedDomain(authz), chlgType)\n}\n\n\n\nfunc GetTargetedDomain(authz acme.Authorization) string ", "output": "{\n\tif authz.Wildcard {\n\t\treturn \"*.\" + authz.Identifier.Value\n\t}\n\treturn authz.Identifier.Value\n}"}
{"input": "package commands\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype basicHandler struct {\n\thandler func(args ...string) (string, error)\n\thelp    func(args ...string) string\n}\n\nvar _ CommandHandler = (*basicHandler)(nil)\n\nfunc (h *basicHandler) Handle(argv ...string) (string, error) {\n\treturn h.handler(argv...)\n}\n\nfunc (h *basicHandler) Help(argv ...string) string {\n\treturn h.help(argv...)\n}\n\nfunc Static(response, help string) CommandHandler {\n\treturn &basicHandler{\n\t\thandler: func(argv ...string) (string, error) {\n\t\t\treturn response, nil\n\t\t},\n\t\thelp: func(argv ...string) string {\n\t\t\treturn fmt.Sprintf(\"`!%s` - %s\", strings.Join(argv, \" \"), help)\n\t\t},\n\t}\n}\n\n\n\nfunc Simple(responder func(...string) (string, error), help string) CommandHandler ", "output": "{\n\treturn &basicHandler{\n\t\thandler: func(argv ...string) (string, error) {\n\t\t\treturn responder(argv...)\n\t\t},\n\t\thelp: func(argv ...string) string {\n\t\t\treturn fmt.Sprintf(\"`!%s` - %s\", strings.Join(argv, \" \"), help)\n\t\t},\n\t}\n}"}
{"input": "package tracing\n\nimport (\n\t\"crypto/sha256\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/containous/traefik/log\"\n)\n\n\nconst TraceNameHashLength = 8\n\n\n\nconst OperationNameMaxLengthNumber = 10\n\n\n\n\nfunc truncateString(str string, num int) string {\n\ttext := str\n\tif len(str) > num {\n\t\tif num > 3 {\n\t\t\tnum -= 3\n\t\t}\n\t\ttext = str[0:num] + \"...\"\n\t}\n\treturn text\n}\n\n\nfunc computeHash(name string) string {\n\tdata := []byte(name)\n\thash := sha256.New()\n\tif _, err := hash.Write(data); err != nil {\n\t\tlog.WithoutContext().WithField(\"OperationName\", name).Errorf(\"Failed to create Span name hash for %s: %v\", name, err)\n\t}\n\n\treturn fmt.Sprintf(\"%x\", hash.Sum(nil))[:TraceNameHashLength]\n}\n\nfunc generateOperationName(prefix string, parts []string, sep string, spanLimit int) string ", "output": "{\n\tname := prefix + \" \" + strings.Join(parts, sep)\n\n\tmaxLength := OperationNameMaxLengthNumber + len(prefix) + 1\n\n\tif spanLimit > 0 && len(name) > spanLimit {\n\t\tif spanLimit < maxLength {\n\t\t\tlog.WithoutContext().Warnf(\"SpanNameLimit cannot be lesser than %d: falling back on %d, maxLength, maxLength+3\", maxLength)\n\t\t\tspanLimit = maxLength + 3\n\t\t}\n\n\t\tlimit := (spanLimit - maxLength) / 2\n\n\t\tvar fragments []string\n\t\tfor _, value := range parts {\n\t\t\tfragments = append(fragments, truncateString(value, limit))\n\t\t}\n\t\tfragments = append(fragments, computeHash(name))\n\n\t\tname = prefix + \" \" + strings.Join(fragments, sep)\n\t}\n\n\treturn name\n}"}
{"input": "package sale\n\nimport \"go2o/src/core/domain/interface/valueobject\"\n\n\nfunc ParseToPartialValueItem(v *valueobject.Goods) *ValueItem {\n\treturn &ValueItem{\n\t\tId:         v.Item_Id,\n\t\tCategoryId: v.CategoryId,\n\t\tName:       v.Name,\n\t\tGoodsNo:    v.GoodsNo,\n\t\tImage:      v.Image,\n\t\tPrice:      v.Price,\n\t\tSalePrice:  v.SalePrice,\n\t}\n}\n\n\n\n\nfunc ParseToValueGoods(v *valueobject.Goods) *ValueGoods ", "output": "{\n\treturn &ValueGoods{\n\t\tId:            v.GoodsId,\n\t\tItemId:        v.Item_Id,\n\t\tIsPresent:     v.IsPresent,\n\t\tSkuId:         v.SkuId,\n\t\tPromotionFlag: v.PromotionFlag,\n\t\tStockNum:      v.StockNum,\n\t\tSaleNum:       v.SaleNum,\n\t\tSalePrice:     v.SalePrice,\n\t\tPromPrice:     v.PromPrice,\n\t\tPrice:         v.Price,\n\t}\n}"}
{"input": "package tracker\n\nimport (\n\t\"sync\"\n\n\t\"github.com/GoogleContainerTools/skaffold/pkg/skaffold/graph\"\n)\n\ntype Container struct {\n\tName string\n\tID   string\n}\n\ntype ContainerTracker struct {\n\tsync.RWMutex\n\tdeployedContainers  map[string]Container      \n\tcontainerToArtifact map[string]graph.Artifact \n\tcontainers          map[string]bool           \n\tnotifier            chan string\n}\n\n\n\n\n\n\n\nfunc (t *ContainerTracker) Notifier() chan string {\n\treturn t.notifier\n}\n\nfunc (t *ContainerTracker) ArtifactForContainer(id string) graph.Artifact {\n\tt.Lock()\n\tdefer t.Unlock()\n\treturn t.containerToArtifact[id]\n}\n\n\n\nfunc (t *ContainerTracker) ContainerForImage(image string) (Container, bool) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tc, found := t.deployedContainers[image]\n\treturn c, found\n}\n\n\n\nfunc (t *ContainerTracker) DeployedContainers() map[string]Container {\n\treturn t.deployedContainers\n}\n\n\nfunc (t *ContainerTracker) Reset() {\n\tfor c := range t.containers {\n\t\tdelete(t.containers, c)\n\t}\n}\n\n\nfunc (t *ContainerTracker) Add(artifact graph.Artifact, c Container) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tt.deployedContainers[artifact.ImageName] = c\n\tt.containerToArtifact[c.ID] = artifact\n\tgo func() {\n\t\tt.notifier <- c.ID\n\t}()\n}\n\nfunc NewContainerTracker() *ContainerTracker ", "output": "{\n\treturn &ContainerTracker{\n\t\tcontainerToArtifact: make(map[string]graph.Artifact),\n\t\tdeployedContainers:  make(map[string]Container),\n\t\tnotifier:            make(chan string, 1),\n\t}\n}"}
{"input": "package hub\n\nimport (\n\t\"io\"\n)\n\ntype hub struct {\n\tconnections map[io.WriteCloser]bool\n}\n\ntype Hub interface {\n\tRegister(client io.WriteCloser)\n\tUnregister(client io.WriteCloser)\n\tBroadcast(message []byte)\n}\n\nfunc NewHub() *hub {\n\treturn &hub{\n\t\tconnections: make(map[io.WriteCloser]bool),\n\t}\n}\n\n\n\nfunc (h *hub) Unregister(c io.WriteCloser) error {\n\tif _, ok := h.connections[c]; ok {\n\t\tdelete(h.connections, c)\n\t\treturn c.Close()\n\t}\n\treturn nil\n}\n\nfunc (h *hub) Broadcast(m []byte) {\n\tfor c := range h.connections {\n\t\tif _, err := c.Write(m); err != nil {\n\t\t\th.Unregister(c)\n\t\t}\n\t}\n}\n\nfunc (h *hub) Register(c io.WriteCloser) ", "output": "{\n\th.connections[c] = true\n}"}
{"input": "package cmd\n\nimport (\n\t\"testing\"\n\n\t\"gopkg.in/h2non/gock.v1\"\n)\n\n\n\nfunc TestPropertyDelete(t *testing.T) {\n\tdefer gock.Off()\n\n\tgock.New(hostForTest).\n\t\tDelete(\"/config/\" + testSubject + \"/properties/compatibility\").\n\t\tReply(200).\n\t\tSetHeaders(map[string]string{\n\t\t\t\"Content-Type\":   \"text/plain\",\n\t\t\t\"Content-Length\": \"1\",\n\t\t}).\n\t\tBodyString(\"1\")\n\n\targs := []string{\"config\", \"delete\", \"compatibility\", \"--subject\", testSubject}\n\tconfigDeleteCmd.Root().SetArgs(args)\n\n\tif err := configDeleteCmd.Execute(); err != nil {\n\t\tt.Errorf(\"config delete property command is expected to be success with args %v but an error was occured %v\", args, err)\n\t}\n}\n\nfunc TestConfigDelete(t *testing.T) ", "output": "{\n\tdefer gock.Off()\n\n\tgock.New(hostForTest).\n\t\tDelete(\"/config/\" + testSubject).\n\t\tReply(200).\n\t\tSetHeaders(map[string]string{\n\t\t\t\"Content-Type\":   \"text/plain\",\n\t\t\t\"Content-Length\": \"1\",\n\t\t}).\n\t\tBodyString(\"1\")\n\n\targs := []string{\"config\", \"delete\", \"--subject\", testSubject}\n\tconfigDeleteCmd.Root().SetArgs(args)\n\n\tif err := configDeleteCmd.Execute(); err != nil {\n\t\tt.Errorf(\"config delete command is expected to be success with args %v but an error was occured %v\", args, err)\n\t}\n}"}
{"input": "package iso20022\n\n\ntype MandateStatus1Choice struct {\n\n\tCode *ExternalMandateStatus1Code `xml:\"Cd\"`\n\n\tProprietary *Max35Text `xml:\"Prtry\"`\n}\n\nfunc (m *MandateStatus1Choice) SetCode(value string) {\n\tm.Code = (*ExternalMandateStatus1Code)(&value)\n}\n\n\n\nfunc (m *MandateStatus1Choice) SetProprietary(value string) ", "output": "{\n\tm.Proprietary = (*Max35Text)(&value)\n}"}
{"input": "package futures\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n\n\ntype Completer <-chan interface{}\n\n\n\n\n\n\n\ntype Future struct {\n\ttriggered bool \n\titem      interface{}\n\terr       error\n\tlock      sync.Mutex\n\twg        sync.WaitGroup\n}\n\n\n\nfunc (f *Future) GetResult() (interface{}, error) {\n\tf.lock.Lock()\n\tif f.triggered {\n\t\tf.lock.Unlock()\n\t\treturn f.item, f.err\n\t}\n\tf.lock.Unlock()\n\n\tf.wg.Wait()\n\treturn f.item, f.err\n}\n\nfunc (f *Future) setItem(item interface{}, err error) {\n\tf.lock.Lock()\n\tf.triggered = true\n\tf.item = item\n\tf.err = err\n\tf.lock.Unlock()\n\tf.wg.Done()\n}\n\nfunc listenForResult(f *Future, ch Completer, timeout time.Duration, wg *sync.WaitGroup) {\n\twg.Done()\n\tselect {\n\tcase item := <-ch:\n\t\tf.setItem(item, nil)\n\tcase <-time.After(timeout):\n\t\tf.setItem(nil, fmt.Errorf(`Timeout after %f seconds.`, timeout.Seconds()))\n\t}\n}\n\n\n\n\n\n\n\nfunc New(completer Completer, timeout time.Duration) *Future ", "output": "{\n\tf := &Future{}\n\tf.wg.Add(1)\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo listenForResult(f, completer, timeout, &wg)\n\twg.Wait()\n\treturn f\n}"}
{"input": "package memcachep\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n)\n\ntype Stats map[string]fmt.Stringer\n\n\ntype FuncStat struct {\n\tCallable func() string\n}\n\nfunc (f *FuncStat) String() string {\n\treturn f.Callable()\n}\n\n\ntype StaticStat struct {\n\tValue string\n}\n\nfunc (s *StaticStat) String() string {\n\treturn s.Value\n}\n\n\ntype CounterStat struct {\n\tCount        int\n\tcalculations chan int\n}\n\n\n\nfunc (c *CounterStat) SetCount(num int) {\n\tc.Count = num\n}\n\nfunc (c *CounterStat) Decrement(num int) {\n\tc.calculations <- -num\n}\n\nfunc (c *CounterStat) String() string {\n\treturn strconv.Itoa(c.Count)\n}\n\nfunc (c *CounterStat) work() {\n\tfor num := range c.calculations {\n\t\tc.Count = c.Count + num\n\t}\n}\n\nfunc NewCounterStat() *CounterStat {\n\tc := &CounterStat{}\n\tc.calculations = make(chan int, 100)\n\tgo c.work()\n\treturn c\n}\n\nfunc NewStats() Stats {\n\ts := make(Stats)\n\ts[\"pid\"] = &StaticStat{strconv.Itoa(os.Getpid())}\n\ts[\"version\"] = &StaticStat{VERSION}\n\ts[\"golang\"] = &StaticStat{runtime.Version()}\n\ts[\"goroutines\"] = &FuncStat{func() string { return strconv.Itoa(runtime.NumGoroutine()) }}\n\ts[\"cpu_num\"] = &StaticStat{strconv.Itoa(runtime.NumCPU())}\n\ts[\"total_connections\"] = NewCounterStat()\n\ts[\"curr_connections\"] = NewCounterStat()\n\ts[\"cmd_get\"] = NewCounterStat()\n\treturn s\n}\n\nfunc (c *CounterStat) Increment(num int) ", "output": "{\n\tc.calculations <- num\n}"}
{"input": "package testutils\n\nimport (\n\t\"sync\"\n\n\t\"github.com/uber/jaeger/thrift-gen/baggage\"\n)\n\nfunc newBaggageRestrictionManager() *baggageRestrictionManager {\n\treturn &baggageRestrictionManager{\n\t\trestrictions: make(map[string][]*baggage.BaggageRestriction),\n\t}\n}\n\ntype baggageRestrictionManager struct {\n\tsync.Mutex\n\n\trestrictions map[string][]*baggage.BaggageRestriction\n}\n\n\n\n\n\nfunc (m *baggageRestrictionManager) AddBaggageRestrictions(service string, restrictions []*baggage.BaggageRestriction) {\n\tm.Lock()\n\tdefer m.Unlock()\n\tm.restrictions[service] = restrictions\n}\n\nfunc (m *baggageRestrictionManager) GetBaggageRestrictions(serviceName string) ([]*baggage.BaggageRestriction, error) ", "output": "{\n\tm.Lock()\n\tdefer m.Unlock()\n\tif restrictions, ok := m.restrictions[serviceName]; ok {\n\t\treturn restrictions, nil\n\t}\n\treturn nil, nil\n}"}
{"input": "package dosingdecision\n\nimport (\n\t\"github.com/tidepool-org/platform/structure\"\n)\n\nconst (\n\tRecommendedBasalDurationMaximum = 86400000\n\tRecommendedBasalDurationMinimum = 0\n\tRecommendedBasalRateMaximum     = 100\n\tRecommendedBasalRateMinimum     = 0\n)\n\ntype RecommendedBasal struct {\n\tRate     *float64 `json:\"rate,omitempty\" bson:\"rate,omitempty\"`\n\tDuration *int     `json:\"duration,omitempty\" bson:\"duration,omitempty\"`\n}\n\nfunc ParseRecommendedBasal(parser structure.ObjectParser) *RecommendedBasal {\n\tif !parser.Exists() {\n\t\treturn nil\n\t}\n\tdatum := NewRecommendedBasal()\n\tparser.Parse(datum)\n\treturn datum\n}\n\nfunc NewRecommendedBasal() *RecommendedBasal {\n\treturn &RecommendedBasal{}\n}\n\n\n\nfunc (r *RecommendedBasal) Validate(validator structure.Validator) {\n\tvalidator.Float64(\"rate\", r.Rate).Exists().InRange(RecommendedBasalRateMinimum, RecommendedBasalRateMaximum)\n\tvalidator.Int(\"duration\", r.Duration).InRange(RecommendedBasalDurationMinimum, RecommendedBasalDurationMaximum)\n}\n\nfunc (r *RecommendedBasal) Parse(parser structure.ObjectParser) ", "output": "{\n\tr.Rate = parser.Float64(\"rate\")\n\tr.Duration = parser.Int(\"duration\")\n}"}
{"input": "package v1alpha1\n\nimport (\n\trest \"k8s.io/client-go/rest\"\n\tv1alpha1 \"k8s.io/ingress-gce/pkg/experimental/apis/workload/v1alpha1\"\n\t\"k8s.io/ingress-gce/pkg/experimental/workload/client/clientset/versioned/scheme\"\n)\n\ntype NetworkingV1alpha1Interface interface {\n\tRESTClient() rest.Interface\n\tWorkloadsGetter\n}\n\n\ntype NetworkingV1alpha1Client struct {\n\trestClient rest.Interface\n}\n\nfunc (c *NetworkingV1alpha1Client) Workloads(namespace string) WorkloadInterface {\n\treturn newWorkloads(c, namespace)\n}\n\n\nfunc NewForConfig(c *rest.Config) (*NetworkingV1alpha1Client, error) {\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := rest.RESTClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &NetworkingV1alpha1Client{client}, nil\n}\n\n\n\nfunc NewForConfigOrDie(c *rest.Config) *NetworkingV1alpha1Client {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n\n\n\n\nfunc setConfigDefaults(config *rest.Config) error {\n\tgv := v1alpha1.SchemeGroupVersion\n\tconfig.GroupVersion = &gv\n\tconfig.APIPath = \"/apis\"\n\tconfig.NegotiatedSerializer = scheme.Codecs.WithoutConversion()\n\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = rest.DefaultKubernetesUserAgent()\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (c *NetworkingV1alpha1Client) RESTClient() rest.Interface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.restClient\n}\n\nfunc New(c rest.Interface) *NetworkingV1alpha1Client ", "output": "{\n\treturn &NetworkingV1alpha1Client{c}\n}"}
{"input": "package ipam\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/runtime\"\n\t\"github.com/go-openapi/runtime/middleware\"\n\t\"github.com/go-openapi/validate\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n)\n\n\n\n\n\n\n\n\n\ntype PostIPAMParams struct {\n\n\tHTTPRequest *http.Request\n\n\tFamily *string\n}\n\n\n\nfunc (o *PostIPAMParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {\n\tvar res []error\n\to.HTTPRequest = r\n\n\tqs := runtime.Values(r.URL.Query())\n\n\tqFamily, qhkFamily, _ := qs.GetOK(\"family\")\n\tif err := o.bindFamily(qFamily, qhkFamily, route.Formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (o *PostIPAMParams) bindFamily(rawData []string, hasKey bool, formats strfmt.Registry) error {\n\tvar raw string\n\tif len(rawData) > 0 {\n\t\traw = rawData[len(rawData)-1]\n\t}\n\tif raw == \"\" { \n\t\treturn nil\n\t}\n\n\to.Family = &raw\n\n\tif err := o.validateFamily(formats); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (o *PostIPAMParams) validateFamily(formats strfmt.Registry) error {\n\n\tif err := validate.Enum(\"family\", \"query\", *o.Family, []interface{}{\"ipv4\", \"ipv6\"}); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc NewPostIPAMParams() PostIPAMParams ", "output": "{\n\tvar ()\n\treturn PostIPAMParams{}\n}"}
{"input": "package manual\n\nimport (\n\t\"github.com/juju/juju/core/instance\"\n\tcorenetwork \"github.com/juju/juju/core/network\"\n\t\"github.com/juju/juju/core/network/firewall\"\n\t\"github.com/juju/juju/core/status\"\n\t\"github.com/juju/juju/environs/context\"\n\t\"github.com/juju/juju/environs/manual\"\n)\n\ntype manualBootstrapInstance struct {\n\thost string\n}\n\nfunc (manualBootstrapInstance) Id() instance.Id {\n\treturn BootstrapInstanceId\n}\n\nfunc (manualBootstrapInstance) Status(ctx context.ProviderCallContext) instance.Status {\n\treturn instance.Status{\n\t\tStatus: status.Running,\n\t}\n}\n\nfunc (manualBootstrapInstance) Refresh(ctx context.ProviderCallContext) error {\n\treturn nil\n}\n\nfunc (inst manualBootstrapInstance) Addresses(ctx context.ProviderCallContext) (corenetwork.ProviderAddresses, error) {\n\taddr, err := manual.HostAddress(inst.host)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn []corenetwork.ProviderAddress{addr}, nil\n}\n\n\n\nfunc (manualBootstrapInstance) ClosePorts(ctx context.ProviderCallContext, machineId string, rules firewall.IngressRules) error {\n\treturn nil\n}\n\nfunc (manualBootstrapInstance) IngressRules(ctx context.ProviderCallContext, machineId string) (firewall.IngressRules, error) {\n\treturn nil, nil\n}\n\nfunc (manualBootstrapInstance) OpenPorts(ctx context.ProviderCallContext, machineId string, rules firewall.IngressRules) error ", "output": "{\n\treturn nil\n}"}
{"input": "package sliceiterator\n\n\ntype Iterator struct {\n\tdata *[]string\n\tidx  int\n}\n\n\nfunc New(s *[]string) *Iterator {\n\treturn &Iterator{data: s, idx: -1}\n}\n\n\nfunc (a *Iterator) Size() int {\n\treturn len(*a.data)\n}\n\n\nfunc (a *Iterator) Index() int {\n\treturn a.idx\n}\n\n\nfunc (a *Iterator) Next() bool {\n\tif a.idx < len(*a.data) {\n\t\ta.idx++\n\t}\n\treturn a.idx < len(*a.data)\n}\n\n\nfunc (a *Iterator) ExistsNext() bool {\n\treturn a.idx+1 < len(*a.data)\n}\n\n\nfunc (a *Iterator) Value() string {\n\tif a.idx >= len(*a.data) {\n\t\treturn \"\"\n\t}\n\treturn (*a.data)[a.idx]\n}\n\n\nfunc (a *Iterator) PeekNextValue() (string, bool) {\n\tif a.idx+1 >= len(*a.data) {\n\t\treturn \"\", false\n\t}\n\treturn (*a.data)[a.idx+1], true\n}\n\n\nfunc (a *Iterator) IsLast() bool {\n\treturn a.idx == len(*a.data)-1\n}\n\n\nfunc (a *Iterator) Remaining() []string {\n\tif a.idx >= len(*a.data) {\n\t\treturn []string{}\n\t}\n\treturn (*a.data)[a.idx:]\n}\n\n\n\n\nfunc (a *Iterator) Reset() ", "output": "{\n\ta.idx = -1\n}"}
{"input": "package main\n\nimport \"fmt\"\n\nvar GoogleAccountID = \"32984782374\"\n\nfunc main() {\n}\n\n\n\nfunc getLikeCount() ", "output": "{\n\tfmt.Print(\"Your Google Account ID: \", GoogleAccountID)\n}"}
{"input": "package wallabago\n\nimport \"testing\"\n\nconst tagsResult = `[{\"id\":53,\"label\":\"2min\",\"slug\":\"2min\"},{\"id\":57,\"label\":\"android\",\"slug\":\"android\"},{\"id\":58,\"label\":\"linux\",\"slug\":\"linux\"}]`\n\n\n\nfunc mockGetTagsOfEntry(url string, httpMethod string, postData []byte) ([]byte, error) {\n\treturn []byte(tagsResult), nil\n}\n\nfunc TestGetTags(t *testing.T) {\n\texpectedID := 57\n\texpectedLabel := \"android\"\n\texpectedSlug := \"android\"\n\ttags, _ := GetTags(mockGetTagsOfEntry)\n\tif tags[1].ID != expectedID {\n\t\tt.Errorf(\"expected id=%v, but got %v\", expectedID, tags[1].ID)\n\t}\n\tif tags[1].Label != expectedLabel {\n\t\tt.Errorf(\"expected label=%v, but got %v\", expectedLabel, tags[1].Label)\n\t}\n\tif tags[1].Slug != expectedSlug {\n\t\tt.Errorf(\"expected slug=%v, but got %v\", expectedSlug, tags[1].Slug)\n\t}\n}\n\nfunc TestGetTagsOfEntry(t *testing.T) ", "output": "{\n\tarticleID := 3977\n\texpectedID := 57\n\texpectedLabel := \"android\"\n\texpectedSlug := \"android\"\n\ttags, _ := GetTagsOfEntry(mockGetTagsOfEntry, articleID)\n\tif tags[1].ID != expectedID {\n\t\tt.Errorf(\"expected id=%v, but got %v\", expectedID, tags[1].ID)\n\t}\n\tif tags[1].Label != expectedLabel {\n\t\tt.Errorf(\"expected label=%v, but got %v\", expectedLabel, tags[1].Label)\n\t}\n\tif tags[1].Slug != expectedSlug {\n\t\tt.Errorf(\"expected slug=%v, but got %v\", expectedSlug, tags[1].Slug)\n\t}\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype PublicIpPool struct {\n\n\tCompartmentId *string `mandatory:\"true\" json:\"compartmentId\"`\n\n\tId *string `mandatory:\"true\" json:\"id\"`\n\n\tTimeCreated *common.SDKTime `mandatory:\"true\" json:\"timeCreated\"`\n\n\tCidrBlocks []string `mandatory:\"false\" json:\"cidrBlocks\"`\n\n\tDefinedTags map[string]map[string]interface{} `mandatory:\"false\" json:\"definedTags\"`\n\n\tDisplayName *string `mandatory:\"false\" json:\"displayName\"`\n\n\tFreeformTags map[string]string `mandatory:\"false\" json:\"freeformTags\"`\n\n\tLifecycleState PublicIpPoolLifecycleStateEnum `mandatory:\"false\" json:\"lifecycleState,omitempty\"`\n}\n\n\n\n\ntype PublicIpPoolLifecycleStateEnum string\n\n\nconst (\n\tPublicIpPoolLifecycleStateInactive PublicIpPoolLifecycleStateEnum = \"INACTIVE\"\n\tPublicIpPoolLifecycleStateUpdating PublicIpPoolLifecycleStateEnum = \"UPDATING\"\n\tPublicIpPoolLifecycleStateActive   PublicIpPoolLifecycleStateEnum = \"ACTIVE\"\n\tPublicIpPoolLifecycleStateDeleting PublicIpPoolLifecycleStateEnum = \"DELETING\"\n\tPublicIpPoolLifecycleStateDeleted  PublicIpPoolLifecycleStateEnum = \"DELETED\"\n)\n\nvar mappingPublicIpPoolLifecycleState = map[string]PublicIpPoolLifecycleStateEnum{\n\t\"INACTIVE\": PublicIpPoolLifecycleStateInactive,\n\t\"UPDATING\": PublicIpPoolLifecycleStateUpdating,\n\t\"ACTIVE\":   PublicIpPoolLifecycleStateActive,\n\t\"DELETING\": PublicIpPoolLifecycleStateDeleting,\n\t\"DELETED\":  PublicIpPoolLifecycleStateDeleted,\n}\n\n\nfunc GetPublicIpPoolLifecycleStateEnumValues() []PublicIpPoolLifecycleStateEnum {\n\tvalues := make([]PublicIpPoolLifecycleStateEnum, 0)\n\tfor _, v := range mappingPublicIpPoolLifecycleState {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}\n\nfunc (m PublicIpPool) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package issue\n\nimport (\n\t\"github.com/watermint/toolbox/quality/recipe/qtr_endtoend\"\n\t\"testing\"\n)\n\n\n\nfunc TestList_Exec(t *testing.T) ", "output": "{\n\tqtr_endtoend.TestRecipe(t, &List{})\n}"}
{"input": "package packets\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n\n\ntype UnsubackPacket struct {\n\tFixedHeader\n\tMessageID uint16\n}\n\nfunc (ua *UnsubackPacket) Type() byte {\n\treturn ua.FixedHeader.MessageType\n}\nfunc (ua *UnsubackPacket) String() string {\n\tstr := fmt.Sprintf(\"%s\\n\", ua.FixedHeader)\n\tstr += fmt.Sprintf(\"MessageID: %d\", ua.MessageID)\n\treturn str\n}\n\nfunc (ua *UnsubackPacket) Write(w io.Writer) error {\n\tvar err error\n\tua.FixedHeader.RemainingLength = 2\n\tpacket := ua.FixedHeader.pack()\n\tpacket.Write(encodeUint16(ua.MessageID))\n\t_, err = packet.WriteTo(w)\n\n\treturn err\n}\n\n\n\nfunc (ua *UnsubackPacket) Unpack(b io.Reader) error {\n\tua.MessageID = decodeUint16(b)\n\n\treturn nil\n}\n\n\n\n\n\nfunc (ua *UnsubackPacket) Details() Details ", "output": "{\n\treturn Details{Qos: 0, MessageID: ua.MessageID}\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\t\"text/template\"\n)\n\nfunc init() {\n\thttp.Handle(\"/view\", appHandler(viewRecord))\n}\n\n\n\nfunc viewRecord(w http.ResponseWriter, r *http.Request) error {\n\tc := appengine.NewContext(r)\n\tkey := datastore.NewKey(c, \"Record\", r.FormValue(\"id\"), 0, nil)\n\trecord := new(Record)\n\tif err := datastore.Get(c, key, record); err != nil {\n\t\treturn err\n\t}\n\treturn viewTemplate.Execute(w, record)\n}\n\n\n\ntype appHandler func(http.ResponseWriter, *http.Request) error\n\n\n\n\n\ntype ap struct{}\n\nfunc (ap) NewContext(*http.Request) *ctx { return nil }\n\ntype ctx struct{}\n\nfunc (*ctx) Errorf(string, ...interface{}) {}\n\nvar appengine ap\n\ntype ds struct{}\n\nfunc (ds) NewKey(*ctx, string, string, int, *int) string { return \"\" }\nfunc (ds) Get(*ctx, string, *Record) error               { return nil }\n\nvar datastore ds\n\ntype Record struct{}\n\nvar viewTemplate *template.Template\n\nfunc main() {}\n\nfunc (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tif err := fn(w, r); err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\ntype stackEntry interface {\n\tString() string\n\tType() string\n}\n\ntype lenable interface {\n\tLength() int\n}\n\ntype Boolean bool\ntype Integer int\ntype Double float64\ntype Dict map[string]stackEntry\ntype Array []stackEntry\ntype String string\n\n\ntype quotation []word\n\nfunc (s String) String() string {\n\treturn \"<<\" + string(s) + \">>\"\n}\n\n\nfunc (i Integer) String() string {\n\treturn strconv.Itoa(int(i))\n}\n\nfunc (d Double) String() string {\n\treturn fmt.Sprint(float64(d))\n}\n\nfunc (q quotation) String() string {\n\treturn fmt.Sprint([]word(q))\n}\n\nfunc (dict Dict) String() string {\n\treturn fmt.Sprint(map[string]stackEntry(dict))\n}\n\nfunc (a Array) String() string {\n\treturn fmt.Sprint([]stackEntry(a))\n}\n\nfunc (i Integer) Type() string {\n\treturn \"Integer\"\n}\n\nfunc (d Double) Type() string {\n\treturn \"Double\"\n}\n\nfunc (q quotation) Type() string {\n\treturn \"Quotation\"\n}\n\nfunc (a Array) Type() string {\n\treturn \"Vector\"\n}\n\nfunc (dict Dict) Type() string {\n\treturn \"Dictionary\"\n}\n\nfunc (b Boolean) Type() string {\n\treturn \"Boolean\"\n}\n\nfunc (s String) Type() string {\n\treturn \"String\"\n}\n\nfunc (dict Dict) Length() int {\n\treturn len(dict)\n}\n\nfunc (a Array) Length() int {\n\treturn len(a)\n}\n\nfunc (b Boolean) String() string ", "output": "{\n\tif bool(b) {\n\t\treturn \"t\"\n\t}\n\treturn \"f\"\n}"}
{"input": "package meters\n\nimport \"fmt\"\n\nconst _Meter_name = \"SmallVerticalMediumHorizontalLargeVertical\"\n\nvar _Meter_index = [...]uint8{0, 13, 29, 42}\n\n\n\nfunc (i Meter) String() string ", "output": "{\n\tif i < 0 || i >= Meter(len(_Meter_index)-1) {\n\t\treturn fmt.Sprintf(\"Meter(%d)\", i)\n\t}\n\treturn _Meter_name[_Meter_index[i]:_Meter_index[i+1]]\n}"}
{"input": "package iso20022\n\n\ntype CardPaymentEnvironment37 struct {\n\n\tAcquirer *Acquirer4 `xml:\"Acqrr\"`\n\n\tMerchantIdentification *GenericIdentification53 `xml:\"MrchntId,omitempty\"`\n\n\tPOIIdentification *GenericIdentification53 `xml:\"POIId,omitempty\"`\n\n\tPOIComponent []*PointOfInteractionComponent5 `xml:\"POICmpnt,omitempty\"`\n}\n\n\n\nfunc (c *CardPaymentEnvironment37) AddMerchantIdentification() *GenericIdentification53 {\n\tc.MerchantIdentification = new(GenericIdentification53)\n\treturn c.MerchantIdentification\n}\n\nfunc (c *CardPaymentEnvironment37) AddPOIIdentification() *GenericIdentification53 {\n\tc.POIIdentification = new(GenericIdentification53)\n\treturn c.POIIdentification\n}\n\nfunc (c *CardPaymentEnvironment37) AddPOIComponent() *PointOfInteractionComponent5 {\n\tnewValue := new(PointOfInteractionComponent5)\n\tc.POIComponent = append(c.POIComponent, newValue)\n\treturn newValue\n}\n\nfunc (c *CardPaymentEnvironment37) AddAcquirer() *Acquirer4 ", "output": "{\n\tc.Acquirer = new(Acquirer4)\n\treturn c.Acquirer\n}"}
{"input": "package policy\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-openapi/runtime/middleware\"\n)\n\n\ntype GetIPHandlerFunc func(GetIPParams) middleware.Responder\n\n\n\n\n\ntype GetIPHandler interface {\n\tHandle(GetIPParams) middleware.Responder\n}\n\n\nfunc NewGetIP(ctx *middleware.Context, handler GetIPHandler) *GetIP {\n\treturn &GetIP{Context: ctx, Handler: handler}\n}\n\n\ntype GetIP struct {\n\tContext *middleware.Context\n\tHandler GetIPHandler\n}\n\nfunc (o *GetIP) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n\troute, rCtx, _ := o.Context.RouteInfo(r)\n\tif rCtx != nil {\n\t\tr = rCtx\n\t}\n\tvar Params = NewGetIPParams()\n\n\tif err := o.Context.BindValidRequest(r, route, &Params); err != nil { \n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\n\tres := o.Handler.Handle(Params) \n\n\to.Context.Respond(rw, r, route.Produces, route, res)\n\n}\n\nfunc (fn GetIPHandlerFunc) Handle(params GetIPParams) middleware.Responder ", "output": "{\n\treturn fn(params)\n}"}
{"input": "package\tpadding\n\nimport (\n\t. \"gopkg.in/check.v1\"\n)\n\n\n\nfunc (s *TestSuite) TestAlignMultiByte(c *C) {\n\tdata:=[]byte{1,2,3}\n\ttest:=Align(data,40)\n\tc.Assert(test, DeepEquals, []byte{0,0,1,2,3})\n}\n\nfunc (s *TestSuite) TestAlignMultiBytePartial(c *C) {\n\tdata:=[]byte{1,2,3}\n\ttest:=Align(data,43)\n\tc.Assert(test, DeepEquals, []byte{0,0,0,1,2,3})\n}\n\nfunc (s *TestSuite) TestAlignedArray(c *C) {\n\tdata:=[]byte{1,2,3}\n\ttest:=Align(data,24)\n\tc.Assert(test, DeepEquals, []byte{1,2,3})\n}\n\nfunc (s *TestSuite) TestAlignOneByte(c *C) ", "output": "{\n\tdata:=[]byte{1,2,3}\n\ttest:=Align(data,27)\n\tc.Assert(test, DeepEquals, []byte{0,1,2,3})\n}"}
{"input": "package inmemory\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"gitlab.com/qaclana/qaclana/pkg/proto\"\n)\n\n\ntype InMemory struct {\n\n\ts qaclana.State\n\n\tns []chan (qaclana.State)\n}\n\n\nfunc WithState(s qaclana.State) *InMemory {\n\treturn &InMemory{s: s}\n}\n\n\n\n\n\nfunc (m *InMemory) Notifier() (<-chan qaclana.State, error) {\n\tc := make(chan qaclana.State)\n\tm.ns = append(m.ns, c)\n\treturn c, nil\n}\n\n\nfunc (m *InMemory) Current() (qaclana.State, error) {\n\treturn m.s, nil\n}\n\n\nfunc (m *InMemory) NotifyAll(s qaclana.State) error {\n\tfor _, n := range m.ns {\n\t\tn <- s\n\t}\n\n\treturn nil\n}\n\nfunc (m *InMemory) Store(ctx context.Context, s qaclana.State) error ", "output": "{\n\tif m.s == s {\n\t\tlog.Printf(\"Given state (%s) is the same as the current one (%s)\", s, m.s)\n\t\treturn nil\n\t}\n\n\tlog.Printf(\"Setting state to %s\", s)\n\tm.s = s\n\tlog.Printf(\"Set state to %s\", m.s)\n\tm.NotifyAll(s)\n\treturn nil\n}"}
{"input": "package xmessage\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"golang.org/x/net/websocket\"\n\t\"io/ioutil\"\n)\n\ntype middlewareConfig struct {\n\tName  string `json:\"name\"`\n\tKey   string `json:\"key\"`\n\tValue string `json:\"value\"`\n}\n\ntype config struct {\n\tMiddleware []middlewareConfig `json:\"middleware\"`\n}\n\ntype middlewareSupport struct {\n\tName          string\n\tAfterReceive  bool\n\tBeforeProcess bool\n\tAfterProcess  bool\n\tBeforeSend    bool\n\tAfterSend     bool\n}\n\ntype middleware struct {\n\tMap               map[string]interface{}\n\tSupport           []middlewareSupport\n\tAfterReceiveFunc  []func(*Req)\n\tBeforeProcessFunc []func(*Ctx)\n\tAfterProcessFunc  []func(*Ctx)\n\tBeforeSendFunc    []func(*Res)\n\tAfterSendFunc     []func(*Res)\n}\n\ntype Msg struct {\n\tConfig       config\n\tMiddleware   middleware\n\tProcessorMap map[string]*Processor\n}\n\n\nfunc (m *Msg) Server(ws *websocket.Conn) {\n\tvar err error\n\tfor {\n\t\tvar req Req\n\t\treq.Init()\n\t\tif err = websocket.JSON.Receive(ws, &req); err != nil {\n\t\t\tbreak\n\t\t}\n\t\tgo m.do(ws, &req)\n\t}\n}\n\n\n\n\n\nvar msg *Msg\n\nfunc init() {\n\tmsg = &Msg{\n\t\tMiddleware: middleware{\n\t\t\tMap: make(map[string]interface{}),\n\t\t},\n\t\tProcessorMap: make(map[string]*Processor),\n\t}\n\tmsg.loadConfig()\n}\n\n\n\n\nfunc Ins() *Msg {\n\treturn msg\n}\n\n\nfunc LoadModule(x interface{}) {\n\tmsg.loadModule(x)\n}\n\n\nfunc LoadMiddleware(x interface{}) {\n\tmsg.loadMiddleware(x)\n}\n\nfunc (m *Msg) loadConfig() ", "output": "{\n\tvar err error\n\tdata, err := ioutil.ReadFile(\"config.json\")\n\tif err != nil {\n\t\tfmt.Println(\"Read config file error:\", err)\n\t}\n\terr = json.Unmarshal(data, &m.Config)\n\tif err != nil {\n\t\tfmt.Println(\"Unmarshal config file content error:\", err)\n\t}\n}"}
{"input": "package rest\n\n\ntype Method int\n\nconst (\n\tGET Method = 1 + iota\n\tPOST\n\tPUT\n\tDELETE\n)\n\nvar method = [...]string{\n\t\"GET\",\n\t\"POST\",\n\t\"PUT\",\n\t\"DELETE\",\n}\n\n\n\nfunc (m Method) String() string ", "output": "{ return method[m-1] }"}
{"input": "package cli\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n\ntype Float64Flag struct {\n\tName   string\n\tValue  float64\n\tUsage  string\n\tEnvVar string\n\tHide   bool\n}\n\n\nfunc (f Float64Flag) String() string {\n\treturn withEnvHint(f.EnvVar, fmt.Sprintf(\"%s \\\"%v\\\"\\t%v\", prefixedNames(f.Name), f.Value, f.Usage))\n}\n\n\n\n\nfunc (f Float64Flag) getName() string {\n\treturn f.Name\n}\n\nfunc (f Float64Flag) isNotHidden() bool {\n\treturn !f.Hide\n}\n\nfunc (f Float64Flag) Apply(set *flag.FlagSet) ", "output": "{\n\tif f.EnvVar != \"\" {\n\t\tfor _, envVar := range strings.Split(f.EnvVar, \",\") {\n\t\t\tenvVar = strings.TrimSpace(envVar)\n\t\t\tif envVal := os.Getenv(envVar); envVal != \"\" {\n\t\t\t\tenvValFloat, err := strconv.ParseFloat(envVal, 10)\n\t\t\t\tif err == nil {\n\t\t\t\t\tf.Value = float64(envValFloat)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\teachName(f.Name, func(name string) {\n\t\tset.Float64(name, f.Value, f.Usage)\n\t})\n}"}
{"input": "package spool_test\n\nimport (\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/juju/errors\"\n)\n\n\n\nfunc dial(socketPath string) (io.ReadCloser, error) ", "output": "{\n\tconn, err := net.Dial(\"unix\", socketPath)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\treturn conn, nil\n}"}
{"input": "package grpcweb\n\nimport \"google.golang.org/grpc/metadata\"\n\ntype callInfo struct {\n\theaders         metadata.MD\n\ttrailers        metadata.MD\n\tforceWebsockets bool\n}\n\n\ntype CallOption interface {\n\tbefore(*callInfo) error\n\tafter(*callInfo)\n}\n\ntype beforeCall func(c *callInfo) error\n\nfunc (o beforeCall) before(c *callInfo) error { return o(c) }\nfunc (o beforeCall) after(c *callInfo)        {}\n\ntype afterCall func(c *callInfo)\n\nfunc (o afterCall) before(c *callInfo) error { return nil }\nfunc (o afterCall) after(c *callInfo)        { o(c) }\n\n\n\nfunc Header(headers *metadata.MD) CallOption {\n\treturn afterCall(func(c *callInfo) {\n\t\t*headers = c.headers\n\t})\n}\n\n\n\n\n\n\nfunc ForceWebsocketTransport() CallOption {\n\treturn beforeCall(func(c *callInfo) error {\n\t\tc.forceWebsockets = true\n\t\treturn nil\n\t})\n}\n\nfunc Trailer(trailers *metadata.MD) CallOption ", "output": "{\n\treturn afterCall(func(c *callInfo) {\n\t\t*trailers = c.trailers\n\t})\n}"}
{"input": "package libFileSwarm\n\nimport (\n\t\"encoding/json\"\n\t\"libytc\"\n\t\"log\"\n)\n\ntype Encoder struct {\n}\n\nfunc (e Encoder) EncodeBlock(b libytc.Block) []byte {\n\tblock := b.(*Block)\n\n\tencodedBlock, err := json.Marshal(block)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn encodedBlock\n}\n\n\n\nfunc (e Encoder) DecodeBlock(b []byte) libytc.Block ", "output": "{\n\tblock := new(Block)\n\tjson.Unmarshal(b, block)\n\treturn block\n}"}
{"input": "package sagas\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc TestSagaStateFactory(t *testing.T) ", "output": "{\n\n\tsagaId := \"testSaga\"\n\tjob := []byte{0, 1, 2, 3, 4, 5}\n\n\tstate, _ := makeSagaState(\"testSaga\", job)\n\tif state.sagaId != sagaId {\n\t\tt.Error(fmt.Sprintf(\"SagaState SagaId should be the same as the SagaId passed to Factory Method\"))\n\t}\n\n\tif !bytes.Equal(state.job, job) {\n\t\tt.Error(fmt.Sprintf(\"SagaState Job should be the same as the supplied Job passed to Factory Method\"))\n\t}\n}"}
{"input": "package marketplaceordering\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\nfunc New(subscriptionID string) BaseClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient ", "output": "{\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}"}
{"input": "package ricons\n\nimport \"testing\"\n\nfunc TestGridPresent(t *testing.T) {\n\tif gen, exist := Registry[\"grid\"]; !exist {\n\t\tt.Fatal(\"couldn't find 'grid' generator\")\n\t} else {\n\t\tg = gen\n\t}\n}\n\nfunc TestGridStringer(t *testing.T) {\n\tif g.String() != \"grid: grid-based icons\" {\n\t\tt.Errorf(\"stringer mismatch: %v != %v\", \"grid: grid-based icons\", g.String())\n\t}\n}\n\n\n\nfunc BenchmarkGrid32x32(b *testing.B) {\n\tg, ok := Registry[\"grid\"]\n\tif !ok {\n\t\tb.Fatal(\"couldn't find 'grid' generator\")\n\t}\n\tic := NewIcon(32, 32)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := g.Generate(ic); err != nil {\n\t\t\tb.Fatalf(\"(%d) error generating icon: %s\", i+1, err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkGrid16x16(b *testing.B) ", "output": "{\n\tg, ok := Registry[\"grid\"]\n\tif !ok {\n\t\tb.Fatal(\"couldn't find 'grid' generator\")\n\t}\n\tic := NewIcon(16, 16)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := g.Generate(ic); err != nil {\n\t\t\tb.Fatalf(\"(%d) error generating icon: %s\", i+1, err)\n\t\t}\n\t}\n}"}
{"input": "package hypervisor\n\nimport (\n\t\"github.com/hyperhq/runv/hypervisor/types\"\n)\n\n\n\nfunc (ctx *VmContext) reportVmShutdown() {\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tctx.Log(WARNING, \"panic during send shutdown message to channel\")\n\t\t}\n\t}()\n\tctx.client <- &types.VmResponse{\n\t\tVmId:  ctx.Id,\n\t\tCode:  types.E_VM_SHUTDOWN,\n\t\tCause: \"VM shut down\",\n\t}\n}\n\n\n\nfunc (ctx *VmContext) reportSuccess(msg string, data interface{}) {\n\tctx.client <- &types.VmResponse{\n\t\tVmId:  ctx.Id,\n\t\tCode:  types.E_OK,\n\t\tCause: msg,\n\t\tData:  data,\n\t}\n}\n\n\n\nfunc (ctx *VmContext) reportUnexpectedRequest(ev VmEvent, state string) {\n\tctx.client <- &types.VmResponse{\n\t\tVmId:  ctx.Id,\n\t\tCode:  types.E_UNEXPECTED,\n\t\tReply: ev,\n\t\tCause: \"unexpected event during \" + state,\n\t}\n}\n\n\n\nfunc (ctx *VmContext) reportVmFault(cause string) {\n\tctx.client <- &types.VmResponse{\n\t\tVmId:  ctx.Id,\n\t\tCode:  types.E_FAILED,\n\t\tCause: cause,\n\t}\n}\n\nfunc (ctx *VmContext) reportProcessFinished(code int, result *types.ProcessFinished) ", "output": "{\n\tctx.client <- &types.VmResponse{\n\t\tVmId:  ctx.Id,\n\t\tCode:  code,\n\t\tCause: \"container finished\",\n\t\tData:  result,\n\t}\n}"}
{"input": "package kafka\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestOption(t *testing.T) {\n\tvar options Options\n\tassert.Equal(t, `default`, options.group())\n\tassert.NotNil(t, options.logger(), `logger`)\n}\n\n\n\nfunc TestOptionWithURL(t *testing.T) ", "output": "{\n\tvar options Options\n\n\tWithTopics(`topic-test1`, `topic-test2`)(&options)\n\tassert.ElementsMatch(t, []string{`topic-test1`, `topic-test2`}, options.Topics)\n\n\tWithKafkaURL(`nats://demo1:8000,demo2:8000/test?topics=topic1,topic2`)(&options)\n\tassert.ElementsMatch(t, []string{`demo1:8000`, `demo2:8000`}, options.Brokers)\n\tassert.ElementsMatch(t, []string{`topic1`, `topic2`}, options.Topics)\n\tassert.Equal(t, `test`, options.group())\n}"}
{"input": "package main\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"io\"\n\t\"strings\"\n)\n\n\n\nvar (\n\tpadding = string(rune(0))\n\tbits = struct {\n\t\tAES int\n\t\tIV  int\n\t}{32, 16}\n)\n\n\nfunc CBCDecrypt(content string, password string) (string, error) {\n\tdecoded, err := base64.StdEncoding.DecodeString(content)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tiv := decoded[:bits.IV]\n\tpayload := decoded[bits.IV:]\n\n\taesBlock, err := aes.NewCipher(passwordHash(password))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tdecrypter := cipher.NewCBCDecrypter(aesBlock, iv)\n\tdecrypter.CryptBlocks(payload, payload)\n\n\treturn strings.TrimRight(string(payload), padding), nil\n}\n\n\nfunc CBCEncrypt(content string, password string) (string, error) {\n\tkey := passwordHash(password)\n\tblock, err := aes.NewCipher(key)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tpadded := pad(content)\n\tciphertext := make([]byte, aes.BlockSize+len(padded))\n\tiv := ciphertext[:aes.BlockSize]\n\t_, err = io.ReadFull(rand.Reader, iv)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tmode := cipher.NewCBCEncrypter(block, iv)\n\tmode.CryptBlocks(ciphertext[aes.BlockSize:], []byte(padded))\n\treturn base64.StdEncoding.EncodeToString(ciphertext), nil\n}\n\n\n\n\n\nfunc passwordHash(password string) []byte {\n\thasher := sha256.New()\n\thasher.Write([]byte(password))\n\treturn hasher.Sum(nil)\n}\n\nfunc pad(content string) string ", "output": "{\n\treturn content + strings.Repeat(padding,\n\t\tbits.AES-len(content)%bits.AES)\n}"}
{"input": "package pttw\n\nimport (\n\t\"github.com/assertgo/assert\"\n\t\"testing\"\n\t\"bytes\"\n)\n\n\n\nfunc TestWriterShouldWriteSliceDelimitedWithSpaces(t *testing.T) {\n\tassert := assert.New(t)\n\tbuffer := bytes.Buffer{}\n\tWrite([]float64{1, 2}, &buffer)\n\tassert.That(true).IsEqualTo(true)\n\tassert.That(buffer.String()).IsEqualTo(\"1 2\\n\")\n}\n\nfunc TestWriterShouldWriteSlice(t *testing.T) ", "output": "{\n\tassert := assert.New(t)\n\tbuffer := bytes.Buffer{}\n\tWrite([]float64{1}, &buffer)\n\tassert.That(true).IsEqualTo(true)\n\tassert.That(buffer.String()).IsEqualTo(\"1\\n\")\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSECSService_NetworkConfiguration struct {\n\n\tAwsvpcConfiguration *AWSECSService_AwsVpcConfiguration `json:\"AwsvpcConfiguration,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSECSService_NetworkConfiguration) AWSCloudFormationType() string {\n\treturn \"AWS::ECS::Service.NetworkConfiguration\"\n}\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\n\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSECSService_NetworkConfiguration) SetMetadata(metadata map[string]interface{}) ", "output": "{\n\tr._metadata = metadata\n}"}
{"input": "package gorocksdb\n\nimport (\n\t\"testing\"\n\n\t\"github.com/facebookgo/ensure\"\n)\n\nfunc TestSliceTransform(t *testing.T) {\n\tdb := newTestDB(t, \"TestSliceTransform\", func(opts *Options) {\n\t\topts.SetPrefixExtractor(&testSliceTransform{})\n\t})\n\tdefer db.Close()\n\n\two := NewDefaultWriteOptions()\n\tensure.Nil(t, db.Put(wo, []byte(\"foo1\"), []byte(\"foo\")))\n\tensure.Nil(t, db.Put(wo, []byte(\"foo2\"), []byte(\"foo\")))\n\tensure.Nil(t, db.Put(wo, []byte(\"bar1\"), []byte(\"bar\")))\n\n\titer := db.NewIterator(NewDefaultReadOptions())\n\tdefer iter.Close()\n\tprefix := []byte(\"foo\")\n\tnumFound := 0\n\tfor iter.Seek(prefix); iter.ValidForPrefix(prefix); iter.Next() {\n\t\tnumFound++\n\t}\n\tensure.Nil(t, iter.Err())\n\tensure.DeepEqual(t, numFound, 2)\n}\n\n\n\nfunc TestNewNoopPrefixTransform(t *testing.T) {\n\tdb := newTestDB(t, \"TestNewNoopPrefixTransform\", func(opts *Options) {\n\t\topts.SetPrefixExtractor(NewNoopPrefixTransform())\n\t})\n\tdefer db.Close()\n}\n\ntype testSliceTransform struct {\n\tinitiated bool\n}\n\nfunc (st *testSliceTransform) Name() string                { return \"gorocksdb.test\" }\nfunc (st *testSliceTransform) Transform(src []byte) []byte { return src[0:3] }\nfunc (st *testSliceTransform) InDomain(src []byte) bool    { return len(src) >= 3 }\nfunc (st *testSliceTransform) InRange(src []byte) bool     { return len(src) == 3 }\n\nfunc TestFixedPrefixTransformOpen(t *testing.T) ", "output": "{\n\tdb := newTestDB(t, \"TestFixedPrefixTransformOpen\", func(opts *Options) {\n\t\topts.SetPrefixExtractor(NewFixedPrefixTransform(3))\n\t})\n\tdefer db.Close()\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\n\n\n\nfunc MFR(mass int) int {\n\treturn (mass / 3) - 2\n}\n\ntype D1 struct {\n\tmodules []int\n}\n\nfunc (d1 *D1) parse(line string) error {\n\tv, err := strconv.Atoi(line)\n\tif err == nil {\n\t\td1.modules = append(d1.modules, v)\n\t}\n\treturn err\n}\n\nfunc (d1 *D1) part1() (string, error) {\n\tsum := 0\n\tfor _, module := range d1.modules {\n\t\tsum += MFR(module)\n\t}\n\treturn fmt.Sprintf(\"Sum of fuel requirements is %d\", sum), nil\n}\n\nfunc TotalMFR(mass int) int {\n\treq := MFR(mass)\n\tif req > 0 {\n\t\treq += TotalMFR(req)\n\t} else {\n\t\treq = 0\n\t}\n\treturn req\n}\n\nfunc (d1 *D1) part2() (string, error) {\n\tsum := 0\n\tfor _, module := range d1.modules {\n\t\tsum += TotalMFR(module)\n\t}\n\treturn fmt.Sprintf(\"Sum of fuel requirements is %d\", sum), nil\n}\n\nfunc init() ", "output": "{\n\td1 := &D1{}\n\tchallenges[1] = &challenge{\"Day 01\", \"input/day01.txt\", d1}\n}"}
{"input": "package pagerduty\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/GoogleCloudPlatform/terraformer/terraformutils\"\n\tpagerduty \"github.com/heimweh/go-pagerduty/pagerduty\"\n)\n\ntype ScheduleGenerator struct {\n\tPagerDutyService\n}\n\n\n\nfunc (g *ScheduleGenerator) InitResources() error {\n\tclient, err := g.Client()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfuncs := []func(*pagerduty.Client) error{\n\t\tg.createScheduleResources,\n\t}\n\n\tfor _, f := range funcs {\n\t\terr := f(client)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (g *ScheduleGenerator) createScheduleResources(client *pagerduty.Client) error ", "output": "{\n\tvar offset = 0\n\toptions := pagerduty.ListSchedulesOptions{}\n\tfor {\n\t\toptions.Offset = offset\n\t\tresp, _, err := client.Schedules.List(&options)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, schedule := range resp.Schedules {\n\t\t\tg.Resources = append(g.Resources, terraformutils.NewSimpleResource(\n\t\t\t\tschedule.ID,\n\t\t\t\tfmt.Sprintf(\"schedule_%s\", schedule.Name),\n\t\t\t\t\"pagerduty_schedule\",\n\t\t\t\tg.ProviderName,\n\t\t\t\t[]string{},\n\t\t\t))\n\t\t}\n\t\tif !resp.More {\n\t\t\tbreak\n\t\t}\n\n\t\toffset += resp.Limit\n\t}\n\n\treturn nil\n}"}
{"input": "package vm\n\nimport (\n\t\"github.com/expanse-org/go-expanse/common\"\n\t\"github.com/expanse-org/go-expanse/common/math\"\n\t\"github.com/holiman/uint256\"\n)\n\n\n\n\n\n\n\n\nfunc calcMemSize64WithUint(off *uint256.Int, length64 uint64) (uint64, bool) {\n\tif length64 == 0 {\n\t\treturn 0, false\n\t}\n\toffset64, overflow := off.Uint64WithOverflow()\n\tif overflow {\n\t\treturn 0, true\n\t}\n\tval := offset64 + length64\n\treturn val, val < offset64\n}\n\n\n\nfunc getData(data []byte, start uint64, size uint64) []byte {\n\tlength := uint64(len(data))\n\tif start > length {\n\t\tstart = length\n\t}\n\tend := start + size\n\tif end > length {\n\t\tend = length\n\t}\n\treturn common.RightPadBytes(data[start:end], int(size))\n}\n\n\nfunc toWordSize(size uint64) uint64 {\n\tif size > math.MaxUint64-31 {\n\t\treturn math.MaxUint64/32 + 1\n\t}\n\n\treturn (size + 31) / 32\n}\n\nfunc allZero(b []byte) bool {\n\tfor _, byte := range b {\n\t\tif byte != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc calcMemSize64(off, l *uint256.Int) (uint64, bool) ", "output": "{\n\tif !l.IsUint64() {\n\t\treturn 0, true\n\t}\n\treturn calcMemSize64WithUint(off, l.Uint64())\n}"}
{"input": "package preload\n\nimport (\n\t\"net/url\"\n\n\t\"github.com/google/webpackager/resource\"\n\t\"github.com/google/webpackager/resource/httplink\"\n)\n\n\nconst (\n\tAsAudio    = \"audio\"\n\tAsDocument = \"document\"\n\tAsEmbed    = \"embed\"\n\tAsFetch    = \"fetch\"\n\tAsFont     = \"font\"\n\tAsImage    = \"image\"\n\tAsObject   = \"object\"\n\tAsScript   = \"script\"\n\tAsStyle    = \"style\"\n\tAsTrack    = \"track\"\n\tAsWorker   = \"worker\"\n\tAsVideo    = \"video\"\n)\n\n\ntype Preload struct {\n\t*httplink.Link\n\n\tResources []*resource.Resource\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc NewPreloadForLink(link *httplink.Link) *Preload {\n\tr := resource.NewResource(link.URL)\n\treturn &Preload{link, []*resource.Resource{r}}\n}\n\n\n\n\n\n\nfunc NewPreloadForResource(r *resource.Resource, as string) *Preload {\n\tlink := httplink.NewLink(r.RequestURL, httplink.RelPreload)\n\tif as != \"\" {\n\t\tlink.Params.Set(httplink.ParamAs, as)\n\t}\n\treturn &Preload{link, []*resource.Resource{r}}\n}\n\nfunc NewPreloadForURL(u *url.URL, as string) *Preload ", "output": "{\n\tlink := httplink.NewLink(u, httplink.RelPreload)\n\tif as != \"\" {\n\t\tlink.Params.Set(httplink.ParamAs, as)\n\t}\n\treturn &Preload{link, []*resource.Resource{resource.NewResource(u)}}\n}"}
{"input": "package synth\n\nimport \"strings\"\n\ntype builder struct {\n\tb []string\n}\n\n\n\nfunc (b *builder) push(s ...string) {\n\tb.b = append(b.b, s...)\n}\n\nfunc (b *builder) csv(values []string, each func(string)) {\n\tfor i, value := range values {\n\t\teach(value)\n\t\tif i != len(values)-1 {\n\t\t\tb.push(\",\")\n\t\t}\n\t}\n}\n\nfunc (b *builder) values(hdr []string) {\n\tb.push(\"VALUES (\")\n\tb.csv(hdr, func(string) {\n\t\tb.push(\"?\")\n\t})\n\tb.push(\");\")\n}\n\nfunc (b *builder) join() string {\n\treturn strings.Join(b.b, \" \")\n}\n\n\n\nfunc CreateTable(temporary bool, name string, header []string) string {\n\tb := build(\"CREATE\")\n\n\tif temporary {\n\t\tb.push(\"TEMPORARY\")\n\t}\n\n\tb.push(\"TABLE\", name, \"(\")\n\n\tb.csv(header, func(h string) {\n\t\tb.push(h, \"TEXT\")\n\t})\n\n\tb.push(\");\")\n\n\treturn b.join()\n}\n\n\n\n\nfunc Insert(name string, header []string) string {\n\tb := build(\"INSERT INTO\", name, \"(\")\n\n\tb.csv(header, func(h string) {\n\t\tb.push(h)\n\t})\n\n\tb.push(\")\")\n\tb.values(header)\n\treturn b.join()\n}\n\n\n\nfunc Values(preface string, header []string) string {\n\tb := build(preface)\n\tb.values(header)\n\treturn b.join()\n}\n\nfunc build(s ...string) *builder ", "output": "{\n\tb := &builder{\n\t\tb: s,\n\t}\n\treturn b\n}"}
{"input": "package dbtest\n\nimport (\n\t\"fmt\"\n\t\"github.com/muesli/cache2go\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar cachegoclient *cache2go.CacheTable\n\n\n\nfunc BenchmarkBSet(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tkey := fmt.Sprintf(\"key%v\", i)\n\t\tvalue := fmt.Sprintf(\"value%v\", i)\n\t\tcachegoclient.Add(key, 5*time.Minute, value)\n\t}\n}\n\nfunc BenchmarkBGet(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tkey := fmt.Sprintf(\"key%v\", i)\n\t\tcachegoclient.Value(key)\n\t}\n}\n\nfunc init() ", "output": "{\n\tcachegoclient = cache2go.Cache(\"mycache\")\n}"}
{"input": "package stringutil\n\nimport \"sort\"\n\n\ntype StringCount struct {\n\tKey   string\n\tCount int\n}\n\n\ntype StringCountList []StringCount\n\nfunc (b StringCountList) Len() int { return len(b) }\nfunc (b StringCountList) Less(i, j int) bool {\n\tif b[i].Count < b[j].Count {\n\t\treturn true\n\t}\n\tif b[i].Count == b[j].Count {\n\t\tif b[i].Key < b[j].Key {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn false\n}\nfunc (b StringCountList) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\n\n\ntype ReversedStringCountList struct {\n\tStringCountList\n}\n\n\nfunc (b ReversedStringCountList) Less(i, j int) bool {\n\tif b.StringCountList[i].Count > b.StringCountList[j].Count {\n\t\treturn true\n\t}\n\tif b.StringCountList[i].Count == b.StringCountList[j].Count {\n\t\tif b.StringCountList[i].Key < b.StringCountList[j].Key {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\treturn false\n}\n\n\n\n\n\nfunc SortCountOfString(count map[string]int, reverse bool) StringCountList {\n\tcountList := make(StringCountList, len(count))\n\ti := 0\n\tfor b, c := range count {\n\t\tcountList[i] = StringCount{b, c}\n\t\ti++\n\t}\n\tif reverse {\n\t\tsort.Sort(ReversedStringCountList{countList})\n\t} else {\n\t\tsort.Sort(countList)\n\t}\n\treturn countList\n}\n\nfunc CountOfString(s []string) map[string]int ", "output": "{\n\tcount := make(map[string]int)\n\tfor _, b := range s {\n\t\tcount[b]++\n\t}\n\treturn count\n}"}
{"input": "package handlers\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/doubledutch/dd-vote/api/auth\"\n\t\"github.com/jinzhu/gorm\"\n\n\t\"github.com/doubledutch/dd-vote/api/models/resp\"\n\t\"github.com/doubledutch/dd-vote/api/models/table\"\n\t\"github.com/gin-gonic/gin\"\n)\n\n\ntype CommentHandler struct {\n\tdb *gorm.DB\n}\n\n\n\n\n\nfunc (handler CommentHandler) CreateComment(c *gin.Context) {\n\tpostUUID := c.Param(\"puuid\")\n\tvar post table.Post\n\tif err := handler.db.Where(\"uuid = ?\", postUUID).First(&post).Error; err != nil {\n\t\tc.JSON(http.StatusNotFound, resp.APIResponse{IsError: true, Message: \"Question does not exist\"})\n\t\treturn\n\t}\n\n\tvar comment table.Comment\n\tc.Bind(&comment)\n\tif !comment.IsValidForCreate() {\n\t\tc.JSON(http.StatusBadRequest, resp.APIResponse{IsError: true, Message: \"Invalid data\"})\n\t\treturn\n\t}\n\tcomment.PostID = post.ID\n\tcomment.UserID = auth.GetUserIDFromCookie(c)\n\n\tif err := handler.db.Create(&comment).Error; err != nil {\n\t\tc.JSON(http.StatusInternalServerError, resp.APIResponse{IsError: true, Message: \"Unknown error\"})\n\t\treturn\n\t}\n\n\thandler.db.Preload(\"User\").Find(&comment)\n\n\tc.JSON(http.StatusCreated, resp.APIResponse{IsError: false, Value: comment})\n}\n\nfunc NewCommentHandler(db *gorm.DB) *CommentHandler ", "output": "{\n\treturn &CommentHandler{db: db}\n}"}
{"input": "package core\n\nimport \"fmt\"\n\n\ntype Job struct {\n\tID         int\n\tName       string\n\tSteps      []Step\n\tContext    map[string]interface{}\n\tBefore     []Action\n\tAfter      []Action\n}\n\n\n\n\n\nfunc (instance Job) AddStep(step Step) Job {\n\tsteps := append(instance.Steps, step)\n\tinstance.Steps = steps\n\treturn instance\n}\n\nfunc (instance Job) CreateStep() Step ", "output": "{\n\treturn Step{\n\t\tID:         len(instance.Steps),\n\t\tName:       fmt.Sprintf(\"Step #%v\", len(instance.Steps)+1),\n\t\tJobID:      instance.ID,\n\t\tAssertions: []Assertion{},\n\t\tExtractors: []Extractor{},\n\t}\n}"}
{"input": "package client\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/docker/engine-api/types\"\n\t\"golang.org/x/net/context\"\n)\n\n\nfunc (cli *Client) ContainerExecCreate(ctx context.Context, container string, config types.ExecConfig) (types.ContainerExecCreateResponse, error) {\n\tvar response types.ContainerExecCreateResponse\n\tresp, err := cli.post(ctx, \"/containers/\"+container+\"/exec\", nil, config, nil)\n\tif err != nil {\n\t\treturn response, err\n\t}\n\terr = json.NewDecoder(resp.body).Decode(&response)\n\tensureReaderClosed(resp)\n\treturn response, err\n}\n\n\nfunc (cli *Client) ContainerExecStart(ctx context.Context, execID string, config types.ExecStartCheck) error {\n\tresp, err := cli.post(ctx, \"/exec/\"+execID+\"/start\", nil, config, nil)\n\tensureReaderClosed(resp)\n\treturn err\n}\n\n\n\n\n\nfunc (cli *Client) ContainerExecAttach(ctx context.Context, execID string, config types.ExecConfig) (types.HijackedResponse, error) {\n\theaders := map[string][]string{\"Content-Type\": {\"application/json\"}}\n\treturn cli.postHijacked(ctx, \"/exec/\"+execID+\"/start\", nil, config, headers)\n}\n\n\n\n\nfunc (cli *Client) ContainerExecInspect(ctx context.Context, execID string) (types.ContainerExecInspect, error) ", "output": "{\n\tvar response types.ContainerExecInspect\n\tresp, err := cli.get(ctx, \"/exec/\"+execID+\"/json\", nil, nil)\n\tif err != nil {\n\t\treturn response, err\n\t}\n\n\terr = json.NewDecoder(resp.body).Decode(&response)\n\tensureReaderClosed(resp)\n\treturn response, err\n}"}
{"input": "package client \n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/url\"\n\n\t\"github.com/tiborvass/docker/api/types\"\n\t\"github.com/tiborvass/docker/api/types/filters\"\n\t\"github.com/tiborvass/docker/api/types/swarm\"\n)\n\n\n\n\nfunc (cli *Client) ServiceList(ctx context.Context, options types.ServiceListOptions) ([]swarm.Service, error) ", "output": "{\n\tquery := url.Values{}\n\n\tif options.Filters.Len() > 0 {\n\t\tfilterJSON, err := filters.ToJSON(options.Filters)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tquery.Set(\"filters\", filterJSON)\n\t}\n\n\tif options.Status {\n\t\tquery.Set(\"status\", \"true\")\n\t}\n\n\tresp, err := cli.get(ctx, \"/services\", query, nil)\n\tdefer ensureReaderClosed(resp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar services []swarm.Service\n\terr = json.NewDecoder(resp.body).Decode(&services)\n\treturn services, err\n}"}
{"input": "package feeds\n\nimport (\n\t\"testing\"\n\t\"net/url\"\n)\n\nvar tests = []struct {\n\turl string\n\tid string\n\texpected string\n}{\n\t{\"http://example.com/feeds/\", \"123\", \"http://example.com/feeds/123\"},\n\t{\"http://example.com/feeds\", \"123\", \"http://example.com/feeds/123\"},\n\t{\"http://example.com/feeds\", \"otherId\", \"http://example.com/feeds/otherId\"},\n\t{\"http://otherexample.com/feeds\", \"otherId\", \"http://otherexample.com/feeds/otherId\"},\n\t{\"http://localhost/feeds\", \"otherId\", \"http://localhost/feeds/otherId\"},\n\t{\"http://localhost:8080/feeds\", \"otherId\", \"http://localhost:8080/feeds/otherId\"},\n\t{\"https://localhost:8080/feeds\", \"otherId\", \"https://localhost:8080/feeds/otherId\"},\n\t{\"https://localhost:8080/somePrefix/feeds\", \"otherId\", \"https://localhost:8080/feeds/otherId\"},\n}\n\n\n\nfunc TestInputs(t *testing.T) ", "output": "{\n\tfor _, tt := range tests {\n\t\tu, _ := url.Parse(tt.url)\n\t\tactual := getFeedPath(u, tt.id)\n\t\tif actual != tt.expected {\n\t\t\tt.Errorf(\"Got %v, expected %v for url: %v, id: %v\",\n\t\t\tactual, tt.expected, tt.url, tt.id)\n\t\t}\n\t}\n}"}
{"input": "package customer\n\nimport (\n\t\"testing\"\n\n\tassert \"github.com/stretchr/testify/require\"\n\tstripe \"github.com/stripe/stripe-go\"\n\t_ \"github.com/stripe/stripe-go/testing\"\n)\n\nfunc TestCustomerDel(t *testing.T) {\n\tcustomer, err := Del(\"cus_123\", nil)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, customer)\n}\n\n\n\nfunc TestCustomerList(t *testing.T) {\n\ti := List(&stripe.CustomerListParams{})\n\n\tassert.True(t, i.Next())\n\tassert.Nil(t, i.Err())\n\tassert.NotNil(t, i.Customer())\n}\n\nfunc TestCustomerNew(t *testing.T) {\n\tcustomer, err := New(&stripe.CustomerParams{\n\t\tEmail: stripe.String(\"foo@example.com\"),\n\t\tShipping: &stripe.CustomerShippingDetailsParams{\n\t\t\tAddress: &stripe.AddressParams{\n\t\t\t\tLine1: stripe.String(\"line1\"),\n\t\t\t\tCity:  stripe.String(\"city\"),\n\t\t\t},\n\t\t\tName: stripe.String(\"name\"),\n\t\t},\n\t})\n\tassert.Nil(t, err)\n\tassert.NotNil(t, customer)\n}\n\nfunc TestCustomerNew_NilParams(t *testing.T) {\n\tcustomer, err := New(nil)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, customer)\n}\n\nfunc TestCustomerUpdate(t *testing.T) {\n\tcustomer, err := Update(\"cus_123\", &stripe.CustomerParams{\n\t\tEmail: stripe.String(\"foo@example.com\"),\n\t})\n\tassert.Nil(t, err)\n\tassert.NotNil(t, customer)\n}\n\nfunc TestCustomerGet(t *testing.T) ", "output": "{\n\tcustomer, err := Get(\"cus_123\", nil)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, customer)\n}"}
{"input": "package mediatype\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n)\n\nvar encoders = make(map[string]EncoderFunc)\n\n\ntype EncoderFunc func(w io.Writer) Encoder\n\n\ntype Encoder interface {\n\tEncode(v interface{}) error\n}\n\n\nfunc AddEncoder(format string, encfunc EncoderFunc) {\n\tencoders[format] = encfunc\n}\n\n\n\nfunc (m *MediaType) Encoder(w io.Writer) (Encoder, error) {\n\tif encfunc, ok := encoders[m.Format]; ok {\n\t\treturn encfunc(w), nil\n\t}\n\treturn nil, fmt.Errorf(\"No encoder found for format %s (%s)\", m.Format, m.String())\n}\n\n\n\n\n\nfunc (m *MediaType) Encode(v interface{}) (*bytes.Buffer, error) ", "output": "{\n\tif v == nil {\n\t\treturn nil, fmt.Errorf(\"Nothing to encode\")\n\t}\n\n\tbuf := new(bytes.Buffer)\n\tenc, err := m.Encoder(buf)\n\tif err != nil {\n\t\treturn buf, err\n\t}\n\n\treturn buf, enc.Encode(v)\n}"}
{"input": "package vsphere\n\nimport (\n\t\"github.com/juju/errors\"\n\n\t\"github.com/juju/juju/storage\"\n)\n\n\n\n\n\nfunc (*environ) StorageProvider(t storage.ProviderType) (storage.Provider, error) {\n\treturn nil, errors.NotFoundf(\"storage provider %q\", t)\n}\n\nfunc (*environ) StorageProviderTypes() ([]storage.ProviderType, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "package Filter\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/reactivego/scheduler\"\n\t\"github.com/reactivego/subscriber\"\n)\n\n\n\n\ntype Scheduler = scheduler.Scheduler\n\n\n\n\n\n\ntype Subscriber = subscriber.Subscriber\n\n\n\n\n\n\n\n\n\ntype IntObserver func(next int, err error, done bool)\n\n\n\n\n\ntype ObservableInt func(IntObserver, Scheduler, Subscriber)\n\n\n\n\nfunc FromInt(slice ...int) ObservableInt {\n\tobservable := func(observe IntObserver, scheduler Scheduler, subscriber Subscriber) {\n\t\ti := 0\n\t\trunner := scheduler.ScheduleRecursive(func(self func()) {\n\t\t\tif subscriber.Subscribed() {\n\t\t\t\tif i < len(slice) {\n\t\t\t\t\tobserve(slice[i], nil, false)\n\t\t\t\t\tif subscriber.Subscribed() {\n\t\t\t\t\t\ti++\n\t\t\t\t\t\tself()\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar zero int\n\t\t\t\t\tobserve(zero, nil, true)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tsubscriber.OnUnsubscribe(runner.Cancel)\n\t}\n\treturn observable\n}\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (o ObservableInt) Println(a ...interface{}) error {\n\tsubscriber := subscriber.New()\n\tscheduler := scheduler.MakeTrampoline()\n\tobserver := func(next int, err error, done bool) {\n\t\tif !done {\n\t\t\tfmt.Println(append(a, next)...)\n\t\t} else {\n\t\t\tsubscriber.Done(err)\n\t\t}\n\t}\n\tsubscriber.OnWait(scheduler.Wait)\n\to(observer, scheduler, subscriber)\n\treturn subscriber.Wait()\n}\n\nfunc (o ObservableInt) Filter(predicate func(next int) bool) ObservableInt ", "output": "{\n\tobservable := func(observe IntObserver, subscribeOn Scheduler, subscriber Subscriber) {\n\t\tobserver := func(next int, err error, done bool) {\n\t\t\tif done || predicate(next) {\n\t\t\t\tobserve(next, err, done)\n\t\t\t}\n\t\t}\n\t\to(observer, subscribeOn, subscriber)\n\t}\n\treturn observable\n}"}
{"input": "package service\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-openapi/runtime\"\n\n\t\"github.com/cilium/cilium/api/v1/models\"\n)\n\n\nconst GetServiceIDOKCode int = 200\n\n\ntype GetServiceIDOK struct {\n\n\tPayload *models.Service `json:\"body,omitempty\"`\n}\n\n\nfunc NewGetServiceIDOK() *GetServiceIDOK {\n\n\treturn &GetServiceIDOK{}\n}\n\n\nfunc (o *GetServiceIDOK) WithPayload(payload *models.Service) *GetServiceIDOK {\n\to.Payload = payload\n\treturn o\n}\n\n\nfunc (o *GetServiceIDOK) SetPayload(payload *models.Service) {\n\to.Payload = payload\n}\n\n\n\n\n\nconst GetServiceIDNotFoundCode int = 404\n\n\ntype GetServiceIDNotFound struct {\n}\n\n\nfunc NewGetServiceIDNotFound() *GetServiceIDNotFound {\n\n\treturn &GetServiceIDNotFound{}\n}\n\n\nfunc (o *GetServiceIDNotFound) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {\n\n\trw.Header().Del(runtime.HeaderContentType) \n\n\trw.WriteHeader(404)\n}\n\nfunc (o *GetServiceIDOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) ", "output": "{\n\n\trw.WriteHeader(200)\n\tif o.Payload != nil {\n\t\tpayload := o.Payload\n\t\tif err := producer.Produce(rw, payload); err != nil {\n\t\t\tpanic(err) \n\t\t}\n\t}\n}"}
{"input": "package stringutil\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n)\n\n\n\n\n\n\nfunc Rstrip(s string) string ", "output": "{\n\treturn strings.TrimRightFunc(s, unicode.IsSpace)\n}"}
{"input": "package driver\n\nimport (\n\t\"github.com/WeisswurstSystems/WWM-BB/user\"\n)\n\ntype memoryStore struct {\n\tdata map[string]user.User\n}\n\n\nfunc NewMemoryStore() user.Store {\n\tstore := memoryStore{\n\t\tdata: make(map[string]user.User),\n\t}\n\treturn &store\n}\n\n\n\nfunc (m *memoryStore) FindAll() (users []user.User, err error) {\n\tfor _, u := range m.data {\n\t\tusers = append(users, u)\n\t}\n\treturn users, nil\n}\n\nfunc (m *memoryStore) FindByRegistrationID(registrationID string) (user.User, error) {\n\tfor _, u := range m.data {\n\t\tif u.RegistrationID == registrationID {\n\t\t\treturn u, nil\n\t\t}\n\t}\n\treturn user.User{}, user.ErrNotFound\n}\n\nfunc (m *memoryStore) Save(u user.User) error {\n\tm.data[u.Login.Mail] = u\n\treturn nil\n}\n\nfunc (m *memoryStore) RemoveByMail(mail string) error {\n\tdelete(m.data, mail)\n\treturn nil\n}\n\nfunc (m *memoryStore) FindByMail(mail string) (user.User, error) ", "output": "{\n\tu, ok := m.data[mail]\n\tif !ok {\n\t\treturn user.User{}, user.ErrNotFound\n\t}\n\treturn u, nil\n}"}
{"input": "package service\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-openapi/runtime\"\n\n\t\"github.com/cilium/cilium/api/v1/models\"\n)\n\n\nconst GetServiceIDOKCode int = 200\n\n\ntype GetServiceIDOK struct {\n\n\tPayload *models.Service `json:\"body,omitempty\"`\n}\n\n\n\n\n\nfunc (o *GetServiceIDOK) WithPayload(payload *models.Service) *GetServiceIDOK {\n\to.Payload = payload\n\treturn o\n}\n\n\nfunc (o *GetServiceIDOK) SetPayload(payload *models.Service) {\n\to.Payload = payload\n}\n\n\nfunc (o *GetServiceIDOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {\n\n\trw.WriteHeader(200)\n\tif o.Payload != nil {\n\t\tpayload := o.Payload\n\t\tif err := producer.Produce(rw, payload); err != nil {\n\t\t\tpanic(err) \n\t\t}\n\t}\n}\n\n\nconst GetServiceIDNotFoundCode int = 404\n\n\ntype GetServiceIDNotFound struct {\n}\n\n\nfunc NewGetServiceIDNotFound() *GetServiceIDNotFound {\n\n\treturn &GetServiceIDNotFound{}\n}\n\n\nfunc (o *GetServiceIDNotFound) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {\n\n\trw.Header().Del(runtime.HeaderContentType) \n\n\trw.WriteHeader(404)\n}\n\nfunc NewGetServiceIDOK() *GetServiceIDOK ", "output": "{\n\n\treturn &GetServiceIDOK{}\n}"}
{"input": "package gps\n\nimport (\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/armon/go-radix\"\n)\n\n\n\n\n\n\n\n\n\ntype deducerTrie struct {\n\tsync.RWMutex\n\tt *radix.Tree\n}\n\nfunc newDeducerTrie() *deducerTrie {\n\treturn &deducerTrie{\n\t\tt: radix.New(),\n\t}\n}\n\n\nfunc (t *deducerTrie) Delete(s string) (pathDeducer, bool) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tif d, had := t.t.Delete(s); had {\n\t\treturn d.(pathDeducer), had\n\t}\n\treturn nil, false\n}\n\n\nfunc (t *deducerTrie) Insert(s string, d pathDeducer) (pathDeducer, bool) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tif d2, had := t.t.Insert(s, d); had {\n\t\treturn d2.(pathDeducer), had\n\t}\n\treturn nil, false\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc isPathPrefixOrEqual(pre, path string) bool {\n\tprflen, pathlen := len(pre), len(path)\n\tif pathlen == prflen+1 {\n\t\treturn false\n\t}\n\n\treturn prflen == pathlen || strings.Index(path[prflen:], \"/\") == 0\n}\n\nfunc (t *deducerTrie) LongestPrefix(s string) (string, pathDeducer, bool) ", "output": "{\n\tt.RLock()\n\tdefer t.RUnlock()\n\tif p, d, has := t.t.LongestPrefix(s); has {\n\t\treturn p, d.(pathDeducer), has\n\t}\n\treturn \"\", nil, false\n}"}
{"input": "package main\n\nimport \"strings\"\n\ntype code_section interface {\n\tCode() bool\n}\n\ntype para string\n\n\n\ntype code string\n\nfunc (code) Code() bool {\n\treturn true\n}\n\ntype Article struct {\n\tTitle               string\n\tIntro               []para\n\tGoCode, ReflectCode []code_section\n\tUses, Tags          []string\n\tslug                string\n}\n\nfunc (a *Article) Slug() string {\n\tif a.slug == \"\" {\n\t\ta.slug = strings.ToLower(strings.Replace(a.Title, \" \", \"-\", -1))\n\t}\n\treturn a.slug\n}\n\ntype Articles []*Article\n\nfunc (a *Articles) Add(ao *Article) {\n\t*a = append(*a, ao)\n}\n\nfunc (a Articles) Len() int {\n\treturn len(a)\n}\n\nfunc (a Articles) Swap(i, j int) {\n\ta[j], a[i] = a[i], a[j]\n}\n\nfunc (a Articles) Less(i, j int) bool {\n\treturn a[i].Title < a[j].Title\n}\n\nfunc (para) Code() bool ", "output": "{\n\treturn false\n}"}
{"input": "package autostart\n\nimport (\n\t\"context\"\n\t\"flag\"\n\n\t\"github.com/vmware/govmomi/govc/cli\"\n\t\"github.com/vmware/govmomi/vim25/types\"\n)\n\ntype remove struct {\n\t*AutostartFlag\n}\n\nfunc init() {\n\tcli.Register(\"host.autostart.remove\", &remove{})\n}\n\n\n\nfunc (cmd *remove) Process(ctx context.Context) error {\n\tif err := cmd.AutostartFlag.Process(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (cmd *remove) Usage() string {\n\treturn \"VM...\"\n}\n\nfunc (cmd *remove) Run(ctx context.Context, f *flag.FlagSet) error {\n\tvar powerInfo = types.AutoStartPowerInfo{\n\t\tStartAction:      \"none\",\n\t\tStartDelay:       -1,\n\t\tStartOrder:       -1,\n\t\tStopAction:       \"none\",\n\t\tStopDelay:        -1,\n\t\tWaitForHeartbeat: types.AutoStartWaitHeartbeatSettingSystemDefault,\n\t}\n\n\treturn cmd.ReconfigureVMs(f.Args(), powerInfo)\n}\n\nfunc (cmd *remove) Register(ctx context.Context, f *flag.FlagSet) ", "output": "{\n\tcmd.AutostartFlag, ctx = newAutostartFlag(ctx)\n\tcmd.AutostartFlag.Register(ctx, f)\n}"}
{"input": "package testutil\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"strings\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\nfunc CreateZip(contents map[string]string) *bytes.Buffer {\n\tvar result bytes.Buffer\n\tzipWriter := zip.NewWriter(&result)\n\tdefer zipWriter.Close()\n\tfor filename, fileContents := range contents {\n\t\tentryWriter, e := zipWriter.Create(filename)\n\t\tExpect(e).NotTo(HaveOccurred())\n\t\tentryWriter.Write([]byte(fileContents))\n\n\t}\n\te := zipWriter.Close()\n\tExpect(e).NotTo(HaveOccurred())\n\treturn &result\n}\n\n\n\nfunc VerifyZipFileEntry(reader *zip.Reader, expectedFilename string, expectedContent string) ", "output": "{\n\tvar foundEntries []string\n\tfor _, entry := range reader.File {\n\t\tif entry.Name == expectedFilename {\n\t\t\tcontent, e := entry.Open()\n\t\t\tExpect(e).NotTo(HaveOccurred())\n\t\t\tExpect(ioutil.ReadAll(content)).To(MatchRegexp(expectedContent), \"for filename \"+expectedFilename)\n\t\t\treturn\n\t\t}\n\t\tfoundEntries = append(foundEntries, entry.Name)\n\t}\n\tFail(\"Did not find entry with name \" + expectedFilename + \". Found only: \" + strings.Join(foundEntries, \", \"))\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/gophercloud/gophercloud\"\n\t\"github.com/gophercloud/gophercloud/openstack\"\n)\n\ntype identity struct {\n\tscV3 *gophercloud.ServiceClient\n}\n\ntype identityConfig struct {\n\tendpoint        string\n\tserviceUserName string\n\tservicePassword string\n}\n\n\n\nfunc newIdentityClient(config identityConfig) (*identity, error) ", "output": "{\n\topt := gophercloud.AuthOptions{\n\t\tIdentityEndpoint: config.endpoint + \"/v3/\",\n\t\tUsername:         config.serviceUserName,\n\t\tPassword:         config.servicePassword,\n\t\tTenantName:       \"service\",\n\t\tDomainID:         \"default\",\n\t\tAllowReauth:      true,\n\t}\n\tprovider, err := openstack.AuthenticatedClient(opt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tv3client, err := openstack.NewIdentityV3(provider, gophercloud.EndpointOpts{})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Unable to get keystone V3 client : %v\", err)\n\t}\n\n\tid := &identity{\n\t\tscV3: v3client,\n\t}\n\n\treturn id, err\n}"}
{"input": "package iso20022\n\n\ntype UndertakingAdvice1 struct {\n\n\tUndertakingIssuanceMessage *UndertakingIssuanceMessage `xml:\"UdrtkgIssncMsg\"`\n\n\tFirstAdvisingPartyAdditionalInformation *AdvisingPartyAdditionalInformation1 `xml:\"FrstAdvsgPtyAddtlInf,omitempty\"`\n\n\tSecondAdvisingPartyAdditionalInformation *AdvisingPartyAdditionalInformation1 `xml:\"ScndAdvsgPtyAddtlInf,omitempty\"`\n\n\tConfirmationDetails *UndertakingConfirmation1 `xml:\"ConfDtls,omitempty\"`\n\n\tDigitalSignature []*PartyAndSignature2 `xml:\"DgtlSgntr,omitempty\"`\n}\n\nfunc (u *UndertakingAdvice1) AddUndertakingIssuanceMessage() *UndertakingIssuanceMessage {\n\tu.UndertakingIssuanceMessage = new(UndertakingIssuanceMessage)\n\treturn u.UndertakingIssuanceMessage\n}\n\nfunc (u *UndertakingAdvice1) AddFirstAdvisingPartyAdditionalInformation() *AdvisingPartyAdditionalInformation1 {\n\tu.FirstAdvisingPartyAdditionalInformation = new(AdvisingPartyAdditionalInformation1)\n\treturn u.FirstAdvisingPartyAdditionalInformation\n}\n\nfunc (u *UndertakingAdvice1) AddSecondAdvisingPartyAdditionalInformation() *AdvisingPartyAdditionalInformation1 {\n\tu.SecondAdvisingPartyAdditionalInformation = new(AdvisingPartyAdditionalInformation1)\n\treturn u.SecondAdvisingPartyAdditionalInformation\n}\n\nfunc (u *UndertakingAdvice1) AddConfirmationDetails() *UndertakingConfirmation1 {\n\tu.ConfirmationDetails = new(UndertakingConfirmation1)\n\treturn u.ConfirmationDetails\n}\n\n\n\nfunc (u *UndertakingAdvice1) AddDigitalSignature() *PartyAndSignature2 ", "output": "{\n\tnewValue := new(PartyAndSignature2)\n\tu.DigitalSignature = append(u.DigitalSignature, newValue)\n\treturn newValue\n}"}
{"input": "package hash\n\nimport \"unsafe\"\n\nconst DJBInit uint32 = 5381\n\nfunc DJBCombine(acc, h uint32) uint32 {\n\treturn mul33(acc) + h\n}\n\nfunc DJB(hs ...uint32) uint32 {\n\tacc := DJBInit\n\tfor _, h := range hs {\n\t\tacc = DJBCombine(acc, h)\n\t}\n\treturn acc\n}\n\nfunc UInt32(u uint32) uint32 {\n\treturn u\n}\n\nfunc UInt64(u uint64) uint32 {\n\treturn mul33(uint32(u>>32)) + uint32(u&0xffffffff)\n}\n\nfunc Pointer(p unsafe.Pointer) uint32 {\n\tswitch unsafe.Sizeof(p) {\n\tcase 4:\n\t\treturn UInt32(uint32(uintptr(p)))\n\tcase 8:\n\t\treturn UInt64(uint64(uintptr(p)))\n\tdefault:\n\t\tpanic(\"unhandled pointer size\")\n\t}\n}\n\nfunc UIntPtr(p uintptr) uint32 {\n\tswitch unsafe.Sizeof(p) {\n\tcase 4:\n\t\treturn UInt32(uint32(p))\n\tcase 8:\n\t\treturn UInt64(uint64(p))\n\tdefault:\n\t\tpanic(\"unhandled pointer size\")\n\t}\n}\n\nfunc String(s string) uint32 {\n\th := DJBInit\n\tfor i := 0; i < len(s); i++ {\n\t\th = DJBCombine(h, uint32(s[i]))\n\t}\n\treturn h\n}\n\n\n\nfunc mul33(u uint32) uint32 ", "output": "{\n\treturn u<<5 + u\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n)\n\nconst source = `//\n// This file is automatically generated by generate.go -- Do not edit!\n//\npackage main\n\nimport (\nIMPORTS\n)\n\n`\n\n\n\n\nfunc listDirectories(path string) ([]string, error) {\n\tnames := []string{}\n\titems, err := ioutil.ReadDir(path)\n\tif err != nil {\n\t\treturn names, err\n\t}\n\n\tfor _, item := range items {\n\t\tif item.IsDir() {\n\t\t\tcurrentDir := filepath.Join(path, item.Name())\n\t\t\tnames = append(names, currentDir)\n\n\t\t\tsubNames, err := listDirectories(currentDir)\n\t\t\tif err == nil {\n\t\t\t\tnames = append(names, subNames...)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn names, nil\n}\n\nfunc main() {\n\timports, err := listDirectories(\"command/\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to list commands: %s\", err)\n\t}\n\n\toutput := source\n\toutput = strings.Replace(output, \"IMPORTS\", makeImports(imports), 1)\n\n\tfile, err := os.Create(\"commands.go\")\n\tdefer file.Close()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to write: %s\", err)\n\t}\n\n\t_, err = file.WriteString(output)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed writing: %s\", err)\n\t}\n\n}\n\nfunc makeImports(dirs []string) string ", "output": "{\n\timports := []string{}\n\n\tfor _, dir := range dirs {\n\t\timports = append(imports, fmt.Sprintf(\"\\t_ \\\"github.com/vtolstov/cloudagent/%s\\\"\\n\", dir))\n\t}\n\n\tsort.Strings(imports)\n\n\treturn strings.Join(imports, \"\")\n}"}
{"input": "package commands\n\nimport (\n\t\"github.com/gohugoio/hugo/releaser\"\n\t\"github.com/spf13/cobra\"\n)\n\nfunc init() {\n\tHugoCmd.AddCommand(createReleaser().cmd)\n}\n\ntype releaseCommandeer struct {\n\tcmd *cobra.Command\n\n\tpatchLevel int\n\n\tskipPublish bool\n\n\tstep int\n}\n\n\n\nfunc (r *releaseCommandeer) release() error {\n\treturn releaser.New(r.patchLevel, r.step, r.skipPublish).Run()\n}\n\nfunc createReleaser() *releaseCommandeer ", "output": "{\n\tr := &releaseCommandeer{\n\t\tcmd: &cobra.Command{\n\t\t\tUse:    \"release\",\n\t\t\tShort:  \"Release a new version of Hugo.\",\n\t\t\tHidden: true,\n\t\t},\n\t}\n\n\tr.cmd.RunE = func(cmd *cobra.Command, args []string) error {\n\t\treturn r.release()\n\t}\n\n\tr.cmd.PersistentFlags().IntVarP(&r.patchLevel, \"patch\", \"p\", 0, \"patch level, defaults to 0 for main releases\")\n\tr.cmd.PersistentFlags().IntVarP(&r.step, \"step\", \"s\", -1, \"release step, defaults to -1 for all steps.\")\n\tr.cmd.PersistentFlags().BoolVarP(&r.skipPublish, \"skip-publish\", \"\", false, \"skip all publishing pipes of the release\")\n\n\treturn r\n}"}
{"input": "package iso20022\n\n\ntype PartyAndAuthorisation3 struct {\n\n\tModificationCode *Modification1Code `xml:\"ModCd,omitempty\"`\n\n\tPartyOrGroup *PartyOrGroup1Choice `xml:\"PtyOrGrp\"`\n\n\tSignatureOrder *Max15PlusSignedNumericText `xml:\"SgntrOrdr,omitempty\"`\n\n\tAuthorisation *Authorisation2 `xml:\"Authstn\"`\n}\n\nfunc (p *PartyAndAuthorisation3) SetModificationCode(value string) {\n\tp.ModificationCode = (*Modification1Code)(&value)\n}\n\nfunc (p *PartyAndAuthorisation3) AddPartyOrGroup() *PartyOrGroup1Choice {\n\tp.PartyOrGroup = new(PartyOrGroup1Choice)\n\treturn p.PartyOrGroup\n}\n\nfunc (p *PartyAndAuthorisation3) SetSignatureOrder(value string) {\n\tp.SignatureOrder = (*Max15PlusSignedNumericText)(&value)\n}\n\n\n\nfunc (p *PartyAndAuthorisation3) AddAuthorisation() *Authorisation2 ", "output": "{\n\tp.Authorisation = new(Authorisation2)\n\treturn p.Authorisation\n}"}
{"input": "package metrics_test\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/gkarlik/quark-go\"\n\t\"github.com/gkarlik/quark-go/metrics/prometheus\"\n\t\"github.com/gkarlik/quark-go/middleware/metrics\"\n\ttr \"github.com/gkarlik/quark-go/service/trace/noop\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype TestService struct {\n\t*quark.ServiceBase\n}\n\ntype TestHttpHandler struct{}\n\nfunc (h *TestHttpHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"OK\"))\n}\n\nfunc TestMetricsMiddleware(t *testing.T) {\n\ta, _ := quark.GetHostAddress(1234)\n\n\tts := &TestService{\n\t\tServiceBase: quark.NewService(\n\t\t\tquark.Name(\"TestService\"),\n\t\t\tquark.Version(\"1.0\"),\n\t\t\tquark.Address(a),\n\t\t\tquark.Metrics(prometheus.NewMetricsExposer()),\n\t\t\tquark.Tracer(tr.NewTracer())),\n\t}\n\tdefer ts.Dispose()\n\n\tmm := metrics.NewRequestMetricsMiddleware(ts)\n\tr, _ := http.NewRequest(http.MethodGet, \"/test\", nil)\n\tw := httptest.NewRecorder()\n\th := mm.Handle(&TestHttpHandler{})\n\th.ServeHTTP(w, r)\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n}\n\n\n\nfunc TestMetricsMiddlewareWithNext(t *testing.T) ", "output": "{\n\ta, _ := quark.GetHostAddress(1234)\n\n\tts := &TestService{\n\t\tServiceBase: quark.NewService(\n\t\t\tquark.Name(\"TestService\"),\n\t\t\tquark.Version(\"1.0\"),\n\t\t\tquark.Address(a),\n\t\t\tquark.Metrics(prometheus.NewMetricsExposer()),\n\t\t\tquark.Tracer(tr.NewTracer())),\n\t}\n\tdefer ts.Dispose()\n\n\tmm := metrics.NewRequestMetricsMiddleware(ts)\n\tr, _ := http.NewRequest(http.MethodGet, \"/test\", nil)\n\tw := httptest.NewRecorder()\n\tth := &TestHttpHandler{}\n\tmm.HandleWithNext(w, r, th.ServeHTTP)\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n}"}
{"input": "package sqltrace\n\nimport (\n\t\"flag\"\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\t\"sync/atomic\"\n)\n\nfunc boolToInt64(f bool) int64 {\n\tif f {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\ntype sqlTrace struct {\n\ton int64 \n\n\t*log.Logger\n}\n\nfunc newSQLTrace() *sqlTrace {\n\treturn &sqlTrace{\n\t\tLogger: log.New(os.Stdout, \"hdb \", log.Ldate|log.Ltime|log.Lshortfile),\n\t}\n}\nfunc (t *sqlTrace) On() bool      { return atomic.LoadInt64(&t.on) != 0 }\nfunc (t *sqlTrace) SetOn(on bool) { atomic.StoreInt64(&t.on, boolToInt64(on)) }\n\ntype flagValue struct {\n\tt *sqlTrace\n}\n\nfunc (v flagValue) IsBoolFlag() bool { return true }\n\n\n\nfunc (v flagValue) Set(s string) error {\n\tf, err := strconv.ParseBool(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\tv.t.SetOn(f)\n\treturn nil\n}\n\nvar tracer = newSQLTrace()\n\nfunc init() {\n\tflag.Var(&flagValue{t: tracer}, \"hdb.sqlTrace\", \"enabling hdb sql trace\")\n}\n\n\nfunc On() bool { return tracer.On() }\n\n\nfunc SetOn(on bool) { tracer.SetOn(on) }\n\n\nfunc Trace(v ...interface{}) { tracer.Print(v...) }\n\n\nfunc Tracef(format string, v ...interface{}) { tracer.Printf(format, v...) }\n\n\nfunc Traceln(v ...interface{}) { tracer.Println(v...) }\n\nfunc (v flagValue) String() string ", "output": "{\n\tif v.t == nil {\n\t\treturn \"\"\n\t}\n\treturn strconv.FormatBool(v.t.On())\n}"}
{"input": "package util\n\nimport (\n\t\"fmt\"\n\n\tttnlog \"github.com/TheThingsNetwork/go-utils/log\"\n\t\"github.com/spf13/viper\"\n)\n\nfunc PrintConfig(ctx ttnlog.Interface, debug bool) {\n\tprt := ctx.Infof\n\tif debug {\n\t\tprt = ctx.Debugf\n\t}\n\n\tprt(\"Using config:\")\n\tfmt.Println()\n\tprintKV(\"config file\", viper.ConfigFileUsed())\n\tprintKV(\"data dir\", viper.GetString(\"data\"))\n\tfmt.Println()\n\n\tfor key, val := range viper.AllSettings() {\n\t\tswitch key {\n\t\tcase \"builddate\":\n\t\t\tfallthrough\n\t\tcase \"gitcommit\":\n\t\t\tfallthrough\n\t\tcase \"gitbranch\":\n\t\t\tfallthrough\n\t\tcase \"version\":\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tprintKV(key, val)\n\t\t}\n\t}\n\tfmt.Println()\n}\n\n\n\nfunc printKV(key, val interface{}) ", "output": "{\n\tfmt.Printf(\"%20s: %v\\n\", key, val)\n}"}
{"input": "package initio\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\ntype Servo struct {\n\tPin     int \n\tCurrent int \n}\n\nfunc NewServo(pin int) *Servo {\n\treturn &Servo{Pin: pin}\n}\n\n\nfunc (s *Servo) Set(degrees int) {\n\tmakeRequest(fmt.Sprintf(\"/api/servos/%s/set/%d\", servoNames[s.Pin], degrees))\n}\n\n\nfunc (s *Servo) Get() int {\n\tresult, _, _ := makeRequest(fmt.Sprintf(\"/api/servos/%s/get\", servoNames[s.Pin]))\n\ti, _ := strconv.Atoi(string(result))\n\treturn i\n}\n\n\n\n\nfunc (s *Servo) Inc(increment int) {\n}\n\n\nfunc StopServos() {\n}\n\n\nfunc StartServos() {\n}\n\nfunc (s *Servo) Reset() ", "output": "{\n\tmakeRequest(fmt.Sprintf(\"/api/servos/%s/reset\", servoNames[s.Pin]))\n}"}
{"input": "package metadata\n\nimport (\n\t\"context\"\n\n\t\"github.com/gravitational/teleport/api\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\nconst (\n\tVersionKey = \"version\"\n)\n\n\nfunc defaultMetadata() map[string]string {\n\treturn map[string]string{\n\t\tVersionKey: api.Version,\n\t}\n}\n\n\n\n\nfunc AddMetadataToContext(ctx context.Context, raw map[string]string) context.Context {\n\tmd := metadata.New(raw)\n\tif existingMd, ok := metadata.FromOutgoingContext(ctx); ok {\n\t\tfor key, vals := range existingMd {\n\t\t\tmd.Set(key, vals...)\n\t\t}\n\t}\n\treturn metadata.NewOutgoingContext(ctx, md)\n}\n\n\n\ntype DisableInterceptors struct{}\n\n\n\n\n\n\n\nfunc UnaryClientInterceptor(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {\n\tif disable := ctx.Value(DisableInterceptors{}); disable == nil {\n\t\tctx = AddMetadataToContext(ctx, defaultMetadata())\n\t}\n\treturn invoker(ctx, method, req, reply, cc, opts...)\n}\n\n\n\n\nfunc ClientVersionFromContext(ctx context.Context) (string, bool) {\n\tmd, ok := metadata.FromIncomingContext(ctx)\n\tif !ok {\n\t\treturn \"\", false\n\t}\n\tversionList := md.Get(VersionKey)\n\tif len(versionList) != 1 {\n\t\treturn \"\", false\n\t}\n\treturn versionList[0], true\n}\n\nfunc StreamClientInterceptor(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) ", "output": "{\n\tif disable := ctx.Value(DisableInterceptors{}); disable == nil {\n\t\tctx = AddMetadataToContext(ctx, defaultMetadata())\n\t}\n\treturn streamer(ctx, desc, cc, method, opts...)\n}"}
{"input": "package krberror\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n\nconst (\n\tseparator       = \" < \"\n\tEncodingError   = \"Encoding_Error\"\n\tNetworkingError = \"Networking_Error\"\n\tDecryptingError = \"Decrypting_Error\"\n\tEncryptingError = \"Encrypting_Error\"\n\tChksumError     = \"Checksum_Error\"\n\tKRBMsgError     = \"KRBMessage_Handling_Error\"\n\tConfigError     = \"Configuration_Error\"\n\tKDCError        = \"KDC_Error\"\n)\n\n\ntype Krberror struct {\n\tRootCause string\n\tEText     []string\n}\n\n\n\n\n\nfunc (e *Krberror) Add(et string, s string) {\n\te.EText = append([]string{fmt.Sprintf(\"%s: %s\", et, s)}, e.EText...)\n}\n\n\nfunc NewKrberror(et, s string) Krberror {\n\treturn Krberror{\n\t\tRootCause: et,\n\t\tEText:     []string{s},\n\t}\n}\n\n\nfunc Errorf(err error, et, format string, a ...interface{}) Krberror {\n\tif e, ok := err.(Krberror); ok {\n\t\te.Add(et, fmt.Sprintf(format, a...))\n\t\treturn e\n\t}\n\treturn NewErrorf(et, format+\": %s\", append(a, err)...)\n}\n\n\nfunc NewErrorf(et, format string, a ...interface{}) Krberror {\n\tvar s string\n\tif len(a) > 0 {\n\t\ts = fmt.Sprintf(\"%s: %s\", et, fmt.Sprintf(format, a...))\n\t} else {\n\t\ts = fmt.Sprintf(\"%s: %s\", et, format)\n\t}\n\treturn Krberror{\n\t\tRootCause: et,\n\t\tEText:     []string{s},\n\t}\n}\n\nfunc (e Krberror) Error() string ", "output": "{\n\treturn fmt.Sprintf(\"[Root cause: %s] \", e.RootCause) + strings.Join(e.EText, separator)\n}"}
{"input": "package main\n\nimport \"log\"\nimport \"os\"\nimport \"sync\"\nimport \"encoding/json\"\n\n\ntype GNConfigSlot struct {\n\tLabel, Filename string\n}\n\n\n\ntype GNConfig struct {\n\tSlots        [10]GNConfigSlot\n\tLastRecalled int\n}\n\nvar conf GNConfig\nvar conflock sync.RWMutex\n\nfunc init() {\n\terr := conf.Read()\n\tif err != nil {\n\t\tlog.Println(\"Configuration file not found. Creating a blank file.\")\n\t\tconf.Write()\n\t}\n}\n\n\n\nfunc (c *GNConfig) Read() error {\n\tfp, err := os.Open(\"/gn_config.json\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fp.Close()\n\n\tjdec := json.NewDecoder(fp)\n\terr = jdec.Decode(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (c *GNConfig) Write() {\n\tFSRemountRW()\n\tfp, err := os.Create(\"/gn_config.json\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tjenc := json.NewEncoder(fp)\n\terr = jenc.Encode(&c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = fp.Close()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tFSRemountRO()\n\treturn\n}\n\n\n\nfunc (c *GNConfig) ReadDone() {\n\tconflock.RUnlock()\n}\n\nfunc (c *GNConfig) WriteStart() {\n\tconflock.Lock()\n}\n\nfunc (c *GNConfig) WriteDone() {\n\tc.Write()\n\tconflock.Unlock()\n}\n\nfunc (c *GNConfig) ReadStart() ", "output": "{\n\tconflock.RLock()\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\ntype ErrorResponse struct {\n\n\tErrors []string `json:\"errors\"`\n\n\tMessage *string `json:\"message\"`\n}\n\n\nfunc (m *ErrorResponse) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateErrors(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateMessage(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n\n\nfunc (m *ErrorResponse) validateMessage(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"message\", \"body\", m.Message); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *ErrorResponse) validateErrors(formats strfmt.Registry) error ", "output": "{\n\n\tif swag.IsZero(m.Errors) { \n\t\treturn nil\n\t}\n\n\treturn nil\n}"}
{"input": "package generators\n\nimport (\n\t\"go-sysgen/src/definitions\"\n)\n\ntype (\n\tPrimaryStarGenerator struct{}\n)\n\n\nfunc (Generator PrimaryStarGenerator) GetName() string {\n\treturn \"PrimaryStarGenerator\"\n}\n\n\nfunc (Generator PrimaryStarGenerator) Run(system *definitions.System) {\n\tvar resultStar definitions.Star\n\tvar result interface{}\n\n\tresultStar.Primary = true\n\tresultStar.Dwarf = false\n\n\tclassProb := Generator.getStarClassProbability()\n\tresult = definitions.GetProbabilityResult(\n\t\tclassProb.RollAll(),\n\t\tclassProb.Lookup,\n\t)\n\tresultStar.Class = result.(string)\n\n\tsizeProb := Generator.getStarSizeProbability()\n\tresult = definitions.GetProbabilityResult(\n\t\tsizeProb.RollAll(),\n\t\tsizeProb.Lookup,\n\t)\n\tresultStar.Size = result.(string)\n\n\tresultStar.DecimalClassification = resultStar.GetDecimalClassification()\n\n\tresultStar.DwarfType = \"-\"\n\n\tsystem.Bodies = append(system.Bodies, resultStar)\n}\n\n\n\nfunc (Generator PrimaryStarGenerator) getStarSizeProbability() definitions.Probability {\n\tvar result definitions.Probability\n\n\tresult.Dice = append(result.Dice, definitions.Dice{\n\t\tSides: 10,\n\t}, definitions.Dice{\n\t\tSides: 10,\n\t})\n\n\tresult.Lookup = map[int]interface{}{\n\t\t2:  \"II\",\n\t\t4:  \"III\",\n\t\t8:  \"IV\",\n\t\t18: \"V\",\n\t\t20: \"VI\",\n\t}\n\n\treturn result\n}\n\nfunc (Generator PrimaryStarGenerator) getStarClassProbability() definitions.Probability ", "output": "{\n\tvar result definitions.Probability\n\n\tresult.Dice = append(result.Dice, definitions.Dice{\n\t\tSides: 10,\n\t}, definitions.Dice{\n\t\tSides: 10,\n\t})\n\n\tresult.Lookup = map[int]interface{}{\n\t\t3:  \"A\",\n\t\t7:  \"F\",\n\t\t12: \"G\",\n\t\t17: \"K\",\n\t\t20: \"M\",\n\t}\n\n\treturn result\n}"}
{"input": "package syscall\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Getpagesize() int { return 4096 }\n\nfunc Gettimeofday(tv *Timeval) (err error)\nfunc Time(t *Time_t) (tt Time_t, err error)\n\nfunc TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }\n\nfunc NsecToTimespec(nsec int64) (ts Timespec) {\n\tts.Sec = nsec / 1e9\n\tts.Nsec = nsec % 1e9\n\treturn\n}\n\nfunc TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }\n\nfunc NsecToTimeval(nsec int64) (tv Timeval) {\n\tnsec += 999 \n\ttv.Sec = nsec / 1e9\n\ttv.Usec = nsec % 1e9 / 1e3\n\treturn\n}\n\n\n\nfunc (r *PtraceRegs) SetPC(pc uint64) { r.Rip = pc }\n\nfunc (iov *Iovec) SetLen(length int) {\n\tiov.Len = uint64(length)\n}\n\nfunc (msghdr *Msghdr) SetControllen(length int) {\n\tmsghdr.Controllen = uint64(length)\n}\n\nfunc (cmsg *Cmsghdr) SetLen(length int) {\n\tcmsg.Len = uint64(length)\n}\n\nfunc (r *PtraceRegs) PC() uint64 ", "output": "{ return r.Rip }"}
{"input": "package field\n\nimport (\n\t\"sync\"\n\n\t\"github.com/elemchat/elemchat/wizard\"\n)\n\ntype Field struct {\n\tsync.Mutex\n\tWizards map[*wizard.Wizard]struct{}\n\trecv    chan wizard.Message\n\tclosed  bool\n}\n\ntype HandleFunc func(wizard.Message)\n\nfunc New(handle HandleFunc) *Field {\n\tf := &Field{\n\t\tMutex:   sync.Mutex{},\n\t\tWizards: make(map[*wizard.Wizard]struct{}),\n\t\trecv:    make(chan wizard.Message),\n\t\tclosed:  false,\n\t}\n\n\tgo f.loop(handle)\n\treturn f\n}\n\n\nfunc (f *Field) WithLock(fn func(*Field)) {\n\tf.Lock()\n\tfn(f)\n\tf.Unlock()\n}\n\nfunc (f *Field) Close() {\n\tf.WithLock(func(f *Field) {\n\t\tif f.closed {\n\t\t\treturn\n\t\t}\n\n\t\tgo func() {\n\t\t\tfor _ = range f.recv {\n\t\t\t}\n\t\t}()\n\n\t\tfor w, _ := range f.Wizards {\n\t\t\tw.Close(true)\n\t\t\tdelete(f.Wizards, w)\n\t\t}\n\t\tclose(f.recv)\n\t\tf.closed = true\n\t})\n}\n\nfunc (f *Field) Enter(fn func(recv chan<- wizard.Message) *wizard.Wizard) {\n\tf.WithLock(func(f *Field) {\n\t\tif f.closed {\n\t\t\treturn\n\t\t}\n\n\t\tw := fn(f.recv)\n\t\tif w != nil {\n\t\t\tf.Wizards[w] = struct{}{}\n\t\t}\n\t})\n}\n\n\n\nfunc (f *Field) loop(handle HandleFunc) ", "output": "{\n\tif handle == nil {\n\t\tf.Close()\n\t\treturn\n\t}\n\tfor message := range f.recv {\n\t\tif message.Msg() == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\thandle(message)\n\t}\n}"}
{"input": "package ui\n\nimport (\n\t\"fmt\"\n)\n\ntype SkipStageError struct {\n\tcause       error\n\tskipMessage string\n}\n\nfunc NewSkipStageError(cause error, skipMessage string) SkipStageError {\n\treturn SkipStageError{\n\t\tcause:       cause,\n\t\tskipMessage: skipMessage,\n\t}\n}\n\nfunc (e SkipStageError) Error() string {\n\treturn fmt.Sprintf(\"%s: %s\", e.skipMessage, e.cause)\n}\n\n\n\nfunc (e SkipStageError) Cause() error {\n\treturn e.cause\n}\n\nfunc (e SkipStageError) SkipMessage() string ", "output": "{\n\treturn e.skipMessage\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/coreos/rkt/Godeps/_workspace/src/github.com/appc/spec/discovery\"\n)\n\nvar (\n\tcmdDiscover = &Command{\n\t\tName:        \"discover\",\n\t\tDescription: \"Discover the download URLs for an app\",\n\t\tSummary:     \"Discover the download URLs for one or more app container images\",\n\t\tUsage:       \"APP...\",\n\t\tRun:         runDiscover,\n\t}\n)\n\n\n\nfunc runDiscover(args []string) (exit int) {\n\tif len(args) < 1 {\n\t\tstderr(\"discover: at least one name required\")\n\t}\n\n\tfor _, name := range args {\n\t\tapp, err := discovery.NewAppFromString(name)\n\t\tif app.Labels[\"os\"] == \"\" {\n\t\t\tapp.Labels[\"os\"] = runtime.GOOS\n\t\t}\n\t\tif app.Labels[\"arch\"] == \"\" {\n\t\t\tapp.Labels[\"arch\"] = runtime.GOARCH\n\t\t}\n\t\tif err != nil {\n\t\t\tstderr(\"%s: %s\", name, err)\n\t\t\treturn 1\n\t\t}\n\t\teps, attempts, err := discovery.DiscoverEndpoints(*app, transportFlags.Insecure)\n\t\tif err != nil {\n\t\t\tstderr(\"error fetching %s: %s\", name, err)\n\t\t\treturn 1\n\t\t}\n\t\tfor _, a := range attempts {\n\t\t\tfmt.Printf(\"discover walk: prefix: %s error: %v\\n\", a.Prefix, a.Error)\n\t\t}\n\t\tfor _, aciEndpoint := range eps.ACIEndpoints {\n\t\t\tfmt.Printf(\"ACI: %s, ASC: %s\\n\", aciEndpoint.ACI, aciEndpoint.ASC)\n\t\t}\n\t\tif len(eps.Keys) > 0 {\n\t\t\tfmt.Println(\"Keys: \" + strings.Join(eps.Keys, \",\"))\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc init() ", "output": "{\n\tcmdDiscover.Flags.BoolVar(&transportFlags.Insecure, \"insecure\", false,\n\t\t\"Allow insecure non-TLS downloads over http\")\n}"}
{"input": "package kafka\n\nimport (\n\t\"github.com/hyperledger/fabric/orderer/config\"\n\tab \"github.com/hyperledger/fabric/protos/orderer\"\n)\n\n\ntype Orderer interface {\n\tBroadcast(stream ab.AtomicBroadcast_BroadcastServer) error\n\tDeliver(stream ab.AtomicBroadcast_DeliverServer) error\n\tTeardown() error\n}\n\n\ntype Closeable interface {\n\tClose() error\n}\n\ntype serverImpl struct {\n\tbroadcaster Broadcaster\n\tdeliverer   Deliverer\n}\n\n\n\n\n\nfunc (s *serverImpl) Broadcast(stream ab.AtomicBroadcast_BroadcastServer) error {\n\treturn s.broadcaster.Broadcast(stream)\n}\n\n\nfunc (s *serverImpl) Deliver(stream ab.AtomicBroadcast_DeliverServer) error {\n\treturn s.deliverer.Deliver(stream)\n}\n\n\nfunc (s *serverImpl) Teardown() error {\n\ts.deliverer.Close()\n\treturn s.broadcaster.Close()\n}\n\nfunc New(conf *config.TopLevel) Orderer ", "output": "{\n\treturn &serverImpl{\n\t\tbroadcaster: newBroadcaster(conf),\n\t\tdeliverer:   newDeliverer(conf),\n\t}\n}"}
{"input": "package inmemory\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"gitlab.com/qaclana/qaclana/pkg/proto\"\n)\n\n\ntype InMemory struct {\n\n\ts qaclana.State\n\n\tns []chan (qaclana.State)\n}\n\n\nfunc WithState(s qaclana.State) *InMemory {\n\treturn &InMemory{s: s}\n}\n\n\nfunc (m *InMemory) Store(ctx context.Context, s qaclana.State) error {\n\tif m.s == s {\n\t\tlog.Printf(\"Given state (%s) is the same as the current one (%s)\", s, m.s)\n\t\treturn nil\n\t}\n\n\tlog.Printf(\"Setting state to %s\", s)\n\tm.s = s\n\tlog.Printf(\"Set state to %s\", m.s)\n\tm.NotifyAll(s)\n\treturn nil\n}\n\n\nfunc (m *InMemory) Notifier() (<-chan qaclana.State, error) {\n\tc := make(chan qaclana.State)\n\tm.ns = append(m.ns, c)\n\treturn c, nil\n}\n\n\nfunc (m *InMemory) Current() (qaclana.State, error) {\n\treturn m.s, nil\n}\n\n\n\n\nfunc (m *InMemory) NotifyAll(s qaclana.State) error ", "output": "{\n\tfor _, n := range m.ns {\n\t\tn <- s\n\t}\n\n\treturn nil\n}"}
{"input": "package conversions\n\nimport \"jvmgo/ch11/instructions/base\"\nimport \"jvmgo/ch11/rtda\"\n\n\ntype L2D struct{ base.NoOperandsInstruction }\n\nfunc (self *L2D) Execute(frame *rtda.Frame) {\n\tstack := frame.OperandStack()\n\tl := stack.PopLong()\n\td := float64(l)\n\tstack.PushDouble(d)\n}\n\n\ntype L2F struct{ base.NoOperandsInstruction }\n\nfunc (self *L2F) Execute(frame *rtda.Frame) {\n\tstack := frame.OperandStack()\n\tl := stack.PopLong()\n\tf := float32(l)\n\tstack.PushFloat(f)\n}\n\n\ntype L2I struct{ base.NoOperandsInstruction }\n\n\n\nfunc (self *L2I) Execute(frame *rtda.Frame) ", "output": "{\n\tstack := frame.OperandStack()\n\tl := stack.PopLong()\n\ti := int32(l)\n\tstack.PushInt(i)\n}"}
{"input": "package workshop\n\nimport (\n\t\"math\"\n)\n\n\ntype Shape interface {\n\tarea()\n\tcircumference()\n\tvolume()\n}\n\n\ntype Circle struct {\n\tradius float64\n\tPI     float64\n}\n\nfunc (circle *Circle) area() float64 {\n\treturn circle.PI * math.Pow(circle.radius, 2)\n}\n\n\n\n\ntype Square struct {\n\tside float64\n}\n\nfunc (square *Square) area() float64 {\n\treturn math.Pow(square.side, 2)\n}\n\ntype Sphere struct {\n\tPI     float64\n\tradius float64\n}\n\nfunc (sphere *Sphere) volume() float64 {\n\treturn (4 / 3) * sphere.PI * math.Pow(sphere.radius, 3)\n}\n\n\ntype Cube struct {\n\tside float64\n}\n\nfunc (cube *Cube) volume() float64 {\n\treturn math.Pow(cube.side, 3)\n}\n\nfunc (square *Square) volume() float64 {\n\treturn math.Pow(square.side, 3)\n}\n\n\ntype Rectangle struct {\n\theight int\n\twidth  int\n}\n\nfunc (rectangle *Rectangle) area() int {\n\treturn rectangle.height * rectangle.width\n}\n\nfunc interfaces() {\n\tcircle := Circle{radius: 5.5, PI: math.Pi}\n\tareaOfCircle := circle.area()\n\n\tassert(areaOfCircle == 55)\n\tassert(circle.circumference() == 88)\n\n\tvar square = Square{5}\n\tassert(square.area() == 36)\n\n\tcube := new(Cube)\n\tassert(cube.volume() == 8)\n\n\tvar rectangle = Rectangle{width: 4, height: 5}\n\tassert(rectangle.area() == 2)\n}\n\nfunc (circle *Circle) circumference() float64 ", "output": "{\n\treturn 2 * circle.PI * circle.radius\n}"}
{"input": "package matchers\n\nimport (\n\t\"fmt\"\n\t\"github.com/bfontaine/go-tchoutchou/Godeps/_workspace/src/github.com/onsi/gomega/format\"\n\t\"regexp\"\n)\n\ntype MatchRegexpMatcher struct {\n\tRegexp string\n\tArgs   []interface{}\n}\n\n\n\nfunc (matcher *MatchRegexpMatcher) FailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, \"to match regular expression\", matcher.regexp())\n}\n\nfunc (matcher *MatchRegexpMatcher) NegatedFailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, \"not to match regular expression\", matcher.regexp())\n}\n\nfunc (matcher *MatchRegexpMatcher) regexp() string {\n\tre := matcher.Regexp\n\tif len(matcher.Args) > 0 {\n\t\tre = fmt.Sprintf(matcher.Regexp, matcher.Args...)\n\t}\n\treturn re\n}\n\nfunc (matcher *MatchRegexpMatcher) Match(actual interface{}) (success bool, err error) ", "output": "{\n\tactualString, ok := toString(actual)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"RegExp matcher requires a string or stringer.\\nGot:%s\", format.Object(actual, 1))\n\t}\n\n\tmatch, err := regexp.Match(matcher.regexp(), []byte(actualString))\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"RegExp match failed to compile with error:\\n\\t%s\", err.Error())\n\t}\n\n\treturn match, nil\n}"}
{"input": "package authgo\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"golang.org/x/crypto/scrypt\"\n)\n\nconst (\n\tSaltLength = 64\n\tHashLength = 64\n)\n\ntype PasswordSalt struct {\n\tHash string\n\tSalt string\n}\n\n\nfunc generateSalt() string {\n\tdata := make([]byte, SaltLength)\n\t_, err := rand.Read(data)\n\tif err != nil {\n\t\tlog.Println(err.Error())\n\t}\n\n\treturn fmt.Sprintf(\"%x\", data)\n}\n\n\nfunc prependSalt(salt, rawPass string) string {\n\tvar buffer bytes.Buffer\n\tbuffer.WriteString(salt)\n\tbuffer.WriteString(rawPass)\n\treturn buffer.String()\n}\n\n\nfunc hashPassword(salt, rawPass string) string {\n\thash, err := scrypt.Key([]byte(rawPass), []byte(salt), 16384, 8, 1, HashLength)\n\tif err != nil {\n\t\tlog.Println(err.Error())\n\t}\n\treturn fmt.Sprintf(\"%x\", hash)\n}\n\n\n\n\n\nfunc PasswordMatch(rawPass string, pwSalt *PasswordSalt) bool {\n\thash := hashPassword(pwSalt.Salt, rawPass)\n\treturn pwSalt.Hash == hash\n}\n\nfunc CreatePassword(rawPass string) PasswordSalt ", "output": "{\n\tsalt := generateSalt()\n\thash := hashPassword(salt, rawPass)\n\tpasswordSalt := PasswordSalt{Hash: hash, Salt: salt}\n\n\treturn passwordSalt\n}"}
{"input": "package main\n\nimport (\n\t\"bytes\"\n\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"os/exec\"\n\n\t\"github.com/AcalephStorage/consul-alerts/consul\"\n\n\tlog \"github.com/Sirupsen/logrus\"\n)\n\nvar eventsChannel = make(chan []consul.Event)\n\nvar firstEventRun bool = true\n\n\n\nfunc processEvents() {\n\tfor {\n\t\tevents := <-eventsChannel\n\t\tfor _, event := range events {\n\t\t\tprocessEvent(event)\n\t\t}\n\t}\n}\n\nfunc processEvent(event consul.Event) {\n\tlog.Println(\"----------------------------------------\")\n\tlog.Printf(\"Processing event %s:\\n\", event.ID)\n\tlog.Println(\"----------------------------------------\")\n\teventHandlers := consulClient.EventHandlers(event.Name)\n\tfor _, eventHandler := range eventHandlers {\n\t\texecuteEventHandler(event, eventHandler)\n\t}\n\tlog.Printf(\"Event Processed.\\n\\n\")\n}\n\nfunc executeEventHandler(event consul.Event, eventHandler string) {\n\n\tdata, err := json.Marshal(&event)\n\tif err != nil {\n\t\tlog.Println(\"Unable to read event: \", event)\n\t}\n\n\tinput := bytes.NewReader(data)\n\toutput := new(bytes.Buffer)\n\tcmd := exec.Command(eventHandler)\n\tcmd.Stdin = input\n\tcmd.Stdout = output\n\tcmd.Stderr = output\n\n\tif err := cmd.Run(); err != nil {\n\t\tlog.Println(\"error running handler: \", err)\n\t} else {\n\t\tlog.Printf(\">>> \\n%s -> %s:\\n %s\\n\", event.ID, eventHandler, output)\n\t}\n}\n\nfunc eventHandler(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tconsulClient.LoadConfig()\n\tif firstEventRun {\n\t\tlog.Println(\"Now watching for events.\")\n\t\tfirstEventRun = false\n\t\treturn\n\t}\n\n\tif !consulClient.EventsEnabled() {\n\t\tlog.Println(\"Event handling disabled. Event ignored.\")\n\t\treturn\n\t}\n\n\tvar events []consul.Event\n\ttoWatchObject(r.Body, &events)\n\teventsChannel <- events\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nvar start time.Time\nvar delta time.Duration\n\ntype GoltWatcher struct {\n\tInterval        float64\n\tWatchingChannel chan []byte\n\trequestSent     int64\n\trequestDelta    int64\n}\n\n\n\nfunc (w *GoltWatcher) OutputAverageThroughput() {\n\tspentTime := time.Since(start)\n\tthroughput := float64(w.requestSent) / spentTime.Seconds()\n\tfmt.Printf(\"Average throughput: %f R/S - # requests sent %d\\n\", throughput, w.requestSent)\n}\n\nfunc (w *GoltWatcher) Watch() ", "output": "{\n\ttimeCounter := w.Interval\n\tstart = time.Now()\n\tfor {\n\t\tevent := <-w.WatchingChannel\n\t\tif event != nil {\n\t\t\tw.requestSent++\n\t\t\tw.requestDelta++\n\t\t}\n\t\tdelta = time.Since(start)\n\t\tif delta.Seconds() > timeCounter {\n\t\t\tthroughput := float64(w.requestDelta) / w.Interval\n\t\t\tfmt.Printf(\"Throughput in the last %.2f seconds: %.2f R/S - # requests sent last %.2f seconds %d\\n\",\n\t\t\t\tw.Interval,\n\t\t\t\tthroughput,\n\t\t\t\tw.Interval,\n\t\t\t\tw.requestDelta)\n\t\t\tw.requestDelta = 0\n\t\t\ttimeCounter += w.Interval\n\t\t}\n\t}\n}"}
{"input": "package authboss\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\n\ntype DefaultLogger log.Logger\n\n\n\n\n\nfunc (d *DefaultLogger) Write(b []byte) (int, error) {\n\t((*log.Logger)(d)).Printf(\"%s\", b)\n\treturn len(b), nil\n}\n\nfunc NewDefaultLogger() *DefaultLogger ", "output": "{\n\treturn ((*DefaultLogger)(log.New(os.Stdout, \"\", log.LstdFlags)))\n}"}
{"input": "package cmd\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/aptly-dev/aptly/deb\"\n\t\"github.com/smira/commander\"\n)\n\nfunc aptlySnapshotRename(cmd *commander.Command, args []string) error {\n\tvar (\n\t\terr      error\n\t\tsnapshot *deb.Snapshot\n\t)\n\n\tif len(args) != 2 {\n\t\tcmd.Usage()\n\t\treturn commander.ErrCommandError\n\t}\n\n\toldName, newName := args[0], args[1]\n\n\tsnapshot, err = context.CollectionFactory().SnapshotCollection().ByName(oldName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to rename: %s\", err)\n\t}\n\n\t_, err = context.CollectionFactory().SnapshotCollection().ByName(newName)\n\tif err == nil {\n\t\treturn fmt.Errorf(\"unable to rename: snapshot %s already exists\", newName)\n\t}\n\n\tsnapshot.Name = newName\n\terr = context.CollectionFactory().SnapshotCollection().Update(snapshot)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to rename: %s\", err)\n\t}\n\n\tfmt.Printf(\"\\nSnapshot %s -> %s has been successfully renamed.\\n\", oldName, newName)\n\n\treturn err\n}\n\n\n\nfunc makeCmdSnapshotRename() *commander.Command ", "output": "{\n\tcmd := &commander.Command{\n\t\tRun:       aptlySnapshotRename,\n\t\tUsageLine: \"rename <old-name> <new-name>\",\n\t\tShort:     \"renames snapshot\",\n\t\tLong: `\nCommand changes name of the snapshot. Snapshot name should be unique.\n\nExample:\n\n  $ aptly snapshot rename wheezy-min wheezy-main\n`,\n\t}\n\n\treturn cmd\n\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\t\"io/ioutil\"\n\t\"strings\"\n)\n\nconst TwistRoot = \"https://twist.moe\"\n\n\n\nfunc UrlPseudoJoin(path string) string {\n\treturn TwistRoot + strings.TrimSpace(path)\n}\n\nfunc FetchPageContents(url string) (string, error) ", "output": "{\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(body), nil\n}"}
{"input": "package server\n\nimport (\n\t\"fmt\"\n\t\"github.com/talbor49/HoneyBee/grammar\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n)\n\nconst (\n\tport      = \"8080\"\n\tip        = \"0.0.0.0\"\n\tbufferLen = 1024\n)\n\n\ntype DatabaseConnection struct {\n\tnet.Conn\n\tBucket      string\n\tConnections int\n\tUsername    string\n}\n\n\n\n\nfunc handleConnection(conn DatabaseConnection) {\n\tdefer conn.Close()\n\n\tvar rawRequest []byte\n\tbuff := make([]byte, bufferLen)\n\n\tfor {\n\t\treqLen, err := conn.Read(buff)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading buffer. %s\", err)\n\t\t\treturn\n\t\t}\n\t\trawRequest = buff[:reqLen]\n\t\tif len(rawRequest) > 0 && rawRequest[0] == grammar.QUIT_REQUEST {\n\t\t\tbreak\n\t\t}\n\t\tgo HandleRequest(rawRequest, &conn)\n\t}\n\tlog.Println(\"Closed connection\")\n}\n\nfunc StartServer() ", "output": "{\n\taddr := fmt.Sprintf(\"%s:%s\", ip, port)\n\tlistener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t\tos.Exit(1)\n\t}\n\tlog.Printf(\"Listening on: %s\", addr)\n\tdefer listener.Close()\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Error accepting message from client, %s\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tdbconn := DatabaseConnection{conn, \"\", 0, \"\"}\n\t\tgo handleConnection(dbconn)\n\t}\n}"}
{"input": "package data\n\nimport \"unicode\"\n\n\n\n\n\nfunc isASCII(s string) bool {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] > unicode.MaxASCII {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc FindEncoding(s string) (enc Encoding) ", "output": "{\n\tif isASCII(s) {\n\t\tenc = GSM7BIT\n\t} else {\n\t\tenc = UCS2\n\t}\n\treturn\n}"}
{"input": "package apimgr\n\nimport \"reflect\"\n\nfunc newSorter(manager *Manager) *sorter {\n\tapis := []Definition{}\n\tfor _, api := range manager.apiMethodPatternMap {\n\t\tapis = append(apis, api)\n\t}\n\treturn &sorter{\n\t\tManager: manager,\n\t\tapis:    apis,\n\t}\n}\n\ntype sorter struct {\n\t*Manager\n\n\tapis []Definition\n}\n\nfunc (t sorter) Len() int {\n\treturn len(t.apis)\n}\n\nfunc (t sorter) Swap(i int, j int) {\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\n}\n\nfunc (t sorter) Less(i int, j int) bool {\n\tki := t.getSortKey(t.apis[i])\n\tkj := t.getSortKey(t.apis[j])\n\treturn ki < kj\n}\n\n\n\nfunc (t sorter) getSortKey(api Definition) string ", "output": "{\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\n\treturn key\n}"}
{"input": "package ShortMessagingService\n\nimport \"fmt\"\n\n\ntype Message interface {\n\tSend(phone string, message string) (map[string]bool, error)\n}\n\nvar channels = make(map[string]ShortMessagingService)\n\n\ntype ShortMessagingService interface {\n\tParse(filename string) (Message, error)\n}\n\n\n\nfunc NewShortMessagingService(channel, filename string) (Message, error) {\n\tif service, ok := channels[channel]; ok {\n\t\treturn service.Parse(filename)\n\t}\n\treturn nil, fmt.Errorf(\"unknown sms channel: %q\", channel)\n}\n\n\n\n\nfunc Register(name string, sms ShortMessagingService) ", "output": "{\n\tif sms == nil {\n\t\tpanic(\"[SMS]: Register channel is nil\")\n\t}\n\tif _, ok := channels[name]; ok {\n\t\tpanic(\"[SMS]: Register called teice for channel \" + name)\n\t}\n\tchannels[name] = sms\n}"}
{"input": "package stack\n\nimport (\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/filters\"\n\t\"github.com/docker/docker/api/types/swarm\"\n\t\"github.com/docker/docker/cli/compose/convert\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/docker/opts\"\n)\n\nfunc getStackFilter(namespace string) filters.Args {\n\tfilter := filters.NewArgs()\n\tfilter.Add(\"label\", convert.LabelNamespace+\"=\"+namespace)\n\treturn filter\n}\n\nfunc getStackFilterFromOpt(namespace string, opt opts.FilterOpt) filters.Args {\n\tfilter := opt.Value()\n\tfilter.Add(\"label\", convert.LabelNamespace+\"=\"+namespace)\n\treturn filter\n}\n\nfunc getAllStacksFilter() filters.Args {\n\tfilter := filters.NewArgs()\n\tfilter.Add(\"label\", convert.LabelNamespace)\n\treturn filter\n}\n\n\n\nfunc getStackNetworks(\n\tctx context.Context,\n\tapiclient client.APIClient,\n\tnamespace string,\n) ([]types.NetworkResource, error) {\n\treturn apiclient.NetworkList(\n\t\tctx,\n\t\ttypes.NetworkListOptions{Filters: getStackFilter(namespace)})\n}\n\nfunc getServices(\n\tctx context.Context,\n\tapiclient client.APIClient,\n\tnamespace string,\n) ([]swarm.Service, error) ", "output": "{\n\treturn apiclient.ServiceList(\n\t\tctx,\n\t\ttypes.ServiceListOptions{Filters: getStackFilter(namespace)})\n}"}
{"input": "package policy\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\n\nfunc New(subscriptionID string) BaseClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient ", "output": "{\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}"}
{"input": "package types\n\nimport (\n\t\"fmt\"\n\t\"go/token\"\n)\n\n\ntype Package struct {\n\tpath     string\n\tname     string\n\tscope    *Scope\n\tcomplete bool\n\timports  []*Package\n\tfake     bool \n\tcgo      bool \n}\n\n\n\nfunc NewPackage(path, name string) *Package {\n\tscope := NewScope(Universe, token.NoPos, token.NoPos, fmt.Sprintf(\"package %q\", path))\n\treturn &Package{path: path, name: name, scope: scope}\n}\n\n\nfunc (pkg *Package) Path() string { return pkg.path }\n\n\nfunc (pkg *Package) Name() string { return pkg.name }\n\n\nfunc (pkg *Package) SetName(name string) { pkg.name = name }\n\n\n\n\nfunc (pkg *Package) Scope() *Scope { return pkg.scope }\n\n\n\nfunc (pkg *Package) Complete() bool { return pkg.complete }\n\n\nfunc (pkg *Package) MarkComplete() { pkg.complete = true }\n\n\n\n\n\n\n\nfunc (pkg *Package) Imports() []*Package { return pkg.imports }\n\n\n\n\n\nfunc (pkg *Package) String() string {\n\treturn fmt.Sprintf(\"package %s (%q)\", pkg.name, pkg.path)\n}\n\nfunc (pkg *Package) SetImports(list []*Package) ", "output": "{ pkg.imports = list }"}
{"input": "package catalogs\n\n\n\n\nimport (\n\t\"time\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/runtime\"\n\tcr \"github.com/go-openapi/runtime/client\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n)\n\n\n\nfunc NewGetNodesIdentifierCatalogsParams() *GetNodesIdentifierCatalogsParams {\n\tvar ()\n\treturn &GetNodesIdentifierCatalogsParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}\n\n\n\nfunc NewGetNodesIdentifierCatalogsParamsWithTimeout(timeout time.Duration) *GetNodesIdentifierCatalogsParams {\n\tvar ()\n\treturn &GetNodesIdentifierCatalogsParams{\n\n\t\ttimeout: timeout,\n\t}\n}\n\n\ntype GetNodesIdentifierCatalogsParams struct {\n\n\tIdentifier string\n\n\ttimeout time.Duration\n}\n\n\nfunc (o *GetNodesIdentifierCatalogsParams) WithIdentifier(identifier string) *GetNodesIdentifierCatalogsParams {\n\to.Identifier = identifier\n\treturn o\n}\n\n\n\n\nfunc (o *GetNodesIdentifierCatalogsParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error ", "output": "{\n\n\tr.SetTimeout(o.timeout)\n\tvar res []error\n\n\tif err := r.SetPathParam(\"identifier\", o.Identifier); err != nil {\n\t\treturn err\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package feed\n\nimport (\n\t\"go-common/app/interface/main/app-card/model/card/rank\"\n\t\"go-common/app/interface/main/app-feed/model\"\n)\n\n\n\nfunc (s *Service) RankCard(plat int8) (ranks []*rank.Rank, aids []int64) ", "output": "{\n\tvar limit int\n\tif !model.IsIPad(plat) {\n\t\tlimit = 3\n\t} else {\n\t\tlimit = 4\n\t}\n\tranks = make([]*rank.Rank, 0, limit)\n\taids = make([]int64, 0, limit)\n\tfor _, rank := range s.rankCache {\n\t\tranks = append(ranks, rank)\n\t\taids = append(aids, rank.Aid)\n\t\tif len(ranks) == limit {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}"}
{"input": "package rivet\n\nimport (\n\t\"net/http\"\n)\n\n\ntype Response struct {\n\tw      http.ResponseWriter\n\tstatus int\n\tsize   int\n}\n\n\n\n\n\n\nfunc (r *Response) Flush() {\n\tif flusher, ok := r.w.(http.Flusher); ok {\n\t\tflusher.Flush()\n\t}\n}\n\n\nfunc (r *Response) WriteHeader(s int) {\n\tr.status = s\n\tr.w.WriteHeader(s)\n}\n\n\nfunc (r *Response) Write(b []byte) (int, error) {\n\tif !r.Written() {\n\t\tr.WriteHeader(http.StatusOK)\n\t}\n\tsize, err := r.w.Write(b)\n\tr.size += size\n\treturn size, err\n}\n\n\nfunc (r *Response) Status() int {\n\treturn r.status\n}\n\n\nfunc (r *Response) Size() int {\n\treturn r.size\n}\n\n\nfunc (r *Response) Written() bool {\n\treturn r.status != 0 || r.size != 0\n}\n\nfunc NewResponse(rw http.ResponseWriter) *Response ", "output": "{\n\treturn &Response{rw, 0, 0}\n}"}
{"input": "package hplot\n\nimport (\n\t\"github.com/go-hep/hbook\"\n\t\"github.com/gonum/plot\"\n\t\"github.com/gonum/plot/palette\"\n\t\"github.com/gonum/plot/palette/brewer\"\n\t\"github.com/gonum/plot/plotter\"\n\t\"github.com/gonum/plot/vg/draw\"\n)\n\n\n\ntype H2D struct {\n\tH *hbook.H2D\n\n\tPalette palette.Palette\n\n\tInfos HInfos\n\n\tp *plotter.HeatMap\n}\n\n\nfunc NewH2D(h *hbook.H2D, p palette.Palette) *H2D {\n\tif p == nil {\n\t\tp, _ = brewer.GetPalette(brewer.TypeAny, \"RdYlBu\", 11)\n\t}\n\treturn &H2D{\n\t\tH:       h,\n\t\tPalette: p,\n\t}\n}\n\n\n\n\n\nfunc (h *H2D) Plot(c draw.Canvas, p *plot.Plot) {\n\th.pltr().Plot(c, p)\n}\n\n\n\nfunc (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\n\n\n\n\nfunc (h *H2D) GlyphBoxes(p *plot.Plot) []plot.GlyphBox {\n\treturn h.pltr().GlyphBoxes(p)\n}\n\n\nvar _ plot.Plotter = (*H2D)(nil)\nvar _ plot.DataRanger = (*H2D)(nil)\nvar _ plot.GlyphBoxer = (*H2D)(nil)\n\nfunc (h *H2D) pltr() *plotter.HeatMap ", "output": "{\n\tif h.p == nil {\n\t\th.p = plotter.NewHeatMap(h.H.GridXYZ(), h.Palette)\n\t}\n\treturn h.p\n}"}
{"input": "package host\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\n\n\n\nfunc TestRPCDownload(t *testing.T) ", "output": "{\n\tif testing.Short() {\n\t\tt.SkipNow()\n\t}\n\tht, err := newHostTester(\"TestRPCDownload\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tnickname := \"TestRPCDownload1\"\n\tuploadData, err := ht.uploadFile(nickname, renewDisabled)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdownloadPath := filepath.Join(ht.persistDir, nickname+\".download\")\n\terr = ht.renter.Download(nickname, downloadPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdownloadData, err := ioutil.ReadFile(downloadPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(uploadData, downloadData) {\n\t\tt.Error(\"uploaded and downloaded file do not match\")\n\t}\n}"}
{"input": "package net\n\nfunc cgoLookupHost(name string) (addrs []string, err error, completed bool) {\n\treturn nil, nil, false\n}\n\nfunc cgoLookupPort(network, service string) (port int, err error, completed bool) {\n\treturn 0, nil, false\n}\n\n\n\nfunc cgoLookupCNAME(name string) (cname string, err error, completed bool) {\n\treturn \"\", nil, false\n}\n\nfunc cgoLookupIP(name string) (addrs []IP, err error, completed bool) ", "output": "{\n\treturn nil, nil, false\n}"}
{"input": "package server\n\nimport (\n\t\"sync/atomic\"\n\n\t\"github.com/berkaroad/saashard/admin\"\n\t\"github.com/berkaroad/saashard/config\"\n\t\"github.com/berkaroad/saashard/proxy\"\n)\n\nconst (\n\tOffline = iota\n\tOnline\n\tUnknown\n)\n\n\ntype Server struct {\n\tcfg *config.Config\n\n\tstatusIndex int32\n\tstatus      [2]int32\n\trunning     bool\n\n\tproxy *proxy.Server\n\tadmin *admin.Server\n}\n\n\nfunc NewServer(cfg *config.Config) (*Server, error) {\n\tvar err error\n\ts := new(Server)\n\ts.cfg = cfg\n\n\tatomic.StoreInt32(&s.statusIndex, 0)\n\ts.status[s.statusIndex] = Online\n\n\ts.proxy, err = proxy.NewServer(cfg)\n\ts.admin, err = admin.NewServer(cfg)\n\treturn s, err\n}\n\n\nfunc (s *Server) Run() {\n\ts.running = true\n\n\tgo s.proxy.Run()\n\n\ts.admin.Run()\n}\n\n\n\n\n\nfunc (s *Server) Close() {\n\ts.running = false\n\ts.proxy.Close()\n\ts.admin.Close()\n}\n\nfunc (s *Server) Status() string ", "output": "{\n\tvar status string\n\tswitch s.status[s.statusIndex] {\n\tcase Online:\n\t\tstatus = \"online\"\n\tcase Offline:\n\t\tstatus = \"offline\"\n\tcase Unknown:\n\t\tstatus = \"unknown\"\n\tdefault:\n\t\tstatus = \"unknown\"\n\t}\n\treturn status\n}"}
{"input": "package fakeclock\n\nimport (\n\t\"time\"\n\n\t\"github.com/pivotal-golang/clock\"\n)\n\ntype fakeTicker struct {\n\ttimer clock.Timer\n}\n\n\n\nfunc (ft *fakeTicker) C() <-chan time.Time {\n\treturn ft.timer.C()\n}\n\nfunc (ft *fakeTicker) Stop() {\n\tft.timer.Stop()\n}\n\nfunc newFakeTicker(timer *fakeTimer) *fakeTicker ", "output": "{\n\treturn &fakeTicker{\n\t\ttimer: timer,\n\t}\n}"}
{"input": "package error\n\nimport (\n\t\"strconv\"\n)\n\n\n\ntype StructuralError string\n\nfunc (s StructuralError) String() string {\n\treturn \"OpenPGP data invalid: \" + string(s)\n}\n\n\n\ntype UnsupportedError string\n\nfunc (s UnsupportedError) String() string {\n\treturn \"OpenPGP feature unsupported: \" + string(s)\n}\n\n\n\ntype InvalidArgumentError string\n\nfunc (i InvalidArgumentError) String() string {\n\treturn \"OpenPGP argument invalid: \" + string(i)\n}\n\n\n\ntype SignatureError string\n\nfunc (b SignatureError) String() string {\n\treturn \"OpenPGP signature invalid: \" + string(b)\n}\n\ntype keyIncorrect int\n\n\n\nvar KeyIncorrectError = keyIncorrect(0)\n\ntype unknownIssuer int\n\nfunc (unknownIssuer) String() string {\n\treturn \"signature make by unknown entity\"\n}\n\nvar UnknownIssuerError = unknownIssuer(0)\n\ntype UnknownPacketTypeError uint8\n\nfunc (upte UnknownPacketTypeError) String() string {\n\treturn \"unknown OpenPGP packet type: \" + strconv.Itoa(int(upte))\n}\n\nfunc (ki keyIncorrect) String() string ", "output": "{\n\treturn \"the given key was incorrect\"\n}"}
{"input": "package osfs\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t. \"gopkg.in/check.v1\"\n\t\"gopkg.in/src-d/go-billy.v2/test\"\n)\n\nfunc Test(t *testing.T) { TestingT(t) }\n\ntype OSSuite struct {\n\ttest.FilesystemSuite\n\tpath string\n}\n\nvar _ = Suite(&OSSuite{})\n\nfunc (s *OSSuite) SetUpTest(c *C) {\n\ts.path, _ = ioutil.TempDir(os.TempDir(), \"go-billy-osfs-test\")\n\ts.FilesystemSuite.FS = New(s.path)\n}\n\n\n\nfunc (s *OSSuite) TestOpenDoesNotCreateDir(c *C) {\n\t_, err := s.FS.Open(\"dir/non-existent\")\n\tc.Assert(err, NotNil)\n\n\t_, err = os.Stat(filepath.Join(s.path, \"dir\"))\n\tc.Assert(os.IsNotExist(err), Equals, true)\n}\n\nfunc (s *OSSuite) TearDownTest(c *C) ", "output": "{\n\terr := os.RemoveAll(s.path)\n\tc.Assert(err, IsNil)\n}"}
{"input": "package handlers\n\nimport(\n\t\"strconv\"\n\t\"github.com/sheng/air\"\n\t\"github.com/BouncyElf/mynote/models\"\n\t\"github.com/BouncyElf/mynote/utils\"\n)\n\n\n\n\n\nfunc MessagePageHandler(c *air.Context) error {\n\tif res, _ := models.IsAuthenticated(c); res != true {\n\t\treturn utils.ErrorPage(c, \"401\")\n\t}\n\tuser, usp, err := models.GetUserInfoByCookie(c)\n\tif err != nil {\n\t\treturn utils.ErrorPage(c, \"500\")\n\t}\n\n\tmsgs, err := models.GetMessageByUser(*user)\n\tif err != nil {\n\t\treturn utils.ErrorPage(c, \"500\")\n\t}\n\n\tres := true\n\tc.Data[\"iflogin\"] = res\n\tc.Data[\"title\"] = \"我的消息\"\n\tc.Data[\"messages\"] = msgs\n\tc.Data[\"msg_num\"] = usp.Msg_num\n\n\treturn c.Render(\"message/message.html\", \"base.html\")\n}\n\n\nfunc DeleteMessageAPI(c *air.Context) error {\n\tif res, _ := models.IsAuthenticated(c); res != true {\n\t\treturn utils.ErrorResponse(c, \"401\")\n\t}\n\n\tmessage_id_string := c.Param(\"message_id\")\n\tmessage_id, _ := strconv.Atoi(message_id_string)\n\n\tif err := models.DeleteMessageByID(c, message_id); err != nil {\n\t\treturn utils.ErrorResponse(c, err.Error())\n\t}\n\n\treturn utils.SuccessResponse(c, \"删除成功\")\n}\n\nfunc LeaveMessageAPI(c *air.Context) error ", "output": "{\n\tvar msg models.Message\n\tmsg.From_name = c.FormValue(\"from\")\n\tmsg.Email = c.FormValue(\"email\")\n\tusername := c.FormValue(\"to\")\n\tuser, _, err := models.GetUserInfoByUsername(username)\n\tif err != nil {\n\t\treturn utils.ErrorResponse(c, \"留言失败，请刷新\")\n\t}\n\tmsg.To_id = user.ID\n\tmsg.Content = c.FormValue(\"content\")\n\tif err = models.CreateMessage(&msg); err != nil {\n\t\treturn utils.ErrorResponse(c, \"留言失败，请刷新 222 \")\n\t}\n\treturn utils.SuccessResponse(c, \"留言成功\")\n}"}
{"input": "package version\n\nimport (\n\tapi \"github.com/containerd/containerd/api/services/version\"\n\t\"github.com/containerd/containerd/plugin\"\n\tctrdversion \"github.com/containerd/containerd/version\"\n\tempty \"github.com/golang/protobuf/ptypes/empty\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n)\n\nvar _ api.VersionServer = &Service{}\n\n\n\nfunc New(ic *plugin.InitContext) (interface{}, error) {\n\treturn &Service{}, nil\n}\n\ntype Service struct {\n}\n\nfunc (s *Service) Register(server *grpc.Server) error {\n\tapi.RegisterVersionServer(server, s)\n\treturn nil\n}\n\nfunc (s *Service) Version(ctx context.Context, _ *empty.Empty) (*api.VersionResponse, error) {\n\treturn &api.VersionResponse{\n\t\tVersion:  ctrdversion.Version,\n\t\tRevision: ctrdversion.Revision,\n\t}, nil\n}\n\nfunc init() ", "output": "{\n\tplugin.Register(\"version-grpc\", &plugin.Registration{\n\t\tType: plugin.GRPCPlugin,\n\t\tInit: New,\n\t})\n}"}
{"input": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdata := []float64{43, 56, 87, 12, 45, 57}\n\n\tn := average(data...)\n\n\tfmt.Println(n)\n}\n\n\n\nfunc average(sf ...float64) float64 ", "output": "{\n\ttotal := 0.0\n\n\tfor _, v := range sf {\n\t\ttotal += v\n\t}\n\n\treturn total / float64(len(sf))\n}"}
{"input": "package main\n\nimport (\n\t\"net\"\n)\n\ntype ClientV1 struct {\n\tnet.Conn\n\tpeerInfo *PeerInfo\n}\n\nfunc NewClientV1(conn net.Conn) *ClientV1 {\n\treturn &ClientV1{\n\t\tConn: conn,\n\t}\n}\n\n\n\nfunc (c *ClientV1) String() string ", "output": "{\n\treturn c.RemoteAddr().String()\n}"}
{"input": "package main\n\n\n\n\nimport \"C\"\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"runtime/pprof\"\n\t\"time\"\n\t\"unsafe\"\n)\n\nfunc init() {\n\tregister(\"CgoPprofThread\", CgoPprofThread)\n\tregister(\"CgoPprofThreadNoTraceback\", CgoPprofThreadNoTraceback)\n}\n\n\n\nfunc CgoPprofThreadNoTraceback() {\n\tpprofThread()\n}\n\nfunc pprofThread() {\n\tf, err := os.CreateTemp(\"\", \"prof\")\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(2)\n\t}\n\n\tif err := pprof.StartCPUProfile(f); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(2)\n\t}\n\n\tC.runCPUHogThread()\n\n\tt0 := time.Now()\n\tfor C.getCPUHogThreadCount() < 2 && time.Since(t0) < time.Second {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\n\tpprof.StopCPUProfile()\n\n\tname := f.Name()\n\tif err := f.Close(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(2)\n\t}\n\n\tfmt.Println(name)\n}\n\nfunc CgoPprofThread() ", "output": "{\n\truntime.SetCgoTraceback(0, unsafe.Pointer(C.pprofCgoThreadTraceback), nil, nil)\n\tpprofThread()\n}"}
{"input": "package pipes\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"github.com/nu7hatch/gouuid\"\n\n\t\"github.com/concourse/atc\"\n)\n\n\n\nfunc (s *Server) CreatePipe(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tguid, err := uuid.NewV4()\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\terr = s.db.CreatePipe(guid.String(), s.url)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tpr, pw := io.Pipe()\n\n\tpipeResource := atc.Pipe{\n\t\tID: guid.String(),\n\t}\n\n\tpipe := pipe{\n\t\tresource: pipeResource,\n\n\t\tread:  pr,\n\t\twrite: pw,\n\t}\n\n\ts.pipesL.Lock()\n\ts.pipes[pipeResource.ID] = pipe\n\ts.pipesL.Unlock()\n\n\tw.WriteHeader(http.StatusCreated)\n\n\tjson.NewEncoder(w).Encode(pipeResource)\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"testing\"\n)\n\nvar artifacts = []struct {\n\tin  string\n\tout string\n}{\n\t{\"fixtures/virtualbox-ovf.json\", \"packer_virtualbox-ovf_virtualbox.vhd\"},\n\t{\"fixtures/virtualbox-ova.json\", \"packer_virtualbox-ova_virtualbox.vhd\"},\n}\n\n\nfunc init() {\n\tcmd := exec.Command(\"packer\", \"build\", \"--force\", \"fixtures/virtualbox-iso.json\")\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\terr := cmd.Run()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n\n\nfunc TestIntegration(t *testing.T) ", "output": "{\n\tif err := os.Chdir(\"test\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tfor _, tt := range artifacts {\n\t\tcmd := exec.Command(\"packer\", \"build\", \"--force\", tt.in)\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\t\terr := cmd.Run()\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif _, err := os.Stat(tt.out); os.IsNotExist(err) {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}"}
{"input": "package blobinfocache\n\nimport (\n\t\"github.com/containers/image/v5/pkg/compression\"\n\tcompressiontypes \"github.com/containers/image/v5/pkg/compression/types\"\n\t\"github.com/containers/image/v5/types\"\n\tdigest \"github.com/opencontainers/go-digest\"\n)\n\n\n\n\nfunc FromBlobInfoCache(bic types.BlobInfoCache) BlobInfoCache2 {\n\tif bic2, ok := bic.(BlobInfoCache2); ok {\n\t\treturn bic2\n\t}\n\treturn &v1OnlyBlobInfoCache{\n\t\tBlobInfoCache: bic,\n\t}\n}\n\ntype v1OnlyBlobInfoCache struct {\n\ttypes.BlobInfoCache\n}\n\nfunc (bic *v1OnlyBlobInfoCache) RecordDigestCompressorName(anyDigest digest.Digest, compressorName string) {\n}\n\nfunc (bic *v1OnlyBlobInfoCache) CandidateLocations2(transport types.ImageTransport, scope types.BICTransportScope, digest digest.Digest, canSubstitute bool) []BICReplacementCandidate2 {\n\treturn nil\n}\n\n\n\n\n\n\n\n\n\n\nfunc OperationAndAlgorithmForCompressor(compressorName string) (types.LayerCompression, *compressiontypes.Algorithm, error) {\n\tswitch compressorName {\n\tcase Uncompressed:\n\t\treturn types.Decompress, nil, nil\n\tcase UnknownCompression:\n\t\treturn types.PreserveOriginal, nil, nil\n\tdefault:\n\t\talgo, err := compression.AlgorithmByName(compressorName)\n\t\tif err == nil {\n\t\t\treturn types.Compress, &algo, nil\n\t\t}\n\t\treturn types.PreserveOriginal, nil, err\n\t}\n}\n\nfunc CandidateLocationsFromV2(v2candidates []BICReplacementCandidate2) []types.BICReplacementCandidate ", "output": "{\n\tcandidates := make([]types.BICReplacementCandidate, 0, len(v2candidates))\n\tfor _, c := range v2candidates {\n\t\tcandidates = append(candidates, types.BICReplacementCandidate{\n\t\t\tDigest:   c.Digest,\n\t\t\tLocation: c.Location,\n\t\t})\n\t}\n\treturn candidates\n}"}
{"input": "package players\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\n\n\nfunc TestRepo_UnPick(t *testing.T) {\n\tp := Player{ID: 1}\n\tr := &Repo{\n\t\tPosition: 3,\n\t\tClaimed:  []Player{{ID: 1, ADP: 45}},\n\t}\n\n\tvar err error\n\n\tp.ID = 2\n\terr = r.UnPick(p)\n\n\trequire.Error(t, err)\n\trequire.Equal(t, 1, len(r.Claimed))\n\trequire.Equal(t, 0, len(r.Available))\n\trequire.Equal(t, 3, r.Position)\n\n\tp.ID = 1\n\terr = r.UnPick(p)\n\n\trequire.NoError(t, err)\n\trequire.Equal(t, 0, len(r.Claimed))\n\trequire.Equal(t, 1, len(r.Available))\n\trequire.Equal(t, 2, r.Position)\n}\n\nfunc TestRepo_Pick(t *testing.T) ", "output": "{\n\tp := Player{ID: 1}\n\tr := &Repo{\n\t\tAvailable: []Player{{ID: 1, ADP: 45}},\n\t}\n\tvar err error\n\n\tp.ID = 2\n\terr = r.Pick(p)\n\trequire.Error(t, err)\n\n\trequire.Equal(t, 0, len(r.Claimed))\n\trequire.Equal(t, 1, len(r.Available))\n\trequire.Equal(t, 0, r.Position)\n\n\tp.ID = 1\n\terr = r.Pick(p)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 0, len(r.Available))\n\trequire.Equal(t, 1, len(r.Claimed))\n\trequire.Equal(t, 1, r.Position)\n}"}
{"input": "package logging\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype LogGroupSummary struct {\n\n\tId *string `mandatory:\"true\" json:\"id\"`\n\n\tCompartmentId *string `mandatory:\"true\" json:\"compartmentId\"`\n\n\tDisplayName *string `mandatory:\"true\" json:\"displayName\"`\n\n\tDescription *string `mandatory:\"false\" json:\"description\"`\n\n\tDefinedTags map[string]map[string]interface{} `mandatory:\"false\" json:\"definedTags\"`\n\n\tFreeformTags map[string]string `mandatory:\"false\" json:\"freeformTags\"`\n\n\tTimeCreated *common.SDKTime `mandatory:\"false\" json:\"timeCreated\"`\n\n\tTimeLastModified *common.SDKTime `mandatory:\"false\" json:\"timeLastModified\"`\n\n\tLifecycleState LogGroupLifecycleStateEnum `mandatory:\"false\" json:\"lifecycleState,omitempty\"`\n}\n\n\n\nfunc (m LogGroupSummary) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package network\n\nimport (\n\t\"github.com/docker/docker/api/server/httputils\"\n\t\"github.com/docker/docker/api/server/router\"\n)\n\n\ntype networkRouter struct {\n\troutes []router.Route\n}\n\n\nfunc (n networkRouter) Routes() []router.Route {\n\treturn n.routes\n}\n\ntype networkRoute struct {\n\tpath    string\n\thandler httputils.APIFunc\n}\n\n\n\n\nfunc (l networkRoute) Handler() httputils.APIFunc ", "output": "{\n\treturn l.handler\n}"}
{"input": "package models\n\n\n\n\nimport (\n\t\"strconv\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/swag\"\n)\n\n\n\ntype OpenpitrixDescribeUsersDetailResponseUserDetailSet []*OpenpitrixUserDetail\n\n\n\n\nfunc (m OpenpitrixDescribeUsersDetailResponseUserDetailSet) Validate(formats strfmt.Registry) error ", "output": "{\n\tvar res []error\n\n\tfor i := 0; i < len(m); i++ {\n\n\t\tif swag.IsZero(m[i]) { \n\t\t\tcontinue\n\t\t}\n\n\t\tif m[i] != nil {\n\n\t\t\tif err := m[i].Validate(formats); err != nil {\n\t\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\t\treturn ve.ValidateName(strconv.Itoa(i))\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package backingstore\n\nimport (\n\t\"github.com/gostor/gotgt/pkg/api\"\n\t\"github.com/gostor/gotgt/pkg/scsi\"\n)\n\nfunc init() {\n\tscsi.RegisterBackingStore(\"null\", newNull)\n}\n\ntype NullBackingStore struct {\n\tscsi.BaseBackingStore\n}\n\nfunc newNull() (api.BackingStore, error) {\n\treturn &NullBackingStore{\n\t\tBaseBackingStore: scsi.BaseBackingStore{\n\t\t\tName:            \"null\",\n\t\t\tDataSize:        0,\n\t\t\tOflagsSupported: 0,\n\t\t},\n\t}, nil\n}\n\nfunc (bs *NullBackingStore) Open(dev *api.SCSILu, path string) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Close(dev *api.SCSILu) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Init(dev *api.SCSILu, Opts string) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Exit(dev *api.SCSILu) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Size(dev *api.SCSILu) uint64 {\n\treturn 0\n}\n\nfunc (bs *NullBackingStore) Read(offset, tl int64) ([]byte, error) {\n\treturn nil, nil\n}\n\n\n\nfunc (bs *NullBackingStore) DataSync(offset, tl int64) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) DataAdvise(offset, length int64, advise uint32) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Unmap([]api.UnmapBlockDescriptor) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Write(wbuf []byte, offset int64) error ", "output": "{\n\treturn nil\n}"}
{"input": "package opengl\n\n\ntype framebuffer struct {\n\tgraphics *Graphics\n\tnative   framebufferNative\n\twidth    int\n\theight   int\n}\n\n\n\n\n\nfunc newScreenFramebuffer(context *context, width, height int) *framebuffer {\n\treturn &framebuffer{\n\t\tnative: context.getScreenFramebuffer(),\n\t\twidth:  width,\n\t\theight: height,\n\t}\n}\n\nfunc (f *framebuffer) delete(context *context) {\n\tif !f.native.equal(context.getScreenFramebuffer()) {\n\t\tcontext.deleteFramebuffer(f.native)\n\t}\n}\n\nfunc newFramebufferFromTexture(context *context, texture textureNative, width, height int) (*framebuffer, error) ", "output": "{\n\tnative, err := context.newFramebuffer(texture)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &framebuffer{\n\t\tnative: native,\n\t\twidth:  width,\n\t\theight: height,\n\t}, nil\n}"}
{"input": "package alertsv2\n\nimport (\n\turl \"net/url\"\n\t\"strconv\"\n)\n\ntype ListAlertLogsRequest struct {\n\t*Identifier\n\tOffset    string\n\tDirection Direction\n\tLimit     int\n\tOrder     Order\n\tApiKey    string\n}\n\n\n\nfunc (r *ListAlertLogsRequest) GetApiKey() string {\n\treturn r.ApiKey\n}\n\nfunc (r *ListAlertLogsRequest) GenerateUrl() (string, url.Values, error) ", "output": "{\n\tpath, params, err := r.Identifier.GenerateUrl()\n\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tif r.Offset != \"\" {\n\t\tparams.Add(\"offset\", r.Offset)\n\t}\n\n\tif r.Direction != \"\" {\n\t\tparams.Add(\"direction\", string(r.Direction))\n\t}\n\n\tif r.Limit != 0 {\n\t\tparams.Add(\"limit\", strconv.Itoa(r.Limit))\n\t}\n\n\tif r.Order != \"\" {\n\t\tparams.Add(\"order\", string(r.Order))\n\t}\n\n\treturn path + \"/logs\", params, nil\n}"}
{"input": "package matchers\n\nvar (\n\tTypeWoff  = newType(\"woff\", \"application/font-woff\")\n\tTypeWoff2 = newType(\"woff2\", \"application/font-woff\")\n\tTypeTtf   = newType(\"ttf\", \"application/font-sfnt\")\n\tTypeOtf   = newType(\"otf\", \"application/font-sfnt\")\n)\n\nvar Font = Map{\n\tTypeWoff:  Woff,\n\tTypeWoff2: Woff2,\n\tTypeTtf:   Ttf,\n\tTypeOtf:   Otf,\n}\n\nfunc Woff(buf []byte) bool {\n\treturn len(buf) > 7 &&\n\t\tbuf[0] == 0x77 && buf[1] == 0x4F && buf[2] == 0x46 && buf[3] == 0x46 &&\n\t\tbuf[4] == 0x00 && buf[5] == 0x01 && buf[6] == 0x00 && buf[7] == 0x00\n}\n\n\n\nfunc Ttf(buf []byte) bool {\n\treturn len(buf) > 4 &&\n\t\tbuf[0] == 0x00 && buf[1] == 0x01 &&\n\t\tbuf[2] == 0x00 && buf[3] == 0x00 &&\n\t\tbuf[4] == 0x00\n}\n\nfunc Otf(buf []byte) bool {\n\treturn len(buf) > 4 &&\n\t\tbuf[0] == 0x4F && buf[1] == 0x54 &&\n\t\tbuf[2] == 0x54 && buf[3] == 0x4F &&\n\t\tbuf[4] == 0x00\n}\n\nfunc Woff2(buf []byte) bool ", "output": "{\n\treturn len(buf) > 7 &&\n\t\tbuf[0] == 0x77 && buf[1] == 0x4F && buf[2] == 0x46 && buf[3] == 0x32 &&\n\t\tbuf[4] == 0x00 && buf[5] == 0x01 && buf[6] == 0x00 && buf[7] == 0x00\n}"}
{"input": "package lib_gc_log\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\n\n\nvar (\n\tTrace   *log.Logger\n\tInfo    *log.Logger\n\tWarning *log.Logger\n\tError   *log.Logger\n)\n\nfunc Init(\n\ttraceHandle io.Writer,\n\tinfoHandle io.Writer,\n\twarningHandle io.Writer,\n\terrorHandle io.Writer) {\n\n\tTrace = log.New(traceHandle,\n\t\t\"TRACE: \",\n\t\tlog.Ldate|log.Ltime|log.Lmicroseconds|log.Lshortfile)\n\n\tInfo = log.New(infoHandle,\n\t\t\"INFO: \",\n\t\tlog.Ldate|log.Ltime|log.Lmicroseconds|log.Lshortfile)\n\n\tWarning = log.New(warningHandle,\n\t\t\"WARNING: \",\n\t\tlog.Ldate|log.Ltime|log.Lmicroseconds|log.Lshortfile)\n\n\tError = log.New(errorHandle,\n\t\t\"ERROR: \",\n\t\tlog.Ldate|log.Ltime|log.Lmicroseconds|log.Lshortfile)\n}\n\nfunc init() ", "output": "{\n\tfmt.Println(\"Log activated !!!\")\n\tInit(ioutil.Discard, os.Stdout, os.Stdout, os.Stdout)\n}"}
{"input": "package ks\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc ReadBytesFromFile(filename string) ([]byte, error) {\n\tfin, err := os.Open(filename)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ioutil.ReadAll(fin)\n}\n\nfunc ReadLines(r io.Reader) []string {\n\n\tbr := bufio.NewReader(r)\n\tvar res []string\n\n\tfor {\n\t\ts, _, err := br.ReadLine()\n\n\t\tif err != nil {\n\t\t\treturn res\n\t\t}\n\n\t\tres = append(res, string(s))\n\n\t}\n\n}\n\n\n\nfunc FileExists(filename string) bool {\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\n\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc ListFiles(folder string) []string ", "output": "{\n\n\tvar res []string\n\n\tfilepath.Walk(fmt.Sprintf(folder),\n\t\tfunc(path string, info os.FileInfo, err error) error {\n\n\t\t\tif info != nil && !info.IsDir() {\n\t\t\t\tres = append(res, info.Name())\n\t\t\t}\n\n\t\t\treturn nil\n\t\t})\n\treturn res\n}"}
{"input": "package block\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os/exec\"\n\t\"strings\"\n\n\t\"github.com/openebs/maya/cmd/maya-agent/types/v1\"\n)\n\n\n\n\n\nfunc FormatOutputForUser(resJsonDecoded *v1.BlockDeviceInfo) {\n\tfmt.Printf(\"%v  %9v  %4v  %4v\\n\", \"Name\", \"Size\", \"Type\", \"Mountpoint\")\n\tfor _, v := range resJsonDecoded.Blockdevices {\n\t\tif v.Type == \"disk\" && (v.Mountpoint == \"\" || v.Mountpoint == \"/\" ||\n\t\t\tstrings.HasPrefix(v.Mountpoint, \"/mnt/\")) {\n\t\t\tif v.Mountpoint == \"\" {\n\t\t\t\tv.Mountpoint = \"null\"\n\t\t\t}\n\t\t\tfmt.Printf(\"%v  %9v  %5v  %5v\\n\", v.Name, v.Size, v.Type, v.Mountpoint)\n\t\t\tif v.Children != nil {\n\t\t\t\tfor _, u := range v.Children {\n\t\t\t\t\tif u.Type == \"part\" {\n\t\t\t\t\t\tif u.Mountpoint == \"\" {\n\t\t\t\t\t\t\tu.Mountpoint = \"null\"\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfmt.Printf(\"|_%v  %6v  %5v  %5v\\n\", u.Name, u.Size, u.Type, u.Mountpoint)\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc ListBlockExec(resJsonDecoded *v1.BlockDeviceInfo) error ", "output": "{\n\tListBlockCommand := v1.OsCommand{\"lsblk\", \"-J\"}\n\tres, err := exec.Command(ListBlockCommand.Command, ListBlockCommand.Flag).Output()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn json.Unmarshal(res, &resJsonDecoded)\n}"}
{"input": "package income\n\nimport (\n\t\"context\"\n\n\t\"go-common/app/job/main/growup/conf\"\n\t\"go-common/library/database/sql\"\n\t\"go-common/library/log\"\n)\n\n\ntype Dao struct {\n\tc    *conf.Config\n\tdb   *sql.DB\n\trddb *sql.DB\n\tTx   *sql.Tx\n}\n\n\nfunc New(c *conf.Config) (d *Dao) {\n\tlog.Info(\"dao start\")\n\td = &Dao{\n\t\tc:    c,\n\t\tdb:   sql.NewMySQL(c.Mysql.Growup),\n\t\trddb: sql.NewMySQL(c.Mysql.Allowance),\n\t}\n\td.Tx, _ = d.BeginTran(context.TODO())\n\treturn d\n}\n\n\nfunc (d *Dao) Ping(c context.Context) (err error) {\n\treturn d.db.Ping(c)\n}\n\n\nfunc (d *Dao) Close() {\n\tif d.db != nil {\n\t\td.db.Close()\n\t}\n}\n\n\nfunc (d *Dao) BeginTran(c context.Context) (tx *sql.Tx, err error) {\n\treturn d.db.Begin(c)\n}\n\n\n\n\n\nfunc (d *Dao) QueryRow(c context.Context, sql string) (rows *sql.Row) {\n\treturn d.db.QueryRow(c, sql)\n}\n\n\nfunc (d *Dao) Query(c context.Context, sql string) (rows *sql.Rows, err error) {\n\treturn d.db.Query(c, sql)\n}\n\nfunc (d *Dao) Exec(c context.Context, sql string) (err error) ", "output": "{\n\t_, err = d.db.Exec(c, sql)\n\treturn\n}"}
{"input": "package store\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Row struct {\n\tData []string\n}\n\n\n\nfunc ReadRows(path, delimiter string) *[]Row {\n\tf, _ := os.Open(path)\n\n\tdefer f.Close()\n\n\trows := []Row{}\n\ts := bufio.NewScanner(f)\n\ts.Split(bufio.ScanLines)\n\n\tfor s.Scan() {\n\t\tdata := strings.Split(s.Text(), delimiter)\n\t\tr := &Row{Data: data}\n\t\trows = append(rows, *r)\n\t}\n\n\treturn &rows\n}\n\nfunc WriteData(path string, data []byte) {\n\tf, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0644)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tdefer f.Close()\n\n\t_, err = f.Write(data)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n\nfunc WriteRows(path string, rows *[]Row, delimeter string) {\n\tf, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0644)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tdefer f.Close()\n\n\tfor _, r := range *rows {\n\t\t_, err = f.WriteString(strings.Join(r.Data, delimeter))\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t}\n\t}\n}\n\nfunc ReadData(path string) []byte ", "output": "{\n\td, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn []byte(``)\n\t}\n\n\treturn d\n}"}
{"input": "package model\n\nimport (\n\t\"testing\"\n)\n\nfunc TestArticleAdd(t *testing.T) {\n\tvar arts []*Article\n\tarts = append(arts, &Article{Title: \"党中央\", Content: \"不错哟\", Used: true})\n\tarts = append(arts, &Article{Title: \"中央党\", Content: \"不错哟\", Used: true})\n\tart := new(Article)\n\tr, err := art.Add(arts...)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else {\n\t\tt.Log(\"Article added success:\", r)\n\t}\n}\n\nfunc TestArticleAdd1(t *testing.T) {\n\tart := &Article{Title: \"党中xxxx央\", Content: \"不xxx错哟\", Used: true}\n\tartType := &ArticleType{Name: \"C#\", Ord: 1}\n\tr, err := artType.Add1(art, artType)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else {\n\t\tt.Log(r)\n\t}\n}\n\nfunc TestArticleDelete(t *testing.T) {\n\tart := &Article{}\n\tr, err := art.Delete(art, \"id>=?\", 4)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else {\n\t\tt.Log(\"Article delete success:\", r)\n\t}\n}\n\n\n\nfunc TestArticleUpdateByID(t *testing.T) ", "output": "{\n\tart := &Article{BaseModel: &BaseModel{ID: 3}, Title: \"我打啊\"}\n\tr, err := art.UpdateByID(art, \"Title,CreateTime\", \"\")\n\tif err != nil {\n\t\tt.Error(err)\n\t} else {\n\t\tt.Log(\"Article update success:\", r)\n\t}\n}"}
{"input": "package sysfs\n\nimport (\n\t\"strings\"\n)\n\ntype Object string\n\nfunc (obj Object) Exists() bool {\n\treturn dirExists(string(obj))\n}\n\n\n\nfunc (obj Object) SubObjects() []Object {\n\tpath := string(obj) + \"/\"\n\tobjects := make([]Object, 0)\n\tlsDirs(path, func(name string) {\n\t\tobjects = append(objects, Object(path+name))\n\t})\n\treturn objects\n}\n\nfunc (obj Object) SubObject(name string) Object {\n\treturn Object(string(obj) + \"/\" + name)\n}\n\nfunc (obj Object) Attributes() []Attribute {\n\tpath := string(obj) + \"/\"\n\tattribs := make([]Attribute, 0)\n\tlsFiles(path, func(name string) {\n\t\tattribs = append(attribs, Attribute{Path: path + name})\n\t})\n\treturn attribs\n}\n\nfunc (obj Object) Attribute(name string) *Attribute {\n\treturn &Attribute{Path: string(obj) + \"/\" + name}\n}\n\nfunc (obj Object) Name() string ", "output": "{\n\treturn string(obj)[strings.LastIndex(string(obj), \"/\")+1:]\n}"}
{"input": "package Plugin\n\nimport \"github.com/MPjct/GoMP/MySQLProtocol\"\n\ntype Plugin_interface interface {\n\tinit(context MySQLProtocol.Context)\n\tread_handshake(context MySQLProtocol.Context)\n\tsend_handshake(context MySQLProtocol.Context)\n\tread_auth(context MySQLProtocol.Context)\n\tsend_auth(context MySQLProtocol.Context)\n\tread_auth_result(context MySQLProtocol.Context)\n\tsend_auth_result(context MySQLProtocol.Context)\n\tread_query(context MySQLProtocol.Context)\n\tsend_query(context MySQLProtocol.Context)\n\tread_query_result(context MySQLProtocol.Context)\n\tsend_query_result(context MySQLProtocol.Context)\n\tcleanup(context MySQLProtocol.Context)\n}\n\ntype Plugin struct {\n}\n\nfunc (plugin *Plugin) init(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) read_handshake(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) send_handshake(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) read_auth(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) send_auth(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) read_auth_result(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) send_auth_result(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) read_query(context MySQLProtocol.Context) {\n\treturn\n}\n\n\n\nfunc (plugin *Plugin) read_query_result(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) send_query_result(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) cleanup(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) send_query(context MySQLProtocol.Context) ", "output": "{\n\treturn\n}"}
{"input": "package loggabletracer\n\nimport opentracing \"gx/ipfs/QmWLWmRVSiagqP15jczsGME1qpob6HDbtbHAY2he9W5iUo/opentracing-go\"\n\ntype accessorPropagator struct {\n\ttracer *LoggableTracer\n}\n\n\n\n\ntype DelegatingCarrier interface {\n\tSetState(traceID, spanID uint64, sampled bool)\n\tState() (traceID, spanID uint64, sampled bool)\n\tSetBaggageItem(key, value string)\n\tGetBaggage(func(key, value string))\n}\n\n\n\nfunc (p *accessorPropagator) Extract(\n\tcarrier interface{},\n) (opentracing.SpanContext, error) {\n\tdc, ok := carrier.(DelegatingCarrier)\n\tif !ok || dc == nil {\n\t\treturn nil, opentracing.ErrInvalidCarrier\n\t}\n\n\ttraceID, spanID, sampled := dc.State()\n\tsc := SpanContext{\n\t\tTraceID: traceID,\n\t\tSpanID:  spanID,\n\t\tSampled: sampled,\n\t\tBaggage: nil,\n\t}\n\tdc.GetBaggage(func(k, v string) {\n\t\tif sc.Baggage == nil {\n\t\t\tsc.Baggage = map[string]string{}\n\t\t}\n\t\tsc.Baggage[k] = v\n\t})\n\n\treturn sc, nil\n}\n\nfunc (p *accessorPropagator) Inject(\n\tspanContext opentracing.SpanContext,\n\tcarrier interface{},\n) error ", "output": "{\n\tdc, ok := carrier.(DelegatingCarrier)\n\tif !ok || dc == nil {\n\t\treturn opentracing.ErrInvalidCarrier\n\t}\n\tsc, ok := spanContext.(SpanContext)\n\tif !ok {\n\t\treturn opentracing.ErrInvalidSpanContext\n\t}\n\tdc.SetState(sc.TraceID, sc.SpanID, sc.Sampled)\n\tfor k, v := range sc.Baggage {\n\t\tdc.SetBaggageItem(k, v)\n\t}\n\treturn nil\n}"}
{"input": "package seller\n\nimport (\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/gomicro/gomws/auth\"\n\t\"github.com/gomicro/gomws/marketplace\"\n)\n\ntype Seller struct {\n\tId          string\n\tAuthToken   string\n\tMarketplace marketplace.Marketplace\n\tAuth        auth.Auth\n}\n\n\n\nfunc (s *Seller) Sign(u *url.URL) {\n\tparams := u.Query()\n\tparams.Set(\"SellerId\", s.Id)\n\tparams.Set(\"MWSAuthToken\", s.AuthToken)\n\tu.RawQuery = params.Encode()\n\ts.Auth.Sign(u)\n}\n\nfunc New(id, authToken, country string, auth auth.Auth) *Seller ", "output": "{\n\treturn &Seller{id, authToken, marketplace.Marketplaces[strings.ToLower(country)], auth}\n}"}
{"input": "package proc\n\nimport \"fmt\"\n\n\n\n\n\ntype Registers interface {\n\tPC() uint64\n\tSP() uint64\n\tCX() uint64\n\tTLS() uint64\n\tSetPC(*Thread, uint64) error\n\tString() string\n}\n\n\n\n\n\nfunc (thread *Thread) PC() (uint64, error) {\n\tregs, err := thread.Registers()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn regs.PC(), nil\n}\n\nfunc (thread *Thread) Registers() (Registers, error) ", "output": "{\n\tregs, err := registers(thread)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not get registers: %s\", err)\n\t}\n\treturn regs, nil\n}"}
{"input": "package tccpsubnets\n\nimport (\n\t\"context\"\n)\n\n\n\nfunc (r *Resource) EnsureDeleted(ctx context.Context, obj interface{}) error ", "output": "{\n\treturn nil\n}"}
{"input": "package message\n\nimport \"fmt\"\n\n\n\n\nfunc readURI(bytes *Bytes) (uri URI, err error) {\n\tvar ldapstring LDAPString\n\tldapstring, err = readLDAPString(bytes)\n\tif err != nil {\n\t\terr = LdapError{fmt.Sprintf(\"readURI:\\n%s\", err.Error())}\n\t\treturn\n\t}\n\turi = URI(ldapstring)\n\treturn\n}\n\n\n\n\n\n\n\n\n\nfunc (u URI) size() int {\n\treturn LDAPString(u).size()\n}\n\nfunc (u URI) write(bytes *Bytes) int ", "output": "{\n\treturn LDAPString(u).write(bytes)\n}"}
{"input": "package characteristic\n\nimport (\n\t\"github.com/brutella/hc/model\"\n)\n\ntype HeatingCoolingMode struct {\n\t*ByteCharacteristic\n}\n\nfunc NewHeatingCoolingMode(current model.HeatCoolModeType, charType CharType, permissions []string) *HeatingCoolingMode {\n\tc := HeatingCoolingMode{NewByteCharacteristic(byte(current), permissions)}\n\tc.Type = charType\n\n\treturn &c\n}\n\n\n\nfunc NewTargetHeatingCoolingMode(current model.HeatCoolModeType) *HeatingCoolingMode {\n\treturn NewHeatingCoolingMode(current, CharTypeHeatingCoolingModeTarget, PermsAll())\n}\n\nfunc (c *HeatingCoolingMode) SetHeatingCoolingMode(mode model.HeatCoolModeType) {\n\tc.SetByte(byte(mode))\n}\n\nfunc (c *HeatingCoolingMode) HeatingCoolingMode() model.HeatCoolModeType {\n\treturn model.HeatCoolModeType(c.Byte())\n}\n\nfunc NewCurrentHeatingCoolingMode(current model.HeatCoolModeType) *HeatingCoolingMode ", "output": "{\n\treturn NewHeatingCoolingMode(current, CharTypeHeatingCoolingModeCurrent, PermsRead())\n}"}
{"input": "package views\n\nimport \"github.com/cSploit/daemon/models\"\n\ntype networkIdxElem struct {\n\tmodels.Network\n\tHideHosts string `json:\"hosts,omitempty\"`\n}\n\ntype networkShowView struct {\n\tmodels.Network\n\tOverrideHosts interface{} `json:\"hosts,omitempty\"`\n}\n\nfunc NetworkIndex(args interface{}) interface{} {\n\tnets := args.([]models.Network)\n\tres := make([]networkIdxElem, len(nets))\n\n\tfor i, n := range nets {\n\t\tres[i] = networkIdxElem{Network: n}\n\t}\n\n\treturn res\n}\n\nfunc NetworkShow(arg interface{}) interface{} {\n\tnet := arg.(models.Network)\n\tres := networkShowView{Network: net}\n\n\tif len(net.Hosts) > 0 {\n\t\tres.OverrideHosts = HostsIndex(net.Hosts)\n\t}\n\n\treturn res\n}\n\n\n\nfunc networkAsChild(arg interface{}) interface{} ", "output": "{\n\tnetwork := arg.(models.Network)\n\treturn networkIdxElem{Network: network}\n}"}
{"input": "package transport \n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\n\n\n\ntype httpTransport struct {\n\thttp.RoundTripper\n\tscheme string\n\taddr   string\n}\n\n\nfunc NewHTTPTransport(r http.RoundTripper, scheme, addr string) Transport {\n\treturn httpTransport{\n\t\tRoundTripper: r,\n\t\tscheme:       scheme,\n\t\taddr:         addr,\n\t}\n}\n\n\n\n\n\nfunc (t httpTransport) NewRequest(path string, data io.Reader) (*http.Request, error) ", "output": "{\n\treq, err := newHTTPRequest(path, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.URL.Scheme = t.scheme\n\treq.URL.Host = t.addr\n\treturn req, nil\n}"}
{"input": "package db\n\nimport (\n\t\"hg/messages\"\n\t\"fmt\"\n\t\"gopkg.in/mgo.v2\"\n)\n\nconst (\n\tmongoURL = \"127.0.0.1:27017\"\n)\n\nfunc persist(operation string,historyEntry messages.HistoryMessage) {\n\tfmt.Println(\"Do db operation\")\n\tsession, err := mgo.Dial(mongoURL)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer session.Close()\n\n\thistoryCollection := session.DB(\"historys\").C(\"history\")\n\n\tswitch operation {\n\tcase \"Insert\":\n\t\terr = historyCollection.Insert(historyEntry)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Can't insert document: %v\\n\", err)\n\t\t\tpanic(err)\n\t\t}\n\tcase \"Update\":\n\t\tfmt.Println(\"Update method is not supported yet!\")\n\tcase \"Delete\":\n\t\tfmt.Println(\"Delete method is not supported yet!\")\n\tcase \"Put\":\n\t\tfmt.Println(\"Put method is not supported yet!\")\n\t}\n}\n\n\n\nfunc RecordHistory(historyEntry messages.HistoryMessage)", "output": "{\n\tfmt.Println(\"Start to record history object\")\n\tpersist(\"Insert\",historyEntry)\n}"}
{"input": "package config\n\nimport (\n\t\"github.com/mitchellh/go-homedir\"\n\t\"os\"\n)\n\nconst DB_FILE = \"davedb.db\"\n\n\n\nfunc DbPath() string {\n\thomeDir, _ := homedir.Dir()\n\treturn homeDir + string(os.PathSeparator) + DB_FILE\n}\n\nfunc TimeFormat() string ", "output": "{\n\treturn \"Monday, 2 Jan 2006\"\n}"}
{"input": "package clients\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest/adal\"\n\t\"k8s.io/client-go/util/flowcontrol\"\n\t\"k8s.io/legacy-cloud-providers/azure/retry\"\n)\n\n\ntype ClientConfig struct {\n\tLocation                string\n\tSubscriptionID          string\n\tResourceManagerEndpoint string\n\tServicePrincipalToken   *adal.ServicePrincipalToken\n\tRateLimitConfig         *RateLimitConfig\n\tBackoff                 *retry.Backoff\n\n\tCloudProviderBackoffRetries    int\n\tCloudProviderBackoffDuration   int\n\tShouldOmitCloudProviderBackoff bool\n}\n\n\n\n\n\ntype RateLimitConfig struct {\n\tCloudProviderRateLimit bool `json:\"cloudProviderRateLimit,omitempty\" yaml:\"cloudProviderRateLimit,omitempty\"`\n\tCloudProviderRateLimitQPS float32 `json:\"cloudProviderRateLimitQPS,omitempty\" yaml:\"cloudProviderRateLimitQPS,omitempty\"`\n\tCloudProviderRateLimitBucket int `json:\"cloudProviderRateLimitBucket,omitempty\" yaml:\"cloudProviderRateLimitBucket,omitempty\"`\n\tCloudProviderRateLimitQPSWrite float32 `json:\"cloudProviderRateLimitQPSWrite,omitempty\" yaml:\"cloudProviderRateLimitQPSWrite,omitempty\"`\n\tCloudProviderRateLimitBucketWrite int `json:\"cloudProviderRateLimitBucketWrite,omitempty\" yaml:\"cloudProviderRateLimitBucketWrite,omitempty\"`\n}\n\n\nfunc RateLimitEnabled(config *RateLimitConfig) bool {\n\treturn config != nil && config.CloudProviderRateLimit\n}\n\n\nfunc NewRateLimiter(config *RateLimitConfig) (flowcontrol.RateLimiter, flowcontrol.RateLimiter) {\n\treadLimiter := flowcontrol.NewFakeAlwaysRateLimiter()\n\twriteLimiter := flowcontrol.NewFakeAlwaysRateLimiter()\n\n\tif config != nil && config.CloudProviderRateLimit {\n\t\treadLimiter = flowcontrol.NewTokenBucketRateLimiter(\n\t\t\tconfig.CloudProviderRateLimitQPS,\n\t\t\tconfig.CloudProviderRateLimitBucket)\n\n\t\twriteLimiter = flowcontrol.NewTokenBucketRateLimiter(\n\t\t\tconfig.CloudProviderRateLimitQPSWrite,\n\t\t\tconfig.CloudProviderRateLimitBucketWrite)\n\t}\n\n\treturn readLimiter, writeLimiter\n}\n\nfunc (cfg *ClientConfig) WithRateLimiter(rl *RateLimitConfig) *ClientConfig ", "output": "{\n\tnewClientConfig := *cfg\n\tnewClientConfig.RateLimitConfig = rl\n\treturn &newClientConfig\n}"}
{"input": "package cat\n\nimport (\n\t\"time\"\n)\n\nvar (\n\taggregator_message_channel chan Message\n\taggregator_max_batch_size  int\n)\n\nfunc cat_aggregator_init() {\n\taggregator_message_channel = make(chan Message, 1<<10)\n\taggregator_max_batch_size = 1 << 8\n\tgo aggregator_run()\n}\n\n\n\n\nfunc aggregator_collect() bool {\n\tmessages := make(chan Message, sender_max_batch_size)\n\tvar count = 0\ncollect:\n\tfor count < aggregator_max_batch_size {\n\t\tselect {\n\t\tcase message := <-aggregator_message_channel:\n\t\t\tmessages <- message\n\t\t\tcount++\n\t\tdefault:\n\t\t\tbreak collect\n\t\t}\n\t}\n\tclose(messages)\n\tif count > 0 {\n\t\taggregator_transfer(messages)\n\t\treturn false\n\t} else {\n\t\treturn true\n\t}\n}\n\nfunc aggregator_transfer(messages <-chan Message) {\n\tt := NewTransaction(\"_CatMergeTree\", \"_CatMergeTree\", nil)\n\tfor message := range messages {\n\t\tt.AddChild(message)\n\t}\n\tt.SetStatus(\"0\")\n\tt.Complete()\n\tsender_transaction_channel <- t\n}\n\nfunc aggregator_run() ", "output": "{\n\tfor {\n\t\tif aggregator_collect() {\n\t\t\ttime.Sleep(1 << 16 * time.Microsecond)\n\t\t}\n\t}\n}"}
{"input": "package user\n\nimport (\n\tapi \"code.gitea.io/sdk/gitea\"\n\n\t\"code.gitea.io/gitea/models\"\n\t\"code.gitea.io/gitea/modules/context\"\n)\n\n\n\n\n\n\n\nfunc CreateAccessToken(ctx *context.APIContext, form api.CreateAccessTokenOption) {\n\tt := &models.AccessToken{\n\t\tUID:  ctx.User.ID,\n\t\tName: form.Name,\n\t}\n\tif err := models.NewAccessToken(t); err != nil {\n\t\tctx.Error(500, \"NewAccessToken\", err)\n\t\treturn\n\t}\n\tctx.JSON(201, &api.AccessToken{t.Name, t.Sha1})\n}\n\nfunc ListAccessTokens(ctx *context.APIContext) ", "output": "{\n\ttokens, err := models.ListAccessTokens(ctx.User.ID)\n\tif err != nil {\n\t\tctx.Error(500, \"ListAccessTokens\", err)\n\t\treturn\n\t}\n\n\tapiTokens := make([]*api.AccessToken, len(tokens))\n\tfor i := range tokens {\n\t\tapiTokens[i] = &api.AccessToken{tokens[i].Name, tokens[i].Sha1}\n\t}\n\tctx.JSON(200, &apiTokens)\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi\"\n)\n\ntype todosResource struct{}\n\n\nfunc (rs todosResource) Routes() chi.Router {\n\tr := chi.NewRouter()\n\n\tr.Get(\"/\", rs.List)    \n\tr.Post(\"/\", rs.Create) \n\tr.Put(\"/\", rs.Delete)\n\n\tr.Route(\"/{id}\", func(r chi.Router) {\n\t\tr.Get(\"/\", rs.Get)       \n\t\tr.Put(\"/\", rs.Update)    \n\t\tr.Delete(\"/\", rs.Delete) \n\t\tr.Get(\"/sync\", rs.Sync)\n\t})\n\n\treturn r\n}\n\nfunc (rs todosResource) List(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todos list of stuff..\"))\n}\n\nfunc (rs todosResource) Create(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todos create\"))\n}\n\n\n\nfunc (rs todosResource) Update(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todo update\"))\n}\n\nfunc (rs todosResource) Delete(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todo delete\"))\n}\n\nfunc (rs todosResource) Sync(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todo sync\"))\n}\n\nfunc (rs todosResource) Get(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tw.Write([]byte(\"todo get\"))\n}"}
{"input": "package metadata\n\nimport (\n\t\"context\"\n\n\t\"github.com/gravitational/teleport/api\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\nconst (\n\tVersionKey = \"version\"\n)\n\n\nfunc defaultMetadata() map[string]string {\n\treturn map[string]string{\n\t\tVersionKey: api.Version,\n\t}\n}\n\n\n\n\nfunc AddMetadataToContext(ctx context.Context, raw map[string]string) context.Context {\n\tmd := metadata.New(raw)\n\tif existingMd, ok := metadata.FromOutgoingContext(ctx); ok {\n\t\tfor key, vals := range existingMd {\n\t\t\tmd.Set(key, vals...)\n\t\t}\n\t}\n\treturn metadata.NewOutgoingContext(ctx, md)\n}\n\n\n\ntype DisableInterceptors struct{}\n\n\n\nfunc StreamClientInterceptor(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) {\n\tif disable := ctx.Value(DisableInterceptors{}); disable == nil {\n\t\tctx = AddMetadataToContext(ctx, defaultMetadata())\n\t}\n\treturn streamer(ctx, desc, cc, method, opts...)\n}\n\n\n\n\n\n\n\n\nfunc ClientVersionFromContext(ctx context.Context) (string, bool) {\n\tmd, ok := metadata.FromIncomingContext(ctx)\n\tif !ok {\n\t\treturn \"\", false\n\t}\n\tversionList := md.Get(VersionKey)\n\tif len(versionList) != 1 {\n\t\treturn \"\", false\n\t}\n\treturn versionList[0], true\n}\n\nfunc UnaryClientInterceptor(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error ", "output": "{\n\tif disable := ctx.Value(DisableInterceptors{}); disable == nil {\n\t\tctx = AddMetadataToContext(ctx, defaultMetadata())\n\t}\n\treturn invoker(ctx, method, req, reply, cc, opts...)\n}"}
{"input": "package main\n\nimport \"fmt\"\n\n\nfunc main() {\n\n\n\n\ta := []int{10, 20, 30}\n\tfmt.Println(a)\n\tdemo11(a...)\n\tfmt.Println(a)\n\n}\n\n\nfunc function11(s string, a ...int) {\n\tfmt.Printf(\"%T,%v\\n\", a, a)\n}\n\n\n\n\n\nfunc demo11(a ...int) {\n\tfor i := range a {\n\t\ta[i] += 100\n\t}\n}\n\nfunc test11(a ...int) ", "output": "{\n\tfmt.Println(a)\n}"}
{"input": "package models\n\nimport (\n\t\"fmt\"\n)\n\n\ntype Auth struct {\n\tEndpoint string \n\tKey      string \n}\n\n\nfunc (a *Auth) IsNew() bool {\n\treturn a.Key == \"\"\n}\n\n\nfunc (a *Auth) Save() error {\n\n\tif err := put(\"auths\", a.Endpoint, a); err != nil {\n\t\treturn fmt.Errorf(\"failed to save auth: %s\", err.Error())\n\t}\n\n\treturn nil\n}\n\n\nfunc (a *Auth) Delete() error {\n\n\treturn DeleteAuth(a.Endpoint)\n}\n\n\nfunc LoadAuth() (*Auth, error) {\n\tauth := &Auth{\n\t\tEndpoint: \"nanobox\",\n\t}\n\n\tif err := get(\"auths\", auth.Endpoint, &auth); err != nil {\n\t\treturn auth, fmt.Errorf(\"failed to load auth: %s\", err.Error())\n\t}\n\n\treturn auth, nil\n}\n\n\n\n\n\nfunc DeleteAuth(endpoint string) error {\n\n\tif err := destroy(\"auths\", endpoint); err != nil {\n\t\treturn fmt.Errorf(\"failed to delete auth: %s\", err.Error())\n\t}\n\n\treturn nil\n}\n\nfunc LoadAuthByEndpoint(endpoint string) (*Auth, error) ", "output": "{\n\tauth := &Auth{\n\t\tEndpoint: endpoint,\n\t}\n\n\tif err := get(\"auths\", endpoint, &auth); err != nil {\n\t\treturn auth, fmt.Errorf(\"failed to load auth: %s\", err.Error())\n\t}\n\n\treturn auth, nil\n}"}
{"input": "package dataSet\n\nconst DATANOTFOUND = \"no data with this key\"\n\ntype DataSet struct {\n\tSet map[string]PieceOfData\n}\n\ntype PieceOfData struct {\n\tTag   string \n\tValue string \n}\n\nfunc (d *DataSet) SetData(key, value, tag string) bool {\n\t_, exist := d.Set[key]\n\tif exist {\n\t\treturn false\n\t} else {\n\t\td.Set[key] = PieceOfData{\n\t\t\ttag,\n\t\t\tvalue,\n\t\t}\n\t\treturn true\n\t}\n}\n\n\n\nfunc (d *DataSet) DelData(key string) {\n\tdelete(d.Set, key)\n}\n\nfunc (d *DataSet) GetSet() map[string]PieceOfData {\n\treturn d.Set\n}\n\nfunc MakeDataSet() DataSet {\n\treturn DataSet{\n\t\tmake(map[string]PieceOfData),\n\t}\n}\n\nfunc (d *DataSet) GetData(key string) PieceOfData ", "output": "{\n\tval, ok := d.Set[key]\n\tif ok {\n\t\treturn val\n\n\t} else {\n\t\treturn PieceOfData{\n\t\t\t\"\",\n\t\t\tDATANOTFOUND,\n\t\t}\n\t}\n}"}
{"input": "package info_fakes\n\nimport (\n\t\"sync\"\n\n\t\"github.com/cloudfoundry-incubator/diego-ssh/cf-plugin/models/info\"\n)\n\ntype FakeInfoFactory struct {\n\tGetStub        func() (info.Info, error)\n\tgetMutex       sync.RWMutex\n\tgetArgsForCall []struct{}\n\tgetReturns     struct {\n\t\tresult1 info.Info\n\t\tresult2 error\n\t}\n}\n\nfunc (fake *FakeInfoFactory) Get() (info.Info, error) {\n\tfake.getMutex.Lock()\n\tfake.getArgsForCall = append(fake.getArgsForCall, struct{}{})\n\tfake.getMutex.Unlock()\n\tif fake.GetStub != nil {\n\t\treturn fake.GetStub()\n\t} else {\n\t\treturn fake.getReturns.result1, fake.getReturns.result2\n\t}\n}\n\n\n\nfunc (fake *FakeInfoFactory) GetReturns(result1 info.Info, result2 error) {\n\tfake.GetStub = nil\n\tfake.getReturns = struct {\n\t\tresult1 info.Info\n\t\tresult2 error\n\t}{result1, result2}\n}\n\nvar _ info.InfoFactory = new(FakeInfoFactory)\n\nfunc (fake *FakeInfoFactory) GetCallCount() int ", "output": "{\n\tfake.getMutex.RLock()\n\tdefer fake.getMutex.RUnlock()\n\treturn len(fake.getArgsForCall)\n}"}
{"input": "package goweb\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype ctx struct {\n\twriter  http.ResponseWriter \n\trequest *http.Request       \n}\n\n\nfunc (this *ctx) SetHeader(key, val string) {\n\tthis.writer.Header().Set(key, val)\n}\n\n\nfunc (this *ctx) GetHeader(key string) {\n\tthis.request.Header.Get(key)\n}\n\n\nfunc (this *ctx) Echo(result string) error {\n\t_, err := this.writer.Write([]byte(result))\n\treturn err\n}\n\n\nfunc (this *ctx) JSON(data interface{}, hasIndent bool) {\n\tthis.SetHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n\tvar content []byte\n\tvar err error\n\tif hasIndent {\n\t\tcontent, err = json.MarshalIndent(data, \"\", \"  \")\n\t} else {\n\t\tcontent, err = json.Marshal(data)\n\t}\n\tif err != nil {\n\t\tthis.EchoError(err)\n\t\treturn\n\t}\n\n\terr = this.Echo(string(content))\n\n\tif err != nil {\n\t\tthis.EchoError(err)\n\t}\n}\n\n\nfunc (this *ctx) Redirect(url string) {\n\thttp.Redirect(this.writer, this.request, url, http.StatusFound)\n}\n\n\n\n\n\nfunc (this *ctx) RunError(err error) {\n\tlog.Println(err)\n\tthis.EchoError(errors.New(\"Page wrong\"))\n}\n\nfunc (this *ctx) EchoError(err error) ", "output": "{\n\thttp.Error(this.writer, err.Error(), http.StatusInternalServerError)\n}"}
{"input": "package avalanche\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/valyala/fasthttp\"\n)\n\n\ntype HTTPWriterConfig struct {\n\tHost string\n\n\tDatabase string\n}\n\n\ntype HTTPWriter struct {\n\tclient fasthttp.Client\n\n\tc   HTTPWriterConfig\n\turl []byte\n}\n\n\nfunc NewHTTPWriter(c HTTPWriterConfig) LineProtocolWriter {\n\treturn &HTTPWriter{\n\t\tclient: fasthttp.Client{\n\t\t\tName: \"avalanche\",\n\t\t},\n\n\t\tc:   c,\n\t\turl: []byte(c.Host + \"/write?db=\" + url.QueryEscape(c.Database)),\n\t}\n}\n\nvar (\n\tpost      = []byte(\"POST\")\n\ttextPlain = []byte(\"text/plain\")\n)\n\n\n\n\n\n\nfunc (w *HTTPWriter) WriteLineProtocol(body []byte) (int64, error) ", "output": "{\n\treq := fasthttp.AcquireRequest()\n\treq.Header.SetContentTypeBytes(textPlain)\n\treq.Header.SetMethodBytes(post)\n\treq.Header.SetRequestURIBytes(w.url)\n\treq.SetBody(body)\n\n\tresp := fasthttp.AcquireResponse()\n\tstart := time.Now()\n\terr := w.client.Do(req, resp)\n\tlat := time.Since(start).Nanoseconds()\n\tif err == nil {\n\t\tsc := resp.StatusCode()\n\t\tif sc != fasthttp.StatusNoContent {\n\t\t\terr = fmt.Errorf(\"Invalid write response (status %d): %s\", sc, resp.Body())\n\t\t}\n\t}\n\n\tfasthttp.ReleaseResponse(resp)\n\tfasthttp.ReleaseRequest(req)\n\n\treturn lat, err\n}"}
{"input": "package fakes\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"code.google.com/p/go-uuid/uuid\"\n\t. \"github.com/mandarjog/leasedispenser/leasemanager\"\n)\n\ntype MemProvider struct {\n\tDB map[string]ProviderLeaseInfo\n}\n\n\n\nfunc (s MemProvider) Request(req ProviderLeaseRequest) (info ProviderLeaseInfo, err error) {\n\tproviderLeaseID := uuid.New()\n\tinfo.ProviderLeaseID = providerLeaseID\n\tinfo.StatusCode = LeaseStatusPending\n\tnewinfo := info\n\tnewinfo.StatusCode = LeaseStatusActive\n\tnewinfo.LeaseStartDate = time.Now().UnixNano()\n\tnewinfo.LeaseEndDate = newinfo.LeaseStartDate + req.Duration\n\ts.DB[providerLeaseID] = newinfo\n\treturn\n}\nfunc (s MemProvider) Info(providerLeaseID string) (info ProviderLeaseInfo, err error) {\n\tvar found bool\n\tif info, found = s.DB[providerLeaseID]; !found {\n\t\terr = errors.New(providerLeaseID + \" was not found\")\n\t}\n\treturn\n}\n\nfunc NewMemProvider() LeaseProvider ", "output": "{\n\treturn MemProvider{\n\t\tDB: make(map[string]ProviderLeaseInfo),\n\t}\n}"}
{"input": "package gen\n\nimport \"encoding/json\"\n\n\ntype RoleDefinitionAttributes struct {\n  Role string `json:\"role,omitempty\"`\n  Permissions []string `json:\"permissions,omitempty\"`\n}\n\n\n\n\nfunc (data * RoleDefinitionAttributes) FromJson(raw []byte) error ", "output": "{\n  return json.Unmarshal(raw, data)\n}"}
{"input": "package telegraf\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/influxdb/influxdb/client\"\n)\n\n\n\ntype BatchPoints struct {\n\tmu sync.Mutex\n\n\tclient.BatchPoints\n\n\tDebug bool\n\n\tPrefix string\n\n\tConfig *ConfiguredPlugin\n}\n\n\n\n\n\nfunc (bp *BatchPoints) AddValuesWithTime(\n\tmeasurement string,\n\tvalues map[string]interface{},\n\ttags map[string]string,\n\ttimestamp time.Time,\n) {\n\tbp.mu.Lock()\n\tdefer bp.mu.Unlock()\n\n\tmeasurement = bp.Prefix + measurement\n\n\tif bp.Config != nil {\n\t\tif !bp.Config.ShouldPass(measurement, tags) {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif bp.Debug {\n\t\tvar tg []string\n\n\t\tfor k, v := range tags {\n\t\t\ttg = append(tg, fmt.Sprintf(\"%s=\\\"%s\\\"\", k, v))\n\t\t}\n\n\t\tvar vals []string\n\n\t\tfor k, v := range values {\n\t\t\tvals = append(vals, fmt.Sprintf(\"%s=%v\", k, v))\n\t\t}\n\n\t\tsort.Strings(tg)\n\t\tsort.Strings(vals)\n\n\t\tfmt.Printf(\"> [%s] %s %s\\n\", strings.Join(tg, \" \"), measurement, strings.Join(vals, \" \"))\n\t}\n\n\tbp.Points = append(bp.Points, client.Point{\n\t\tMeasurement: measurement,\n\t\tTags:        tags,\n\t\tFields:      values,\n\t\tTime:        timestamp,\n\t})\n}\n\nfunc (bp *BatchPoints) Add(measurement string, val interface{}, tags map[string]string) ", "output": "{\n\tbp.mu.Lock()\n\tdefer bp.mu.Unlock()\n\n\tmeasurement = bp.Prefix + measurement\n\n\tif bp.Config != nil {\n\t\tif !bp.Config.ShouldPass(measurement, tags) {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif bp.Debug {\n\t\tvar tg []string\n\n\t\tfor k, v := range tags {\n\t\t\ttg = append(tg, fmt.Sprintf(\"%s=\\\"%s\\\"\", k, v))\n\t\t}\n\n\t\tsort.Strings(tg)\n\n\t\tfmt.Printf(\"> [%s] %s value=%v\\n\", strings.Join(tg, \" \"), measurement, val)\n\t}\n\n\tbp.Points = append(bp.Points, client.Point{\n\t\tMeasurement: measurement,\n\t\tTags:        tags,\n\t\tFields: map[string]interface{}{\n\t\t\t\"value\": val,\n\t\t},\n\t})\n}"}
{"input": "package string_byte_array_converter\n\nimport (\n\t\"github.com/khlieng/name_pending/Godeps/_workspace/src/github.com/blevesearch/bleve/analysis\"\n\t\"github.com/khlieng/name_pending/Godeps/_workspace/src/github.com/blevesearch/bleve/registry\"\n)\n\ntype StringByteArrayConverter struct{}\n\nfunc NewStringByteArrayConverter() *StringByteArrayConverter {\n\treturn &StringByteArrayConverter{}\n}\n\nfunc (c *StringByteArrayConverter) Convert(in []byte) (interface{}, error) {\n\treturn string(in), nil\n}\n\n\n\nfunc init() {\n\tregistry.RegisterByteArrayConverter(\"string\", Constructor)\n}\n\nfunc Constructor(config map[string]interface{}, cache *registry.Cache) (analysis.ByteArrayConverter, error) ", "output": "{\n\treturn NewStringByteArrayConverter(), nil\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\t\"net/url\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar rootCmd *cobra.Command\n\n\n\nfunc run(cmd *cobra.Command, args []string) {\n\taddress, err := cmd.Flags().GetString(\"address\")\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tu := url.URL{Scheme: \"ws\", Host: address, Path: \"/publish\"}\n\tlog.Printf(\"connecting to %s\", u.String())\n\n\tc, _, err := websocket.DefaultDialer.Dial(u.String(), nil)\n\tif err != nil {\n\t\tlog.Fatal(\"dial:\", err)\n\t}\n\tdefer c.Close()\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\t_, message, err := c.ReadMessage()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"read:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Printf(\"recv: %s\", message)\n\t\t\tbreak\n\t\t}\n\t\twg.Done()\n\t}()\n\n\terr = c.WriteMessage(websocket.TextMessage, []byte(\"hello\"))\n\tif err != nil {\n\t\tlog.Println(\"write:\", err)\n\t\treturn\n\t}\n\n\twg.Wait()\n}\n\nfunc main() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}\n\nfunc init() ", "output": "{\n\trootCmd = &cobra.Command{\n\t\tUse:   \"ws-client\",\n\t\tShort: \"demo for websocket client\",\n\t\tLong:  \"demo for websocket client\",\n\t\tRun:   run,\n\t}\n\n\trootCmd.Flags().StringP(\"address\", \"a\", \"127.0.0.1:8080\", \"server listening address\")\n}"}
{"input": "package ts_test\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"github.com/32bitkid/bitreader\"\n\t\"github.com/32bitkid/mpeg/ts\"\n\t\"strings\"\n)\n\n\n\n\nfunc Example() ", "output": "{\n\treader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(shortTsStream))\n\tbr := bitreader.NewReader(reader)\n\n\tpacket := new(ts.Packet)\n\tfor {\n\t\terr := packet.Next(br)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(packet)\n\t}\n\n}"}
{"input": "package iso20022\n\n\ntype PointOfInteractionComponent6 struct {\n\n\tType *POIComponentType4Code `xml:\"Tp\"`\n\n\tIdentification *PointOfInteractionComponentIdentification1 `xml:\"Id\"`\n\n\tStatus *PointOfInteractionComponentStatus3 `xml:\"Sts,omitempty\"`\n\n\tStandardCompliance []*GenericIdentification48 `xml:\"StdCmplc,omitempty\"`\n\n\tCharacteristics *PointOfInteractionComponentCharacteristics2 `xml:\"Chrtcs,omitempty\"`\n\n\tAssessment []*PointOfInteractionComponentAssessment1 `xml:\"Assmnt,omitempty\"`\n}\n\nfunc (p *PointOfInteractionComponent6) SetType(value string) {\n\tp.Type = (*POIComponentType4Code)(&value)\n}\n\n\n\nfunc (p *PointOfInteractionComponent6) AddStatus() *PointOfInteractionComponentStatus3 {\n\tp.Status = new(PointOfInteractionComponentStatus3)\n\treturn p.Status\n}\n\nfunc (p *PointOfInteractionComponent6) AddStandardCompliance() *GenericIdentification48 {\n\tnewValue := new(GenericIdentification48)\n\tp.StandardCompliance = append(p.StandardCompliance, newValue)\n\treturn newValue\n}\n\nfunc (p *PointOfInteractionComponent6) AddCharacteristics() *PointOfInteractionComponentCharacteristics2 {\n\tp.Characteristics = new(PointOfInteractionComponentCharacteristics2)\n\treturn p.Characteristics\n}\n\nfunc (p *PointOfInteractionComponent6) AddAssessment() *PointOfInteractionComponentAssessment1 {\n\tnewValue := new(PointOfInteractionComponentAssessment1)\n\tp.Assessment = append(p.Assessment, newValue)\n\treturn newValue\n}\n\nfunc (p *PointOfInteractionComponent6) AddIdentification() *PointOfInteractionComponentIdentification1 ", "output": "{\n\tp.Identification = new(PointOfInteractionComponentIdentification1)\n\treturn p.Identification\n}"}
{"input": "package edit_test\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n)\n\n\n\nfunc TestEdit(t *testing.T) ", "output": "{\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Edit Suite\")\n}"}
{"input": "package discovery\n\nimport (\n\t\"crypto/sha256\"\n\t\"io\"\n\t\"os\"\n)\n\n\n\ntype PluginMeta struct {\n\tName string\n\n\tVersion VersionStr\n\n\tPath string\n}\n\n\n\n\n\nfunc (m PluginMeta) SHA256() ([]byte, error) ", "output": "{\n\tf, err := os.Open(m.Path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\th := sha256.New()\n\t_, err = io.Copy(h, f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn h.Sum(nil), nil\n}"}
{"input": "package widgets\n\nimport (\n\t\"strings\"\n\n\t\"github.com/ambientsound/pms/songlist\"\n\t\"github.com/ambientsound/pms/style\"\n\t\"github.com/gdamore/tcell\"\n\t\"github.com/gdamore/tcell/views\"\n)\n\ntype ColumnheadersWidget struct {\n\tcolumns songlist.Columns\n\tview    views.View\n\n\tstyle.Styled\n\tviews.WidgetWatchers\n}\n\nfunc NewColumnheadersWidget() (c *ColumnheadersWidget) {\n\tc = &ColumnheadersWidget{}\n\tc.columns = make(songlist.Columns, 0)\n\treturn\n}\n\nfunc (c *ColumnheadersWidget) SetColumns(cols songlist.Columns) {\n\tc.columns = cols\n}\n\nfunc (c *ColumnheadersWidget) Draw() {\n\tx := 0\n\ty := 0\n\tfor i := range c.columns {\n\t\tcol := c.columns[i]\n\t\ttitle := []rune(strings.Title(col.Tag()))\n\t\tp := 0\n\t\tfor _, r := range title {\n\t\t\tc.view.SetContent(x+p, y, r, nil, c.Style(\"header\"))\n\t\t\tp++\n\t\t}\n\t\tx += col.Width()\n\t}\n}\n\nfunc (c *ColumnheadersWidget) SetView(v views.View) {\n\tc.view = v\n}\n\nfunc (c *ColumnheadersWidget) Size() (int, int) {\n\tx, y := c.view.Size()\n\ty = 1\n\treturn x, y\n}\n\nfunc (w *ColumnheadersWidget) Resize() {\n}\n\n\n\nfunc (w *ColumnheadersWidget) HandleEvent(ev tcell.Event) bool ", "output": "{\n\treturn false\n}"}
{"input": "package discovery\n\nimport (\n\t\"errors\"\n\n\t\"github.com/spf13/pflag\"\n\n\tvtadminpb \"vitess.io/vitess/go/vt/proto/vtadmin\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype DynamicDiscovery struct {\n\tJSONDiscovery\n}\n\n\n\n\nfunc NewDynamic(cluster *vtadminpb.Cluster, flags *pflag.FlagSet, args []string) (Discovery, error) ", "output": "{\n\tdisco := &DynamicDiscovery{\n\t\tJSONDiscovery: JSONDiscovery{\n\t\t\tcluster: cluster,\n\t\t},\n\t}\n\n\tjson := flags.String(\"discovery\", \"\", \"the json config object\")\n\tif err := flags.Parse(args); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif json == nil || *json == \"\" {\n\t\treturn nil, errors.New(\"must pass service discovery json config object\")\n\t}\n\n\tbytes := []byte(*json)\n\tif err := disco.parseConfig(bytes); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn disco, nil\n}"}
{"input": "package ray\n\nimport (\n\t\"github.com/v2ray/v2ray-core/common/alloc\"\n)\n\nconst (\n\tbufferSize = 128\n)\n\n\n\n\ntype directRay struct {\n\tInput  chan *alloc.Buffer\n\tOutput chan *alloc.Buffer\n}\n\nfunc (this *directRay) OutboundInput() <-chan *alloc.Buffer {\n\treturn this.Input\n}\n\nfunc (this *directRay) OutboundOutput() chan<- *alloc.Buffer {\n\treturn this.Output\n}\n\nfunc (this *directRay) InboundInput() chan<- *alloc.Buffer {\n\treturn this.Input\n}\n\nfunc (this *directRay) InboundOutput() <-chan *alloc.Buffer {\n\treturn this.Output\n}\n\nfunc NewRay() Ray ", "output": "{\n\treturn &directRay{\n\t\tInput:  make(chan *alloc.Buffer, bufferSize),\n\t\tOutput: make(chan *alloc.Buffer, bufferSize),\n\t}\n}"}
{"input": "package service\n\nimport (\n\tgofig \"github.com/akutz/gofig/types\"\n\n\t\"github.com/rexray/rexray/libstorage/api/registry\"\n\t\"github.com/rexray/rexray/libstorage/api/server/handlers\"\n\t\"github.com/rexray/rexray/libstorage/api/server/httputils\"\n\t\"github.com/rexray/rexray/libstorage/api/types\"\n\t\"github.com/rexray/rexray/libstorage/api/utils/schema\"\n)\n\n\n\ntype router struct {\n\troutes []types.Route\n}\n\nfunc (r *router) Name() string {\n\treturn \"service-router\"\n}\n\nfunc (r *router) Init(config gofig.Config) {\n\tr.initRoutes()\n}\n\n\nfunc (r *router) Routes() []types.Route {\n\treturn r.routes\n}\n\nfunc (r *router) initRoutes() {\n\n\tr.routes = []types.Route{\n\n\t\thttputils.NewGetRoute(\n\t\t\t\"services\",\n\t\t\t\"/services\",\n\t\t\tr.servicesList,\n\t\t\thandlers.NewAuthAllSvcsHandler(),\n\t\t\thandlers.NewSchemaValidator(nil, schema.ServiceInfoMapSchema, nil)),\n\n\t\thttputils.NewGetRoute(\n\t\t\t\"serviceInspect\",\n\t\t\t\"/services/{service}\",\n\t\t\tr.serviceInspect,\n\t\t\thandlers.NewServiceValidator(),\n\t\t\thandlers.NewAuthSvcHandler(),\n\t\t\thandlers.NewSchemaValidator(nil, schema.ServiceInfoSchema, nil)),\n\t}\n}\n\nfunc init() ", "output": "{\n\tregistry.RegisterRouter(&router{})\n}"}
{"input": "package main\n\nimport \"fmt\"\n\nconst (\n\ta = iota\n\tb\n\tc\n\td\n\te\n)\n\nvar x = []int{1, 2, 3}\n\nfunc f(x int, len *byte) {\n\t*len = byte(x)\n}\n\n\n\nfunc whatis1(x interface{}) string {\n\txx := x\n\tswitch xx.(type) {\n\tdefault:\n\t\treturn fmt.Sprint(\"default \", xx)\n\tcase int, int8, int16, int32:\n\t\treturn fmt.Sprint(\"signed \", xx)\n\tcase int64:\n\t\treturn fmt.Sprint(\"signed64 \", xx.(int64))\n\tcase uint, uint8, uint16, uint32:\n\t\treturn fmt.Sprint(\"unsigned \", xx)\n\tcase uint64:\n\t\treturn fmt.Sprint(\"unsigned64 \", xx.(uint64))\n\tcase nil:\n\t\treturn fmt.Sprint(\"nil \", xx)\n\t}\n\tpanic(\"not reached\")\n}\n\nfunc check(x interface{}, s string) {\n\tw := whatis(x)\n\tif w != s {\n\t\tfmt.Println(\"whatis\", x, \"=>\", w, \"!=\", s)\n\t\tpanic(\"fail\")\n\t}\n\n\tw = whatis1(x)\n\tif w != s {\n\t\tfmt.Println(\"whatis1\", x, \"=>\", w, \"!=\", s)\n\t\tpanic(\"fail\")\n\t}\n}\n\nfunc main() {\n\tcheck(1, \"signed 1\")\n\tcheck(uint(1), \"unsigned 1\")\n\tcheck(int64(1), \"signed64 1\")\n\tcheck(uint64(1), \"unsigned64 1\")\n\tcheck(1.5, \"default 1.5\")\n\tcheck(nil, \"nil <nil>\")\n}\n\nfunc whatis(x interface{}) string ", "output": "{\n\tswitch xx := x.(type) {\n\tdefault:\n\t\treturn fmt.Sprint(\"default \", xx)\n\tcase int, int8, int16, int32:\n\t\treturn fmt.Sprint(\"signed \", xx)\n\tcase int64:\n\t\treturn fmt.Sprint(\"signed64 \", int64(xx))\n\tcase uint, uint8, uint16, uint32:\n\t\treturn fmt.Sprint(\"unsigned \", xx)\n\tcase uint64:\n\t\treturn fmt.Sprint(\"unsigned64 \", uint64(xx))\n\tcase nil:\n\t\treturn fmt.Sprint(\"nil \", xx)\n\t}\n\tpanic(\"not reached\")\n}"}
{"input": "package api\n\ntype FakeCurlRepository struct {\n\tMethod         string\n\tPath           string\n\tHeader         string\n\tBody           string\n\tResponseHeader string\n\tResponseBody   string\n\tError          error\n}\n\n\n\nfunc (repo *FakeCurlRepository) Request(method, path, header, body string) (resHeaders, resBody string, apiErr error) ", "output": "{\n\trepo.Method = method\n\trepo.Path = path\n\trepo.Header = header\n\trepo.Body = body\n\n\tresHeaders = repo.ResponseHeader\n\tresBody = repo.ResponseBody\n\tapiErr = repo.Error\n\treturn\n}"}
{"input": "package elastic\n\n\n\n\n\n\n\n\n\ntype MissingAggregation struct {\n\tfield           string\n\tsubAggregations map[string]Aggregation\n\tmeta            map[string]interface{}\n}\n\nfunc NewMissingAggregation() *MissingAggregation {\n\treturn &MissingAggregation{\n\t\tsubAggregations: make(map[string]Aggregation),\n\t}\n}\n\n\n\nfunc (a *MissingAggregation) SubAggregation(name string, subAggregation Aggregation) *MissingAggregation {\n\ta.subAggregations[name] = subAggregation\n\treturn a\n}\n\n\nfunc (a *MissingAggregation) Meta(metaData map[string]interface{}) *MissingAggregation {\n\ta.meta = metaData\n\treturn a\n}\n\nfunc (a *MissingAggregation) Source() (interface{}, error) {\n\n\tsource := make(map[string]interface{})\n\topts := make(map[string]interface{})\n\tsource[\"missing\"] = opts\n\n\tif a.field != \"\" {\n\t\topts[\"field\"] = a.field\n\t}\n\n\tif len(a.subAggregations) > 0 {\n\t\taggsMap := make(map[string]interface{})\n\t\tsource[\"aggregations\"] = aggsMap\n\t\tfor name, aggregate := range a.subAggregations {\n\t\t\tsrc, err := aggregate.Source()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\taggsMap[name] = src\n\t\t}\n\t}\n\n\tif len(a.meta) > 0 {\n\t\tsource[\"meta\"] = a.meta\n\t}\n\n\treturn source, nil\n}\n\nfunc (a *MissingAggregation) Field(field string) *MissingAggregation ", "output": "{\n\ta.field = field\n\treturn a\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ListShapesRequest struct {\n\n\tCompartmentId *string `mandatory:\"true\" contributesTo:\"query\" name:\"compartmentId\"`\n\n\tAvailabilityDomain *string `mandatory:\"false\" contributesTo:\"query\" name:\"availabilityDomain\"`\n\n\tLimit *int `mandatory:\"false\" contributesTo:\"query\" name:\"limit\"`\n\n\tPage *string `mandatory:\"false\" contributesTo:\"query\" name:\"page\"`\n\n\tImageId *string `mandatory:\"false\" contributesTo:\"query\" name:\"imageId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request ListShapesRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request ListShapesRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\n\n\n\nfunc (request ListShapesRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ListShapesResponse struct {\n\n\tRawResponse *http.Response\n\n\tItems []Shape `presentIn:\"body\"`\n\n\tOpcNextPage *string `presentIn:\"header\" name:\"opc-next-page\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response ListShapesResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response ListShapesResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request ListShapesRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) ", "output": "{\n\n\treturn nil, false\n\n}"}
{"input": "package vault\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype SecretRule interface {\n}\n\ntype secretrule struct {\n\tJsonData []byte\n\tRuleType string `json:\"ruleType\"`\n}\n\n\n\n\n\nfunc (m *secretrule) UnmarshalPolymorphicJSON(data []byte) (interface{}, error) {\n\n\tif data == nil || string(data) == \"null\" {\n\t\treturn nil, nil\n\t}\n\n\tvar err error\n\tswitch m.RuleType {\n\tcase \"SECRET_EXPIRY_RULE\":\n\t\tmm := SecretExpiryRule{}\n\t\terr = json.Unmarshal(data, &mm)\n\t\treturn mm, err\n\tcase \"SECRET_REUSE_RULE\":\n\t\tmm := SecretReuseRule{}\n\t\terr = json.Unmarshal(data, &mm)\n\t\treturn mm, err\n\tdefault:\n\t\treturn *m, nil\n\t}\n}\n\nfunc (m secretrule) String() string {\n\treturn common.PointerString(m)\n}\n\n\ntype SecretRuleRuleTypeEnum string\n\n\nconst (\n\tSecretRuleRuleTypeExpiryRule SecretRuleRuleTypeEnum = \"SECRET_EXPIRY_RULE\"\n\tSecretRuleRuleTypeReuseRule  SecretRuleRuleTypeEnum = \"SECRET_REUSE_RULE\"\n)\n\nvar mappingSecretRuleRuleType = map[string]SecretRuleRuleTypeEnum{\n\t\"SECRET_EXPIRY_RULE\": SecretRuleRuleTypeExpiryRule,\n\t\"SECRET_REUSE_RULE\":  SecretRuleRuleTypeReuseRule,\n}\n\n\nfunc GetSecretRuleRuleTypeEnumValues() []SecretRuleRuleTypeEnum {\n\tvalues := make([]SecretRuleRuleTypeEnum, 0)\n\tfor _, v := range mappingSecretRuleRuleType {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}\n\nfunc (m *secretrule) UnmarshalJSON(data []byte) error ", "output": "{\n\tm.JsonData = data\n\ttype Unmarshalersecretrule secretrule\n\ts := struct {\n\t\tModel Unmarshalersecretrule\n\t}{}\n\terr := json.Unmarshal(data, &s.Model)\n\tif err != nil {\n\t\treturn err\n\t}\n\tm.RuleType = s.Model.RuleType\n\n\treturn err\n}"}
{"input": "package main\n\nimport \"reflect\"\n\nfunc typeof(x interface{}) string {\n\treturn reflect.Typeof(x).String();\n}\n\n\n\nfunc g() int {\n\treturn 0;\n}\n\ntype T func() int\n\nvar m = map[string] T {\n\t\"f\": f\n}\n\ntype A int\ntype B int\n\nvar a A = 1;\nvar b B = 2;\nvar x int;\n\nfunc main() {\n\twant := typeof(g);\n\tif t := typeof(f); t != want {\n\t\tpanicln(\"type of f is\", t, \"want\", want);\n\t}\n\n\twant = typeof(a);\n\tif t := typeof(+a); t != want {\n\t\tpanicln(\"type of +a is\", t, \"want\", want);\n\t}\n\tif t := typeof(a+0); t != want {\n\t\tpanicln(\"type of a+0 is\", t, \"want\", want);\n\t}\n}\n\nfunc f() int ", "output": "{\n\treturn 0;\n}"}
{"input": "package tools_test\n\nimport (\n\t\"testing\"\n\n\tgc \"launchpad.net/gocheck\"\n)\n\n\n\nfunc Test(t *testing.T) ", "output": "{\n\tsetupToolsTests()\n\tsetupSimpleStreamsTests(t)\n\tgc.TestingT(t)\n}"}
{"input": "package hdiutil\n\nimport \"os/exec\"\n\n\ntype formatFlag interface {\n\tformatFlag() []string\n}\n\ntype convertFormot int\n\nconst (\n\tConvertUDRW convertFormot = 1 << iota\n\tConvertUDRO\n\tConvertUDCO\n\tConvertUDZO\n\tConvertULFO\n\tConvertUDBZ\n\tConvertUDTO\n\tConvertUDSP\n\tConvertUDSB\n\tConvertUFBI\n\tConvertUDRo\n\tConvertUDCo\n\tConvertRdWr\n\tConvertRdxx\n\tConvertROCo\n\tConvertRken\n\tConvertDC42\n)\n\n\ntype convertFlag interface {\n\tconvertFlag() []string\n}\n\n\ntype ConvertAlign int\n\n\n\ntype convertPmap bool\n\nfunc (c convertPmap) convertFlag() []string { return boolFlag(\"pmap\", bool(c)) }\n\n\n\n\n\n\ntype ConvertSegmentSize string\n\nfunc (c ConvertSegmentSize) convertFlag() []string { return stringFlag(\"segmentSize\", string(c)) }\n\n\n\n\ntype ConvertTasks int\n\nfunc (c ConvertTasks) convertFlag() []string { return intFlag(\"tasks\", int(c)) }\n\nconst (\n\tConvertPmap convertPmap = true\n)\n\n\nfunc Convert(image string, format formatFlag, outfile string, flags ...convertFlag) error {\n\tcmd := exec.Command(hdiutilPath, \"convert\", image)\n\tcmd.Args = append(cmd.Args, format.formatFlag()...)\n\tcmd.Args = append(cmd.Args, outfile)\n\tif len(flags) > 0 {\n\t\tfor _, flag := range flags {\n\t\t\tcmd.Args = append(cmd.Args, flag.convertFlag()...)\n\t\t}\n\t}\n\n\terr := cmd.Run()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c ConvertAlign) convertFlag() []string ", "output": "{ return intFlag(\"align\", int(c)) }"}
{"input": "package io\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/api/v1\"\n\t\"k8s.io/kubernetes/pkg/apimachinery/registered\"\n\t\"k8s.io/kubernetes/pkg/runtime\"\n)\n\n\nfunc LoadPodFromFile(filePath string) (*v1.Pod, error) {\n\tif filePath == \"\" {\n\t\treturn nil, fmt.Errorf(\"file path not specified\")\n\t}\n\tpodDef, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read file path %s: %+v\", filePath, err)\n\t}\n\tif len(podDef) == 0 {\n\t\treturn nil, fmt.Errorf(\"file was empty: %s\", filePath)\n\t}\n\tpod := &v1.Pod{}\n\n\tcodec := api.Codecs.LegacyCodec(registered.GroupOrDie(v1.GroupName).GroupVersion)\n\tif err := runtime.DecodeInto(codec, podDef, pod); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed decoding file: %v\", err)\n\t}\n\treturn pod, nil\n}\n\n\n\n\nfunc SavePodToFile(pod *v1.Pod, filePath string, perm os.FileMode) error ", "output": "{\n\tif filePath == \"\" {\n\t\treturn fmt.Errorf(\"file path not specified\")\n\t}\n\tcodec := api.Codecs.LegacyCodec(registered.GroupOrDie(v1.GroupName).GroupVersion)\n\tdata, err := runtime.Encode(codec, pod)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed encoding pod: %v\", err)\n\t}\n\treturn ioutil.WriteFile(filePath, data, perm)\n}"}
{"input": "package schema\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n\n\t\"github.com/seccom/kpass/src/util\"\n)\n\n\ntype User struct {\n\tID        string    `json:\"id\"`\n\tPass      string    `json:\"pass\"` \n\tAvatar    util.OID  `json:\"avatar\"`\n\tIsBlocked bool      `json:\"isBlocked\"`\n\tCreated   time.Time `json:\"created\"`\n\tUpdated   time.Time `json:\"updated\"`\n}\n\n\nfunc UserFrom(str string) (*User, error) {\n\tuser := new(User)\n\tif err := json.Unmarshal([]byte(str), user); err != nil {\n\t\treturn nil, err\n\t}\n\treturn user, nil\n}\n\n\nfunc (u *User) String() string {\n\treturn jsonMarshal(u)\n}\n\n\n\n\n\ntype UserResult struct {\n\tID      string    `json:\"id\"`\n\tAvatar  string    `json:\"avatar\"`\n\tCreated time.Time `json:\"created\"`\n\tUpdated time.Time `json:\"updated\"`\n}\n\n\nfunc (u *UserResult) String() string {\n\treturn jsonMarshal(u)\n}\n\nfunc (u *User) Result() *UserResult ", "output": "{\n\treturn &UserResult{\n\t\tID:      u.ID,\n\t\tAvatar:  DownloadURL(u.Avatar, \"user\", u.ID, \"\"),\n\t\tCreated: u.Created,\n\t\tUpdated: u.Updated,\n\t}\n}"}
{"input": "package antlr\n\nimport \"fmt\"\n\ntype TraceListener struct {\n\tparser *BaseParser\n}\n\nfunc NewTraceListener(parser *BaseParser) *TraceListener {\n\ttl := new(TraceListener)\n\ttl.parser = parser\n\treturn tl\n}\n\nfunc (t *TraceListener) VisitErrorNode(_ ErrorNode) {\n}\n\nfunc (t *TraceListener) EnterEveryRule(ctx ParserRuleContext) {\n\tfmt.Println(\"enter   \" + t.parser.GetRuleNames()[ctx.GetRuleIndex()] + \", LT(1)=\" + t.parser.input.LT(1).GetText())\n}\n\nfunc (t *TraceListener) VisitTerminal(node TerminalNode) {\n\tfmt.Println(\"consume \" + fmt.Sprint(node.GetSymbol()) + \" rule \" + t.parser.GetRuleNames()[t.parser.ctx.GetRuleIndex()])\n}\n\n\n\nfunc (t *TraceListener) ExitEveryRule(ctx ParserRuleContext) ", "output": "{\n\tfmt.Println(\"exit    \" + t.parser.GetRuleNames()[ctx.GetRuleIndex()] + \", LT(1)=\" + t.parser.input.LT(1).GetText())\n}"}
{"input": "package firebase\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n)\n\n\ntype DataSnapshot struct {\n\tref *Reference\n\traw []byte\n}\n\n\nfunc (snapshot *DataSnapshot) Key() string {\n\tpanic(ErrNotImplemented)\n}\n\n\n\n\n\nfunc (snapshot *DataSnapshot) Exists() bool {\n\treturn bytes.Compare(snapshot.raw, []byte(\"null\")) != 0\n}\n\n\nfunc (snapshot *DataSnapshot) Val(v interface{}) error {\n\treturn json.NewDecoder(bytes.NewReader(snapshot.raw)).Decode(v)\n}\n\n\nfunc (snapshot *DataSnapshot) Bytes() []byte {\n\treturn snapshot.raw\n}\n\n\ntype ChildSnapshot struct {\n\tPrevChildKey string\n}\n\n\ntype OldChildSnapshot struct {\n}\n\nfunc (snapshot *DataSnapshot) Ref() *Reference ", "output": "{\n\treturn snapshot.ref\n}"}
{"input": "package daemon\n\nimport (\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/Microsoft/go-winio\"\n)\n\n\n\nfunc npipeDial(path string, timeout time.Duration) (net.Conn, error) ", "output": "{\n\treturn winio.DialPipe(path, &timeout)\n}"}
{"input": "package eulerlibs\n\nimport \"testing\"\n\n\n\nfunc TestSquareOfSum(t *testing.T) {\n\texpected := 3025\n\tactual := SquareOfSum(10)\n\tif expected != actual {\n\t\tt.Errorf(\"expected:%d - actual:%d\", expected, actual)\n\t}\n}\n\nfunc BenchmarkRunP6(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tRunP6(100)\n\t}\n}\n\nfunc TestSumOfSquares(t *testing.T) ", "output": "{\n\texpected := 385\n\tactual := SumOfSquares(10)\n\tif expected != actual {\n\t\tt.Errorf(\"expected:%d - actual:%d\", expected, actual)\n\t}\n}"}
{"input": "package client\n\nimport (\n\tuserapi \"github.com/openshift/origin/pkg/user/api\"\n\t_ \"github.com/openshift/origin/pkg/user/api/v1beta1\"\n)\n\n\ntype UsersInterface interface {\n\tUsers() UserInterface\n}\n\n\ntype UserInterface interface {\n\tGet(name string) (*userapi.User, error)\n}\n\n\ntype users struct {\n\tr *Client\n}\n\n\n\n\n\nfunc (c *users) Get(name string) (result *userapi.User, err error) {\n\tresult = &userapi.User{}\n\terr = c.r.Get().Resource(\"users\").Name(name).Do().Into(result)\n\treturn\n}\n\nfunc newUsers(c *Client) *users ", "output": "{\n\treturn &users{\n\t\tr: c,\n\t}\n}"}
{"input": "package iso20022\n\n\ntype CorporateActionElection1 struct {\n\n\tOptionType *CorporateActionOption1FormatChoice `xml:\"OptnTp\"`\n\n\tOptionNumber *Exact3NumericText `xml:\"OptnNb\"`\n\n\tOriginalInstructedQuantity *UnitOrFaceAmount1Choice `xml:\"OrgnlInstdQty\"`\n\n\tRemainingQuantity *UnitOrFaceAmount1Choice `xml:\"RmngQty\"`\n}\n\nfunc (c *CorporateActionElection1) AddOptionType() *CorporateActionOption1FormatChoice {\n\tc.OptionType = new(CorporateActionOption1FormatChoice)\n\treturn c.OptionType\n}\n\nfunc (c *CorporateActionElection1) SetOptionNumber(value string) {\n\tc.OptionNumber = (*Exact3NumericText)(&value)\n}\n\n\n\nfunc (c *CorporateActionElection1) AddRemainingQuantity() *UnitOrFaceAmount1Choice {\n\tc.RemainingQuantity = new(UnitOrFaceAmount1Choice)\n\treturn c.RemainingQuantity\n}\n\nfunc (c *CorporateActionElection1) AddOriginalInstructedQuantity() *UnitOrFaceAmount1Choice ", "output": "{\n\tc.OriginalInstructedQuantity = new(UnitOrFaceAmount1Choice)\n\treturn c.OriginalInstructedQuantity\n}"}
{"input": "package render\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\t\"github.com/pkg/errors\"\n)\n\nvar pbContentType = []string{\"application/x-protobuf\"}\n\n\nfunc (r PB) Render(w http.ResponseWriter) error {\n\tif r.TTL <= 0 {\n\t\tr.TTL = 1\n\t}\n\treturn writePB(w, r)\n}\n\n\nfunc (r PB) WriteContentType(w http.ResponseWriter) {\n\twriteContentType(w, pbContentType)\n}\n\n\n\nfunc writePB(w http.ResponseWriter, obj PB) (err error) ", "output": "{\n\tvar pbBytes []byte\n\twriteContentType(w, pbContentType)\n\n\tif pbBytes, err = proto.Marshal(&obj); err != nil {\n\t\terr = errors.WithStack(err)\n\t\treturn\n\t}\n\n\tif _, err = w.Write(pbBytes); err != nil {\n\t\terr = errors.WithStack(err)\n\t}\n\treturn\n}"}
{"input": "package atomic\n\nimport (\n\t\"sync/atomic\"\n)\n\n\ntype Value int64\n\n\nfunc (v *Value) Inc() {\n\tv.Add(1)\n}\n\n\nfunc (v *Value) Dec() {\n\tv.Add(-1)\n}\n\n\nfunc (v *Value) Add(delta int64) {\n\tatomic.AddInt64((*int64)(v), delta)\n}\n\n\nfunc (v *Value) Sub(delta int64) {\n\tv.Add(-delta)\n}\n\n\nfunc (v *Value) Set(value int64) {\n\tatomic.StoreInt64((*int64)(v), value)\n}\n\n\n\n\nfunc (v *Value) Get() int64 ", "output": "{\n\treturn atomic.LoadInt64((*int64)(v))\n}"}
{"input": "package accounts\n\nimport (\n\t\"testing\"\n\n\tos \"github.com/rackspace/gophercloud/openstack/objectstorage/v1/accounts\"\n\tth \"github.com/rackspace/gophercloud/testhelper\"\n\tfake \"github.com/rackspace/gophercloud/testhelper/client\"\n)\n\nfunc TestUpdateAccounts(t *testing.T) {\n\tth.SetupHTTP()\n\tdefer th.TeardownHTTP()\n\n\tos.HandleUpdateAccountSuccessfully(t)\n\n\toptions := &UpdateOpts{Metadata: map[string]string{\"gophercloud-test\": \"accounts\"}}\n\tres := Update(fake.ServiceClient(), options)\n\tth.CheckNoErr(t, res.Err)\n}\n\n\n\nfunc TestGetAccounts(t *testing.T) ", "output": "{\n\tth.SetupHTTP()\n\tdefer th.TeardownHTTP()\n\n\tos.HandleGetAccountSuccessfully(t)\n\n\texpected := map[string]string{\"Foo\": \"bar\"}\n\tactual, err := Get(fake.ServiceClient()).ExtractMetadata()\n\tth.CheckNoErr(t, err)\n\tth.CheckDeepEquals(t, expected, actual)\n}"}
{"input": "package log\n\nimport (\n\t\"github.com/sirupsen/logrus\"\n)\n\ntype LogLevel uint32\n\nconst (\n\tPanicLevel LogLevel = iota\n\tFatalLevel\n\tErrorLevel\n\tWarnLevel\n\tInfoLevel\n\tDebugLevel\n\tTraceLevel\n)\n\ntype Fields map[string]interface{}\n\ntype Logger interface {\n\tPanic(msg string, fields Fields)\n\tFatal(msg string, fields Fields)\n\tError(msg string, fields Fields)\n\tWarn(msg string, fields Fields)\n\tInfo(msg string, fields Fields)\n\tDebug(msg string, fields Fields)\n\tSetLevel(level LogLevel)\n\tGetLevel() LogLevel\n}\n\ntype DefaultLogger struct {\n\tlogger *logrus.Logger\n}\n\nfunc (l *DefaultLogger) Panic(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Panic(msg)\n}\n\n\n\nfunc (l *DefaultLogger) Error(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Error(msg)\n}\n\nfunc (l *DefaultLogger) Warn(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Warn(msg)\n}\n\nfunc (l *DefaultLogger) Info(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Info(msg)\n}\n\nfunc (l *DefaultLogger) Debug(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Debug(msg)\n}\n\nfunc (l *DefaultLogger) SetLevel(level LogLevel) {\n\tl.logger.SetLevel(logrus.Level(level))\n}\n\nfunc (l *DefaultLogger) GetLevel() LogLevel {\n\treturn LogLevel(l.logger.GetLevel())\n}\n\nfunc NewDefaultLogger() *DefaultLogger {\n\treturn &DefaultLogger{\n\t\tlogger: logrus.New(),\n\t}\n}\n\nfunc (l *DefaultLogger) Fatal(msg string, fields Fields) ", "output": "{\n\tl.logger.WithFields(logrus.Fields(fields)).Fatal(msg)\n}"}
{"input": "package main\n \nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n \nfunc main() {\n \n    slice := generateSlice(20)\n    fmt.Println(\"\\n--- Unsorted --- \\n\\n\", slice)\n    quicksort(slice)\n    fmt.Println(\"\\n--- Sorted ---\\n\\n\", slice, \"\\n\")\n}\n \n\n\n  \nfunc quicksort(a []int) []int {\n    if len(a) < 2 {\n        return a\n    }\n      \n    left, right := 0, len(a)-1\n      \n    pivot := rand.Int() % len(a)\n      \n    a[pivot], a[right] = a[right], a[pivot]\n      \n    for i, _ := range a {\n        if a[i] < a[right] {\n            a[left], a[i] = a[i], a[left]\n            left++\n        }\n    }\n      \n    a[left], a[right] = a[right], a[left]\n      \n    quicksort(a[:left])\n    quicksort(a[left+1:])\n      \n    return a\n}\n\nfunc generateSlice(size int) []int ", "output": "{\n \n    slice := make([]int, size, size)\n    rand.Seed(time.Now().UnixNano())\n    for i := 0; i < size; i++ {\n        slice[i] = rand.Intn(999) - rand.Intn(999)\n    }\n    return slice\n}"}
{"input": "package geoMath\n\nimport (\n  \"github.com/helmutkemper/mgo/bson\"\n  \"github.com/helmutkemper/db\"\n)\n\ntype RelationErrorStt struct {\n  IdMongo                               bson.ObjectId       `bson:\"_id,omitempty\"`\n  IdParser                              bson.ObjectId       `bson:\"IdParser,omitempty\"`\n  \n  Id                                    int64\n  IdSearched                            int64\n  DbCollectionName                      string              `bson:\"dbCollectionName\" json:\"-\"`\n  *db.DbStt                                                 `bson:\"-\"`             \n}\n\nfunc ( RelationErrorAStt *RelationErrorStt ) SetDbCollectionName( nameAStr string ){ RelationErrorAStt.DbCollectionName = nameAStr }\n\n\n\nfunc ( RelationErrorAStt *RelationErrorStt ) FindOne( queryAObj bson.M ) error {\n  err := RelationErrorAStt.DbStt.TestConnection()\n  if err != nil {\n    return err\n  }\n\n  return RelationErrorAStt.DbStt.FindOne( RelationErrorAStt.DbCollectionName, &RelationErrorAStt, queryAObj )\n}\n\nfunc ( RelationErrorAStt *RelationErrorStt ) RemoveAll( queryAObj bson.M ) error {\n  err := RelationErrorAStt.DbStt.TestConnection()\n  if err != nil {\n    return err\n  }\n\n  _, ret := RelationErrorAStt.DbStt.RemoveAll( RelationErrorAStt.DbCollectionName, queryAObj )\n  return ret\n}\n\nfunc ( RelationErrorAStt *RelationErrorStt ) Insert() error ", "output": "{\n  var err error\n\n  err = RelationErrorAStt.DbStt.TestConnection()\n  if err != nil{\n    return err\n  }\n\n  RelationErrorAStt.IdMongo, err = RelationErrorAStt.DbStt.GetMongoId()\n  if err != nil{\n    return err\n  }\n\n  if RelationErrorAStt.DbStt.HasIndex( RelationErrorAStt.DbCollectionName, \"id\" ) != true {\n    RelationErrorAStt.DbStt.IndexKeyMake ( RelationErrorAStt.DbCollectionName, \"id\" )\n  }\n\n  if RelationErrorAStt.DbStt.HasIndex( RelationErrorAStt.DbCollectionName, \"idSearched\" ) != true {\n    RelationErrorAStt.DbStt.IndexKeyMake ( RelationErrorAStt.DbCollectionName, \"idSearched\" )\n  }\n\n  return RelationErrorAStt.DbStt.Insert( RelationErrorAStt.DbCollectionName, RelationErrorAStt )\n}"}
{"input": "package seqnum\n\n\ntype Value uint32\n\n\ntype Size uint32\n\n\nfunc (v Value) LessThan(w Value) bool {\n\treturn int32(v-w) < 0\n}\n\n\n\n\n\nfunc (v Value) InRange(a, b Value) bool {\n\treturn v-a < b-a\n}\n\n\n\nfunc (v Value) InWindow(first Value, size Size) bool {\n\treturn v.InRange(first, first.Add(size))\n}\n\n\nfunc Overlap(a Value, b Size, x Value, y Size) bool {\n\treturn a.LessThan(x.Add(y)) && x.LessThan(a.Add(b))\n}\n\n\nfunc (v Value) Add(s Size) Value {\n\treturn v + Value(s)\n}\n\n\nfunc (v Value) Size(w Value) Size {\n\treturn Size(w - v)\n}\n\n\nfunc (v *Value) UpdateForward(s Size) {\n\t*v += Value(s)\n}\n\nfunc (v Value) LessThanEq(w Value) bool ", "output": "{\n\tif v == w {\n\t\treturn true\n\t}\n\treturn v.LessThan(w)\n}"}
{"input": "package integrations\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestRenderFileSVGIsInImgTag(t *testing.T) ", "output": "{\n\tdefer prepareTestEnv(t)()\n\n\tsession := loginUser(t, \"user2\")\n\n\treq := NewRequest(t, \"GET\", \"/user2/repo2/src/branch/master/line.svg\")\n\tresp := session.MakeRequest(t, req, http.StatusOK)\n\n\tdoc := NewHTMLParser(t, resp.Body)\n\tsrc, exists := doc.doc.Find(\".file-view img\").Attr(\"src\")\n\tassert.True(t, exists, \"The SVG image should be in an <img> tag so that scripts in the SVG are not run\")\n\tassert.Equal(t, \"/user2/repo2/raw/branch/master/line.svg\", src)\n}"}
{"input": "package dns\n\nimport (\n\t\"github.com/cilium/cilium/pkg/hubble/metrics/api\"\n)\n\ntype dnsPlugin struct{}\n\nfunc (p *dnsPlugin) NewHandler() api.Handler {\n\treturn &dnsHandler{}\n}\n\n\n\nfunc init() {\n\tapi.DefaultRegistry().Register(\"dns\", &dnsPlugin{})\n}\n\nfunc (p *dnsPlugin) HelpText() string ", "output": "{\n\treturn `dns - DNS related metrics\nReports metrics related to DNS queries and responses\n\nMetrics:\n  hubble_dns_queries_total    Number of observed TCP queries\n  hubble_dns_responses_total  Number of observed TCP responses\n\nOptions:\n query                  - Include query name as label\n ignoreAAAA             - Do not include AAAA query & responses in metrics` +\n\t\tapi.ContextOptionsHelp\n}"}
{"input": "package models\n\nimport (\n\t\"fmt\"\n\n\t\"google.golang.org/protobuf/reflect/protoreflect\"\n\t\"google.golang.org/protobuf/types/known/fieldmaskpb\"\n)\n\n\nfunc ValidateMask(message protoreflect.ProtoMessage, mask *fieldmaskpb.FieldMask) error {\n\tif mask == nil {\n\t\treturn nil\n\t}\n\n\tif len(mask.GetPaths()) == 1 && mask.Paths[0] == \"*\" {\n\t\treturn nil\n\t}\n\n\tunknowns := make([]string, 0)\n\tfor _, field := range mask.GetPaths() {\n\t\tif _, err := fieldmaskpb.New(message, field); err != nil {\n\t\t\tunknowns = append(unknowns, field)\n\t\t}\n\t}\n\n\tif len(unknowns) > 0 {\n\t\treturn fmt.Errorf(\"unrecognized fields %v\", unknowns)\n\t}\n\n\treturn nil\n}\n\n\n\n\n\n\nfunc populatedFields(m protoreflect.ProtoMessage) *fieldmaskpb.FieldMask {\n\tmask, _ := fieldmaskpb.New(m)\n\n\tm.ProtoReflect().Range(func(field protoreflect.FieldDescriptor, _ protoreflect.Value) bool {\n\t\t_ = mask.Append(m, string(field.Name()))\n\t\treturn true \n\t})\n\n\treturn mask\n}\n\nfunc allFields(m protoreflect.ProtoMessage) *fieldmaskpb.FieldMask {\n\tmask, _ := fieldmaskpb.New(m)\n\n\tfields := m.ProtoReflect().Descriptor().Fields()\n\tfor i := 0; i < fields.Len(); i++ {\n\t\t_ = mask.Append(m, string(fields.Get(i).Name()))\n\t}\n\n\treturn mask\n}\n\nfunc ExpandMask(m protoreflect.ProtoMessage, mask *fieldmaskpb.FieldMask) *fieldmaskpb.FieldMask ", "output": "{\n\tif mask == nil || len(mask.GetPaths()) == 0 {\n\t\treturn populatedFields(m)\n\t} else if len(mask.GetPaths()) == 1 && mask.Paths[0] == \"*\" {\n\t\treturn allFields(m)\n\t}\n\n\tmask.Normalize()\n\treturn mask\n}"}
{"input": "package brackets\n\nimport \"strings\"\n\nconst testVersion = 3\n\nvar openCloseMappings = map[rune]rune{\n\t'{': '}',\n\t'[': ']',\n\t'(': ')',\n}\n\ntype Stack []rune\n\nfunc (s *Stack) Put(r rune) {\n\t*s = append((*s), r)\n}\n\nfunc (s *Stack) Clear() {\n\t*s = Stack{}\n}\n\nfunc (s *Stack) Pop() rune {\n\tif len(*s) == 0 {\n\t\treturn 0\n\t}\n\n\td := (*s)[len(*s)-1]\n\t(*s) = (*s)[:len(*s)-1]\n\treturn d\n}\n\nfunc (s Stack) Empty() bool {\n\treturn len(s) == 0\n}\n\ntype BracketType int\n\nconst (\n\tOpen BracketType = iota\n\tClose\n\tInvalid\n)\n\n\n\nfunc getBracketType(r rune) BracketType {\n\tcloseBrackets := \"}])\"\n\topenBrackets := \"{[(\"\n\n\tif strings.ContainsRune(closeBrackets, r) {\n\t\treturn Close\n\t} else if strings.ContainsRune(openBrackets, r) {\n\t\treturn Open\n\t}\n\n\treturn Invalid\n}\n\nfunc Bracket(input string) (bool, error) ", "output": "{\n\tvar stack Stack\n\tvar popping bool\n\n\tfor _, r := range input {\n\t\tswitch getBracketType(r) {\n\t\tcase Close:\n\t\t\tpopping = true\n\t\tcase Open:\n\t\t\tpopping = false\n\t\t\tstack.Put(r)\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\n\t\tif popping {\n\t\t\tpoppedRune := stack.Pop()\n\t\t\texpected, ok := openCloseMappings[poppedRune]\n\n\t\t\tif !ok || expected != r {\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tif stack.Empty() {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}"}
{"input": "package remove_duplicates_from_sorted_array\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc TestRemoveDuplicates(t *testing.T) ", "output": "{\n\tnums := []int{1, 2, 3, 3, 5, 7, 7, 7, 11, 15}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{1, 1, 2}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{1}\n\tfmt.Println(removeDuplicates(nums), nums)\n\n\tnums = []int{}\n\tfmt.Println(removeDuplicates(nums), nums)\n}"}
{"input": "package events\n\nimport \"github.com/gophercloud/gophercloud\"\n\nvar apiVersion = \"v1\"\nvar apiName = \"events\"\n\nfunc commonURL(client *gophercloud.ServiceClient) string {\n\treturn client.ServiceURL(apiVersion, apiName)\n}\n\nfunc listURL(client *gophercloud.ServiceClient) string {\n\treturn commonURL(client)\n}\n\nfunc idURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(apiVersion, apiName, id)\n}\n\n\n\nfunc getURL(client *gophercloud.ServiceClient, id string) string ", "output": "{\n\treturn idURL(client, id)\n}"}
{"input": "package aesample\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/mzimmerman/aesample/subpkga\"\n\t\"github.com/mzimmerman/aesample/util\"\n)\n\nfunc init() {\n\thttp.HandleFunc(\"/\", root)\n\thttp.HandleFunc(\"/subpkga\", subpkga.Root)\n\tutil.Log(\"aesample init()\")\n}\n\n\n\nfunc root(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tfmt.Fprint(w, \"Hello, you've reached aesample, the root package does nothing\")\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n\n\nfunc swap(x *int, y *int) {\n\tvar temp int\n\ttemp = *x;\n\t*x = *y\n\t*y = temp\n}\n\nfunc getSequence() func() int {\n\tvar i int = 0;\n\treturn func() int {\n\t\ti++;\n\t\treturn i\n\t}\n}\n\ntype Circle struct {\n\tx, y, radius float64\n}\n\nfunc(circle Circle) area() float64 {\n\treturn math.Pi * circle.radius * circle.radius \n}\n\nfunc main() {\n\tvar  a, b int = 2, 3;\n\tfmt.Printf(\"max value is %d\\n\", max(a,b));\n\n\tfmt.Printf(\"a = %d, b = %d\\n\", a, b);\n\tswap(&a, &b);\n\tfmt.Printf(\"a = %d, b = %d\\n\", a, b);\n\n\txxx := swap\n\txxx(&a, &b)\n\tfmt.Printf(\"a = %d, b = %d\\n\", a, b);\n\n\tnumber := getSequence()\n\tfmt.Printf(\"number is %d\\n\", number())\n\tfmt.Printf(\"number is %d\\n\", number())\n\tfmt.Printf(\"number is %d\\n\", number())\n\tfmt.Printf(\"number is %d\\n\", number())\n\tnumber1 := getSequence()\n\tfmt.Printf(\"number1 is %d\\n\", number1())\n\tfmt.Printf(\"number1 is %d\\n\", number1())\n\tfmt.Printf(\"number1 is %d\\n\", number1())\n\tfmt.Printf(\"number1 is %d\\n\", number1())\n\n\tcircle := Circle{x:0, y:0, radius:5}\n\tfmt.Printf(\"Circle area: %f\\n\", circle.area())\n\n}\n\nfunc max(x int, y int) int ", "output": "{\n\tif (x > y) {\n\t\treturn x\n\t} else {\n\t\treturn y\n\t}\n}"}
{"input": "package versioned\n\nimport (\n\t\"strconv\"\n)\n\n\ntype Version int64\n\n\n\n\nfunc ParseVersion(s string) Version {\n\ti, _ := strconv.ParseInt(s, 10, 64)\n\treturn Version(i)\n}\n\n\ntype Object struct {\n\tData interface{}\n\tVersion Version\n}\n\n\n\n\n\n\n\nfunc (o *Object) CompareVersion(other Object) int64 ", "output": "{\n\treturn int64(o.Version) - int64(other.Version)\n}"}
{"input": "package articler\n\ntype DB interface {\n\tVisited(string) bool\n\tVisit(string) error\n\n\tSave(*Article) error\n\tGet(url string) (*Article, error)\n\tGetAll() []*Article\n}\n\ntype MemoryDb struct {\n\turls map[string]struct{}\n}\n\n\nfunc (db *MemoryDb) Visit(u string) error {\n\tif db.urls == nil {\n\t\tdb.urls = map[string]struct{}{}\n\t}\n\tdb.urls[u] = struct{}{}\n\treturn nil\n}\n\nfunc (db *MemoryDb) Visited(u string) bool ", "output": "{\n\tif _, ok := db.urls[u]; ok {\n\t\treturn true\n\t}\n\treturn false\n}"}
{"input": "package twitch\n\ntype IngestsS struct {\n\tIngests []IngestS `json:\"ingests,omitempty\"`\n}\n\ntype IngestS struct {\n\tName         string  `json:\"name,omitempty\"`\n\tDefault      bool    `json:\"default,omitempty\"`\n\tId           int     `json:\"_id,omitempty\"`\n\tUrlTemplate  string  `json:\"url_template,omitempty\"`\n\tAvailability float64 `json:\"availability,omitempty\"`\n}\n\ntype IngestsMethod struct {\n\tclient *Client\n}\n\n\n\nfunc (i *IngestsMethod) List() (*IngestsS, error) ", "output": "{\n\trel := \"ingests\"\n\n\tingests := new(IngestsS)\n\t_, err := i.client.Get(rel, ingests)\n\treturn ingests, err\n}"}
{"input": "package commands\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/juju/cmd\"\n\t\"github.com/juju/utils/ssh\"\n\t\"launchpad.net/gnuflag\"\n\n\t\"github.com/juju/juju/cmd/modelcmd\"\n)\n\n\nfunc NewListKeysCommand() cmd.Command {\n\treturn modelcmd.Wrap(&listKeysCommand{})\n}\n\nvar listKeysDoc = `\nList the authorized ssh keys in the model, allowing the holders of those keys to log on to Juju nodes.\nBy default, just the key fingerprint is printed. Use --full to display the entire key.\n\n`\n\n\ntype listKeysCommand struct {\n\tSSHKeysBase\n\tshowFullKey bool\n\tuser        string\n}\n\n\n\n\n\nfunc (c *listKeysCommand) SetFlags(f *gnuflag.FlagSet) {\n\tf.BoolVar(&c.showFullKey, \"full\", false, \"show full key instead of just the key fingerprint\")\n}\n\n\nfunc (c *listKeysCommand) Run(context *cmd.Context) error {\n\tclient, err := c.NewKeyManagerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer client.Close()\n\n\tmode := ssh.Fingerprints\n\tif c.showFullKey {\n\t\tmode = ssh.FullKeys\n\t}\n\tc.user = \"admin\"\n\tresults, err := client.ListKeys(mode, c.user)\n\tif err != nil {\n\t\treturn err\n\t}\n\tresult := results[0]\n\tif result.Error != nil {\n\t\treturn result.Error\n\t}\n\tfmt.Fprintf(context.Stdout, \"Keys used in model: %s\\n\", c.ConnectionName())\n\tfmt.Fprintln(context.Stdout, strings.Join(result.Result, \"\\n\"))\n\treturn nil\n}\n\nfunc (c *listKeysCommand) Info() *cmd.Info ", "output": "{\n\treturn &cmd.Info{\n\t\tName:    \"list-ssh-keys\",\n\t\tDoc:     listKeysDoc,\n\t\tPurpose: \"list authorised ssh keys in a model\",\n\t\tAliases: []string{\"ssh-key\", \"ssh-keys\", \"list-ssh-key\"},\n\t}\n}"}
{"input": "package expression\n\nimport \"gopkg.in/sqle/sqle.v0/sql\"\n\ntype UnresolvedColumn struct {\n\tname string\n}\n\nfunc NewUnresolvedColumn(name string) *UnresolvedColumn {\n\treturn &UnresolvedColumn{name}\n}\n\nfunc (UnresolvedColumn) Resolved() bool {\n\treturn false\n}\n\n\n\nfunc (UnresolvedColumn) Type() sql.Type {\n\treturn sql.String \n}\n\nfunc (c UnresolvedColumn) Name() string {\n\treturn c.name\n}\n\nfunc (UnresolvedColumn) Eval(r sql.Row) interface{} {\n\treturn \"FAIL\" \n}\n\nfunc (p *UnresolvedColumn) TransformUp(f func(sql.Expression) sql.Expression) sql.Expression {\n\tn := *p\n\treturn f(&n)\n}\n\ntype UnresolvedFunction struct {\n\tname        string\n\tIsAggregate bool\n\tChildren    []sql.Expression\n}\n\nfunc NewUnresolvedFunction(name string, agg bool,\n\tchildren ...sql.Expression) *UnresolvedFunction {\n\treturn &UnresolvedFunction{name, agg, children}\n}\n\nfunc (UnresolvedFunction) Resolved() bool {\n\treturn false\n}\n\nfunc (UnresolvedFunction) IsNullable() bool {\n\treturn true\n}\n\nfunc (UnresolvedFunction) Type() sql.Type {\n\treturn sql.String \n}\n\nfunc (c UnresolvedFunction) Name() string {\n\treturn c.name\n}\n\nfunc (UnresolvedFunction) Eval(r sql.Row) interface{} {\n\treturn \"FAIL\" \n}\n\nfunc (p *UnresolvedFunction) TransformUp(f func(sql.Expression) sql.Expression) sql.Expression {\n\tvar rc []sql.Expression\n\tfor _, c := range p.Children {\n\t\trc = append(rc, f(c))\n\t}\n\n\treturn f(NewUnresolvedFunction(p.name, p.IsAggregate, rc...))\n}\n\nfunc (UnresolvedColumn) IsNullable() bool ", "output": "{\n\treturn true\n}"}
{"input": "package unversioned\n\nimport (\n\tapi \"k8s.io/kubernetes/pkg/api\"\n\tregistered \"k8s.io/kubernetes/pkg/apimachinery/registered\"\n\trestclient \"k8s.io/kubernetes/pkg/client/restclient\"\n)\n\ntype AuthorizationInterface interface {\n\tGetRESTClient() *restclient.RESTClient\n\tSubjectAccessReviewsGetter\n}\n\n\ntype AuthorizationClient struct {\n\t*restclient.RESTClient\n}\n\nfunc (c *AuthorizationClient) SubjectAccessReviews() SubjectAccessReviewInterface {\n\treturn newSubjectAccessReviews(c)\n}\n\n\nfunc NewForConfig(c *restclient.Config) (*AuthorizationClient, error) {\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := restclient.RESTClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &AuthorizationClient{client}, nil\n}\n\n\n\nfunc NewForConfigOrDie(c *restclient.Config) *AuthorizationClient {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n\n\nfunc New(c *restclient.RESTClient) *AuthorizationClient {\n\treturn &AuthorizationClient{c}\n}\n\n\n\n\n\nfunc (c *AuthorizationClient) GetRESTClient() *restclient.RESTClient {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.RESTClient\n}\n\nfunc setConfigDefaults(config *restclient.Config) error ", "output": "{\n\tg, err := registered.Group(\"authorization.k8s.io\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tconfig.APIPath = \"/apis\"\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = restclient.DefaultKubernetesUserAgent()\n\t}\n\tcopyGroupVersion := g.GroupVersion\n\tconfig.GroupVersion = &copyGroupVersion\n\n\tconfig.NegotiatedSerializer = api.Codecs\n\n\tif config.QPS == 0 {\n\t\tconfig.QPS = 5\n\t}\n\tif config.Burst == 0 {\n\t\tconfig.Burst = 10\n\t}\n\treturn nil\n}"}
{"input": "package helpers\n\nimport (\n\t\"github.com/btcsuite/btcd/wire\"\n\t\"github.com/btcsuite/btcutil\"\n)\n\n\nfunc SumOutputValues(outputs []*wire.TxOut) (totalOutput btcutil.Amount) {\n\tfor _, txOut := range outputs {\n\t\ttotalOutput += btcutil.Amount(txOut.Value)\n\t}\n\treturn totalOutput\n}\n\n\n\n\nfunc SumOutputSerializeSizes(outputs []*wire.TxOut) (serializeSize int) ", "output": "{\n\tfor _, txOut := range outputs {\n\t\tserializeSize += txOut.SerializeSize()\n\t}\n\treturn serializeSize\n}"}
{"input": "package hostqueue\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\t\"regexp\"\n\n\t\"appengine\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype Status struct {\n\tName  string `json:\"name\"`\n\tHosts []Host `json:\"hosts\"`\n\tNext  int    `json:\"next\"`\n}\n\n\n\n\nfunc convertToStatus(group Group) Status {\n\treturn Status{\n\t\tName: group.GroupName,\n\t\tNext: group.Next,\n\t\tHosts: group.Hosts,\n\t\t}\n}\n\nfunc isValidUUID(text string) bool {\n\tr := regexp.MustCompile(\"^[a-z0-9]{8}-[a-z0-9]{4}-[1-5][a-z0-9]{3}-[a-z0-9]{4}-[a-z0-9]{12}$\")\n\treturn r.MatchString(text)\n}\n\nfunc DisplayGroupStatus(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tctx := appengine.NewContext(r)\n\tpathVars := mux.Vars(r)\n\n\tuuid := pathVars[\"uuid\"]\n\tctx.Infof(\"UUID: %s\", uuid)\n\n\tif isValidUUID((uuid)) {\n\t\tgroup, err := GetGroupByUUID(ctx, uuid)\n\t\tctx.Infof(\"group: %v\", group)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tstatus := convertToStatus(group)\n\t\tw.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\")\n\n\t\tvar tpl = template.Must(template.ParseGlob(\"templates/*.html\"))\n\t\tif err := tpl.ExecuteTemplate(w, \"status.html\", status); err != nil {\n\t\t\tctx.Infof(\"%v\", err)\n\t\t}\n\n\t} else {\n\t\tw.Write([]byte(\"Invalid group\"))\n\t}\n}"}
{"input": "package RowBinary\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"testing\"\n)\n\n\n\nfunc BenchmarkReadFileReverse(b *testing.B) {\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tr, err := NewReader(\"testdata/default.1559465733030407809\", true)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tn, err := io.Copy(ioutil.Discard, r)\n\t\tif err != nil || n != 20037 {\n\t\t\tb.Fatal()\n\t\t}\n\t}\n}\n\nfunc BenchmarkReadFileDirect(b *testing.B) ", "output": "{\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tr, err := NewReader(\"testdata/default.1559465733030407809\", false)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tn, err := io.Copy(ioutil.Discard, r)\n\t\tif err != nil || n != 20037 {\n\t\t\tb.Fatal()\n\t\t}\n\t}\n}"}
{"input": "package sieve\n\n\n\nfunc Sieve(limit int) (primes []int) ", "output": "{\n\tc := make([]bool, limit)\n\tfor p := 2; p < limit; {\n\t\tfor i := p + p; i < limit; i += p {\n\t\t\tc[i] = true\n\t\t}\n\t\tfor p++; p < limit && c[p]; p++ {\n\t\t}\n\t}\n\tfor i := 2; i < limit; i++ {\n\t\tif !c[i] {\n\t\t\tprimes = append(primes, i)\n\t\t}\n\t}\n\treturn\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/swag\"\n)\n\n\n\ntype OpenpitrixCeaseClustersResponse struct {\n\n\tClusterID []string `json:\"cluster_id\"`\n\n\tJobID []string `json:\"job_id\"`\n}\n\n\n\n\nfunc (m *OpenpitrixCeaseClustersResponse) validateClusterID(formats strfmt.Registry) error {\n\n\tif swag.IsZero(m.ClusterID) { \n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\nfunc (m *OpenpitrixCeaseClustersResponse) validateJobID(formats strfmt.Registry) error {\n\n\tif swag.IsZero(m.JobID) { \n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\n\nfunc (m *OpenpitrixCeaseClustersResponse) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\nfunc (m *OpenpitrixCeaseClustersResponse) UnmarshalBinary(b []byte) error {\n\tvar res OpenpitrixCeaseClustersResponse\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *OpenpitrixCeaseClustersResponse) Validate(formats strfmt.Registry) error ", "output": "{\n\tvar res []error\n\n\tif err := m.validateClusterID(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateJobID(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package dockerfile\n\nimport (\n\t\"github.com/docker/go-metrics\"\n)\n\nvar (\n\tbuildsTriggered metrics.Counter\n\tbuildsFailed    metrics.LabeledCounter\n)\n\n\n\nconst (\n\tmetricsDockerfileSyntaxError        = \"dockerfile_syntax_error\"\n\tmetricsDockerfileEmptyError         = \"dockerfile_empty_error\"\n\tmetricsCommandNotSupportedError     = \"command_not_supported_error\"\n\tmetricsErrorProcessingCommandsError = \"error_processing_commands_error\"\n\tmetricsBuildTargetNotReachableError = \"build_target_not_reachable_error\"\n\tmetricsMissingOnbuildArgumentsError = \"missing_onbuild_arguments_error\"\n\tmetricsUnknownInstructionError      = \"unknown_instruction_error\"\n\tmetricsBuildCanceled                = \"build_canceled\"\n)\n\n\n\nfunc init() ", "output": "{\n\tbuildMetrics := metrics.NewNamespace(\"builder\", \"\", nil)\n\n\tbuildsTriggered = buildMetrics.NewCounter(\"builds_triggered\", \"Number of triggered image builds\")\n\tbuildsFailed = buildMetrics.NewLabeledCounter(\"builds_failed\", \"Number of failed image builds\", \"reason\")\n\tfor _, r := range []string{\n\t\tmetricsDockerfileSyntaxError,\n\t\tmetricsDockerfileEmptyError,\n\t\tmetricsCommandNotSupportedError,\n\t\tmetricsErrorProcessingCommandsError,\n\t\tmetricsBuildTargetNotReachableError,\n\t\tmetricsMissingOnbuildArgumentsError,\n\t\tmetricsUnknownInstructionError,\n\t\tmetricsBuildCanceled,\n\t} {\n\t\tbuildsFailed.WithValues(r)\n\t}\n\n\tmetrics.Register(buildMetrics)\n}"}
{"input": "package customerio\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype APIClient struct {\n\tKey       string\n\tURL       string\n\tUserAgent string\n\tClient    *http.Client\n}\n\n\n\nfunc NewAPIClient(key string, opts ...option) *APIClient {\n\tclient := &APIClient{\n\t\tKey:       key,\n\t\tClient:    http.DefaultClient,\n\t\tURL:       \"https://api.customer.io\",\n\t\tUserAgent: DefaultUserAgent,\n\t}\n\n\tfor _, opt := range opts {\n\t\topt.api(client)\n\t}\n\treturn client\n}\n\n\n\nfunc (c *APIClient) doRequest(ctx context.Context, verb, requestPath string, body interface{}) ([]byte, int, error) ", "output": "{\n\tb, err := json.Marshal(body)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\treq, err := http.NewRequest(verb, c.URL+requestPath, bytes.NewBuffer(b))\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\treq = req.WithContext(ctx)\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+c.Key)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Add(\"User-Agent\", c.UserAgent)\n\n\tresp, err := c.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\trespBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\treturn respBody, resp.StatusCode, nil\n}"}
{"input": "package main\n\nimport \"github.com/rwynn/gtm\"\n\n\n\nfunc filterOps(op *gtm.Op) bool ", "output": "{\n\treturn true\n}"}
{"input": "package data\n\nimport \"testing\"\nimport \"github.com/stretchr/testify/assert\"\n\n\n\nfunc TestMap(t *testing.T) ", "output": "{\n\tm := NewMap()\n\tm.Set(\"a\", 1)\n\tassert.Equal(t, m.Int(\"a\"), 1)\n}"}
{"input": "package integration\n\nimport \"github.com/coreos/pkg/capnslog\"\n\n\n\nfunc init() ", "output": "{\n\tcapnslog.SetGlobalLogLevel(capnslog.INFO)\n}"}
{"input": "package queue\n\n\ntype Element interface{}\n\n\ntype Queue []Element\n\n\nfunc NewQueue() Queue {\n\treturn Queue{}\n}\n\n\n\n\n\nfunc (q *Queue) Enqueue(v Element) {\n\t*q = append(*q, v)\n}\n\nfunc (q *Queue) Dequeue() Element ", "output": "{\n\tif len(*q) > 0 {\n\t\tv := (*q)[0]\n\t\t*q = (*q)[1:]\n\t\treturn v\n\t}\n\treturn nil\n}"}
{"input": "package passthrough\n\nimport \"google.golang.org/grpc/resolver\"\n\nconst scheme = \"passthrough\"\n\ntype passthroughBuilder struct{}\n\nfunc (*passthroughBuilder) Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOption) (resolver.Resolver, error) {\n\tr := &passthroughResolver{\n\t\ttarget: target,\n\t\tcc:     cc,\n\t}\n\tr.start()\n\treturn r, nil\n}\n\n\n\ntype passthroughResolver struct {\n\ttarget resolver.Target\n\tcc     resolver.ClientConn\n}\n\nfunc (r *passthroughResolver) start() {\n\tr.cc.NewAddress([]resolver.Address{{Addr: r.target.Endpoint}})\n}\n\nfunc (*passthroughResolver) ResolveNow(o resolver.ResolveNowOption) {}\n\nfunc (*passthroughResolver) Close() {}\n\nfunc init() {\n\tresolver.Register(&passthroughBuilder{})\n}\n\nfunc (*passthroughBuilder) Scheme() string ", "output": "{\n\treturn scheme\n}"}
{"input": "package collector\n\nimport (\n\t\"fullerite/metric\"\n\t\"math/rand\"\n)\n\n\ntype Test struct {\n\tinterval int\n\tchannel  chan metric.Metric\n}\n\n\nfunc NewTest() *Test {\n\tt := new(Test)\n\tt.channel = make(chan metric.Metric)\n\treturn t\n}\n\n\nfunc (t Test) Collect() {\n\tmetric := metric.New(\"TestMetric\")\n\tmetric.Value = rand.Float64()\n\tmetric.AddDimension(\"testing\", \"yes\")\n\tt.Channel() <- metric\n}\n\n\nfunc (t Test) Name() string {\n\treturn \"Test\"\n}\n\n\nfunc (t Test) Interval() int {\n\treturn t.interval\n}\n\n\n\n\n\n\nfunc (t Test) String() string {\n\treturn t.Name() + \"Collector\"\n}\n\n\nfunc (t *Test) SetInterval(interval int) {\n\tt.interval = interval\n}\n\nfunc (t Test) Channel() chan metric.Metric ", "output": "{\n\treturn t.channel\n}"}
{"input": "package expvar\n\nimport (\n\t\"expvar\"\n\t\"runtime\"\n\t\"sync\"\n\n\t\"github.com/mholt/caddy\"\n\t\"github.com/mholt/caddy/caddyhttp/httpserver\"\n)\n\nfunc init() {\n\tcaddy.RegisterPlugin(\"expvar\", caddy.Plugin{\n\t\tServerType: \"http\",\n\t\tAction:     setup,\n\t})\n}\n\n\nfunc setup(c *caddy.Controller) error {\n\tresource, err := expVarParse(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpublishExtraVars()\n\n\tev := ExpVar{Resource: resource}\n\n\thttpserver.GetConfig(c).AddMiddleware(func(next httpserver.Handler) httpserver.Handler {\n\t\tev.Next = next\n\t\treturn ev\n\t})\n\n\treturn nil\n}\n\nfunc expVarParse(c *caddy.Controller) (Resource, error) {\n\tvar resource Resource\n\tvar err error\n\n\tfor c.Next() {\n\t\targs := c.RemainingArgs()\n\t\tswitch len(args) {\n\t\tcase 0:\n\t\t\tresource = Resource(defaultExpvarPath)\n\t\tcase 1:\n\t\t\tresource = Resource(args[0])\n\t\tdefault:\n\t\t\treturn resource, c.ArgErr()\n\t\t}\n\t}\n\n\treturn resource, err\n}\n\n\n\nvar publishOnce sync.Once \nvar defaultExpvarPath = \"/debug/vars\"\n\nfunc publishExtraVars() ", "output": "{\n\tpublishOnce.Do(func() {\n\t\texpvar.Publish(\"Goroutines\", expvar.Func(func() interface{} {\n\t\t\treturn runtime.NumGoroutine()\n\t\t}))\n\t})\n}"}
{"input": "package match\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\n\nfunc Match(t *testing.T, value interface{}) *Matcher {\n\treturn &Matcher{\n\t\tt:     t,\n\t\tvalue: value,\n\t}\n}\n\n\nfunc IsNil(t *testing.T, value interface{}) *Matcher {\n\treturn Match(t, value).IsNil()\n}\n\n\nfunc IsNotNil(t *testing.T, value interface{}) *Matcher {\n\treturn Match(t, value).IsNotNil()\n}\n\n\nfunc Equals(t *testing.T, value, other interface{}) *Matcher {\n\treturn Match(t, value).Equals(other)\n}\n\n\nfunc NotEquals(t *testing.T, value, other interface{}) *Matcher {\n\treturn Match(t, value).NotEquals(other)\n}\n\n\nfunc LessThan(t *testing.T, value, other interface{}) *Matcher {\n\treturn Match(t, value).LessThan(other)\n}\n\n\nfunc GreaterThan(t *testing.T, value, other interface{}) *Matcher {\n\treturn Match(t, value).GreaterThan(other)\n}\n\n\n\n\n\nfunc Matches(t *testing.T, value interface{}, pattern string) *Matcher {\n\treturn Match(t, value).Matches(pattern)\n}\n\n\nfunc KindOf(t *testing.T, value interface{}, kind reflect.Kind) *Matcher {\n\treturn Match(t, value).KindOf(kind)\n}\n\nfunc Contains(t *testing.T, value, other interface{}) *Matcher ", "output": "{\n\treturn Match(t, value).Contains(other)\n}"}
{"input": "package flume_log\n\nimport (\n\t\"errors\"\n\t\"strings\"\n)\n\nvar defaultAgentAddr string\n\ntype FlumeLogger struct {\n\tclient *FlumeClient\n}\n\nfunc init() {\n\tdefaultAgentAddr = \"127.0.0.1:5140\"\n}\n\n\n\nfunc NewFlumeLoggerWithAddr(agentAddr string) *FlumeLogger {\n\tc := NewFlumeClient(agentAddr)\n\treturn &FlumeLogger{c}\n}\n\nfunc (l *FlumeLogger) Info(logInfo string, detail *DetailInfo) error {\n\treturn l.log(\"info\", logInfo, detail)\n}\n\nfunc (l *FlumeLogger) Warn(logInfo string, detail *DetailInfo) error {\n\treturn l.log(\"warn\", logInfo, detail)\n}\n\nfunc (l *FlumeLogger) Error(logInfo string, detail *DetailInfo) error {\n\treturn l.log(\"error\", logInfo, detail)\n}\n\nfunc (l *FlumeLogger) log(typeInfo string, logInfo string, detail *DetailInfo) error {\n\tlog_info := NewLogInfo()\n\tlog_info.module = detail.module\n\ttopic := \"log.\" + gAppName + \".\" + detail.module\n\tlog_info.topic = strings.ToLower(topic)\n\tlog_info.level = typeInfo\n\tlog_info.typ = typeInfo\n\tlog_info.tag = logInfo\n\tlog_info.detail = detail\n\tif l.client != nil {\n\t\treturn l.client.SendLog(log_info.Serialize())\n\t}\n\treturn errors.New(\"no client\")\n}\n\nfunc (l *FlumeLogger) Stop() {\n\tif l.client != nil {\n\t\tl.client.Stop()\n\t}\n}\n\nfunc NewFlumeLogger() *FlumeLogger ", "output": "{\n\tc := NewFlumeClient(defaultAgentAddr)\n\treturn &FlumeLogger{c}\n}"}
{"input": "package file\n\nimport (\n\t\"encoding/json\"\n\t\"os\"\n)\n\nfunc FileExist(path string) bool {\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc FileExistAndReadable(path string) bool {\n\tinfo, err := os.Stat(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn false\n\t\t} else if os.IsPermission(err) {\n\t\t\treturn false\n\t\t}\n\t}\n\tif info.IsDir() {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc IsDirectory(path string) bool {\n\tinfo, err := os.Stat(path)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn info.IsDir()\n}\n\n\n\nfunc SaveJSON(path string, data interface{}) error {\n\tj, err := os.Create(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer j.Close()\n\n\terr = json.NewEncoder(j).Encode(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc LoadJSON(path string, data interface{}) (result interface{}, err error) ", "output": "{\n\tj, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer j.Close()\n\terr = json.NewDecoder(j).Decode(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}"}
{"input": "package http\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/smartystreets/goconvey/convey\"\n\t\"go-common/app/admin/main/aegis/model\"\n)\n\nvar arg = &model.SearchParams{\n\tBusinessID: 1,\n\tOID:     []string{\"206137981869783258\", \"206137981871880409\", \"206129056929839317\", \"206117679558326449\"},\n\tKeyWord: \"分享图片\",\n\tFlowID:  -12345,\n\tExtra1:  \"1,2,3,4,5\",\n\tMid:     -12345,\n\tState:   0,\n}\n\n\n\nfunc TestUpsertES(t *testing.T) {\n\tconvey.Convey(\"UpsertES\", t, func(ctx convey.C) {\n\t\trsc := []*model.UpsertItem{\n\t\t\t{\n\t\t\t\tID:    47,\n\t\t\t\tState: -3,\n\t\t\t},\n\t\t\tnil,\n\t\t\t{\n\t\t\t\tState: 0,\n\t\t\t},\n\t\t}\n\t\tctx.Convey(\"When everything goes positive\", func(ctx convey.C) {\n\t\t\thttpMock(\"POST\", d.c.Host.Manager+_upsertES).Reply(200).JSON(`{\"code\":0,\"message\":\"msg\"}`)\n\t\t\terr := d.UpsertES(context.Background(), rsc)\n\t\t\tctx.Convey(\"No return values\", func(ctx convey.C) {\n\t\t\t\tctx.So(err, convey.ShouldBeNil)\n\t\t\t})\n\t\t})\n\t})\n}\n\nfunc TestHttpResourceES(t *testing.T) ", "output": "{\n\tconvey.Convey(\"ResourceES\", t, func(ctx convey.C) {\n\t\tvar (\n\t\t\tc = context.Background()\n\t\t)\n\t\tctx.Convey(\"When everything goes positive\", func(ctx convey.C) {\n\t\t\tres, err := d.ResourceES(c, arg)\n\t\t\tt.Logf(\"res(%+v)\", res)\n\t\t\tctx.Convey(\"Then err should be nil.sres should not be nil.\", func(ctx convey.C) {\n\t\t\t\tctx.So(err, convey.ShouldBeNil)\n\t\t\t})\n\t\t})\n\t})\n}"}
{"input": "package log\n\nimport (\n\t\"fmt\"\n\tslog \"log/syslog\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/superkkt/go-logging\"\n)\n\ntype syslog struct {\n\twriter *slog.Writer\n}\n\n\n\nfunc (r *syslog) Log(level logging.Level, calldepth int, record *logging.Record) error {\n\tline := fmt.Sprintf(\"%v (TID=%v)\", record.Formatted(calldepth+1), getGoRoutineID())\n\tswitch level {\n\tcase logging.CRITICAL:\n\t\treturn r.writer.Crit(line)\n\tcase logging.ERROR:\n\t\treturn r.writer.Err(line)\n\tcase logging.WARNING:\n\t\treturn r.writer.Warning(line)\n\tcase logging.NOTICE:\n\t\treturn r.writer.Notice(line)\n\tcase logging.INFO:\n\t\treturn r.writer.Info(line)\n\tcase logging.DEBUG:\n\t\treturn r.writer.Debug(line)\n\tdefault:\n\t\tpanic(\"unexpected log level\")\n\t}\n}\n\nfunc getGoRoutineID() string {\n\tvar buf [64]byte\n\tn := runtime.Stack(buf[:], false)\n\treturn strings.Fields(strings.TrimPrefix(string(buf[:n]), \"goroutine \"))[0]\n}\n\nfunc NewSyslog(prefix string) (logging.Backend, error) ", "output": "{\n\tw, err := slog.New(slog.LOG_CRIT, prefix)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &syslog{writer: w}, nil\n}"}
{"input": "package primitives\n\nimport (\n  \"fmt\"\n  \"github.com/kedebug/LispEx/value\"\n)\n\ntype Lt struct {\n  value.Primitive\n}\n\n\n\nfunc (self *Lt) Apply(args []value.Value) value.Value {\n  if len(args) != 2 {\n    panic(fmt.Sprint(\"argument mismatch for `<', expected 2, given: \", len(args)))\n  }\n  if v1, ok := args[0].(*value.IntValue); ok {\n    if v2, ok := args[1].(*value.IntValue); ok {\n      return value.NewBoolValue(v1.Value < v2.Value)\n    } else if v2, ok := args[1].(*value.FloatValue); ok {\n      return value.NewBoolValue(float64(v1.Value) < v2.Value)\n    }\n  } else if v1, ok := args[0].(*value.FloatValue); ok {\n    if v2, ok := args[1].(*value.IntValue); ok {\n      return value.NewBoolValue(v1.Value < float64(v2.Value))\n    } else if v2, ok := args[1].(*value.FloatValue); ok {\n      return value.NewBoolValue(v1.Value < v2.Value)\n    }\n  }\n  panic(fmt.Sprint(\"incorrect argument type for `<', expected number?\"))\n}\n\nfunc NewLt() *Lt ", "output": "{\n  return &Lt{value.Primitive{\"<\"}}\n}"}
{"input": "package ovh\n\n\ntype Client struct {\n\tOVHWrapper APIWrapper\n}\n\n\n\n\n\nfunc (c *Client) GetDomainRedirection(id int) (*DomainRedirection, error) {\n\tsubRedir, err := c.OVHWrapper.GetDomainRedirection(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn subRedir, nil\n}\n\nfunc (c *Client) GetAllRedirections() ([]*DomainRedirection, error) {\n\tIDs, err := c.OVHWrapper.GetDomainRedirectionIDs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tredirs := []*DomainRedirection{}\n\n\tfor _, id := range IDs {\n\t\tredir, err := c.OVHWrapper.GetDomainRedirection(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tredirs = append(redirs, redir)\n\t}\n\n\treturn redirs, nil\n}\n\n\nfunc (c *Client) CreateDomainRedirection(subdomain string, target string) (*DomainRedirection, error) {\n\n\tredir := DomainRedirection{\n\t\tType:      \"visiblePermanent\",\n\t\tSubDomain: subdomain,\n\t\tTarget:    target,\n\t}\n\n\tovhRedir, err := c.OVHWrapper.PostDomainRedirection(&redir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = c.OVHWrapper.DomainRefreshDNSZone()\n\n\treturn ovhRedir, err\n}\n\nfunc (c *Client) GetDomainRedirectionByName(name string) (*DomainRedirection, error) ", "output": "{\n\tid, err := c.OVHWrapper.GetDomainRedirectionID(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsubRedir, err := c.OVHWrapper.GetDomainRedirection(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn subRedir, nil\n}"}
{"input": "package response\n\nimport \"encoding/json\"\nimport \"net/http\"\n\n\ntype Response struct {\n\tStatusCode int         `json:\"status_code\"`\n\tMessage    string      `json:\"message\"`\n\tData       interface{} `json:\"data\"`\n}\n\n\nfunc createResponse(result Response) []byte {\n\tres, _ := json.Marshal(result)\n\treturn res\n}\n\n\n\n\n\nfunc Failed(message string) []byte {\n\treturn createResponse(Response{\n\t\tStatusCode: 500,\n\t\tMessage:    message,\n\t})\n}\n\nfunc SendJSONResponseHeader(w http.ResponseWriter) {\n\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc Success(result interface{}) []byte ", "output": "{\n\treturn createResponse(Response{\n\t\tStatusCode: 200,\n\t\tMessage:    \"ok\",\n\t\tData:       result,\n\t})\n}"}
{"input": "package main\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n)\n\n\ntype IPWhiteListMiddleware struct {\n\t*BaseMiddleware\n}\n\n\n\nfunc (i *IPWhiteListMiddleware) IsEnabledForSpec() bool {\n\treturn i.Spec.EnableIpWhiteListing && len(i.Spec.AllowedIPs) > 0\n}\n\n\nfunc (i *IPWhiteListMiddleware) ProcessRequest(w http.ResponseWriter, r *http.Request, _ interface{}) (error, int) {\n\tif !i.Spec.EnableIpWhiteListing {\n\t\treturn nil, 200\n\t}\n\n\tremoteIP := net.ParseIP(requestIP(r))\n\n\tfor _, ip := range i.Spec.AllowedIPs {\n\t\tallowedIP, allowedNet, err := net.ParseCIDR(ip)\n\t\tif err != nil {\n\t\t\tallowedIP = net.ParseIP(ip)\n\t\t}\n\n\t\tif allowedNet != nil && allowedNet.Contains(remoteIP) {\n\t\t\treturn nil, 200\n\t\t}\n\n\t\tif allowedIP.Equal(remoteIP) {\n\t\t\treturn nil, 200\n\t\t}\n\t}\n\n\tAuthFailed(i.BaseMiddleware, r, remoteIP.String())\n\tReportHealthCheckValue(i.Spec.Health, KeyFailure, \"-1\")\n\n\treturn errors.New(\"Access from this IP has been disallowed\"), 403\n}\n\nfunc (i *IPWhiteListMiddleware) Name() string ", "output": "{\n\treturn \"IPWhiteListMiddleware\"\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSIoTAnalyticsPipeline_DeviceShadowEnrich struct {\n\n\tAttribute string `json:\"Attribute,omitempty\"`\n\n\tName string `json:\"Name,omitempty\"`\n\n\tNext string `json:\"Next,omitempty\"`\n\n\tRoleArn string `json:\"RoleArn,omitempty\"`\n\n\tThingName string `json:\"ThingName,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSIoTAnalyticsPipeline_DeviceShadowEnrich) AWSCloudFormationType() string {\n\treturn \"AWS::IoTAnalytics::Pipeline.DeviceShadowEnrich\"\n}\n\n\n\nfunc (r *AWSIoTAnalyticsPipeline_DeviceShadowEnrich) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSIoTAnalyticsPipeline_DeviceShadowEnrich) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSIoTAnalyticsPipeline_DeviceShadowEnrich) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSIoTAnalyticsPipeline_DeviceShadowEnrich) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\n\n\nfunc (r *AWSIoTAnalyticsPipeline_DeviceShadowEnrich) SetDeletionPolicy(policy policies.DeletionPolicy) ", "output": "{\n\tr._deletionPolicy = policy\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/akrennmair/cyder\"\n\t\"net/http\"\n)\n\ntype Foo struct{}\n\nfunc (f *Foo) Index(rr *cyder.RequestResponse) {\n\trr.StatusCode(200)\n\tfmt.Fprintf(rr, \"hello world from index\")\n}\n\nfunc (f *Foo) Foobar(rr *cyder.RequestResponse) {\n\trr.StatusCode(200)\n\tfmt.Fprintf(rr, \"hello world from foobar\")\n}\n\n\n\ntype Index struct{}\n\nfunc (i *Index) Index(rr *cyder.RequestResponse) {\n\trr.StatusCode(200)\n\tfmt.Fprintf(rr, \"hello world from /\")\n}\n\nfunc main() {\n\thttp.Handle(\"/foo/\", http.StripPrefix(\"/foo\", cyder.Handler(&Foo{})))\n\thttp.Handle(\"/\", cyder.Handler(&Index{}))\n\n\tfmt.Printf(\"Starting HTTP server on :8000...\\n\")\n\tif err := http.ListenAndServe(\":8000\", nil); err != nil {\n\t\tfmt.Printf(\"ListenAndServe: %v\\n\", err)\n\t}\n}\n\nfunc (f *Foo) Pope(rr *cyder.RequestResponse, a int) ", "output": "{\n\trr.StatusCode(200)\n\tfmt.Fprintf(rr, \"Pope: %d\", a)\n}"}
{"input": "package input\n\nimport \"github.com/hajimehoshi/ebiten\"\n\nconst (\n\tMBLeft   = ebiten.MouseButtonLeft\n\tMBRight  = ebiten.MouseButtonRight\n\tMBMiddle = ebiten.MouseButtonMiddle\n)\n\nvar (\n\tglobalCursor = NewEbitenCursor()\n)\n\ntype MB = ebiten.MouseButton\n\ntype ICursor interface {\n\tUpdate()\n\tGetPos() (x, y int)\n\tIsPressed() bool\n}\n\ntype ebCursor struct {\n\tstate int\n\tx     int\n\ty     int\n}\n\nfunc (e *ebCursor) Update() {\n\te.x, e.y = ebiten.CursorPosition()\n\tif ebiten.IsMouseButtonPressed(MBLeft) {\n\t\te.state++\n\t} else {\n\t\te.state = 0\n\t}\n}\n\nfunc (e *ebCursor) GetPos() (x, y int) {\n\treturn e.x, e.y\n}\n\nfunc (e *ebCursor) IsPressed() bool {\n\treturn e.state > 0\n}\n\nfunc (e *ebCursor) IsTriggered() bool {\n\treturn e.state == 1\n}\n\nfunc GetCursorInput() ICursor {\n\treturn globalCursor\n}\n\n\n\nfunc NewEbitenCursor() ICursor ", "output": "{\n\treturn &ebCursor{}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n\n\ntype HTTPError interface {\n\tWriteToPage(w http.ResponseWriter) bool\n\tHTTPStatus() int\n\tError() string\n}\n\n\n\ntype StatusError struct {\n\tStatus  int\n\tMessage string\n}\n\n\n\nfunc (e StatusError) Error() string {\n\treturn fmt.Sprintf(\"%v -- %v\", e.Status, e.Message)\n}\n\n\n\nfunc (e StatusError) HTTPStatus() int {\n\treturn e.Status\n}\n\n\nfunc (e StatusError) WriteToPage(w http.ResponseWriter) bool {\n\ttw := defaultTW.SetTemplate(errorTmpl)\n\n\treturn tw.SetStatusCode(e.Status).SetTmplArgs(e).Execute(w)\n}\n\n\n\ntype DatabaseError struct {\n\tdbError error\n}\n\n\n\n\n\n\n\n\n\n\nfunc (e *DatabaseError) HTTPStatus() int {\n\treturn 500\n}\n\n\nfunc (e *DatabaseError) Error() string {\n\treturn fmt.Sprintf(\"DatabaseError: %v\", e.dbError)\n}\n\n\nfunc (e *DatabaseError) WriteToPage(w http.ResponseWriter) bool {\n\ttw := defaultTW.SetTemplate(error500Tmpl)\n\n\treturn tw.SetStatusCode(500).SetTmplArgs(e).Execute(w)\n}\n\nfunc NewDatabaseError(err error) HTTPError ", "output": "{\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\treturn &DatabaseError{err}\n}"}
{"input": "package controllers\n\nimport (\n\t\"strings\"\n\n\t\"github.com/astaxie/beego\"\n)\n\nconst (\n\tMSG_OK  = 0\n\tMSG_ERR = -1\n)\n\n\ntype BaseController struct {\n\tbeego.Controller\n\tcontrollerName string\n\tactionName     string\n}\n\n\n\n\nfunc (b *BaseController) display(tpl ...string) {\n\tvar tplname string\n\tif len(tpl) > 0 {\n\t\ttplname = tpl[0] + \".html\"\n\t} else {\n\t\ttplname = b.controllerName + \"/\" + b.actionName + \".html\"\n\t}\n\tb.Layout = \"layout.html\"\n\tb.TplName = tplname\n}\n\nfunc (b *BaseController) redirect(url string) {\n\tb.Redirect(url, 302)\n\tb.StopRun()\n}\n\nfunc (b *BaseController) showError(args ...string) {\n\tb.Data[\"error\"] = args[0]\n\tredirect := b.Ctx.Request.Referer()\n\tif len(args) > 1 {\n\t\tredirect = args[1]\n\t}\n\n\tb.Data[\"redirect\"] = redirect\n\tb.Data[\"pageTitle\"] = \"Error\"\n\tb.display(\"error/error\")\n\tb.Render()\n\tb.StopRun()\n}\n\nfunc (b *BaseController) ajaxMsg(msg interface{}, msgno int) {\n\tout := make(map[string]interface{})\n\tout[\"status\"] = msgno\n\tout[\"msg\"] = msg\n\tstatus := 200\n\tif msgno != MSG_OK {\n\t\tstatus = 500\n\t}\n\tb.Data[\"json\"] = out\n\tb.Ctx.Output.SetStatus(status)\n\tb.ServeJSON()\n\tb.StopRun()\n}\n\nfunc (b *BaseController) Prepare() ", "output": "{\n\tcontrollerName, actionName := b.GetControllerAndAction()\n\tb.controllerName = strings.ToLower(controllerName[0 : len(controllerName)-10])\n\tb.actionName = strings.ToLower(actionName)\n\n\tb.Data[\"siteName\"] = beego.AppConfig.String(\"site.name\")\n\tb.Data[\"curRoute\"] = b.controllerName + \".\" + b.actionName\n\tb.Data[\"curController\"] = b.controllerName\n}"}
{"input": "package controllers\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/astaxie/beego\"\n\t\"github.com/scmo/apayment-backend/models\"\n\t\"github.com/scmo/apayment-backend/services\"\n\t\"time\"\n)\n\n\n\n\ntype JournalController struct {\n\tbeego.Controller\n}\n\nfunc (controller *JournalController) getUser() *models.User {\n\tclaims, err := services.ParseToken(controller.Ctx.Request.Header.Get(\"Authorization\"))\n\tif err != nil {\n\t\tcontroller.CustomAbort(401, \"Unauthorized\")\n\t}\n\tuser, err := services.GetUserByUsername(claims.Subject)\n\tif err != nil {\n\t\tcontroller.CustomAbort(404, err.Error())\n\t}\n\treturn user\n}\n\n\n\n\n\n\n\nfunc (this *JournalController) GetMonthlyStats() {\n\n\tuser := this.getUser()\n\n\tmonth, err := this.GetUint8(\"month\")\n\tif err != nil {\n\t\tthis.CustomAbort(400, \"Month not sent\")\n\t}\n\tyear, err := this.GetUint16(\"year\")\n\tif err != nil {\n\t\tthis.CustomAbort(400, \"Year not sent\")\n\t}\n\n\tif month < 1 || month > 12 || year < 1900 || year > uint16(time.Now().Year()) {\n\t\tthis.CustomAbort(400, \"Value not possible for one of the parameter. Year must be a 4 digit integer. Month parameter must be a interger between 1 and 31.\")\n\t}\n\n\tmonthlyStats, err := services.GetMonthlyStats(user.TVD, month, year)\n\tif err != nil {\n\t\tthis.CustomAbort(501, \"Internal Error \"+err.Error())\n\t}\n\tthis.Data[\"json\"] = monthlyStats\n\tthis.ServeJSON()\n}\n\n\n\n\n\n\n\n\nfunc (this *JournalController) AddJournalEntry() ", "output": "{\n\tuser := this.getUser()\n\n\tvar journalEntry models.JournalEntry\n\tjson.Unmarshal(this.Ctx.Input.RequestBody, &journalEntry)\n\n\tjournalEntry.SetDate()\n\tservices.AddJournalEntry(&journalEntry)\n\n\tthis.Data[\"json\"] = user\n\tthis.ServeJSON()\n}"}
{"input": "package xor\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n)\n\n\n\n\nfunc XORBytes(a, b []byte) ([]byte, error) {\n\tif len(a) != len(b) {\n\t\treturn nil, fmt.Errorf(\"length of byte slices is not equivalent: %d != %d\", len(a), len(b))\n\t}\n\n\tbuf := make([]byte, len(a))\n\n\tfor i, _ := range a {\n\t\tbuf[i] = a[i] ^ b[i]\n\t}\n\n\treturn buf, nil\n}\n\n\n\n\n\n\nfunc XORBase64(a, b string) ([]byte, error) ", "output": "{\n\taBytes, err := base64.StdEncoding.DecodeString(a)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error decoding first base64 value: %w\", err)\n\t}\n\tif aBytes == nil || len(aBytes) == 0 {\n\t\treturn nil, fmt.Errorf(\"decoded first base64 value is nil or empty\")\n\t}\n\n\tbBytes, err := base64.StdEncoding.DecodeString(b)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error decoding second base64 value: %w\", err)\n\t}\n\tif bBytes == nil || len(bBytes) == 0 {\n\t\treturn nil, fmt.Errorf(\"decoded second base64 value is nil or empty\")\n\t}\n\n\treturn XORBytes(aBytes, bBytes)\n}"}
{"input": "package syncbase_test\n\nimport (\n\t\"regexp\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"v.io/v23/syncbase\"\n)\n\nconst (\n\tuuidLoopInvocations int = 100\n)\n\n\n\nfunc TestUUIDCollisions(t *testing.T) {\n\tvar mutex sync.Mutex\n\tvar waitGroup sync.WaitGroup\n\tuuidMap := make(map[string]bool)\n\n\tcreateUUID := func() {\n\t\tmutex.Lock()\n\t\tdefer mutex.Unlock()\n\t\tuuidMap[syncbase.UUID()] = true\n\t\twaitGroup.Done()\n\t}\n\n\tfor i := 0; i < uuidLoopInvocations; i++ {\n\t\twaitGroup.Add(1)\n\t\tgo createUUID()\n\t}\n\n\twaitGroup.Wait()\n\n\tif len(uuidMap) != uuidLoopInvocations {\n\t\tt.Errorf(\"UUID collision for %d UUIDs\", uuidLoopInvocations-len(uuidMap))\n\t}\n}\n\nfunc TestUUIDFormat(t *testing.T) ", "output": "{\n\tuuid := syncbase.UUID()\n\tregexp := regexp.MustCompile(\"(?i)^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$\")\n\tif !regexp.MatchString(uuid) {\n\t\tt.Errorf(\"Incorrect UUID format: %v\", uuid)\n\t}\n}"}
{"input": "package vip\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"go-common/app/interface/main/app-view/conf\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nvar (\n\td *Dao\n)\n\nfunc init() {\n\tdir, _ := filepath.Abs(\"../../cmd/app-view-test.toml\")\n\tflag.Set(\"conf\", dir)\n\tconf.Init()\n\td = New(conf.Conf)\n\ttime.Sleep(time.Second)\n}\n\nfunc ctx() context.Context {\n\treturn context.Background()\n}\n\n\n\nfunc TestVIPActive(t *testing.T) ", "output": "{\n\tConvey(\"get VIPActive all\", t, func() {\n\t\t_, err := d.VIPActive(ctx(), 1)\n\t\tSo(err, ShouldBeNil)\n\t})\n}"}
{"input": "package complaintdb\n\nimport(\n\t\"golang.org/x/net/context\"\n\t\"github.com/skypies/util/gcp/ds\"\n\t\"github.com/skypies/complaints/complaintdb/types\"\n)\n\n\ntype ComplaintIterator ds.Iterator\n\nfunc (cdb *ComplaintDB)NewComplaintIterator(cq *CQuery) *ComplaintIterator {\n\tit := ds.NewIterator(cdb.Ctx(), cdb.Provider, (*ds.Query)(cq), types.Complaint{})\n\treturn (*ComplaintIterator)(it)\n}\n\n\n\nfunc (ci *ComplaintIterator)Remaining() int {\n\tit := (*ds.Iterator)(ci)\n\treturn it.Remaining()\n}\n\nfunc (ci *ComplaintIterator)Err() error {\n\tit := (*ds.Iterator)(ci)\n\treturn it.Err()\n}\n\nfunc (ci *ComplaintIterator)Complaint() *types.Complaint {\n\tc := types.Complaint{}\n\n\tit := (*ds.Iterator)(ci)\n\tkeyer := it.Val(&c)\n\n\tFixupComplaint(&c, keyer.Encode())\n\n\treturn &c\n}\n\nfunc (ci *ComplaintIterator)Iterate(ctx context.Context) bool ", "output": "{\n\tit := (*ds.Iterator)(ci)\n\treturn it.Iterate(ctx)\n}"}
{"input": "package auth\n\nimport (\n\t\"context\"\n\t\"net/http\"\n)\n\nvar authenticated = \"authenticated\"\nvar teamNameKey = \"teamName\"\nvar teamIDKey = \"teamID\"\nvar isAdminKey = \"isAdmin\"\nvar isSystemKey = \"system\"\n\nfunc WrapHandler(\n\thandler http.Handler,\n\tvalidator Validator,\n\tuserContextReader UserContextReader,\n) http.Handler {\n\treturn authHandler{\n\t\thandler:           handler,\n\t\tvalidator:         validator,\n\t\tuserContextReader: userContextReader,\n\t}\n}\n\ntype authHandler struct {\n\thandler           http.Handler\n\tvalidator         Validator\n\tuserContextReader UserContextReader\n}\n\n\n\nfunc (h authHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tctx := context.WithValue(r.Context(), authenticated, h.validator.IsAuthenticated(r))\n\tteamName, teamID, isAdmin, found := h.userContextReader.GetTeam(r)\n\tif found {\n\t\tctx = context.WithValue(ctx, teamNameKey, teamName)\n\t\tctx = context.WithValue(ctx, teamIDKey, teamID)\n\t\tctx = context.WithValue(ctx, isAdminKey, isAdmin)\n\t}\n\n\tisSystem, found := h.userContextReader.GetSystem(r)\n\tif found {\n\t\tctx = context.WithValue(ctx, isSystemKey, isSystem)\n\t}\n\th.handler.ServeHTTP(w, r.WithContext(ctx))\n}"}
{"input": "package gpio\n\n\ntype Mode byte\n\nconst (\n\tIn    Mode = 0     \n\tOut   Mode = out   \n\tAlt   Mode = alt   \n\tAltIn Mode = altIn \n\tAna   Mode = ana   \n)\n\n\ntype Driver byte\n\nconst (\n\tPushPull  Driver = 0\n\tOpenDrain Driver = openDrain\n)\n\n\n\n\n\ntype Speed int8\n\nconst (\n\tVeryLow  Speed = veryLow  \n\tLow      Speed = low      \n\tMedium   Speed = 0        \n\tHigh     Speed = high     \n\tVeryHigh Speed = veryHigh \n)\n\n\ntype Pull byte\n\nconst (\n\tNoPull   Pull = 0        \n\tPullUp   Pull = pullUp   \n\tPullDown Pull = pullDown \n)\n\n\ntype Config struct {\n\tMode   Mode   \n\tDriver Driver \n\tSpeed  Speed  \n\tPull   Pull   \n}\n\n\nfunc (p *Port) SetupPin(index int, cfg *Config) {\n\tsetup(p, index, cfg)\n}\n\n\nfunc (p *Port) Setup(pins Pins, cfg *Config) {\n\tfor n := 0; n < 16; n++ {\n\t\tif pins&(1<<uint(n)) != 0 {\n\t\t\tsetup(p, n, cfg)\n\t\t}\n\t}\n}\n\n\n\n\n\nfunc (p *Port) Lock(pins Pins) ", "output": "{\n\tpins1 := uint32(pins) | 0x10000\n\tp.lckr.Store(pins1)\n\tp.lckr.Store(uint32(pins))\n\tp.lckr.Store(pins1)\n\tp.lckr.Load()\n\tp.lckr.Load()\n}"}
{"input": "package sample\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n)\n\ntype sampleState struct {\n\trate        uint64\n\tseed        int64\n\tsampleCount uint64\n\ttrueCount   uint64\n\trnd         *rand.Rand\n}\n\n\ntype Sampler interface {\n\tSample() bool\n\tSampleFrom(probe uint64) bool\n\tState\n}\n\n\ntype State interface {\n\tReset()\n\tString() string\n\tRate() uint64\n\tCalls() uint64\n\tCount() uint64\n}\n\nfunc (state *sampleState) Rate() uint64 {\n\tif state != nil {\n\t\treturn state.rate\n\t}\n\treturn 0\n}\n\nfunc (state *sampleState) Calls() uint64 {\n\tif state != nil {\n\t\treturn state.sampleCount\n\t}\n\treturn 0\n}\n\nfunc (state *sampleState) Count() uint64 {\n\tif state != nil {\n\t\treturn state.trueCount\n\t}\n\treturn 0\n}\n\nfunc (state *sampleState) Reset() {\n\tstate.rnd.Seed(state.seed)\n\tstate.sampleCount = 0\n\tstate.trueCount = 0\n}\n\nfunc (state *sampleState) String() string {\n\ttype X *sampleState\n\tx := X(state)\n\treturn fmt.Sprintf(\"%+v\", x)\n}\n\n\nfunc Deviation(state State) (deviation float64) {\n\tif state != nil && state.Count() > 0 {\n\t\tdeviation = 1.0 - 1.0/float64(state.Rate())*(float64(state.Calls())/float64(state.Count()))\n\t} else {\n\t\tdeviation = 1.0\n\t}\n\n\treturn\n}\n\n\n\n\nfunc Stats(state State) string ", "output": "{\n\tif state != nil {\n\t\treturn fmt.Sprintf(\"Rate: %d, SampleCount: %d, TrueCount: %d, Deviation: %.4f%%\", state.Rate(), state.Calls(), state.Count(), Deviation(state)*100.0)\n\t}\n\treturn \"No state provided\"\n}"}
{"input": "package models\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n)\n\n\nconst (\n\tIncomeStatusPending    = \"Pending\"\n\tIncomeStatusCharged    = \"Charged\"\n\tIncomeStatusChargeback = \"Chargeback\"\n)\n\n\nconst (\n\tIncomeTypeReward       = 0\n\tIncomeTypeSuperrewards = 2\n\tIncomeTypeClixwall     = 3\n\tIncomeTypePtcwall      = 4\n\tIncomeTypePersonaly    = 5\n\tIncomeTypeKiwiwall     = 7\n\tIncomeTypeAdscendMedia = 8\n\tIncomeTypeAdgateMedia  = 9\n\tIncomeTypeOffertoro    = 10\n)\n\nvar incomeTypes = map[int64]string{\n\tIncomeTypeReward:       \"reward\",\n\tIncomeTypeSuperrewards: \"superrewards\",\n\tIncomeTypeClixwall:     \"clixwall\",\n\tIncomeTypePtcwall:      \"ptcwall\",\n\tIncomeTypePersonaly:    \"personaly\",\n\tIncomeTypeKiwiwall:     \"kiwiwall\",\n\tIncomeTypeAdscendMedia: \"adscend media\",\n\tIncomeTypeAdgateMedia:  \"adgate media\",\n\tIncomeTypeOffertoro:    \"offertoro\",\n}\n\n\ntype Income struct {\n\tID            int64     `db:\"id\"`\n\tUserID        int64     `db:\"user_id\"`\n\tRefererID     int64     `db:\"referer_id\"`\n\tType          int64     `db:\"type\"`\n\tIncome        float64   `db:\"income\"`\n\tRefererIncome float64   `db:\"referer_income\"`\n\tCreatedAt     time.Time `db:\"created_at\"`\n\tStatus        string    `db:\"status\"`\n}\n\n\n\n\nfunc (i Income) MarshalJSON() ([]byte, error) ", "output": "{\n\tt, ok := incomeTypes[i.Type]\n\tif !ok {\n\t\tpanic(fmt.Sprintf(\"Invalid income type %v\", i.Type))\n\t}\n\n\tif i.Type != IncomeTypeReward {\n\t\tt = fmt.Sprintf(\"%s.%s\", t, i.Status)\n\t}\n\n\treturn json.Marshal(map[string]interface{}{\n\t\t\"type\":           t,\n\t\t\"income\":         i.Income,\n\t\t\"referer_income\": i.RefererIncome,\n\t\t\"created_at\":     i.CreatedAt,\n\t})\n}"}
{"input": "package test\n\nimport (\n\tbuildapi \"github.com/openshift/origin/pkg/build/api\"\n\t\"k8s.io/kubernetes/pkg/util/sets\"\n)\n\ntype FakeBuildConfigStore struct {\n\tBuild *buildapi.BuildConfig\n\tErr   error\n}\n\nfunc NewFakeBuildConfigStore(build *buildapi.BuildConfig) FakeBuildConfigStore {\n\treturn FakeBuildConfigStore{Build: build}\n}\n\nfunc (s FakeBuildConfigStore) Add(obj interface{}) error {\n\treturn s.Err\n}\n\nfunc (s FakeBuildConfigStore) Update(obj interface{}) error {\n\treturn s.Err\n}\n\nfunc (s FakeBuildConfigStore) Delete(obj interface{}) error {\n\treturn s.Err\n}\n\nfunc (s FakeBuildConfigStore) Resync() error {\n\treturn s.Err\n}\n\nfunc (s FakeBuildConfigStore) List() []interface{} {\n\treturn []interface{}{s.Build}\n}\n\nfunc (s FakeBuildConfigStore) ListKeys() []string {\n\treturn []string{\"config\"}\n}\n\nfunc (s FakeBuildConfigStore) ContainedIDs() sets.String {\n\treturn sets.NewString()\n}\n\nfunc (s FakeBuildConfigStore) Get(obj interface{}) (item interface{}, exists bool, err error) {\n\treturn s.GetByKey(\"\")\n}\n\nfunc (s FakeBuildConfigStore) GetByKey(id string) (item interface{}, exists bool, err error) {\n\tif s.Err != nil {\n\t\treturn nil, false, err\n\t}\n\tif s.Build == nil {\n\t\treturn nil, false, nil\n\t}\n\n\treturn s.Build, true, nil\n}\n\n\n\nfunc (s FakeBuildConfigStore) Replace(list []interface{}, resourceVersion string) error ", "output": "{\n\treturn nil\n}"}
{"input": "package stack\n\nimport \"errors\"\n\n\ntype Stack []interface{}\n\n\n\n\n\nfunc (stack Stack) Cap() int {\n\treturn cap(stack)\n}\n\n\nfunc (stack Stack) IsEmpty() bool {\n\treturn len(stack) == 0\n}\n\n\nfunc (stack *Stack) Push(x interface{}) {\n\t*stack = append(*stack, x)\n}\n\n\n\nfunc (stack *Stack) Pop() (interface{}, error) {\n\ttheStack := *stack\n\tif len(theStack) == 0 {\n\t\treturn nil, errors.New(\"can't Pop() an empty stack\")\n\t}\n\tx := theStack[len(theStack)-1]\n\t*stack = theStack[:len(theStack)-1]\n\treturn x, nil\n}\n\n\n\nfunc (stack Stack) Top() (interface{}, error) {\n\tif len(stack) == 0 {\n\t\treturn nil, errors.New(\"cant't Top() an empty stack\")\n\t}\n\treturn stack[len(stack)-1], nil\n}\n\nfunc (stack Stack) Len() int ", "output": "{\n\treturn len(stack)\n}"}
{"input": "package rkive\n\nimport (\n\t\"bytes\"\n\tcheck \"gopkg.in/check.v1\"\n\t\"time\"\n)\n\n\n\nfunc (s *riakSuite) TestCache(c *check.C) {\n\tstartt := time.Now()\n\n\tcache := s.cl.Bucket(\"test-cache\")\n\terr := cache.MakeCache()\n\tif err != nil {\n\t\tc.Fatal(err)\n\t}\n\tprops, err := cache.GetProperties()\n\tif err != nil {\n\t\tc.Error(err)\n\t}\n\tif !bytes.Equal(props.GetBackend(), []byte(\"cache\")) {\n\t\tc.Errorf(\"Expected backend %q; got %q\", \"cache\", props.GetBackend())\n\t}\n\n\n\tob := &TestObject{\n\t\tData: []byte(\"Save this.\"),\n\t}\n\n\terr = cache.New(ob, nil)\n\tif err != nil {\n\t\tc.Error(err)\n\t}\n\n\tob2 := &TestObject{\n\t\tData: []byte(\"overwrite!\"),\n\t}\n\n\terr = cache.Overwrite(ob2, ob.Info().Key())\n\tif err != nil {\n\t\tc.Error(err)\n\t}\n\n\tvar upd bool\n\tupd, err = cache.Update(ob)\n\tif err != nil {\n\t\tc.Error(err)\n\t}\n\tif !upd {\n\t\tc.Error(\"Expected update.\")\n\t}\n\n\tif !bytes.Equal(ob.Data, []byte(\"overwrite!\")) {\n\t\tc.Errorf(\"Expected body %q; got %q\", []byte(\"overwrite!\"), ob.Data)\n\t}\n\n\ts.runtime += time.Since(startt)\n}\n\nfunc (s *riakSuite) TestGetBucketTypeProperties(c *check.C) ", "output": "{\n\tc.Skip(\"not implemented\")\n}"}
{"input": "package database\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype UpdateDataGuardAssociationRequest struct {\n\n\tDatabaseId *string `mandatory:\"true\" contributesTo:\"path\" name:\"databaseId\"`\n\n\tDataGuardAssociationId *string `mandatory:\"true\" contributesTo:\"path\" name:\"dataGuardAssociationId\"`\n\n\tUpdateDataGuardAssociationDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\n\n\n\nfunc (request UpdateDataGuardAssociationRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request UpdateDataGuardAssociationRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request UpdateDataGuardAssociationRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype UpdateDataGuardAssociationResponse struct {\n\n\tRawResponse *http.Response\n\n\tDataGuardAssociation `presentIn:\"body\"`\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response UpdateDataGuardAssociationResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response UpdateDataGuardAssociationResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request UpdateDataGuardAssociationRequest) String() string ", "output": "{\n\treturn common.PointerString(request)\n}"}
{"input": "package fritz\n\nimport (\n\t\"unicode/utf16\"\n\t\"unicode/utf8\"\n)\n\nfunc utf8To16LE(p []byte) []byte {\n\tbs := make([]byte, 0, 2*len(p))\n\tpos := 0\n\tfor pos < len(p) {\n\t\tbytes, size := consumeNextRune(p[pos:])\n\t\tpos += size\n\t\tbs = append(bs, bytes...)\n\t}\n\treturn bs\n}\n\n\n\nfunc consumeNextRune(p []byte) ([]byte, int) ", "output": "{\n\tr, size := utf8.DecodeRune(p)\n\tif r <= 0xffff {\n\t\treturn []byte{uint8(r), uint8(r >> 8)}, size\n\t}\n\tr1, r2 := utf16.EncodeRune(r)\n\treturn []byte{uint8(r1), uint8(r1 >> 8), uint8(r2), uint8(r2 >> 8)}, size\n}"}
{"input": "package runtime_test\n\nimport (\n\t\"runtime\"\n\t\"testing\"\n)\n\n\n\n\nfunc BenchmarkSyscallWork(b *testing.B) {\n\tbenchmarkSyscall(b, 100, 1)\n}\n\nfunc BenchmarkSyscallExcess(b *testing.B) {\n\tbenchmarkSyscall(b, 0, 4)\n}\n\nfunc BenchmarkSyscallExcessWork(b *testing.B) {\n\tbenchmarkSyscall(b, 100, 4)\n}\n\nfunc benchmarkSyscall(b *testing.B, work, excess int) {\n\tb.SetParallelism(excess)\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfoo := 42\n\t\tfor pb.Next() {\n\t\t\truntime.Entersyscall()\n\t\t\tfor i := 0; i < work; i++ {\n\t\t\t\tfoo *= 2\n\t\t\t\tfoo /= 2\n\t\t\t}\n\t\t\truntime.Exitsyscall()\n\t\t}\n\t\t_ = foo\n\t})\n}\n\nfunc BenchmarkSyscall(b *testing.B) ", "output": "{\n\tbenchmarkSyscall(b, 0, 1)\n}"}
{"input": "package testutil\n\nimport (\n\t\"testing\"\n\n\tci \"gx/ipfs/QmPGxZ1DP2w45WcogpW1h43BvseXbfke9N91qotpoQcUeS/go-libp2p-crypto\"\n\tma \"gx/ipfs/QmSWLfmj5frN9xVLMMN846dMDriy5wN5jeghUm7aTW3DAG/go-multiaddr\"\n\tpeer \"gx/ipfs/QmWUswjn261LSyVxWAEpMVtPdy8zmKBJJfBpG3Qdpa8ZsE/go-libp2p-peer\"\n)\n\ntype Identity interface {\n\tAddress() ma.Multiaddr\n\tID() peer.ID\n\tPrivateKey() ci.PrivKey\n\tPublicKey() ci.PubKey\n}\n\n\n\nfunc RandIdentity() (Identity, error) {\n\tp, err := RandPeerNetParams()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &identity{*p}, nil\n}\n\nfunc RandIdentityOrFatal(t *testing.T) Identity {\n\tp, err := RandPeerNetParams()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn &identity{*p}\n}\n\n\ntype identity struct {\n\tPeerNetParams\n}\n\nfunc (p *identity) ID() peer.ID {\n\treturn p.PeerNetParams.ID\n}\n\nfunc (p *identity) Address() ma.Multiaddr {\n\treturn p.Addr\n}\n\nfunc (p *identity) PrivateKey() ci.PrivKey {\n\treturn p.PrivKey\n}\n\n\n\nfunc (p *identity) PublicKey() ci.PubKey ", "output": "{\n\treturn p.PubKey\n}"}
{"input": "package timeutil\n\nimport (\n\t\"time\"\n)\n\n\nfunc SetTimeout(t time.Duration, callback func()) {\n\tgo func() {\n\t\ttime.Sleep(t)\n\t\tcallback()\n\t}()\n}\n\n\n\nfunc SetInterval(t time.Duration, callback func() bool) {\n\tgo func() {\n\t\tfor {\n\t\t\ttime.Sleep(t)\n\t\t\tif !callback() {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n}\n\n\nfunc Nanosecond() int64 {\n\treturn time.Now().UnixNano()\n}\n\n\n\n\n\nfunc Millisecond() int64 {\n\treturn time.Now().UnixNano() / 1e6\n}\n\n\nfunc Second() int64 {\n\treturn time.Now().UnixNano() / 1e9\n}\n\n\nfunc Date() string {\n\treturn time.Now().Format(\"2006-01-02\")\n}\n\n\nfunc Datetime() string {\n\treturn time.Now().Format(\"2006-01-02 15:04:05\")\n}\n\n\n\nfunc Format(format string, timestamps ...int64) string {\n\ttimestamp := Second()\n\tif len(timestamps) > 0 {\n\t\ttimestamp = timestamps[0]\n\t}\n\treturn time.Unix(timestamp, 0).Format(format)\n}\n\n\nfunc StrToTime(format string, timestr string) (int64, error) {\n\tt, err := time.Parse(format, timestr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn t.Unix(), nil\n}\n\nfunc Microsecond() int64 ", "output": "{\n\treturn time.Now().UnixNano() / 1e3\n}"}
{"input": "package module\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n)\n\n\ntype ModuleType uint\n\nconst (\n\tGlobalModule ModuleType = iota\n\tTypeModule\n\tHeaderModule\n)\n\ntype Module interface {\n\tType() ModuleType\n\tName() string\n\tLoad() ([]byte, error)\n}\n\ntype module struct {\n\ttyp  ModuleType\n\tname string\n\tpath string\n}\n\nfunc New(typ ModuleType, name string, path string) Module {\n\treturn &module{\n\t\ttyp:  typ,\n\t\tname: name,\n\t\tpath: path,\n\t}\n}\n\n\n\nfunc (m *module) Type() ModuleType {\n\treturn m.typ\n}\n\nfunc (m *module) Load() ([]byte, error) {\n\tb, err := ioutil.ReadFile(m.path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read file %s: %w\", m.path, err)\n\t}\n\n\treturn b, nil\n}\n\nfunc (m *module) Name() string ", "output": "{\n\treturn m.name\n}"}
{"input": "package rpcmux\n\nimport (\n\t\"time\"\n\n\t\"github.com/jj-io/jj/rpc\"\n)\n\nvar (\n\tRouterDebugPing  = \"debug.ping\"\n\tRouterDebugSleep = \"debug.sleep\"\n\tRouterHelp       = \"help\"\n)\n\n\n\nfunc HelpHandler(w rpc.ResponseWriter, req *rpc.Request) {\n\tlist := w.(*responseWriter).routerList()\n\tw.Response(list)\n}\n\nfunc PingHandler(w rpc.ResponseWriter, data *rpc.Request) {\n\tw.Response(\"pong\")\n}\n\nfunc SleepHandler(w rpc.ResponseWriter, data *rpc.Request) {\n\tvar params string\n\tif err := data.Params(&params); err != nil {\n\t\tw.Error(err)\n\t\treturn\n\t}\n\n\tduration, err := time.ParseDuration(params)\n\tif err != nil {\n\t\tw.Errorf(\"%v: %v\", err, params)\n\t\treturn\n\t}\n\n\ttime.Sleep(duration)\n\tw.Responsef(\"sleep %v\", duration)\n}\n\nfunc InitDebugHandler(handler rpc.Handler) ", "output": "{\n\thandler.HandleFunc(RouterDebugPing, PingHandler)\n\thandler.HandleFunc(RouterDebugSleep, SleepHandler)\n\thandler.HandleFunc(RouterHelp, HelpHandler)\n}"}
{"input": "package backend\n\nimport (\n\t\"github.com/polyglottis/platform/content\"\n\t\"github.com/polyglottis/platform/language\"\n\t\"github.com/polyglottis/platform/user\"\n)\n\ntype Configuration struct {\n\tContent  content.Server\n\tLanguage language.Server\n\tUser     user.Server\n}\n\ntype Engine struct {\n\t*Configuration\n}\n\n\n\nfunc NewEngine(c *Configuration) *Engine ", "output": "{\n\treturn &Engine{\n\t\tConfiguration: c,\n\t}\n}"}
{"input": "package alertsv2\n\nimport \"net/url\"\n\ntype AddAlertAttachmentRequest struct {\n\t*AttachmentAlertIdentifier\n\tAttachmentFilePath    string `json:\"alertfile,omitempty\"`\n\tAttachmentFileContent []byte\n\tAttachmentFileName    string\n\tUser                  string `json:\"user,omitempty\"`\n\tIndexFile             string `json:\"indexFile,omitempty\"`\n\tApiKey                string `json:\"-\"`\n}\n\n\n\nfunc (r *AddAlertAttachmentRequest) GetApiKey() string {\n\treturn r.ApiKey\n}\n\nfunc (r *AddAlertAttachmentRequest) GenerateUrl() (string, url.Values, error) ", "output": "{\n\tpath, params, err := r.AttachmentAlertIdentifier.GenerateUrl()\n\treturn path + \"/attachments\", params, err\n}"}
{"input": "package prometheus_test\n\nimport (\n\t\"github.com/golang/protobuf/proto\"\n\tdto \"github.com/prometheus/client_model/go\"\n)\n\n\n\nfunc NewCounter(name string, v float64, ls ...*dto.LabelPair) *dto.MetricFamily ", "output": "{\n\tm := &dto.Metric{\n\t\tLabel: ls,\n\t\tCounter: &dto.Counter{\n\t\t\tValue: &v,\n\t\t},\n\t}\n\treturn &dto.MetricFamily{\n\t\tName:   proto.String(name),\n\t\tType:   dto.MetricType_COUNTER.Enum(),\n\t\tMetric: []*dto.Metric{m},\n\t}\n}"}
{"input": "package server\n\nimport (\n\t\"context\"\n\n\t\"github.com/jaegertracing/jaeger/cmd/collector/app/processor\"\n\t\"github.com/jaegertracing/jaeger/model\"\n\t\"github.com/jaegertracing/jaeger/thrift-gen/sampling\"\n)\n\ntype mockSamplingStore struct{}\n\nfunc (s mockSamplingStore) GetSamplingStrategy(_ context.Context, serviceName string) (*sampling.SamplingStrategyResponse, error) {\n\treturn nil, nil\n}\n\ntype mockSpanProcessor struct {\n}\n\nfunc (p *mockSpanProcessor) Close() error {\n\treturn nil\n}\n\n\n\nfunc (p *mockSpanProcessor) ProcessSpans(spans []*model.Span, _ processor.SpansOptions) ([]bool, error) ", "output": "{\n\treturn []bool{}, nil\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n)\n\nfunc SetupErrorMessages() {\n\tErrorMessages = map[int]string{\n\t\thttp.StatusNotFound:            \"That page doesn't exist\",\n\t\thttp.StatusUnauthorized:        \"You're not Dave! You need to Login!\",\n\t\thttp.StatusInternalServerError: \"Something is going horribly wrong!\",\n\t\thttp.StatusBadRequest:          \"You can't do that!\",\n\t}\n}\n\nfunc httpError(code int, w http.ResponseWriter, req *http.Request, ctx *Context, pjax bool) error {\n\tw.WriteHeader(code)\n\tmessage := \"\"\n\tif _, ok := ErrorMessages[code]; ok {\n\t\tmessage = ErrorMessages[code]\n\t}\n\treturn T(\"error.html\", pjax).Execute(w, map[string]interface{}{\n\t\t\"ctx\":     ctx,\n\t\t\"code\":    code,\n\t\t\"message\": message,\n\t})\n}\n\nfunc notFound(w http.ResponseWriter, req *http.Request, ctx *Context, pjax bool) error {\n\treturn httpError(http.StatusNotFound, w, req, ctx, pjax)\n}\n\nfunc notAuthed(w http.ResponseWriter, req *http.Request, ctx *Context, pjax bool) error {\n\treturn httpError(http.StatusUnauthorized, w, req, ctx, pjax)\n}\n\nfunc InternalError(w http.ResponseWriter, req *http.Request, ctx *Context, pjax bool) error {\n\treturn httpError(http.StatusInternalServerError, w, req, ctx, pjax)\n}\n\n\n\nfunc badRequest(w http.ResponseWriter, req *http.Request, ctx *Context, pjax bool) error ", "output": "{\n\treturn httpError(http.StatusBadRequest, w, req, ctx, pjax)\n}"}
{"input": "package libytc\n\nimport (\n\t\"fmt\"\n\t\"log\"\n)\n\ntype UnknownUpdate struct {\n\tpayload string\n\tchain   string\n\tType    string\n}\n\n\n\nfunc (t *UnknownUpdate) Verify(i interface{}) (err error) {\n\tlog.Fatal(\"Cannot Verify Unknown Update\")\n\treturn\n}\n\nfunc (t *UnknownUpdate) Apply(i interface{}) {\n\tlog.Fatal(\"Cannot Apply Unknown Update\")\n\treturn\n}\n\nfunc (t *UnknownUpdate) Chain() string {\n\treturn t.chain\n}\n\nfunc (t *UnknownUpdate) String() string {\n\treturn fmt.Sprint(t)\n}\n\nfunc (t *UnknownUpdate) MarshallJSON(b []byte, err error) {\n\tb = []byte(t.payload)\n\treturn\n}\n\nfunc NewUnknownUpdate(payload string, chain string, Type string) (t *UnknownUpdate) ", "output": "{\n\tt = new(UnknownUpdate)\n\tt.payload = payload\n\tt.chain = chain\n\tt.Type = Type\n\treturn\n}"}
{"input": "package challenge\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-acme/lego/acme\"\n)\n\n\ntype Type string\n\nconst (\n\tHTTP01 = Type(\"http-01\")\n\n\tDNS01 = Type(\"dns-01\")\n\n\tTLSALPN01 = Type(\"tls-alpn-01\")\n)\n\n\n\nfunc FindChallenge(chlgType Type, authz acme.Authorization) (acme.Challenge, error) {\n\tfor _, chlg := range authz.Challenges {\n\t\tif chlg.Type == string(chlgType) {\n\t\t\treturn chlg, nil\n\t\t}\n\t}\n\n\treturn acme.Challenge{}, fmt.Errorf(\"[%s] acme: unable to find challenge %s\", GetTargetedDomain(authz), chlgType)\n}\n\nfunc GetTargetedDomain(authz acme.Authorization) string {\n\tif authz.Wildcard {\n\t\treturn \"*.\" + authz.Identifier.Value\n\t}\n\treturn authz.Identifier.Value\n}\n\nfunc (t Type) String() string ", "output": "{\n\treturn string(t)\n}"}
{"input": "package builder\n\nimport (\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\n\tvelerov1api \"github.com/vmware-tanzu/velero/pkg/apis/velero/v1\"\n)\n\n\ntype PodVolumeBackupBuilder struct {\n\tobject *velerov1api.PodVolumeBackup\n}\n\n\nfunc ForPodVolumeBackup(ns, name string) *PodVolumeBackupBuilder {\n\treturn &PodVolumeBackupBuilder{\n\t\tobject: &velerov1api.PodVolumeBackup{\n\t\t\tTypeMeta: metav1.TypeMeta{\n\t\t\t\tAPIVersion: velerov1api.SchemeGroupVersion.String(),\n\t\t\t\tKind:       \"PodVolumeBackup\",\n\t\t\t},\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tNamespace: ns,\n\t\t\t\tName:      name,\n\t\t\t},\n\t\t},\n\t}\n}\n\n\nfunc (b *PodVolumeBackupBuilder) Result() *velerov1api.PodVolumeBackup {\n\treturn b.object\n}\n\n\n\n\n\nfunc (b *PodVolumeBackupBuilder) Phase(phase velerov1api.PodVolumeBackupPhase) *PodVolumeBackupBuilder {\n\tb.object.Status.Phase = phase\n\treturn b\n}\n\n\nfunc (b *PodVolumeBackupBuilder) SnapshotID(snapshotID string) *PodVolumeBackupBuilder {\n\tb.object.Status.SnapshotID = snapshotID\n\treturn b\n}\n\n\nfunc (b *PodVolumeBackupBuilder) PodName(name string) *PodVolumeBackupBuilder {\n\tb.object.Spec.Pod.Name = name\n\treturn b\n}\n\n\nfunc (b *PodVolumeBackupBuilder) Volume(volume string) *PodVolumeBackupBuilder {\n\tb.object.Spec.Volume = volume\n\treturn b\n}\n\nfunc (b *PodVolumeBackupBuilder) ObjectMeta(opts ...ObjectMetaOpt) *PodVolumeBackupBuilder ", "output": "{\n\tfor _, opt := range opts {\n\t\topt(b.object)\n\t}\n\n\treturn b\n}"}
{"input": "package operations\n\nimport (\n\t\"github.com/asuleymanov/golos-go/encoding/transaction\"\n\t\"github.com/asuleymanov/golos-go/types\"\n)\n\n\ntype WithdrawVestingOperation struct {\n\tAccount       string       `json:\"account\"`\n\tVestingShares *types.Asset `json:\"vesting_shares\"`\n}\n\n\nfunc (op *WithdrawVestingOperation) Type() OpType {\n\treturn TypeWithdrawVesting\n}\n\n\nfunc (op *WithdrawVestingOperation) Data() interface{} {\n\treturn op\n}\n\n\n\n\nfunc (op *WithdrawVestingOperation) MarshalTransaction(encoder *transaction.Encoder) error ", "output": "{\n\tenc := transaction.NewRollingEncoder(encoder)\n\tenc.EncodeUVarint(uint64(TypeWithdrawVesting.Code()))\n\tenc.Encode(op.Account)\n\tenc.Encode(op.VestingShares)\n\treturn enc.Err()\n}"}
{"input": "package controller\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/pajbot/pajbot2/pkg/web/views\"\n)\n\n\n\nfunc handleProfile(w http.ResponseWriter, r *http.Request) ", "output": "{\n\terr := views.Render(\"profile\", w, r)\n\tif err != nil {\n\t\tlog.Println(\"Error rendering dashboard view:\", err)\n\t}\n}"}
{"input": "package template\n\nimport (\n\t\"github.com/dpb587/metalink\"\n)\n\ntype templateFile metalink.File\n\nfunc (tf templateFile) MD5() string {\n\tfor _, hash := range tf.Hashes {\n\t\tif hash.Type == \"md5\" {\n\t\t\treturn hash.Hash\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\nfunc (tf templateFile) SHA1() string {\n\tfor _, hash := range tf.Hashes {\n\t\tif hash.Type == \"sha-1\" {\n\t\t\treturn hash.Hash\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\nfunc (tf templateFile) SHA256() string {\n\tfor _, hash := range tf.Hashes {\n\t\tif hash.Type == \"sha-256\" {\n\t\t\treturn hash.Hash\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\n\n\nfunc (tf templateFile) SHA512() string ", "output": "{\n\tfor _, hash := range tf.Hashes {\n\t\tif hash.Type == \"sha-512\" {\n\t\t\treturn hash.Hash\n\t\t}\n\t}\n\n\treturn \"\"\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\ntype Error struct {\n\n\tCode int64 `json:\"code,omitempty\"`\n\n\tFields string `json:\"fields,omitempty\"`\n\n\tMessage *string `json:\"message\"`\n}\n\n\nfunc (m *Error) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateMessage(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n\n\nfunc (m *Error) validateMessage(formats strfmt.Registry) error ", "output": "{\n\n\tif err := validate.Required(\"message\", \"body\", m.Message); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package gitlab\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/ovh/cds/sdk\"\n)\n\n\n\n\n\n\nfunc (c *gitlabClient) UploadReleaseFile(ctx context.Context, repo string, releaseName string, uploadURL string, artifactName string, r io.Reader, fileLength int) error {\n\treturn fmt.Errorf(\"not implemented\")\n}\n\nfunc (c *gitlabClient) Release(ctx context.Context, repo string, tagName string, title string, releaseNote string) (*sdk.VCSRelease, error) ", "output": "{\n\treturn nil, fmt.Errorf(\"not implemented\")\n}"}
{"input": "package netx\n\nimport (\n\t\"io\"\n\n\t\"github.com/simia-tech/netx/value\"\n)\n\ntype multicast struct {\n\tlistener io.ReadCloser\n\tconn     io.WriteCloser\n}\n\n\n\nfunc ListenAndDialMulticast(network, readAddress, writeAddress string, options ...value.Option) (io.ReadWriteCloser, error) {\n\tlistener, err := ListenMulticast(network, readAddress, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconn, err := DialMulticast(network, writeAddress, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &multicast{listener: listener, conn: conn}, nil\n}\n\nfunc (m *multicast) Read(buffer []byte) (int, error) {\n\treturn m.listener.Read(buffer)\n}\n\n\n\nfunc (m *multicast) Close() error {\n\tif err := m.listener.Close(); err != nil {\n\t\treturn err\n\t}\n\tif err := m.conn.Close(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (m *multicast) Write(buffer []byte) (int, error) ", "output": "{\n\treturn m.conn.Write(buffer)\n}"}
{"input": "package xbp\n\ntype Conn struct {\n\tProtocol Protocol\n\tnextSeq  uint16\n}\n\nfunc NewConnection(protocol Protocol) *Conn {\n\treturn &Conn{\n\t\tProtocol: protocol,\n\t}\n}\n\nfunc (conn *Conn) getNextSeq() uint16 {\n\tconn.nextSeq++\n\treturn conn.nextSeq\n}\n\nfunc (conn *Conn) sendPacket(flag byte, seq uint16, text string, payload []byte) error {\n\treturn conn.Protocol.SendPacket(&Packet{\n\t\tFlag:    flag,\n\t\tSeq:     seq,\n\t\tText:    text,\n\t\tPayload: payload,\n\t})\n}\n\nfunc (conn *Conn) SendMessage(text string, payload []byte) error {\n\treturn conn.sendPacket(FlagMessage, conn.getNextSeq(), text, payload)\n}\n\nfunc (conn *Conn) SendRequest(text string, payload []byte) (uint16, error) {\n\tseq := conn.getNextSeq()\n\treturn seq, conn.sendPacket(FlagRequest, seq, text, payload)\n}\n\n\n\nfunc (conn *Conn) ReadPacket() (*Packet, error) {\n\treturn conn.Protocol.ReadPacket()\n}\n\nfunc (conn *Conn) Close() error {\n\treturn conn.Protocol.Close()\n}\n\nfunc (conn *Conn) SendResponse(seq uint16, text string, payload []byte) error ", "output": "{\n\treturn conn.sendPacket(FlagResponse, seq, text, payload)\n}"}
{"input": "package mysqlctl\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/youtube/vitess/go/vt/dbconfigs\"\n)\n\n\n\n\nfunc CreateMysqld(tabletUID uint32, mysqlSocket string, mysqlPort int32, dbconfigFlags dbconfigs.DBConfigFlag) (*Mysqld, error) {\n\tmycnf := NewMycnf(tabletUID, mysqlPort)\n\tif err := mycnf.RandomizeMysqlServerID(); err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't generate random MySQL server_id: %v\", err)\n\t}\n\tif mysqlSocket != \"\" {\n\t\tmycnf.SocketFile = mysqlSocket\n\t}\n\n\tdbcfgs, err := dbconfigs.Init(mycnf.SocketFile, dbconfigFlags)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't Init dbconfigs: %v\", err)\n\t}\n\n\treturn NewMysqld(mycnf, dbcfgs, dbconfigFlags), nil\n}\n\n\n\n\n\n\nfunc OpenMysqld(tabletUID uint32, dbconfigFlags dbconfigs.DBConfigFlag) (*Mysqld, error) ", "output": "{\n\tmycnf, err := ReadMycnf(MycnfFile(tabletUID))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't read my.cnf file: %v\", err)\n\t}\n\n\tdbcfgs, err := dbconfigs.Init(mycnf.SocketFile, dbconfigFlags)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't Init dbconfigs: %v\", err)\n\t}\n\n\treturn NewMysqld(mycnf, dbcfgs, dbconfigFlags), nil\n}"}
{"input": "package armmonitor_test\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azidentity\"\n\t\"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/monitor/armmonitor\"\n)\n\n\n\n\n\nfunc ExamplePrivateLinkResourcesClient_Get() {\n\tcred, err := azidentity.NewDefaultAzureCredential(nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to obtain a credential: %v\", err)\n\t}\n\tctx := context.Background()\n\tclient := armmonitor.NewPrivateLinkResourcesClient(\"<subscription-id>\", cred, nil)\n\tres, err := client.Get(ctx,\n\t\t\"<resource-group-name>\",\n\t\t\"<scope-name>\",\n\t\t\"<group-name>\",\n\t\tnil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"Response result: %#v\\n\", res.PrivateLinkResourcesClientGetResult)\n}\n\nfunc ExamplePrivateLinkResourcesClient_ListByPrivateLinkScope() ", "output": "{\n\tcred, err := azidentity.NewDefaultAzureCredential(nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to obtain a credential: %v\", err)\n\t}\n\tctx := context.Background()\n\tclient := armmonitor.NewPrivateLinkResourcesClient(\"<subscription-id>\", cred, nil)\n\tpager := client.ListByPrivateLinkScope(\"<resource-group-name>\",\n\t\t\"<scope-name>\",\n\t\tnil)\n\tfor {\n\t\tnextResult := pager.NextPage(ctx)\n\t\tif err := pager.Err(); err != nil {\n\t\t\tlog.Fatalf(\"failed to advance page: %v\", err)\n\t\t}\n\t\tif !nextResult {\n\t\t\tbreak\n\t\t}\n\t\tfor _, v := range pager.PageResponse().Value {\n\t\t\tlog.Printf(\"Pager result: %#v\\n\", v)\n\t\t}\n\t}\n}"}
{"input": "package kubectl\n\nimport (\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/api/v1\"\n)\n\n\n\n\ntype FilterFunc func(runtime.Object, PrintOptions) bool\n\n\ntype Filters []FilterFunc\n\nfunc NewResourceFilter() Filters {\n\treturn []FilterFunc{\n\t\tfilterPods,\n\t}\n}\n\n\n\n\n\n\nfunc (f Filters) Filter(obj runtime.Object, opts *PrintOptions) (bool, error) {\n\tobj, _ = DecodeUnknownObject(obj)\n\n\tfor _, filter := range f {\n\t\tif ok := filter(obj, *opts); ok {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\n\nfunc DecodeUnknownObject(obj runtime.Object) (runtime.Object, error) {\n\tvar err error\n\n\tswitch obj.(type) {\n\tcase runtime.Unstructured, *runtime.Unknown:\n\t\tif objBytes, err := runtime.Encode(api.Codecs.LegacyCodec(), obj); err == nil {\n\t\t\tif decodedObj, err := runtime.Decode(api.Codecs.UniversalDecoder(), objBytes); err == nil {\n\t\t\t\tobj = decodedObj\n\t\t\t}\n\t\t}\n\t}\n\n\treturn obj, err\n}\n\nfunc filterPods(obj runtime.Object, options PrintOptions) bool ", "output": "{\n\tswitch p := obj.(type) {\n\tcase *v1.Pod:\n\t\treason := string(p.Status.Phase)\n\t\tif p.Status.Reason != \"\" {\n\t\t\treason = p.Status.Reason\n\t\t}\n\t\treturn !options.ShowAll && (reason == string(v1.PodSucceeded) || reason == string(v1.PodFailed))\n\tcase *api.Pod:\n\t\treason := string(p.Status.Phase)\n\t\tif p.Status.Reason != \"\" {\n\t\t\treason = p.Status.Reason\n\t\t}\n\t\treturn !options.ShowAll && (reason == string(api.PodSucceeded) || reason == string(api.PodFailed))\n\t}\n\treturn false\n}"}
{"input": "package metrics\n\nimport (\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/pachyderm/pachyderm/src/client/pkg/uuid\"\n\t\"github.com/pachyderm/pachyderm/src/client/version\"\n\n\t\"go.pedge.io/lion/proto\"\n\tkube \"k8s.io/kubernetes/pkg/client/unversioned\"\n)\n\nvar metrics = &Metrics{}\nvar modified int64\n\n\nfunc AddRepos(num int64) {\n\tatomic.AddInt64(&metrics.Repos, num)\n\tatomic.SwapInt64(&modified, 1)\n}\n\n\nfunc AddCommits(num int64) {\n\tatomic.AddInt64(&metrics.Commits, num)\n\tatomic.SwapInt64(&modified, 1)\n}\n\n\nfunc AddFiles(num int64) {\n\tatomic.AddInt64(&metrics.Files, num)\n\tatomic.SwapInt64(&modified, 1)\n}\n\n\nfunc AddBytes(num int64) {\n\tatomic.AddInt64(&metrics.Bytes, num)\n\tatomic.SwapInt64(&modified, 1)\n}\n\n\n\n\n\nfunc AddPipelines(num int64) {\n\tatomic.AddInt64(&metrics.Pipelines, num)\n\tatomic.SwapInt64(&modified, 1)\n}\n\n\n\nfunc ReportMetrics(clusterID string, kubeClient *kube.Client) {\n\tmetrics.ID = clusterID\n\tmetrics.PodID = uuid.NewWithoutDashes()\n\tmetrics.Version = version.PrettyPrintVersion(version.Version)\n\tfor {\n\t\twrite := atomic.SwapInt64(&modified, 0)\n\t\tif write == 1 {\n\t\t\texternalMetrics(kubeClient, metrics)\n\t\t\tprotolion.Info(metrics)\n\t\t\treportSegment(metrics)\n\t\t}\n\t\t<-time.After(15 * time.Second)\n\t}\n}\n\nfunc AddJobs(num int64) ", "output": "{\n\tatomic.AddInt64(&metrics.Jobs, num)\n\tatomic.SwapInt64(&modified, 1)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/sendgrid/sendgrid-go\"\n\t\"os\"\n)\n\n\n\n\n\nfunc Returnsalistofallpartnersettings() {\n  apiKey := os.Getenv(\"YOUR_SENDGRID_APIKEY\")\n  host := \"https://api.sendgrid.com\"\n  request := sendgrid.GetRequest(apiKey, \"/v3/partner_settings\", host)\n  request.Method = \"GET\"\n  queryParams := make(map[string]string)\n  queryParams[\"limit\"] = \"1\"\n  queryParams[\"offset\"] = \"1\"\n  request.QueryParams = queryParams\n  response, err := sendgrid.API(request)\n  if err != nil {\n    fmt.Println(err)\n  } else {\n    fmt.Println(response.StatusCode)\n    fmt.Println(response.Body)\n    fmt.Println(response.Headers)\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc ReturnsallNewRelicpartnersettings() {\n  apiKey := os.Getenv(\"YOUR_SENDGRID_APIKEY\")\n  host := \"https://api.sendgrid.com\"\n  request := sendgrid.GetRequest(apiKey, \"/v3/partner_settings/new_relic\", host)\n  request.Method = \"GET\"\n  response, err := sendgrid.API(request)\n  if err != nil {\n    fmt.Println(err)\n  } else {\n    fmt.Println(response.StatusCode)\n    fmt.Println(response.Body)\n    fmt.Println(response.Headers)\n  }\n}\n\nfunc main() {\n    \n}\n\nfunc UpdatesNewRelicpartnersettings() ", "output": "{\n  apiKey := os.Getenv(\"YOUR_SENDGRID_APIKEY\")\n  host := \"https://api.sendgrid.com\"\n  request := sendgrid.GetRequest(apiKey, \"/v3/partner_settings/new_relic\", host)\n  request.Method = \"PATCH\"\n  request.Body = []byte(` {\n  \"enable_subuser_statistics\": true, \n  \"enabled\": true, \n  \"license_key\": \"\"\n}`)\n  response, err := sendgrid.API(request)\n  if err != nil {\n    fmt.Println(err)\n  } else {\n    fmt.Println(response.StatusCode)\n    fmt.Println(response.Body)\n    fmt.Println(response.Headers)\n  }\n}"}
{"input": "package waas\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype IpHashLoadBalancingMethod struct {\n}\n\n\n\n\nfunc (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\n\nfunc (m IpHashLoadBalancingMethod) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package qr\n\nimport (\n\t\"github.com/m3o/m3o-go/client\"\n)\n\nfunc NewQrService(token string) *QrService {\n\treturn &QrService{\n\t\tclient: client.NewClient(&client.Options{\n\t\t\tToken: token,\n\t\t}),\n\t}\n}\n\ntype QrService struct {\n\tclient *client.Client\n}\n\n\n\n\ntype GenerateRequest struct {\n\tSize int64 `json:\"size,string\"`\n\tText string `json:\"text\"`\n}\n\ntype GenerateResponse struct {\n\tQr string `json:\"qr\"`\n}\n\nfunc (t *QrService) Generate(request *GenerateRequest) (*GenerateResponse, error) ", "output": "{\n\trsp := &GenerateResponse{}\n\treturn rsp, t.client.Call(\"qr\", \"Generate\", request, rsp)\n}"}
{"input": "package algorithms\n\n\n\nfunc lengthOfLastWord(s string) int ", "output": "{\n\ti := len(s) - 1\n\tfor i >= 0 && s[i] == ' ' {\n\t\ti--\n\t}\n\tend := i\n\tfor i >= 0 && s[i] != ' ' {\n\t\ti--\n\t}\n\treturn end - i\n}"}
{"input": "package unit\n\nimport (\n\t\"github.com/juju/cmd\"\n\t\"github.com/juju/names/v4\"\n\t\"github.com/juju/utils/v2/voyeur\"\n\n\t\"github.com/juju/juju/agent\"\n\t\"github.com/juju/juju/cmd/containeragent/utils\"\n\t\"github.com/juju/juju/cmd/jujud/agent/agentconf\"\n\t\"github.com/juju/juju/worker/logsender\"\n)\n\ntype (\n\tManifoldsConfig    = manifoldsConfig\n\tContainerUnitAgent = containerUnitAgent\n)\n\ntype ContainerUnitAgentTest interface {\n\tcmd.Command\n\tDataDir() string\n\tSetAgentConf(cfg agentconf.AgentConf)\n\tChangeConfig(change agent.ConfigMutator) error\n\tCurrentConfig() agent.Config\n\tTag() names.UnitTag\n\tCharmModifiedVersion() int\n\tGetContainerNames() []string\n}\n\nfunc NewForTest(\n\tctx *cmd.Context,\n\tbufferedLogger *logsender.BufferedLogWriter,\n\tconfigChangedVal *voyeur.Value,\n\tfileReaderWriter utils.FileReaderWriter,\n\tenvironment utils.Environment,\n) ContainerUnitAgentTest {\n\treturn &containerUnitAgent{\n\t\tctx:              ctx,\n\t\tAgentConf:        agentconf.NewAgentConf(\"\"),\n\t\tbufferedLogger:   bufferedLogger,\n\t\tconfigChangedVal: configChangedVal,\n\t\tfileReaderWriter: fileReaderWriter,\n\t\tenvironment:      environment,\n\t}\n}\n\nfunc (c *containerUnitAgent) SetAgentConf(cfg agentconf.AgentConf) {\n\tc.AgentConf = cfg\n}\n\nfunc (c *containerUnitAgent) GetContainerNames() []string {\n\treturn c.containerNames\n}\n\n\n\nfunc (c *containerUnitAgent) DataDir() string ", "output": "{\n\treturn c.AgentConf.DataDir()\n}"}
{"input": "package query\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/EverythingMe/meduza/errors\"\n)\n\n\n\ntype Query interface {\n\tValidate() error\n}\n\ntype Ordering struct {\n\tBy        string `bson:\"by\"`\n\tAscending bool   `bson:\"asc\"`\n}\n\nvar NoOrder = Ordering{Ascending: true}\n\n\nfunc (o Ordering) IsNil() bool {\n\treturn len(o.By) == 0\n}\n\nfunc (o Ordering) Validate() error {\n\treturn nil\n}\n\ntype Paging struct {\n\tOffset int `bson:\"offset\"`\n\tLimit  int `bson:\"limit\"`\n}\n\n\n\n\nvar DefaultPagingLimit = 100\n\ntype Response struct {\n\tTime      time.Duration `bson:\"time\"`\n\tstartTime time.Time\n\tError     *errors.Error `bson:\"error\"`\n}\n\ntype QueryResult interface {\n\tElapsed() time.Duration\n\tErr() error\n}\n\nfunc NewResponse(err error) *Response {\n\n\treturn &Response{\n\t\tstartTime: time.Now(),\n\t\tError:     errors.Wrap(err),\n\t}\n}\n\nfunc (r *Response) Elapsed() time.Duration {\n\treturn r.Time\n}\n\nfunc (r *Response) Err() error {\n\tif r.Error == nil {\n\t\treturn nil\n\t}\n\treturn r.Error\n}\n\nfunc (r *Response) Done() {\n\tr.Time = time.Since(r.startTime)\n}\n\nfunc (r *Response) String() string {\n\treturn fmt.Sprintf(\"Response: {Time: %v, Error: %v}\", r.Time, r.Error)\n}\n\ntype PingQuery struct{}\n\nfunc (PingQuery) Validate() error {\n\treturn nil\n}\n\ntype PingResponse struct {\n\t*Response\n}\n\nfunc NewPingResponse() PingResponse {\n\treturn PingResponse{\n\t\tNewResponse(nil),\n\t}\n}\n\nfunc (p Paging) Validate() error ", "output": "{\n\n\tswitch {\n\tcase p.Offset < 0:\n\t\tfallthrough\n\tcase p.Limit == 0:\n\t\tfallthrough\n\tcase p.Limit < -1:\n\t\treturn errors.NewError(\"Invalid paging parameters: offset: %d, limit: %d\", p.Offset, p.Limit)\n\tdefault:\n\t\treturn nil\n\t}\n\n}"}
{"input": "package iso20022\n\n\ntype DeadlineCode4Choice struct {\n\n\tCode *CorporateActionDeadline1Code `xml:\"Cd\"`\n\n\tProprietary *GenericIdentification47 `xml:\"Prtry\"`\n}\n\nfunc (d *DeadlineCode4Choice) SetCode(value string) {\n\td.Code = (*CorporateActionDeadline1Code)(&value)\n}\n\n\n\nfunc (d *DeadlineCode4Choice) AddProprietary() *GenericIdentification47 ", "output": "{\n\td.Proprietary = new(GenericIdentification47)\n\treturn d.Proprietary\n}"}
{"input": "package util\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tprocCgroup    = \"/proc/self/cgroup\"\n\tsysPidsMaxFmt = \"/sys/fs/cgroup/pids%s/pids.max\"\n)\n\n\n\n\n\n\n\nfunc getCgroupPidsFile() (string, error) {\n\tcgroup, err := os.Open(procCgroup)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer cgroup.Close() \n\n\tscanner := bufio.NewScanner(cgroup)\n\tvar slice string\n\tfor scanner.Scan() {\n\t\tparts := strings.SplitN(scanner.Text(), \":\", 3)\n\t\tif parts == nil || len(parts) < 3 {\n\t\t\tcontinue\n\t\t}\n\t\tif parts[1] == \"pids\" {\n\t\t\tslice = parts[2]\n\n\t\t\tbreak\n\t\t}\n\t}\n\tif slice == \"\" {\n\t\treturn \"\", fmt.Errorf(\"could not find a cgroup for 'pids'\")\n\t}\n\n\tpidsMax := fmt.Sprintf(sysPidsMaxFmt, slice)\n\n\treturn pidsMax, nil\n}\n\n\n\n\n\n\n\nfunc SetPIDLimit(limit int) error {\n\tlimitStr := \"max\"\n\tif limit != -1 {\n\t\tlimitStr = fmt.Sprintf(\"%d\", limit)\n\t}\n\n\tpidsMax, err := getCgroupPidsFile()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tf, err := os.Create(pidsMax)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = f.WriteString(limitStr)\n\tif err != nil {\n\t\tf.Close() \n\n\t\treturn err\n\t}\n\n\treturn f.Close()\n}\n\nfunc GetPIDLimit() (int, error) ", "output": "{\n\tpidsMax, err := getCgroupPidsFile()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tf, err := os.Open(pidsMax) \n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer f.Close() \n\n\tmaxPidsStr, err := bufio.NewReader(f).ReadString('\\n')\n\tif err != nil && !errors.Is(err, io.EOF) {\n\t\treturn 0, err\n\t}\n\tmaxPidsStr = strings.TrimRight(maxPidsStr, \"\\n\")\n\n\tmaxPids := -1\n\tif maxPidsStr != \"max\" {\n\t\tmaxPids, err = strconv.Atoi(maxPidsStr)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\treturn maxPids, nil\n}"}
{"input": "package poll\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"os\"\n)\n\n\n\nfunc getVCAPApplicationID() (string, error) ", "output": "{\n\tvcapJSONContainer := make(map[string]interface{})\n\terr := json.Unmarshal([]byte(os.Getenv(\"VCAP_APPLICATION\")), &vcapJSONContainer)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"Error in reading VCAP Application properties: \" + err.Error())\n\t}\n\tappID, ok := vcapJSONContainer[\"application_id\"].(string)\n\tif !ok {\n\t\treturn \"\", errors.New(\"Cannot Read Application Name from VCAP Application properties: string type assertion failed\")\n\t}\n\treturn appID, nil\n}"}
{"input": "package iso20022\n\n\ntype AccountManagementConfirmation3 struct {\n\n\tConfirmationType *AccountManagementType2Code `xml:\"ConfTp\"`\n\n\tAccountApplicationIdentification *Max35Text `xml:\"AcctApplId,omitempty\"`\n\n\tClientReference *Max35Text `xml:\"ClntRef,omitempty\"`\n\n\tCounterpartyReference *AdditionalReference6 `xml:\"CtrPtyRef,omitempty\"`\n\n\tExistingAccountIdentification *Max35Text `xml:\"ExstgAcctId,omitempty\"`\n}\n\nfunc (a *AccountManagementConfirmation3) SetConfirmationType(value string) {\n\ta.ConfirmationType = (*AccountManagementType2Code)(&value)\n}\n\nfunc (a *AccountManagementConfirmation3) SetAccountApplicationIdentification(value string) {\n\ta.AccountApplicationIdentification = (*Max35Text)(&value)\n}\n\nfunc (a *AccountManagementConfirmation3) SetClientReference(value string) {\n\ta.ClientReference = (*Max35Text)(&value)\n}\n\n\n\nfunc (a *AccountManagementConfirmation3) SetExistingAccountIdentification(value string) {\n\ta.ExistingAccountIdentification = (*Max35Text)(&value)\n}\n\nfunc (a *AccountManagementConfirmation3) AddCounterpartyReference() *AdditionalReference6 ", "output": "{\n\ta.CounterpartyReference = new(AdditionalReference6)\n\treturn a.CounterpartyReference\n}"}
{"input": "package views\n\nimport \"github.com/cSploit/daemon/models\"\n\ntype networkIdxElem struct {\n\tmodels.Network\n\tHideHosts string `json:\"hosts,omitempty\"`\n}\n\ntype networkShowView struct {\n\tmodels.Network\n\tOverrideHosts interface{} `json:\"hosts,omitempty\"`\n}\n\nfunc NetworkIndex(args interface{}) interface{} {\n\tnets := args.([]models.Network)\n\tres := make([]networkIdxElem, len(nets))\n\n\tfor i, n := range nets {\n\t\tres[i] = networkIdxElem{Network: n}\n\t}\n\n\treturn res\n}\n\n\n\nfunc networkAsChild(arg interface{}) interface{} {\n\tnetwork := arg.(models.Network)\n\treturn networkIdxElem{Network: network}\n}\n\nfunc NetworkShow(arg interface{}) interface{} ", "output": "{\n\tnet := arg.(models.Network)\n\tres := networkShowView{Network: net}\n\n\tif len(net.Hosts) > 0 {\n\t\tres.OverrideHosts = HostsIndex(net.Hosts)\n\t}\n\n\treturn res\n}"}
{"input": "package errors\n\nimport (\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"runtime\"\n)\n\n\n\n\n\n\n\n\nfunc NewErrorCaller(skip int, fmt_ string, arg_ ...interface{}) error {\n\tpc, file, line, ok := runtime.Caller(skip + 1)\n\tvar funcname string = \"nofunc\"\n\tif ok {\n\t\tfuncname = runtime.FuncForPC(pc).Name()\n\t}\n\treturn &Error{\n\t\tFile: file,\n\t\tLine: line,\n\t\tFunc: funcname,\n\t\tBody: fmt.Sprintf(fmt_, arg_...),\n\t}\n}\n\n\nfunc NewError(fmt_ string, arg_ ...interface{}) error {\n\treturn NewErrorCaller(1, fmt_, arg_...)\n}\n\n\nfunc NewPanic(r interface{}) error {\n\treturn NewErrorCaller(1, \"panic enclosure (%v)\", r)\n}\n\n\nfunc Pack(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\treturn NewErrorCaller(1, \"%s\", err.Error())\n}\n\n\n\ntype Error struct {\n\tFile string\n\tLine int\n\tFunc string\n\tBody string\n}\n\nfunc (e *Error) Error() string {\n\treturn e.Body\n}\n\nfunc Unpack(x interface{}) error {\n\tif x == nil {\n\t\treturn nil\n\t}\n\treturn x.(error)\n}\n\nfunc init() ", "output": "{\n\tgob.Register(&Error{})\n}"}
{"input": "package net\n\nimport (\n\t\"net\"\n\t\"reflect\"\n\n\t\"github.com/segmentio/objconv\"\n)\n\nfunc init() {\n\tobjconv.Install(reflect.TypeOf(net.TCPAddr{}), TCPAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.UDPAddr{}), UDPAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.UnixAddr{}), UnixAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.IPAddr{}), IPAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.IP(nil)), IPAdapter())\n}\n\n\nfunc TCPAddrAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeTCPAddr,\n\t\tDecode: decodeTCPAddr,\n\t}\n}\n\n\nfunc UDPAddrAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeUDPAddr,\n\t\tDecode: decodeUDPAddr,\n\t}\n}\n\n\n\n\n\nfunc IPAddrAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeIPAddr,\n\t\tDecode: decodeIPAddr,\n\t}\n}\n\n\nfunc IPAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeIP,\n\t\tDecode: decodeIP,\n\t}\n}\n\nfunc UnixAddrAdapter() objconv.Adapter ", "output": "{\n\treturn objconv.Adapter{\n\t\tEncode: encodeUnixAddr,\n\t\tDecode: decodeUnixAddr,\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\nfunc setupSignalHandlers() {\n\tsignalChan := make(chan os.Signal, 1)\n\tsignal.Notify(signalChan, os.Interrupt, os.Kill, syscall.SIGTERM)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase signal := <-signalChan:\n\t\t\t\tcui.ln(\"Received\", signal, \"- exiting...\")\n\t\t\t\tos.Exit(0)\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc fatalWithErr(desc string, err error) {\n\tcui.ln(desc)\n\tcui.ln(\"Reason:\", err)\n\tcui.ln(\"Bye...\")\n\tcui.ln(\"\")\n\tos.Exit(1)\n}\n\n\n\nfunc fatal(desc string) ", "output": "{\n\tcui.ln(desc)\n\tcui.ln(\"Bye...\")\n\tcui.ln(\"\")\n\tos.Exit(1)\n}"}
{"input": "package v1\n\n\n\ntype SubjectApplyConfiguration struct {\n\tKind      *string `json:\"kind,omitempty\"`\n\tAPIGroup  *string `json:\"apiGroup,omitempty\"`\n\tName      *string `json:\"name,omitempty\"`\n\tNamespace *string `json:\"namespace,omitempty\"`\n}\n\n\n\nfunc Subject() *SubjectApplyConfiguration {\n\treturn &SubjectApplyConfiguration{}\n}\n\n\n\n\nfunc (b *SubjectApplyConfiguration) WithKind(value string) *SubjectApplyConfiguration {\n\tb.Kind = &value\n\treturn b\n}\n\n\n\n\n\n\n\n\n\nfunc (b *SubjectApplyConfiguration) WithName(value string) *SubjectApplyConfiguration {\n\tb.Name = &value\n\treturn b\n}\n\n\n\n\nfunc (b *SubjectApplyConfiguration) WithNamespace(value string) *SubjectApplyConfiguration {\n\tb.Namespace = &value\n\treturn b\n}\n\nfunc (b *SubjectApplyConfiguration) WithAPIGroup(value string) *SubjectApplyConfiguration ", "output": "{\n\tb.APIGroup = &value\n\treturn b\n}"}
{"input": "package openstack\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\t\"github.com/go-ini/ini\"\n\t\"github.com/rancher/types/apis/management.cattle.io/v3\"\n)\n\nconst (\n\tOpenstackCloudProviderName = \"openstack\"\n)\n\ntype CloudProvider struct {\n\tConfig *v3.OpenstackCloudProvider\n\tName   string\n}\n\nfunc GetInstance() *CloudProvider {\n\treturn &CloudProvider{}\n}\n\nfunc (p *CloudProvider) Init(cloudProviderConfig v3.CloudProvider) error {\n\tif cloudProviderConfig.OpenstackCloudProvider == nil {\n\t\treturn fmt.Errorf(\"Openstack Cloud Provider Config is empty\")\n\t}\n\tp.Name = OpenstackCloudProviderName\n\tif cloudProviderConfig.Name != \"\" {\n\t\tp.Name = cloudProviderConfig.Name\n\t}\n\tp.Config = cloudProviderConfig.OpenstackCloudProvider\n\treturn nil\n}\n\n\n\nfunc (p *CloudProvider) GenerateCloudConfigFile() (string, error) {\n\tbuf := new(bytes.Buffer)\n\tcloudConfig, _ := ini.LoadSources(ini.LoadOptions{IgnoreInlineComment: true}, []byte(\"\"))\n\tif err := ini.ReflectFrom(cloudConfig, p.Config); err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to parse Openstack cloud config\")\n\t}\n\tif _, err := cloudConfig.WriteTo(buf); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn buf.String(), nil\n}\n\nfunc (p *CloudProvider) GetName() string ", "output": "{\n\treturn p.Name\n}"}
{"input": "package api\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n)\n\ntype PageToken struct {\n\tLimit uint16\n\tPage  uint16\n}\n\nfunc DefaultPageToken(limit uint16) PageToken {\n\treturn PageToken{Limit: limit, Page: 1}\n}\n\nfunc (tok PageToken) Next() PageToken {\n\treturn PageToken{Limit: tok.Limit, Page: tok.Page + 1}\n}\n\n\n\nfunc decodePageToken(value string) (*PageToken, error) {\n\tdec, err := base64.URLEncoding.DecodeString(value)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdb := bytes.NewBuffer(dec)\n\n\tvar tok PageToken\n\terr = binary.Read(db, binary.LittleEndian, &tok)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &tok, nil\n}\n\nfunc findNextPageToken(u *url.URL, limit uint16) (*PageToken, error) {\n\tvalues := u.Query()[\"nextPageToken\"]\n\n\tif len(values) > 1 {\n\t\treturn nil, errors.New(\"too many values for page token\")\n\t}\n\n\tif len(values) == 0 {\n\t\treturn nil, nil\n\t}\n\n\tval := values[0]\n\ttok, err := decodePageToken(val)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = validatePageToken(tok, limit)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn tok, nil\n}\n\nfunc validatePageToken(tok *PageToken, limit uint16) error {\n\tif tok.Limit != limit {\n\t\treturn fmt.Errorf(\"token limit must be %d\", limit)\n\t}\n\n\tif tok.Page == 0 {\n\t\treturn errors.New(\"token page must be greater than zero\")\n\t}\n\n\treturn nil\n}\n\nfunc (tok PageToken) Encode() string ", "output": "{\n\tbuf := bytes.Buffer{}\n\tbinary.Write(&buf, binary.LittleEndian, tok)\n\treturn base64.URLEncoding.EncodeToString(buf.Bytes())\n}"}
{"input": "package document\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestNumericField(t *testing.T) ", "output": "{\n\tnf := NewNumericField(\"age\", []uint64{}, 3.4)\n\tnf.Analyze()\n\tnumTokens := nf.AnalyzedLength()\n\ttokenFreqs := nf.AnalyzedTokenFrequencies()\n\tif numTokens != 16 {\n\t\tt.Errorf(\"expected 16 tokens\")\n\t}\n\tif len(tokenFreqs) != 16 {\n\t\tt.Errorf(\"expected 16 token freqs\")\n\t}\n}"}
{"input": "package config\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\n\t\"github.com/spf13/viper\"\n)\n\n\n\n\n\nfunc init() {\n\tif flag.Lookup(\"test.v\") != nil {\n\t\treturn\n\t}\n\n\tsetAPIDefaults()\n\tsetDaemonDefaults()\n\n\tviper.SetConfigType(\"toml\")\n\tviper.SetConfigName(\"config\")\n\tviper.AddConfigPath(\".\")\n\terr := viper.ReadInConfig()\n\tif err != nil {\n\t\tfmt.Println(\"ERROR: Error reading config file: \", err)\n\t}\n}\n\n\n\n\n\nfunc GetString(property string) string {\n\tresult := viper.GetString(property)\n\tif result == \"\" {\n\t\tfmt.Println(\"WARN: Property \" + property + \" is \\\"\\\". Is this not set?\")\n\t}\n\treturn result\n}\n\n\nfunc GetBool(property string) bool {\n\treturn viper.GetBool(property)\n}\n\nfunc GetInt(property string) int ", "output": "{\n\tresult := viper.GetInt(property)\n\tif result == 0 {\n\t\tfmt.Println(\"WARN: Property \" + property + \" is 0. Is this not set?\")\n\t}\n\treturn result\n}"}
{"input": "package renderer\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/ghodss/yaml\"\n\t\"github.com/nuclio/errors\"\n\t\"github.com/olekukonko/tablewriter\"\n)\n\ntype Renderer struct {\n\toutput io.Writer\n}\n\nfunc NewRenderer(output io.Writer) *Renderer {\n\treturn &Renderer{\n\t\toutput: output,\n\t}\n}\n\nfunc (r *Renderer) RenderTable(header []string, records [][]string) {\n\ttableWriter := tablewriter.NewWriter(r.output)\n\ttableWriter.SetHeader(header)\n\ttableWriter.SetBorders(tablewriter.Border{Left: false, Top: false, Right: false, Bottom: false})\n\ttableWriter.SetCenterSeparator(\"|\")\n\ttableWriter.SetHeaderLine(false)\n\ttableWriter.AppendBulk(records)\n\ttableWriter.Render()\n}\n\n\n\nfunc (r *Renderer) RenderJSON(items interface{}) error {\n\tbody, err := json.Marshal(items)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Failed to render JSON\")\n\t}\n\n\tvar pbody bytes.Buffer\n\terr = json.Indent(&pbody, body, \"\", \"\\t\")\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Failed to indent JSON\")\n\t}\n\n\tfmt.Fprintln(r.output, pbody.String()) \n\n\treturn nil\n}\n\nfunc (r *Renderer) RenderYAML(items interface{}) error ", "output": "{\n\tbody, err := yaml.Marshal(items)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Failed to render YAML\")\n\t}\n\n\tfmt.Fprintln(r.output, string(body)) \n\n\treturn nil\n}"}
{"input": "package utils\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"reflect\"\n\t\"time\"\n\n\t_ \"github.com/akutz/golf\"\n\n\t\"github.com/codedellemc/rexray/libstorage/api/context\"\n\t\"github.com/codedellemc/rexray/libstorage/api/types\"\n)\n\n\n\n\n\n\nfunc GetTempSockFile(ctx types.Context) string {\n\n\tf, err := ioutil.TempFile(context.MustPathConfig(ctx).Run, \"\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tname := f.Name()\n\tos.RemoveAll(name)\n\treturn fmt.Sprintf(\"%s.sock\", name)\n}\n\n\nfunc DeviceAttachTimeout(val string) time.Duration {\n\tdur, err := time.ParseDuration(val)\n\tif err != nil {\n\t\treturn time.Duration(30) * time.Second\n\t}\n\treturn dur\n}\n\nfunc GetTypePkgPathAndName(i interface{}) string ", "output": "{\n\tt := reflect.TypeOf(i)\n\tif t.Kind() == reflect.Ptr || t.Kind() == reflect.Interface {\n\t\tt = t.Elem()\n\t}\n\tpkgPath := t.PkgPath()\n\ttypeName := t.Name()\n\tif pkgPath == \"\" {\n\t\treturn typeName\n\t}\n\treturn fmt.Sprintf(\"%s.%s\", pkgPath, typeName)\n}"}
{"input": "package safetime\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/sirupsen/logrus\"\n\t. \"gopkg.in/check.v1\"\n)\n\n\nfunc Test(t *testing.T) {\n\tTestingT(t)\n}\n\ntype SafetimeSuite struct {\n\tout    *bytes.Buffer \n\tlogger *logrus.Entry\n}\n\nvar _ = Suite(&SafetimeSuite{})\n\nfunc (s *SafetimeSuite) SetUpTest(c *C) {\n\ts.out = &bytes.Buffer{}\n\tlogger := logrus.New()\n\tlogger.Out = s.out\n\ts.logger = logrus.NewEntry(logger)\n}\n\n\n\nfunc (s *SafetimeSuite) TestNonNegativeDuration(c *C) {\n\tpast := time.Now().Add(-10 * time.Second)\n\td, ok := TimeSinceSafe(past, s.logger)\n\n\tc.Assert(ok, Equals, true)\n\tc.Assert(d > time.Duration(0), Equals, true)\n\tc.Assert(len(s.out.String()) == 0, Equals, true)\n}\n\nfunc (s *SafetimeSuite) TestNegativeDuration(c *C) ", "output": "{\n\tfuture := time.Now().Add(time.Second)\n\td, ok := TimeSinceSafe(future, s.logger)\n\n\tc.Assert(ok, Equals, false)\n\tc.Assert(d, Equals, time.Duration(0))\n\tfmt.Println(s.out.String())\n\tc.Assert(strings.Contains(s.out.String(), \"BUG: negative duration\"), Equals, true)\n}"}
{"input": "package cachestore\n\nimport (\n\t\"encoding/json\"\n\t\"sync\"\n)\n\n\ntype CacheStore struct {\n\tstores map[string]*KVStore\n\tmutex  sync.RWMutex\n}\n\n\n\nfunc (c *CacheStore) GetStore(svcName string) *KVStore {\n\tc.mutex.RLock()\n\tkvstore := c.stores[svcName]\n\tc.mutex.RUnlock()\n\n\treturn kvstore\n}\n\n\n\nfunc (c *CacheStore) CreateStore(svcName string) *KVStore {\n\tkvstore := NewKVStore()\n\tc.mutex.Lock()\n\tc.stores[svcName] = kvstore\n\tc.mutex.Unlock()\n\n\treturn kvstore\n}\n\n\nfunc (c *CacheStore) DeleteStore(svcName string) {\n\tc.mutex.Lock()\n\tdelete(c.stores, svcName)\n\tc.mutex.Unlock()\n}\n\n\nfunc (c *CacheStore) SetCache(svcName string, key string, value interface{}) {\n\tsvcStore := c.GetStore(svcName)\n\tif svcStore == nil {\n\t\tsvcStore = c.CreateStore(svcName)\n\t}\n\n\tsvcStore.Set(key, value)\n}\n\n\n\n\n\n\nfunc (c *CacheStore) DeleteCache(svcName string, key string) {\n\tsvcStore := c.GetStore(svcName)\n\tif svcStore != nil {\n\t\tsvcStore.Delete(key)\n\t}\n}\n\n\nfunc (c *CacheStore) MarshalJSON() ([]byte, error) {\n\tc.mutex.RLock()\n\tbytes, err := json.Marshal(&c.stores)\n\tc.mutex.RUnlock()\n\treturn bytes, err\n}\n\n\nfunc NewCacheStore() *CacheStore {\n\treturn &CacheStore{map[string]*KVStore{}, sync.RWMutex{}}\n}\n\nfunc (c *CacheStore) GetCache(svcName string, key string) interface{} ", "output": "{\n\tsvcStore := c.GetStore(svcName)\n\tif svcStore == nil {\n\t\treturn nil\n\t}\n\treturn svcStore.Get(key)\n}"}
{"input": "package endpoints\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype Service interface {\n\tServe(path string, w http.ResponseWriter, r *http.Request) bool\n\tClose() error\n}\n\nfunc WriteJSON(data interface{}, w http.ResponseWriter) bool ", "output": "{\n\tbytes, err := json.Marshal(data)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn false\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t_, err = w.Write(bytes)\n\treturn err == nil\n}"}
{"input": "package http\n\nimport (\n\t\"github.com/wcong/ants-go/ants/util\"\n\t\"log\"\n\tHttp \"net/http\"\n\t\"strconv\"\n\t\"sync\"\n)\n\ntype HttpServer struct {\n\tHttp.Server\n}\n\nfunc NewHttpServer(setting *util.Settings, handler Http.Handler) *HttpServer {\n\tport := strconv.Itoa(setting.HttpPort)\n\thttpServer := &HttpServer{\n\t\tHttp.Server{\n\t\t\tAddr:    \":\" + port,\n\t\t\tHandler: handler,\n\t\t},\n\t}\n\treturn httpServer\n}\n\n\n\nfunc (this *HttpServer) server(wg sync.WaitGroup) {\n\tlog.Println(\"start to server http\" + this.Addr)\n\terr := this.ListenAndServe()\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\tlog.Println(\"http server down\")\n\twg.Done()\n}\n\nfunc (this *HttpServer) Start(wg sync.WaitGroup) ", "output": "{\n\tgo this.server(wg)\n}"}
{"input": "package rule\n\ntype InvalidRuleError struct {\n\tRule Rule\n}\n\ntype IncompatibleTypesRuleError struct {\n\tRule Rule\n}\n\ntype InvalidExprError struct {\n\tExpr string\n}\n\n\n\nfunc (e IncompatibleTypesRuleError) Error() string {\n\treturn \"incompatible types in rule: \" + e.Rule.String()\n}\n\nfunc (e InvalidExprError) Error() string {\n\treturn \"invalid expression in rule: \" + e.Expr\n}\n\ntype InvalidRuleFieldError string\n\nfunc (e InvalidRuleFieldError) Error() string {\n\treturn \"invalid rule field: \" + string(e)\n}\n\nfunc (e InvalidRuleError) Error() string ", "output": "{\n\treturn \"invalid rule: \" + e.Rule.String()\n}"}
{"input": "package types\n\nimport (\n\t\"github.com/coreos/ignition/config/shared/errors\"\n\t\"github.com/coreos/ignition/config/validate/report\"\n)\n\ntype Filesystem struct {\n\tName  string           `json:\"name,omitempty\"`\n\tMount *FilesystemMount `json:\"mount,omitempty\"`\n\tPath  *Path            `json:\"path,omitempty\"`\n}\n\ntype FilesystemMount struct {\n\tDevice Path              `json:\"device,omitempty\"`\n\tFormat FilesystemFormat  `json:\"format,omitempty\"`\n\tCreate *FilesystemCreate `json:\"create,omitempty\"`\n}\n\ntype FilesystemCreate struct {\n\tForce   bool        `json:\"force,omitempty\"`\n\tOptions MkfsOptions `json:\"options,omitempty\"`\n}\n\n\n\ntype FilesystemFormat string\n\nfunc (f FilesystemFormat) Validate() report.Report {\n\tswitch f {\n\tcase \"ext4\", \"btrfs\", \"xfs\":\n\t\treturn report.Report{}\n\tdefault:\n\t\treturn report.ReportFromError(errors.ErrFilesystemInvalidFormat, report.EntryError)\n\t}\n}\n\ntype MkfsOptions []string\n\nfunc (f Filesystem) Validate() report.Report ", "output": "{\n\tif f.Mount == nil && f.Path == nil {\n\t\treturn report.ReportFromError(errors.ErrFilesystemNoMountPath, report.EntryError)\n\t}\n\tif f.Mount != nil && f.Path != nil {\n\t\treturn report.ReportFromError(errors.ErrFilesystemMountAndPath, report.EntryError)\n\t}\n\treturn report.Report{}\n}"}
{"input": "package connmgr\n\nimport \"github.com/abcsuite/abclog\"\n\n\n\n\nvar log abclog.Logger\n\n\nfunc init() {\n\tDisableLog()\n}\n\n\n\nfunc DisableLog() {\n\tlog = abclog.Disabled\n}\n\n\n\n\n\n\nfunc UseLogger(logger abclog.Logger) ", "output": "{\n\tlog = logger\n}"}
{"input": "package example\n\nimport (\n\t\"testing\"\n\t\"github.com/remogatto/prettytest\"\n\t\"launchpad.net/gocheck\"\n)\n\n\n\ntype testSuite struct {\n\tprettytest.Suite\n}\n\nfunc TestRunner(t *testing.T) {\n\tprettytest.Run(\n\t\tt,\n\t\tnew(testSuite),\n\t)\n}\n\n\n\n\n\n\nfunc (t *testSuite) TestTrueIsTrue() {\n\tt.True(true)\n}\n\nfunc (t *testSuite) TestEquality() {\n\tt.Equal(\"awesome\", \"awesome\")\n}\n\nfunc (t *testSuite) TestNot() {\n\tt.Not(t.Path(\"foo\"))\n}\n\nfunc (t *testSuite) TestGoCheck() {\n\tt.Check(\"foo\", gocheck.Equals, \"foo\")\n}\n\n\n\n\n\nfunc (t *testSuite) TestInequality() {\n\tt.Equal(\"awesome\", \"ugly\")\n\tt.MustFail()\n}\n\nfunc (t *testSuite) TestMustFail() ", "output": "{\n\tt.Error(\"This test must fail.\")\n\tt.MustFail()\n}"}
{"input": "package middlewares\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc NewBodySizeLimitMiddleware(bodySizeLimit uint64) *BodySizeLimitMiddleware {\n\treturn &BodySizeLimitMiddleware{bodySizeLimit: bodySizeLimit}\n}\n\ntype BodySizeLimitMiddleware struct {\n\tbodySizeLimit uint64\n}\n\n\n\nfunc (middleware *BodySizeLimitMiddleware) ServeHTTP(responseWriter http.ResponseWriter, request *http.Request, next http.HandlerFunc) ", "output": "{\n\tif middleware.bodySizeLimit != 0 {\n\t\tif request.ContentLength == -1 {\n\t\t\tresponseWriter.WriteHeader(http.StatusBadRequest)\n\t\t\tfmt.Fprintf(responseWriter, \"Please provide the header field Content-Length\")\n\t\t\treturn\n\t\t}\n\t\tif uint64(request.ContentLength) > middleware.bodySizeLimit {\n\n\t\t\tdefer request.Body.Close()\n\t\t\tio.Copy(ioutil.Discard, request.Body)\n\n\t\t\tresponseWriter.WriteHeader(http.StatusRequestEntityTooLarge)\n\t\t\treturn\n\t\t}\n\t}\n\tnext(responseWriter, request)\n}"}
{"input": "package fake\n\nimport (\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\n\taction \"github.com/vmware-tanzu/octant/pkg/action\"\n)\n\n\ntype MockActionRegistrar struct {\n\tctrl     *gomock.Controller\n\trecorder *MockActionRegistrarMockRecorder\n}\n\n\ntype MockActionRegistrarMockRecorder struct {\n\tmock *MockActionRegistrar\n}\n\n\nfunc NewMockActionRegistrar(ctrl *gomock.Controller) *MockActionRegistrar {\n\tmock := &MockActionRegistrar{ctrl: ctrl}\n\tmock.recorder = &MockActionRegistrarMockRecorder{mock}\n\treturn mock\n}\n\n\nfunc (m *MockActionRegistrar) EXPECT() *MockActionRegistrarMockRecorder {\n\treturn m.recorder\n}\n\n\nfunc (m *MockActionRegistrar) Register(arg0, arg1 string, arg2 action.DispatcherFunc) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Register\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n\n\n\n\nfunc (m *MockActionRegistrar) Unregister(arg0, arg1 string) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Unregister\", arg0, arg1)\n}\n\n\nfunc (mr *MockActionRegistrarMockRecorder) Unregister(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Unregister\", reflect.TypeOf((*MockActionRegistrar)(nil).Unregister), arg0, arg1)\n}\n\nfunc (mr *MockActionRegistrarMockRecorder) Register(arg0, arg1, arg2 interface{}) *gomock.Call ", "output": "{\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Register\", reflect.TypeOf((*MockActionRegistrar)(nil).Register), arg0, arg1, arg2)\n}"}
{"input": "package db\n\n\n\ntype Image struct {\n\tID int\n\n\tName string\n\n\tDockerfile string\n\n\tDockerID string\n}\n\n\nfunc (db Database) InsertImage() Image {\n\tresult := Image{ID: db.nextID()}\n\tdb.insert(result)\n\treturn result\n}\n\n\nfunc (db Database) SelectFromImage(check func(Image) bool) []Image {\n\timageTable := db.accessTable(ImageTable)\n\tresult := []Image{}\n\tfor _, row := range imageTable.rows {\n\t\tif check == nil || check(row.(Image)) {\n\t\t\tresult = append(result, row.(Image))\n\t\t}\n\t}\n\treturn result\n}\n\nfunc (image Image) getID() int {\n\treturn image.ID\n}\n\nfunc (image Image) tt() TableType {\n\treturn ImageTable\n}\n\nfunc (image Image) String() string {\n\treturn defaultString(image)\n}\n\nfunc (image Image) less(r row) bool {\n\treturn image.ID < r.(Image).ID\n}\n\n\ntype ImageSlice []Image\n\n\nfunc (slc ImageSlice) Get(ii int) interface{} {\n\treturn slc[ii]\n}\n\n\n\n\nfunc (slc ImageSlice) Len() int ", "output": "{\n\treturn len(slc)\n}"}
{"input": "package ast\n\n\ntype AsmLabelAttr struct {\n\tAddr           Address\n\tPos            Position\n\tInherited      bool\n\tFunctionName   string\n\tChildNodes     []Node\n\tIsLiteralLabel bool\n}\n\n\n\n\n\nfunc (n *AsmLabelAttr) AddChild(node Node) {\n\tn.ChildNodes = append(n.ChildNodes, node)\n}\n\n\n\nfunc (n *AsmLabelAttr) Address() Address {\n\treturn n.Addr\n}\n\n\n\nfunc (n *AsmLabelAttr) Children() []Node {\n\treturn n.ChildNodes\n}\n\n\nfunc (n *AsmLabelAttr) Position() Position {\n\treturn n.Pos\n}\n\nfunc parseAsmLabelAttr(line string) *AsmLabelAttr ", "output": "{\n\tgroups := groupsFromRegex(\n\t\t`<(?P<position>.*)>\n\t\t(?P<inherited> Inherited)?\n\t\t \"(?P<function>.+)\"\n\t\t(?P<literal> IsLiteralLabel)?`,\n\t\tline,\n\t)\n\n\treturn &AsmLabelAttr{\n\t\tAddr:           ParseAddress(groups[\"address\"]),\n\t\tPos:            NewPositionFromString(groups[\"position\"]),\n\t\tInherited:      len(groups[\"inherited\"]) > 0,\n\t\tFunctionName:   groups[\"function\"],\n\t\tChildNodes:     []Node{},\n\t\tIsLiteralLabel: len(groups[\"literal\"]) > 0,\n\t}\n}"}
{"input": "package local\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os/user\"\n\t\"path/filepath\"\n\n\tgoyaml \"gopkg.in/yaml.v2\"\n)\n\n\n\ntype BoshConfig struct {\n\tTarget         string\n\tName           string `yaml:\"target_name\"`\n\tVersion        string `yaml:\"target_version\"`\n\tUUID           string `yaml:\"target_uuid\"`\n\tAliases        map[string]map[string]string\n\tAuthentication map[string]*authentication `yaml:\"auth\"`\n\tDeployments    map[string]string          `yaml:\"deployment\"`\n}\n\ntype authentication struct {\n\tUsername string\n\tPassword string\n}\n\n\nfunc LoadBoshConfig(configPath string) (config *BoshConfig, err error) {\n\tconfig = &BoshConfig{}\n\n\tcontents, err := ioutil.ReadFile(configPath)\n\tif err != nil {\n\t\treturn config, err\n\t}\n\tgoyaml.Unmarshal(contents, config)\n\treturn\n}\n\n\nfunc DefaultBoshConfigPath() (configPath string, err error) {\n\tusr, err := user.Current()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn filepath.Abs(usr.HomeDir + \"/.bosh_config\")\n}\n\n\nfunc (config *BoshConfig) CurrentBoshTarget() (target, username, password string, err error) {\n\tif config.Target == \"\" {\n\t\treturn \"\", \"\", \"\", errors.New(\"Please target a BOSH first. Run 'bosh target DIRECTOR_IP'.\")\n\t}\n\tauth := config.Authentication[config.Target]\n\tif auth == nil {\n\t\treturn \"\", \"\", \"\", errors.New(\"Current target has not been authenticated yet. Run 'bosh login'.\")\n\t}\n\treturn config.Target, auth.Username, auth.Password, nil\n}\n\n\n\n\nfunc (config *BoshConfig) CurrentDeploymentManifest() (manifestPath string) ", "output": "{\n\treturn config.Deployments[config.Target]\n}"}
{"input": "package gateway\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/rs/zerolog\"\n)\n\n\ntype LogLevel zerolog.Level\n\n\nconst (\n\tLogDebug LogLevel = LogLevel(zerolog.DebugLevel)\n\tLogInfo  LogLevel = LogLevel(zerolog.InfoLevel)\n\tLogWarn  LogLevel = LogLevel(zerolog.WarnLevel)\n\tLogError LogLevel = LogLevel(zerolog.ErrorLevel)\n)\n\n\nvar Logger zerolog.Logger\n\n\nfunc InitLogging(sink io.Writer) {\n\tLogger = zerolog.New(sink)\n\tzerolog.SetGlobalLevel(zerolog.InfoLevel)\n}\n\n\n\nfunc ConfigLogging(cfg *Config) {\n\tif cfg.LogTimestamps {\n\t\tLogger = Logger.With().Timestamp().Logger()\n\t}\n\tlev := zerolog.InfoLevel\n\tif l, err := zerolog.ParseLevel(cfg.LogLevel); err == nil {\n\t\tlev = l\n\t}\n\tzerolog.SetGlobalLevel(lev)\n}\n\n\n\n\n\n\n\nfunc LogC(ctx context.Context, component string, level LogLevel) *zerolog.Event {\n\treqID, _ := ctx.Value(IDKey).(uuid.UUID)\n\tt0, _ := ctx.Value(T0Key).(time.Time)\n\n\treturn Log(component, level).\n\t\tStr(\"req_id\", reqID.String()).\n\t\tDur(\"req_dt\", time.Since(t0))\n}\n\n\n\n\n\nfunc Log(component string, level LogLevel) *zerolog.Event ", "output": "{\n\tvar event *zerolog.Event\n\tswitch level {\n\tcase LogDebug:\n\t\tevent = Logger.Debug()\n\tcase LogInfo:\n\t\tevent = Logger.Info()\n\tcase LogError:\n\t\tevent = Logger.Error()\n\tdefault:\n\t\tLogger.Error().\n\t\t\tStr(\"component\", \"logger\").\n\t\t\tMsgf(\"unknown log level: %v\", level)\n\t\treturn nil\n\t}\n\treturn event.Str(\"component\", component)\n}"}
{"input": "package v1\n\nimport (\n\tv1 \"github.com/openshift/api/console/v1\"\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/client-go/tools/cache\"\n)\n\n\ntype ConsoleYAMLSampleLister interface {\n\tList(selector labels.Selector) (ret []*v1.ConsoleYAMLSample, err error)\n\tGet(name string) (*v1.ConsoleYAMLSample, error)\n\tConsoleYAMLSampleListerExpansion\n}\n\n\ntype consoleYAMLSampleLister struct {\n\tindexer cache.Indexer\n}\n\n\n\n\n\nfunc (s *consoleYAMLSampleLister) List(selector labels.Selector) (ret []*v1.ConsoleYAMLSample, err error) {\n\terr = cache.ListAll(s.indexer, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*v1.ConsoleYAMLSample))\n\t})\n\treturn ret, err\n}\n\n\nfunc (s *consoleYAMLSampleLister) Get(name string) (*v1.ConsoleYAMLSample, error) {\n\tobj, exists, err := s.indexer.GetByKey(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn nil, errors.NewNotFound(v1.Resource(\"consoleyamlsample\"), name)\n\t}\n\treturn obj.(*v1.ConsoleYAMLSample), nil\n}\n\nfunc NewConsoleYAMLSampleLister(indexer cache.Indexer) ConsoleYAMLSampleLister ", "output": "{\n\treturn &consoleYAMLSampleLister{indexer: indexer}\n}"}
{"input": "package poolcontroller\n\nimport (\n\topenebsFakeClientset \"github.com/openebs/maya/pkg/client/generated/clientset/versioned/fake\"\n\tinformers \"github.com/openebs/maya/pkg/client/generated/informers/externalversions\"\n\tkubeinformers \"k8s.io/client-go/informers\"\n\t\"k8s.io/client-go/kubernetes/fake\"\n\t\"testing\"\n\t\"time\"\n)\n\n\n\n\n\nfunc TestNewCStorPoolController(t *testing.T) ", "output": "{\n\tfakeKubeClient := fake.NewSimpleClientset()\n\tfakeOpenebsClient := openebsFakeClientset.NewSimpleClientset()\n\n\tkubeInformerFactory := kubeinformers.NewSharedInformerFactory(fakeKubeClient, time.Second*30)\n\topenebsInformerFactory := informers.NewSharedInformerFactory(fakeOpenebsClient, time.Second*30)\n\n\tpoolController := NewCStorPoolController(fakeKubeClient, fakeOpenebsClient, kubeInformerFactory,\n\t\topenebsInformerFactory)\n\n\tif poolController.kubeclientset != fakeKubeClient {\n\t\tt.Fatalf(\"Pool controller object's kubeclientset mismatch\")\n\t}\n\tif poolController.clientset != fakeOpenebsClient {\n\t\tt.Fatalf(\"Pool controller object's OpenebsClientset mismatch\")\n\t}\n}"}
{"input": "package filter\n\nimport (\n\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n)\n\n\n\n\n\n\nfunc Distinct(s beam.Scope, col beam.PCollection) beam.PCollection {\n\ts = s.Scope(\"filter.Distinct\")\n\n\tpre := beam.ParDo(s, mapFn, col)\n\tpost := beam.GroupByKey(s, pre)\n\treturn beam.ParDo(s, keyFn, post)\n}\n\nfunc mapFn(elm beam.T) (beam.T, int) {\n\treturn elm, 1\n}\n\nfunc keyFn(key beam.T, _ func(*int) bool) beam.T {\n\treturn key\n}\n\nfunc init() ", "output": "{\n\tbeam.RegisterFunction(mapFn)\n\tbeam.RegisterFunction(keyFn)\n}"}
{"input": "package packets\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n\n\ntype UnsubackPacket struct {\n\tFixedHeader\n\tMessageID uint16\n}\n\n\nfunc (ua *UnsubackPacket) String() string {\n\tstr := fmt.Sprintf(\"%s\\n\", ua.FixedHeader)\n\tstr += fmt.Sprintf(\"MessageID: %d\", ua.MessageID)\n\treturn str\n}\n\nfunc (ua *UnsubackPacket) Write(w io.Writer) error {\n\tvar err error\n\tua.FixedHeader.RemainingLength = 2\n\tpacket := ua.FixedHeader.pack()\n\tpacket.Write(encodeUint16(ua.MessageID))\n\t_, err = packet.WriteTo(w)\n\n\treturn err\n}\n\n\n\nfunc (ua *UnsubackPacket) Unpack(b io.Reader) error {\n\tua.MessageID = decodeUint16(b)\n\n\treturn nil\n}\n\n\n\nfunc (ua *UnsubackPacket) Details() Details {\n\treturn Details{Qos: 0, MessageID: ua.MessageID}\n}\n\nfunc (ua *UnsubackPacket) Type() byte ", "output": "{\n\treturn ua.FixedHeader.MessageType\n}"}
{"input": "package stats\n\n\n\n\n\n\n\n\n\n\n\ntype Measure interface {\n\tName() string\n\tDescription() string\n\tUnit() string\n}\n\n\n\n\ntype Measurement struct {\n\tv interface{} \n\tm Measure\n}\n\n\n\n\n\n\n\n\nfunc DeleteMeasure(m Measure) error {\n\treq := &deleteMeasureReq{\n\t\tm:   m,\n\t\terr: make(chan error),\n\t}\n\tdefaultWorker.c <- req\n\treturn <-req.err\n}\n\nfunc FindMeasure(name string) (m Measure) ", "output": "{\n\treq := &getMeasureByNameReq{\n\t\tname: name,\n\t\tc:    make(chan *getMeasureByNameResp),\n\t}\n\tdefaultWorker.c <- req\n\tresp := <-req.c\n\treturn resp.m\n}"}
{"input": "package repomodel\n\nimport (\n\t\"github.com/kopia/kopia/repo/content\"\n\t\"github.com/kopia/kopia/repo/manifest\"\n)\n\n\ntype RepositorySession struct {\n\tOpenRepo *OpenRepository\n\n\tWrittenContents  ContentSet\n\tWrittenManifests ManifestSet\n}\n\n\n\n\n\nfunc (s *RepositorySession) WriteManifest(mid manifest.ID) {\n\ts.WrittenManifests.Add(mid)\n}\n\n\nfunc (s *RepositorySession) Refresh() {\n\ts.OpenRepo.Refresh()\n}\n\n\n\nfunc (s *RepositorySession) Flush(wc *ContentSet, wm *ManifestSet) {\n\ts.OpenRepo.mu.Lock()\n\tdefer s.OpenRepo.mu.Unlock()\n\n\ts.OpenRepo.Contents.Add(wc.ids...)\n\ts.OpenRepo.Manifests.Add(wm.ids...)\n\n\ts.OpenRepo.RepoData.Contents.Add(wc.ids...)\n\ts.OpenRepo.RepoData.Manifests.Add(wm.ids...)\n\n\ts.WrittenContents.RemoveAll(wc.ids...)\n\ts.WrittenManifests.RemoveAll(wm.ids...)\n}\n\nfunc (s *RepositorySession) WriteContent(cid content.ID) ", "output": "{\n\ts.WrittenContents.Add(cid)\n}"}
{"input": "package exec\n\nimport \"fmt\"\n\nvar (\n\tExecTypeOs ExecType = 0\n\n\texecTypeToString = map[ExecType]string{\n\t\tExecTypeOs: \"os\",\n\t}\n\tlenExecTypeToString = len(execTypeToString)\n\tstringToExecType    = map[string]ExecType{\n\t\t\"os\": ExecTypeOs,\n\t}\n)\n\ntype ExecType uint\n\n\n\nfunc ExecTypeOf(s string) (ExecType, error) {\n\texecType, ok := stringToExecType[s]\n\tif !ok {\n\t\treturn 0, UnknownExecType(s)\n\t}\n\treturn execType, nil\n}\n\nfunc (e ExecType) String() string {\n\tif int(e) < lenExecTypeToString {\n\t\treturn execTypeToString[e]\n\t}\n\tpanic(UnknownExecType(e).Error())\n}\n\nfunc UnknownExecType(unknownExecType interface{}) error {\n\treturn fmt.Errorf(\"exec: unknown ExecType: %v\", unknownExecType)\n}\n\nfunc AllExecTypes() []ExecType ", "output": "{\n\treturn []ExecType{\n\t\tExecTypeOs,\n\t}\n}"}
{"input": "package statsd\n\nimport (\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\n\nconst defaultUDSTimeout = 1 * time.Millisecond\n\n\ntype udsWriter struct {\n\taddr net.Addr\n\tconn net.Conn\n\twriteTimeout time.Duration\n\tsync.RWMutex \n}\n\n\nfunc newUDSWriter(addr string) (*udsWriter, error) {\n\tudsAddr, err := net.ResolveUnixAddr(\"unixgram\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\twriter := &udsWriter{addr: udsAddr, conn: nil, writeTimeout: defaultUDSTimeout}\n\treturn writer, nil\n}\n\n\nfunc (w *udsWriter) SetWriteTimeout(d time.Duration) error {\n\tw.writeTimeout = d\n\treturn nil\n}\n\n\n\n\n\nfunc (w *udsWriter) Close() error {\n\tif w.conn != nil {\n\t\treturn w.conn.Close()\n\t}\n\treturn nil\n}\n\nfunc (w *udsWriter) ensureConnection() (net.Conn, error) {\n\tw.RLock()\n\tcurrentConn := w.conn\n\tw.RUnlock()\n\n\tif currentConn != nil {\n\t\treturn currentConn, nil\n\t}\n\n\tw.Lock()\n\tdefer w.Unlock()\n\tif w.conn != nil {\n\t\treturn w.conn, nil\n\t}\n\n\tnewConn, err := net.Dial(w.addr.Network(), w.addr.String())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tw.conn = newConn\n\treturn newConn, nil\n}\n\nfunc (w *udsWriter) unsetConnection() {\n\tw.Lock()\n\tdefer w.Unlock()\n\tw.conn = nil\n}\n\nfunc (w *udsWriter) Write(data []byte) (int, error) ", "output": "{\n\tconn, err := w.ensureConnection()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tconn.SetWriteDeadline(time.Now().Add(w.writeTimeout))\n\tn, e := conn.Write(data)\n\n\tif err, isNetworkErr := e.(net.Error); err != nil && (!isNetworkErr || !err.Temporary()) {\n\t\tw.unsetConnection()\n\t\treturn 0, e\n\t}\n\treturn n, e\n}"}
{"input": "package goiaf\n\nimport (\n\t\"net/url\"\n\t\"strconv\"\n\t\"time\"\n)\n\n\ntype BookRequest interface {\n\tParamConverter\n\n\tLimit(int) BookRequest\n\n\tName(string) BookRequest\n\n\tFromReleaseDate(time.Time) BookRequest\n\n\tToReleaseDate(time.Time) BookRequest\n}\n\n\nfunc NewBookRequest() BookRequest {\n\tb := bookRequest{}\n\tb.limit = 10\n\treturn b\n}\n\ntype bookRequest struct {\n\trequest\n\n\tname            *string\n\tfromReleaseDate *string\n\ttoReleaseDate   *string\n}\n\nfunc (request bookRequest) Limit(value int) BookRequest {\n\trequest.limit = value\n\treturn request\n}\n\nfunc (request bookRequest) Name(value string) BookRequest {\n\trequest.name = &value\n\treturn request\n}\n\n\n\nfunc (request bookRequest) ToReleaseDate(value time.Time) BookRequest {\n\tv := value.Format(time.RFC3339)\n\trequest.toReleaseDate = &v\n\treturn request\n}\n\nfunc (request bookRequest) Convert() url.Values {\n\tparams := url.Values{}\n\tparams.Add(\"page\", strconv.Itoa(request.limit))\n\n\tif request.page != nil {\n\t\tparams.Set(\"pageSize\", strconv.Itoa(*request.page))\n\t}\n\tif request.name != nil {\n\t\tparams.Set(\"name\", *request.name)\n\t}\n\tif request.fromReleaseDate != nil {\n\t\tparams.Set(\"fromReleaseDate\", *request.fromReleaseDate)\n\t}\n\tif request.toReleaseDate != nil {\n\t\tparams.Set(\"toReleaseDate\", *request.toReleaseDate)\n\t}\n\n\treturn params\n}\n\nfunc (request bookRequest) FromReleaseDate(value time.Time) BookRequest ", "output": "{\n\tv := value.Format(time.RFC3339)\n\trequest.fromReleaseDate = &v\n\treturn request\n}"}
{"input": "package os\n\nimport \"syscall\"\n\n\n\nfunc Hostname() (name string, err error) ", "output": "{\n\tname, err = syscall.Sysctl(\"kern.hostname\")\n\tif err != nil {\n\t\treturn \"\", NewSyscallError(\"sysctl kern.hostname\", err)\n\t}\n\treturn name, nil\n}"}
{"input": "package v1alpha2\n\nimport (\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\n\nconst (\n\tAnchors          = \"subnamespaceanchors\"\n\tAnchorKind       = \"SubnamespaceAnchor\"\n\tAnchorAPIVersion = MetaGroup + \"/v1alpha2\"\n\tSubnamespaceOf   = MetaGroup + \"/subnamespace-of\"\n)\n\n\n\ntype SubnamespaceAnchorState string\n\n\nconst (\n\tMissing   SubnamespaceAnchorState = \"Missing\"\n\tOk        SubnamespaceAnchorState = \"Ok\"\n\tConflict  SubnamespaceAnchorState = \"Conflict\"\n\tForbidden SubnamespaceAnchorState = \"Forbidden\"\n)\n\n\ntype SubnamespaceAnchorStatus struct {\n\tState SubnamespaceAnchorState `json:\"status,omitempty\"`\n}\n\n\n\n\n\n\n\ntype SubnamespaceAnchor struct {\n\tmetav1.TypeMeta   `json:\",inline\"`\n\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n\tStatus SubnamespaceAnchorStatus `json:\"status,omitempty\"`\n}\n\n\n\n\ntype SubnamespaceAnchorList struct {\n\tmetav1.TypeMeta `json:\",inline\"`\n\tmetav1.ListMeta `json:\"metadata,omitempty\"`\n\tItems           []SubnamespaceAnchor `json:\"items\"`\n}\n\n\n\nfunc init() ", "output": "{\n\tSchemeBuilder.Register(&SubnamespaceAnchor{}, &SubnamespaceAnchorList{})\n}"}
{"input": "package iso20022\n\n\ntype PriceValueType6FormatChoice struct {\n\n\tCode *PriceValueType6Code `xml:\"Cd\"`\n\n\tProprietary *GenericIdentification13 `xml:\"Prtry\"`\n}\n\n\n\nfunc (p *PriceValueType6FormatChoice) AddProprietary() *GenericIdentification13 {\n\tp.Proprietary = new(GenericIdentification13)\n\treturn p.Proprietary\n}\n\nfunc (p *PriceValueType6FormatChoice) SetCode(value string) ", "output": "{\n\tp.Code = (*PriceValueType6Code)(&value)\n}"}
{"input": "package entity\n\nimport (\n\t\"context\"\n\n\t\"github.com/utahta/momoclo-channel/dao\"\n)\n\ntype (\n\tReminderRepository interface {\n\t\tFindAll(context.Context) ([]*Reminder, error)\n\t\tSave(context.Context, *Reminder) error\n\t}\n\n\treminderRepository struct {\n\t\tdao.PersistenceHandler\n\t}\n)\n\n\nfunc NewReminderRepository(h dao.PersistenceHandler) ReminderRepository {\n\treturn &reminderRepository{h}\n}\n\n\n\n\n\nfunc (repo *reminderRepository) Save(ctx context.Context, item *Reminder) error {\n\treturn repo.Put(ctx, item)\n}\n\nfunc (repo *reminderRepository) FindAll(ctx context.Context) ([]*Reminder, error) ", "output": "{\n\tkind := repo.Kind(ctx, &Reminder{})\n\tq := repo.NewQuery(kind).Filter(\"Enabled =\", true)\n\n\tvar dst []*Reminder\n\treturn dst, repo.GetAll(ctx, q, &dst)\n}"}
{"input": "package sml_test\n\nimport (\n\t\"encoding/xml\"\n\t\"testing\"\n\n\t\"baliance.com/gooxml/schema/soo/sml\"\n)\n\n\n\nfunc TestCT_RecordMarshalUnmarshal(t *testing.T) {\n\tv := sml.NewCT_Record()\n\tbuf, _ := xml.Marshal(v)\n\tv2 := sml.NewCT_Record()\n\txml.Unmarshal(buf, v2)\n}\n\nfunc TestCT_RecordConstructor(t *testing.T) ", "output": "{\n\tv := sml.NewCT_Record()\n\tif v == nil {\n\t\tt.Errorf(\"sml.NewCT_Record must return a non-nil value\")\n\t}\n\tif err := v.Validate(); err != nil {\n\t\tt.Errorf(\"newly constructed sml.CT_Record should validate: %s\", err)\n\t}\n}"}
{"input": "package config\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/BurntSushi/toml\"\n)\n\ntype Config struct {\n\tWeb *WebConfig `toml:\"web\"`\n\tBot *BotConfig `toml:\"bot\"`\n}\n\ntype BotConfig struct {\n\tChannelId                int    `toml:\"channel_id\"`\n\tChannelSecret            string `toml:\"channel_secret\"`\n\tMID                      string `toml:\"channel_mid\"`\n\tClientWorkerQueueSize    int    `toml:\"client_worker_queue_size\"`\n\tEventDispatcherQueueSize int    `toml:\"event_dispatcher_queue_size\"`\n}\n\ntype WebConfig struct {\n\tHost string `toml:\"host\"`\n\tPort int    `toml:\"port\"`\n}\n\nfunc (wc *WebConfig) Address() string {\n\treturn fmt.Sprintf(\"%s:%d\", wc.Host, wc.Port)\n}\n\n\n\nfunc LoadFromFile(filePath string) *Config ", "output": "{\n\tvar c Config\n\tif _, err := toml.DecodeFile(filePath, &c); err != nil {\n\t\tlog.Fatalf(\"Failed to read config file: %s\", err.Error())\n\t}\n\treturn &c\n}"}
{"input": "package common_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"github.com/jacobsa/crypto/common\"\n\t. \"github.com/jacobsa/oglematchers\"\n\t. \"github.com/jacobsa/ogletest\"\n\t\"testing\"\n)\n\nfunc TestPadBlock(t *testing.T) { RunTests(t) }\n\n\n\n\n\ntype PadBlockTest struct{}\n\n\n\n\n\n\n\nfunc (t *PadBlockTest) FullBlock() {\n\tb := make([]byte, 16)\n\tf := func() { common.PadBlock(b) }\n\tExpectThat(f, Panics(HasSubstr(\"16 bytes\")))\n}\n\nfunc (t *PadBlockTest) LongBlock() {\n\tb := make([]byte, 17)\n\tf := func() { common.PadBlock(b) }\n\tExpectThat(f, Panics(HasSubstr(\"16 bytes\")))\n}\n\nfunc (t *PadBlockTest) OneByteMissing() {\n\tb, err := hex.DecodeString(\"deadbeeffeedfaceba5eba11cafeba\")\n\tAssertEq(nil, err)\n\tAssertEq(15, len(b))\n\n\texpected := append(b, 0x80)\n\tExpectThat(common.PadBlock(b), DeepEquals(expected))\n}\n\nfunc (t *PadBlockTest) MultipleBytesMissing() {\n\tb, err := hex.DecodeString(\"deadbeeffeedfaceba5eba11ca\")\n\tAssertEq(nil, err)\n\tAssertEq(13, len(b))\n\n\texpected := append(b, 0x80, 0x00, 0x00)\n\tExpectThat(common.PadBlock(b), DeepEquals(expected))\n}\n\nfunc (t *PadBlockTest) AllBytesMissing() {\n\tb := []byte{}\n\texpected := append([]byte{0x80}, bytes.Repeat([]byte{0x00}, 15)...)\n\tExpectThat(common.PadBlock(b), DeepEquals(expected))\n}\n\nfunc init() ", "output": "{ RegisterTestSuite(&PadBlockTest{}) }"}
{"input": "package log\n\nimport \"gopkg.in/inconshreveable/log15.v2\"\n\nvar (\n\tLogger log15.Logger\n)\n\nfunc init() {\n\tLogger = log15.New()\n\tLogger.SetHandler(log15.DiscardHandler())\n}\n\n\n\nfunc Interactive() {\n\tLogger.SetHandler(log15.MultiHandler(\n\t\tlog15.LvlFilterHandler(\n\t\t\tlog15.LvlError,\n\t\t\tlog15.StderrHandler)))\n}\n\n\nfunc Debug(msg string, ctx ...interface{}) { Logger.Debug(msg, ctx...) }\n\nfunc Warn(msg string, ctx ...interface{})  { Logger.Warn(msg, ctx...) }\nfunc Error(msg string, ctx ...interface{}) { Logger.Error(msg, ctx...) }\nfunc Crit(msg string, ctx ...interface{})  { Logger.Crit(msg, ctx...) }\n\nfunc Info(msg string, ctx ...interface{})  ", "output": "{ Logger.Info(msg, ctx...) }"}
{"input": "package ec2\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\tawsec2 \"github.com/aws/aws-sdk-go/service/ec2\"\n\t\"github.com/genevieve/leftovers/common\"\n)\n\ntype natGatewaysClient interface {\n\tDescribeNatGateways(*awsec2.DescribeNatGatewaysInput) (*awsec2.DescribeNatGatewaysOutput, error)\n\tDeleteNatGateway(*awsec2.DeleteNatGatewayInput) (*awsec2.DeleteNatGatewayOutput, error)\n}\n\ntype NatGateways struct {\n\tclient natGatewaysClient\n\tlogger logger\n}\n\n\n\nfunc (n NatGateways) List(filter string) ([]common.Deletable, error) {\n\tnatGateways, err := n.client.DescribeNatGateways(&awsec2.DescribeNatGatewaysInput{\n\t\tFilter: []*awsec2.Filter{{\n\t\t\tName:   aws.String(\"state\"),\n\t\t\tValues: []*string{aws.String(\"pending\"), aws.String(\"available\")},\n\t\t}},\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Describing EC2 Nat Gateways: %s\", err)\n\t}\n\n\tvar resources []common.Deletable\n\tfor _, g := range natGateways.NatGateways {\n\t\tr := NewNatGateway(n.client, n.logger, g.NatGatewayId, g.Tags)\n\n\t\tif !strings.Contains(r.Name(), filter) {\n\t\t\tcontinue\n\t\t}\n\n\t\tproceed := n.logger.PromptWithDetails(r.Type(), r.Name())\n\t\tif !proceed {\n\t\t\tcontinue\n\t\t}\n\n\t\tresources = append(resources, r)\n\t}\n\n\treturn resources, nil\n}\n\nfunc (n NatGateways) Type() string {\n\treturn \"ec2-nat-gateway\"\n}\n\nfunc NewNatGateways(client natGatewaysClient, logger logger) NatGateways ", "output": "{\n\treturn NatGateways{\n\t\tclient: client,\n\t\tlogger: logger,\n\t}\n}"}
{"input": "package gl\n\nimport (\n\t\"image\"\n)\n\n\n\n\nimport \"C\"\n\n\n\n\ntype Texture3D struct {\n\tobject C.GLuint\n\tformat TextureFormat\n}\n\n\nfunc NewTexture3D(levels int32, f TextureFormat, width, height, depth int32) Texture3D {\n\tvar t Texture3D\n\tt.format = f\n\tt.object = C.NewTexture3D(C.GLsizei(levels), C.GLenum(f), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth))\n\treturn t\n}\n\n\n\nfunc (t *Texture3D) SubImage(level int32, ox, oy, oz int32, img image.Image) {\n\tp, pf, pt := pointerFormatAndTypeOf(img)\n\tC.Texture3DSubImage(\n\t\tt.object,\n\t\tC.GLint(level),\n\t\tC.GLint(ox), C.GLint(oy), C.GLint(oz),\n\t\tC.GLsizei(img.Bounds().Dx()), C.GLsizei(img.Bounds().Dy()), C.GLsizei(1),\n\t\tpf, pt, p,\n\t)\n}\n\n\nfunc (t *Texture3D) GenerateMipmap() {\n\tC.TextureGenerateMipmap(t.object)\n}\n\n\n\n\n\nfunc (t *Texture3D) Delete() {\n\tC.DeleteTexture(t.object)\n}\n\nfunc (t *Texture3D) Bind(index uint32) ", "output": "{\n\tC.BindTextureUnit(C.GLuint(index), t.object)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/alerting/gocron\"\n)\n\nfunc task() {\n\tfmt.Println(\"I am runnning task.\")\n}\n\n\n\nfunc main() {\n\tgocron.Every(1).Second().Do(taskWithParams, 1, \"hello\")\n\n\tgocron.Every(1).Second().Do(task)\n\tgocron.Every(2).Seconds().Do(task)\n\tgocron.Every(1).Minute().Do(task)\n\tgocron.Every(2).Minutes().Do(task)\n\tgocron.Every(1).Hour().Do(task)\n\tgocron.Every(2).Hours().Do(task)\n\tgocron.Every(1).Day().Do(task)\n\tgocron.Every(2).Days().Do(task)\n\n\tgocron.Every(1).Monday().Do(task)\n\tgocron.Every(1).Thursday().Do(task)\n\n\tgocron.Every(1).Day().At(\"10:30\").Do(task)\n\tgocron.Every(1).Monday().At(\"18:30\").Do(task)\n\n\t_, time := gocron.NextRun()\n\tfmt.Println(time)\n\n\n\t<-gocron.Start()\n\n\ts := gocron.NewScheduler()\n\ts.Every(3).Seconds().Do(task)\n\t<-s.Start()\n}\n\nfunc taskWithParams(a int, b string) ", "output": "{\n\tfmt.Println(a, b)\n}"}
{"input": "package sign\n\nimport (\n\t\"dfss\"\n\tcAPI \"dfss/dfssc/api\"\n\tpAPI \"dfss/dfssp/api\"\n\t\"dfss/dfsst/entities\"\n\t\"dfss/net\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n)\n\ntype clientServer struct {\n\tincomingPromises   chan interface{}\n\tincomingSignatures chan interface{}\n}\n\nfunc getServerErrorCode(c chan interface{}, in interface{}) *pAPI.ErrorCode {\n\tif c != nil {\n\t\tc <- in\n\t\treturn &pAPI.ErrorCode{Code: pAPI.ErrorCode_SUCCESS}\n\t}\n\treturn &pAPI.ErrorCode{Code: pAPI.ErrorCode_INTERR} \n}\n\n\n\n\nfunc (s *clientServer) TreatPromise(ctx context.Context, in *cAPI.Promise) (*pAPI.ErrorCode, error) {\n\tvalid, _, _, _ := entities.IsRequestValid(ctx, []*cAPI.Promise{in})\n\tif !valid {\n\t\treturn &pAPI.ErrorCode{Code: pAPI.ErrorCode_SUCCESS}, nil\n\t}\n\treturn getServerErrorCode(s.incomingPromises, in), nil\n}\n\n\n\n\nfunc (s *clientServer) TreatSignature(ctx context.Context, in *cAPI.Signature) (*pAPI.ErrorCode, error) {\n\treturn getServerErrorCode(s.incomingSignatures, in), nil\n}\n\n\n\n\nfunc (s *clientServer) Discover(ctx context.Context, in *cAPI.Hello) (*cAPI.Hello, error) {\n\treturn &cAPI.Hello{Version: dfss.Version}, nil\n}\n\n\n\n\nfunc (m *SignatureManager) GetServer() *grpc.Server ", "output": "{\n\tserver := net.NewServer(m.auth.Cert, m.auth.Key, m.auth.CA)\n\tm.cServerIface = clientServer{}\n\tcAPI.RegisterClientServer(server, &m.cServerIface)\n\treturn server\n}"}
{"input": "package main\n\nimport \"fmt\"\n\ntype T struct { i int }\n\n\n\nfunc (t *T) Bar () {\n  fmt.Println (t.i)\n}\n\nfunc main () {\n  fmt.Println (\"Shall we?\")\n  var t T\n  t.Foo ()\n  var pt = new (T)\n  pt.Bar ()\n}\n\nfunc (t T) Foo () ", "output": "{\n  fmt.Println (t.i)\n}"}
{"input": "package fake\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\n\t. \"github.com/onsi/gomega\"\n\t\"github.com/onsi/gomega/ghttp\"\n)\n\ntype CFAPI struct {\n\tserver *ghttp.Server\n}\n\ntype CFAPIConfig struct {\n\tRoutes map[string]Response\n}\n\ntype Response struct {\n\tCode int\n\tBody interface{}\n}\n\nfunc NewCFAPI() *CFAPI {\n\tserver := ghttp.NewServer()\n\treturn &CFAPI{\n\t\tserver: server,\n\t}\n}\n\nfunc (a *CFAPI) SetConfiguration(config CFAPIConfig) {\n\ta.server.Reset()\n\n\tfor request, response := range config.Routes {\n\t\tmethod, path := parseRequest(request)\n\t\tresponseBytes, err := json.Marshal(response.Body)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\ta.server.RouteToHandler(method, path, ghttp.RespondWith(response.Code, responseBytes))\n\t}\n}\n\nfunc (a *CFAPI) Close() {\n\ta.server.Close()\n}\n\nfunc (a *CFAPI) URL() string {\n\treturn a.server.URL()\n}\n\n\n\nfunc parseRequest(request string) (string, string) {\n\tfields := strings.Split(request, \" \")\n\tExpect(fields).To(HaveLen(2))\n\treturn fields[0], fields[1]\n}\n\nfunc (a *CFAPI) ReceivedRequests() map[string][]*http.Request ", "output": "{\n\tresult := map[string][]*http.Request{}\n\n\tfor _, req := range a.server.ReceivedRequests() {\n\t\tkey := fmt.Sprintf(\"%s %s\", req.Method, req.URL.Path)\n\t\tresult[key] = append(result[key], req)\n\t}\n\n\treturn result\n}"}
{"input": "package elcomd\n\nimport (\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/baocaixiong/elcom/utils\"\n)\n\ntype ElcomdOptions struct {\n\tHostName          string   `flag:\"broadcast-address\" cfg:\"broadcast_address\"`\n\tLogPath           string   `flag:\"logPath\" cfg:\"log_path\"`\n\tTCPAddress        string   `flag:\"tcp-address\" cfg:\"tcp_address\"`\n\tHTTPAddress       string   `flag:\"http-address\" cfg:\"http_address\"`\n\tNSQDTCPAddresses  []string `flag:\"nsqd-tcp-addresses\" cfg:\"nsqd_tcp_addresses\"`\n\tNSQDHTTPAddresses []string `flag:\"nsqd-http-addresses\" cfg:\"nsqd_http_addresses\"`\n\tlogger            utils.LoggerI\n}\n\nfunc NewElcomdOptions() *ElcomdOptions {\n\n\thostName, err := os.Hostname()\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\to := &ElcomdOptions{\n\t\tLogPath:          \"\",\n\t\tHostName:         hostName,\n\t\tTCPAddress:       \"0.0.0.0:4230\",\n\t\tHTTPAddress:      \"0.0.0.0:4231\",\n\t\tNSQDTCPAddresses: []string{},\n\t\tlogger:           &utils.Logger{Logger: log.New(os.Stderr, \"[elcomd] \", log.Ldate|log.Ltime|log.Lmicroseconds)},\n\t}\n\n\treturn o\n}\n\nfunc (o *ElcomdOptions) HasLogPath() bool {\n\treturn \"\" != o.LogPath\n}\n\nfunc (o *ElcomdOptions) HasNSQDTCPAddress() bool {\n\treturn len(o.NSQDTCPAddresses) > 0\n}\n\n\n\nfunc (o *ElcomdOptions) HasNSQDHTTPAddress() bool ", "output": "{\n\treturn len(o.NSQDHTTPAddresses) > 0\n}"}
{"input": "package types\n\nimport (\n\t\"github.com/coreos/go-semver/semver\"\n\n\t\"github.com/coreos/ignition/config/shared/errors\"\n\t\"github.com/coreos/ignition/config/validate/report\"\n)\n\nfunc (c ConfigReference) ValidateSource() report.Report {\n\tr := report.Report{}\n\terr := validateURL(c.Source)\n\tif err != nil {\n\t\tr.Add(report.Entry{\n\t\t\tMessage: err.Error(),\n\t\t\tKind:    report.EntryError,\n\t\t})\n\t}\n\treturn r\n}\n\n\n\nfunc (v Ignition) Validate() report.Report {\n\ttv, err := v.Semver()\n\tif err != nil {\n\t\treturn report.ReportFromError(errors.ErrInvalidVersion, report.EntryError)\n\t}\n\tif MaxVersion.Major > tv.Major {\n\t\treturn report.ReportFromError(errors.ErrOldVersion, report.EntryError)\n\t}\n\tif MaxVersion.LessThan(*tv) {\n\t\treturn report.ReportFromError(errors.ErrNewVersion, report.EntryError)\n\t}\n\treturn report.Report{}\n}\n\nfunc (v Ignition) Semver() (*semver.Version, error) ", "output": "{\n\treturn semver.NewVersion(v.Version)\n}"}
{"input": "package model\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/huaweicloud/huaweicloud-sdk-go-v3/core/utils\"\n\n\t\"errors\"\n\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/huaweicloud/huaweicloud-sdk-go-v3/core/converter\"\n\n\t\"strings\"\n)\n\n\ntype DetachServerVolumeRequest struct {\n\n\tServerId string `json:\"server_id\"`\n\n\tVolumeId string `json:\"volume_id\"`\n\n\tDeleteFlag *DetachServerVolumeRequestDeleteFlag `json:\"delete_flag,omitempty\"`\n}\n\nfunc (o DetachServerVolumeRequest) String() string {\n\tdata, err := utils.Marshal(o)\n\tif err != nil {\n\t\treturn \"DetachServerVolumeRequest struct{}\"\n\t}\n\n\treturn strings.Join([]string{\"DetachServerVolumeRequest\", string(data)}, \" \")\n}\n\ntype DetachServerVolumeRequestDeleteFlag struct {\n\tvalue string\n}\n\ntype DetachServerVolumeRequestDeleteFlagEnum struct {\n\tE_0 DetachServerVolumeRequestDeleteFlag\n\tE_1 DetachServerVolumeRequestDeleteFlag\n}\n\n\n\nfunc (c DetachServerVolumeRequestDeleteFlag) MarshalJSON() ([]byte, error) {\n\treturn utils.Marshal(c.value)\n}\n\nfunc (c *DetachServerVolumeRequestDeleteFlag) UnmarshalJSON(b []byte) error {\n\tmyConverter := converter.StringConverterFactory(\"string\")\n\tif myConverter != nil {\n\t\tval, err := myConverter.CovertStringToInterface(strings.Trim(string(b[:]), \"\\\"\"))\n\t\tif err == nil {\n\t\t\tc.value = val.(string)\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t} else {\n\t\treturn errors.New(\"convert enum data to string error\")\n\t}\n}\n\nfunc GetDetachServerVolumeRequestDeleteFlagEnum() DetachServerVolumeRequestDeleteFlagEnum ", "output": "{\n\treturn DetachServerVolumeRequestDeleteFlagEnum{\n\t\tE_0: DetachServerVolumeRequestDeleteFlag{\n\t\t\tvalue: \"0\",\n\t\t},\n\t\tE_1: DetachServerVolumeRequestDeleteFlag{\n\t\t\tvalue: \"1\",\n\t\t},\n\t}\n}"}
{"input": "package stateengine\n\nimport ()\n\nconst (\n\tBOOLOUT   string = \"boolout\"\n\tBOOLIN    string = \"boolin\"\n\tANALOGOUT string = \"analogout\"\n\tANALOGIN  string = \"analogin\"\n)\n\ntype EventHandler func(eventName string, id string, arguments interface{})\n\ntype DeviceComm interface {\n\tID() string\n\tRegisterChannel(id string, address string, chType string)\n\tRegisterEventHandler(handler EventHandler)\n\tStart()\n\tStop()\n\tStatus() *Status\n\tGetValue(chAddress string) (ValueMap, error)\n\tSetValue(chAddress string, value ValueMap) error\n}\n\ntype ValueMap map[string]string\n\n\n\nfunc (this ValueMap) Value() string {\n\tif val1, ok := this[\"value\"]; ok {\n\t\treturn val1\n\t}\n\treturn \"\"\n}\n\ntype Status struct {\n\tStatusCode int\n\tStatusText string\n}\n\nfunc NewStatus() *Status {\n\treturn &Status{}\n}\n\nfunc (this *Status) SetError(err error) {\n\tif err != nil {\n\t\tthis.SetErrorStr(err.Error())\n\t}\n}\n\nfunc (this *Status) SetErrorStr(err string) {\n\tthis.StatusCode = 1\n\tthis.StatusText = err\n}\n\nfunc (this *Status) SetOk(message string) {\n\tthis.StatusCode = 0\n\tthis.StatusText = message\n}\n\nfunc (this *Status) IsOk() bool {\n\treturn this.StatusCode == 0\n}\n\ntype Logger interface {\n\tWrite(msg string)\n}\n\nfunc NewValueMap(value string) ValueMap ", "output": "{\n\tr1 := make(ValueMap)\n\tr1[\"value\"] = value\n\treturn r1\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/revel/revel\"\n)\n\nvar status = 200\n\ntype Server struct {\n\t*revel.Controller\n}\n\nfunc (c Server) Online() revel.Result {\n\tstatus = 200\n\treturn c.RenderJSON(status)\n}\n\n\n\nfunc (c Server) Status() revel.Result {\n\treturn c.RenderJSON(status)\n}\n\nfunc (c Server) Offline() revel.Result ", "output": "{\n\tstatus = 404\n\treturn c.RenderJSON(status)\n}"}
{"input": "package webservices\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Version() string {\n\treturn \"v10.3.0-beta\"\n}\n\nfunc UserAgent() string ", "output": "{\n\treturn \"Azure-SDK-For-Go/v10.3.0-beta arm-webservices/2017-01-01\"\n}"}
{"input": "package models\n\nimport (\n\t\"html/template\"\n\t\"time\"\n\n\t\"github.com/NyaaPantsu/nyaa/config\"\n)\n\n\ntype Comment struct {\n\tID        uint      `gorm:\"column:comment_id;primary_key\"`\n\tTorrentID uint      `gorm:\"column:torrent_id\"`\n\tUserID    uint      `gorm:\"column:user_id\"`\n\tContent   string    `gorm:\"column:content\"`\n\tCreatedAt time.Time `gorm:\"column:created_at\"`\n\tUpdatedAt time.Time `gorm:\"column:updated_at\"`\n\tDeletedAt *time.Time\n\n\tTorrent *Torrent `gorm:\"AssociationForeignKey:TorrentID;ForeignKey:torrent_id\"`\n\tUser    *User    `gorm:\"AssociationForeignKey:UserID;ForeignKey:user_id\"`\n}\n\n\ntype CommentJSON struct {\n\tUsername   string        `json:\"username\"`\n\tUserID     int           `json:\"user_id\"`\n\tUserAvatar string        `json:\"user_avatar\"`\n\tContent    template.HTML `json:\"content\"`\n\tDate       time.Time     `json:\"date\"`\n}\n\n\nfunc (c Comment) Size() int {\n\treturn (3 + 3*3 + 2 + 2 + len(c.Content)) * 8\n}\n\n\n\n\n\nfunc (c *Comment) Identifier() string { \n\treturn c.Torrent.Identifier()\n}\n\nfunc (c Comment) TableName() string ", "output": "{\n\treturn config.Get().Models.CommentsTableName\n}"}
{"input": "package cabf_br\n\n\n\nimport (\n\t\"github.com/zmap/zcrypto/x509\"\n\t\"github.com/zmap/zlint/v3/lint\"\n\t\"github.com/zmap/zlint/v3/util\"\n)\n\ntype caAiaMissing struct{}\n\n\n\nfunc init() {\n\tlint.RegisterLint(&lint.Lint{\n\t\tName:            \"e_sub_ca_aia_missing\",\n\t\tDescription:     \"Subordinate CA Certificate: authorityInformationAccess MUST be present, with the exception of stapling.\",\n\t\tCitation:        \"BRs: 7.1.2.2\",\n\t\tSource:          lint.CABFBaselineRequirements,\n\t\tEffectiveDate:   util.CABEffectiveDate,\n\t\tIneffectiveDate: util.CABFBRs_1_7_1_Date,\n\t\tLint:            NewCaAiaMissing,\n\t})\n}\n\nfunc NewCaAiaMissing() lint.LintInterface {\n\treturn &caAiaMissing{}\n}\n\n\n\nfunc (l *caAiaMissing) Execute(c *x509.Certificate) *lint.LintResult {\n\tif util.IsExtInCert(c, util.AiaOID) {\n\t\treturn &lint.LintResult{Status: lint.Pass}\n\t} else {\n\t\treturn &lint.LintResult{Status: lint.Error}\n\t}\n}\n\nfunc (l *caAiaMissing) CheckApplies(c *x509.Certificate) bool ", "output": "{\n\treturn util.IsCACert(c) && !util.IsRootCA(c)\n}"}
{"input": "package server\n\nimport (\n\t\"testing\"\n)\n\nfunc TestLoadConfigFile(t *testing.T) {\n\ttestLoadConfigFile(t)\n}\n\nfunc TestLoadConfigFile_topLevel(t *testing.T) {\n\ttestLoadConfigFile_topLevel(t, nil)\n}\n\nfunc TestLoadConfigFile_json(t *testing.T) {\n\ttestLoadConfigFile_json(t)\n}\n\nfunc TestLoadConfigFile_json2(t *testing.T) {\n\ttestLoadConfigFile_json2(t, nil)\n}\n\nfunc TestLoadConfigDir(t *testing.T) {\n\ttestLoadConfigDir(t)\n}\n\nfunc TestConfig_Sanitized(t *testing.T) {\n\ttestConfig_Sanitized(t)\n}\n\n\n\nfunc TestParseEntropy(t *testing.T) {\n\ttestParseEntropy(t, true)\n}\n\nfunc TestParseListeners(t *testing.T) ", "output": "{\n\ttestParseListeners(t)\n}"}
{"input": "package chip8\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc Test0xDxyn(t *testing.T) ", "output": "{\n\tt.Skip(\"Not implemented\")\n}"}
{"input": "package insteon\n\nimport \"context\"\n\ntype inbox struct {\n\tC chan *packet\n\n\tctx    context.Context\n\tcancel func()\n}\n\nfunc newInbox(ctx context.Context) *inbox {\n\tctx, cancel := context.WithCancel(ctx)\n\n\treturn &inbox{\n\t\tC:      make(chan *packet),\n\t\tctx:    ctx,\n\t\tcancel: cancel,\n\t}\n}\n\n\n\nfunc (i *inbox) close() {\n\ti.cancel()\n}\n\nfunc (i *inbox) Done() <-chan struct{} ", "output": "{\n\treturn i.ctx.Done()\n}"}
{"input": "package mock\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n)\n\ntype constReader struct {\n\tnonce string\n}\n\nfunc (r *constReader) Read(p []byte) (n int, err error) {\n\tcopy(p[:], []byte(r.nonce))\n\treturn len(r.nonce), nil\n}\n\n\n\nfunc WithConstRandReader(testNonce string, f func()) {\n\n\toriginal := rand.Reader\n\trand.Reader = &constReader{nonce: testNonce}\n\n\tf()\n\n\trand.Reader = original\n\n}\n\ntype errorReader struct {\n\terr string\n}\n\nfunc (r *errorReader) Read(p []byte) (n int, err error) {\n\treturn 0, fmt.Errorf(r.err)\n}\n\n\n\n\n\nfunc WithErrorRandReader(testError string, f func()) ", "output": "{\n\n\toriginal := rand.Reader\n\trand.Reader = &errorReader{err: testError}\n\n\tf()\n\n\trand.Reader = original\n\n}"}
{"input": "package limitrange\n\nimport (\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/api\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/registry/generic\"\n\tetcdgeneric \"github.com/GoogleCloudPlatform/kubernetes/pkg/registry/generic/etcd\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/runtime\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/storage\"\n)\n\n\ntype registry struct {\n\t*etcdgeneric.Etcd\n}\n\n\n\n\nfunc NewEtcdRegistry(s storage.Interface) generic.Registry ", "output": "{\n\tprefix := \"/limitranges\"\n\treturn registry{\n\t\tEtcd: &etcdgeneric.Etcd{\n\t\t\tNewFunc:      func() runtime.Object { return &api.LimitRange{} },\n\t\t\tNewListFunc:  func() runtime.Object { return &api.LimitRangeList{} },\n\t\t\tEndpointName: \"limitranges\",\n\t\t\tKeyRootFunc: func(ctx api.Context) string {\n\t\t\t\treturn etcdgeneric.NamespaceKeyRootFunc(ctx, prefix)\n\t\t\t},\n\t\t\tKeyFunc: func(ctx api.Context, id string) (string, error) {\n\t\t\t\treturn etcdgeneric.NamespaceKeyFunc(ctx, prefix, id)\n\t\t\t},\n\t\t\tStorage: s,\n\t\t},\n\t}\n}"}
{"input": "package gridq\n\ntype byColRow []*WriteResponse\n\nfunc (p byColRow) Len() int      { return len(p) }\nfunc (p byColRow) Swap(i, j int) { p[i], p[j] = p[j], p[i] }\nfunc (p byColRow) Less(i, j int) bool {\n\tif p[i].Col < p[j].Col {\n\t\treturn true\n\t} else if p[i].Col > p[j].Col {\n\t\treturn false\n\t} else {\n\t\treturn p[i].Row < p[j].Row\n\t}\n}\n\ntype byRowTimestamp []*ReadResponse\n\nfunc (p byRowTimestamp) Len() int      { return len(p) }\nfunc (p byRowTimestamp) Swap(i, j int) { p[i], p[j] = p[j], p[i] }\nfunc (p byRowTimestamp) Less(i, j int) bool {\n\tif p[i].Row < p[j].Row {\n\t\treturn true\n\t} else if p[i].Row > p[j].Row {\n\t\treturn false\n\t} else {\n\t\treturn p[i].State.Timestamp > p[j].State.Timestamp\n\t}\n}\n\ntype byTimestamp []*ReadResponse\n\nfunc (p byTimestamp) Len() int           { return len(p) }\nfunc (p byTimestamp) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n\n\nfunc (p byTimestamp) Less(i, j int) bool ", "output": "{ return p[i].State.Timestamp < p[j].State.Timestamp }"}
{"input": "package singularity\n\nimport \"github.com/opentable/go-singularity/dtos\"\n\n\n\nfunc (client *Client) DeleteExpiringSkipHealthchecks(requestId string) (response *dtos.SingularityRequestParent, err error) {\n\tpathParamMap := map[string]interface{}{\n\t\t\"requestId\": requestId,\n\t}\n\n\tqueryParamMap := map[string]interface{}{}\n\n\tresponse = new(dtos.SingularityRequestParent)\n\terr = client.DTORequest(response, \"DELETE\", \"/api/requests/request/{requestId}/skip-healthchecks\", pathParamMap, queryParamMap)\n\n\treturn\n}\n\nfunc (client *Client) SkipHealthchecks(requestId string, body *dtos.SingularitySkipHealthchecksRequest) (response *dtos.SingularityRequestParent, err error) ", "output": "{\n\tpathParamMap := map[string]interface{}{\n\t\t\"requestId\": requestId,\n\t}\n\n\tqueryParamMap := map[string]interface{}{}\n\n\tresponse = new(dtos.SingularityRequestParent)\n\terr = client.DTORequest(response, \"PUT\", \"/api/requests/request/{requestId}/skip-healthchecks\", pathParamMap, queryParamMap, body)\n\n\treturn\n}"}
{"input": "package single\n\nimport (\n\t\"io\"\n\n\t\"github.com/ondrej-smola/mesos-go-http/lib/codec/framing\"\n)\n\ntype Reader struct {\n\tr io.Reader\n}\n\nfunc New(r io.Reader) *Reader {\n\treturn &Reader{r: r}\n}\n\n\n\nfunc NewProvider() framing.Provider {\n\treturn func(r io.Reader) framing.Reader {\n\t\treturn New(r)\n\t}\n}\n\nfunc (rr *Reader) ReadFrame(p []byte) (endOfFrame bool, n int, err error) {\n\tn, err = rr.r.Read(p)\n\n\tif err == io.EOF {\n\t\tendOfFrame = true\n\t}\n\n\treturn\n}\n\n\n\nfunc (rr *Reader) Read(p []byte) (int, error) ", "output": "{\n\treturn rr.r.Read(p)\n}"}
{"input": "package msgraph\n\nimport \"context\"\n\n\ntype WorkbookFunctionsVar_PRequestBuilder struct{ BaseRequestBuilder }\n\n\nfunc (b *WorkbookFunctionsRequestBuilder) Var_P(reqObj *WorkbookFunctionsVar_PRequestParameter) *WorkbookFunctionsVar_PRequestBuilder {\n\tbb := &WorkbookFunctionsVar_PRequestBuilder{BaseRequestBuilder: b.BaseRequestBuilder}\n\tbb.BaseRequestBuilder.baseURL += \"/var_P\"\n\tbb.BaseRequestBuilder.requestObject = reqObj\n\treturn bb\n}\n\n\ntype WorkbookFunctionsVar_PRequest struct{ BaseRequest }\n\n\nfunc (b *WorkbookFunctionsVar_PRequestBuilder) Request() *WorkbookFunctionsVar_PRequest {\n\treturn &WorkbookFunctionsVar_PRequest{\n\t\tBaseRequest: BaseRequest{baseURL: b.baseURL, client: b.client, requestObject: b.requestObject},\n\t}\n}\n\n\nfunc (r *WorkbookFunctionsVar_PRequest) Post(ctx context.Context) (resObj *WorkbookFunctionResult, err error) {\n\terr = r.JSONRequest(ctx, \"POST\", \"\", r.requestObject, &resObj)\n\treturn\n}\n\n\ntype WorkbookFunctionsVar_SRequestBuilder struct{ BaseRequestBuilder }\n\n\nfunc (b *WorkbookFunctionsRequestBuilder) Var_S(reqObj *WorkbookFunctionsVar_SRequestParameter) *WorkbookFunctionsVar_SRequestBuilder {\n\tbb := &WorkbookFunctionsVar_SRequestBuilder{BaseRequestBuilder: b.BaseRequestBuilder}\n\tbb.BaseRequestBuilder.baseURL += \"/var_S\"\n\tbb.BaseRequestBuilder.requestObject = reqObj\n\treturn bb\n}\n\n\ntype WorkbookFunctionsVar_SRequest struct{ BaseRequest }\n\n\nfunc (b *WorkbookFunctionsVar_SRequestBuilder) Request() *WorkbookFunctionsVar_SRequest {\n\treturn &WorkbookFunctionsVar_SRequest{\n\t\tBaseRequest: BaseRequest{baseURL: b.baseURL, client: b.client, requestObject: b.requestObject},\n\t}\n}\n\n\n\n\nfunc (r *WorkbookFunctionsVar_SRequest) Post(ctx context.Context) (resObj *WorkbookFunctionResult, err error) ", "output": "{\n\terr = r.JSONRequest(ctx, \"POST\", \"\", r.requestObject, &resObj)\n\treturn\n}"}
{"input": "package golog\n\n\ntype Conf map[string]string\n\nvar (\n\tDefault *Logger\n\tloggers map[string]*Logger\n)\n\nfunc init() {\n\tloggers = map[string]*Logger{}\n\tDefault = GetLogger(\"default\")\n}\n\n\n\nfunc GetLogger(name string) *Logger {\n\tlogger, ok := loggers[name]\n\tif !ok {\n\t\tlogger = &Logger{\n\t\t\tName:  name,\n\t\t\tLevel: DEBUG,\n\t\t\tctx:   Ctx{},\n\t\t}\n\n\t\tlogger.Enable(StdoutAppender())\n\t\tlogger.normalizeName()\n\n\t\tcurnamelen = len(logger.Name)\n\t\tfor _, _logger := range loggers {\n\t\t\t_logger.normalizeName()\n\t\t}\n\n\t\tloggers[name] = logger\n\t}\n\n\treturn logger\n}\n\n\n\n\n\nfunc Enable(name string) {\n\tlogger := loggers[name]\n\tif logger == nil {\n\t\tDefault.Warn(\"cannot find logger \" + name)\n\t\treturn\n\t}\n\n\tlogger.disabled = false\n}\n\nfunc Disable(name string) ", "output": "{\n\tlogger := loggers[name]\n\tif logger == nil {\n\t\tDefault.Warn(\"cannot find logger \" + name)\n\t\treturn\n\t}\n\n\tlogger.disabled = true\n}"}
{"input": "package middlewares\n\nimport (\n\t\"testing\"\n\n\t\"github.com/go-kit/kit/metrics\"\n)\n\nfunc TestMetricsRetryListener(t *testing.T) {\n\tretryListener := NewMetricsRetryListener(nil)\n\tretryListener.Retried(1)\n\n\tretryMetrics := newCollectingMetrics()\n\tretryListener = NewMetricsRetryListener(retryMetrics)\n\tretryListener.Retried(1)\n\tretryListener.Retried(2)\n\n\twantCounterValue := float64(2)\n\tif retryMetrics.retryCounter.counterValue != wantCounterValue {\n\t\tt.Errorf(\"got counter value of %d, want %d\", retryMetrics.retryCounter.counterValue, wantCounterValue)\n\t}\n}\n\n\ntype collectingRetryMetrics struct {\n\tretryCounter *collectingCounter\n}\n\n\n\nfunc (metrics collectingRetryMetrics) getRetryCounter() metrics.Counter {\n\treturn metrics.retryCounter\n}\n\ntype collectingCounter struct {\n\tcounterValue float64\n}\n\nfunc (c *collectingCounter) With(labelValues ...string) metrics.Counter {\n\tpanic(\"collectingCounter.With not implemented!\")\n}\n\nfunc (c *collectingCounter) Add(delta float64) {\n\tc.counterValue += delta\n}\n\nfunc newCollectingMetrics() collectingRetryMetrics ", "output": "{\n\treturn collectingRetryMetrics{retryCounter: &collectingCounter{}}\n}"}
{"input": "package iso20022\n\n\ntype DirectDebitTransaction1 struct {\n\n\tMandateRelatedInformation *MandateRelatedInformation1 `xml:\"MndtRltdInf,omitempty\"`\n\n\tCreditorSchemeIdentification *PartyIdentification8 `xml:\"CdtrSchmeId,omitempty\"`\n\n\tPreNotificationIdentification *Max35Text `xml:\"PreNtfctnId,omitempty\"`\n\n\tPreNotificationDate *ISODate `xml:\"PreNtfctnDt,omitempty\"`\n}\n\nfunc (d *DirectDebitTransaction1) AddMandateRelatedInformation() *MandateRelatedInformation1 {\n\td.MandateRelatedInformation = new(MandateRelatedInformation1)\n\treturn d.MandateRelatedInformation\n}\n\nfunc (d *DirectDebitTransaction1) AddCreditorSchemeIdentification() *PartyIdentification8 {\n\td.CreditorSchemeIdentification = new(PartyIdentification8)\n\treturn d.CreditorSchemeIdentification\n}\n\n\n\nfunc (d *DirectDebitTransaction1) SetPreNotificationDate(value string) {\n\td.PreNotificationDate = (*ISODate)(&value)\n}\n\nfunc (d *DirectDebitTransaction1) SetPreNotificationIdentification(value string) ", "output": "{\n\td.PreNotificationIdentification = (*Max35Text)(&value)\n}"}
{"input": "package graceful\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/zenazn/goji/graceful/listener\"\n)\n\n\n\n\ntype gracefulServer struct {\n\tnet.Listener\n\ts *http.Server\n}\n\nfunc (g gracefulServer) Close() error {\n\tg.s.SetKeepAlivesEnabled(false)\n\treturn g.Listener.Close()\n}\n\n\ntype connState func(net.Conn, http.ConnState)\n\n\n\nfunc (srv *Server) Serve(l net.Listener) error {\n\tshadow := *(*http.Server)(srv)\n\tshadow.ConnState = connState(shadow.ConnState).Wrap\n\n\tl = gracefulServer{l, &shadow}\n\twrap := listener.Wrap(l, listener.Automatic)\n\tappendListener(wrap)\n\n\terr := shadow.Serve(wrap)\n\treturn peacefulError(err)\n}\n\nfunc (c connState) Wrap(nc net.Conn, s http.ConnState) ", "output": "{\n\tswitch s {\n\tcase http.StateIdle:\n\t\tif err := listener.MarkIdle(nc); err != nil {\n\t\t\tlog.Printf(\"error marking conn as idle: %v\", err)\n\t\t}\n\tcase http.StateHijacked:\n\t\tif err := listener.Disown(nc); err != nil {\n\t\t\tlog.Printf(\"error disowning hijacked conn: %v\", err)\n\t\t}\n\t}\n\tif c != nil {\n\t\tc(nc, s)\n\t}\n}"}
{"input": "package metadata\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/cpg1111/kubongo/hostProvider\"\n)\n\n\ntype Instances []hostProvider.Instance\n\n\n\n\nvar current *Instances\n\n\nfunc New(firstInstance *hostProvider.Instance) *Instances {\n\tif current != nil {\n\t\treturn current\n\t}\n\tif firstInstance != nil {\n\t\tcurrent = &Instances{*firstInstance}\n\t\treturn current\n\t}\n\tcurrent = &Instances{}\n\treturn current\n}\n\n\nfunc AddInstance(list *Instances, instance hostProvider.Instance) *Instances {\n\tnewList := append(*list, instance)\n\tlist = &newList\n\treturn list\n}\n\n\nfunc RemoveInstance(list Instances, instance hostProvider.Instance) Instances {\n\tnewList := make(Instances, len(list)-1)\n\tfor i := range list {\n\t\tcastInst := list[i].(hostProvider.LocalInstance)\n\t\tcastOther := instance.(hostProvider.LocalInstance)\n\t\tif castInst.Name != castOther.Name {\n\t\t\tnewList[i] = list[i]\n\t\t}\n\t}\n\treturn newList\n}\n\nfunc (inst Instances) ToMap() (instanceMap map[string]hostProvider.Instance) ", "output": "{\n\tfor i := range inst {\n\t\tcastInst := inst[i].(hostProvider.LocalInstance)\n\t\tinstanceMap[fmt.Sprintf(\"%v\", castInst.Name)] = inst[i]\n\t}\n\treturn\n}"}
{"input": "package authorization\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/ransoni/uchiwa/uchiwa/authentication\"\n\t\"github.com/ransoni/uchiwa/uchiwa/logger\"\n)\n\n\n\ntype Authorization interface {\n\tHandler(http.Handler) http.Handler\n}\n\n\ntype Uchiwa struct{}\n\n\nfunc (u *Uchiwa) Handler(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\treadonly := isReadOnly(r)\n\t\tauthorized := isAuthorized(readonly, r.Method)\n\t\tif !authorized {\n\t\t\thttp.Error(w, \"Request forbidden\", http.StatusForbidden)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc isAuthorized(isReadOnly bool, method string) bool {\n\tif (method != http.MethodHead && method != http.MethodGet) && isReadOnly {\n\t\treturn false\n\t}\n\treturn true\n}\n\n\n\n\n\nfunc isReadOnly(r *http.Request) bool ", "output": "{\n\tvar role *authentication.Role\n\n\ttoken := authentication.GetJWTFromContext(r)\n\tif token == nil { \n\t\tlogger.Debug(\"No JWT found in context\")\n\t\treturn false\n\t}\n\n\trole, err := authentication.GetRoleFromToken(token)\n\tif err != nil {\n\t\tlogger.Debug(\"Invalid token: %s\", err)\n\t\treturn true\n\t}\n\n\treturn role.Readonly\n}"}
{"input": "package instrument\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/uber-go/tally\"\n\t\"github.com/uber-go/tally/m3\"\n\t\"github.com/uber-go/tally/prometheus\"\n)\n\n\ntype MetricSanitizationType int\n\nconst (\n\tNoMetricSanitization MetricSanitizationType = iota\n\n\tM3MetricSanitization\n\n\tPrometheusMetricSanitization\n\n\tdefaultMetricSanitization = NoMetricSanitization\n)\n\nvar (\n\tvalidMetricSanitizationTypes = []MetricSanitizationType{\n\t\tNoMetricSanitization,\n\t\tM3MetricSanitization,\n\t\tPrometheusMetricSanitization,\n\t}\n)\n\nfunc (t MetricSanitizationType) String() string {\n\tswitch t {\n\tcase NoMetricSanitization:\n\t\treturn \"none\"\n\tcase M3MetricSanitization:\n\t\treturn \"m3\"\n\tcase PrometheusMetricSanitization:\n\t\treturn \"prometheus\"\n\t}\n\treturn \"unknown\"\n}\n\n\n\n\n\nfunc (t *MetricSanitizationType) NewOptions() *tally.SanitizeOptions {\n\tswitch *t {\n\tcase NoMetricSanitization:\n\t\treturn nil\n\tcase M3MetricSanitization:\n\t\treturn &m3.DefaultSanitizerOpts\n\tcase PrometheusMetricSanitization:\n\t\treturn &prometheus.DefaultSanitizerOpts\n\t}\n\treturn nil\n}\n\nfunc (t *MetricSanitizationType) UnmarshalYAML(unmarshal func(interface{}) error) error ", "output": "{\n\tvar str string\n\tif err := unmarshal(&str); err != nil {\n\t\treturn err\n\t}\n\tif str == \"\" {\n\t\t*t = defaultMetricSanitization\n\t\treturn nil\n\t}\n\tstrs := make([]string, 0, len(validMetricSanitizationTypes))\n\tfor _, valid := range validMetricSanitizationTypes {\n\t\tif str == valid.String() {\n\t\t\t*t = valid\n\t\t\treturn nil\n\t\t}\n\t\tstrs = append(strs, \"'\"+valid.String()+\"'\")\n\t}\n\treturn fmt.Errorf(\"invalid MetricSanitizationType '%s' valid types are: %s\",\n\t\tstr, strings.Join(strs, \", \"))\n}"}
{"input": "package main\n\nimport (\n    \"fmt\"\n    \"html/template\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"os\"\n)\n\ntype Page struct {\n\tTitle string\n\tBody  []byte\n}\n\nfunc (p *Page) save() error {\n\tfilename := p.Title + \".txt\"\n\treturn ioutil.WriteFile(filename, p.Body, 0600)\n}\n\nfunc loadPage(title string) (*Page, error) {\n\tfilename := title + \".txt\"\n\tbody, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Page{Title: title, Body: body}, nil\n}\n\n\n\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/view/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        http.Redirect(w, r, \"/edit/\" + title, http.StatusFound)\n        return\n    }\n    renderTemplate(w, \"view\", p)\n}\n\nfunc editHandler(w http.ResponseWriter, r *http.Request) {\n    title := r.URL.Path[len(\"/edit/\"):]\n    p, err := loadPage(title)\n    if err != nil {\n        p = &Page{Title: title}\n    }\n    renderTemplate(w, \"edit\", p)\n}\n\nfunc main() {\n    http.HandleFunc(\"/view/\", viewHandler)\n    http.HandleFunc(\"/edit/\", editHandler)\n    \n    fmt.Println(\"starting http service ...\")\n    http.ListenAndServe(os.Getenv(\"IP\") + \":\" + os.Getenv(\"PORT\"), nil)\n}\n\nfunc renderTemplate(w http.ResponseWriter, tmpl string, p *Page) ", "output": "{\n    t, _ := template.ParseFiles(tmpl + \".html\")\n    t.Execute(w, p)\n}"}
{"input": "package conway\n\nimport (\n\t\"fmt\"\n)\n\n\n\nfunc Example_twoCells() {\n\tvar p = Population{cells: map[Cell]int{\n\t\tCell{0, 0}: 0,\n\t\tCell{0, 1}: 0,\n\t},\n\t\tpopNumber: 0,\n\t}\n\tp.Next()\n\tfmt.Println(p)\n}\n\nfunc Example_blinker() {\n\tvar p = Population{cells: map[Cell]int{\n\t\tCell{0, 0}:  0,\n\t\tCell{0, 1}:  0,\n\t\tCell{0, -1}: 0,\n\t},\n\t\tpopNumber: 0,\n\t}\n\tp.SaveToFile(\"blinker0.log\")\n\tp.Next()\n\tp.SaveToFile(\"blinker1.log\")\n\tfmt.Println(len(p.cells))\n}\n\nfunc Example_singleCell() ", "output": "{\n\tvar p = Population{cells: map[Cell]int{\n\t\tCell{0, 0}: 0,\n\t},\n\t\tpopNumber: 0,\n\t}\n\tp.Next()\n\tfmt.Println(p)\n}"}
{"input": "package restful\n\n\n\n\nimport (\n    \"github.com/emicklei/go-restful/log\"\n)\n\nvar trace bool = false\nvar traceLogger log.StdLogger\n\nfunc init() {\n    traceLogger = log.Logger \n}\n\n\n\nfunc TraceLogger(logger log.StdLogger) {\n    traceLogger = logger\n    EnableTracing(logger != nil)\n}\n\n\n\n\n\nfunc EnableTracing(enabled bool) {\n    trace = enabled\n}\n\nfunc SetLogger(customLogger log.StdLogger) ", "output": "{\n    log.SetLogger(customLogger)\n}"}
{"input": "package infrastructure\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"log\"\n\n\t\"github.com/kendellfab/publish/domain\"\n\t_ \"github.com/mxk/go-sqlite/sqlite3\"\n)\n\n\n\nfunc ConnectDb(config *domain.Config) *sql.DB {\n\tif config == nil || config.Sqlite == nil {\n\t\tlog.Fatal(errors.New(\"Publish: Database config required!\"))\n\t}\n\tdb, err := sql.Open(\"sqlite3\", config.Sqlite.Path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn db\n}\n\nfunc init() ", "output": "{\n\tCurrentDb = DbSqlite\n}"}
{"input": "package app\n\nimport (\n\t\"crypto/sha256\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"sort\"\n\t\"sync\"\n\n\t\"github.com/mohae/contour\"\n)\n\n\n\n\ntype SHA256Result struct {\n\tpath string\n\tsum  [sha256.Size]byte\n\terr  error\n}\n\nfunc SHA256Digester(done <-chan struct{}, paths <-chan string, c chan<- SHA256Result) {\n\tfor path := range paths {\n\t\tdata, err := ioutil.ReadFile(path)\n\t\tselect {\n\t\tcase c <- SHA256Result{path, sha256.Sum256(data), err}:\n\t\tcase <-done:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n\nfunc SHA256All(root string) (map[string][sha256.Size]byte, error) {\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\tpaths, errc := walkFiles(done, root)\n\n\tc := make(chan SHA256Result)\n\tvar wg sync.WaitGroup\n\twg.Add(parallelism)\n\tfor i := 0; i < parallelism; i++ {\n\t\tgo func() {\n\t\t\tSHA256Digester(done, paths, c)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(c)\n\t}()\n\n\tsha := make(map[string][sha256.Size]byte)\n\tfor r := range c {\n\t\tif r.err != nil {\n\t\t\treturn nil, r.err\n\t\t}\n\t\tsha[r.path] = r.sum\n\t}\n\tif err := <-errc; err != nil {\n\t\treturn nil, err\n\t}\n\treturn sha, nil\n}\n\nfunc SHA256(path string) (string, error) ", "output": "{\n\tm, err := SHA256All(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar paths []string\n\tfor path := range m {\n\t\tpaths = append(paths, path)\n\t}\n\tsort.Strings(paths)\n\tfor _, path := range paths {\n\t\tfmt.Printf(\"%x %s\\n\", m[path], path)\n\t}\n\treturn \"\", nil\n}"}
{"input": "package validate_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/lxc/lxd/shared/validate\"\n)\n\n\n\nfunc ExampleIsNetworkMAC() ", "output": "{\n\ttests := []string{\n\t\t\"00:00:5e:00:53:01\",\n\t\t\"02:00:5e:10:00:00:00:01\", \n\t\t\"00-00-5e-00-53-01\",       \n\t\t\"0000.5e00.5301\",          \n\t\t\"invalid\",\n\t\t\"\",\n\t}\n\n\tfor _, v := range tests {\n\t\terr := validate.IsNetworkMAC(v)\n\t\tfmt.Printf(\"%s, %t\\n\", v, err == nil)\n\t}\n\n}"}
{"input": "package tests\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/google/go-github/github\"\n\t\"golang.org/x/oauth2\"\n)\n\nvar (\n\tclient *github.Client\n\n\tauth bool\n)\n\nfunc init() {\n\ttoken := os.Getenv(\"GITHUB_AUTH_TOKEN\")\n\tif token == \"\" {\n\t\tprint(\"!!! No OAuth token. Some tests won't run. !!!\\n\\n\")\n\t\tclient = github.NewClient(nil)\n\t} else {\n\t\ttc := oauth2.NewClient(context.Background(), oauth2.StaticTokenSource(\n\t\t\t&oauth2.Token{AccessToken: token},\n\t\t))\n\t\tclient = github.NewClient(tc)\n\t\tauth = true\n\t}\n\n\tvars := []string{envKeyGitHubUsername, envKeyGitHubPassword, envKeyClientID, envKeyClientSecret}\n\n\tfor _, v := range vars {\n\t\tvalue := os.Getenv(v)\n\t\tif value == \"\" {\n\t\t\tprint(\"!!! \" + fmt.Sprintf(msgEnvMissing, v) + \" !!!\\n\\n\")\n\t\t}\n\t}\n\n}\n\n\n\nfunc createRandomTestRepository(owner string, autoinit bool) (*github.Repository, error) {\n\tvar repoName string\n\tfor {\n\t\trepoName = fmt.Sprintf(\"test-%d\", rand.Int())\n\t\t_, resp, err := client.Repositories.Get(owner, repoName)\n\t\tif err != nil {\n\t\t\tif resp.StatusCode == http.StatusNotFound {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\trepo, _, err := client.Repositories.Create(\"\", &github.Repository{Name: github.String(repoName), AutoInit: github.Bool(autoinit)})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn repo, nil\n}\n\nfunc checkAuth(name string) bool ", "output": "{\n\tif !auth {\n\t\tfmt.Printf(\"No auth - skipping portions of %v\\n\", name)\n\t}\n\treturn auth\n}"}
{"input": "package configcore\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/snapcore/snapd/dirs\"\n\t\"github.com/snapcore/snapd/overlord/configstate/config\"\n\t\"github.com/snapcore/snapd/systemd\"\n)\n\nfunc init() {\n\tsupportedConfigurations[\"core.system.disable-backlight-service\"] = true\n}\n\n\n\ntype backlightSysdLogger struct{}\n\nfunc (l *backlightSysdLogger) Notify(status string) {\n\tfmt.Fprintf(Stderr, \"sysd: %s\\n\", status)\n}\n\n\n\n\nfunc handleBacklightServiceConfiguration(tr config.ConfGetter, opts *fsOnlyContext) error {\n\tvar sysd systemd.Systemd\n\tconst serviceName = \"systemd-backlight@.service\"\n\tif opts != nil {\n\t\tsysd = systemd.NewEmulationMode(opts.RootDir)\n\t} else {\n\t\tsysd = systemd.NewUnderRoot(dirs.GlobalRootDir, systemd.SystemMode, &backlightSysdLogger{})\n\t}\n\toutput, err := coreCfg(tr, \"system.disable-backlight-service\")\n\tif err != nil {\n\t\treturn nil\n\t}\n\tif output != \"\" {\n\t\tswitch output {\n\t\tcase \"true\":\n\t\t\treturn sysd.Mask(serviceName)\n\t\tcase \"false\":\n\t\t\treturn sysd.Unmask(serviceName)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unsupported disable-backlight-service option: %q\", output)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc validateBacklightServiceSettings(tr config.ConfGetter) error ", "output": "{\n\treturn validateBoolFlag(tr, \"system.disable-backlight-service\")\n}"}
{"input": "package resourceapply\n\nimport (\n\t\"testing\"\n\n\t\"github.com/openshift/library-go/pkg/operator/events\"\n\t\"k8s.io/client-go/kubernetes/fake\"\n\n\t\"github.com/davecgh/go-spew/spew\"\n)\n\nfunc TestApplyDirectly(t *testing.T) {\n\trequiredObj, gvk, err := genericCodec.Decode([]byte(`apiVersion: v1\nkind: Namespace\nmetadata:\n  name: openshift-apiserver\n  labels:\n    openshift.io/run-level: \"1\"\n`), nil, nil)\n\tt.Log(spew.Sdump(requiredObj))\n\tt.Log(spew.Sdump(gvk))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n\n\nfunc TestApplyDirectlyUnhandledType(t *testing.T) ", "output": "{\n\tfakeClient := fake.NewSimpleClientset()\n\tcontent := func(name string) ([]byte, error) {\n\t\treturn []byte(`apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: sample-claim\n  labels:\n    openshift.io/run-level: \"1\"\n`), nil\n\t}\n\trecorder := events.NewInMemoryRecorder(\"\")\n\tret := ApplyDirectly(fakeClient, recorder, content, \"pvc\")\n\tif ret[0].Error == nil {\n\t\tt.Fatal(\"missing expected error\")\n\t} else if ret[0].Error.Error() != \"unhandled type *v1.PersistentVolumeClaim\" {\n\t\tt.Fatal(ret[0].Error)\n\t}\n}"}
{"input": "package lib\n\nimport (\n\t\"github.com/appc/acbuild/util\"\n\n\t\"github.com/appc/spec/schema\"\n\t\"github.com/appc/spec/schema/types\"\n)\n\n\n\n\n\n\nfunc (a *ACBuild) AddDependency(imageName types.ACIdentifier, imageId *types.Hash, labels types.Labels, size uint) (err error) {\n\tif err = a.lock(); err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err1 := a.unlock(); err == nil {\n\t\t\terr = err1\n\t\t}\n\t}()\n\n\tfn := func(s *schema.ImageManifest) error {\n\t\tremoveDep(imageName)(s)\n\t\ts.Dependencies = append(s.Dependencies,\n\t\t\ttypes.Dependency{\n\t\t\t\tImageName: imageName,\n\t\t\t\tImageID:   imageId,\n\t\t\t\tLabels:    labels,\n\t\t\t\tSize:      size,\n\t\t\t})\n\t\treturn nil\n\t}\n\treturn util.ModifyManifest(fn, a.CurrentACIPath)\n}\n\n\n\nfunc (a *ACBuild) RemoveDependency(imageName string) (err error) {\n\tif err = a.lock(); err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err1 := a.unlock(); err == nil {\n\t\t\terr = err1\n\t\t}\n\t}()\n\n\tacid, err := types.NewACIdentifier(imageName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn util.ModifyManifest(removeDep(*acid), a.CurrentACIPath)\n}\n\nfunc removeDep(imageName types.ACIdentifier) func(*schema.ImageManifest) error ", "output": "{\n\treturn func(s *schema.ImageManifest) error {\n\t\tfoundOne := false\n\t\tfor i := len(s.Dependencies) - 1; i >= 0; i-- {\n\t\t\tif s.Dependencies[i].ImageName == imageName {\n\t\t\t\tfoundOne = true\n\t\t\t\ts.Dependencies = append(\n\t\t\t\t\ts.Dependencies[:i],\n\t\t\t\t\ts.Dependencies[i+1:]...)\n\t\t\t}\n\t\t}\n\t\tif !foundOne {\n\t\t\treturn ErrNotFound\n\t\t}\n\t\treturn nil\n\t}\n}"}
{"input": "package behaviors\n\n\n\n\n\nimport (\n\t\"github.com/tideland/golib/cells\"\n\t\"github.com/tideland/golib/logger\"\n)\n\n\n\n\n\n\ntype CallbackFunc func(topic string, payload cells.Payload) error\n\n\n\ntype callbackBehavior struct {\n\tctx           cells.Context\n\tcallbackFuncs []CallbackFunc\n}\n\n\n\n\nfunc NewCallbackBehavior(cbfs ...CallbackFunc) cells.Behavior {\n\tif len(cbfs) == 0 {\n\t\tlogger.Errorf(\"callback created without callback functions\")\n\t}\n\treturn &callbackBehavior{nil, cbfs}\n}\n\n\nfunc (b *callbackBehavior) Init(ctx cells.Context) error {\n\tb.ctx = ctx\n\treturn nil\n}\n\n\n\n\n\nfunc (b *callbackBehavior) ProcessEvent(event cells.Event) error {\n\tfor _, callbackFunc := range b.callbackFuncs {\n\t\tif err := callbackFunc(event.Topic(), event.Payload()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (b *callbackBehavior) Recover(err interface{}) error {\n\treturn nil\n}\n\nfunc (b *callbackBehavior) Terminate() error ", "output": "{\n\treturn nil\n}"}
{"input": "package engine\n\nimport (\n\t\"time\"\n\n\t\"github.com/aws/amazon-ecs-agent/agent/api\"\n)\n\n\n\ntype impossibleTransitionError struct {\n\tstate api.ContainerStatus\n}\n\nfunc (err *impossibleTransitionError) Error() string {\n\treturn \"Cannot transition to \" + err.state.String()\n}\nfunc (err *impossibleTransitionError) ErrorName() string { return \"ImpossibleStateTransitionError\" }\n\ntype DockerTimeoutError struct {\n\tduration   time.Duration\n\ttransition string\n}\n\nfunc (err *DockerTimeoutError) Error() string {\n\treturn \"Could not transition to \" + err.transition + \"; timed out after waiting \" + err.duration.String()\n}\n\n\ntype ContainerVanishedError struct{}\n\nfunc (err ContainerVanishedError) Error() string     { return \"No container matching saved ID found\" }\nfunc (err ContainerVanishedError) ErrorName() string { return \"ContainerVanishedError\" }\n\ntype CannotXContainerError struct {\n\ttransition string\n\tmsg        string\n}\n\nfunc (err CannotXContainerError) Error() string { return err.msg }\nfunc (err CannotXContainerError) ErrorName() string {\n\treturn \"Cannot\" + err.transition + \"ContainerError\"\n}\n\ntype OutOfMemoryError struct{}\n\nfunc (err OutOfMemoryError) Error() string     { return \"Container killed due to memory usage\" }\nfunc (err OutOfMemoryError) ErrorName() string { return \"OutOfMemoryError\" }\n\n\ntype DockerStateError struct {\n\tdockerError string\n\tname        string\n}\n\nfunc NewDockerStateError(err string) DockerStateError {\n\treturn DockerStateError{\n\t\tdockerError: err,\n\t\tname:        \"DockerStateError\",\n\t}\n}\n\nfunc (err DockerStateError) Error() string {\n\treturn err.dockerError\n}\nfunc (err DockerStateError) ErrorName() string {\n\treturn err.name\n}\n\nfunc (err *DockerTimeoutError) ErrorName() string ", "output": "{ return \"DockerTimeoutError\" }"}
{"input": "package esicache\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/corestoreio/errors\"\n)\n\n\n\n\ntype Cacher interface {\n\tSet(key string, value []byte, expiration time.Duration) error\n\tGet(key string) ([]byte, error)\n}\n\n\n\nfunc NewCacher(url string) (Cacher, error) {\n\n\treturn nil, nil\n}\n\n\ntype Caches []Cacher\n\n\nfunc (c Caches) Set(key string, value []byte, expiration time.Duration) error {\n\treturn nil\n}\n\n\nfunc (c Caches) Get(key string) ([]byte, error) {\n\treturn nil, nil\n}\n\n\nvar MainRegistry = &registry{\n\tcaches: make(map[string]Caches),\n}\n\ntype registry struct {\n\tmu sync.RWMutex\n\tcaches map[string]Caches\n}\n\nfunc (r *registry) Get(ctx context.Context, scope, alias, key string) error {\n\treturn errors.New(\"TODO IMPLEMENT\")\n}\n\n\n\n\nfunc (r *registry) Register(scope, url string) error {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tc, err := NewCacher(url)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"[esikv] NewCacher URL %q\", url)\n\t}\n\n\tif _, ok := r.caches[scope]; !ok {\n\t\tr.caches[scope] = make(Caches, 0, 2)\n\t}\n\tr.caches[scope] = append(r.caches[scope], c)\n\n\treturn nil\n}\n\n\nfunc (r *registry) Len(scope string) int {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\treturn len(r.caches[scope])\n}\n\n\n\n\nfunc (r *registry) Clear() ", "output": "{\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.caches = make(map[string]Caches)\n}"}
{"input": "package iso20022\n\n\ntype UnmatchedReason15Choice struct {\n\n\tCode *UnmatchedReason10Code `xml:\"Cd\"`\n\n\tProprietary *GenericIdentification20 `xml:\"Prtry\"`\n}\n\nfunc (u *UnmatchedReason15Choice) SetCode(value string) {\n\tu.Code = (*UnmatchedReason10Code)(&value)\n}\n\n\n\nfunc (u *UnmatchedReason15Choice) AddProprietary() *GenericIdentification20 ", "output": "{\n\tu.Proprietary = new(GenericIdentification20)\n\treturn u.Proprietary\n}"}
{"input": "package pet\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-swagger/go-swagger/httpkit\"\n\n\t\"github.com/go-swagger/go-swagger/examples/generated/models\"\n)\n\n\ntype GetPetByIDOK struct {\n\n\tPayload *models.Pet `json:\"body,omitempty\"`\n}\n\n\nfunc NewGetPetByIDOK() GetPetByIDOK {\n\treturn GetPetByIDOK{}\n}\n\n\nfunc (o *GetPetByIDOK) WriteResponse(rw http.ResponseWriter, producer httpkit.Producer) {\n\n\trw.WriteHeader(200)\n\tif o.Payload != nil {\n\t\tif err := producer.Produce(rw, o.Payload); err != nil {\n\t\t\tpanic(err) \n\t\t}\n\t}\n}\n\n\ntype GetPetByIDBadRequest struct {\n}\n\n\nfunc NewGetPetByIDBadRequest() GetPetByIDBadRequest {\n\treturn GetPetByIDBadRequest{}\n}\n\n\nfunc (o *GetPetByIDBadRequest) WriteResponse(rw http.ResponseWriter, producer httpkit.Producer) {\n\n\trw.WriteHeader(400)\n}\n\n\ntype GetPetByIDNotFound struct {\n}\n\n\nfunc NewGetPetByIDNotFound() GetPetByIDNotFound {\n\treturn GetPetByIDNotFound{}\n}\n\n\n\n\nfunc (o *GetPetByIDNotFound) WriteResponse(rw http.ResponseWriter, producer httpkit.Producer) ", "output": "{\n\n\trw.WriteHeader(404)\n}"}
{"input": "package protocol\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\n\t\"github.com/aws/aws-sdk-go/aws/request\"\n)\n\n\nvar UnmarshalDiscardBodyHandler = request.NamedHandler{Name: \"awssdk.shared.UnmarshalDiscardBody\", Fn: UnmarshalDiscardBody}\n\n\n\n\nfunc UnmarshalDiscardBody(r *request.Request) ", "output": "{\n\tif r.HTTPResponse == nil || r.HTTPResponse.Body == nil {\n\t\treturn\n\t}\n\n\tio.Copy(ioutil.Discard, r.HTTPResponse.Body)\n\tr.HTTPResponse.Body.Close()\n}"}
{"input": "package store\n\nimport (\n\t\"encoding/binary\"\n\t\"strconv\"\n)\n\ntype Identity uint64\n\ntype Identities []Identity\n\nfunc (i Identity) Bytes() []byte {\n\tvar buf [8]byte\n\tbinary.BigEndian.PutUint64(buf[:], uint64(i))\n\treturn buf[:]\n}\n\nfunc (i Identity) String() string {\n\treturn strconv.FormatUint(uint64(i), 10)\n}\n\n\n\nfunc StringToIdentity(idString string) (Identity, error) {\n\tidInt, err := strconv.Atoi(idString)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn Identity(idInt), nil\n}\n\nfunc (i Identities) Distinct() Identities ", "output": "{\n\tset := map[Identity]bool{}\n\tfor _, id := range i {\n\t\tset[id] = true\n\t}\n\tvalues := make([]Identity, 0, len(set))\n\tfor id := range set {\n\t\tvalues = append(values, id)\n\t}\n\treturn Identities(values)\n}"}
{"input": "package ingester\n\nimport (\n\t\"sync\"\n\t\"unsafe\"\n\n\t\"github.com/prometheus/common/model\"\n)\n\nconst (\n\tcacheLineSize = 64\n)\n\n\ntype paddedMutex struct {\n\tsync.Mutex\n\tpad [cacheLineSize - unsafe.Sizeof(sync.Mutex{})]byte\n}\n\n\n\n\n\n\n\n\n\n\n\ntype fingerprintLocker struct {\n\tfpMtxs    []paddedMutex\n\tnumFpMtxs uint\n}\n\n\n\n\n\n\nfunc (l *fingerprintLocker) Lock(fp model.Fingerprint) {\n\tl.fpMtxs[hashFP(fp)%l.numFpMtxs].Lock()\n}\n\n\nfunc (l *fingerprintLocker) Unlock(fp model.Fingerprint) {\n\tl.fpMtxs[hashFP(fp)%l.numFpMtxs].Unlock()\n}\n\n\n\n\n\n\n\n\nfunc hashFP(fp model.Fingerprint) uint {\n\treturn uint(fp ^ (fp >> 32) ^ (fp >> 16))\n}\n\nfunc newFingerprintLocker(preallocatedMutexes int) *fingerprintLocker ", "output": "{\n\tif preallocatedMutexes < 1024 {\n\t\tpreallocatedMutexes = 1024\n\t}\n\treturn &fingerprintLocker{\n\t\tmake([]paddedMutex, preallocatedMutexes),\n\t\tuint(preallocatedMutexes),\n\t}\n}"}
{"input": "package next\n\nimport (\n    \"gopkg.in/mgo.v2\"\n    \"gopkg.in/mgo.v2/bson\"\n)\n\ntype MongoDB struct {\n    session *mgo.Session\n    db string\n}\n\nfunc NewMongoDB() *MongoDB {\n    return &MongoDB{}\n}\n\nfunc (mongo *MongoDB) Open(url string, db string) {\n    s, err := mgo.Dial(url)\n    if err != nil {\n        panic(err.Error())\n    }\n\n    mongo.session = s\n    mongo.db = db\n}\n\nfunc (mongo *MongoDB) Close() {\n    mongo.session.Close()\n}\n\nfunc (mongo *MongoDB) Session() *mgo.Session {\n    s := mongo.session.Copy()\n    s.SetMode(mgo.Strong, true)\n    return s\n}\n\n\n\nfunc (mongo *MongoDB) InsertOrUpdate(collection string, buziKey string, buziValue interface{}, d interface{}, result interface{}) (error) ", "output": "{\n    s := mongo.Session()\n    defer s.Close()\n\n    c := s.DB(mongo.db).C(collection)\n\n    change := mgo.Change{\n        Update:     bson.M{\"$set\": d},\n        Upsert:     true,\n        Remove:     false,\n        ReturnNew:  true,\n    }\n\n    _, err := c.Find(bson.M{buziKey: buziValue}).Apply(change, result)\n    return err\n}"}
{"input": "package leftpad\n\nimport \"testing\"\n\nfunc TestLength(t *testing.T) {\n\texpected := \"*********I\"\n\texpectedLen := len(expected)\n\n\tres, err := PadLeft(\"I\", \"*\", 10)\n\tif err != nil {\n\t\tt.Error(\"Unexpected error\", err)\n\t}\n\tif len(res) != len(res) {\n\t\tt.Errorf(\"Expected %d, got %d\", expectedLen, len(res))\n\t}\n}\n\n\n\nfunc TestBadTargetLength(t *testing.T) {\n\tpadLengths := []int{3, 2, 1}\n\tfor _, length := range padLengths {\n\t\t_, err := PadLeft(\"src\", \"*\", length)\n\t\tif err == nil {\n\t\t\tt.Error(\"Expected length error, got nil\")\n\t\t}\n\t}\n}\n\nfunc TestBadPaddingChar(t *testing.T) {\n\tpadChars := []string{\"\", \"aa\", \"  \"}\n\n\tfor _, pchar := range padChars {\n\t\t_, err := PadLeft(\"src\", pchar, 10)\n\t\tif err == nil {\n\t\t\tt.Error(\"Expected padding char error, got nil\")\n\t\t}\n\t}\n}\n\nfunc TestPadLeft(t *testing.T) ", "output": "{\n\texpected := \"*********I\"\n\n\tresult, err := PadLeft(\"I\", \"*\", 10)\n\tif err != nil {\n\t\tt.Error(\"Unexpected error\", err)\n\t}\n\tif result != expected {\n\t\tt.Errorf(\"Expected %s, got %s\", expected, result)\n\t}\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSECSService_NetworkConfiguration struct {\n\n\tAwsvpcConfiguration *AWSECSService_AwsVpcConfiguration `json:\"AwsvpcConfiguration,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSECSService_NetworkConfiguration) AWSCloudFormationType() string {\n\treturn \"AWS::ECS::Service.NetworkConfiguration\"\n}\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\n\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSECSService_NetworkConfiguration) Metadata() map[string]interface{} ", "output": "{\n\treturn r._metadata\n}"}
{"input": "package filesystem\n\ntype FileSystem struct{}\n\nconst name = \"filesystem\"\n\n\n\nfunc (self *FileSystem) Collect() (result interface{}, err error) {\n\tresult, err = getFileSystemInfo()\n\treturn\n}\n\nfunc (self *FileSystem) Name() string ", "output": "{\n\treturn name\n}"}
{"input": "package pipe\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc TestReduceChanTypeCoercion(t *testing.T) {\n\tappendToString := func(str string, item fmt.Stringer) string {\n\t\treturn fmt.Sprintf(\"%s%s\", str, item.String())\n\t}\n\n\tin := make(chan testStringer, 5)\n\n\tgo func() {\n\t\tin <- 1\n\t\tin <- 2\n\t\tin <- 3\n\t\tclose(in)\n\t}()\n\n\tout := ReduceChan(appendToString, \"a\", in).(string)\n\n\tif out != \"a123\" {\n\t\tt.Fatal(\"ReduceChan(appendToString, \\\"a\\\", chan testStringer) output \", out)\n\t}\n}\n\nfunc TestReduceChan(t *testing.T) ", "output": "{\n\tin := make(chan int, 5)\n\n\tgo func() {\n\t\tin <- 5\n\t\tin <- 10\n\t\tin <- 20\n\t\tclose(in)\n\t}()\n\n\tout := ReduceChan(sum, 0, in).(int)\n\n\tif out != 35 {\n\t\tt.Fatal(\"ReduceChan(sum, 0, []int{5, 10, 20}) output \", out)\n\t}\n}"}
{"input": "package grpclog \n\nimport \"os\"\n\nvar logger = newLoggerV2()\n\n\nfunc V(l int) bool {\n\treturn logger.V(l)\n}\n\n\nfunc Info(args ...interface{}) {\n\tlogger.Info(args...)\n}\n\n\n\n\n\nfunc Infoln(args ...interface{}) {\n\tlogger.Infoln(args...)\n}\n\n\nfunc Warning(args ...interface{}) {\n\tlogger.Warning(args...)\n}\n\n\nfunc Warningf(format string, args ...interface{}) {\n\tlogger.Warningf(format, args...)\n}\n\n\nfunc Warningln(args ...interface{}) {\n\tlogger.Warningln(args...)\n}\n\n\nfunc Error(args ...interface{}) {\n\tlogger.Error(args...)\n}\n\n\nfunc Errorf(format string, args ...interface{}) {\n\tlogger.Errorf(format, args...)\n}\n\n\nfunc Errorln(args ...interface{}) {\n\tlogger.Errorln(args...)\n}\n\n\n\nfunc Fatal(args ...interface{}) {\n\tlogger.Fatal(args...)\n\tos.Exit(1)\n}\n\n\n\nfunc Fatalf(format string, args ...interface{}) {\n\tlogger.Fatalf(format, args...)\n\tos.Exit(1)\n}\n\n\n\nfunc Fatalln(args ...interface{}) {\n\tlogger.Fatalln(args...)\n\tos.Exit(1)\n}\n\n\n\n\nfunc Print(args ...interface{}) {\n\tlogger.Info(args...)\n}\n\n\n\n\nfunc Printf(format string, args ...interface{}) {\n\tlogger.Infof(format, args...)\n}\n\n\n\n\nfunc Println(args ...interface{}) {\n\tlogger.Infoln(args...)\n}\n\nfunc Infof(format string, args ...interface{}) ", "output": "{\n\tlogger.Infof(format, args...)\n}"}
{"input": "package machiner\n\nimport (\n\t\"github.com/juju/juju/state/api/base\"\n\t\"github.com/juju/juju/state/api/common\"\n\t\"github.com/juju/juju/state/api/params\"\n)\n\nconst machinerFacade = \"Machiner\"\n\n\ntype State struct {\n\tcaller base.Caller\n\t*common.APIAddresser\n}\n\nfunc (st *State) call(method string, params, result interface{}) error {\n\treturn st.caller.Call(machinerFacade, \"\", method, params, result)\n}\n\n\nfunc NewState(caller base.Caller) *State {\n\treturn &State{\n\t\tcaller:       caller,\n\t\tAPIAddresser: common.NewAPIAddresser(machinerFacade, caller),\n\t}\n\n}\n\n\nfunc (st *State) machineLife(tag string) (params.Life, error) {\n\treturn common.Life(st.caller, machinerFacade, tag)\n}\n\n\n\n\nfunc (st *State) Machine(tag string) (*Machine, error) ", "output": "{\n\tlife, err := st.machineLife(tag)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Machine{\n\t\ttag:  tag,\n\t\tlife: life,\n\t\tst:   st,\n\t}, nil\n}"}
{"input": "package pai\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"sqlflow.org/sqlflow/go/model\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGetCheckpointDir(t *testing.T) {\n\ta := assert.New(t)\n\tos.Setenv(\"SQLFLOW_OSS_CHECKPOINT_CONFIG\", \"{\\\"host\\\": \\\"h.com\\\", \\\"arn\\\": \\\"acs:ram::9527:role\\\"}\")\n\tdefer os.Unsetenv(\"SQLFLOW_OSS_CHECKPOINT_CONFIG\")\n\tossModelPath, project := \"p/t/m\", \"pr0j\"\n\n\tckpoint, err := getCheckpointDir(ossModelPath, project)\n\ta.NoError(err)\n\texpectedCkp := fmt.Sprintf(\"oss:%s/p/t/m/?role_arn=acs:ram::9527:role/pai2osspr0j&host=h.com\", model.BucketName)\n\ta.Equal(expectedCkp, ckpoint)\n}\n\n\n\nfunc TestGenRoleName(t *testing.T) ", "output": "{\n\ta := assert.New(t)\n\ta.Equal(genRoleName(\"a\"), \"pai2ossa\")\n\ta.Equal(genRoleName(\"abc\"), \"pai2ossabc\")\n\ta.Equal(genRoleName(\"a_b_c\"), \"pai2ossabc\")\n\ta.Equal(genRoleName(\"a_b_C\"), \"pai2ossabc\")\n\ta.Equal(genRoleName(\"a+b2_C\"), \"pai2ossab2c\")\n}"}
{"input": "package tcp\n\nimport (\n\t\"fmt\"\n)\n\n\ntype probeError struct {\n\taddress string\n\ttimeout bool\n\tmessage string\n\tcause   error\n}\n\nfunc (pe *probeError) Address() string {\n\treturn pe.address\n}\n\nfunc (pe *probeError) Cause() error {\n\treturn pe.cause\n}\n\n\n\nfunc (pe *probeError) Error() string {\n\tmsg := fmt.Sprintf(\n\t\t\"%s (address=%s, timeout=%t)\",\n\t\tpe.message,\n\t\tpe.address,\n\t\tpe.timeout,\n\t)\n\tif pe.cause != nil {\n\t\tmsg = fmt.Sprintf(\"%s: %v\", msg, pe.cause)\n\t}\n\treturn msg\n}\n\nfunc (pe *probeError) String() string {\n\treturn pe.Error()\n}\n\nfunc (pe *probeError) Timeout() bool ", "output": "{\n\treturn pe.timeout\n}"}
{"input": "package validator\n\nimport (\n\t\"reflect\"\n\t\"sync\"\n)\n\ntype cachedField struct {\n\tIdx       int\n\tName      string\n\tAltName   string\n\tCachedTag *cachedTag\n}\n\ntype cachedStruct struct {\n\tName   string\n\tfields map[int]cachedField\n}\n\ntype structCacheMap struct {\n\tlock sync.RWMutex\n\tm    map[reflect.Type]*cachedStruct\n}\n\nfunc (s *structCacheMap) Get(key reflect.Type) (*cachedStruct, bool) {\n\ts.lock.RLock()\n\tvalue, ok := s.m[key]\n\ts.lock.RUnlock()\n\treturn value, ok\n}\n\nfunc (s *structCacheMap) Set(key reflect.Type, value *cachedStruct) {\n\ts.lock.Lock()\n\ts.m[key] = value\n\ts.lock.Unlock()\n}\n\ntype cachedTag struct {\n\ttag             string\n\tisOmitEmpty     bool\n\tisNoStructLevel bool\n\tisStructOnly    bool\n\tdiveTag         string\n\ttags            []*tagVals\n}\n\ntype tagVals struct {\n\ttagVals [][]string\n\tisOrVal bool\n\tisAlias bool\n\ttag     string\n}\n\ntype tagCacheMap struct {\n\tlock sync.RWMutex\n\tm    map[string]*cachedTag\n}\n\nfunc (s *tagCacheMap) Get(key string) (*cachedTag, bool) {\n\ts.lock.RLock()\n\tvalue, ok := s.m[key]\n\ts.lock.RUnlock()\n\n\treturn value, ok\n}\n\n\n\nfunc (s *tagCacheMap) Set(key string, value *cachedTag) ", "output": "{\n\ts.lock.Lock()\n\ts.m[key] = value\n\ts.lock.Unlock()\n}"}
{"input": "package iso20022\n\n\ntype AccountManagementConfirmation2 struct {\n\n\tConfirmationType *AccountManagementType2Code `xml:\"ConfTp\"`\n\n\tAccountApplicationIdentification *Max35Text `xml:\"AcctApplId,omitempty\"`\n\n\tClientReference *Max35Text `xml:\"ClntRef,omitempty\"`\n\n\tCounterpartyReference *AdditionalReference2 `xml:\"CtrPtyRef,omitempty\"`\n}\n\nfunc (a *AccountManagementConfirmation2) SetConfirmationType(value string) {\n\ta.ConfirmationType = (*AccountManagementType2Code)(&value)\n}\n\n\n\nfunc (a *AccountManagementConfirmation2) SetClientReference(value string) {\n\ta.ClientReference = (*Max35Text)(&value)\n}\n\nfunc (a *AccountManagementConfirmation2) AddCounterpartyReference() *AdditionalReference2 {\n\ta.CounterpartyReference = new(AdditionalReference2)\n\treturn a.CounterpartyReference\n}\n\nfunc (a *AccountManagementConfirmation2) SetAccountApplicationIdentification(value string) ", "output": "{\n\ta.AccountApplicationIdentification = (*Max35Text)(&value)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n)\n\n\ntype Player struct {\n\tID             string\n\tName           string\n\tHealth         int\n\tHunger         int\n\tCriticalHunger bool\n\tNextAction     int\n\tDead           bool\n}\n\n\nfunc NewPlayer(ID, name string) *Player {\n\treturn &Player{ID, name, 100, 0, false, 0, false}\n}\n\nfunc (p *Player) String() string {\n\treturn fmt.Sprintf(\"[%-12s](HP: %3d)<Hunger: %3d>\", p.Name, p.Health, p.Hunger)\n}\n\n\nfunc (p *Player) AddHealth(amount int) bool {\n\tp.Health += amount\n\tif p.Health > 100 {\n\t\tp.Health = 100\n\t}\n\tif p.Health <= 0 {\n\t\tp.Health = 0\n\t\tp.Dead = true\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n\n\nfunc (p *Player) AddHunger(amount int) int ", "output": "{\n\tp.Hunger += amount\n\tif p.Hunger >= 100 {\n\t\tp.Hunger = 100\n\t\tif p.CriticalHunger {\n\t\t\treturn 2\n\t\t}\n\t\tp.CriticalHunger = true\n\t\treturn 1\n\t}\n\tif p.Hunger <= 0 {\n\t\tp.Hunger = 0\n\t}\n\treturn 0\n}"}
{"input": "package gisp\n\n\ntype Quote struct {\n\tLisp interface{}\n}\n\n\nfunc (this Quote) Eval(env Env) (interface{}, error) {\n\treturn this.Lisp, nil\n}\n\n\n\n\n\nfunc QL(args ...interface{}) Quote {\n\treturn Q(L(args...))\n}\n\nfunc Q(x interface{}) Quote ", "output": "{\n\treturn Quote{x}\n}"}
{"input": "package console\n\nimport \"github.com/cgrates/cgrates/utils\"\n\n\n\n\ntype ImportTpFromFolder struct {\n\tname      string\n\trpcMethod string\n\trpcParams *utils.AttrImportTPFromFolder\n\trpcResult string\n\t*CommandExecuter\n}\n\nfunc (self *ImportTpFromFolder) Name() string {\n\treturn self.name\n}\n\nfunc (self *ImportTpFromFolder) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\nfunc (self *ImportTpFromFolder) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &utils.AttrImportTPFromFolder{}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *ImportTpFromFolder) PostprocessRpcParams() error {\n\treturn nil\n}\n\nfunc (self *ImportTpFromFolder) RpcResult() interface{} {\n\tvar s string\n\treturn &s\n}\n\nfunc init() ", "output": "{\n\tc := &ImportTpFromFolder{\n\t\tname:      \"import_tp_from_folder\",\n\t\trpcMethod: utils.APIerSv1ImportTariffPlanFromFolder,\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}"}
{"input": "package goldengate\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ChangeDeploymentCompartmentRequest struct {\n\n\tDeploymentId *string `mandatory:\"true\" contributesTo:\"path\" name:\"deploymentId\"`\n\n\tChangeDeploymentCompartmentDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\n\n\n\nfunc (request ChangeDeploymentCompartmentRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request ChangeDeploymentCompartmentRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request ChangeDeploymentCompartmentRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ChangeDeploymentCompartmentResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response ChangeDeploymentCompartmentResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response ChangeDeploymentCompartmentResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request ChangeDeploymentCompartmentRequest) String() string ", "output": "{\n\treturn common.PointerString(request)\n}"}
{"input": "package minicon\n\nimport \"container/ring\"\n\n\n\n\ntype History struct {\n\tr *ring.Ring\n}\n\n\n\n\ntype HistoryMarker *ring.Ring\n\n\n\n\nfunc NewHistory(capacity int) *History {\n\treturn &History{ring.New(capacity)}\n}\n\n\n\n\n\n\nfunc (hs *History) Add(s string, mark HistoryMarker) HistoryMarker {\n\ths.Restore(mark)\n\tif s != \"\" && hs.r.Value != s {\n\t\ths.r.Value = s\n\t\ths.r = hs.r.Next()\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc (hs *History) Back() (string, bool) {\n\treturn hs._update(hs.r.Prev())\n}\n\n\n\n\n\nfunc (hs *History) Forward() (string, bool) {\n\treturn hs._update(hs.r.Next())\n}\n\n\n\n\nfunc (hs *History) Mark() HistoryMarker {\n\treturn hs.r\n}\n\n\n\n\nfunc (hs *History) Restore(mark HistoryMarker) {\n\tif mark != nil {\n\t\ths.r = mark\n\t}\n}\n\n\n\n\n\n\nfunc (hs *History) _update(r *ring.Ring) (ret string, okay bool) ", "output": "{\n\tif s, ok := r.Value.(string); ok && s != \"\" {\n\t\ths.r = r\n\t\tret, okay = s, ok\n\t}\n\treturn ret, okay\n}"}
{"input": "package matchers\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"gx/ipfs/QmUWtNQd8JdEiYiDqNYTUcaqyteJZ2rTNQLiw3dauLPccy/gomega/format\"\n)\n\ntype HaveKeyMatcher struct {\n\tKey interface{}\n}\n\nfunc (matcher *HaveKeyMatcher) Match(actual interface{}) (success bool, err error) {\n\tif !isMap(actual) {\n\t\treturn false, fmt.Errorf(\"HaveKey matcher expects a map.  Got:%s\", format.Object(actual, 1))\n\t}\n\n\tkeyMatcher, keyIsMatcher := matcher.Key.(omegaMatcher)\n\tif !keyIsMatcher {\n\t\tkeyMatcher = &EqualMatcher{Expected: matcher.Key}\n\t}\n\n\tkeys := reflect.ValueOf(actual).MapKeys()\n\tfor i := 0; i < len(keys); i++ {\n\t\tsuccess, err := keyMatcher.Match(keys[i].Interface())\n\t\tif err != nil {\n\t\t\treturn false, fmt.Errorf(\"HaveKey's key matcher failed with:\\n%s%s\", format.Indent, err.Error())\n\t\t}\n\t\tif success {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n\n\nfunc (matcher *HaveKeyMatcher) NegatedFailureMessage(actual interface{}) (message string) {\n\tswitch matcher.Key.(type) {\n\tcase omegaMatcher:\n\t\treturn format.Message(actual, \"not to have key matching\", matcher.Key)\n\tdefault:\n\t\treturn format.Message(actual, \"not to have key\", matcher.Key)\n\t}\n}\n\nfunc (matcher *HaveKeyMatcher) FailureMessage(actual interface{}) (message string) ", "output": "{\n\tswitch matcher.Key.(type) {\n\tcase omegaMatcher:\n\t\treturn format.Message(actual, \"to have key matching\", matcher.Key)\n\tdefault:\n\t\treturn format.Message(actual, \"to have key\", matcher.Key)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"io\"\n\t\"log\"\n)\n\ntype proxy struct {\n\ttransport *http.Transport\n\taddr      string\n}\n\nfunc newProxy(addr string) *proxy {\n\tp := &proxy{addr: addr}\n\tp.transport = &http.Transport{\n\t\tDial: p.dial,\n\t}\n\treturn p\n}\n\n\n\nfunc (p *proxy) proxyPass(w http.ResponseWriter, r *http.Request) {\n\thost, _, _ := net.SplitHostPort(r.RemoteAddr)\n\tr.Header.Add(\"X-Forwarded-For\", host)\n\tr.URL.Scheme = \"http\"\n\tr.URL.Host = r.Host\n\tresp, err := p.transport.RoundTrip(r)\n\tif err != nil {\n\t\tlog.Print(err)\n\t\tw.WriteHeader(http.StatusBadGateway)\n\t\tw.Write([]byte(\"<h1>502 Bad Gateway</h1>\"))\n\t\treturn\n\t}\n\theader := w.Header()\n\tfor k, v := range resp.Header {\n\t\tfor _, v1 := range v {\n\t\t\theader.Add(k, v1)\n\t\t}\n\t}\n\tw.WriteHeader(resp.StatusCode)\n\tio.Copy(w, resp.Body)\n\tresp.Body.Close()\n}\n\nfunc (p *proxy) dial(network string, addr string) (conn net.Conn, err error) ", "output": "{\n\treturn net.Dial(\"tcp\", p.addr)\n}"}
{"input": "package cases\n\nimport \"gx/ipfs/QmVcxhXDbXjNoAdmYBWbY1eU67kQ8eZUHjG4mAYZUtZZu3/go-text/transform\"\n\ntype caseFolder struct{ transform.NopResetter }\n\n\n\n\nfunc (t *caseFolder) Span(src []byte, atEOF bool) (n int, err error) {\n\tc := context{src: src, atEOF: atEOF}\n\tfor c.next() && isFoldFull(&c) {\n\t\tc.checkpoint()\n\t}\n\treturn c.retSpan()\n}\n\nfunc makeFold(o options) transform.SpanningTransformer {\n\treturn &caseFolder{}\n}\n\nfunc (t *caseFolder) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) ", "output": "{\n\tc := context{dst: dst, src: src, atEOF: atEOF}\n\tfor c.next() {\n\t\tfoldFull(&c)\n\t\tc.checkpoint()\n\t}\n\treturn c.ret()\n}"}
{"input": "package core\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/docker/infrakit/pkg/types\"\n)\n\ntype errBadDependency types.Dependency\n\n\n\ntype errCircularDependency []*types.Spec\n\nfunc (e errCircularDependency) Error() string {\n\tdeps := []*types.Spec(e)\n\tlist := fmt.Sprintf(\"%s/%s\", deps[0].Class, deps[0].Metadata.Name)\n\tfor _, dep := range deps[1:] {\n\t\tlist = list + fmt.Sprintf(\"=> %s/%s\", dep.Class, dep.Metadata.Name)\n\t}\n\treturn fmt.Sprintf(\"circular dependency: %s\", list)\n}\n\ntype errNotFound struct {\n\tclass string\n\tname  string\n}\n\nfunc (e errNotFound) Error() string {\n\treturn fmt.Sprintf(\"not found %s/%s\", e.class, e.name)\n}\n\nfunc (e errBadDependency) Error() string ", "output": "{\n\treturn fmt.Sprintf(\"unresolved dependency: class=%s name=%s\", types.Dependency(e).Class, types.Dependency(e).Name)\n}"}
{"input": "package loads\n\nimport \"jvmgo/ch09/instructions/base\"\nimport \"jvmgo/ch09/rtda\"\n\n\ntype ILOAD struct{ base.Index8Instruction }\n\nfunc (self *ILOAD) Execute(frame *rtda.Frame) {\n\t_iload(frame, self.Index)\n}\n\ntype ILOAD_0 struct{ base.NoOperandsInstruction }\n\nfunc (self *ILOAD_0) Execute(frame *rtda.Frame) {\n\t_iload(frame, 0)\n}\n\ntype ILOAD_1 struct{ base.NoOperandsInstruction }\n\n\n\ntype ILOAD_2 struct{ base.NoOperandsInstruction }\n\nfunc (self *ILOAD_2) Execute(frame *rtda.Frame) {\n\t_iload(frame, 2)\n}\n\ntype ILOAD_3 struct{ base.NoOperandsInstruction }\n\nfunc (self *ILOAD_3) Execute(frame *rtda.Frame) {\n\t_iload(frame, 3)\n}\n\nfunc _iload(frame *rtda.Frame, index uint) {\n\tval := frame.LocalVars().GetInt(index)\n\tframe.OperandStack().PushInt(val)\n}\n\nfunc (self *ILOAD_1) Execute(frame *rtda.Frame) ", "output": "{\n\t_iload(frame, 1)\n}"}
{"input": "package term\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc IsANSI(f *os.File) bool {\n\treturn IsTerminal(f)\n}\n\n\n\n\nfunc MakeRaw(f *os.File) error {\n\treturn stty(f, \"-icanon\", \"-echo\").Run()\n}\n\nfunc Restore(f *os.File) error {\n\treturn stty(f, \"icanon\", \"echo\").Run()\n}\n\nfunc Cols() (int, error) {\n\tcols, err := tput(\"cols\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn strconv.Atoi(cols)\n}\n\nfunc Lines() (int, error) {\n\tcols, err := tput(\"lines\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn strconv.Atoi(cols)\n}\n\n\n\nfunc stty(f *os.File, args ...string) *exec.Cmd {\n\tc := exec.Command(\"stty\", args...)\n\tc.Stdin = f\n\treturn c\n}\n\nfunc tput(what string) (string, error) {\n\tc := exec.Command(\"tput\", what)\n\tc.Stderr = os.Stderr\n\tout, err := c.Output()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn strings.TrimSpace(string(out)), nil\n}\n\nfunc IsTerminal(f *os.File) bool ", "output": "{\n\tcmd := exec.Command(\"test\", \"-t\", \"0\")\n\tcmd.Stdin = f\n\treturn cmd.Run() == nil\n}"}
{"input": "package hsapi\n\n\n\nfunc NewAllCards() AllCardsConfig {\n\treturn AllCardsConfig{}\n}\n\n\n\n\n\n\n\nfunc NewCardSearch(name string) CardSearchConfig {\n\treturn CardSearchConfig{\n\t\tName: name,\n\t}\n}\n\n\n\nfunc NewCardsBySet(set Set) CardsBySetConfig {\n\treturn CardsBySetConfig{\n\t\tSet: set,\n\t}\n}\n\n\n\nfunc NewCardsByClass(class Class) CardsByClassConfig {\n\treturn CardsByClassConfig{\n\t\tClass: class,\n\t}\n}\n\n\n\nfunc NewCardsByFaction(faction Faction) CardsByFactionConfig {\n\treturn CardsByFactionConfig{\n\t\tFaction: faction,\n\t}\n}\n\n\n\nfunc NewCardsByQuality(quality Quality) CardsByQualityConfig {\n\treturn CardsByQualityConfig{\n\t\tQuality: quality,\n\t}\n}\n\n\n\nfunc NewCardsByRace(race Race) CardsByRaceConfig {\n\treturn CardsByRaceConfig{\n\t\tRace: race,\n\t}\n}\n\n\n\nfunc NewCardsByType(typ Type) CardsByTypeConfig {\n\treturn CardsByTypeConfig{\n\t\tType: typ,\n\t}\n}\n\n\n\nfunc NewGetCard(id string) GetCardConfig {\n\treturn GetCardConfig{\n\t\tName: id,\n\t}\n}\n\n\n\nfunc NewInfo() InfoConfig {\n\treturn InfoConfig{}\n}\n\n\n\nfunc NewCardImage(cardID string) CardImageConfig {\n\treturn CardImageConfig{\n\t\tCardID: cardID,\n\t\tGold:   false,\n\t\tLocale: EnUS,\n\t}\n}\n\n\n\n\nfunc NewCardSound(cardID string, soundType SoundType) CardSoundConfig {\n\treturn CardSoundConfig{\n\t\tCardID:    cardID,\n\t\tType:      soundType,\n\t\tExtension: MP3,\n\t\tLocale:    EnUS,\n\t}\n}\n\nfunc NewCardBacks() CardBacksConfig ", "output": "{\n\treturn CardBacksConfig{}\n}"}
{"input": "package packet\n\nimport (\n\t\"github.com/coreos/rkt/Godeps/_workspace/src/golang.org/x/crypto/openpgp/errors\"\n\t\"io\"\n)\n\n\n\ntype Reader struct {\n\tq       []Packet\n\treaders []io.Reader\n}\n\n\n\nfunc (r *Reader) Next() (p Packet, err error) {\n\tif len(r.q) > 0 {\n\t\tp = r.q[len(r.q)-1]\n\t\tr.q = r.q[:len(r.q)-1]\n\t\treturn\n\t}\n\n\tfor len(r.readers) > 0 {\n\t\tp, err = Read(r.readers[len(r.readers)-1])\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\t\tif err == io.EOF {\n\t\t\tr.readers = r.readers[:len(r.readers)-1]\n\t\t\tcontinue\n\t\t}\n\t\tif _, ok := err.(errors.UnknownPacketTypeError); !ok {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn nil, io.EOF\n}\n\n\n\n\nfunc (r *Reader) Push(reader io.Reader) {\n\tr.readers = append(r.readers, reader)\n}\n\n\nfunc (r *Reader) Unread(p Packet) {\n\tr.q = append(r.q, p)\n}\n\n\n\nfunc NewReader(r io.Reader) *Reader ", "output": "{\n\treturn &Reader{\n\t\tq:       nil,\n\t\treaders: []io.Reader{r},\n\t}\n}"}
{"input": "package casbin\n\nconst (\n\tnotImplemented = \"not implemented\"\n)\n\n\nfunc (e *Enforcer) addPolicy(sec string, ptype string, rule []string) bool {\n\truleAdded := e.model.AddPolicy(sec, ptype, rule)\n\tif !ruleAdded {\n\t\treturn ruleAdded\n\t}\n\n\tif e.adapter != nil && e.autoSave {\n\t\tif err := e.adapter.AddPolicy(sec, ptype, rule); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\tif e.watcher != nil {\n\t\t\te.watcher.Update()\n\t\t}\n\t}\n\n\treturn ruleAdded\n}\n\n\nfunc (e *Enforcer) removePolicy(sec string, ptype string, rule []string) bool {\n\truleRemoved := e.model.RemovePolicy(sec, ptype, rule)\n\tif !ruleRemoved {\n\t\treturn ruleRemoved\n\t}\n\n\tif e.adapter != nil && e.autoSave {\n\t\tif err := e.adapter.RemovePolicy(sec, ptype, rule); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\tif e.watcher != nil {\n\t\t\te.watcher.Update()\n\t\t}\n\t}\n\n\treturn ruleRemoved\n}\n\n\n\n\nfunc (e *Enforcer) removeFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues ...string) bool ", "output": "{\n\truleRemoved := e.model.RemoveFilteredPolicy(sec, ptype, fieldIndex, fieldValues...)\n\tif !ruleRemoved {\n\t\treturn ruleRemoved\n\t}\n\n\tif e.adapter != nil && e.autoSave {\n\t\tif err := e.adapter.RemoveFilteredPolicy(sec, ptype, fieldIndex, fieldValues...); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\tif e.watcher != nil {\n\t\t\te.watcher.Update()\n\t\t}\n\t}\n\n\treturn ruleRemoved\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/mrlauer/gosockjs\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"path\"\n)\n\nfunc echo(c *gosockjs.Conn) {\n\tio.Copy(c, c)\n}\n\n\n\ntype NoRedirectServer struct {\n\t*http.ServeMux\n}\n\n\nfunc cleanPath(p string) string {\n\tif p == \"\" {\n\t\treturn \"/\"\n\t}\n\tif p[0] != '/' {\n\t\tp = \"/\" + p\n\t}\n\tnp := path.Clean(p)\n\tif p[len(p)-1] == '/' && np != \"/\" {\n\t\tnp += \"/\"\n\t}\n\treturn np\n}\n\nfunc (m *NoRedirectServer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tif req.URL.Path != cleanPath(req.URL.Path) {\n\t\thttp.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n\t\treturn\n\t}\n\thttp.DefaultServeMux.ServeHTTP(w, req)\n}\n\nfunc main() {\n\tgosockjs.Install(\"/echo\", echo)\n\tdwe, err := gosockjs.Install(\"/disabled_websocket_echo\", echo)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\tdwe.WebsocketEnabled = false\n\tcne, err := gosockjs.Install(\"/cookie_needed_echo\", echo)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\tcne.CookieNeeded = true\n\tgosockjs.Install(\"/close\", closeSock)\n\tfmt.Println(\"Listening on port 8081\")\n\thttp.ListenAndServe(\"127.0.0.1:8081\", new(NoRedirectServer))\n}\n\nfunc closeSock(c *gosockjs.Conn) ", "output": "{\n\tc.Close()\n}"}
{"input": "package factor\n\nimport (\n\t\"github.com/jesand/stats\"\n\t\"github.com/jesand/stats/dist\"\n\t\"github.com/jesand/stats/variable\"\n)\n\n\n\n\ntype Factor interface {\n\n\tAdjacent() []variable.RandomVariable\n\n\tScore() float64\n}\n\n\n\n\nfunc NewDistFactor(vars []variable.RandomVariable, distr dist.Dist) *DistFactor {\n\treturn &DistFactor{\n\t\tVars: vars,\n\t\tDist: distr,\n\t}\n}\n\n\ntype DistFactor struct {\n\tVars []variable.RandomVariable\n\tDist dist.Dist\n}\n\n\nfunc (factor DistFactor) Adjacent() []variable.RandomVariable {\n\treturn factor.Vars\n}\n\n\nfunc (factor DistFactor) Score() float64 {\n\tvar (\n\t\tnumVars   = factor.Dist.NumVars()\n\t\tnumParams = factor.Dist.NumParams()\n\t)\n\tif len(factor.Vars) != numVars+numParams {\n\t\tpanic(stats.ErrfFactorVarNum(numVars, numParams, len(factor.Vars)))\n\t}\n\tvar (\n\t\tvars   = make([]float64, numVars)\n\t\tparams = make([]float64, numParams)\n\t)\n\tfor i, rv := range factor.Vars {\n\t\tif i < len(vars) {\n\t\t\tvars[i] = rv.Val()\n\t\t} else {\n\t\t\tparams[i-len(vars)] = rv.Val()\n\t\t}\n\t}\n\treturn factor.Dist.Score(vars, params)\n}\n\n\nfunc NewConstFactor(vars []variable.RandomVariable, value float64) *ConstFactor {\n\treturn &ConstFactor{\n\t\tVars:  vars,\n\t\tValue: value,\n\t}\n}\n\n\ntype ConstFactor struct {\n\tVars  []variable.RandomVariable\n\tValue float64\n}\n\n\n\n\n\nfunc (factor ConstFactor) Score() float64 {\n\treturn factor.Value\n}\n\nfunc (factor ConstFactor) Adjacent() []variable.RandomVariable ", "output": "{\n\treturn factor.Vars\n}"}
{"input": "package gin\n\nimport (\n\t\"github.com/gin-gonic/gin/binding\"\n\t\"log\"\n)\n\n\n\n\n\nfunc (c *Context) BindWith(obj interface{}, b binding.Binding) error {\n\tlog.Println(`BindWith(\\\"interface{}, binding.Binding\\\") error is going to\n\tbe deprecated, please check issue #662 and either use MustBindWith() if you\n\twant HTTP 400 to be automatically returned if any error occur, of use\n\tShouldBindWith() if you need to manage the error.`)\n\treturn c.MustBindWith(obj, b)\n}\n\nfunc (c *Context) GetCookie(name string) (string, error) ", "output": "{\n\tlog.Println(\"GetCookie() method is deprecated. Use Cookie() instead.\")\n\treturn c.Cookie(name)\n}"}
{"input": "package rfc\n\n\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/zmap/zcrypto/x509\"\n\t\"github.com/zmap/zlint/v3/lint\"\n\t\"github.com/zmap/zlint/v3/util\"\n)\n\ntype extDuplicateExtension struct{}\n\n\n\nfunc init() {\n\tlint.RegisterLint(&lint.Lint{\n\t\tName:          \"e_ext_duplicate_extension\",\n\t\tDescription:   \"A certificate MUST NOT include more than one instance of a particular extension\",\n\t\tCitation:      \"RFC 5280: 4.2\",\n\t\tSource:        lint.RFC5280,\n\t\tEffectiveDate: util.RFC2459Date,\n\t\tLint:          &extDuplicateExtension{},\n\t})\n}\n\nfunc (l *extDuplicateExtension) Initialize() error {\n\treturn nil\n}\n\nfunc (l *extDuplicateExtension) CheckApplies(cert *x509.Certificate) bool {\n\treturn cert.Version == 3\n}\n\n\n\nfunc (l *extDuplicateExtension) Execute(cert *x509.Certificate) *lint.LintResult ", "output": "{\n\textensionOIDs := make(map[string]bool)\n\tduplicateOIDs := make(map[string]bool)\n\n\tfor _, ext := range cert.Extensions {\n\t\toid := ext.Id.String()\n\n\t\tif alreadySeen := extensionOIDs[oid]; alreadySeen {\n\t\t\tduplicateOIDs[oid] = true\n\t\t} else {\n\t\t\textensionOIDs[oid] = true\n\t\t}\n\t}\n\n\tif len(duplicateOIDs) == 0 {\n\t\treturn &lint.LintResult{Status: lint.Pass}\n\t}\n\n\tvar duplicateOIDsList []string\n\tfor oid := range duplicateOIDs {\n\t\tduplicateOIDsList = append(duplicateOIDsList, oid)\n\t}\n\n\treturn &lint.LintResult{\n\t\tStatus: lint.Error,\n\t\tDetails: fmt.Sprintf(\n\t\t\t\"The following extensions are duplicated: %s\",\n\t\t\tstrings.Join(duplicateOIDsList, \", \")),\n\t}\n}"}
{"input": "package core\n\nimport (\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/suite\"\n    \"testing\"\n    \"time\"\n)\n\ntype UserTestSuite struct {\n    suite.Suite\n}\n\nfunc (suite *UserTestSuite) TestCreation() {\n    a := assert.New(suite.T())\n\n    u, err := NewUser(\"test.user\", \"password\")\n    if a.NoError(err) {\n        a.Equal(u.Name, \"test.user\")\n        a.NotEmpty(u.CryptoSalt)\n        a.NotEmpty(u.SigningSalt)\n        a.NotEmpty(u.PublicKey)\n        a.NotNil(u.keys)\n\n        u.Drop()\n    }\n}\n\n\n\nfunc (suite *UserTestSuite) TestSaltAccess() {\n    a := assert.New(suite.T())\n\n    u, err := NewUser(\"test.user\", \"password\")\n    if a.NoError(err) {\n        c, err := u.GetCryptoSalt()\n        if a.NoError(err) {\n            a.NotEmpty(c)\n\n            s, err := u.GetSigningSalt()\n            if a.NoError(err) {\n                a.NotEmpty(s)\n                a.NotEqual(c, s)\n            }\n        }\n\n        u.Drop()\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc TestUserTestSuite(t *testing.T) {\n    suite.Run(t, new(UserTestSuite))\n}\n\nfunc (suite *UserTestSuite) TestLoading() ", "output": "{\n    a := assert.New(suite.T())\n\n    original, err := NewUser(\"test.user\", \"password\")\n    if a.NoError(err) {\n        loaded, err := LoadUser(\"test.user\")\n        if a.NoError(err) {\n            a.Equal(loaded.Id, original.Id)\n            a.WithinDuration(loaded.CreatedAt, original.CreatedAt, 0*time.Second)\n            a.WithinDuration(loaded.UpdatedAt, original.UpdatedAt, 0*time.Second)\n            a.Equal(loaded.Name, original.Name)\n            a.Equal(loaded.CryptoSalt, original.CryptoSalt)\n            a.Equal(loaded.SigningSalt, original.SigningSalt)\n            a.Equal(loaded.PublicKey, original.PublicKey)\n            a.Nil(loaded.keys)\n        }\n\n        original.Drop()\n        loaded, err = LoadUser(\"test.user\")\n        a.Error(err)\n    }\n}"}
{"input": "package node\n\nimport (\n\t\"errors\"\n\n\t\"github.com/docker/swarm/cluster\"\n)\n\n\ntype Node struct {\n\tID         string\n\tIP         string\n\tAddr       string\n\tName       string\n\tLabels     map[string]string\n\tContainers cluster.Containers\n\tImages     []*cluster.Image\n\n\tUsedMemory  int64\n\tUsedCpus    int64\n\tTotalMemory int64\n\tTotalCpus   int64\n\n\tHealthIndicator int64\n}\n\n\nfunc NewNode(e *cluster.Engine) *Node {\n\treturn &Node{\n\t\tID:              e.ID,\n\t\tIP:              e.IP,\n\t\tAddr:            e.Addr,\n\t\tName:            e.Name,\n\t\tLabels:          e.Labels,\n\t\tContainers:      e.Containers(),\n\t\tImages:          e.Images(),\n\t\tUsedMemory:      e.UsedMemory(),\n\t\tUsedCpus:        e.UsedCpus(),\n\t\tTotalMemory:     e.TotalMemory(),\n\t\tTotalCpus:       int64(e.TotalCpus()),\n\t\tHealthIndicator: e.HealthIndicator(),\n\t}\n}\n\n\nfunc (n *Node) IsHealthy() bool {\n\treturn n.HealthIndicator > 0\n}\n\n\n\n\n\nfunc (n *Node) AddContainer(container *cluster.Container) error {\n\tif container.Config != nil {\n\t\tmemory := container.Config.HostConfig.Memory\n\t\tcpus := container.Config.HostConfig.CPUShares\n\t\tif n.TotalMemory-memory < 0 || n.TotalCpus-cpus < 0 {\n\t\t\treturn errors.New(\"not enough resources\")\n\t\t}\n\t\tn.UsedMemory = n.UsedMemory + memory\n\t\tn.UsedCpus = n.UsedCpus + cpus\n\t}\n\tn.Containers = append(n.Containers, container)\n\treturn nil\n}\n\nfunc (n *Node) Container(IDOrName string) *cluster.Container ", "output": "{\n\treturn n.Containers.Get(IDOrName)\n}"}
{"input": "package middleware\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/yangou/goji/web\"\n)\n\ntype autoOptionsState int\n\nconst (\n\taosInit autoOptionsState = iota\n\taosHeaderWritten\n\taosProxying\n)\n\n\n\n\n\ntype autoOptionsProxy struct {\n\tw     http.ResponseWriter\n\tc     *web.C\n\tstate autoOptionsState\n}\n\nfunc (p *autoOptionsProxy) Header() http.Header {\n\treturn p.w.Header()\n}\n\nfunc (p *autoOptionsProxy) Write(buf []byte) (int, error) {\n\tswitch p.state {\n\tcase aosInit:\n\t\tp.state = aosHeaderWritten\n\tcase aosProxying:\n\t\treturn len(buf), nil\n\t}\n\treturn p.w.Write(buf)\n}\n\n\n\n\n\nfunc AutomaticOptions(c *web.C, h http.Handler) http.Handler {\n\tfn := func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"OPTIONS\" {\n\t\t\tw = &autoOptionsProxy{c: c, w: w}\n\t\t}\n\n\t\th.ServeHTTP(w, r)\n\t}\n\n\treturn http.HandlerFunc(fn)\n}\n\nfunc getValidMethods(c web.C) []string {\n\tif c.Env == nil {\n\t\treturn nil\n\t}\n\tv, ok := c.Env[web.ValidMethodsKey]\n\tif !ok {\n\t\treturn nil\n\t}\n\tif methods, ok := v.([]string); ok {\n\t\treturn methods\n\t}\n\treturn nil\n}\n\nfunc addMethod(methods []string, method string) []string {\n\tfor _, m := range methods {\n\t\tif m == method {\n\t\t\treturn methods\n\t\t}\n\t}\n\treturn append(methods, method)\n}\n\nfunc (p *autoOptionsProxy) WriteHeader(code int) ", "output": "{\n\tmethods := getValidMethods(*p.c)\n\tswitch p.state {\n\tcase aosInit:\n\t\tif methods != nil && code == http.StatusNotFound {\n\t\t\tp.state = aosProxying\n\t\t\tbreak\n\t\t}\n\t\tp.state = aosHeaderWritten\n\t\tfallthrough\n\tdefault:\n\t\tp.w.WriteHeader(code)\n\t\treturn\n\t}\n\n\tmethods = addMethod(methods, \"OPTIONS\")\n\tp.w.Header().Set(\"Allow\", strings.Join(methods, \", \"))\n\tp.w.WriteHeader(http.StatusOK)\n}"}
{"input": "package iso20022\n\n\ntype SettlementDateTimeIndication1 struct {\n\n\tDebitDateTime *ISODateTime `xml:\"DbtDtTm,omitempty\"`\n\n\tCreditDateTime *ISODateTime `xml:\"CdtDtTm,omitempty\"`\n}\n\n\n\nfunc (s *SettlementDateTimeIndication1) SetCreditDateTime(value string) {\n\ts.CreditDateTime = (*ISODateTime)(&value)\n}\n\nfunc (s *SettlementDateTimeIndication1) SetDebitDateTime(value string) ", "output": "{\n\ts.DebitDateTime = (*ISODateTime)(&value)\n}"}
{"input": "package leetcode\n\nconst MAX_INT32 = 1<<31 - 1\nconst MIN_INT32 = -1 << 31\n\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\n\n\nfunc minInt(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\n\nfunc absInt(num int) int {\n\tif num > 0 {\n\t\treturn num\n\t} else {\n\t\treturn -num\n\t}\n}\n\nfunc qsortInt(nums []int) []int {\n\tif len(nums) <= 1 {\n\t\treturn nums\n\t}\n\n\thead, tail := 0, len(nums)-1\n\tidx, mid := 1, nums[0]\n\tfor head < tail {\n\t\tif nums[idx] > mid {\n\t\t\tnums[idx], nums[tail] = nums[tail], nums[idx]\n\t\t\ttail--\n\t\t} else {\n\t\t\tnums[idx], nums[head] = nums[head], nums[idx]\n\t\t\thead++\n\t\t\tidx++\n\t\t}\n\t}\n\tnums[head] = mid\n\tqsortInt(nums[:head])\n\tqsortInt(nums[head+1:])\n\treturn nums\n}\n\ntype Stack struct {\n\tdata []rune\n}\n\nfunc (s *Stack) push(data rune) {\n\ts.data = append(s.data, data)\n}\n\nfunc (s *Stack) pop() rune {\n\tif len(s.data) == 0 {\n\t\treturn 0\n\t}\n\tret := s.data[len(s.data)-1]\n\ts.data = s.data[:len(s.data)-1]\n\treturn ret\n}\n\nfunc (s Stack) empty() bool {\n\treturn len(s.data) == 0\n}\n\nfunc maxInt(a, b int) int ", "output": "{\n\tif a < b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}"}
{"input": "package core\n\nimport (\n\t\"fmt\"\n)\n\n\n\n\n\n\nfunc PodContainerKey(namespace, podName, containerName string) string {\n\treturn fmt.Sprintf(\"namespace:%s/pod:%s/container:%s\", namespace, podName, containerName)\n}\n\nfunc PodKey(namespace, podName string) string {\n\treturn fmt.Sprintf(\"namespace:%s/pod:%s\", namespace, podName)\n}\n\nfunc NamespaceKey(namespace string) string {\n\treturn fmt.Sprintf(\"namespace:%s\", namespace)\n}\n\n\n\nfunc NodeContainerKey(node, container string) string {\n\treturn fmt.Sprintf(\"node:%s/container:%s\", node, container)\n}\n\nfunc ClusterKey() string {\n\treturn \"cluster\"\n}\n\nfunc NodeKey(node string) string ", "output": "{\n\treturn fmt.Sprintf(\"node:%s\", node)\n}"}
{"input": "package mockelb\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/service/elb\"\n\t\"k8s.io/klog\"\n)\n\n\n\nfunc (m *MockELB) DescribeLoadBalancerAttributes(request *elb.DescribeLoadBalancerAttributesInput) (*elb.DescribeLoadBalancerAttributesOutput, error) {\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\n\tklog.Infof(\"DescribeLoadBalancerAttributes: %v\", request)\n\n\tlb := m.LoadBalancers[aws.StringValue(request.LoadBalancerName)]\n\tif lb == nil {\n\t\treturn nil, fmt.Errorf(\"LoadBalancer not found\")\n\t}\n\n\tcopy := lb.attributes\n\n\treturn &elb.DescribeLoadBalancerAttributesOutput{\n\t\tLoadBalancerAttributes: &copy,\n\t}, nil\n}\n\nfunc (m *MockELB) ModifyLoadBalancerAttributes(request *elb.ModifyLoadBalancerAttributesInput) (*elb.ModifyLoadBalancerAttributesOutput, error) ", "output": "{\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\n\tklog.Infof(\"ModifyLoadBalancerAttributes: %v\", request)\n\n\tlb := m.LoadBalancers[aws.StringValue(request.LoadBalancerName)]\n\tif lb == nil {\n\t\treturn nil, fmt.Errorf(\"LoadBalancer not found\")\n\t}\n\n\tlb.attributes = *request.LoadBalancerAttributes\n\n\tcopy := lb.attributes\n\n\treturn &elb.ModifyLoadBalancerAttributesOutput{\n\t\tLoadBalancerName:       request.LoadBalancerName,\n\t\tLoadBalancerAttributes: &copy,\n\t}, nil\n}"}
{"input": "package main\n\nimport (\n\t\"os\"\n\n\t\"github.com/olekukonko/tablewriter\"\n)\n\ntype tblWriter struct {\n\t*tablewriter.Table\n}\n\nfunc NewTableWriter() *tblWriter {\n\treturn &tblWriter{tablewriter.NewWriter(os.Stdout)}\n}\n\n\n\nfunc (table *tblWriter) WriteData(header []string, data [][]string) error ", "output": "{\n\ttable.SetHeader(header)\n\ttable.AppendBulk(data)\n\ttable.Render()\n\treturn nil\n}"}
{"input": "package db\n\n\n\ntype Image struct {\n\tID int\n\n\tName string\n\n\tDockerfile string\n\n\tDockerID string\n}\n\n\n\n\n\nfunc (db Database) SelectFromImage(check func(Image) bool) []Image {\n\timageTable := db.accessTable(ImageTable)\n\tresult := []Image{}\n\tfor _, row := range imageTable.rows {\n\t\tif check == nil || check(row.(Image)) {\n\t\t\tresult = append(result, row.(Image))\n\t\t}\n\t}\n\treturn result\n}\n\nfunc (image Image) getID() int {\n\treturn image.ID\n}\n\nfunc (image Image) tt() TableType {\n\treturn ImageTable\n}\n\nfunc (image Image) String() string {\n\treturn defaultString(image)\n}\n\nfunc (image Image) less(r row) bool {\n\treturn image.ID < r.(Image).ID\n}\n\n\ntype ImageSlice []Image\n\n\nfunc (slc ImageSlice) Get(ii int) interface{} {\n\treturn slc[ii]\n}\n\n\nfunc (slc ImageSlice) Len() int {\n\treturn len(slc)\n}\n\nfunc (db Database) InsertImage() Image ", "output": "{\n\tresult := Image{ID: db.nextID()}\n\tdb.insert(result)\n\treturn result\n}"}
{"input": "package missing_return\n\nfunc main() {\n    plus(1, 2)\n}\n\n\n\nfunc plus(a, b int) int ", "output": "{\n    return 1\n    a + b\n}"}
{"input": "package api\n\ntype Memstore map[string]*Collection\n\n\n\nfunc (m Memstore) CreateCollection(slug, name string) (Collection, error) {\n\tm[slug] = &Collection{Name: name,\n\t\tSlug:  slug,\n\t\tItems: map[string]Item{},\n\t}\n\treturn *m[slug], nil\n}\n\nfunc (m Memstore) UpdateCollection(slug, name string) error {\n\tif c, ok := m[slug]; !ok {\n\t\treturn CollectionNotFoundError\n\t} else {\n\t\tc.Name = name\n\t}\n\treturn nil\n}\n\nfunc (m Memstore) GetCollectionData(slug string) (Collection, error) {\n\tif c, ok := m[slug]; ok {\n\t\t(*c).Items = nil\n\t\treturn *c, nil\n\t}\n\treturn Collection{}, CollectionNotFoundError\n}\n\nfunc (m Memstore) GetCollectionItems(slug string) (map[string]Item, error) {\n\tif c, ok := m[slug]; ok {\n\t\treturn c.Items, nil\n\t}\n\treturn map[string]Item{}, CollectionNotFoundError\n}\n\nfunc (m Memstore) AddItemToCollection(slug string, item Item) error {\n\tif c, ok := m[slug]; ok {\n\t\tc.Items[item.Tag] = item\n\t\treturn nil\n\t}\n\treturn CollectionNotFoundError\n}\n\nfunc (m Memstore) GetItemFromCollection(slug, tag string) (Item, error) {\n\tif _, ok := m[slug]; !ok {\n\t\treturn Item{}, CollectionNotFoundError\n\t}\n\tif _, ok := m[slug].Items[tag]; !ok {\n\t\treturn Item{}, BlobNotFoundError\n\t}\n\treturn m[slug].Items[tag], nil\n}\n\nfunc (m Memstore) Init(dbName string) error ", "output": "{\n\treturn nil\n}"}
{"input": "package encfile\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n)\n\nfunc gcm(k []byte) cipher.AEAD {\n\taesBC, err := aes.NewCipher(k[0:32])\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\tret, err := cipher.NewGCM(aesBC)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn ret\n}\n\n\n\n\n\nfunc decryptSector(key, nonce, data []byte) ([]byte, error) {\n\talgo := gcm(key)\n\treturn algo.Open(nil, nonce[:algo.NonceSize()], data, nil)\n}\n\nfunc encryptSector(key, nonce, data []byte) []byte ", "output": "{\n\talgo := gcm(key)\n\treturn algo.Seal(nil, nonce[:algo.NonceSize()], data, nil)\n}"}
{"input": "package cmake\n\nimport (\n\t\"github.com/pinpt/dialect/pkg/types\"\n\t\"strings\"\n)\n\ntype CMakeExaminer struct {\n\tinDoubleComment bool\n}\n\nfunc (e *CMakeExaminer) Examine(language string, filename string, line *types.DialectLine) error {\n\tlineBuf := strings.TrimSpace(line.Contents)\n\tif strings.HasPrefix(lineBuf, \"# \") {\n\t\tline.IsComment = true\n\t} else {\n\t\tline.IsCode = true\n\t}\n\n\treturn nil\n}\n\nfunc (e *CMakeExaminer) NewExaminer() types.DialectExaminer {\n\tex := new(CMakeExaminer)\n\treturn ex\n}\n\n\n\nfunc init() ", "output": "{\n\ttypes.RegisterExaminer(\"CMake\", &CMakeExaminer{})\n}"}
{"input": "package behaviors\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/aymerick/raymond\"\n)\n\nfunc parsePayload(p Params, path string) (io.Reader, error) {\n\tvar (\n\t\treplacements = map[string]string{}\n\t\tbuf          = bytes.NewBuffer([]byte{})\n\t)\n\treplacements = replaceStrings(p.Replacements, replacements)\n\treplacements, err := replaceFiles(p.ReplacementFiles, replacements, path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttmpl, err := raymond.ParseFile(filepath.Join(path, p.AppJSON))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tapp, err := tmpl.Exec(replacements)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif _, err = buf.WriteString(app); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf, nil\n}\n\n\n\nfunc replaceFiles(\n\tmetadata []Metadata,\n\treplacements map[string]string,\n\tpath string,\n) (map[string]string, error) {\n\tfor _, v := range metadata {\n\t\tfileValue, err := ioutil.ReadFile(filepath.Join(path, v.Value))\n\t\tif err != nil {\n\t\t\treturn replacements, fmt.Errorf(\n\t\t\t\t\"Error replacing %s from replacement_files: %v\",\n\t\t\t\tv.Name,\n\t\t\t\terr,\n\t\t\t)\n\t\t}\n\t\treplacements[v.Name] = strings.TrimSpace(string(fileValue))\n\t}\n\n\treturn replacements, nil\n}\n\nfunc replaceStrings(\n\tmetadata []Metadata,\n\treplacements map[string]string,\n) map[string]string ", "output": "{\n\tfor _, v := range metadata {\n\t\treplacements[v.Name] = v.Value\n\t}\n\n\treturn replacements\n}"}
{"input": "package api\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/nordsieck/defect\"\n)\n\nconst (\n\tPlaylistItems = \"https://www.googleapis.com/youtube/v3/playlistItems\"\n\n\tKey            = \"key\"\n\tPart           = \"part\"\n\tContentDetails = \"contentDetails\"\n\tPlaylistID     = \"playlistId\"\n\tMaxResults     = \"maxResults\"\n\tPageToken      = \"pageToken\"\n\n\tErrDeserializeInput = defect.Error(\"Unable to deserialize input\")\n\n\tMaxPlaylistItems = \"50\" \n)\n\nfunc GetPlaylistFragment(key, playlist, token string) (videoIDs []string, pageToken string, e error) {\n\tparams := url.Values{\n\t\tKey:        {key},\n\t\tPart:       {ContentDetails},\n\t\tPlaylistID: {playlist},\n\t\tMaxResults: {MaxPlaylistItems},\n\t}\n\tif token != \"\" {\n\t\tparams[PageToken] = []string{token}\n\t}\n\tresp, err := http.Get(PlaylistItems + \"?\" + params.Encode())\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tpl, err := DeserializePlaylist(resp.Body)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\treturn pl.VideoIDs(), pl.NextPageToken, nil\n}\n\n\n\nfunc PlaylistVideos(key, playlist string) ([]string, error) ", "output": "{\n\tfullList := []string{}\n\n\ttoken := \"\"\n\tfor {\n\t\tvar list []string\n\t\tvar err error\n\t\tlist, token, err = GetPlaylistFragment(key, playlist, token)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfullList = append(fullList, list...)\n\t\tif token == \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn fullList, nil\n}"}
{"input": "package manager\n\nimport (\n\t\"testing\"\n)\n\n\n\n\nvar keywordTestStrings = []struct {\n\tTestString string\n\tKeyword    string\n}{\n\t{`curl -fsSL \"$GOLANG_DOWNLOAD_URL\" -o golang.tar.gz &&`, \"Go\"},\n\t{`echo \"$GOLANG_DOWNLOAD_SHA1 golang.tar.gz\" | sha1sum -c - &&`, \"Go\"},\n\t{`./file.zimpl --no-clean 2>&1`, \"Zimpl\"},\n}\n\nfunc TestKeywordMapping(t *testing.T) ", "output": "{\n\tfor _, test := range keywordTestStrings {\n\t\tkeywords := Keywords(test.TestString)\n\t\tif keywords == nil {\n\t\t\tt.Errorf(\"Keywords method returned no results, when expected %s\", test.Keyword)\n\t\t}\n\t\tfor _, key := range keywords {\n\t\t\tif key != test.Keyword {\n\t\t\t\tt.Errorf(\"Incorrect expected keyword: %s\", key)\n\t\t\t}\n\t\t}\n\t}\n\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSCloudFrontDistribution_ViewerCertificate struct {\n\n\tAcmCertificateArn string `json:\"AcmCertificateArn,omitempty\"`\n\n\tCloudFrontDefaultCertificate bool `json:\"CloudFrontDefaultCertificate,omitempty\"`\n\n\tIamCertificateId string `json:\"IamCertificateId,omitempty\"`\n\n\tMinimumProtocolVersion string `json:\"MinimumProtocolVersion,omitempty\"`\n\n\tSslSupportMethod string `json:\"SslSupportMethod,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) AWSCloudFormationType() string {\n\treturn \"AWS::CloudFront::Distribution.ViewerCertificate\"\n}\n\n\n\n\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) DependsOn() []string ", "output": "{\n\treturn r._dependsOn\n}"}
{"input": "package ergo_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/gima/ergo/v1\"\n\t\"github.com/gima/ergo/v1/pp\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n\n\n\n\n\n\nfunc TestComposer_AddLinked(t *testing.T) {\n\tolde := fmt.Errorf(\"\")\n\toldE := ergo.New(\"\").Err()\n\tE := ergo.New(\"\").AddLinked(olde, oldE).Err()\n\trequire.Equal(t, 2, E.Linked().Len())\n\trequire.Equal(t, olde, E.Linked().Get(0))\n\trequire.Equal(t, oldE, E.Linked().Get(1))\n}\n\n\n\nfunc TestComposer_SetCause(t *testing.T) {\n\toldE := ergo.New(\"\").Err()\n\tE := ergo.New(\"\").SetCause(oldE).Err()\n\trequire.Equal(t, oldE, E.Cause())\n\n\tolde := fmt.Errorf(\"\")\n\tE = ergo.New(\"\").SetCause(olde).Err()\n\trequire.Equal(t, olde, E.Cause())\n}\n\n\n\nfunc TestComposer_SetPub(t *testing.T) {\n\tE := ergo.New(\"\").SetPub(\"Public Message\").Err()\n\trequire.Equal(t, \"Public Message\", E.PublicError())\n}\n\n\n\nfunc TestComposer_SkipStackRetainsOne(t *testing.T) {\n\tE := ergo.New(\"\").\n\t\tSkipStack(-1).\n\t\tSkipStack(1000).\n\t\tSkipStack(1).\n\t\tSkipStack(0).\n\t\tSkipStack(-1).\n\t\tErr()\n\n\trequire.Equal(t, 1, E.StackTrace().Len())\n}\n\nfunc TestComposer_AddContext(t *testing.T) ", "output": "{\n\tE := ergo.New(\"\").Err()\n\trequire.Equal(t, 0, E.Context().Len())\n\n\tE = ergo.New(\"\").AddContext(\"K1\", \"V1\").Err()\n\trequire.Equal(t, 1, E.Context().Len())\n\tk, v := E.Context().Get(0)\n\trequire.Equal(t, \"K1V1\", k+v)\n\n\tE = ergo.New(\"\").AddContextFrom(pp.Map{\"K1\": \"V1\"}).Err()\n\trequire.Equal(t, 1, E.Context().Len())\n\tk, v = E.Context().Get(0)\n\trequire.Equal(t, \"K1V1\", k+v)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\n\n\nfunc main() {\n\thttp.HandleFunc(\"/\", Handler)\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc Handler(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tfmt.Fprintln(w, r.URL.Path)\n}"}
{"input": "package storage\n\nimport \"testing\"\n\n\n\nfunc TestUnifyName(t *testing.T) ", "output": "{\n\texpected := \"github.com/tenmozes/solomon\"\n\tif actual := UnifyName(\"https://github.com/tenmozes/solomon.git\"); actual != expected {\n\t\tt.Errorf(\"Exptected %s got %s\", expected, actual)\n\t}\n\tif actual := UnifyName(\"git@github.com:tenmozes/solomon.git\"); actual != expected {\n\t\tt.Errorf(\"Exptected %s got %s\", expected, actual)\n\t}\n}"}
{"input": "package openpgp\n\nimport (\n\t\"hash\"\n\t\"os\"\n)\n\n\n\nfunc NewCanonicalTextHash(h hash.Hash) hash.Hash {\n\treturn &canonicalTextHash{h, 0}\n}\n\ntype canonicalTextHash struct {\n\th hash.Hash\n\ts int\n}\n\nvar newline = []byte{'\\r', '\\n'}\n\nfunc (cth *canonicalTextHash) Write(buf []byte) (int, os.Error) {\n\tstart := 0\n\n\tfor i, c := range buf {\n\t\tswitch cth.s {\n\t\tcase 0:\n\t\t\tif c == '\\r' {\n\t\t\t\tcth.s = 1\n\t\t\t} else if c == '\\n' {\n\t\t\t\tcth.h.Write(buf[start:i])\n\t\t\t\tcth.h.Write(newline)\n\t\t\t\tstart = i + 1\n\t\t\t}\n\t\tcase 1:\n\t\t\tcth.s = 0\n\t\t}\n\t}\n\n\tcth.h.Write(buf[start:])\n\treturn len(buf), nil\n}\n\n\n\nfunc (cth *canonicalTextHash) Reset() {\n\tcth.h.Reset()\n\tcth.s = 0\n}\n\nfunc (cth *canonicalTextHash) Size() int {\n\treturn cth.h.Size()\n}\n\nfunc (cth *canonicalTextHash) Sum() []byte ", "output": "{\n\treturn cth.h.Sum()\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSSESReceiptRule_StopAction struct {\n\n\tScope string `json:\"Scope,omitempty\"`\n\n\tTopicArn string `json:\"TopicArn,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\n\n\n\n\nfunc (r *AWSSESReceiptRule_StopAction) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSSESReceiptRule_StopAction) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSSESReceiptRule_StopAction) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSSESReceiptRule_StopAction) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSSESReceiptRule_StopAction) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSSESReceiptRule_StopAction) AWSCloudFormationType() string ", "output": "{\n\treturn \"AWS::SES::ReceiptRule.StopAction\"\n}"}
{"input": "package internal\n\n\n\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar limitSem = make(chan int, 100) \n\n\n\nfunc limitDial(network, addr string) (net.Conn, error) {\n\tlimitSem <- 1\n\n\tconn, err := net.DialTimeout(network, addr, 500*time.Millisecond)\n\tif err != nil {\n\t\tlimitRelease()\n\t\treturn nil, err\n\t}\n\tlc := &limitConn{Conn: conn}\n\truntime.SetFinalizer(lc, (*limitConn).Close) \n\treturn lc, nil\n}\n\ntype limitConn struct {\n\tclose sync.Once\n\tnet.Conn\n}\n\nfunc (lc *limitConn) Close() error {\n\tdefer lc.close.Do(func() {\n\t\tlimitRelease()\n\t\truntime.SetFinalizer(lc, nil)\n\t})\n\treturn lc.Conn.Close()\n}\n\nfunc limitRelease() ", "output": "{\n\tselect {\n\tcase <-limitSem:\n\tdefault:\n\t\tlog.Print(\"appengine: unbalanced limitSem release!\")\n\t}\n}"}
{"input": "package apl\n\nimport (\n\t\"fmt\"\n\t\"github.com/dghubble/sling\"\n\t\"net/http\"\n)\n\n\ntype ComponentService struct {\n\tsling    *sling.Sling\n\tendpoint string\n}\n\n\nfunc NewComponentsService(sling *sling.Sling) *ComponentService {\n\treturn &ComponentService{\n\t\tsling:    sling,\n\t\tendpoint: \"components\",\n\t}\n}\n\n\ntype Component struct {\n\tID           string            `json:\"id\"`\n\tName         string            `json:\"name\"`\n\tCategory     string            `json:\"category\"`\n\tLastModified string            `json:\"last_modified\"`\n\tCreatedTime  string            `json:\"created_time\"`\n\tVersions     []string          `json:\"versions,omitempty\"`\n\tMetaData     map[string]string `json:\"meta_data,omitempty\"`\n}\n\n\ntype ComponentParams struct {\n\tCategory string `url:\"category,omitempty\"`\n\tName     string `url:\"name,omitempty\"`\n}\n\n\n\n\n\nfunc (c *ComponentService) Get(id string) (Component, *http.Response, error) {\n\n\toutput := &struct {\n\t\tData Component `json:\"data\"`\n\t}{}\n\tpath := fmt.Sprintf(\"%s/%s\", c.endpoint, id)\n\tresp, err := doGet(c.sling, path, output)\n\treturn output.Data, resp, err\n\n}\n\nfunc (c *ComponentService) List(params *ComponentParams) ([]Component, *http.Response, error) ", "output": "{\n\toutput := &struct {\n\t\tData []Component `json:\"data\"`\n\t}{}\n\tresp, err := doList(c.sling, c.endpoint, params, output)\n\treturn output.Data, resp, err\n}"}
{"input": "package main\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/sha1\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"fmt\"\n)\n\nfunc hashSha1(data []byte) string {\n\tsum := sha1.Sum(data)\n\treturn base64.StdEncoding.EncodeToString(sum[:])\n}\n\nfunc hashSha256(data []byte) string {\n\tsum := sha256.Sum256(data)\n\treturn base64.StdEncoding.EncodeToString(sum[:])\n}\n\nfunc hashSha512(data []byte) string {\n\tsum := sha512.Sum512(data)\n\treturn base64.StdEncoding.EncodeToString(sum[:])\n}\n\n\n\nfunc main() {\n\tdata := []byte(\"Hello World!\")\n\tfmt.Println(\"hashSha1:\", hashSha1(data))\n\tfmt.Println(\"hashSha256:\", hashSha256(data))\n\tfmt.Println(\"hashSha512:\", hashSha512(data))\n\tfmt.Println(\"hashMd5:\", hashMd5(data))\n}\n\nfunc hashMd5(data []byte) string ", "output": "{\n\tsum := md5.Sum(data)\n\treturn base64.StdEncoding.EncodeToString(sum[:])\n}"}
{"input": "package lowercase\n\nimport (\n\t\"bytes\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"github.com/blevesearch/bleve/analysis\"\n\t\"github.com/blevesearch/bleve/registry\"\n)\n\n\nconst Name = \"to_lower\"\n\ntype LowerCaseFilter struct {\n}\n\nfunc NewLowerCaseFilter() *LowerCaseFilter {\n\treturn &LowerCaseFilter{}\n}\n\n\n\nfunc LowerCaseFilterConstructor(config map[string]interface{}, cache *registry.Cache) (analysis.TokenFilter, error) {\n\treturn NewLowerCaseFilter(), nil\n}\n\nfunc init() {\n\tregistry.RegisterTokenFilter(Name, LowerCaseFilterConstructor)\n}\n\n\n\n\n\n\n\nfunc toLowerDeferredCopy(s []byte) []byte {\n\tj := 0\n\tfor i := 0; i < len(s); {\n\t\twid := 1\n\t\tr := rune(s[i])\n\t\tif r >= utf8.RuneSelf {\n\t\t\tr, wid = utf8.DecodeRune(s[i:])\n\t\t}\n\n\t\tl := unicode.ToLower(r)\n\n\t\tif l == r {\n\t\t\ti += wid\n\t\t\tj += wid\n\t\t\tcontinue\n\t\t}\n\n\t\tif l == 'σ' && i+2 == len(s) {\n\t\t\tl = 'ς'\n\t\t}\n\n\t\tlwid := utf8.RuneLen(l)\n\t\tif lwid > wid {\n\t\t\trest := bytes.ToLower(s[i:])\n\t\t\trv := make([]byte, j+len(rest))\n\t\t\tcopy(rv[:j], s[:j])\n\t\t\tcopy(rv[j:], rest)\n\t\t\treturn rv\n\t\t} else {\n\t\t\tutf8.EncodeRune(s[j:], l)\n\t\t}\n\t\ti += wid\n\t\tj += lwid\n\t}\n\treturn s[:j]\n}\n\nfunc (f *LowerCaseFilter) Filter(input analysis.TokenStream) analysis.TokenStream ", "output": "{\n\tfor _, token := range input {\n\t\ttoken.Term = toLowerDeferredCopy(token.Term)\n\t}\n\treturn input\n}"}
{"input": "package awspublicip\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"github.com/dan-v/awslambdaproxy/pkg/server/publicip\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n)\n\nconst (\n\tDefaultHTTPTimeout = time.Second * 10\n\tAWSProviderURL     = \"http://checkip.amazonaws.com/\"\n)\n\ntype PublicIPClient struct {\n\tproviderURL string\n\thttpClient  *http.Client\n}\n\nfunc New() *PublicIPClient {\n\treturn &PublicIPClient{\n\t\tproviderURL: AWSProviderURL,\n\t\thttpClient: &http.Client{\n\t\t\tTimeout: DefaultHTTPTimeout,\n\t\t},\n\t}\n}\n\nfunc (p *PublicIPClient) GetIP() (string, error) {\n\tresp, err := p.httpClient.Get(p.providerURL)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"http request to get ip address from %v failed: %w\", p.providerURL, err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbuf, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"reading response body from %v failed: %w\", p.providerURL, err)\n\t}\n\n\tip := string(bytes.TrimSpace(buf))\n\tif net.ParseIP(ip) == nil {\n\t\treturn \"\", fmt.Errorf(\"unable to parse ip %v: %w\",\n\t\t\tpublicip.ErrInvalidIPAddress, publicip.ErrInvalidIPAddress)\n\t}\n\treturn ip, nil\n}\n\n\n\nfunc (p *PublicIPClient) ProviderURL() string ", "output": "{\n\treturn p.providerURL\n}"}
{"input": "package string\n\nimport (\n\tdss \"github.com/emirpasic/gods/stacks/arraystack\"\n)\n\n\nfunc Reverse(s string) string {\n\tr := []rune(s) \n\tfor i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n\t\tr[i], r[j] = r[j], r[i]\n\t}\n\treturn string(r)\n}\n\n\n\n\n\n\n\n\n\n\nfunc ReverseNest1(s string) string {\n\tr := []rune(s)\n\tswitchHeadTail(r)\n\treturn string(r)\n}\n\nfunc switchHeadTail(r []rune) {\n\tif len(r) <= 1 {\n\t\treturn\n\t}\n\tbottom, top := 0, len(r)-1\n\tr[bottom], r[top] = r[top], r[bottom]\n\tswitchHeadTail(r[bottom+1 : top])\n}\n\n\nfunc ReverseInStack(s string) string {\n\tr := []rune(s)\n\tstack := dss.New()\n\tfor i := 0; i < len(r); i++ {\n\t\tstack.Push(r[i])\n\t}\n\trs := make([]rune, len(r))\n\tfor i := 0; i < len(r); i++ {\n\t\tv, _ := stack.Pop()\n\t\tif v != nil {\n\t\t\trs[i] = v.(rune)\n\t\t}\n\t}\n\treturn string(rs)\n}\n\nfunc ReverseNest(s string) string ", "output": "{\n\tr := []rune(s)\n\tif len(r) == 1 || len(r) == 0 {\n\t\treturn s\n\t}\n\tsub := ReverseNest(string(r[1:]))\n\treturn sub + string(r[0:1])\n}"}
{"input": "package api\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/coreos/fleet/log\"\n)\n\nvar unavailable = &unavailableHdlr{}\n\n\n\ntype Server struct {\n\tlisteners []net.Listener\n\tapi       http.Handler\n\tcur       http.Handler\n}\n\nfunc (s *Server) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\ts.cur.ServeHTTP(rw, req)\n}\n\nfunc (s *Server) Serve() {\n\tfor i, _ := range s.listeners {\n\t\tl := s.listeners[i]\n\t\tgo func() {\n\t\t\terr := http.Serve(l, s)\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Failed serving HTTP on listener: %s\", l.Addr)\n\t\t\t}\n\t\t}()\n\t}\n}\n\n\n\n\nfunc (s *Server) Available(stop chan bool) {\n\ts.cur = s.api\n\t<-stop\n\ts.cur = unavailable\n}\n\ntype unavailableHdlr struct{}\n\nfunc (uh *unavailableHdlr) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tsendError(rw, http.StatusServiceUnavailable, errors.New(\"fleet server currently unavailable\"))\n}\n\nfunc NewServer(listeners []net.Listener, hdlr http.Handler) *Server ", "output": "{\n\treturn &Server{\n\t\tlisteners: listeners,\n\t\tapi:       hdlr,\n\t\tcur:       unavailable,\n\t}\n}"}
{"input": "package weighted\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/AsynkronIT/protoactor-go/cluster\"\n)\n\ntype WeightedMemberStatusValue struct {\n\tWeight int\n}\n\n\n\ntype WeightedMemberStatusValueSerializer struct{}\n\nfunc (s *WeightedMemberStatusValueSerializer) ToValueBytes(val cluster.MemberStatusValue) []byte {\n\tdVal, _ := val.(*WeightedMemberStatusValue)\n\treturn []byte(strconv.Itoa(dVal.Weight))\n}\n\nfunc (s *WeightedMemberStatusValueSerializer) FromValueBytes(val []byte) cluster.MemberStatusValue {\n\tweight, _ := strconv.Atoi(string(val))\n\treturn &WeightedMemberStatusValue{Weight: weight}\n}\n\nfunc (sv *WeightedMemberStatusValue) IsSame(val cluster.MemberStatusValue) bool ", "output": "{\n\tif val == nil {\n\t\treturn false\n\t}\n\tif v, ok := val.(*WeightedMemberStatusValue); ok {\n\t\treturn sv.Weight == v.Weight\n\t}\n\treturn false\n}"}
{"input": "package libkb\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\n\tkeybase1 \"github.com/keybase/client/go/protocol/keybase1\"\n\t\"golang.org/x/net/context\"\n)\n\ntype Syncer interface {\n\tContextifier\n\tsync.Locker\n\tloadFromStorage(m MetaContext, u keybase1.UID, useExpiration bool) error\n\tsyncFromServer(m MetaContext, u keybase1.UID, forceReload bool) error\n\tstore(m MetaContext, u keybase1.UID) error\n\tneedsLogin(m MetaContext) bool\n}\n\n\n\nfunc RunSyncerCached(m MetaContext, s Syncer, uid keybase1.UID) (err error) {\n\tif uid.IsNil() {\n\t\treturn NotFoundError{\"No UID given to syncer\"}\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tdefer m.Trace(fmt.Sprintf(\"RunSyncerCached(%s)\", uid), &err)()\n\n\treturn s.loadFromStorage(m, uid, false)\n}\n\nfunc RunSyncer(m MetaContext, s Syncer, uid keybase1.UID, loggedIn bool, forceReload bool) (err error) ", "output": "{\n\tif uid.IsNil() {\n\t\treturn NotFoundError{\"No UID given to syncer\"}\n\t}\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tdefer m.Trace(fmt.Sprintf(\"RunSyncer(%s)\", uid), &err)()\n\n\tif err = s.loadFromStorage(m, uid, true); err != nil {\n\t\treturn\n\t}\n\n\tif m.G().ConnectivityMonitor.IsConnected(context.Background()) == ConnectivityMonitorNo {\n\t\tm.Debug(\"| not connected, won't sync with server\")\n\t\treturn\n\t}\n\n\tif s.needsLogin(m) && !loggedIn {\n\t\tm.Debug(\"| Won't sync with server since we're not logged in\")\n\t\treturn\n\t}\n\tif err = s.syncFromServer(m, uid, forceReload); err != nil {\n\t\treturn\n\t}\n\tif err = s.store(m, uid); err != nil {\n\t\treturn\n\t}\n\n\treturn\n}"}
{"input": "package blobstore\n\nimport (\n\t\"io\"\n\n\t\"code.google.com/p/go.net/context\"\n)\n\ntype Blobstore interface {\n\tDel(path string) error\n\n\tGet(path string) ([]byte, error)\n\n\tGetReader(path string) (io.ReadCloser, error)\n\n\tPut(path string, data []byte) error\n\n\tPutReader(path string, r io.Reader) error\n}\n\n\nfunc Del(c context.Context, path string) error {\n\treturn FromContext(c).Del(path)\n}\n\n\nfunc Get(c context.Context, path string) ([]byte, error) {\n\treturn FromContext(c).Get(path)\n}\n\n\n\n\n\n\n\nfunc Put(c context.Context, path string, data []byte) error {\n\treturn FromContext(c).Put(path, data)\n}\n\n\n\nfunc PutReader(c context.Context, path string, r io.Reader) error {\n\treturn FromContext(c).PutReader(path, r)\n}\n\nfunc GetReader(c context.Context, path string) (io.ReadCloser, error) ", "output": "{\n\treturn FromContext(c).GetReader(path)\n}"}
{"input": "package testclient\n\nimport (\n\tkapi \"k8s.io/kubernetes/pkg/api\"\n\tktestclient \"k8s.io/kubernetes/pkg/client/unversioned/testclient\"\n\n\t\"github.com/openshift/origin/pkg/client\"\n\timageapi \"github.com/openshift/origin/pkg/image/api\"\n)\n\n\n\n\ntype FakeImages struct {\n\tFake *Fake\n}\n\nvar _ client.ImageInterface = &FakeImages{}\n\n\n\nfunc (c *FakeImages) List(opts kapi.ListOptions) (*imageapi.ImageList, error) {\n\tobj, err := c.Fake.Invokes(ktestclient.NewRootListAction(\"images\", opts), &imageapi.ImageList{})\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*imageapi.ImageList), err\n}\n\nfunc (c *FakeImages) Create(inObj *imageapi.Image) (*imageapi.Image, error) {\n\tobj, err := c.Fake.Invokes(ktestclient.NewRootCreateAction(\"images\", inObj), inObj)\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*imageapi.Image), err\n}\n\nfunc (c *FakeImages) Delete(name string) error {\n\t_, err := c.Fake.Invokes(ktestclient.NewRootDeleteAction(\"images\", name), &imageapi.Image{})\n\treturn err\n}\n\nfunc (c *FakeImages) Get(name string) (*imageapi.Image, error) ", "output": "{\n\tobj, err := c.Fake.Invokes(ktestclient.NewRootGetAction(\"images\", name), &imageapi.Image{})\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*imageapi.Image), err\n}"}
{"input": "package utils\n\nimport (\n\t\"go/types\"\n\n\t\"golang.org/x/tools/go/ssa\"\n)\n\n\n\nfunc Dereference(t types.Type) types.Type {\n\tfor {\n\t\ttt, ok := t.Underlying().(*types.Pointer)\n\t\tif !ok {\n\t\t\treturn t\n\t\t}\n\t\tt = tt.Elem()\n\t}\n}\n\n\n\nfunc DecomposeType(t types.Type) (path, name string) {\n\tn, ok := t.(*types.Named)\n\tif !ok {\n\t\treturn\n\t}\n\n\tif pkg := n.Obj().Pkg(); pkg != nil {\n\t\tpath = pkg.Path()\n\t}\n\n\treturn path, n.Obj().Name()\n}\n\n\n\n\n\nfunc DecomposeField(t types.Type, field int) (typePath, typeName, fieldName string) {\n\tderef := Dereference(t)\n\ttypePath, typeName = DecomposeType(deref)\n\tfieldName = deref.Underlying().(*types.Struct).Field(field).Name()\n\treturn\n}\n\n\n\n\n\nfunc UnqualifiedName(t *types.Var) string {\n\treturn types.TypeString(t.Type(), func(*types.Package) string { return \"\" })\n}\n\n\n\n\n\n\n\nfunc DecomposeFunction(f *ssa.Function) (path, recv, name string) ", "output": "{\n\tif f.Pkg != nil {\n\t\tpath = f.Pkg.Pkg.Path()\n\t}\n\tname = f.Name()\n\tif recvVar := f.Signature.Recv(); recvVar != nil {\n\t\trecv = UnqualifiedName(recvVar)\n\t}\n\treturn\n}"}
{"input": "package model\n\nimport (\n\t\"fmt\"\n)\n\ntype Template struct {\n\tId       int    `json:\"id\"`\n\tName     string `json:\"name\"`\n\tParentId int    `json:\"parentId\"`\n\tActionId int    `json:\"actionId\"`\n\tCreator  string `json:\"creator\"`\n}\n\n\n\ntype NewTemplate struct {\n\tID       int    `json:\"id\"`\n\tName     string `json:\"name\"`\n\tParentID int    `json:\"parent_id\"`\n\tActionID int    `json:\"action_id\"`\n\tCreator  string `json:\"creator\"`\n}\n\nfunc (this *NewTemplate) String() string {\n\treturn fmt.Sprintf(\n\t\t\"<ID:%d, Name:%s, ParentID:%d, ActionID:%d, Creator:%s>\",\n\t\tthis.ID,\n\t\tthis.Name,\n\t\tthis.ParentID,\n\t\tthis.ActionID,\n\t\tthis.Creator,\n\t)\n}\n\nfunc (this *Template) String() string ", "output": "{\n\treturn fmt.Sprintf(\n\t\t\"<Id:%d, Name:%s, ParentId:%d, ActionId:%d, Creator:%s>\",\n\t\tthis.Id,\n\t\tthis.Name,\n\t\tthis.ParentId,\n\t\tthis.ActionId,\n\t\tthis.Creator,\n\t)\n}"}
{"input": "package pgp\n\nimport (\n\t\"math/big\"\n\t\"reflect\"\n\t\"unsafe\"\n\n\t\"github.com/awnumar/memguard\"\n\t\"github.com/pkg/errors\"\n)\n\ntype writeTo struct {\n\tbuffer   *memguard.LockedBuffer\n\tposition int\n}\n\nfunc (w *writeTo) Write(p []byte) (n int, err error) {\n\tif len(p)+w.position > w.buffer.Size() {\n\t\treturn 0, errors.New(\"Overflow\")\n\t}\n\tif err := w.buffer.MoveAt(p, w.position); err != nil {\n\t\treturn 0, errors.Wrap(err, \"Memcopy\")\n\t}\n\tw.position += len(p)\n\treturn len(p), nil\n}\n\nfunc (w *writeTo) Result() []byte {\n\tw.buffer.MakeImmutable()\n\treturn w.buffer.Buffer()[0:w.position]\n}\n\nvar sizeOfUInt int\n\nfunc bytesToWords(raw []byte) []big.Word {\n\theader := *(*reflect.SliceHeader)(unsafe.Pointer(&raw))\n\theader.Len /= sizeOfUInt\n\theader.Cap /= sizeOfUInt\n\treturn *(*[]big.Word)(unsafe.Pointer(&header))\n}\n\n\n\nfunc init() {\n\ta := uint(0)\n\n\tsizeOfUInt = int(unsafe.Sizeof(a))\n}\n\nfunc wordsToBytes(raw []big.Word) []byte ", "output": "{\n\theader := *(*reflect.SliceHeader)(unsafe.Pointer(&raw))\n\theader.Len *= sizeOfUInt\n\theader.Cap *= sizeOfUInt\n\treturn *(*[]byte)(unsafe.Pointer(&header))\n}"}
{"input": "package v1beta1\n\nimport (\n\tv1beta1 \"k8s.io/api/scheduling/v1beta1\"\n\tserializer \"k8s.io/apimachinery/pkg/runtime/serializer\"\n\t\"k8s.io/client-go/kubernetes/scheme\"\n\trest \"k8s.io/client-go/rest\"\n)\n\ntype SchedulingV1beta1Interface interface {\n\tRESTClient() rest.Interface\n\tPriorityClassesGetter\n}\n\n\ntype SchedulingV1beta1Client struct {\n\trestClient rest.Interface\n}\n\nfunc (c *SchedulingV1beta1Client) PriorityClasses() PriorityClassInterface {\n\treturn newPriorityClasses(c)\n}\n\n\nfunc NewForConfig(c *rest.Config) (*SchedulingV1beta1Client, error) {\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := rest.RESTClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &SchedulingV1beta1Client{client}, nil\n}\n\n\n\nfunc NewForConfigOrDie(c *rest.Config) *SchedulingV1beta1Client {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n\n\nfunc New(c rest.Interface) *SchedulingV1beta1Client {\n\treturn &SchedulingV1beta1Client{c}\n}\n\nfunc setConfigDefaults(config *rest.Config) error {\n\tgv := v1beta1.SchemeGroupVersion\n\tconfig.GroupVersion = &gv\n\tconfig.APIPath = \"/apis\"\n\tconfig.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: scheme.Codecs}\n\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = rest.DefaultKubernetesUserAgent()\n\t}\n\n\treturn nil\n}\n\n\n\n\n\nfunc (c *SchedulingV1beta1Client) RESTClient() rest.Interface ", "output": "{\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.restClient\n}"}
{"input": "package clw11\n\n\nimport \"C\"\nimport (\n\t\"sync\"\n\t\"unsafe\"\n)\n\ntype BufferCallbackFunc func(memobj Mem, userData interface{})\n\ntype bufferCallbackData struct {\n\tfunction BufferCallbackFunc\n\tuserData interface{}\n}\n\ntype bufferCallbackCollection struct {\n\tsync.Mutex\n\tcallbackMap map[uintptr]bufferCallbackData\n\tcounter     uintptr\n}\n\nfunc (bcc *bufferCallbackCollection) add(function BufferCallbackFunc, userData interface{}) uintptr {\n\n\tbcc.Lock()\n\tkey := bcc.counter\n\tbcc.counter++\n\tbcc.callbackMap[key] = bufferCallbackData{function, userData}\n\tbcc.Unlock()\n\n\treturn key\n}\n\nfunc (bcc *bufferCallbackCollection) get(key uintptr) (BufferCallbackFunc, interface{}) {\n\n\tbcc.Lock()\n\tdata := bcc.callbackMap[key]\n\tdelete(bcc.callbackMap, key)\n\tbcc.Unlock()\n\n\treturn data.function, data.userData\n}\n\nvar (\n\tBufferCallbackFunction = bufferCallback\n\tbufferCallbacks        = bufferCallbackCollection{callbackMap: map[uintptr]bufferCallbackData{}}\n)\n\n\n\n\nfunc bufferCallback(memobj C.cl_mem, user_data unsafe.Pointer) ", "output": "{\n\n\tcallback, userData := bufferCallbacks.get(uintptr(user_data))\n\tcallback(Mem(memobj), userData)\n}"}
{"input": "package iconv\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport \"C\"\n\nimport (\n\t\"sync\"\n)\n\nvar getAliasesOnce sync.Once\nvar allAliases = map[string][]string{}\n\nfunc aliases() map[string][]string {\n\tgetAliasesOnce.Do(getAliases)\n}\n\n\n\nfunc getAliases() ", "output": "{\n\tvar next *C.nameList\n\tfor p := C.listNames(); p != nil; p = next {\n\t\tnext = p.next\n\t\taliases := make([]string, p.n)\n\t\tpnames := (*[1e9]*C.char)(unsafe.Pointer(p.names))\n\t\tfor i := range aliases {\n\t\t\taliases[i] = C.GoString(pnames[i])\n\t\t\tC.free(unsafe.Pointer(pnames[i]))\n\t\t}\n\t\tC.free(unsafe.Pointer(p.names))\n\t\tC.free(unsafe.Pointer(p))\n\t\tfor _, alias := range aliases {\n\t\t\tallAliases[alias] = aliases\n\t\t}\n\t}\n}"}
{"input": "package fake_rootfs_cleaner\n\nimport (\n\t\"sync\"\n\n\t\"code.cloudfoundry.org/garden-linux/resource_pool\"\n\t\"code.cloudfoundry.org/lager\"\n)\n\ntype FakeRootFSCleaner struct {\n\tCleanStub        func(log lager.Logger, path string) error\n\tcleanMutex       sync.RWMutex\n\tcleanArgsForCall []struct {\n\t\tlog  lager.Logger\n\t\tpath string\n\t}\n\tcleanReturns struct {\n\t\tresult1 error\n\t}\n}\n\nfunc (fake *FakeRootFSCleaner) Clean(log lager.Logger, path string) error {\n\tfake.cleanMutex.Lock()\n\tfake.cleanArgsForCall = append(fake.cleanArgsForCall, struct {\n\t\tlog  lager.Logger\n\t\tpath string\n\t}{log, path})\n\tfake.cleanMutex.Unlock()\n\tif fake.CleanStub != nil {\n\t\treturn fake.CleanStub(log, path)\n\t} else {\n\t\treturn fake.cleanReturns.result1\n\t}\n}\n\nfunc (fake *FakeRootFSCleaner) CleanCallCount() int {\n\tfake.cleanMutex.RLock()\n\tdefer fake.cleanMutex.RUnlock()\n\treturn len(fake.cleanArgsForCall)\n}\n\nfunc (fake *FakeRootFSCleaner) CleanArgsForCall(i int) (lager.Logger, string) {\n\tfake.cleanMutex.RLock()\n\tdefer fake.cleanMutex.RUnlock()\n\treturn fake.cleanArgsForCall[i].log, fake.cleanArgsForCall[i].path\n}\n\n\n\nvar _ resource_pool.RootFSCleaner = new(FakeRootFSCleaner)\n\nfunc (fake *FakeRootFSCleaner) CleanReturns(result1 error) ", "output": "{\n\tfake.CleanStub = nil\n\tfake.cleanReturns = struct {\n\t\tresult1 error\n\t}{result1}\n}"}
{"input": "package testutils\n\ntype processorStorage struct {\n\tstoreName []byte\n}\n\nfunc newStore(p *DummyProcessorContext) *processorStorage {\n\treturn &processorStorage{}\n}\n\nfunc (p *processorStorage) Get(key, ns string) ([]byte, error) {\n\treturn nil, nil\n}\n\nfunc (p *processorStorage) Set(key, ns string, value []byte) error {\n\treturn nil\n}\n\n\n\nfunc (p *processorStorage) Has(key, ns string) (bool, error) {\n\treturn true, nil\n}\n\nfunc (p *processorStorage) Delete(key, ns string) error ", "output": "{\n\treturn nil\n}"}
{"input": "package hook\n\nimport (\n\t\"fmt\"\n\n\t\"gopkg.in/juju/charm.v6-unstable/hooks\"\n\t\"gopkg.in/juju/names.v2\"\n)\n\n\nconst (\n\tLeaderElected         hooks.Kind = \"leader-elected\"\n\tLeaderDeposed         hooks.Kind = \"leader-deposed\"\n\tLeaderSettingsChanged hooks.Kind = \"leader-settings-changed\"\n)\n\n\n\ntype Info struct {\n\tKind hooks.Kind `yaml:\"kind\"`\n\n\tRelationId int `yaml:\"relation-id,omitempty\"`\n\n\tRemoteUnit string `yaml:\"remote-unit,omitempty\"`\n\n\tChangeVersion int64 `yaml:\"change-version,omitempty\"`\n\n\tStorageId string `yaml:\"storage-id,omitempty\"`\n}\n\n\n\n\n\n\ntype Committer interface {\n\tCommitHook(Info) error\n}\n\n\n\ntype Validator interface {\n\tValidateHook(Info) error\n}\n\nfunc (hi Info) Validate() error ", "output": "{\n\tswitch hi.Kind {\n\tcase hooks.RelationJoined, hooks.RelationChanged, hooks.RelationDeparted:\n\t\tif hi.RemoteUnit == \"\" {\n\t\t\treturn fmt.Errorf(\"%q hook requires a remote unit\", hi.Kind)\n\t\t}\n\t\tfallthrough\n\tcase hooks.Install, hooks.Start, hooks.ConfigChanged, hooks.UpgradeCharm, hooks.Stop, hooks.RelationBroken,\n\t\thooks.CollectMetrics, hooks.MeterStatusChanged, hooks.UpdateStatus:\n\t\treturn nil\n\tcase hooks.Action:\n\t\treturn fmt.Errorf(\"hooks.Kind Action is deprecated\")\n\tcase hooks.StorageAttached, hooks.StorageDetaching:\n\t\tif !names.IsValidStorage(hi.StorageId) {\n\t\t\treturn fmt.Errorf(\"invalid storage ID %q\", hi.StorageId)\n\t\t}\n\t\treturn nil\n\tcase LeaderElected, LeaderDeposed, LeaderSettingsChanged:\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unknown hook kind %q\", hi.Kind)\n}"}
{"input": "package dbfiles\n\nimport (\n\t\"encoding/csv\"\n\t\"io\"\n\n\t\"github.com/juju/errgo\"\n)\n\ntype Driver interface {\n\tExtention() string\n\tWrite(io.Writer, []string) error\n\tRead(io.Reader) ([][]string, error)\n}\n\ntype CSV struct{}\n\nfunc (driver CSV) Extention() string {\n\treturn \"csv\"\n}\n\nfunc (driver CSV) Write(writer io.Writer, values []string) error {\n\tcsvwriter := csv.NewWriter(writer)\n\n\terr := csvwriter.WriteAll([][]string{values})\n\tif err != nil {\n\t\treturn errgo.Notef(err, \"can not write to csv writer\")\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (driver CSV) Read(reader io.Reader) ([][]string, error) ", "output": "{\n\tcsvreader := csv.NewReader(reader)\n\tcsvreader.FieldsPerRecord = -1\n\n\tvar values [][]string\n\n\tvalues, err := csvreader.ReadAll()\n\tif err != nil {\n\t\treturn nil, errgo.Notef(err, \"can not read all records from file\")\n\t}\n\n\treturn values, nil\n}"}
{"input": "package remote\n\nimport (\n\t\"github.com/AsynkronIT/protoactor-go/actor\"\n)\n\ntype process struct {\n\tpid    *actor.PID\n\tremote *Remote\n}\n\nfunc newProcess(pid *actor.PID, r *Remote) actor.Process {\n\treturn &process{\n\t\tpid:    pid,\n\t\tremote: r,\n\t}\n}\n\nfunc (ref *process) SendUserMessage(pid *actor.PID, message interface{}) {\n\theader, msg, sender := actor.UnwrapEnvelope(message)\n\tref.remote.SendMessage(pid, header, msg, sender, -1)\n}\n\nfunc (ref *process) SendSystemMessage(pid *actor.PID, message interface{}) {\n\n\tswitch msg := message.(type) {\n\tcase *actor.Watch:\n\t\trw := &remoteWatch{\n\t\t\tWatcher: msg.Watcher,\n\t\t\tWatchee: pid,\n\t\t}\n\t\tref.remote.edpManager.remoteWatch(rw)\n\tcase *actor.Unwatch:\n\t\truw := &remoteUnwatch{\n\t\t\tWatcher: msg.Watcher,\n\t\t\tWatchee: pid,\n\t\t}\n\t\tref.remote.edpManager.remoteUnwatch(ruw)\n\tdefault:\n\t\tref.remote.SendMessage(pid, nil, message, nil, -1)\n\t}\n}\n\n\n\nfunc (ref *process) Stop(pid *actor.PID) ", "output": "{\n\tref.SendSystemMessage(pid, stopMessage)\n}"}
{"input": "package utils\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc ToJson(data interface{}) string {\n\tb, err := json.Marshal(data)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t}\n\treturn string(b)\n}\n\nfunc GetHostIp() string {\n\tip := \"127.0.0.1\"\n\n\taddrs, _ := net.InterfaceAddrs()\n\tfor _, a := range addrs {\n\t\tipnet := net.ParseIP(a.String())\n\t\tif ipnet == nil {\n\t\t\tipnet, _, _ = net.ParseCIDR(a.String())\n\t\t}\n\t\tif ipnet != nil && !ipnet.IsLoopback() && !ipnet.IsUnspecified() {\n\t\t\tif ipnet.To4() != nil {\n\t\t\t\tip = ipnet.String()\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ip\n}\n\n\n\nfunc IsIgnoreRequest(url string, contentType string, statusCode int) bool ", "output": "{\n\tif statusCode != 200 {\n\t\treturn true\n\t}\n\tif !strings.Contains(contentType, \"text\") && !strings.Contains(contentType, \"application\") {\n\t\treturn true\n\t}\n\n\tswitch {\n\tcase strings.Contains(contentType, \"text/css\"):\n\t\tfallthrough\n\tcase strings.Contains(contentType, \"text/javascript\"):\n\t\treturn true\n\tdefault:\n\t\tbreak\n\t}\n\tidx := strings.Index(url, \"?\")\n\tif idx >= 0 {\n\t\turl = url[:idx]\n\t}\n\text := strings.ToLower(filepath.Ext(url))\n\treturn ext == \".js\" || ext == \".css\" ||\n\t\text == \".jpg\" || ext == \".jpeg\" || ext == \".gif\" || ext == \".png\" ||\n\t\text == \".bmp\" || ext == \".ico\" || ext == \".woff\" || ext == \".font\" ||\n\t\text == \".ttf\" || ext == \".svg\" || ext == \".pdf\" || ext == \".txt\"\n}"}
{"input": "package v1\n\nimport (\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/client-go/pkg/apis/extensions/v1beta1\"\n)\n\nconst (\n\tIotDaemonSetKind = \"IotDaemonSet\"\n\tIotDaemonSetType = \"iotdaemonsets\"\n)\n\ntype IotDaemonSet struct {\n\tmetav1.TypeMeta `json:\",inline\"`\n\tMetadata        metav1.ObjectMeta       `json:\"metadata,omitempty\"`\n\tSpec            v1beta1.DaemonSetSpec   `json:\"spec,omitempty\"`\n\tStatus          v1beta1.DaemonSetStatus `json:\"status,omitempty\"`\n}\n\ntype IotDaemonSetList struct {\n\tmetav1.TypeMeta `json:\",inline\"`\n\tMetadata        metav1.ListMeta `json:\"metadata,omitempty\"`\n\tItems           []IotDaemonSet  `json:\"items\"`\n}\n\nfunc (iotDaemonSet *IotDaemonSet) GetObjectKind() schema.ObjectKind {\n\treturn &iotDaemonSet.TypeMeta\n}\n\n\n\nfunc (iotDaemonSetList *IotDaemonSetList) GetObjectKind() schema.ObjectKind {\n\treturn &iotDaemonSetList.TypeMeta\n}\n\nfunc (iotDaemonSetList *IotDaemonSetList) GetListMeta() metav1.List {\n\treturn &iotDaemonSetList.Metadata\n}\n\nfunc (iotDaemonSet *IotDaemonSet) GetObjectMeta() *metav1.ObjectMeta ", "output": "{\n\treturn &iotDaemonSet.Metadata\n}"}
{"input": "package apicaller\n\nimport (\n\t\"github.com/juju/errors\"\n\n\t\"github.com/juju/juju/agent\"\n\t\"github.com/juju/juju/api/base\"\n\t\"github.com/juju/juju/worker\"\n\t\"github.com/juju/juju/worker/dependency\"\n)\n\n\ntype ManifoldConfig struct {\n\tAgentName string\n}\n\n\n\nfunc Manifold(config ManifoldConfig) dependency.Manifold {\n\treturn dependency.Manifold{\n\t\tInputs: []string{\n\t\t\tconfig.AgentName,\n\t\t},\n\t\tOutput: outputFunc,\n\t\tStart:  startFunc(config),\n\t}\n}\n\n\n\nfunc startFunc(config ManifoldConfig) dependency.StartFunc {\n\treturn func(getResource dependency.GetResourceFunc) (worker.Worker, error) {\n\n\t\tvar a agent.Agent\n\t\tif err := getResource(config.AgentName, &a); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tconn, err := openConnection(a)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Annotate(err, \"cannot open api\")\n\t\t}\n\n\t\tcurrentConfig := a.CurrentConfig()\n\t\tif currentConfig.Environment().Id() == \"\" {\n\t\t\terr := a.ChangeConfig(func(setter agent.ConfigSetter) error {\n\t\t\t\tenvironTag, err := conn.EnvironTag()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn errors.Annotate(err, \"no environment uuid set on api\")\n\t\t\t\t}\n\t\t\t\treturn setter.Migrate(agent.MigrateParams{\n\t\t\t\t\tEnvironment: environTag,\n\t\t\t\t})\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tlogger.Warningf(\"unable to save environment uuid: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\treturn newApiConnWorker(conn)\n\t}\n}\n\n\n\n\nfunc outputFunc(in worker.Worker, out interface{}) error ", "output": "{\n\tinWorker, _ := in.(*apiConnWorker)\n\toutPointer, _ := out.(*base.APICaller)\n\tif inWorker == nil || outPointer == nil {\n\t\treturn errors.Errorf(\"expected %T->%T; got %T->%T\", inWorker, outPointer, in, out)\n\t}\n\t*outPointer = inWorker.conn\n\treturn nil\n}"}
{"input": "package gtka\n\nimport (\n\t\"github.com/gotk3/gotk3/gtk\"\n\t\"github.com/coyim/gotk3adapter/gliba\"\n\t\"github.com/coyim/gotk3adapter/gtki\"\n)\n\ntype application struct {\n\t*gliba.Application\n\tinternal *gtk.Application\n}\n\nfunc wrapApplicationSimple(v *gtk.Application) *application {\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn &application{gliba.WrapApplicationSimple(&v.Application), v}\n}\n\nfunc wrapApplication(v *gtk.Application, e error) (*application, error) {\n\treturn wrapApplicationSimple(v), e\n}\n\nfunc unwrapApplication(v gtki.Application) *gtk.Application {\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn v.(*application).internal\n}\n\n\n\nfunc (v *application) GetActiveWindow() gtki.Window ", "output": "{\n\tret := wrapWindowSimple(v.internal.GetActiveWindow())\n\tif ret == nil {\n\t\treturn nil\n\t}\n\treturn ret\n}"}
{"input": "package usercache\n\nimport (\n\t\"fmt\"\n\n\t\"k8s.io/client-go/tools/cache\"\n\n\tuserapi \"github.com/openshift/api/user/v1\"\n\tuserinformer \"github.com/openshift/client-go/user/informers/externalversions/user/v1\"\n)\n\n\n\ntype GroupCache struct {\n\tindexer      cache.Indexer\n\tgroupsSynced cache.InformerSynced\n}\n\nconst ByUserIndexName = \"ByUser\"\n\n\n\nfunc ByUserIndexKeys(obj interface{}) ([]string, error) {\n\tgroup, ok := obj.(*userapi.Group)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"unexpected type: %v\", obj)\n\t}\n\n\treturn group.Users, nil\n}\n\nfunc NewGroupCache(groupInformer userinformer.GroupInformer) *GroupCache {\n\treturn &GroupCache{\n\t\tindexer:      groupInformer.Informer().GetIndexer(),\n\t\tgroupsSynced: groupInformer.Informer().HasSynced,\n\t}\n}\n\nfunc (c *GroupCache) GroupsFor(username string) ([]*userapi.Group, error) {\n\tobjs, err := c.indexer.ByIndex(ByUserIndexName, username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tgroups := make([]*userapi.Group, len(objs))\n\tfor i := range objs {\n\t\tgroups[i] = objs[i].(*userapi.Group)\n\t}\n\n\treturn groups, nil\n}\n\n\n\nfunc (c *GroupCache) HasSynced() bool ", "output": "{\n\treturn c.groupsSynced()\n}"}
{"input": "package msgpackzip\n\nimport (\n\t\"bytes\"\n\t\"compress/flate\"\n\t\"io/ioutil\"\n)\n\nfunc flateCompress(b []byte) ([]byte, error) {\n\tvar buf bytes.Buffer\n\tzw, err := flate.NewWriter(&buf, flate.DefaultCompression)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_, err = zw.Write(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = zw.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\n\n\n\nfunc flateInflate(b []byte) ([]byte, error) ", "output": "{\n\tbuf := bytes.NewBuffer(b)\n\tzr := flate.NewReader(buf)\n\treturn ioutil.ReadAll(zr)\n}"}
{"input": "package daemon\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-openapi/runtime\"\n\n\t\"github.com/cilium/cilium/api/v1/models\"\n)\n\n\nconst GetDebuginfoOKCode int = 200\n\n\ntype GetDebuginfoOK struct {\n\n\tPayload *models.DebugInfo `json:\"body,omitempty\"`\n}\n\n\nfunc NewGetDebuginfoOK() *GetDebuginfoOK {\n\n\treturn &GetDebuginfoOK{}\n}\n\n\nfunc (o *GetDebuginfoOK) WithPayload(payload *models.DebugInfo) *GetDebuginfoOK {\n\to.Payload = payload\n\treturn o\n}\n\n\nfunc (o *GetDebuginfoOK) SetPayload(payload *models.DebugInfo) {\n\to.Payload = payload\n}\n\n\nfunc (o *GetDebuginfoOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {\n\n\trw.WriteHeader(200)\n\tif o.Payload != nil {\n\t\tpayload := o.Payload\n\t\tif err := producer.Produce(rw, payload); err != nil {\n\t\t\tpanic(err) \n\t\t}\n\t}\n}\n\n\nconst GetDebuginfoFailureCode int = 500\n\n\ntype GetDebuginfoFailure struct {\n\n\tPayload models.Error `json:\"body,omitempty\"`\n}\n\n\nfunc NewGetDebuginfoFailure() *GetDebuginfoFailure {\n\n\treturn &GetDebuginfoFailure{}\n}\n\n\n\n\n\nfunc (o *GetDebuginfoFailure) SetPayload(payload models.Error) {\n\to.Payload = payload\n}\n\n\nfunc (o *GetDebuginfoFailure) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {\n\n\trw.WriteHeader(500)\n\tpayload := o.Payload\n\tif err := producer.Produce(rw, payload); err != nil {\n\t\tpanic(err) \n\t}\n}\n\nfunc (o *GetDebuginfoFailure) WithPayload(payload models.Error) *GetDebuginfoFailure ", "output": "{\n\to.Payload = payload\n\treturn o\n}"}
{"input": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n\n\nfunc main() {\n\tcalcDone := make(chan struct{})\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tgo func() {\n\t\texpensiveOp(ctx)\n\t\tcalcDone <- struct{}{}\n\t}()\n\n\tselect {\n\tcase <-calcDone:\n\t\tfmt.Println(\"Calculation done\")\n\tcase <-ctx.Done():\n\t\tfmt.Println(\"Calculation Timeout\")\n\t}\n}\n\nfunc expensiveOp(ctx context.Context) ", "output": "{\n\tfor {\n\t\ttime.Sleep(1 * time.Second)\n\t\tfmt.Println(\"Still calculating nothing\")\n\t}\n}"}
{"input": "package kvstore\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/cilium/cilium/pkg/metrics\"\n\t\"github.com/cilium/cilium/pkg/option\"\n)\n\nconst (\n\tmetricDelete = \"delete\"\n\tmetricRead   = \"read\"\n\tmetricSet    = \"set\"\n)\n\nfunc getScopeFromKey(key string) string {\n\ts := strings.SplitN(key, \"/\", 5)\n\tif len(s) != 5 {\n\t\tif len(key) >= 12 {\n\t\t\treturn key[:12]\n\t\t}\n\t\treturn key\n\t}\n\treturn fmt.Sprintf(\"%s/%s\", s[2], s[3])\n}\n\n\n\nfunc trackEventQueued(key string, typ EventType, duration time.Duration) {\n\tif !option.Config.MetricsConfig.KVStoreEventsQueueDurationEnabled {\n\t\treturn\n\t}\n\tmetrics.KVStoreEventsQueueDuration.WithLabelValues(getScopeFromKey(key), typ.String()).Observe(duration.Seconds())\n}\n\nfunc recordQuorumError(err string) {\n\tif !option.Config.MetricsConfig.KVStoreQuorumErrorsEnabled {\n\t\treturn\n\t}\n\tmetrics.KVStoreQuorumErrors.WithLabelValues(err).Inc()\n}\n\nfunc increaseMetric(key, kind, action string, duration time.Duration, err error) ", "output": "{\n\tif !option.Config.MetricsConfig.KVStoreOperationsDurationEnabled {\n\t\treturn\n\t}\n\tnamespace := getScopeFromKey(key)\n\toutcome := metrics.Error2Outcome(err)\n\tmetrics.KVStoreOperationsDuration.\n\t\tWithLabelValues(namespace, kind, action, outcome).Observe(duration.Seconds())\n}"}
{"input": "package msg\n\ntype Message struct {\n}\n\nfunc (m *Message) Send(email, subject string, body []byte) error {\n\treturn nil\n}\n\ntype Messager interface {\n\tSend(email, subject string, body []byte) error\n}\n\n\n\nfunc Alert(m Messager, problem []byte) error ", "output": "{\n\treturn m.Send(\"noc@example.com\", \"Critical Error\", problem)\n}"}
{"input": "package errors\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestUnauthenticated(t *testing.T) ", "output": "{\n\terr := Unauthenticated(\"basic\")\n\tassert.EqualValues(t, 401, err.Code())\n\tassert.Equal(t, \"unauthenticated for basic\", err.Error())\n}"}
{"input": "package scanner\n\nimport (\n\t\"github.com/carlcui/expressive/locator\"\n\t\"github.com/carlcui/expressive/token\"\n)\n\ntype MockScanner struct {\n\ttoks []*token.Token\n\tpos  int\n}\n\nfunc (scanner *MockScanner) Init(toks []*token.Token) {\n\tscanner.toks = toks\n\tscanner.pos = 0\n}\n\n\n\nfunc (scanner *MockScanner) Next() *token.Token ", "output": "{\n\tif scanner.pos >= len(scanner.toks) {\n\t\treturn token.IllegalToken(\"\", locator.CreateIndexLocation(scanner.pos))\n\t}\n\n\tcur := scanner.toks[scanner.pos]\n\tcur.Locator = &locator.IndexLocation{Index: scanner.pos}\n\n\tscanner.pos++\n\n\treturn cur\n}"}
{"input": "package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n\n\nfunc (cmd *removeCommand) removeBlueprints(args []string) error ", "output": "{\n\tflagset := flag.NewFlagSet(\"remove-blueprints\", flag.ExitOnError)\n\tvar (\n\t\tflBlueprintName = flagset.String(\"name\", \"\", \"name of blueprint, optionally comma-separated\")\n\t)\n\tflagset.Usage = usageFor(flagset, \"mdmctl remove blueprints [flags]\")\n\tif err := flagset.Parse(args); err != nil {\n\t\treturn err\n\t}\n\n\tctx := context.Background()\n\terr := cmd.blueprintsvc.RemoveBlueprints(ctx, strings.Split(*flBlueprintName, \",\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"removed blueprint(s): %s\\n\", *flBlueprintName)\n\n\treturn nil\n}"}
{"input": "package goutil\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype WorkSubmitter interface {\n\tSubmit(f func())\n}\n\ntype WorkQueue interface {\n\tWorkSubmitter\n\tWait()\n}\n\nfunc NewWorkQueue(n int) WorkQueue {\n\tvar wg sync.WaitGroup\n\tch := make(chan func())\n\tfor i := 0; i < n; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor f := range ch {\n\t\t\t\tf()\n\t\t\t}\n\t\t}()\n\t}\n\treturn iWorkQueue{wg: &wg, ch: ch}\n}\n\ntype iWorkQueue struct {\n\twg *sync.WaitGroup\n\tch chan func()\n}\n\n\n\nfunc (w iWorkQueue) Wait() {\n\tclose(w.ch)\n\tw.wg.Wait()\n}\n\ntype Tool struct {\n}\n\nfunc (Tool) Name() string {\n\treturn \"testq,test the work queue\"\n}\n\nfunc (t Tool) Run(args []string) {\n\tq := NewWorkQueue(100)\n\n\tvar started, ended int64\n\n\twork := func() {\n\t\tatomic.AddInt64(&started, 1)\n\t\tfmt.Printf(\"%d\\n\", started)\n\t\ttime.Sleep(time.Duration(30+rand.Intn(70)) * time.Millisecond)\n\t\tatomic.AddInt64(&ended, 1)\n\t}\n\n\tfor i := 0; i < 3000; i++ {\n\t\tq.Submit(work)\n\t}\n\n\tq.Wait()\n\n\tfmt.Println(started, ended)\n\n}\n\nfunc (w iWorkQueue) Submit(f func()) ", "output": "{\n\tw.ch <- f\n}"}
{"input": "package vulnerabilityscanning\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ListWorkRequestsRequest struct {\n\n\tCompartmentId *string `mandatory:\"true\" contributesTo:\"query\" name:\"compartmentId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tPage *string `mandatory:\"false\" contributesTo:\"query\" name:\"page\"`\n\n\tLimit *int `mandatory:\"false\" contributesTo:\"query\" name:\"limit\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\n\n\n\nfunc (request ListWorkRequestsRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request ListWorkRequestsRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request ListWorkRequestsRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ListWorkRequestsResponse struct {\n\n\tRawResponse *http.Response\n\n\tWorkRequestCollection `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n\n\tOpcNextPage *string `presentIn:\"header\" name:\"opc-next-page\"`\n}\n\nfunc (response ListWorkRequestsResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response ListWorkRequestsResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request ListWorkRequestsRequest) String() string ", "output": "{\n\treturn common.PointerString(request)\n}"}
{"input": "package types\n\nimport (\n\t\"exec\"\n\t\"go/ast\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar gcName, gcPath string \n\nfunc init() {\n\tswitch runtime.GOARCH {\n\tcase \"386\":\n\t\tgcName = \"8g\"\n\tcase \"amd64\":\n\t\tgcName = \"6g\"\n\tcase \"arm\":\n\t\tgcName = \"5g\"\n\tdefault:\n\t\tgcName = \"unknown-GOARCH-compiler\"\n\t\tgcPath = gcName\n\t\treturn\n\t}\n\tgcPath, _ = exec.LookPath(gcName)\n}\n\nfunc compile(t *testing.T, dirname, filename string) {\n\tcmd := exec.Command(gcPath, filename)\n\tcmd.Dir = dirname\n\tout, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\tt.Errorf(\"%s %s failed: %s\", gcName, filename, err)\n\t\treturn\n\t}\n\tt.Logf(\"%s\", string(out))\n}\n\n\n\nvar imports = make(map[string]*ast.Object)\n\nfunc testPath(t *testing.T, path string) bool {\n\t_, err := GcImporter(imports, path)\n\tif err != nil {\n\t\tt.Errorf(\"testPath(%s): %s\", path, err)\n\t\treturn false\n\t}\n\treturn true\n}\n\nconst maxTime = 3e9 \n\n\n\nfunc TestGcImport(t *testing.T) {\n\tcompile(t, \"testdata\", \"exports.go\")\n\n\tnimports := 0\n\tif testPath(t, \"./testdata/exports\") {\n\t\tnimports++\n\t}\n\tnimports += testDir(t, \"\", time.Nanoseconds()+maxTime) \n\tt.Logf(\"tested %d imports\", nimports)\n}\n\nfunc testDir(t *testing.T, dir string, endTime int64) (nimports int) ", "output": "{\n\tdirname := filepath.Join(pkgRoot, dir)\n\tlist, err := ioutil.ReadDir(dirname)\n\tif err != nil {\n\t\tt.Errorf(\"testDir(%s): %s\", dirname, err)\n\t}\n\tfor _, f := range list {\n\t\tif time.Nanoseconds() >= endTime {\n\t\t\tt.Log(\"testing time used up\")\n\t\t\treturn\n\t\t}\n\t\tswitch {\n\t\tcase f.IsRegular():\n\t\t\tfor _, ext := range pkgExts {\n\t\t\t\tif strings.HasSuffix(f.Name, ext) {\n\t\t\t\t\tname := f.Name[0 : len(f.Name)-len(ext)] \n\t\t\t\t\tif testPath(t, filepath.Join(dir, name)) {\n\t\t\t\t\t\tnimports++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase f.IsDirectory():\n\t\t\tnimports += testDir(t, filepath.Join(dir, f.Name), endTime)\n\t\t}\n\t}\n\treturn\n}"}
{"input": "package vertigo\n\nimport (\n\t\"strings\"\n)\n\n\n\n\ntype Token struct {\n\tIdx         int\n\tWord        string\n\tAttrs       []string\n\tStructAttrs map[string]string\n}\n\n\n\n\n\n\n\nfunc (t *Token) PosAttrByIndex(idx int) string {\n\tif idx == 0 {\n\t\treturn t.Word\n\n\t} else if idx > 0 && idx < len(t.Attrs)+1 {\n\t\treturn t.Attrs[idx-1]\n\t}\n\treturn \"\"\n}\n\n\n\n\n\n\n\nfunc (t *Token) MatchesFilter(filterCNF [][][]string) bool {\n\tvar sub bool\n\tfor _, item := range filterCNF {\n\t\tsub = false\n\t\tfor _, v := range item {\n\t\t\tif v[1] == t.StructAttrs[v[0]] {\n\t\t\t\tsub = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif sub == false {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\n\n\ntype Structure struct {\n\n\tName string\n\n\tAttrs map[string]string\n\n\tIsEmpty bool\n}\n\n\n\n\ntype StructureClose struct {\n\tName string\n}\n\nfunc (t *Token) WordLC() string ", "output": "{\n\treturn strings.ToLower(t.Word)\n}"}
{"input": "package aspect\n\nimport ()\n\n\ntype Parameters struct {\n\targs []interface{}\n}\n\n\nfunc (p *Parameters) Add(i interface{}) int {\n\tp.args = append(p.args, i)\n\treturn len(p.args)\n}\n\nfunc (p *Parameters) Args() []interface{} {\n\treturn p.args\n}\n\n\nfunc (p *Parameters) Len() int {\n\treturn len(p.args)\n}\n\n\nfunc Params() *Parameters {\n\treturn &Parameters{}\n}\n\n\ntype Parameter struct {\n\tValue interface{}\n}\n\nfunc (p *Parameter) String() string {\n\tcompiled, _ := p.Compile(&defaultDialect{}, Params())\n\treturn compiled\n}\n\n\n\n\n\nfunc (p *Parameter) Compile(d Dialect, params *Parameters) (string, error) ", "output": "{\n\ti := params.Add(p.Value)\n\treturn d.Parameterize(i), nil\n}"}
{"input": "package markdown\n\nimport (\n\t\"strings\"\n)\n\nfunc newEscaper(chars ...string) *strings.Replacer {\n\treplacements := []string{}\n\n\tfor _, char := range chars {\n\t\treplacements = append(replacements, char, \"\\\\\"+char)\n\t}\n\n\treturn strings.NewReplacer(replacements...)\n}\n\nvar escaper = newEscaper(\n\t\"*\", \"_\", \"~\", \n\t\"`\",                \n\t\"<\", \">\", \"@\", \"#\", \n\t\":\", \n)\n\n\n\n\nfunc Escape(s string) string ", "output": "{\n\treturn escaper.Replace(s)\n}"}
{"input": "package mocks\n\nimport (\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\tcluster \"sigs.k8s.io/kind/pkg/cluster\"\n)\n\n\ntype Mockprovider struct {\n\tctrl     *gomock.Controller\n\trecorder *MockproviderMockRecorder\n}\n\n\ntype MockproviderMockRecorder struct {\n\tmock *Mockprovider\n}\n\n\n\n\n\nfunc (m *Mockprovider) EXPECT() *MockproviderMockRecorder {\n\treturn m.recorder\n}\n\n\nfunc (m *Mockprovider) Create(name string, options ...cluster.CreateOption) error {\n\tm.ctrl.T.Helper()\n\tvarargs := []interface{}{name}\n\tfor _, a := range options {\n\t\tvarargs = append(varargs, a)\n\t}\n\tret := m.ctrl.Call(m, \"Create\", varargs...)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n\nfunc (mr *MockproviderMockRecorder) Create(name interface{}, options ...interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\tvarargs := append([]interface{}{name}, options...)\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Create\", reflect.TypeOf((*Mockprovider)(nil).Create), varargs...)\n}\n\n\nfunc (m *Mockprovider) List() ([]string, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"List\")\n\tret0, _ := ret[0].([]string)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n\nfunc (mr *MockproviderMockRecorder) List() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"List\", reflect.TypeOf((*Mockprovider)(nil).List))\n}\n\nfunc NewMockprovider(ctrl *gomock.Controller) *Mockprovider ", "output": "{\n\tmock := &Mockprovider{ctrl: ctrl}\n\tmock.recorder = &MockproviderMockRecorder{mock}\n\treturn mock\n}"}
{"input": "package euler4\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\n\t\"github.com/andrew-field/maths\"\n)\n\nfunc check(e error) {\n\tif e != nil {\n\t\tpanic(e)\n\t}\n}\n\n\n\n\n\nfunc MaximumPathSumTwo() int ", "output": "{\n\tabsPath, err := filepath.Abs(\"p067_triangle.txt\")\n\tcheck(err)\n\tf, err := os.Open(absPath)\n\tcheck(err)\n\tdefer f.Close()\n\n\treader := bufio.NewReader(f) \n\n\tnumbers := make([]int, 0)\n\n\tnumber := make([]byte, 2)\n\tfor {\n\t\t_, err = reader.Read(number)\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tcheck(err)\n\t\tvalue, err := strconv.Atoi(string(number))\n\t\tcheck(err)\n\t\tnumbers = append(numbers, value)\n\t}\n\n\tpyramidTree := maths.CreatePyramidTree(numbers...)\n\n\treturn maths.MaxPath(pyramidTree)\n}"}
{"input": "package demo\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/mabetle/mgo/mcore/msdb\"\n)\n\n\n\n\n\nfunc DemoSimpleTable(table msdb.SimpleTable) ", "output": "{\n\n\tvar rows int = table.GetRows()\n\tvar cols int = table.GetCols()\n\n\tfmt.Println(\"Rows:\", rows)\n\tfmt.Println(\"Cols:\", cols)\n\n\n\tfor table.Next() {\n\t\tfor i := 0; i < cols; i++ {\n\t\t\tfmt.Printf(\"%s\\t\", table.GetString(string(i)))\n\t\t}\n\t\tfmt.Println()\n\t}\n}"}
{"input": "package csm\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMetricChanPush(t *testing.T) {\n\tch := newMetricChan(5)\n\tdefer close(ch.ch)\n\n\tpushed := ch.Push(metric{})\n\tif !pushed {\n\t\tt.Errorf(\"expected metrics to be pushed\")\n\t}\n\n\tif e, a := 1, len(ch.ch); e != a {\n\t\tt.Errorf(\"expected %d, but received %d\", e, a)\n\t}\n}\n\nfunc TestMetricChanPauseContinue(t *testing.T) {\n\tch := newMetricChan(5)\n\tdefer close(ch.ch)\n\tch.Pause()\n\n\tif !ch.IsPaused() {\n\t\tt.Errorf(\"expected to be paused, but did not pause properly\")\n\t}\n\n\tch.Continue()\n\tif ch.IsPaused() {\n\t\tt.Errorf(\"expected to be not paused, but did not continue properly\")\n\t}\n\n\tpushed := ch.Push(metric{})\n\tif !pushed {\n\t\tt.Errorf(\"expected metrics to be pushed\")\n\t}\n\n\tif e, a := 1, len(ch.ch); e != a {\n\t\tt.Errorf(\"expected %d, but received %d\", e, a)\n\t}\n}\n\nfunc TestMetricChanPushWhenPaused(t *testing.T) {\n\tch := newMetricChan(5)\n\tdefer close(ch.ch)\n\tch.Pause()\n\n\tpushed := ch.Push(metric{})\n\tif pushed {\n\t\tt.Errorf(\"expected metrics to not be pushed\")\n\t}\n\n\tif e, a := 0, len(ch.ch); e != a {\n\t\tt.Errorf(\"expected %d, but received %d\", e, a)\n\t}\n}\n\n\n\nfunc TestMetricChanNonBlocking(t *testing.T) ", "output": "{\n\tch := newMetricChan(0)\n\tdefer close(ch.ch)\n\n\tpushed := ch.Push(metric{})\n\tif pushed {\n\t\tt.Errorf(\"expected metrics to be not pushed\")\n\t}\n\n\tif e, a := 0, len(ch.ch); e != a {\n\t\tt.Errorf(\"expected %d, but received %d\", e, a)\n\t}\n}"}
{"input": "package dnsutil\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"github.com/miekg/dns\"\n)\n\n\n\n\nfunc ParseHostPortOrFile(s ...string) ([]string, error) {\n\tvar servers []string\n\tfor _, host := range s {\n\t\taddr, _, err := net.SplitHostPort(host)\n\t\tif err != nil {\n\t\t\tif net.ParseIP(host) == nil {\n\t\t\t\tss, err := tryFile(host)\n\t\t\t\tif err == nil {\n\t\t\t\t\tservers = append(servers, ss...)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn servers, fmt.Errorf(\"not an IP address or file: %q\", host)\n\t\t\t}\n\t\t\tss := net.JoinHostPort(host, \"53\")\n\t\t\tservers = append(servers, ss)\n\t\t\tcontinue\n\t\t}\n\n\t\tif net.ParseIP(addr) == nil {\n\t\t\tss, err := tryFile(host)\n\t\t\tif err == nil {\n\t\t\t\tservers = append(servers, ss...)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn servers, fmt.Errorf(\"not an IP address or file: %q\", host)\n\t\t}\n\t\tservers = append(servers, host)\n\t}\n\treturn servers, nil\n}\n\n\n\n\n\n\nfunc ParseHostPort(s, defaultPort string) (string, error) {\n\taddr, port, err := net.SplitHostPort(s)\n\tif port == \"\" {\n\t\tport = defaultPort\n\t}\n\tif err != nil {\n\t\tif net.ParseIP(s) == nil {\n\t\t\treturn \"\", fmt.Errorf(\"must specify an IP address: `%s'\", s)\n\t\t}\n\t\treturn net.JoinHostPort(s, port), nil\n\t}\n\n\tif net.ParseIP(addr) == nil {\n\t\treturn \"\", fmt.Errorf(\"must specify an IP address: `%s'\", addr)\n\t}\n\treturn net.JoinHostPort(addr, port), nil\n}\n\nfunc tryFile(s string) ([]string, error) ", "output": "{\n\tc, err := dns.ClientConfigFromFile(s)\n\tif err == os.ErrNotExist {\n\t\treturn nil, fmt.Errorf(\"failed to open file %q: %q\", s, err)\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\n\tservers := []string{}\n\tfor _, s := range c.Servers {\n\t\tservers = append(servers, net.JoinHostPort(s, c.Port))\n\t}\n\treturn servers, nil\n}"}
{"input": "package sandbox\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"text/template\"\n\n\t\"ireul.com/com\"\n)\n\nconst tplSeedSSH = `#!/bin/bash\n# create /root/.ssh\nmkdir -p /root/.ssh\nchmod 700 /root/.ssh\ncd /root/.ssh\n\n# write keys\necho \"{{.PublicKey}}\"  > id_rsa.pub\nchmod 644 id_rsa.pub\necho \"{{.PrivateKey}}\" > id_rsa\nchmod 600 id_rsa\n\n# write README\necho \"id_rsa 和 id_rsa.pub 受 Bunker 管理，请勿修改\" > README\n`\n\nconst tplSSHConfig = `#!/bin/bash\n# remove .ssh/config\nrm -f /root/.ssh/config\n\n# create new .ssh/config\n{{range .Entries}}\necho \"Host {{.Name}}\" >> /root/.ssh/config\necho \"  HostName {{.Host}}\" >> /root/.ssh/config\necho \"  Port {{.Port}}\" >> /root/.ssh/config\necho \"  User {{.User}}\" >> /root/.ssh/config\n{{end}}\n`\n\n\ntype SSHEntry struct {\n\tName string\n\tHost string\n\tPort uint\n\tUser string\n}\n\n\n\nfunc scriptSeedSSH(publicKey string, privateKey string) string {\n\treturn createScript(\n\t\t\"seed-ssh\",\n\t\ttplSeedSSH,\n\t\tcom.NewMap(\"PublicKey\", publicKey, \"PrivateKey\", privateKey),\n\t)\n}\n\n\nfunc ScriptSeedSSHConfig(entries []SSHEntry) string {\n\treturn createScript(\n\t\t\"seed-ssh-config\",\n\t\ttplSSHConfig,\n\t\tcom.NewMap(\"Entries\", entries),\n\t)\n}\n\nfunc createScript(name string, tmpl string, data com.Map) string ", "output": "{\n\tt, err := template.New(name).Parse(tmpl)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tbuf := &bytes.Buffer{}\n\tt.Execute(buf, data)\n\treturn buf.String()\n}"}
{"input": "package jd\n\nimport (\n\t\"fmt\"\n)\n\nfunc patchAll(n JsonNode, d Diff) (JsonNode, error) {\n\tvar err error\n\tfor _, de := range d {\n\t\tn, err = n.patch(Path{}, de.Path, de.OldValues, de.NewValues)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn n, nil\n}\n\nfunc singleValue(nodes []JsonNode) JsonNode {\n\tif len(nodes) == 0 {\n\t\treturn voidNode{}\n\t}\n\tif len(nodes) > 1 {\n\t\tpanic(fmt.Sprintf(\"Expected single value. Got %v.\", nodes))\n\t}\n\treturn nodes[0]\n}\n\n\n\nfunc patchErrNonSetDiff(oldValues, newValues []JsonNode, path Path) (JsonNode, error) {\n\tif len(oldValues) > 1 {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"Invalid diff: Multiple removals from non-set at %v.\",\n\t\t\tpath)\n\t} else {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"Invalid diff: Multiple additions to a non-set at %v.\",\n\t\t\tpath)\n\t}\n}\n\nfunc patchErrExpectValue(want, found JsonNode, path Path) (JsonNode, error) {\n\treturn nil, fmt.Errorf(\n\t\t\"Found %v at %v. Expected %v.\",\n\t\tfound.Json(), path, want.Json())\n}\n\nfunc patchErrExpectColl(n JsonNode, pe interface{}) (JsonNode, error) ", "output": "{\n\tswitch pe := pe.(type) {\n\tcase string:\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"Found %v at %v. Expected JSON object.\",\n\t\t\tn.Json(), pe)\n\tcase float64:\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"Found %v at %v. Expected JSON array.\",\n\t\t\tn.Json(), pe)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Invalid path element %v.\", pe))\n\t}\n\n}"}
{"input": "package commands\n\nimport (\n\t\"code.google.com/p/log4go\"\n\t\"github.com/limetext/lime/backend\"\n)\n\ntype cmd struct {\n\tname string\n\tcmd  backend.Command\n}\n\n\n\nfunc register(cmds []cmd) ", "output": "{\n\te := backend.GetEditor()\n\tfor i := range cmds {\n\t\tif err := e.CommandHandler().Register(cmds[i].name, cmds[i].cmd); err != nil {\n\t\t\tlog4go.Error(\"Failed to register command %s: %s\", cmds[i].name, err)\n\t\t}\n\t}\n}"}
{"input": "package plugin\n\nimport \"strings\"\n\n\ntype YandexShare struct{}\n\n\nfunc (p *YandexShare) Defaults() map[string]string {\n\treturn map[string]string{\"services\": \"facebook,twitter,gplus\", \"size\": \"m\", \"lang\": \"en\"}\n}\n\n\n\n\nfunc (p *YandexShare) SetUp(settings map[string]string) (map[string]string, error) ", "output": "{\n\tif val, ok := settings[\"services\"]; ok {\n\t\tsettings[\"services\"] = strings.Replace(val, \" \", \",\", -1)\n\t}\n\n\treturn mergeSettings(settings, p.Defaults()), nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc ab() (a, b int) {\n\ta, b = 1, 2\n\treturn\n}\n\n\n\nfunc pick(index int, args ...interface{}) interface{} {\n\treturn args[index]\n}\n\nfunc main() {\n\n\tfmt.Printf(\"%v\\n\", first(ab()))\n\n}\n\nfunc first(args ...interface{}) interface{} ", "output": "{\n\treturn args[0]\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n\t\"net/http\"\n)\n\n\ntype ListBootVolumeAttachmentsRequest struct {\n\n\tAvailabilityDomain *string `mandatory:\"true\" contributesTo:\"query\" name:\"availabilityDomain\"`\n\n\tCompartmentId *string `mandatory:\"true\" contributesTo:\"query\" name:\"compartmentId\"`\n\n\tLimit *int `mandatory:\"false\" contributesTo:\"query\" name:\"limit\"`\n\n\tPage *string `mandatory:\"false\" contributesTo:\"query\" name:\"page\"`\n\n\tInstanceId *string `mandatory:\"false\" contributesTo:\"query\" name:\"instanceId\"`\n\n\tBootVolumeId *string `mandatory:\"false\" contributesTo:\"query\" name:\"bootVolumeId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\n\n\n\nfunc (request ListBootVolumeAttachmentsRequest) HTTPRequest(method, path string) (http.Request, error) {\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request ListBootVolumeAttachmentsRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ListBootVolumeAttachmentsResponse struct {\n\n\tRawResponse *http.Response\n\n\tItems []BootVolumeAttachment `presentIn:\"body\"`\n\n\tOpcNextPage *string `presentIn:\"header\" name:\"opc-next-page\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response ListBootVolumeAttachmentsResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response ListBootVolumeAttachmentsResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request ListBootVolumeAttachmentsRequest) String() string ", "output": "{\n\treturn common.PointerString(request)\n}"}
{"input": "package elastic\n\nimport (\n\t\"context\"\n\t\"testing\"\n)\n\nfunc TestIndicesLifecycle(t *testing.T) {\n\tclient := setupTestClient(t)\n\n\tcreateIndex, err := client.CreateIndex(testIndexName).Do(context.TODO())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !createIndex.Acknowledged {\n\t\tt.Errorf(\"expected IndicesCreateResult.Acknowledged %v; got %v\", true, createIndex.Acknowledged)\n\t}\n\n\tindexExists, err := client.IndexExists(testIndexName).Do(context.TODO())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !indexExists {\n\t\tt.Fatalf(\"index %s should exist, but doesn't\\n\", testIndexName)\n\t}\n\n\tdeleteIndex, err := client.DeleteIndex(testIndexName).Do(context.TODO())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !deleteIndex.Acknowledged {\n\t\tt.Errorf(\"expected DeleteIndexResult.Acknowledged %v; got %v\", true, deleteIndex.Acknowledged)\n\t}\n\n\tindexExists, err = client.IndexExists(testIndexName).Do(context.TODO())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif indexExists {\n\t\tt.Fatalf(\"index %s should not exist, but does\\n\", testIndexName)\n\t}\n}\n\n\n\nfunc TestIndicesCreateValidate(t *testing.T) ", "output": "{\n\tclient := setupTestClient(t)\n\n\tres, err := NewIndicesCreateService(client).Body(testMapping).Do(context.TODO())\n\tif err == nil {\n\t\tt.Fatalf(\"expected IndicesCreate to fail without index name\")\n\t}\n\tif res != nil {\n\t\tt.Fatalf(\"expected result to be == nil; got: %v\", res)\n\t}\n}"}
{"input": "package accumulator\n\nimport \"strconv\"\n\ntype Int64 int64\n\n\n\n\n\nfunc (a *Int64) Accumulate64(i int64, err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t*a += Int64(i)\n}\n\nfunc (a *Int64) String() string {\n\treturn strconv.FormatInt(int64(*a), 10)\n}\n\nfunc (a *Int64) Accumulate(i int, err error) ", "output": "{\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t*a += Int64(i)\n}"}
{"input": "package plugin\n\nimport (\n\t\"github.com/mitchellh/packer/packer\"\n\t\"log\"\n)\n\ntype cmdHook struct {\n\thook   packer.Hook\n\tclient *Client\n}\n\n\n\nfunc (c *cmdHook) checkExit(p interface{}, cb func()) {\n\tif c.client.Exited() {\n\t\tcb()\n\t} else if p != nil {\n\t\tlog.Panic(p)\n\t}\n}\n\nfunc (c *cmdHook) Run(name string, ui packer.Ui, comm packer.Communicator, data interface{}) error ", "output": "{\n\tdefer func() {\n\t\tr := recover()\n\t\tc.checkExit(r, nil)\n\t}()\n\n\treturn c.hook.Run(name, ui, comm, data)\n}"}
{"input": "package wade\n\nimport (\n\t\"fmt\"\n\tgourl \"net/url\"\n\n\t\"github.com/gowade/vdom\"\n\t\"github.com/gowade/wade/dom\"\n\t\"github.com/gowade/wade/driver\"\n)\n\ntype M map[string]interface{}\n\ntype AppMode int\n\nconst (\n\tDevelopmentMode AppMode = iota\n\tProductionMode\n)\n\nvar (\n\tmode AppMode = DevelopmentMode\n)\n\ntype Component interface{}\n\nfunc ClientSide() bool {\n\treturn driver.Env() == driver.BrowserEnv\n}\n\nfunc DevMode() bool {\n\treturn mode == DevelopmentMode\n}\n\nfunc SetMode(appMode AppMode) {\n\tmode = appMode\n}\n\nfunc Str(value interface{}) string {\n\tif s, ok := value.(string); ok {\n\t\treturn s\n\t}\n\n\treturn fmt.Sprint(value)\n}\n\nfunc MergeMaps(m1, m2 map[string]interface{}) map[string]interface{} {\n\tif m1 == nil && m2 == nil {\n\t\treturn nil\n\t}\n\n\tm := make(map[string]interface{})\n\tif m1 != nil {\n\t\tfor k, v := range m1 {\n\t\t\tm[k] = v\n\t\t}\n\t}\n\n\tif m2 != nil {\n\t\tfor k, v := range m2 {\n\t\t\tm[k] = v\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc If(cond bool, v string) string {\n\tif cond {\n\t\treturn v\n\t}\n\n\treturn \"\"\n}\n\nfunc WrapEvt(handler func(dom.Event)) interface{} {\n\treturn dom.NewEventHandler(handler)\n}\n\nfunc QueryEscape(str string) string {\n\treturn gourl.QueryEscape(str)\n}\n\n\n\nfunc NewVNodeList(nodes ...interface{}) []vdom.VNode ", "output": "{\n\tvar l []vdom.VNode\n\tfor _, n := range nodes {\n\t\tif n == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch n := n.(type) {\n\t\tcase []vdom.VNode:\n\t\t\tl = append(l, n...)\n\t\tcase *vdom.VElement, vdom.VText:\n\t\t\tl = append(l, n.(vdom.VNode))\n\t\tdefault:\n\t\t\tpanic(\"Invalid node type\")\n\t\t}\n\t}\n\n\treturn l\n}"}
{"input": "package memory\n\nimport (\n\t\"fmt\"\n)\n\n\ntype RAM struct {\n\tdata       []byte\n\twindow     []byte\n\taddrOffset uint16\n}\n\n\n\n\n\n\nfunc (r *RAM) SetWindow(offset uint32) error {\n\n\tif uint32(len(r.data)) <= offset {\n\t\treturn fmt.Errorf(\"window offset out of range (%d)\", offset)\n\t}\n\n\tr.window = r.data[offset:]\n\n\treturn nil\n}\n\n\nfunc (r *RAM) Read(addr uint16) (byte, error) {\n\n\tif r.addrOffset > addr {\n\t\treturn 0, ReadOutOfRangeError(addr)\n\t}\n\n\tphysicalAddr := addr - r.addrOffset\n\n\tif uint(len(r.window)) <= uint(physicalAddr) {\n\t\treturn 0, ReadOutOfRangeError(addr)\n\t}\n\n\treturn r.window[physicalAddr], nil\n}\n\n\nfunc (r *RAM) Write(addr uint16, data byte) error {\n\n\tif r.addrOffset > addr {\n\t\treturn WriteOutOfRangeError(addr)\n\t}\n\n\tphysicalAddr := addr - r.addrOffset\n\n\tif uint(len(r.window)) <= uint(physicalAddr) {\n\t\treturn WriteOutOfRangeError(addr)\n\t}\n\n\tr.window[physicalAddr] = data\n\n\treturn nil\n}\n\nfunc NewRAM(data []byte, addrOffset uint16) *RAM ", "output": "{\n\n\tr := RAM{data: data, addrOffset: addrOffset}\n\tr.SetWindow(0)\n\n\treturn &r\n}"}
{"input": "package helpers\n\nimport (\n\t\"fmt\"\n\t\"gopkg.in/ini.v1\"\n\t\"runtime\"\n)\n\ntype Distro struct {\n\tFamily     string \n\tInitSystem string \n\tVersion    string \n}\n\n\n\n\n\nfunc (d *Distro) SetInitSystem() error {\n\n\tswitch d.Family {\n\tcase \"debian\":\n\t\td.InitSystem = \"systemd\" \n\tcase \"centos\":\n\t\td.InitSystem = \"sysv\"\n\tdefault:\n\t\treturn fmt.Errorf(\"Unknown Init system for distribution: %s\", d.Family)\n\t}\n\treturn nil\n}\n\n\n\nfunc GetDistro() (*Distro, error) {\n\td := Distro{}\n\tif runtime.GOOS == \"linux\" {\n\t\ti, err := ini.Load([]byte(\"\"), \"/etc/os-release\")\n\t\tsection, err := i.Section(\"\").GetKey(\"ID_LIKE\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\terr = d.SetFamily(section.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\terr = d.SetInitSystem()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn &d, nil\n}\n\nfunc (d *Distro) SetFamily(family string) error ", "output": "{\n\n\tswitch family {\n\tcase \"debian\":\n\t\td.Family = family\n\tcase \"centos\":\n\t\td.Family = family\n\tdefault:\n\t\treturn fmt.Errorf(\"Unknown Linux distribution: %s\", family)\n\t}\n\treturn nil\n}"}
{"input": "package util\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n\nfunc Example_noTrailingNewline() {\n\tld := NewLineDelimiter(os.Stdout, \"|\")\n\tdefer ld.Flush()\n\tfmt.Fprint(ld, \"  Hello  \\n  World  \")\n}\n\nfunc Example_trailingNewline() ", "output": "{\n\tld := NewLineDelimiter(os.Stdout, \"|\")\n\tdefer ld.Flush()\n\tfmt.Fprint(ld, \"  Hello  \\n  World  \\n\")\n}"}
{"input": "package main\n\nimport (\n\t\"go/build\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/posener/complete\"\n)\n\n\n\nfunc predictPackages(a complete.Args) (prediction []string) {\n\tprediction = []string{a.Last}\n\tlastPrediction := \"\"\n\tfor len(prediction) == 1 && (lastPrediction == \"\" || lastPrediction != prediction[0]) {\n\t\tlastPrediction = prediction[0]\n\t\ta.Last = prediction[0]\n\t\tprediction = predictLocalAndSystem(a)\n\t}\n\treturn\n}\n\nfunc predictLocalAndSystem(a complete.Args) []string {\n\tlocalDirs := complete.PredictFilesSet(listPackages(a.Directory())).Predict(a)\n\ts := systemDirs(a.Last)\n\tsysDirs := complete.PredictSet(s...).Predict(a)\n\treturn append(localDirs, sysDirs...)\n}\n\n\n\nfunc listPackages(dir string) (directories []string) {\n\tfiles, err := ioutil.ReadDir(dir)\n\tif err != nil {\n\t\tcomplete.Log(\"failed reading directory %s: %s\", dir, err)\n\t\treturn\n\t}\n\n\tpaths := make([]string, 0, len(files)+1)\n\tfor _, f := range files {\n\t\tif f.IsDir() {\n\t\t\tpaths = append(paths, filepath.Join(dir, f.Name()))\n\t\t}\n\t}\n\tpaths = append(paths, dir)\n\n\tfor _, p := range paths {\n\t\tpkg, err := build.ImportDir(p, 0)\n\t\tif err != nil {\n\t\t\tcomplete.Log(\"failed importing directory %s: %s\", p, err)\n\t\t\tcontinue\n\t\t}\n\t\tdirectories = append(directories, pkg.Dir)\n\t}\n\treturn\n}\n\n\n\nfunc systemDirs(dir string) (directories []string) ", "output": "{\n\tpaths := strings.Split(os.Getenv(\"GOPATH\"), \":\")\n\tfor i := range paths {\n\t\tpaths[i] = filepath.Join(paths[i], \"src\")\n\t}\n\n\tif !strings.HasSuffix(dir, \"/\") {\n\t\tdir = filepath.Dir(dir)\n\t}\n\n\tfor _, basePath := range paths {\n\t\tpath := filepath.Join(basePath, dir)\n\t\tfiles, err := ioutil.ReadDir(path)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tswitch dir {\n\t\tcase \"\", \".\", \"/\", \"./\":\n\t\tdefault:\n\t\t\tdirectories = append(directories, dir)\n\t\t}\n\t\tfor _, f := range files {\n\t\t\tif !f.IsDir() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdirectories = append(directories, filepath.Join(dir, f.Name())+\"/\")\n\t\t}\n\t}\n\treturn\n}"}
{"input": "package example\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n\n\nfunc bar() int {\n\treturn 4\n}\n\nfunc statementRemoveStructInitialization() (a http.Header, b error) {\n\tvar err error\n\n\ta, b = http.Header{}, err\n\n\treturn\n}\n\nfunc statementRemoveStringArrayMap() map[string][]string {\n\thash := \"ok\"\n\tvar hdr = make(map[string][]string)\n\n\thdr[\"Hash\"] = []string{hash}\n\n\treturn hdr\n}\n\nfunc foo() int ", "output": "{\n\tn := 1\n\n\tfor i := 0; i < 3; i++ {\n\t\tif i == 0 {\n\t\t\tn++\n\t\t} else if i == 1 {\n\t\t\tn += 2\n\t\t} else {\n\t\t\tn += 3\n\t\t}\n\n\t\tn++\n\t}\n\n\tif n < 0 {\n\t\tn = 0\n\t}\n\n\tn++\n\n\tn += bar()\n\n\tbar()\n\n\tswitch {\n\tcase n < 20:\n\t\tn++\n\tcase n > 20:\n\t\tn--\n\tdefault:\n\t\tn = 0\n\t\tfmt.Println(n)\n\t\tfunc() {}()\n\t}\n\n\tvar x = 0\n\tx++\n\n\treturn n\n}"}
{"input": "package like\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/smartystreets/goconvey/convey\"\n)\n\n\n\nfunc TestAddExtend(t *testing.T) ", "output": "{\n\tconvey.Convey(\"ipRequestKey\", t, func(ctx convey.C) {\n\t\tvar (\n\t\t\tc     = context.Background()\n\t\t\tquery = \"(2355,10)\"\n\t\t)\n\t\tctx.Convey(\"When everything goes positive\", func(ctx convey.C) {\n\t\t\tres, err := d.AddExtend(c, query)\n\t\t\tctx.Convey(\"Then err should be nil.likes should not be nil.\", func(ctx convey.C) {\n\t\t\t\tctx.So(err, convey.ShouldBeNil)\n\t\t\t\tfmt.Printf(\"%d\", res)\n\t\t\t})\n\t\t})\n\t})\n}"}
{"input": "package models\n\nimport (\n\t\"koding/db/mongodb/modelhelper\"\n\t\"net\"\n\t\"socialapi/config\"\n\t\"socialapi/request\"\n\n\t\"github.com/koding/logging\"\n)\n\n\ntype Client struct {\n\tAccount *Account\n\n\tIP net.IP\n\n\tSessionID string\n}\n\n\ntype Context struct {\n\tGroupName string\n\tClient    *Client\n\tlog       logging.Logger\n}\n\n\nfunc NewContext(log logging.Logger) *Context {\n\treturn &Context{\n\t\tlog: log,\n\t}\n}\n\n\nfunc (c *Context) OverrideQuery(q *request.Query) *request.Query {\n\tq.GroupName = c.GroupName\n\tif c.IsLoggedIn() {\n\t\tq.AccountId = c.Client.Account.Id\n\t} else {\n\t\tq.AccountId = 0\n\t}\n\n\treturn q\n}\n\n\nfunc (c *Context) IsLoggedIn() bool {\n\tif c.Client == nil {\n\t\treturn false\n\t}\n\n\tif c.Client.Account == nil {\n\t\treturn false\n\t}\n\n\tif c.Client.Account.Id == 0 {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n\n\n\n\n\n\n\n\nfunc (c *Context) CanManage() error {\n\tif !c.IsLoggedIn() {\n\t\treturn ErrNotLoggedIn\n\t}\n\n\tcanManage, err := modelhelper.CanManage(c.Client.Account.Nick, c.GroupName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !canManage {\n\t\treturn ErrCannotManageGroup\n\t}\n\n\treturn nil\n}\n\n\nfunc (c *Context) MustGetLogger() logging.Logger {\n\tif c.log == nil {\n\t\tpanic(ErrLoggerNotExist)\n\t}\n\n\treturn c.log\n}\n\nfunc (c *Context) IsAdmin() bool ", "output": "{\n\tif !c.IsLoggedIn() {\n\t\treturn false\n\t}\n\n\tsuperAdmins := config.MustGet().DummyAdmins\n\treturn IsIn(c.Client.Account.Nick, superAdmins...)\n}"}
{"input": "package heap\n\nimport \"jvmgo/ch07/classfile\"\n\ntype Field struct {\n\tClassMember\n\tconstValueIndex uint\n\tslotId          uint\n}\n\nfunc newFields(class *Class, cfFields []*classfile.MemberInfo) []*Field {\n\tfields := make([]*Field, len(cfFields))\n\tfor i, cfField := range cfFields {\n\t\tfields[i] = &Field{}\n\t\tfields[i].class = class\n\t\tfields[i].copyMemberInfo(cfField)\n\t\tfields[i].copyAttributes(cfField)\n\t}\n\treturn fields\n}\nfunc (self *Field) copyAttributes(cfField *classfile.MemberInfo) {\n\tif valAttr := cfField.ConstantValueAttribute(); valAttr != nil {\n\t\tself.constValueIndex = uint(valAttr.ConstantValueIndex())\n\t}\n}\n\nfunc (self *Field) IsVolatile() bool {\n\treturn 0 != self.accessFlags&ACC_VOLATILE\n}\nfunc (self *Field) IsTransient() bool {\n\treturn 0 != self.accessFlags&ACC_TRANSIENT\n}\n\n\nfunc (self *Field) ConstValueIndex() uint {\n\treturn self.constValueIndex\n}\nfunc (self *Field) SlotId() uint {\n\treturn self.slotId\n}\nfunc (self *Field) isLongOrDouble() bool {\n\treturn self.descriptor == \"J\" || self.descriptor == \"D\"\n}\n\nfunc (self *Field) IsEnum() bool ", "output": "{\n\treturn 0 != self.accessFlags&ACC_ENUM\n}"}
{"input": "package common\n\nimport (\n\t\"strconv\"\n\t\"time\"\n)\n\ntype ConversionResult struct {\n\tDateAsString string\n\tDateAsInt    int\n\tDate         time.Time\n}\n\n\n\nfunc ConvertStringToDates(dateAsString string) (ConversionResult, error) {\n\tresult := ConversionResult{}\n\tresult.DateAsString = dateAsString\n\n\tdateAsInt, err := strconv.Atoi(dateAsString)\n\tif err != nil {\n\t\treturn result, nil\n\t}\n\tresult.DateAsInt = dateAsInt\n\n\tdate, err := time.Parse(\"20060102\", dateAsString)\n\tif err != nil {\n\t\treturn result, nil\n\t}\n\tresult.Date = date\n\n\treturn result, nil\n}\n\nfunc (d *ConversionResult) Tomorrow() (ConversionResult, error) {\n\treturn ConvertStringToDates(d.Date.AddDate(0, 0, 1).Format(\"20060102\"))\n}\n\nfunc (d *ConversionResult) Yesterday() (ConversionResult, error) {\n\treturn ConvertStringToDates(d.Date.AddDate(0, 0, -1).Format(\"20060102\"))\n}\n\nfunc ConvertIntToDisplay(dateAsInt int) string ", "output": "{\n\tdayAsString := strconv.Itoa(dateAsInt)\n\n\treturn dayAsString\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/PuerkitoBio/goquery\"\n)\n\n\ntype Scraper struct {\n\tf Fetcher\n}\n\n\n\n\n\nfunc (s *Scraper) Scrape(log AppLogger, exts Extractors) (int64, Items, error) {\n\tvar items Items\n\n\tresp := s.f.Fetch(log)\n\tif resp.Error() != nil {\n\t\treturn 0, nil, resp.Error()\n\t}\n\tr := resp.ReadCloser()\n\tdefer r.Close()\n\n\tdoc, err := goquery.NewDocumentFromReader(r)\n\tif err != nil {\n\t\tlog.Error(fmt.Sprintf(\"%v\", err))\n\t\treturn 0, nil, err\n\t}\n\n\tfor name, ext := range exts {\n\t\tlog.Debug(fmt.Sprintf(\"extract `%s` from `%s`\", name, s.f.URL()))\n\t\titems = append(items, ext.Extract(doc.Selection)...)\n\t}\n\n\treturn resp.Length(), items, nil\n}\n\nfunc NewScraper(f Fetcher) *Scraper ", "output": "{\n\treturn &Scraper{\n\t\tf: f,\n\t}\n}"}
{"input": "package cache\n\nimport (\n\t\"math\"\n\t\"reflect\"\n)\n\n\n\nconst (\n\tMB = 1024 * 1024\n\n\tPtrSize = 4 << (^uintptr(0) >> 63) \n\tIntSize = 4 << (^uint(0) >> 63)\n\n\thmapStructSize = IntSize + \n\t\t1 + 1 + 2 + 4 + \n\t\tPtrSize*3 + \n\t\tPtrSize + 2*PtrSize \n\n\tbucketSizeWithoutIndirectPointerOverhead = 1 << 3 \n\n\tmapLoadFactor = 6.5\n)\n\nfunc mapKeyOrValueSizeWithIndirectPointerOverhead(rawSize int) int {\n\tif rawSize > 128 {\n\t\treturn rawSize + PtrSize\n\t}\n\treturn rawSize\n}\n\n\n\n\n\n\nfunc StaticSizeOfMap(\n\tzeroValueKey, zeroValueValue interface{}, count int) (bytes int) {\n\treturn StaticSizeOfMapWithSize(int(reflect.TypeOf(zeroValueKey).Size()),\n\t\tint(reflect.TypeOf(zeroValueValue).Size()), count)\n}\n\n\n\n\n\n\nfunc StaticSizeOfMapWithSize(\n\tkeyStaticSize, valueStaticSize int, count int) (bytes int) ", "output": "{\n\tkeySize := mapKeyOrValueSizeWithIndirectPointerOverhead(keyStaticSize)\n\tvalueSize := mapKeyOrValueSizeWithIndirectPointerOverhead(valueStaticSize)\n\n\tB := math.Ceil(math.Log2(float64(count) / mapLoadFactor))\n\tnumBuckets := int(math.Exp2(B))\n\n\treturn hmapStructSize +\n\t\tbucketSizeWithoutIndirectPointerOverhead*numBuckets +\n\t\t(keySize+valueSize)*count\n}"}
{"input": "package libnetwork\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nfunc (c *controller) cleanupServiceBindings(nid string) {\n}\n\n\n\nfunc (c *controller) rmServiceBinding(name, sid, nid, eid string, vip net.IP, ingressPorts []*PortConfig, aliases []string, ip net.IP) error {\n\treturn fmt.Errorf(\"not supported\")\n}\n\nfunc (sb *sandbox) populateLoadbalancers(ep *endpoint) {\n}\n\nfunc arrangeIngressFilterRule() {\n}\n\nfunc (c *controller) addServiceBinding(name, sid, nid, eid string, vip net.IP, ingressPorts []*PortConfig, aliases []string, ip net.IP) error ", "output": "{\n\treturn fmt.Errorf(\"not supported\")\n}"}
{"input": "package funcs\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestFuncs(t *testing.T) ", "output": "{\n\tUrlfilter(\"hi\")\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\n\t\"github.com/afg984/thegame/server/go/thegame/pb\"\n)\n\ntype Bullet struct {\n\tEntity\n\towner   *Hero\n\ttimeout int\n\tid      int\n}\n\nfunc (b *Bullet) ToProto() *pb.Bullet {\n\treturn &pb.Bullet{\n\t\tEntity: EntityToProto(b),\n\t\tOwner:  int32(b.owner.id),\n\t}\n}\n\nfunc (b *Bullet) String() string {\n\treturn fmt.Sprintf(\"Bullet#%d:%s\", b.id, b.owner)\n}\n\nfunc (b *Bullet) ID() int {\n\treturn b.id\n}\n\nfunc (b *Bullet) MaxHealth() int {\n\treturn b.owner.ability(BulletPenetration)\n}\n\nfunc (b *Bullet) Friction() float64 {\n\treturn 0.02\n}\n\nfunc (b *Bullet) IsBounded() bool {\n\treturn false\n}\n\nfunc (b *Bullet) MaxSpeed() float64 {\n\treturn math.Inf(1)\n}\n\nfunc (b *Bullet) Radius() float64 {\n\treturn 10\n}\n\nfunc (b *Bullet) Team() int {\n\treturn b.owner.Team()\n}\n\nfunc (b *Bullet) BodyDamage() int {\n\treturn b.owner.ability(BulletDamage)\n}\n\nfunc (b *Bullet) CanAcquireExperience() bool {\n\treturn true\n}\n\nfunc (b *Bullet) AcquireExperience(e int) {\n\tb.owner.AcquireExperience(e)\n}\n\n\n\nfunc experienceToLevelUp(level int) int {\n\treturn int(10 * math.Pow(1.2, float64(level)))\n}\n\nfunc (b *Bullet) RewardingExperience() int ", "output": "{\n\treturn 0\n}"}
{"input": "package archive\n\nimport (\n\t\"os\"\n\n\t\"github.com/docker/docker/pkg/system\"\n)\n\nfunc statDifferent(oldStat *system.StatT, newStat *system.StatT) bool {\n\n\tif oldStat.Mtim() != newStat.Mtim() ||\n\t\toldStat.Mode() != newStat.Mode() ||\n\t\toldStat.Size() != newStat.Size() && !oldStat.Mode().IsDir() {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n\nfunc getIno(fi os.FileInfo) (inode uint64) {\n\treturn\n}\n\nfunc hasHardlinks(fi os.FileInfo) bool {\n\treturn false\n}\n\nfunc (info *FileInfo) isDir() bool ", "output": "{\n\treturn info.parent == nil || info.stat.Mode().IsDir()\n}"}
{"input": "package data\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"testing\"\n)\n\n\n\nfunc TestMsg(t *testing.T) {\n\tmsg := new(Message)\n\tjson.Unmarshal([]byte(`{\n\t\"msg_type\": \"msg_type\",\n\t\"msg\": \"msg\",\n\t\"from_user_id\": \"from_user_id\",\n\t\"to_user_id\": \"to_user_id\",\n\t\"from_conn_id\": \"from_conn_id\",\n\t\"to_conn_id\": \"to_conn_id\"\n}`), msg)\n\tt.Log(msg)\n}\n\nfunc TestBytesInt32Convert(t *testing.T) ", "output": "{\n\tvar i32 int32\n\ti32 = 11\n\tt.Log(i32)\n\tbs := Int32ToBytes(i32)\n\tt.Log(bs)\n\tt.Log(len(bs))\n\tt.Log(cap(bs))\n\tbuff := bytes.NewBuffer(bs)\n\tt.Log(buff.Bytes())\n\tinew := BytesToInt32(bs)\n\tt.Log(inew)\n\tif i32 == inew {\n\t\tt.Log(i32 == inew)\n\t} else {\n\t\tt.Fail()\n\t}\n}"}
{"input": "package mayday\n\nimport (\n\t\"github.com/coreos/mayday/mayday/tar\"\n\t\"github.com/coreos/mayday/mayday/tarable\"\n)\n\n\n\nfunc Run(t tar.Tar, tarables []tarable.Tarable) error ", "output": "{\n\n\tfor _, tb := range tarables {\n\t\tt.Add(tb)\n\t\tt.MaybeMakeLink(tb.Link(), tb.Name())\n\t}\n\n\treturn nil\n}"}
{"input": "package core\n\nimport (\n\t\"fmt\"\n)\n\ntype pluginRegistry struct {\n\tplugins map[string]Plugin\n}\n\n\nvar PluginRegistry = pluginRegistry{\n\tplugins: make(map[string]Plugin),\n}\n\n\n\n\nfunc (registry *pluginRegistry) Register(plugin Plugin, ID string) string {\n\tcollision := 1\n\tpluginID := ID\n\tfor {\n\t\tif _, exists := registry.plugins[pluginID]; !exists {\n\t\t\tregistry.plugins[pluginID] = plugin\n\t\t\treturn pluginID \n\t\t}\n\t\tpluginID = fmt.Sprintf(\"%s%d\", ID, collision)\n\t\tcollision++\n\t}\n}\n\n\n\nfunc (registry *pluginRegistry) RegisterUnique(plugin Plugin, ID string) {\n\tif _, exists := registry.plugins[ID]; !exists {\n\t\tregistry.plugins[ID] = plugin\n\t}\n}\n\n\n\n\n\nfunc (registry *pluginRegistry) GetPluginWithState(ID string) PluginWithState {\n\tplugin := registry.GetPlugin(ID)\n\tpluginWithState, hasState := plugin.(PluginWithState)\n\tif !hasState {\n\t\tpluginWithState = nil\n\t}\n\treturn pluginWithState\n}\n\nfunc (registry *pluginRegistry) GetPlugin(ID string) Plugin ", "output": "{\n\tplugin, exists := registry.plugins[ID]\n\tif !exists {\n\t\tplugin = nil\n\t}\n\treturn plugin\n}"}
{"input": "package identifier\n\n\n\n\n\nimport (\n\t\"github.com/tideland/golib/errors\"\n)\n\n\n\n\n\nconst (\n\tErrInvalidHexLength = iota + 1\n\tErrInvalidHexValue\n)\n\nvar errorMessages = errors.Messages{\n\tErrInvalidHexLength: \"invalid length of hex string, has to be 32\",\n\tErrInvalidHexValue:  \"invalid value of hex string\",\n}\n\n\n\n\n\n\n\nfunc IsInvalidHexLengthError(err error) bool {\n\treturn errors.IsError(err, ErrInvalidHexLength)\n}\n\n\n\n\n\nfunc IsInvalidHexValueError(err error) bool ", "output": "{\n\treturn errors.IsError(err, ErrInvalidHexValue)\n}"}
{"input": "package exec\n\nimport (\n\t\"io\";\n\t\"testing\";\n)\n\nfunc TestRunCat(t *testing.T) {\n\tcmd, err := Run(\"/bin/cat\", []string{\"cat\"}, nil,\n\t\tPipe, Pipe, DevNull);\n\tif err != nil {\n\t\tt.Fatalf(\"opencmd /bin/cat: %v\", err)\n\t}\n\tio.WriteString(cmd.Stdin, \"hello, world\\n\");\n\tcmd.Stdin.Close();\n\tbuf, err := io.ReadAll(cmd.Stdout);\n\tif err != nil {\n\t\tt.Fatalf(\"reading from /bin/cat: %v\", err)\n\t}\n\tif string(buf) != \"hello, world\\n\" {\n\t\tt.Fatalf(\"reading from /bin/cat: got %q\", buf)\n\t}\n\tif err = cmd.Close(); err != nil {\n\t\tt.Fatalf(\"closing /bin/cat: %v\", err)\n\t}\n}\n\n\n\nfunc TestRunEcho(t *testing.T) ", "output": "{\n\tcmd, err := Run(\"/bin/echo\", []string{\"echo\", \"hello\", \"world\"}, nil,\n\t\tDevNull, Pipe, DevNull);\n\tif err != nil {\n\t\tt.Fatalf(\"opencmd /bin/echo: %v\", err)\n\t}\n\tbuf, err := io.ReadAll(cmd.Stdout);\n\tif err != nil {\n\t\tt.Fatalf(\"reading from /bin/echo: %v\", err)\n\t}\n\tif string(buf) != \"hello world\\n\" {\n\t\tt.Fatalf(\"reading from /bin/echo: got %q\", buf)\n\t}\n\tif err = cmd.Close(); err != nil {\n\t\tt.Fatalf(\"closing /bin/echo: %v\", err)\n\t}\n}"}
{"input": "package dataintegration\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype DerivedType struct {\n\n\tKey *string `mandatory:\"false\" json:\"key\"`\n\n\tModelVersion *string `mandatory:\"false\" json:\"modelVersion\"`\n\n\tParentRef *ParentReference `mandatory:\"false\" json:\"parentRef\"`\n\n\tName *string `mandatory:\"false\" json:\"name\"`\n\n\tObjectStatus *int `mandatory:\"false\" json:\"objectStatus\"`\n\n\tDescription *string `mandatory:\"false\" json:\"description\"`\n}\n\n\nfunc (m DerivedType) GetKey() *string {\n\treturn m.Key\n}\n\n\nfunc (m DerivedType) GetModelVersion() *string {\n\treturn m.ModelVersion\n}\n\n\nfunc (m DerivedType) GetParentRef() *ParentReference {\n\treturn m.ParentRef\n}\n\n\nfunc (m DerivedType) GetName() *string {\n\treturn m.Name\n}\n\n\nfunc (m DerivedType) GetObjectStatus() *int {\n\treturn m.ObjectStatus\n}\n\n\nfunc (m DerivedType) GetDescription() *string {\n\treturn m.Description\n}\n\n\n\n\nfunc (m DerivedType) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeDerivedType DerivedType\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"modelType\"`\n\t\tMarshalTypeDerivedType\n\t}{\n\t\t\"DERIVED_TYPE\",\n\t\t(MarshalTypeDerivedType)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\n\nfunc (m DerivedType) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package flatjson\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n)\n\ntype Map map[string]interface{}\n\n\nfunc Flatten(val interface{}) Map {\n\trval := reflect.ValueOf(val)\n\trval = extractStruct(rval, rval)\n\n\tif rval.Kind() != reflect.Struct {\n\t\tpanic(\"Flatten: must be called with a struct type\")\n\t}\n\n\tm := Map{}\n\trecursiveFlatten(rval, \"\", m)\n\treturn m\n}\n\nfunc keyForField(field reflect.StructField, v reflect.Value) (string, bool) {\n\tif tag := field.Tag.Get(\"json\"); tag != \"\" {\n\t\ttokens := strings.SplitN(tag, \",\", 2)\n\t\tname := tokens[0]\n\t\topts := \"\"\n\n\t\tif len(tokens) > 1 {\n\t\t\topts = tokens[1]\n\t\t}\n\n\t\tif name == \"-\" || strings.Contains(opts, \"omitempty\") && isEmptyValue(v) {\n\t\t\treturn \"\", false\n\t\t} else if name != \"\" {\n\t\t\treturn name, false\n\t\t}\n\t}\n\n\tif field.Anonymous {\n\t\treturn \"\", true\n\t}\n\treturn field.Name, false\n}\n\nfunc extractStruct(val, fallback reflect.Value) reflect.Value {\n\tswitch val.Kind() {\n\tcase reflect.Struct:\n\t\treturn val\n\tcase reflect.Ptr:\n\t\treturn extractStruct(val.Elem(), fallback)\n\tcase reflect.Interface:\n\t\treturn extractStruct(val.Elem(), fallback)\n\tdefault:\n\t\treturn fallback\n\t}\n}\n\n\n\nfunc isEmptyValue(v reflect.Value) bool {\n\treturn v.Interface() == reflect.Zero(v.Type()).Interface()\n}\n\nfunc recursiveFlatten(val reflect.Value, prefix string, output Map) int ", "output": "{\n\tvalType := val.Type()\n\tadded := 0\n\n\tfor i := 0; i < val.NumField(); i++ {\n\t\tchild := val.Field(i)\n\t\tchildType := valType.Field(i)\n\t\tchildPrefix := prefix\n\n\t\tkey, anonymous := keyForField(childType, child)\n\n\t\tif childType.PkgPath != \"\" || (key == \"\" && !anonymous) {\n\t\t\tcontinue\n\t\t} else if !anonymous {\n\t\t\tchildPrefix = prefix + key + \".\"\n\t\t}\n\n\t\tchild = extractStruct(child, child)\n\n\t\tif child.Kind() == reflect.Struct {\n\t\t\tchildAdded := recursiveFlatten(child, childPrefix, output)\n\t\t\tif childAdded != 0 {\n\t\t\t\tadded += childAdded\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\toutput[prefix+key] = child.Addr().Interface()\n\t\tadded++\n\t}\n\n\treturn added\n}"}
{"input": "package camelsource\n\nimport (\n\tfmt \"fmt\"\n\n\ttypes \"k8s.io/apimachinery/pkg/types\"\n\tcache \"k8s.io/client-go/tools/cache\"\n\tv1alpha1 \"knative.dev/eventing-camel/pkg/apis/sources/v1alpha1\"\n\treconciler \"knative.dev/pkg/reconciler\"\n)\n\n\ntype state struct {\n\tkey string\n\tnamespace string\n\tname string\n\treconciler Interface\n\troi ReadOnlyInterface\n\tisROI bool\n\trof ReadOnlyFinalizer\n\tisROF bool\n\tisLeader bool\n}\n\nfunc newState(key string, r *reconcilerImpl) (*state, error) {\n\tnamespace, name, err := cache.SplitMetaNamespaceKey(key)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid resource key: %s\", key)\n\t}\n\n\troi, isROI := r.reconciler.(ReadOnlyInterface)\n\trof, isROF := r.reconciler.(ReadOnlyFinalizer)\n\n\tisLeader := r.IsLeaderFor(types.NamespacedName{\n\t\tNamespace: namespace,\n\t\tName:      name,\n\t})\n\n\treturn &state{\n\t\tkey:        key,\n\t\tnamespace:  namespace,\n\t\tname:       name,\n\t\treconciler: r.reconciler,\n\t\troi:        roi,\n\t\tisROI:      isROI,\n\t\trof:        rof,\n\t\tisROF:      isROF,\n\t\tisLeader:   isLeader,\n\t}, nil\n}\n\n\n\n\n\nfunc (s *state) isNotLeaderNorObserver() bool {\n\tif !s.isLeader && !s.isROI && !s.isROF {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n\nfunc (s *state) reconcileMethodFor(o *v1alpha1.CamelSource) (string, doReconcile) ", "output": "{\n\tif o.GetDeletionTimestamp().IsZero() {\n\t\tif s.isLeader {\n\t\t\treturn reconciler.DoReconcileKind, s.reconciler.ReconcileKind\n\t\t} else if s.isROI {\n\t\t\treturn reconciler.DoObserveKind, s.roi.ObserveKind\n\t\t}\n\t} else if fin, ok := s.reconciler.(Finalizer); s.isLeader && ok {\n\t\treturn reconciler.DoFinalizeKind, fin.FinalizeKind\n\t} else if !s.isLeader && s.isROF {\n\t\treturn reconciler.DoObserveFinalizeKind, s.rof.ObserveFinalizeKind\n\t}\n\treturn \"unknown\", nil\n}"}
{"input": "package concurrent\n\nimport (\n\t\"context\"\n)\n\n\n\nfunc (w *workflowRuntime) executeFlow(jobId int64) {\n\tw.mutex.Lock()\n\tjob := w.tasks[jobId]\n\tw.mutex.Unlock()\n\n\tif len(job.dependentIds) > 0 {\n\t\tw.executeDependentFlow(jobId, job)\n\t\treturn\n\t}\n\n\tw.executionSlots <- struct{}{}\n\tresult := w.handlers[job.funcname](job.args, w, nil)\n\tw.setResult(jobId, result)\n\t<-w.executionSlots\n}\n\nfunc (w *workflowRuntime) executeDependentFlow(jobId int64, job *flowTask) {\n\tgo func() {\n\t\tvar results []interface{}\n\t\tfor _, dependentId := range job.dependentIds {\n\t\t\tresults = append(results, w.getResult(dependentId.(int64)))\n\t\t}\n\n\t\tw.executionSlots <- struct{}{}\n\t\tresult := w.handlers[job.funcname](job.args, w, results)\n\t\tw.setResult(jobId, result)\n\t\t<-w.executionSlots\n\t}()\n}\n\nfunc (w *workflowRuntime) spawnWorker(ctx context.Context) ", "output": "{\n\tgo func() {\n\t\tvar job int64\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-w.idQueue.GetTaskChan():\n\t\t\t\tjob = w.idQueue.GetTask()\n\t\t\t\tw.executeFlow(job)\n\t\t\t}\n\t\t}\n\t}()\n}"}
{"input": "package geth\n\nimport (\n\t\"errors\"\n\t\"math/big\"\n)\n\n\ntype BigInt struct {\n\tbigint *big.Int\n}\n\n\nfunc NewBigInt(x int64) *BigInt {\n\treturn &BigInt{big.NewInt(x)}\n}\n\n\nfunc (bi *BigInt) GetBytes() []byte {\n\treturn bi.bigint.Bytes()\n}\n\n\nfunc (bi *BigInt) String() string {\n\treturn bi.bigint.String()\n}\n\n\n\nfunc (bi *BigInt) GetInt64() int64 {\n\treturn bi.bigint.Int64()\n}\n\n\n\nfunc (bi *BigInt) SetBytes(buf []byte) {\n\tbi.bigint.SetBytes(buf)\n}\n\n\nfunc (bi *BigInt) SetInt64(x int64) {\n\tbi.bigint.SetInt64(x)\n}\n\n\n\n\n\n\nfunc (bi *BigInt) SetString(x string, base int) {\n\tbi.bigint.SetString(x, base)\n}\n\n\ntype BigInts struct{ bigints []*big.Int }\n\n\n\n\n\nfunc (bi *BigInts) Get(index int) (bigint *BigInt, _ error) {\n\tif index < 0 || index >= len(bi.bigints) {\n\t\treturn nil, errors.New(\"index out of bounds\")\n\t}\n\treturn &BigInt{bi.bigints[index]}, nil\n}\n\n\nfunc (bi *BigInts) Set(index int, bigint *BigInt) error {\n\tif index < 0 || index >= len(bi.bigints) {\n\t\treturn errors.New(\"index out of bounds\")\n\t}\n\tbi.bigints[index] = bigint.bigint\n\treturn nil\n}\n\nfunc (bi *BigInts) Size() int ", "output": "{\n\treturn len(bi.bigints)\n}"}
{"input": "package keybindings\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/atotto/clipboard\"\n\t\"github.com/dambrisco/bored/layout\"\n\t\"github.com/dambrisco/bored/reddit\"\n\t\"github.com/jroimartin/gocui\"\n\t\"github.com/toqueteos/webbrowser\"\n)\n\nfunc enter(g *gocui.Gui, v *gocui.View) error {\n\tsubmission := reddit.GetCurrentSubmission()\n\twebbrowser.Open(\"https://www.reddit.com/\" + submission.Permalink)\n\treturn nil\n}\n\nfunc link(g *gocui.Gui, v *gocui.View) error {\n\tsubmission := reddit.GetCurrentSubmission()\n\twebbrowser.Open(submission.URL)\n\treturn nil\n}\n\n\n\nfunc comments(g *gocui.Gui, v *gocui.View) error {\n\tlayout.SetPage(layout.Comments)\n\tlayout.Clear(g, v)\n\treturn nil\n}\n\nfunc info(g *gocui.Gui, v *gocui.View) error {\n\tif layout.GetPage() == layout.List {\n\t\ts := reddit.GetCurrentSubmission()\n\t\tb := v.Buffer()\n\t\tv.Clear()\n\t\tif strings.HasPrefix(b, \"S\") {\n\t\t\tfmt.Fprint(v, layout.BuildTitleTag(s))\n\t\t} else {\n\t\t\tfmt.Fprintf(v, \"Score: %d | Subreddit: %s\", s.Score, s.Subreddit)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc yank(g *gocui.Gui, v *gocui.View) error ", "output": "{\n\tsubmission := reddit.GetCurrentSubmission()\n\tclipboard.WriteAll(submission.URL)\n\treturn nil\n}"}
{"input": "package context\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\n\t\"github.com/yosssi/goat/config\"\n\t\"gopkg.in/yaml.v2\"\n)\n\n\ntype Config struct {\n\tInitTasks []*Task    `json:\"init_tasks\" yaml:\"init_tasks\"`\n\tWatchers  []*Watcher `json:\"watchers\" yaml:\"watchers\"`\n}\n\n\n\n\nfunc NewConfig() (*Config, error) ", "output": "{\n\tbytes, err := ioutil.ReadFile(config.JSONConfigFile)\n\tif err != nil {\n\t\tbytes, err = ioutil.ReadFile(config.YAMLConfigFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tconfig := &Config{}\n\t\tif err := yaml.Unmarshal(bytes, config); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn config, nil\n\t}\n\n\tconfig := &Config{}\n\tif err := json.Unmarshal(bytes, config); err != nil {\n\t\treturn nil, err\n\t}\n\treturn config, nil\n}"}
{"input": "package conway\n\nimport (\n\t\"fmt\"\n)\n\nfunc Example_singleCell() {\n\tvar p = Population{cells: map[Cell]int{\n\t\tCell{0, 0}: 0,\n\t},\n\t\tpopNumber: 0,\n\t}\n\tp.Next()\n\tfmt.Println(p)\n}\n\nfunc Example_twoCells() {\n\tvar p = Population{cells: map[Cell]int{\n\t\tCell{0, 0}: 0,\n\t\tCell{0, 1}: 0,\n\t},\n\t\tpopNumber: 0,\n\t}\n\tp.Next()\n\tfmt.Println(p)\n}\n\n\n\nfunc Example_blinker() ", "output": "{\n\tvar p = Population{cells: map[Cell]int{\n\t\tCell{0, 0}:  0,\n\t\tCell{0, 1}:  0,\n\t\tCell{0, -1}: 0,\n\t},\n\t\tpopNumber: 0,\n\t}\n\tp.SaveToFile(\"blinker0.log\")\n\tp.Next()\n\tp.SaveToFile(\"blinker1.log\")\n\tfmt.Println(len(p.cells))\n}"}
{"input": "package diag\n\nimport \"fmt\"\n\n\n\n\n\n\n\n\nfunc FromErr(err error) Diagnostics {\n\tif err == nil {\n\t\treturn nil\n\t}\n\treturn Diagnostics{\n\t\tDiagnostic{\n\t\t\tSeverity: Error,\n\t\t\tSummary:  err.Error(),\n\t\t},\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc Errorf(format string, a ...interface{}) Diagnostics ", "output": "{\n\treturn Diagnostics{\n\t\tDiagnostic{\n\t\t\tSeverity: Error,\n\t\t\tSummary:  fmt.Sprintf(format, a...),\n\t\t},\n\t}\n}"}
{"input": "package contextutil_test\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/arjantop/cuirass/util/contextutil\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"golang.org/x/net/context\"\n)\n\nfunc TestDoErrorReturned(t *testing.T) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\terr := contextutil.Do(ctx, func() error {\n\t\treturn errors.New(\"foo\")\n\t})\n\tassert.Equal(t, errors.New(\"foo\"), err)\n}\n\nfunc TestDoWithCancelErrorReturned(t *testing.T) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\terr := contextutil.DoWithCancel(ctx, func() {}, func() error {\n\t\treturn errors.New(\"foo\")\n\t})\n\tassert.Equal(t, errors.New(\"foo\"), err)\n}\n\n\n\nfunc TestDoWithCancelTimeout(t *testing.T) ", "output": "{\n\tctx, cancel := context.WithTimeout(context.Background(), time.Nanosecond)\n\tdefer cancel()\n\tvar called bool\n\terr := contextutil.DoWithCancel(ctx, func() { called = true }, func() error {\n\t\ttime.Sleep(2 * time.Nanosecond)\n\t\treturn nil\n\t})\n\tassert.Equal(t, context.DeadlineExceeded, err)\n}"}
{"input": "package smtp\n\nimport (\n\t\"bufio\"\n\t\"crypto/tls\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/glynnbailey/gomail/database\"\n)\n\n\n\n\nfunc Listen(config map[string]string, db *database.Database, tlsConfig *tls.Config) ", "output": "{\n\n\tln, err := net.Listen(\"tcp\", \":\"+config[\"SMTP_LISTEN_PORT\"])\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tlog.Println(\"gomail-smtp started successfully, listening on port \" + config[\"SMTP_LISTEN_PORT\"])\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\n\t\tclient := &client{\n\t\t\tConn:   conn,\n\t\t\tAddr:   conn.RemoteAddr().String(),\n\t\t\tTime:   time.Now().Unix(),\n\t\t\tAuth:   false,\n\t\t\tReader: bufio.NewReader(conn),\n\t\t\tWriter: bufio.NewWriter(conn),\n\t\t}\n\n\t\tgo handleSMTPclient(client, config, db, tlsConfig)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/antizealot1337/multihost\"\n)\n\nfunc main() {\n\tfilename := flag.String(\"file\", \"\",\n\t\t\"The file name that contains the routes.\")\n\n\tcheckDir := flag.Bool(\"check\", false, \"Will check the path\")\n\n\tflag.Parse()\n\n\tif *filename == \"\" {\n\t\tfmt.Println(\"Expected filename.\")\n\t\tflag.PrintDefaults()\n\t\tos.Exit(-1)\n\t} \n\n\tfile, err := os.Open(*filename)\n\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\tos.Exit(-1)\n\t} \n\n\thostWidth, pathWidth := 20, 20\n\n\troutes := multihost.ReadRoutes(file)\n\n\tif err := file.Close(); err != nil {\n\t\tfmt.Println(err.Error())\n\t\tos.Exit(-1)\n\t} \n\n\tfor host, path := range routes {\n\t\tif hostLen := len(host); hostLen > hostWidth {\n\t\t\thostWidth = hostLen + 2\n\t\t} \n\n\t\tif pathLen := len(path); pathLen > pathWidth {\n\t\t\tpathWidth = pathLen + 2\n\t\t} \n\t} \n\n\tfmtStr := fmt.Sprintf(\"%%-%ds %%-%ds\", hostWidth, pathWidth)\n\n\tfmt.Printf(fmtStr, \"Host\", \"Path\")\n\n\tfmt.Println()\n\n\tfor host, path := range routes {\n\t\tfmt.Printf(fmtStr, host, path)\n\n\t\tif *checkDir {\n\t\t\tfmt.Printf(\" (%s)\", checkStatus(path))\n\t\t} \n\n\t\tfmt.Println()\n\t} \n} \n\n\n\nfunc checkStatus(path string) string ", "output": "{\n\tif info, err := os.Stat(path); err != nil {\n\t\treturn \"Does not exist\"\n\t} else if !info.IsDir() {\n\t\treturn \"Not a directory\"\n\t} \n\treturn \"OK\"\n}"}
{"input": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\n\n\nfunc TestLogParser(t *testing.T) ", "output": "{\n\tfields := []string{\"\", \"\", \"size\", \"\", \"\", \"duration\", \"method\", \"url\", \"\", \"\", \"mime_type\", \"agent\"}\n\tp := NewLogParser(strings.NewReader(ssvLog), NewSSVLexer(fields))\n\n\tch, err := p.Get()\n\tif err != nil {\n\t\tt.Fatalf(\"%v\\n\", err)\n\t}\n\n\tfor r := range ch {\n\t\tif r.Err() != nil {\n\t\t\tt.Errorf(\"%v\", r.Err())\n\t\t}\n\t}\n}"}
{"input": "package sorting\n\nimport (\n\t. \"gopkg.in/check.v1\"\n)\n\nvar _ = Suite(&MySuite{})\n\nfunc (s *MySuite) TestNumberOfDiscIntersections(c *C) {\n\tc.Assert(NumberOfDiscIntersections([]int{1, 5, 2, 1, 4, 0}), Equals, 11)\n}\n\n\n\nfunc (s *MySuite) BenchmarkNumberOfDiscIntersections(c *C) ", "output": "{\n\tfor i := 0; i < c.N; i++ {\n\t\tNumberOfDiscIntersections([]int{1, 5, 2, 1, 4, 0})\n\t}\n}"}
{"input": "package ble\n\n\n\nimport \"C\"\n\nimport (\n  \"os\"\n  \"unsafe\"\n)\n\ntype ConnInfo struct {\n  HCIHandle uint16\n  DevClass  [3]uint8\n}\n\n\n\nfunc GetConnInfo(fd *os.File) *ConnInfo ", "output": "{\n  ci := make([]byte, 5)\n  socklen := C.socklen_t(5)\n\n  C.getsockopt(C.int(fd.Fd()), C.int(SOL_L2CAP), C.int(L2CAP_CONNINFO),\n    unsafe.Pointer(&ci[0]), &socklen);\n\n  var result ConnInfo\n  result.HCIHandle = uint16(ci[0]) + uint16(ci[1]) << 8\n  for i := 0; i < 3; i++ {\n    result.DevClass[i] = ci[i + 2]\n  }\n  return &result\n}"}
{"input": "package net\n\nimport (\n\t\"os\";\n\t\"syscall\";\n)\n\ntype pollster struct{}\n\nfunc newpollster() (p *pollster, err os.Error) {\n\treturn nil, os.NewSyscallError(\"networking\", syscall.ENACL);\n}\n\n\n\nfunc (p *pollster) StopWaiting(fd int, bits uint) {\n}\n\nfunc (p *pollster) DelFD(fd int, mode int) {\n}\n\nfunc (p *pollster) WaitFD(nsec int64) (fd int, mode int, err os.Error) {\n\t_, err = newpollster();\n\treturn;\n}\n\nfunc (p *pollster) Close() os.Error {\n\treturn nil;\n}\n\nfunc (p *pollster) AddFD(fd int, mode int, repeat bool) os.Error ", "output": "{\n\t_, err := newpollster();\n\treturn err;\n}"}
{"input": "package pgxlog\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/flynn/flynn/pkg/sirenia/xlog\"\n)\n\nconst Zero xlog.Position = \"0/00000000\"\n\ntype PgXLog struct{}\n\nfunc (p PgXLog) Zero() xlog.Position {\n\treturn Zero\n}\n\n\nfunc (p PgXLog) Increment(pos xlog.Position, increment int) (xlog.Position, error) {\n\tparts, err := parse(pos)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn makePosition(parts[0], parts[1]+increment), nil\n}\n\n\n\nfunc (p PgXLog) Compare(xlog1, xlog2 xlog.Position) (int, error) {\n\tp1, err := parse(xlog1)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tp2, err := parse(xlog2)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif p1[0] == p2[0] && p1[1] == p2[1] {\n\t\treturn 0, nil\n\t}\n\tif p1[0] > p2[0] || p1[0] == p2[0] && p1[1] > p2[1] {\n\t\treturn 1, nil\n\t}\n\treturn -1, nil\n}\n\n\n\n\n\n\n\n\n\nfunc makePosition(filepart int, offset int) xlog.Position {\n\treturn xlog.Position(fmt.Sprintf(\"%X/%08X\", filepart, offset))\n}\n\nfunc parseHex(s string) (int, error) {\n\tres, err := strconv.ParseInt(s, 16, 64)\n\treturn int(res), err\n}\n\nfunc parse(xlog xlog.Position) (res [2]int, err error) ", "output": "{\n\tparts := strings.SplitN(string(xlog), \"/\", 2)\n\tif len(parts) != 2 {\n\t\terr = fmt.Errorf(\"malformed xlog position %q\", xlog)\n\t\treturn\n\t}\n\n\tres[0], err = parseHex(parts[0])\n\tif err != nil {\n\t\treturn\n\t}\n\tres[1], err = parseHex(parts[1])\n\n\treturn\n}"}
{"input": "package hplot\n\nimport (\n\t\"github.com/go-hep/hbook\"\n\t\"github.com/gonum/plot\"\n\t\"github.com/gonum/plot/palette\"\n\t\"github.com/gonum/plot/palette/brewer\"\n\t\"github.com/gonum/plot/plotter\"\n\t\"github.com/gonum/plot/vg/draw\"\n)\n\n\n\ntype H2D struct {\n\tH *hbook.H2D\n\n\tPalette palette.Palette\n\n\tInfos HInfos\n\n\tp *plotter.HeatMap\n}\n\n\nfunc NewH2D(h *hbook.H2D, p palette.Palette) *H2D {\n\tif p == nil {\n\t\tp, _ = brewer.GetPalette(brewer.TypeAny, \"RdYlBu\", 11)\n\t}\n\treturn &H2D{\n\t\tH:       h,\n\t\tPalette: p,\n\t}\n}\n\nfunc (h *H2D) pltr() *plotter.HeatMap {\n\tif h.p == nil {\n\t\th.p = plotter.NewHeatMap(h.H.GridXYZ(), h.Palette)\n\t}\n\treturn h.p\n}\n\n\n\n\n\n\n\nfunc (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\n\n\n\n\nfunc (h *H2D) GlyphBoxes(p *plot.Plot) []plot.GlyphBox {\n\treturn h.pltr().GlyphBoxes(p)\n}\n\n\nvar _ plot.Plotter = (*H2D)(nil)\nvar _ plot.DataRanger = (*H2D)(nil)\nvar _ plot.GlyphBoxer = (*H2D)(nil)\n\nfunc (h *H2D) Plot(c draw.Canvas, p *plot.Plot) ", "output": "{\n\th.pltr().Plot(c, p)\n}"}
{"input": "package metrics\n\nimport (\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/pachyderm/pachyderm/src/client/pkg/uuid\"\n\t\"github.com/pachyderm/pachyderm/src/client/version\"\n\n\t\"go.pedge.io/lion/proto\"\n\tkube \"k8s.io/kubernetes/pkg/client/unversioned\"\n)\n\nvar metrics = &Metrics{}\nvar modified int64\n\n\nfunc AddRepos(num int64) {\n\tatomic.AddInt64(&metrics.Repos, num)\n\tatomic.SwapInt64(&modified, 1)\n}\n\n\nfunc AddCommits(num int64) {\n\tatomic.AddInt64(&metrics.Commits, num)\n\tatomic.SwapInt64(&modified, 1)\n}\n\n\nfunc AddFiles(num int64) {\n\tatomic.AddInt64(&metrics.Files, num)\n\tatomic.SwapInt64(&modified, 1)\n}\n\n\nfunc AddBytes(num int64) {\n\tatomic.AddInt64(&metrics.Bytes, num)\n\tatomic.SwapInt64(&modified, 1)\n}\n\n\nfunc AddJobs(num int64) {\n\tatomic.AddInt64(&metrics.Jobs, num)\n\tatomic.SwapInt64(&modified, 1)\n}\n\n\n\n\n\n\nfunc ReportMetrics(clusterID string, kubeClient *kube.Client) {\n\tmetrics.ID = clusterID\n\tmetrics.PodID = uuid.NewWithoutDashes()\n\tmetrics.Version = version.PrettyPrintVersion(version.Version)\n\tfor {\n\t\twrite := atomic.SwapInt64(&modified, 0)\n\t\tif write == 1 {\n\t\t\texternalMetrics(kubeClient, metrics)\n\t\t\tprotolion.Info(metrics)\n\t\t\treportSegment(metrics)\n\t\t}\n\t\t<-time.After(15 * time.Second)\n\t}\n}\n\nfunc AddPipelines(num int64) ", "output": "{\n\tatomic.AddInt64(&metrics.Pipelines, num)\n\tatomic.SwapInt64(&modified, 1)\n}"}
{"input": "package v2\n\n\ntype APIVersion struct {\n\tlabel string\n\torder byte\n}\n\n\n\nfunc (v APIVersion) AtLeast(test APIVersion) bool {\n\treturn v.order >= test.order\n}\n\n\n\nfunc (v APIVersion) HeaderValue() string {\n\treturn v.label\n}\n\nconst (\n\tinternalAPIVersion2_11 = \"2.11\"\n\n\tinternalAPIVersion2_12 = \"2.12\"\n)\n\n\n\nfunc Version2_11() APIVersion {\n\treturn APIVersion{label: internalAPIVersion2_12, order: 0}\n}\n\n\n\nfunc LatestAPIVersion() APIVersion {\n\treturn Version2_12()\n}\n\nfunc Version2_12() APIVersion ", "output": "{\n\treturn APIVersion{label: internalAPIVersion2_12, order: 1}\n}"}
{"input": "package portal\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient {\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}\n\nfunc New(subscriptionID string) BaseClient ", "output": "{\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"golang.org/x/net/context\"\n)\n\n\n\n\nfunc setCommand(r *ReplYell) {\n\tshellState := getShellState()\n\n\tif len(r.Args) != 2 {\n\t\tfmt.Println(\"Need a key and a value\")\n\t\treturn\n\t}\n\n\tkey := r.Args[0]\n\tvalue := r.Args[1]\n\n\tif !strings.HasPrefix(key, \"/\") {\n\t\tif shellState.pwd != \"/\" {\n\t\t\tkey = shellState.pwd + key\n\t\t} else {\n\t\t\tkey = shellState.pwd + \"/\" + key\n\t\t}\n\t\tfmt.Println(\"Setting \" + key)\n\t}\n\n\tresp, err := shellState.kapi.Set(context.TODO(), key, value, nil)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tprintResponseKey(resp)\n}\n\nfunc NewSetCommand() ReplCommand ", "output": "{\n\treturn ReplCommand{\n\t\tName:  \"set\",\n\t\tUsage: \"set key value\",\n\t\tFlags: []ReplFlag{\n\t\t\tReplFlag{\"ttl\", \"t\", false, true},\n\t\t},\n\t\tAction: func(r *ReplYell) {\n\t\t\tsetCommand(r)\n\t\t},\n\t}\n}"}
{"input": "package jwt_test\n\nimport (\n\t\"camlistore.org/third_party/golang.org/x/oauth2\"\n\t\"camlistore.org/third_party/golang.org/x/oauth2/jwt\"\n)\n\n\n\nfunc ExampleJWTConfig() ", "output": "{\n\tconf := &jwt.Config{\n\t\tEmail: \"xxx@developer.com\",\n\t\tPrivateKey: []byte(\"-----BEGIN RSA PRIVATE KEY-----...\"),\n\t\tSubject:    \"user@example.com\",\n\t\tTokenURL:   \"https:provider.com/o/oauth2/token\",\n\t}\n\tclient := conf.Client(oauth2.NoContext)\n\tclient.Get(\"...\")\n}"}
{"input": "package yaormfilter\n\n\ntype NilFilter struct {\n\tvaluefilterimpl\n}\n\n\nfunc NewNilFilter() ValueFilter {\n\treturn &NilFilter{}\n}\n\n\nfunc (f *NilFilter) Equals(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) NotEquals(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Like(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) ILike(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Nil(v bool) ValueFilter {\n\tf.nil(v)\n\treturn f\n\n}\n\n\nfunc (f *NilFilter) In(values ...interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) NotIn(values ...interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Lt(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Lte(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Gt(v interface{}) ValueFilter {\n\treturn f\n}\n\n\n\n\n\nfunc (f *NilFilter) Raw(s RawFilterFunc) ValueFilter {\n\tf.raw(s)\n\treturn f\n}\n\nfunc (f *NilFilter) Gte(v interface{}) ValueFilter ", "output": "{\n\treturn f\n}"}
{"input": "package logger\n\n\n\ntype options struct {\n\tvalues map[string][]OptionItem\n}\n\n\ntype Option struct {\n\tApply func(op *options)\n}\n\n\nfunc BackendOption(name string, level string, settings map[string]interface{}) Option {\n\treturn Option{func(op *options) {\n\t\tvals := make([]OptionItem, 0)\n\t\tvals = append(vals, OptionItem{\"level\", level})\n\n\t\tif len(settings) > 0 {\n\t\t\tfor k, v := range settings {\n\t\t\t\tvals = append(vals, OptionItem{k, v})\n\t\t\t}\n\t\t}\n\n\t\top.values[name] = vals\n\t}}\n}\n\n\n\n\n\nfunc GetterOption(name string, settings map[string]interface{}) Option {\n\treturn Option{func(op *options) {\n\t\tvals := make([]OptionItem, 0)\n\t\tif len(settings) > 0 {\n\t\t\tfor k, v := range settings {\n\t\t\t\tvals = append(vals, OptionItem{k, v})\n\t\t\t}\n\t\t}\n\n\t\top.values[name] = vals\n\t}}\n}\n\n\ntype OptionItem struct {\n\tfield string\n\tval   interface{}\n}\n\n\nfunc (o *OptionItem) Field() string {\n\treturn o.field\n}\n\n\nfunc (o *OptionItem) Int() int {\n\tif o.val == nil {\n\t\treturn 0\n\t}\n\n\treturn o.val.(int)\n}\n\n\nfunc (o *OptionItem) String() string {\n\tif o.val == nil {\n\t\treturn \"\"\n\t}\n\n\treturn o.val.(string)\n}\n\n\nfunc (o *OptionItem) Raw() interface{} {\n\treturn o.val\n}\n\nfunc SweeperOption(name string, duration int, settings map[string]interface{}) Option ", "output": "{\n\treturn Option{func(op *options) {\n\t\tvals := make([]OptionItem, 0)\n\t\tvals = append(vals, OptionItem{\"duration\", duration})\n\n\t\tif len(settings) > 0 {\n\t\t\tfor k, v := range settings {\n\t\t\t\tvals = append(vals, OptionItem{k, v})\n\t\t\t}\n\t\t}\n\n\t\top.values[name] = vals\n\t}}\n}"}
{"input": "package metrics\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype Registry struct {\n\tdescriptors []*groupDesc\n\tgroups      []groupRegistry\n}\n\nconst (\n\tDefaultGroup = GID(0)\n)\n\n\nfunc NewRegistry() *Registry {\n\tvar r Registry\n\tr.MustRegisterGroup(\"global\")\n\treturn &r\n}\n\n\n\nfunc (r *Registry) mustRegister(gd *groupDesc) {\n\tif err := r.register(gd); err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\n\n\n\nfunc (r *Registry) MustRegisterGroup(name string) GID {\n\tgd := &groupDesc{Name: name}\n\tr.mustRegister(gd)\n\treturn gd.id\n}\n\nfunc (r *Registry) mustGetGroupRegistry(id GID) *groupRegistry {\n\tif int(id) >= len(r.groups) {\n\t\tpanic(\"invalid group ID\")\n\t}\n\treturn &r.groups[id]\n}\n\n\n\n\n\nfunc (r *Registry) MustRegisterCounter(name string, opts ...descOption) ID {\n\tdesc := newDesc(name, opts...)\n\treturn r.mustGetGroupRegistry(desc.gid).mustRegisterCounter(desc)\n}\n\n\n\n\n\nfunc (r *Registry) MustRegisterTimer(name string, opts ...descOption) ID {\n\tdesc := newDesc(name, opts...)\n\treturn r.mustGetGroupRegistry(desc.gid).mustRegisterTimer(desc)\n}\n\nfunc (r *Registry) NewGroup(gid GID) *Group {\n\treturn r.mustGetGroupRegistry(gid).newGroup()\n}\n\nfunc (r *Registry) register(gd *groupDesc) error ", "output": "{\n\tp := sort.Search(len(r.descriptors), func(i int) bool {\n\t\treturn r.descriptors[i].Name == gd.Name\n\t})\n\n\tif p != len(r.descriptors) {\n\t\treturn fmt.Errorf(\"group name '%s' already in use\", gd.Name)\n\t}\n\n\tr.descriptors = append(r.descriptors, gd)\n\tsort.Slice(r.descriptors, func(i, j int) bool {\n\t\treturn r.descriptors[i].Name < r.descriptors[j].Name\n\t})\n\n\tgd.id = GID(len(r.groups))\n\tr.groups = append(r.groups, groupRegistry{desc: gd})\n\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\n\n\nfunc readValue(bdb *bolt.DB, k []byte) (N int) {\n\tbdb.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket([]byte(\"predicate\"))\n\t\tif bucket == nil {\n\t\t\treturn errors.New(\"Bucket not found\")\n\t\t}\n\t\tval := bucket.Get(k)\n\t\tm := make([]byte, len(val))\n\t\tcopy(m, val)\n\t\tN = len(m)\n\t\treturn nil\n\t})\n\treturn\n}\n\nfunc main() {\n\tdb, err := bolt.Open(\"bolt.db\", 0600, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\tk := []byte(\"key\")\n\tN := 512\n\tif err := writeNBytes(db, k, N); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(readValue(db, k))\n}\n\nfunc writeNBytes(bdb *bolt.DB, k []byte, N int) error ", "output": "{\n\tbuf := make([]byte, N)\n\treturn bdb.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.CreateBucketIfNotExists([]byte(\"predicate\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn bucket.Put(k, buf)\n\t})\n}"}
{"input": "package app\n\nimport (\n\t. \"strconv\"\n\t\"time\"\n)\n\ntype User struct {\n\tId        int64\n\tNom       string\n\tPrenom    string\n\tEmail     string\n\tPassword  string\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}\n\n\nfunc (u User) Save() {\n\tdb.Save(&u)\n}\n\n\nfunc (u User) Update() {\n\tdb.First(&u, &u.Id).Update(&u)\n}\n\n\n\n\n\n\nfunc (u User) GetById() User {\n\tdb.Where(\"id = ?\", Itoa(int(u.Id))).Find(&u)\n\treturn u\n}\n\n\nfunc (u User) GetList() []User {\n\tvar users []User\n\tdb.Find(&users)\n\treturn users\n}\n\nfunc (u User) Delete() ", "output": "{\n\tdb.Delete(&u)\n}"}
{"input": "package vpc\n\nimport (\n\t\"github.com/ucloud/ucloud-sdk-go/ucloud/request\"\n\t\"github.com/ucloud/ucloud-sdk-go/ucloud/response\"\n)\n\n\ntype ListSubnetForNATGWRequest struct {\n\trequest.CommonBase\n\n\n\n\tVPCId *string `required:\"false\"`\n}\n\n\ntype ListSubnetForNATGWResponse struct {\n\tresponse.CommonBase\n\n\tDataSet []NatgwSubnetDataSet\n}\n\n\nfunc (c *VPCClient) NewListSubnetForNATGWRequest() *ListSubnetForNATGWRequest {\n\treq := &ListSubnetForNATGWRequest{}\n\n\tc.Client.SetupRequest(req)\n\n\treq.SetRetryable(true)\n\treturn req\n}\n\n\n\n\nfunc (c *VPCClient) ListSubnetForNATGW(req *ListSubnetForNATGWRequest) (*ListSubnetForNATGWResponse, error) ", "output": "{\n\tvar err error\n\tvar res ListSubnetForNATGWResponse\n\n\treqCopier := *req\n\n\terr = c.Client.InvokeAction(\"ListSubnetForNATGW\", &reqCopier, &res)\n\tif err != nil {\n\t\treturn &res, err\n\t}\n\n\treturn &res, nil\n}"}
{"input": "package algorithm\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n)\n\ntype BuildSet map[int]struct{}\n\nfunc (set BuildSet) Contains(buildID int) bool {\n\t_, found := set[buildID]\n\treturn found\n}\n\n\n\nfunc (set BuildSet) Intersect(otherSet BuildSet) BuildSet {\n\tresult := BuildSet{}\n\n\tfor key, val := range set {\n\t\t_, found := otherSet[key]\n\t\tif found {\n\t\t\tresult[key] = val\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc (set BuildSet) Equal(otherSet BuildSet) bool {\n\tif len(set) != len(otherSet) {\n\t\treturn false\n\t}\n\n\tfor x, _ := range set {\n\t\tif !otherSet.Contains(x) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (set BuildSet) String() string {\n\txs := []string{}\n\tfor x, _ := range set {\n\t\txs = append(xs, fmt.Sprintf(\"%v\", x))\n\t}\n\n\tsort.Strings(xs)\n\n\treturn fmt.Sprintf(\"{%s}\", strings.Join(xs, \" \"))\n}\n\nfunc (set BuildSet) Union(otherSet BuildSet) BuildSet ", "output": "{\n\tnewSet := BuildSet{}\n\n\tfor buildID, _ := range set {\n\t\tnewSet[buildID] = struct{}{}\n\t}\n\n\tfor buildID, _ := range otherSet {\n\t\tnewSet[buildID] = struct{}{}\n\t}\n\n\treturn newSet\n}"}
{"input": "package helpers\n\nimport (\n\t\"github.com/docker/docker/pkg/homedir\"\n\t\"os\"\n)\n\nfunc GetCurrentWorkingDirectory() string {\n\tdir, err := os.Getwd()\n\tif err == nil {\n\t\treturn dir\n\t}\n\treturn \"\"\n}\n\n\n\nfunc GetHomeDir() string ", "output": "{\n\treturn homedir.Get()\n}"}
{"input": "package goavro\n\nimport \"testing\"\n\nfunc TestSchemaPrimitiveNullCodec(t *testing.T) {\n\ttestSchemaPrimativeCodec(t, `\"null\"`)\n}\n\nfunc TestPrimitiveNullBinary(t *testing.T) {\n\ttestBinaryEncodeFailBadDatumType(t, `\"null\"`, false)\n\ttestBinaryCodecPass(t, `\"null\"`, nil, nil)\n}\n\n\n\nfunc TestPrimitiveNullText(t *testing.T) ", "output": "{\n\ttestTextEncodeFailBadDatumType(t, `\"null\"`, false)\n\ttestTextCodecPass(t, `\"null\"`, nil, []byte(\"null\"))\n}"}
{"input": "package dataintegration\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype JavaType struct {\n\n\tKey *string `mandatory:\"false\" json:\"key\"`\n\n\tModelVersion *string `mandatory:\"false\" json:\"modelVersion\"`\n\n\tParentRef *ParentReference `mandatory:\"false\" json:\"parentRef\"`\n\n\tName *string `mandatory:\"false\" json:\"name\"`\n\n\tObjectStatus *int `mandatory:\"false\" json:\"objectStatus\"`\n\n\tDescription *string `mandatory:\"false\" json:\"description\"`\n\n\tJavaTypeName *string `mandatory:\"false\" json:\"javaTypeName\"`\n\n\tConfigDefinition *ConfigDefinition `mandatory:\"false\" json:\"configDefinition\"`\n}\n\n\nfunc (m JavaType) GetKey() *string {\n\treturn m.Key\n}\n\n\n\n\n\nfunc (m JavaType) GetParentRef() *ParentReference {\n\treturn m.ParentRef\n}\n\n\nfunc (m JavaType) GetName() *string {\n\treturn m.Name\n}\n\n\nfunc (m JavaType) GetObjectStatus() *int {\n\treturn m.ObjectStatus\n}\n\n\nfunc (m JavaType) GetDescription() *string {\n\treturn m.Description\n}\n\nfunc (m JavaType) String() string {\n\treturn common.PointerString(m)\n}\n\n\nfunc (m JavaType) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeJavaType JavaType\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"modelType\"`\n\t\tMarshalTypeJavaType\n\t}{\n\t\t\"JAVA_TYPE\",\n\t\t(MarshalTypeJavaType)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\n\nfunc (m JavaType) GetModelVersion() *string ", "output": "{\n\treturn m.ModelVersion\n}"}
{"input": "package connect\n\nimport \"io\"\nimport \"github.com/LilyPad/GoLilyPad/packet\"\n\ntype RequestAuthenticate struct {\n\tUsername string\n\tPassword string\n}\n\n\n\nfunc (this *RequestAuthenticate) Id() int {\n\treturn REQUEST_AUTHENTICATE\n}\n\ntype requestAuthenticateCodec struct {\n\n}\n\nfunc (this *requestAuthenticateCodec) Decode(reader io.Reader) (request Request, err error) {\n\trequestAuthenticate := new(RequestAuthenticate)\n\trequestAuthenticate.Username, err = packet.ReadString(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\trequestAuthenticate.Password, err = packet.ReadString(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\trequest = requestAuthenticate\n\treturn\n}\n\nfunc (this *requestAuthenticateCodec) Encode(writer io.Writer, request Request) (err error) {\n\trequestAuthenticate := request.(*RequestAuthenticate)\n\terr = packet.WriteString(writer, requestAuthenticate.Username)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = packet.WriteString(writer, requestAuthenticate.Password)\n\treturn\n}\n\ntype ResultAuthenticate struct {\n\n}\n\nfunc NewResultAuthenticate() (this *ResultAuthenticate) {\n\tthis = new(ResultAuthenticate)\n\treturn\n}\n\nfunc (this *ResultAuthenticate) Id() int {\n\treturn REQUEST_AUTHENTICATE\n}\n\ntype resultAuthenticateCodec struct {\n\n}\n\nfunc (this *resultAuthenticateCodec) Decode(reader io.Reader) (result Result, err error) {\n\tresult = new(ResultAuthenticate)\n\treturn\n}\n\nfunc (this *resultAuthenticateCodec) Encode(writer io.Writer, result Result) (err error) {\n\treturn\n}\n\nfunc NewRequestAuthenticate(username string, password string) (this *RequestAuthenticate) ", "output": "{\n\tthis = new(RequestAuthenticate)\n\tthis.Username = username\n\tthis.Password = password\n\treturn\n}"}
{"input": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype Timestamp struct {\n\tTime string `json:\"startup\"`\n}\n\nfunc StartTimer(w http.ResponseWriter, r *http.Request) {\n\tt := Timestamp{\n\t\tTime: fmt.Sprint(time.Now().UTC()),\n\t}\n\n\tb, err := json.Marshal(t)\n\tif err != nil {\n\t\thttp.Error(w, \"failed to get time\", http.StatusInternalServerError)\n\t} else {\n\t\treader := bytes.NewReader(b)\n\t\treader.WriteTo(w)\n\t}\n}\n\n\n\nfunc main() {\n\thttp.HandleFunc(\"/runLambda/pausable-start-timer\", StartTimer)\n\tlog.Fatal(http.ListenAndServe(\":8080\", Log(http.DefaultServeMux)))\n}\n\nfunc Log(handler http.Handler) http.Handler ", "output": "{\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlog.Printf(\"%s %s %s\", r.RemoteAddr, r.Method, r.URL)\n\t\thandler.ServeHTTP(w, r)\n\t})\n}"}
{"input": "package cluster\n\nimport \"github.com/docker/docker/api/types\"\n\n\ntype Volume struct {\n\ttypes.Volume\n\n\tEngine *Engine\n}\n\n\ntype Volumes []*Volume\n\n\n\n\nfunc (volumes Volumes) Get(name string) *Volume ", "output": "{\n\tif len(name) == 0 {\n\t\treturn nil\n\t}\n\n\tcandidates := []*Volume{}\n\n\tfor _, volume := range volumes {\n\t\tif volume.Name == name || volume.Engine.ID+\"/\"+volume.Name == name || volume.Engine.Name+\"/\"+volume.Name == name {\n\t\t\tcandidates = append(candidates, volume)\n\t\t}\n\t}\n\n\tif size := len(candidates); size == 1 {\n\t\treturn candidates[0]\n\t} else if size > 1 {\n\t\tfor _, volume := range candidates {\n\t\t\tif volume.Name == name && volume.Driver != \"local\" {\n\t\t\t\treturn volume\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\tfor _, volume := range volumes {\n\t\tif volume.Name == \"/\"+name {\n\t\t\treturn volume\n\t\t}\n\t}\n\n\treturn nil\n}"}
{"input": "package zygo\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc MakeRaw(args []Sexp) (*SexpRaw, error) {\n\traw := make([]byte, 0)\n\tfor i := 0; i < len(args); i++ {\n\t\tswitch e := args[i].(type) {\n\t\tcase *SexpStr:\n\t\t\ta := []byte(e.S)\n\t\t\traw = append(raw, a...)\n\t\tdefault:\n\t\t\treturn &SexpRaw{},\n\t\t\t\tfmt.Errorf(\"raw takes only string arguments. We see %T: '%v'\", e, e)\n\t\t}\n\t}\n\treturn &SexpRaw{Val: raw}, nil\n}\n\n\n\nfunc RawToStringFunction(env *Zlisp, name string, args []Sexp) (Sexp, error) ", "output": "{\n\tif len(args) != 1 {\n\t\treturn SexpNull, WrongNargs\n\t}\n\n\tswitch t := args[0].(type) {\n\tcase *SexpRaw:\n\t\treturn &SexpStr{S: string(t.Val)}, nil\n\t}\n\treturn SexpNull, errors.New(\"argument must be raw\")\n}"}
{"input": "package comparisons\n\nimport \"jvmgo/ch05/instructions/base\"\nimport \"jvmgo/ch05/rtda\"\n\n\ntype IF_ACMPEQ struct{ base.BranchInstruction }\n\nfunc (self *IF_ACMPEQ) Execute(frame *rtda.Frame) {\n\tif _acmp(frame) {\n\t\tbase.Branch(frame, self.Offset)\n\t}\n}\n\ntype IF_ACMPNE struct{ base.BranchInstruction }\n\n\n\nfunc _acmp(frame *rtda.Frame) bool {\n\tstack := frame.OperandStack()\n\tref2 := stack.PopRef()\n\tref1 := stack.PopRef()\n\treturn ref1 == ref2 \n}\n\nfunc (self *IF_ACMPNE) Execute(frame *rtda.Frame) ", "output": "{\n\tif !_acmp(frame) {\n\t\tbase.Branch(frame, self.Offset)\n\t}\n}"}
{"input": "package gtk_mock\n\nimport \"github.com/twstrike/coyim/Godeps/_workspace/src/github.com/twstrike/gotk3adapter/gtki\"\n\ntype MockTextView struct {\n\tMockContainer\n}\n\nfunc (*MockTextView) SetEditable(v1 bool) {\n}\n\nfunc (*MockTextView) SetCursorVisible(v1 bool) {\n}\n\nfunc (*MockTextView) SetBuffer(v1 gtki.TextBuffer) {\n}\n\nfunc (*MockTextView) GetBuffer() (gtki.TextBuffer, error) {\n\treturn nil, nil\n}\n\nfunc (*MockTextView) ForwardDisplayLine(gtki.TextIter) bool {\n\treturn false\n}\n\nfunc (*MockTextView) BackwardDisplayLine(gtki.TextIter) bool {\n\treturn false\n}\n\n\n\nfunc (*MockTextView) BackwardDisplayLineStart(gtki.TextIter) bool {\n\treturn false\n}\n\nfunc (*MockTextView) StartsDisplayLine(gtki.TextIter) bool {\n\treturn false\n}\n\nfunc (*MockTextView) MoveVisually(gtki.TextIter, int) bool {\n\treturn false\n}\n\nfunc (*MockTextView) ForwardDisplayLineEnd(gtki.TextIter) bool ", "output": "{\n\treturn false\n}"}
{"input": "package router\n\nimport (\n\t\"interfaces\"\n\n\t\"github.com/labstack/echo\"\n)\n\nvar (\n\tMatchRouteCtxKey = \"_MatchRoute\"\n)\n\nfunc MatchVRouteFromContext(\n\tctx echo.Context,\n) *interfaces.RouteMatch {\n\n\tif route, exists := ctx.Get(MatchRouteCtxKey).(*interfaces.RouteMatch); exists {\n\t\treturn route\n\t}\n\n\treturn nil\n}\n\n\n\nfunc SetMatchedVRouteContext(\n\tctx echo.Context,\n\tmatch *interfaces.RouteMatch,\n) ", "output": "{\n\tctx.Set(MatchRouteCtxKey, match)\n}"}
{"input": "package vml_test\n\nimport (\n\t\"encoding/xml\"\n\t\"testing\"\n\n\t\"baliance.com/gooxml/schema/urn/schemas_microsoft_com/vml\"\n)\n\nfunc TestAG_AllShapeAttributesConstructor(t *testing.T) {\n\tv := vml.NewAG_AllShapeAttributes()\n\tif v == nil {\n\t\tt.Errorf(\"vml.NewAG_AllShapeAttributes must return a non-nil value\")\n\t}\n\tif err := v.Validate(); err != nil {\n\t\tt.Errorf(\"newly constructed vml.AG_AllShapeAttributes should validate: %s\", err)\n\t}\n}\n\n\n\nfunc TestAG_AllShapeAttributesMarshalUnmarshal(t *testing.T) ", "output": "{\n\tv := vml.NewAG_AllShapeAttributes()\n\tbuf, _ := xml.Marshal(v)\n\tv2 := vml.NewAG_AllShapeAttributes()\n\txml.Unmarshal(buf, v2)\n}"}
{"input": "package classfile\n\nimport (\n\n)\n\ntype ConstantPool []ConstantInfo\n\nfunc readConstantPool(reader *ClassReader) ConstantPool {\n\tcount := int(reader.ReadUint16())\n\tcp := make([]ConstantInfo, count)\n\tfor i := 1; i < count; i++ {\n\t\tcp[i] = readConstantInfo(reader, cp)\n\t\tswitch cp[i].(type) {\n\t\tcase *ConstantLongInfo, *ConstantDoubleInfo:\n\t\t\ti++\n\t\t}\n\t}\n\treturn cp\n}\n\nfunc (self ConstantPool) getConstantInfo(index uint16) ConstantInfo {\n\tif cpInfo := self[index]; cpInfo != nil {\n\t\treturn cpInfo\n\t}\n\tpanic(\"Invalid constant pool index!\")\n}\n\nfunc (self ConstantPool) getNameAndType(index uint16) (string, string) {\n\tcpInfo := self.getConstantInfo(index).(*ConstantNameAndTypeInfo)\n\tname := self.getUtf8(cpInfo.nameIndex)\n\tdesc := self.getUtf8(cpInfo.descriptorIndex)\n\treturn name, desc\n}\n\n\n\nfunc (self ConstantPool) getUtf8(index uint16) string {\n\tutf8Info := self.getConstantInfo(index).(*ConstantUtf8Info)\n\treturn utf8Info.str\n}\n\nfunc (self ConstantPool) getClassName(index uint16) string ", "output": "{\n\tclassInfo := self.getConstantInfo(index).(*ConstantClassInfo)\n\treturn self.getUtf8(classInfo.nameIndex)\n}"}
{"input": "package apmcontrolplane\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetWorkRequestRequest struct {\n\n\tWorkRequestId *string `mandatory:\"true\" contributesTo:\"path\" name:\"workRequestId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetWorkRequestRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request GetWorkRequestRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request GetWorkRequestRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request GetWorkRequestRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetWorkRequestResponse struct {\n\n\tRawResponse *http.Response\n\n\tWorkRequest `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n\n\tRetryAfter *float32 `presentIn:\"header\" name:\"retry-after\"`\n}\n\n\n\n\nfunc (response GetWorkRequestResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response GetWorkRequestResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package endpoints\n\n\ntype SimpleHostResolver struct {\n}\n\n\n\n\n\nfunc (resolver *SimpleHostResolver) TryResolve(param *ResolveParam) (endpoint string, support bool, err error) {\n\tif support = len(param.Domain) > 0; support {\n\t\tendpoint = param.Domain\n\t}\n\treturn\n}\n\nfunc (resolver *SimpleHostResolver) GetName() (name string) ", "output": "{\n\tname = \"simple host resolver\"\n\treturn\n}"}
{"input": "package poet\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\ntype MethodSuite struct{}\n\nvar _ = Suite(&MethodSuite{})\n\nfunc (s *TemplateSuite) TestMethod(c *C) {\n\texpected := \"\" +\n\t\t\"func (b *bytes.Buffer) foo() {\\n\" +\n\t\t\"}\\n\"\n\n\tm := NewMethodSpec(\"foo\", \"b\", TypeReferenceFromInstance(&bytes.Buffer{}))\n\n\tactual := m.String()\n\tc.Assert(actual, Equals, expected)\n}\n\n\n\nfunc (s *TemplateSuite) TestMethodValueReceiver(c *C) {\n\texpected := \"\" +\n\t\t\"func (b bytes.Buffer) foo() {\\n\" +\n\t\t\"}\\n\"\n\n\tm := NewMethodSpec(\"foo\", \"b\", TypeReferenceFromInstance(bytes.Buffer{}))\n\n\tactual := m.String()\n\tc.Assert(actual, Equals, expected)\n}\n\nfunc (s *TemplateSuite) TestMethodWithStatement(c *C) ", "output": "{\n\texpected := \"\" +\n\t\t\"func (b *bytes.Buffer) foo() {\\n\" +\n\t\t\"\\tfmt.Println()\\n\" +\n\t\t\"}\\n\"\n\n\tm := NewMethodSpec(\"foo\", \"b\", TypeReferenceFromInstance(&bytes.Buffer{}))\n\tm.Statement(\"$T()\", TypeReferenceFromInstance(fmt.Println))\n\n\tactual := m.String()\n\tc.Assert(actual, Equals, expected)\n}"}
{"input": "package servo_test\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n\t\"github.com/fgrosse/servo\"\n\t\"fmt\"\n)\n\nfunc TestServo(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Servo Test Suite\")\n}\n\ntype TestBundle struct {}\n\nfunc (b *TestBundle) Boot(kernel *servo.Kernel) {\n\tkernel.RegisterType(\"test_bundle.my_type\", NewService)\n}\n\ntype SomeService struct {}\n\nfunc NewRecursiveService(*SomeService) *SomeService {\n\treturn &SomeService{}\n}\n\nfunc NewService() *SomeService {\n\treturn &SomeService{}\n}\n\nfunc NewServiceWithParam(param interface{}) *SomeService {\n\tpanic(param)\n\treturn &SomeService{}\n}\n\n\ntype ServerMock struct {\n\tRunHasBeenCalled bool\n\tReturnError      bool\n\n\tParameter1, Parameter2 string\n}\n\n\n\nfunc (s *ServerMock) Run() error {\n\ts.RunHasBeenCalled = true\n\tif s.ReturnError {\n\t\treturn fmt.Errorf(\"ServerMock was told to return an error!\")\n\t}\n\n\treturn nil\n}\n\nfunc NewServerMockWithParams(param1, param2 string) *ServerMock ", "output": "{\n\tExpect(param1).To(Equal(\"foo\"), `NewServerMockWithParams should always be called with the values \"foo\" and \"bar\"`)\n\tExpect(param2).To(Equal(\"bar\"), `NewServerMockWithParams should always be called with the values \"foo\" and \"bar\"`)\n\n\treturn &ServerMock{\n\t\tParameter1: param1,\n\t\tParameter2: param2,\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/lmas/labassistant\"\n)\n\nfunc main() {\n\tex := labassistant.NewExperiment(\"test\")\n\n\tex.SetControl(testcontrol)\n\n\tex.AddCandidate(testcan1)\n\tex.AddCandidate(testcan2)\n\tex.AddCandidate(testcan3)\n\tex.AddCandidate(testcan4)\n\tex.AddCandidate(testcan5)\n\tex.AddCandidate(testcan6)\n\tex.AddCandidate(testcan7)\n\n\n\n\tex.Run(1, 2)\n\n\tpublish(ex)\n}\n\n\n\n\nfunc testcontrol(i1, i2 int) (int, int, int) {\n\treturn i1, i2, i1 + i2\n}\n\n\n\nfunc testcan1(i1, i2 int) (int, int, int) {\n\treturn i1, i2, i1 + i2\n}\n\n\n\n\nfunc testcan2(i1, i2 int) (int, int, int) {\n\treturn i1, i2, -1\n}\n\n\nfunc testcan3(i1, i2 int) error {\n\treturn fmt.Errorf(\"bad output\")\n}\n\n\nfunc testcan4(i1, i2 int) (int, int, int) {\n\ti := 1 - 1\n\treturn i1, i2, 1 / i\n}\n\n\nfunc testcan5(i1, i2 int) (int, int) {\n\treturn i1, i2\n}\n\n\nfunc testcan6(i1, i2 int) (int, int, int, int) {\n\treturn i1, i2, i1 + i2, 0\n}\n\n\nfunc testcan7(i1, i2 int) (int, int, int) {\n\ttime.Sleep(10000 * time.Nanosecond)\n\treturn i1, i2, i1 + i2\n}\n\nfunc publish(ex *labassistant.Experiment) ", "output": "{\n\tfmt.Printf(\"%v duration: %v\\t output: %v\\n\", ex.Control.Name, ex.Control.Duration, ex.Control.Outputs)\n\n\tfor _, ob := range ex.Candidates {\n\t\toutput := ob.Outputs\n\n\t\tif ob.Panic != nil {\n\t\t\toutput = []interface{}{ob.Panic}\n\t\t}\n\n\t\tfmt.Printf(\"Candidate %v duration: %v \\t mismatch: %v \\t output: %v\\n\", ob.Name, ob.Duration, ob.Mismatch, output)\n\t}\n\n\tfmt.Println(\"Run order: \", strings.Join(ex.RunOrder, \", \"))\n}"}
{"input": "package dbr\n\ntype union struct {\n\tbuilder []Builder\n\tall     bool\n}\n\n\nfunc Union(builder ...Builder) interface {\n\tBuilder\n\tAs(string) Builder\n} {\n\treturn &union{\n\t\tbuilder: builder,\n\t}\n}\n\n\nfunc UnionAll(builder ...Builder) interface {\n\tBuilder\n\tAs(string) Builder\n} {\n\treturn &union{\n\t\tbuilder: builder,\n\t\tall:     true,\n\t}\n}\n\n\n\nfunc (u *union) As(alias string) Builder {\n\treturn as(u, alias)\n}\n\nfunc (u *union) Build(d Dialect, buf Buffer) error ", "output": "{\n\tfor i, b := range u.builder {\n\t\tif i > 0 {\n\t\t\tbuf.WriteString(\" UNION \")\n\t\t\tif u.all {\n\t\t\t\tbuf.WriteString(\"ALL \")\n\t\t\t}\n\t\t}\n\t\tbuf.WriteString(placeholder)\n\t\tbuf.WriteValue(b)\n\t}\n\treturn nil\n}"}
{"input": "package jms\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype UpdateFleetAgentConfigurationRequest struct {\n\n\tFleetId *string `mandatory:\"true\" contributesTo:\"path\" name:\"fleetId\"`\n\n\tUpdateFleetAgentConfigurationDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request UpdateFleetAgentConfigurationRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request UpdateFleetAgentConfigurationRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request UpdateFleetAgentConfigurationRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request UpdateFleetAgentConfigurationRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype UpdateFleetAgentConfigurationResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response UpdateFleetAgentConfigurationResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\n\n\nfunc (response UpdateFleetAgentConfigurationResponse) HTTPResponse() *http.Response ", "output": "{\n\treturn response.RawResponse\n}"}
{"input": "package query\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\t\"github.com/m3db/m3/src/m3ninx/generated/proto/querypb\"\n\t\"github.com/m3db/m3/src/m3ninx/search\"\n\t\"github.com/m3db/m3/src/m3ninx/search/searcher\"\n)\n\n\ntype FieldQuery struct {\n\tfield []byte\n}\n\n\nfunc NewFieldQuery(field []byte) search.Query {\n\treturn &FieldQuery{\n\t\tfield: field,\n\t}\n}\n\n\nfunc (q *FieldQuery) Field() []byte {\n\treturn q.field\n}\n\n\n\n\n\nfunc (q *FieldQuery) Equal(o search.Query) bool {\n\to, ok := singular(o)\n\tif !ok {\n\t\treturn false\n\t}\n\n\tinner, ok := o.(*FieldQuery)\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn bytes.Equal(q.field, inner.field)\n}\n\n\nfunc (q *FieldQuery) ToProto() *querypb.Query {\n\tterm := querypb.FieldQuery{\n\t\tField: q.field,\n\t}\n\n\treturn &querypb.Query{\n\t\tQuery: &querypb.Query_Field{Field: &term},\n\t}\n}\n\nfunc (q *FieldQuery) String() string {\n\treturn fmt.Sprintf(\"field(%s)\", q.field)\n}\n\nfunc (q *FieldQuery) Searcher() (search.Searcher, error) ", "output": "{\n\treturn searcher.NewFieldSearcher(q.field)\n}"}
{"input": "\n\nfunc twoSum(nums []int, target int) []int ", "output": "{\n    mymap := make(map[int]int)\n    for i := 0; i < len(nums); i++ {\n        j, ok := mymap[target-nums[i]]\n        if ok {\n            result := []int{j, i}\n            return result\n        }\n        mymap[nums[i]] = i\n    }\n    result := []int{-1, -1}\n    return result\n}"}
{"input": "package cmd\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/spf13/cobra\"\n\n\t\"github.com/spf13/viper\"\n)\n\nvar (\n\tcfgFile  string\n\tproject  string\n\tinstance string\n\tdatabase string\n\n\trootCmd = &cobra.Command{\n\t\tUse:   \"gcsb\",\n\t\tShort: \"Like YCSB but for spanner\",\n\t\tLong:  ``,\n\t}\n)\n\n\n\n\n\nfunc init() {\n\tcobra.OnInitialize(initConfig)\n\n\tflags := rootCmd.PersistentFlags()\n\tflags.StringVar(&cfgFile, \"config\", \"\", \"config file (default is ./gcsb.yaml)\")\n\n\tflags.StringVarP(&project, \"project\", \"p\", \"\", \"GCP Project\")\n\tviper.BindPFlag(\"project\", flags.Lookup(\"project\")) \n\n\tflags.StringVarP(&instance, \"instance\", \"i\", \"\", \"Spanner Instance\")\n\tviper.BindPFlag(\"instance\", flags.Lookup(\"instance\"))\n\n\tflags.StringVarP(&database, \"database\", \"d\", \"\", \"Spanner Database\")\n\tviper.BindPFlag(\"database\", flags.Lookup(\"database\"))\n}\n\n\nfunc initConfig() {\n\tif cfgFile != \"\" {\n\t\tviper.SetConfigFile(cfgFile)\n\t} else {\n\t\tviper.AddConfigPath(\".\")\n\t\tviper.SetConfigName(\"gcsb\")\n\t}\n\n\tviper.AutomaticEnv() \n\tviper.SetEnvPrefix(\"GCSB\")\n\tviper.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\"))\n\n\n\tviper.ReadInConfig() \n}\n\nfunc Execute() ", "output": "{\n\tif err := rootCmd.Execute(); err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}"}
{"input": "package models\n\nimport (\n\t\"time\"\n)\n\n\ntype MapLayer struct {\n\tId          int64         `json:\"id\"`\n\tName        string        `json:\"name\" validate:\"max=254;required\"`\n\tDescription string        `json:\"description\"`\n\tMap         *Map          `json:\"map\"`\n\tMapId       int64         `json:\"map_id\" validate:\"required\"`\n\tStatus      string        `json:\"status\" validate:\"required\"`\n\tWeight      int64         `json:\"weight\"`\n\tElements    []*MapElement `json:\"elements\"`\n\tCreatedAt   time.Time     `json:\"created_at\"`\n\tUpdatedAt   time.Time     `json:\"updated_at\"`\n}\n\n\ntype SortMapLayersByWeight []*MapLayer\n\n\n\n\n\nfunc (l SortMapLayersByWeight) Swap(i, j int) { l[i], l[j] = l[j], l[i] }\n\n\nfunc (l SortMapLayersByWeight) Less(i, j int) bool { return l[i].Weight < l[j].Weight }\n\n\ntype SortMapLayer struct {\n\tId     int64 `json:\"id\"`\n\tWeight int64 `json:\"weight\"`\n}\n\nfunc (l SortMapLayersByWeight) Len() int ", "output": "{ return len(l) }"}
{"input": "package daemon\n\n\n\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n\tgolangswaggerpaths \"path\"\n)\n\n\ntype GetDebuginfoURL struct {\n\t_basePath string\n}\n\n\n\n\nfunc (o *GetDebuginfoURL) WithBasePath(bp string) *GetDebuginfoURL {\n\to.SetBasePath(bp)\n\treturn o\n}\n\n\n\n\n\n\n\nfunc (o *GetDebuginfoURL) Build() (*url.URL, error) {\n\tvar result url.URL\n\n\tvar _path = \"/debuginfo\"\n\n\t_basePath := o._basePath\n\tif _basePath == \"\" {\n\t\t_basePath = \"/v1\"\n\t}\n\tresult.Path = golangswaggerpaths.Join(_basePath, _path)\n\n\treturn &result, nil\n}\n\n\nfunc (o *GetDebuginfoURL) Must(u *url.URL, err error) *url.URL {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif u == nil {\n\t\tpanic(\"url can't be nil\")\n\t}\n\treturn u\n}\n\n\nfunc (o *GetDebuginfoURL) String() string {\n\treturn o.Must(o.Build()).String()\n}\n\n\nfunc (o *GetDebuginfoURL) BuildFull(scheme, host string) (*url.URL, error) {\n\tif scheme == \"\" {\n\t\treturn nil, errors.New(\"scheme is required for a full url on GetDebuginfoURL\")\n\t}\n\tif host == \"\" {\n\t\treturn nil, errors.New(\"host is required for a full url on GetDebuginfoURL\")\n\t}\n\n\tbase, err := o.Build()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbase.Scheme = scheme\n\tbase.Host = host\n\treturn base, nil\n}\n\n\nfunc (o *GetDebuginfoURL) StringFull(scheme, host string) string {\n\treturn o.Must(o.BuildFull(scheme, host)).String()\n}\n\nfunc (o *GetDebuginfoURL) SetBasePath(bp string) ", "output": "{\n\to._basePath = bp\n}"}
{"input": "package assert\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\t\"github.com/alecthomas/colour\"\n\t\"github.com/alecthomas/repr\"\n\t\"github.com/sergi/go-diff/diffmatchpatch\"\n)\n\n\n\nfunc DiffValuesDefault(a, b interface{}) string {\n\tdiff := diffmatchpatch.New()\n\tat := repr.String(a)\n\tbt := repr.String(b)\n\tdiffs := diff.DiffMain(at, bt, true)\n\tw := bytes.NewBuffer(nil)\n\tfor _, d := range diffs {\n\t\tswitch d.Type {\n\t\tcase diffmatchpatch.DiffEqual:\n\t\t\tif len(d.Text) <= 40 {\n\t\t\t\tw.WriteString(d.Text)\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(w, \"%s...%s\", d.Text[:15], d.Text[len(d.Text)-15:])\n\t\t\t}\n\t\tcase diffmatchpatch.DiffDelete:\n\t\t\tfmt.Fprintf(w, \"-{{%s}}\", d.Text)\n\t\tcase diffmatchpatch.DiffInsert:\n\t\t\tfmt.Fprintf(w, \"+{{%s}}\", d.Text)\n\t\t}\n\t}\n\treturn w.String()\n}\n\nfunc DiffValues(a, b interface{}) string ", "output": "{\n\tprinter := colour.String()\n\tdiff := diffmatchpatch.New()\n\tat := repr.String(a, repr.OmitEmpty())\n\tbt := repr.String(b, repr.OmitEmpty())\n\tdiffs := diff.DiffMain(at, bt, true)\n\tfor _, d := range diffs {\n\t\tswitch d.Type {\n\t\tcase diffmatchpatch.DiffEqual:\n\t\t\tif len(d.Text) <= 40 {\n\t\t\t\tprinter.Print(d.Text)\n\t\t\t} else {\n\t\t\t\tprinter.Printf(\"%s^B...^R%s\", d.Text[:15], d.Text[len(d.Text)-15:])\n\t\t\t}\n\t\tcase diffmatchpatch.DiffDelete:\n\t\t\tprinter.Printf(\"^9%s^R\", d.Text)\n\t\tcase diffmatchpatch.DiffInsert:\n\t\t\tprinter.Printf(\"^a%s^R\", d.Text)\n\t\t}\n\t}\n\treturn printer.String()\n}"}
{"input": "package signature\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"log\"\n\n\t\"github.com/cloudfoundry/dropsonde/metrics\"\n)\n\nconst SIGNATURE_LENGTH = 32\n\n\n\ntype Verifier struct {\n\tsharedSecret string\n}\n\n\n\nfunc NewVerifier(sharedSecret string) *Verifier {\n\treturn &Verifier{\n\t\tsharedSecret: sharedSecret,\n\t}\n}\n\n\n\n\n\n\n\n\nfunc (v *Verifier) Run(inputChan <-chan []byte, outputChan chan<- []byte) {\n\tfor signedMessage := range inputChan {\n\t\tif len(signedMessage) < SIGNATURE_LENGTH {\n\t\t\tlog.Print(\"signatureVerifier: missing signature\")\n\t\t\tcontinue\n\t\t}\n\n\t\tsignature, message := signedMessage[:SIGNATURE_LENGTH], signedMessage[SIGNATURE_LENGTH:]\n\t\tif v.verifyMessage(message, signature) {\n\t\t\toutputChan <- message\n\t\t\tmetrics.BatchIncrementCounter(\"signatureVerifier.validSignatures\")\n\t\t} else {\n\t\t\tlog.Print(\"signatureVerifier: invalid signature\")\n\t\t}\n\t}\n}\n\nfunc (v *Verifier) verifyMessage(message, signature []byte) bool {\n\texpectedMAC := generateSignature(message, []byte(v.sharedSecret))\n\treturn hmac.Equal(signature, expectedMAC)\n}\n\n\n\nfunc SignMessage(message, secret []byte) []byte {\n\tsignature := generateSignature(message, secret)\n\treturn append(signature, message...)\n}\n\n\n\nfunc generateSignature(message, secret []byte) []byte ", "output": "{\n\tmac := hmac.New(sha256.New, secret)\n\tmac.Write(message)\n\treturn mac.Sum(nil)\n}"}
{"input": "package font\n\nimport (\n\t\"github.com/golang/freetype/truetype\"\n\t\"golang.org/x/image/font\"\n\t\"golang.org/x/image/font/gofont/gobold\"\n\t\"golang.org/x/image/font/gofont/goitalic\"\n\t\"golang.org/x/image/font/gofont/goregular\"\n\n\t\"github.com/tanema/amore/file\"\n)\n\n\ntype Face font.Face\n\n\nfunc NewTTFFace(filepath string, size float32) (font.Face, error) {\n\tfontBytes, err := file.Read(filepath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ttfFromBytes(fontBytes, size)\n}\n\n\nfunc Bold(fontSize float32) (font.Face, error) {\n\treturn ttfFromBytes(gobold.TTF, fontSize)\n}\n\n\nfunc Default(fontSize float32) (font.Face, error) {\n\treturn ttfFromBytes(goregular.TTF, fontSize)\n}\n\n\nfunc Italic(fontSize float32) (font.Face, error) {\n\treturn ttfFromBytes(goitalic.TTF, fontSize)\n}\n\n\n\nfunc ttfFromBytes(fontBytes []byte, size float32) (font.Face, error) ", "output": "{\n\tttf, err := truetype.Parse(fontBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn truetype.NewFace(ttf, &truetype.Options{\n\t\tSize:              float64(size),\n\t\tGlyphCacheEntries: 1,\n\t}), nil\n}"}
{"input": "package main\n\nimport \"fmt\"\n\n\n\nfunc main() {\n\ts1 := []string{\"a\", \"\", \"b\", \"\", \"c\", \"\"}\n\ts2 := []string{\"a\", \"\", \"b\", \"\", \"c\", \"\"}\n\ts3 := nonempty(s1)\n\ts4 := nonempty2(s2)\n\tfmt.Printf(\"%q\\n\", s3) \n\tfmt.Printf(\"%q\\n\", s4) \n}\n\nfunc nonempty(strings []string) []string {\n\ti := 0\n\tfor _, s := range strings {\n\t\tif s != \"\" {\n\t\t\tstrings[i] = s\n\t\t\ti++\n\t\t}\n\t}\n\treturn strings[:i]\n}\n\n\n\nfunc nonempty2(strings []string) []string ", "output": "{\n\tout := strings[:0]\n\tfor _, s := range strings {\n\t\tif s != \"\" {\n\t\t\tout = append(out, s)\n\t\t}\n\t}\n\treturn out\n}"}
{"input": "package clients\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/VolantMQ/volantmq/subscriber\"\n)\n\nvar subCount int32 = 0\n\n\n\ntype container struct {\n\tlock      sync.Mutex\n\trmLock    sync.RWMutex\n\tses       *session\n\texpiry    atomic.Value\n\tsub       *subscriber.Type\n\tremovable bool\n\tremoved   bool\n}\n\nfunc (s *container) setRemovable(rm bool) {\n\ts.rmLock.Lock()\n\ts.removable = rm\n\ts.rmLock.Unlock()\n}\n\nfunc (s *container) acquire() {\n\ts.lock.Lock()\n}\n\n\n\nfunc (s *container) session() *session {\n\tdefer s.rmLock.Unlock()\n\ts.rmLock.Lock()\n\treturn s.ses\n}\n\nfunc (s *container) swap(from *container) *container {\n\ts.ses = from.ses\n\n\ts.ses.idLock = &s.lock\n\n\treturn s\n}\n\nfunc (s *container) subscriber(cleanStart bool, c subscriber.Config) *subscriber.Type {\n\tif cleanStart && s.sub != nil {\n\t\ts.sub.Offline(true)\n\t\ts.sub = nil\n\t}\n\n\tif s.sub == nil {\n\t\ts.sub = subscriber.New(c)\n\t}\n\n\treturn s.sub\n}\n\nfunc (s *container) release() ", "output": "{\n\ts.lock.Unlock()\n}"}
{"input": "package sctp\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n)\n\ntype paramHeader struct {\n\ttyp paramType\n\tlen int\n\traw []byte\n}\n\nconst (\n\tparamHeaderLength = 4\n)\n\nfunc (p *paramHeader) marshal() ([]byte, error) {\n\tparamLengthPlusHeader := paramHeaderLength + len(p.raw)\n\n\trawParam := make([]byte, paramLengthPlusHeader)\n\tbinary.BigEndian.PutUint16(rawParam[0:], uint16(p.typ))\n\tbinary.BigEndian.PutUint16(rawParam[2:], uint16(paramLengthPlusHeader))\n\tcopy(rawParam[paramHeaderLength:], p.raw)\n\n\treturn rawParam, nil\n}\n\nfunc (p *paramHeader) unmarshal(raw []byte) {\n\tparamLengthPlusHeader := binary.BigEndian.Uint16(raw[2:])\n\tparamLength := paramLengthPlusHeader - initOptionalVarHeaderLength\n\n\tp.typ = paramType(binary.BigEndian.Uint16(raw[0:]))\n\tp.raw = raw[paramHeaderLength : paramHeaderLength+paramLength]\n\tp.len = int(paramLengthPlusHeader)\n}\n\nfunc (p *paramHeader) length() int {\n\treturn p.len\n}\n\n\n\n\nfunc (p paramHeader) String() string ", "output": "{\n\treturn fmt.Sprintf(\"%s (%d): %s\", p.typ, p.len, p.raw)\n}"}
{"input": "package report\n\nimport \"testing\"\n\n\n\nfunc TestPercentiles(t *testing.T) ", "output": "{\n\tnums := make([]float64, 100)\n\tnums[99] = 1 \n\tdata := percentiles(nums)\n\tif data[len(pctls)-2] != 1 {\n\t\tt.Fatalf(\"99-percentile expected 1, got %f\", data[len(pctls)-2])\n\t}\n\n\tnums = make([]float64, 1000)\n\tnums[999] = 1 \n\tdata = percentiles(nums)\n\tif data[len(pctls)-1] != 1 {\n\t\tt.Fatalf(\"99.9-percentile expected 1, got %f\", data[len(pctls)-1])\n\t}\n}"}
{"input": "package syscall\n\nfunc Getpagesize() int { return 4096 }\n\nfunc TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }\n\nfunc NsecToTimespec(nsec int64) (ts Timespec) {\n\tts.Sec = int64(nsec / 1e9)\n\tts.Nsec = int32(nsec % 1e9)\n\treturn\n}\n\nfunc TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }\n\nfunc NsecToTimeval(nsec int64) (tv Timeval) {\n\tnsec += 999 \n\ttv.Usec = int32(nsec % 1e9 / 1e3)\n\ttv.Sec = int64(nsec / 1e9)\n\treturn\n}\n\nfunc SetKevent(k *Kevent_t, fd, mode, flags int) {\n\tk.Ident = uint32(fd)\n\tk.Filter = uint32(mode)\n\tk.Flags = uint32(flags)\n}\n\nfunc (iov *Iovec) SetLen(length int) {\n\tiov.Len = uint32(length)\n}\n\n\n\nfunc (cmsg *Cmsghdr) SetLen(length int) {\n\tcmsg.Len = uint32(length)\n}\n\nfunc (msghdr *Msghdr) SetControllen(length int) ", "output": "{\n\tmsghdr.Controllen = uint32(length)\n}"}
{"input": "package nodes\n\nimport (\n\t\"encoding/json\"\n\t\"sync\"\n)\n\n\ntype Name struct {\n\tTaxID string     `json:\"TaxID\"`\n\tNames []NameItem `json:\"Names\"`\n}\n\n\ntype NameItem struct {\n\tName       string `json:\"Name\"`\n\tUniqueName string `json:\"UniqueName\"`\n\tNameClass  string `json:\"NameClass\"`\n}\n\n\nfunc (name Name) ToJSON() (string, error) {\n\ts, err := json.Marshal(name)\n\treturn string(s), err\n}\n\n\nfunc NameFromJSON(s string) (Name, error) {\n\tvar name Name\n\terr := json.Unmarshal([]byte(s), &name)\n\treturn name, err\n}\n\n\nfunc NameFromArgs(items []string) Name {\n\tif len(items) != 4 {\n\t\treturn Name{}\n\t}\n\n\treturn Name{\n\t\tTaxID: items[0],\n\t\tNames: []NameItem{\n\t\t\tNameItem{\n\t\t\t\tName:       items[1],\n\t\t\t\tUniqueName: items[2],\n\t\t\t\tNameClass:  items[3],\n\t\t\t}},\n\t}\n}\n\n\n\n\n\nvar Names map[string]Name\n\nvar mutex1 = &sync.Mutex{}\n\n\nfunc SetNames(names map[string]Name) {\n\tmutex1.Lock()\n\tNames = names\n\tmutex1.Unlock()\n}\n\nfunc MergeNames(names ...Name) Name ", "output": "{\n\tif len(names) < 2 {\n\t\treturn names[0]\n\t}\n\tname := names[0]\n\tfor _, another := range names[1:] {\n\t\tif another.TaxID != name.TaxID {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, anotherNameItem := range another.Names {\n\t\t\tname.Names = append(name.Names, anotherNameItem)\n\t\t}\n\t}\n\treturn name\n}"}
{"input": "package store\n\nimport \"strings\"\n\n\ntype ByPathLen []string\n\nfunc (s ByPathLen) Len() int { return len(s) }\n\n\n\nfunc (s ByPathLen) Swap(i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\n\ntype ByLen []string\n\n\nfunc (s ByLen) Len() int { return len(s) }\n\n\nfunc (s ByLen) Less(i, j int) bool { return len(s[i]) > len(s[j]) }\n\n\nfunc (s ByLen) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\n\nfunc (s ByPathLen) Less(i, j int) bool ", "output": "{\n\treturn strings.Count(s[i], \"/\") < strings.Count(s[j], \"/\")\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"flag\"\n\t\"io/ioutil\"\n\t\"log\"\n\n\t\"github.com/davars/sohop\"\n)\n\nvar (\n\tconfigPath string\n\thttpAddr   string\n\thttpsAddr  string\n)\n\n\n\nfunc newConfig() *sohop.Config {\n\tflag.StringVar(&configPath, \"config\", \"config.json\", \"Config file\")\n\tflag.StringVar(&httpAddr, \"httpAddr\", \":80\", \"Address to bind HTTP server\")\n\tflag.StringVar(&httpsAddr, \"httpsAddr\", \":443\", \"Address to bind HTTPS server\")\n\tflag.Parse()\n\n\tconfigData, err := ioutil.ReadFile(configPath)\n\tcheck(err)\n\n\tc := &sohop.Config{}\n\terr = json.Unmarshal(configData, c)\n\tcheck(err)\n\n\treturn c\n}\n\nfunc main() {\n\tsohop.Server{\n\t\tConfig:    newConfig(),\n\t\tHTTPAddr:  httpAddr,\n\t\tHTTPSAddr: httpsAddr,\n\t}.Run()\n}\n\nfunc check(err error) ", "output": "{\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"input": "package chipmunk\n\nimport \"github.com/dataarts/chipmunk/vect\"\n\nconst (\n\terrorBias = 0.00179701029991443 \n)\n\ntype ConstraintCallback interface {\n\tCollisionPreSolve(constraint Constraint)\n\tCollisionPostSolve(constraint Constraint)\n}\n\ntype Constraint interface {\n\tConstraint() *BasicConstraint\n\tPreSolve()\n\tPostSolve()\n\tPreStep(dt vect.Float)\n\tApplyCachedImpulse(dt_coef vect.Float)\n\tApplyImpulse()\n\tImpulse() vect.Float\n}\n\ntype BasicConstraint struct {\n\tBodyA, BodyB    *Body\n\tspace           *Space\n\tMaxForce        vect.Float\n\tErrorBias       vect.Float\n\tMaxBias         vect.Float\n\tCallbackHandler ConstraintCallback\n\tUserData        Data\n}\n\nfunc NewConstraint(a, b *Body) BasicConstraint {\n\treturn BasicConstraint{BodyA: a, BodyB: b, MaxForce: Inf, MaxBias: Inf, ErrorBias: errorBias}\n}\n\nfunc (this *BasicConstraint) Constraint() *BasicConstraint {\n\treturn this\n}\n\n\n\nfunc (this *BasicConstraint) ApplyCachedImpulse(dt_coef vect.Float) {\n\tpanic(\"empty constraint\")\n}\n\nfunc (this *BasicConstraint) ApplyImpulse() {\n\tpanic(\"empty constraint\")\n}\n\nfunc (this *BasicConstraint) Impulse() vect.Float {\n\tpanic(\"empty constraint\")\n}\n\nfunc (this *BasicConstraint) PreSolve() {\n\tif this.CallbackHandler != nil {\n\t\tthis.CallbackHandler.CollisionPreSolve(this)\n\t}\n}\n\nfunc (this *BasicConstraint) PostSolve() {\n\tif this.CallbackHandler != nil {\n\t\tthis.CallbackHandler.CollisionPostSolve(this)\n\t}\n}\n\nfunc (this *BasicConstraint) PreStep(dt vect.Float) ", "output": "{\n\tpanic(\"empty constraint\")\n}"}
{"input": "package service\n\nimport (\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\n\n\nfunc Test_QueryUserInfo(t *testing.T) ", "output": "{\n\tConvey(\"query user or create user\", t, func() {\n\t\t_, err := s.QueryUser(\"zhanglu\")\n\t\tSo(err, ShouldBeNil)\n\t})\n}"}
{"input": "package cloudtail\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\n\n\nfunc TestPipeFromReader(t *testing.T) ", "output": "{\n\tConvey(\"Works\", t, func() {\n\t\tclient := &fakeClient{}\n\t\tbuf := NewPushBuffer(PushBufferOptions{Client: client})\n\n\t\tbody := `\n    line\n        another\n\n    last one\n    `\n\n\t\tPipeFromReader(strings.NewReader(body), NullParser(), buf, nil)\n\t\tSo(buf.Stop(nil), ShouldBeNil)\n\n\t\ttext := []string{}\n\t\tfor _, e := range client.getEntries() {\n\t\t\ttext = append(text, e.TextPayload)\n\t\t}\n\t\tSo(text, ShouldResemble, []string{\"line\", \"another\", \"last one\"})\n\t})\n}"}
{"input": "package types\n\nimport (\n\t\"net\"\n)\n\n\ntype IPv4 [4]byte\n\n\n\nfunc (v4 IPv4) String() string {\n\treturn v4.IP().String()\n}\n\n\nfunc (v4 *IPv4) DeepCopyInto(out *IPv4) {\n\tcopy(out[:], v4[:])\n\treturn\n}\n\nfunc (v4 IPv4) IP() net.IP ", "output": "{\n\treturn v4[:]\n}"}
{"input": "package store\n\nimport (\n\t\"github.com/docker/docker/pkg/plugins\"\n)\n\n\nfunc FindWithCapability(capability string) ([]CompatPlugin, error) {\n\tpl, err := plugins.GetAll(capability)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := make([]CompatPlugin, len(pl))\n\tfor i, p := range pl {\n\t\tresult[i] = p\n\t}\n\treturn result, nil\n}\n\n\n\n\nfunc LookupWithCapability(name, capability string, _ int) (CompatPlugin, error) ", "output": "{\n\treturn plugins.Get(name, capability)\n}"}
{"input": "package GoPolygons\n\nimport (\n\t\"math\"\n)\n\n\ntype Point struct {\n\tX float64\n\tY float64\n}\n\n\n\n\nfunc (pt Point) IsSame(p Point) bool {\n\treturn pt.X == p.X && pt.Y == p.Y\n}\n\n\nfunc (pt Point) GetDistance(p Point) float64 {\n\tx := p.X - pt.X\n\ty := p.Y - pt.Y\n\treturn math.Sqrt(math.Pow(x, 2) + math.Pow(y, 2))\n}\n\n\nfunc (pt Point) GetBearing(p Point) float64 {\n\tx := pt.X - p.X\n\ty := pt.Y - p.Y\n\treturn math.Atan2(y, x) * 180.0 / math.Pi\n}\n\nfunc NewPoint(x float64, y float64) Point ", "output": "{\n\treturn Point{X: x, Y: y}\n}"}
{"input": "package member\n\nimport (\n\t\"github.com/watermint/toolbox/domain/dropbox/api/dbx_auth\"\n\t\"github.com/watermint/toolbox/domain/dropbox/api/dbx_conn\"\n\t\"github.com/watermint/toolbox/domain/dropbox/model/mo_path\"\n\t\"github.com/watermint/toolbox/domain/dropbox/service/sv_sharedfolder_member\"\n\t\"github.com/watermint/toolbox/domain/dropbox/usecase/uc_sharedfolder\"\n\t\"github.com/watermint/toolbox/infra/control/app_control\"\n\t\"github.com/watermint/toolbox/infra/recipe/rc_exec\"\n\t\"github.com/watermint/toolbox/infra/recipe/rc_recipe\"\n\t\"github.com/watermint/toolbox/quality/recipe/qtr_endtoend\"\n)\n\ntype Delete struct {\n\tPeer      dbx_conn.ConnScopedIndividual\n\tPath      mo_path.DropboxPath\n\tEmail     string\n\tLeaveCopy bool\n}\n\nfunc (z *Delete) Preset() {\n\tz.Peer.SetScopes(\n\t\tdbx_auth.ScopeFilesContentRead,\n\t\tdbx_auth.ScopeSharingRead,\n\t\tdbx_auth.ScopeSharingWrite,\n\t)\n}\n\n\n\nfunc (z *Delete) Test(c app_control.Control) error {\n\treturn rc_exec.ExecMock(c, &Delete{}, func(r rc_recipe.Recipe) {\n\t\tm := r.(*Delete)\n\t\tm.Email = \"emma@example.com\"\n\t\tm.Path = qtr_endtoend.NewTestDropboxFolderPath(\"delete\")\n\t})\n}\n\nfunc (z *Delete) Exec(c app_control.Control) error ", "output": "{\n\tsfr := uc_sharedfolder.NewResolver(z.Peer.Context())\n\n\tsf, err := sfr.Resolve(z.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\topts := make([]sv_sharedfolder_member.RemoveOption, 0)\n\tif z.LeaveCopy {\n\t\topts = append(opts, sv_sharedfolder_member.LeaveACopy())\n\t}\n\terr = sv_sharedfolder_member.New(z.Peer.Context(), sf).Remove(sv_sharedfolder_member.RemoveByEmail(z.Email), opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package core\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/splicers/elastigo/api\"\n)\n\n\n\n\n\ntype MoreLikeThisQuery struct {\n\tMoreLikeThis MLT `json:\"more_like_this\"`\n}\n\ntype MLT struct {\n\tFields              []string `json:\"fields\"`\n\tLikeText            string   `json:\"like_text\"`\n\tPercentTermsToMatch float32  `json:\"percent_terms_to_match\"`\n\tMinTermFrequency    int      `json:\"min_term_freq\"`\n\tMaxQueryTerms       int      `json:\"max_query_terms\"`\n\tStopWords           []string `json:\"stop_words\"`\n\tMinDocFrequency     int      `json:\"min_doc_freq\"`\n\tMaxDocFrequency     int      `json:\"max_doc_freq\"`\n\tMinWordLength       int      `json:\"min_word_len\"`\n\tMaxWordLength       int      `json:\"max_word_len\"`\n\tBoostTerms          int      `json:\"boost_terms\"`\n\tBoost               float32  `json:\"boost\"`\n\tAnalyzer            string   `json:\"analyzer\"`\n}\n\nfunc MoreLikeThis(index string, _type string, id string, args map[string]interface{}, query MoreLikeThisQuery) (api.BaseResponse, error) ", "output": "{\n\tvar url string\n\tvar retval api.BaseResponse\n\turl = fmt.Sprintf(\"/%s/%s/%s/_mlt\", index, _type, id)\n\tbody, err := api.DoCommand(\"GET\", url, args, query)\n\tif err != nil {\n\t\treturn retval, err\n\t}\n\tif err == nil {\n\t\tjsonErr := json.Unmarshal(body, &retval)\n\t\tif jsonErr != nil {\n\t\t\treturn retval, jsonErr\n\t\t}\n\t}\n\treturn retval, err\n}"}
{"input": "package rpcd\n\nimport (\n\t\"runtime\"\n\n\t\"github.com/Cloud-Foundations/Dominator/lib/srpc\"\n\t\"github.com/Cloud-Foundations/Dominator/objectserver/rpcd/lib\"\n)\n\n\n\nfunc (t *srpcType) AddObjects(conn *srpc.Conn) error ", "output": "{\n\tdefer runtime.GC() \n\tif t.replicationMaster == \"\" {\n\t\treturn lib.AddObjects(conn, conn, conn, t.objectServer, t.logger)\n\t}\n\treturn lib.AddObjectsWithMaster(conn, conn, conn, t.objectServer,\n\t\tt.replicationMaster, t.logger)\n}"}
{"input": "package main\n\nimport (\n\tlogpkg \"github.com/ckeyer/go-log\"\n)\n\nvar log *logpkg.Logger\n\n\n\nfunc init() ", "output": "{\n\tlog = logpkg.GetDefaultLogger()\n}"}
{"input": "package dao\n\nimport (\n\t\"flag\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"go-common/app/interface/main/web/conf\"\n\n\t\"gopkg.in/h2non/gock.v1\"\n)\n\nvar (\n\td *Dao\n)\n\nfunc TestMain(m *testing.M) {\n\tif os.Getenv(\"DEPLOY_ENV\") != \"local\" {\n\t\tflag.Set(\"app_id\", \"main.web-svr.web-interface\")\n\t\tflag.Set(\"conf_token\", \"bc99caee81f27661bd5ff50d1c0d58d6\")\n\t\tflag.Set(\"tree_id\", \"2685\")\n\t\tflag.Set(\"conf_version\", \"docker-1\")\n\t\tflag.Set(\"deploy_env\", \"uat\")\n\t\tflag.Set(\"conf_host\", \"config.bilibili.co\")\n\t\tflag.Set(\"conf_path\", \"/tmp\")\n\t\tflag.Set(\"region\", \"sh\")\n\t\tflag.Set(\"zone\", \"sh001\")\n\t} else {\n\t\tflag.Set(\"conf\", \"../cmd/web-interface-test.toml\")\n\t}\n\tflag.Parse()\n\tif err := conf.Init(); err != nil {\n\t\tpanic(err)\n\t}\n\td = New(conf.Conf)\n\td.httpR.SetTransport(gock.DefaultTransport)\n\td.httpBigData.SetTransport(gock.DefaultTransport)\n\td.httpHelp.SetTransport(gock.DefaultTransport)\n\tos.Exit(m.Run())\n}\n\n\n\nfunc httpMock(method, url string) *gock.Request ", "output": "{\n\tr := gock.New(url)\n\tr.Method = strings.ToUpper(method)\n\treturn r\n}"}
{"input": "package doctor\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestOk(t *testing.T) {\n\tinitializingStatus := HealthcheckStatusInitializing\n\tokStatus := HealthcheckStatusOk\n\timpairedStatus := HealthcheckStatusImpaired\n\tassert.True(t, initializingStatus.Ok())\n\tassert.True(t, okStatus.Ok())\n\tassert.False(t, impairedStatus.Ok())\n}\n\ntype testHealthcheckStatus struct {\n\tSomeStatus HealthcheckStatus `json:\"status\"`\n}\n\n\n\nfunc TestUnmarshalHealthcheckStatus(t *testing.T) ", "output": "{\n\tstatus := HealthcheckStatusInitializing\n\n\terr := json.Unmarshal([]byte(`\"INITIALIZING\"`), &status)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif status != HealthcheckStatusInitializing {\n\t\tt.Error(\"INITIALIZING should unmarshal to INITIALIZING, not \" + status.String())\n\t}\n\n\tvar test testHealthcheckStatus\n\terr = json.Unmarshal([]byte(`{\"status\":\"IMPAIRED\"}`), &test)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif test.SomeStatus != HealthcheckStatusImpaired {\n\t\tt.Error(\"IMPAIRED should unmarshal to IMPAIRED, not \" + test.SomeStatus.String())\n\t}\n}"}
{"input": "package go9p\n\nimport (\n\t\"github.com/lionkov/go9p/p/srv\"\n)\n\nfunc lazysetupChan(C *chan *srv.Conn) {\n\tif *C == nil {\n\t\t*C = make(chan *srv.Conn)\n\t}\n}\n\nfunc AddConnOps(s *srv.Srv) *ConnOps {\n\tco := new(ConnOps)\n\tco.Srv = s\n\treturn co\n\n}\n\ntype ConnOps struct {\n\t*srv.Srv\n\tclosedC, openedC chan *srv.Conn\n}\n\n\n\nfunc (o *ConnOps) ClosedC() (c chan *srv.Conn) {\n\tlazysetupChan(&o.closedC)\n\treturn o.closedC\n}\n\nfunc (o *ConnOps) ConnOpened(c *srv.Conn) {\n\tif o.openedC != nil {\n\t\to.openedC <- c\n\t}\n}\n\nfunc (o *ConnOps) ConnClosed(c *srv.Conn) {\n\tif o.closedC != nil {\n\t\to.closedC <- c\n\t}\n}\n\nfunc (o *ConnOps) OpenedC() (c chan *srv.Conn) ", "output": "{\n\tlazysetupChan(&o.openedC)\n\treturn o.openedC\n}"}
{"input": "package server\n\nimport \"golang.org/x/crypto/bcrypt\"\n\n\n\n\n\n\nfunc MatchPassword(password string, hashedPassword string) (bool, error) {\n\terr := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn err == nil, err\n}\n\nfunc createHashedPassword(password string) (string, error) ", "output": "{\n\thash, err := bcrypt.GenerateFromPassword([]byte(password), 11)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\n\treturn string(hash), err\n}"}
{"input": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestMoveBlanksToEnd(t *testing.T) ", "output": "{\n\tassert.Equal(t, moveBlanksToEnd(\"?\"), \"?\")\n\tassert.Equal(t, moveBlanksToEnd(\"I?\"), \"I?\")\n\tassert.Equal(t, moveBlanksToEnd(\"?AB?C\"), \"ABC??\")\n\tassert.Equal(t, moveBlanksToEnd(\"??\"), \"??\")\n\tassert.Equal(t, moveBlanksToEnd(\"?FED\"), \"FED?\")\n\tassert.Equal(t, moveBlanksToEnd(\"X?X\"), \"XX?\")\n}"}
{"input": "package mongodb\n\nimport \"github.com/gaeshi-gaeshi/thermo-smart/data/models\"\n\n\n\ntype TemperaturesRepository struct {\n\tcontext *Context\n}\n\nfunc (self *TemperaturesRepository) Find(query *Query) []models.Temperature {\n\tvar result []models.Temperature\n\tquery.mongoQuery.All(&result)\n\n\treturn result\n}\n\nfunc (self *TemperaturesRepository) Insert(item *models.Temperature) error {\n\terr := self.context.Temperatures().Insert(item)\n\treturn err\n}\n\nfunc (self *TemperaturesRepository) InitQuery() *Query {\n\treturn NewQuery(self.context.Temperatures())\n}\n\nfunc NewTemperaturesRepository(c *Context) *TemperaturesRepository ", "output": "{\n\treturn &TemperaturesRepository{\n\t\tcontext: c,\n\t}\n}"}
{"input": "package adt\n\ntype Stack struct {\n\ttop *Element\n\tsize int\n}\n \ntype Element struct {\n\tvalue interface{} \n\tnext *Element\n}\n\n\nfunc NewStack() *Stack {\n\treturn new(Stack)\n\n}\n\n\nfunc (s *Stack) Len() int {\n\treturn s.size\n}\n\n\n\n\n\nfunc (s *Stack) Push(value interface{}) {\n\ts.top = &Element{value, s.top}\n\ts.size++\n}\n \n\n\nfunc (s *Stack) Pop() (value interface{}) {\n\tif s.size > 0 {\n\t\tvalue, s.top = s.top.value, s.top.next\n\t\ts.size--\n\t\treturn\n\t}\n\treturn nil\n}\n\nfunc (s *Stack) IsEmpty() bool ", "output": "{\n\treturn s.Len()==0\n}"}
{"input": "package main\n\nimport \"testing\"\n\n\n\nfunc TestStartPortNumber(t *testing.T) ", "output": "{\n\n\ttype assert struct {\n\t\tcurrentProcs []*Proc\n\t\texpect       int\n\t}\n\n\tasserts := []assert{\n\t\tassert{\n\t\t\tcurrentProcs: nil,\n\t\t\texpect:       8000,\n\t\t},\n\t\tassert{\n\t\t\tcurrentProcs: []*Proc{&Proc{Port: 8000}},\n\t\t\texpect:       9000,\n\t\t},\n\t\tassert{\n\t\t\tcurrentProcs: []*Proc{&Proc{Port: 9000}},\n\t\t\texpect:       8000,\n\t\t},\n\t}\n\n\tfor _, a := range asserts {\n\t\tport := Service{OldProcs: a.currentProcs}.startPortNumber()\n\t\tif port != a.expect {\n\t\t\tt.Errorf(\"port should be %d, but %d\", a.expect, port)\n\t\t}\n\t}\n\n}"}
{"input": "package graphics\n\nfunc MaxF(x1, x2 float32) float32 {\n\tif x1 > x2 {\n\t\treturn x1\n\t}\n\treturn x2\n}\n\nfunc MinF(x1, x2 float32) float32 {\n\tif x1 < x2 {\n\t\treturn x1\n\t}\n\treturn x2\n}\n\n\n\n\n\nfunc Cos2Atan(d float32) float32 {\n\treturn (1.0 - d*d) / (1.0 + d*d)\n}\n\nfunc Sin2Atan(d float32) float32 ", "output": "{\n\treturn 2.0 * d / (1.0 + d*d)\n}"}
{"input": "package main\n\nimport (\n  \"fmt\"\n  _ \"github.com/lib/pq\"\n)\n\nfunc checkReferralID(referral_id string) bool {\n  fmt.Println(\"Checking for valid referral_id:\", referral_id)\n  var count int8\n  if referral_id == \"\"{\n    return true\n  }\n  db.QueryRow(\"SELECT COUNT(*) FROM referral WHERE referral_id=$1\",referral_id).Scan(&count)\n  if count == 0 {\n    return false\n  }else{\n    return true\n  }\n}\n\n\n\nfunc createReferralID(referral_id, wallet_id string)  bool{\n  fmt.Println(\"Creating ReferralID\",referral_id, wallet_id)\n  db.QueryRow(\"INSERT INTO referral(referral_id, referral_count, wallet_id) VALUES($1,$2,$3);\",referral_id, 0, wallet_id)\n  return true\n}\n\nfunc updateReferralTable(referral_id string) string", "output": "{\n  var count int8\n  db.QueryRow(\"SELECT referral_count FROM referral WHERE referral_id=$1\",referral_id).Scan(&count)\n  count++\n  db.QueryRow(\"UPDATE referral SET referral_count=$1 where referral_id=$2\", count, referral_id)\n  var wallet_id string\n  db.QueryRow(\"SELECT wallet_id FROM referral WHERE referral_id=$1\",referral_id).Scan(&wallet_id)\n  return wallet_id\n}"}
{"input": "package abi\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n\n\n\n\n\n\nfunc reflectIntKind(unsigned bool, size int) reflect.Kind {\n\tswitch size {\n\tcase 8:\n\t\tif unsigned {\n\t\t\treturn reflect.Uint8\n\t\t}\n\t\treturn reflect.Int8\n\tcase 16:\n\t\tif unsigned {\n\t\t\treturn reflect.Uint16\n\t\t}\n\t\treturn reflect.Int16\n\tcase 32:\n\t\tif unsigned {\n\t\t\treturn reflect.Uint32\n\t\t}\n\t\treturn reflect.Int32\n\tcase 64:\n\t\tif unsigned {\n\t\t\treturn reflect.Uint64\n\t\t}\n\t\treturn reflect.Int64\n\t}\n\treturn reflect.Ptr\n}\n\n\n\nfunc mustArrayToByteSlice(value reflect.Value) reflect.Value {\n\tslice := reflect.MakeSlice(reflect.TypeOf([]byte{}), value.Len(), value.Len())\n\treflect.Copy(slice, value)\n\treturn slice\n}\n\n\n\n\n\nfunc set(dst, src reflect.Value, output Argument) error {\n\tdstType := dst.Type()\n\tsrcType := src.Type()\n\n\tswitch {\n\tcase dstType.AssignableTo(src.Type()):\n\t\tdst.Set(src)\n\tcase dstType.Kind() == reflect.Array && srcType.Kind() == reflect.Slice:\n\t\tif dst.Len() < output.Type.SliceSize {\n\t\t\treturn fmt.Errorf(\"abi: cannot unmarshal src (len=%d) in to dst (len=%d)\", output.Type.SliceSize, dst.Len())\n\t\t}\n\t\treflect.Copy(dst, src)\n\tcase dstType.Kind() == reflect.Interface:\n\t\tdst.Set(src)\n\tcase dstType.Kind() == reflect.Ptr:\n\t\treturn set(dst.Elem(), src, output)\n\tdefault:\n\t\treturn fmt.Errorf(\"abi: cannot unmarshal %v in to %v\", src.Type(), dst.Type())\n\t}\n\treturn nil\n}\n\nfunc indirect(v reflect.Value) reflect.Value ", "output": "{\n\tif v.Kind() == reflect.Ptr && v.Elem().Type() != big_t {\n\t\treturn indirect(v.Elem())\n\t}\n\treturn v\n}"}
{"input": "package method\n\nimport \"github.com/drgomesp/cargo/argument\"\n\n\ntype Method struct {\n\tName string\n\tArgs []*argument.Argument\n}\n\n\n\n\nfunc New(name string, args ...interface{}) *Method ", "output": "{\n\targuments := make([]*argument.Argument, len(args))\n\n\tfor i, arg := range args {\n\t\targuments[i] = argument.New(arg)\n\t}\n\n\treturn &Method{\n\t\tName: name,\n\t\tArgs: arguments,\n\t}\n}"}
{"input": "package util\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc SortAndUnique(data sort.Interface) int {\n\tsort.Sort(data)\n\treturn Unique(data)\n}\n\n\n\nfunc UniqueStrings(strings []string) []string {\n\treturn strings[:SortAndUnique(sort.StringSlice(strings))]\n}\n\nfunc Unique(data sort.Interface) int ", "output": "{\n\tif !sort.IsSorted(data) {\n\t\tpanic(fmt.Errorf(\"util: the input to Unique() must be sorted\"))\n\t}\n\n\tif data.Len() == 0 {\n\t\treturn 0\n\t}\n\tlength := data.Len()\n\tj := 0\n\tfor i := 1; i < length; i++ {\n\t\tif data.Less(i-1, i) {\n\t\t\tdata.Swap(i-1, j)\n\t\t\tj++\n\t\t}\n\t}\n\tdata.Swap(length-1, j)\n\treturn j + 1\n}"}
{"input": "package remotecommand\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/util/runtime\"\n)\n\n\n\ntype streamProtocolV3 struct {\n\t*streamProtocolV2\n\n\tresizeStream io.Writer\n}\n\nvar _ streamProtocolHandler = &streamProtocolV3{}\n\nfunc newStreamProtocolV3(options StreamOptions) streamProtocolHandler {\n\treturn &streamProtocolV3{\n\t\tstreamProtocolV2: newStreamProtocolV2(options).(*streamProtocolV2),\n\t}\n}\n\nfunc (p *streamProtocolV3) createStreams(conn streamCreator) error {\n\tif err := p.streamProtocolV2.createStreams(conn); err != nil {\n\t\treturn err\n\t}\n\n\tif p.Tty {\n\t\theaders := http.Header{}\n\t\theaders.Set(v1.StreamType, v1.StreamTypeResize)\n\t\tvar err error\n\t\tp.resizeStream, err = conn.CreateStream(headers)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (p *streamProtocolV3) handleResizes() {\n\tif p.resizeStream == nil || p.TerminalSizeQueue == nil {\n\t\treturn\n\t}\n\tgo func() {\n\t\tdefer runtime.HandleCrash()\n\n\t\tencoder := json.NewEncoder(p.resizeStream)\n\t\tfor {\n\t\t\tsize := p.TerminalSizeQueue.Next()\n\t\t\tif size == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := encoder.Encode(&size); err != nil {\n\t\t\t\truntime.HandleError(err)\n\t\t\t}\n\t\t}\n\t}()\n}\n\n\n\ntype errorDecoderV3 struct {\n\terrorDecoderV2\n}\n\nfunc (p *streamProtocolV3) stream(conn streamCreator) error ", "output": "{\n\tif err := p.createStreams(conn); err != nil {\n\t\treturn err\n\t}\n\n\n\terrorChan := watchErrorStream(p.errorStream, &errorDecoderV3{})\n\n\tp.handleResizes()\n\n\tp.copyStdin()\n\n\tvar wg sync.WaitGroup\n\tp.copyStdout(&wg)\n\tp.copyStderr(&wg)\n\n\twg.Wait()\n\n\treturn <-errorChan\n}"}
{"input": "package primitives\n\nimport (\n  \"fmt\"\n  . \"github.com/kedebug/LispEx/value\"\n  \"math/rand\"\n  \"time\"\n)\n\ntype Random struct {\n  Primitive\n  rand *rand.Rand\n}\n\nfunc NewRandom() *Random {\n  r := rand.New(rand.NewSource(time.Now().UnixNano()))\n  return &Random{Primitive: Primitive{\"random\"}, rand: r}\n}\n\n\n\nfunc (self *Random) Apply(args []Value) Value ", "output": "{\n  if len(args) != 1 {\n    panic(fmt.Sprint(\"random: argument mismatch, expected 1\"))\n  }\n  if val, ok := args[0].(*IntValue); ok {\n    if val.Value <= 0 {\n      panic(fmt.Sprint(\"random: expected positive integer, given: \", val))\n    }\n    return NewIntValue(self.rand.Int63n(val.Value))\n  }\n  panic(fmt.Sprint(\"random: expected integer?, given: \", args[0]))\n}"}
{"input": "package volumeactions\n\nimport \"github.com/gophercloud/gophercloud\"\n\nfunc attachURL(c *gophercloud.ServiceClient, id string) string {\n\treturn c.ServiceURL(\"volumes\", id, \"action\")\n}\n\nfunc detachURL(c *gophercloud.ServiceClient, id string) string {\n\treturn attachURL(c, id)\n}\n\n\n\nfunc unreserveURL(c *gophercloud.ServiceClient, id string) string {\n\treturn attachURL(c, id)\n}\n\nfunc initializeConnectionURL(c *gophercloud.ServiceClient, id string) string {\n\treturn attachURL(c, id)\n}\n\nfunc teminateConnectionURL(c *gophercloud.ServiceClient, id string) string {\n\treturn attachURL(c, id)\n}\n\nfunc reserveURL(c *gophercloud.ServiceClient, id string) string ", "output": "{\n\treturn attachURL(c, id)\n}"}
{"input": "package libstring\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"net\"\n\t\"os\"\n\t\"os/user\"\n\t\"strings\"\n)\n\n\n\n\n\nfunc ExpandTildeAndEnv(path string) string {\n\tpath = ExpandTilde(path)\n\treturn os.ExpandEnv(path)\n}\n\n\n\nfunc GeneratePassword(size int) (string, error) {\n\tif size < 32 {\n\t\tsize = 32\n\t}\n\n\trb := make([]byte, size)\n\t_, err := rand.Read(rb)\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn base64.URLEncoding.EncodeToString(rb), nil\n}\n\n\nfunc StringInSlice(beingSearched string, list []string) bool {\n\tfor _, b := range list {\n\t\tif b == beingSearched {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc GetIP(address string) net.IP {\n\tsplitAddress := strings.Split(address, \":\")\n\tif len(splitAddress) == 0 {\n\t\treturn nil\n\t}\n\n\treturn net.ParseIP(splitAddress[0])\n}\n\nfunc ExpandTilde(path string) string ", "output": "{\n\tif path == \"\" {\n\t\treturn path\n\t}\n\n\tif path[:2] == \"~/\" {\n\t\tusr, err := user.Current()\n\t\tif err != nil || usr == nil {\n\t\t\treturn path\n\t\t}\n\n\t\tif usr.Name == \"root\" {\n\t\t\tpath = strings.Replace(path, \"~\", \"/root\", 1)\n\t\t} else {\n\t\t\tpath = strings.Replace(path, \"~\", usr.HomeDir, 1)\n\t\t}\n\n\t}\n\treturn path\n}"}
{"input": "package cluster\n\ntype Status struct {\n\tCurrentVersion string `json:\"currentVersion\"`\n\tTargetVersion  string `json:\"targetVersion\"`\n}\n\n\n\nfunc (s *Status) setVersion(v string) {\n\ts.TargetVersion = \"\"\n\ts.CurrentVersion = v\n}\n\nfunc (s *Status) upgradeVersionTo(v string) ", "output": "{\n\ts.TargetVersion = v\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n)\n\n\n\nfunc FileWriter(ch <-chan Res, wg *sync.WaitGroup, filename string) error {\n\tf, err := os.Create(filename)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer f.Close()\n\n\twriter := csv.NewWriter(f)\n\tif err = writer.Write(Config.ResultHeads); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor data := range ch {\n\t\tvalues := make([]string, 0, len(Config.ResultHeads))\n\t\tfor _, k := range Config.ResultHeads {\n\t\t\tif v, ok := data[k]; ok {\n\t\t\t\tvalues = append(values, fmt.Sprintf(\"%v\", v))\n\t\t\t} else {\n\t\t\t\tvalues = append(values, \"\")\n\t\t\t}\n\t\t}\n\t\tif err = writer.Write(values); err != nil {\n\t\t\tlog.Printf(\"写csv文件错误: %v\\n\", values)\n\t\t}\n\t}\n\tdefer wg.Done()\n\treturn nil\n}\n\nfunc HTTPWorker(c *Client, in <-chan Param, out chan<- Res, wg *sync.WaitGroup) error ", "output": "{\n\tfor param := range in {\n\t\tres := make(Res)\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tdata, err := c.Request(param)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\terr = json.Unmarshal(data, &res)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v, ok := res[\"code\"]; ok {\n\t\t\t\tif v == \"00\" || v == \"100002\" {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor k, v := range param {\n\t\t\tres[k] = v\n\t\t}\n\t\tout <- res\n\t}\n\tdefer wg.Done()\n\treturn nil\n}"}
{"input": "package isdocker\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestIsNonDockerProcess(t *testing.T) {\n\tisdocker := IsDocker()\n\tif isdocker == true {\n\t\tt.Errorf(\"process is in non-docker mode, but shows docker mode !!!\")\n\t}\n}\n\nfunc TestIsDockerProcess(t *testing.T) ", "output": "{\n\tisdocker := IsDocker()\n\tif isdocker == false {\n\t\tt.Errorf(\"process is in docker mode, but shows non-docker mode !!!\")\n\t}\n}"}
{"input": "package leet_901\n\ntype StockSpanner struct {\n\tf     []int\n\tprice []int\n}\n\nfunc Constructor() StockSpanner {\n\treturn StockSpanner{}\n}\n\n\n\nfunc (this *StockSpanner) Next(price int) int ", "output": "{\n\tthis.price = append(this.price, price)\n\tif len(this.f) == 0 {\n\t\tthis.f = append(this.f, 1)\n\t\treturn 1\n\t}\n\tans := 1\n\ti := len(this.price) - 2\n\tfor i >= 0 && this.price[i] <= price {\n\t\tans += this.f[i]\n\t\ti -= this.f[i]\n\t}\n\tthis.f = append(this.f, ans)\n\treturn ans\n}"}
{"input": "package lock\n\nimport (\n\t\"os\"\n)\n\ntype LockedFile interface {\n\tFile() *os.File\n\tExclusive() bool\n\tClose() error\n}\n\ntype DefaultLockedFile struct {\n\tf         *os.File\n\texclusive bool\n}\n\nfunc OpenExclusive(path string, flag int, perm os.FileMode) (LockedFile, error) {\n\treturn open(path, flag, perm, true)\n}\n\n\n\nfunc (e *DefaultLockedFile) File() *os.File {\n\treturn e.f\n}\n\nfunc (e *DefaultLockedFile) Exclusive() bool {\n\treturn e.exclusive\n}\n\nfunc (e *DefaultLockedFile) Close() error {\n\terr := e.unlock()\n\terr2 := e.f.Close()\n\tif err2 != nil && err == nil {\n\t\terr = err2\n\t}\n\treturn err\n}\n\nfunc OpenShared(path string, flag int, perm os.FileMode) (LockedFile, error) ", "output": "{\n\treturn open(path, flag, perm, false)\n}"}
{"input": "package descriptor\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\n\t\"gx/ipfs/QmdxUuburamoF6zF9qjeQC4WYcWGbWuRmdLacMEsW8ioD8/gogo-protobuf/proto\"\n)\n\n\n\n\n\n\n\n\ntype Message interface {\n\tproto.Message\n\tDescriptor() ([]byte, []int)\n}\n\n\n\nfunc ForMessage(msg Message) (fd *FileDescriptorProto, md *DescriptorProto) {\n\tgz, path := msg.Descriptor()\n\tfd, err := extractFile(gz)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"invalid FileDescriptorProto for %T: %v\", msg, err))\n\t}\n\n\tmd = fd.MessageType[path[0]]\n\tfor _, i := range path[1:] {\n\t\tmd = md.NestedType[i]\n\t}\n\treturn fd, md\n}\n\n\nfunc (field *FieldDescriptorProto) IsScalar() bool {\n\tif field.Type == nil {\n\t\treturn false\n\t}\n\tswitch *field.Type {\n\tcase FieldDescriptorProto_TYPE_DOUBLE,\n\t\tFieldDescriptorProto_TYPE_FLOAT,\n\t\tFieldDescriptorProto_TYPE_INT64,\n\t\tFieldDescriptorProto_TYPE_UINT64,\n\t\tFieldDescriptorProto_TYPE_INT32,\n\t\tFieldDescriptorProto_TYPE_FIXED64,\n\t\tFieldDescriptorProto_TYPE_FIXED32,\n\t\tFieldDescriptorProto_TYPE_BOOL,\n\t\tFieldDescriptorProto_TYPE_UINT32,\n\t\tFieldDescriptorProto_TYPE_ENUM,\n\t\tFieldDescriptorProto_TYPE_SFIXED32,\n\t\tFieldDescriptorProto_TYPE_SFIXED64,\n\t\tFieldDescriptorProto_TYPE_SINT32,\n\t\tFieldDescriptorProto_TYPE_SINT64:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc extractFile(gz []byte) (*FileDescriptorProto, error) ", "output": "{\n\tr, err := gzip.NewReader(bytes.NewReader(gz))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open gzip reader: %v\", err)\n\t}\n\tdefer r.Close()\n\n\tb, err := ioutil.ReadAll(r)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to uncompress descriptor: %v\", err)\n\t}\n\n\tfd := new(FileDescriptorProto)\n\tif err := proto.Unmarshal(b, fd); err != nil {\n\t\treturn nil, fmt.Errorf(\"malformed FileDescriptorProto: %v\", err)\n\t}\n\n\treturn fd, nil\n}"}
{"input": "package config\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/bgentry/go-netrc/netrc\"\n)\n\ntype netrcfinder interface {\n\tFindMachine(string) *netrc.Machine\n}\n\ntype noNetrc struct{}\n\n\n\nfunc (c *Configuration) parseNetrc() (netrcfinder, error) {\n\thome := c.Getenv(\"HOME\")\n\tif len(home) == 0 {\n\t\treturn &noNetrc{}, nil\n\t}\n\n\tnrcfilename := filepath.Join(home, netrcBasename)\n\tif _, err := os.Stat(nrcfilename); err != nil {\n\t\treturn &noNetrc{}, nil\n\t}\n\n\treturn netrc.ParseFile(nrcfilename)\n}\n\nfunc (n *noNetrc) FindMachine(host string) *netrc.Machine ", "output": "{\n\treturn nil\n}"}
{"input": "package models\n\nimport (\n\t\"github.com/astaxie/beego/orm\"\n)\n\nfunc (this *Note) FillAttrs() bool {\n\to := orm.NewOrm()\n\terr := o.Read(this)\n\tif err == orm.ErrNoRows {\n\t\treturn false\n\t} else if err == orm.ErrMissPK {\n\t\treturn false\n\t} else {\n\t\treturn true\n\t}\n}\n\n\n\nfunc (this *Note) Delete() error {\n\tif _, err := orm.NewOrm().Delete(this); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (this *Note) Update(fields ...string) error {\n\tif _, err := orm.NewOrm().Update(this, fields...); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc TodoNotes(userId int) []*Note {\n\tvar notes []*Note\n\tNotes().Filter(\"UserId\", userId).Filter(\"Done\", 0).All(&notes)\n\treturn notes\n}\n\nfunc DoneNotes(userId int) []*Note {\n\tvar notes []*Note\n\tNotes().Filter(\"UserId\", userId).Filter(\"Done\", 1).All(&notes)\n\treturn notes\n}\n\nfunc Notes() orm.QuerySeter {\n\treturn orm.NewOrm().QueryTable(\"note\").OrderBy(\"-Id\")\n}\n\nfunc (this *Note) Insert() error ", "output": "{\n\to := orm.NewOrm()\n\tid, err := o.Insert(this)\n\tif err != nil {\n\t\treturn err\n\t}\n\tthis.Id = int(id)\n\treturn nil\n}"}
{"input": "package fr\n\nimport (\n\t\"github.com/blevesearch/bleve/v2/analysis\"\n\t\"github.com/blevesearch/bleve/v2/analysis/token/stop\"\n\t\"github.com/blevesearch/bleve/v2/registry\"\n)\n\n\n\nfunc init() {\n\tregistry.RegisterTokenFilter(StopName, StopTokenFilterConstructor)\n}\n\nfunc StopTokenFilterConstructor(config map[string]interface{}, cache *registry.Cache) (analysis.TokenFilter, error) ", "output": "{\n\ttokenMap, err := cache.TokenMapNamed(StopName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn stop.NewStopTokensFilter(tokenMap), nil\n}"}
{"input": "package wml_test\n\nimport (\n\t\"encoding/xml\"\n\t\"testing\"\n\n\t\"baliance.com/gooxml/schema/soo/wml\"\n)\n\n\n\nfunc TestCT_ProofMarshalUnmarshal(t *testing.T) {\n\tv := wml.NewCT_Proof()\n\tbuf, _ := xml.Marshal(v)\n\tv2 := wml.NewCT_Proof()\n\txml.Unmarshal(buf, v2)\n}\n\nfunc TestCT_ProofConstructor(t *testing.T) ", "output": "{\n\tv := wml.NewCT_Proof()\n\tif v == nil {\n\t\tt.Errorf(\"wml.NewCT_Proof must return a non-nil value\")\n\t}\n\tif err := v.Validate(); err != nil {\n\t\tt.Errorf(\"newly constructed wml.CT_Proof should validate: %s\", err)\n\t}\n}"}
{"input": "package v1\n\nimport (\n\tv1 \"github.com/openshift/api/config/v1\"\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/client-go/tools/cache\"\n)\n\n\n\ntype OAuthLister interface {\n\tList(selector labels.Selector) (ret []*v1.OAuth, err error)\n\tGet(name string) (*v1.OAuth, error)\n\tOAuthListerExpansion\n}\n\n\ntype oAuthLister struct {\n\tindexer cache.Indexer\n}\n\n\n\n\n\nfunc (s *oAuthLister) List(selector labels.Selector) (ret []*v1.OAuth, err error) {\n\terr = cache.ListAll(s.indexer, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*v1.OAuth))\n\t})\n\treturn ret, err\n}\n\n\nfunc (s *oAuthLister) Get(name string) (*v1.OAuth, error) {\n\tobj, exists, err := s.indexer.GetByKey(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn nil, errors.NewNotFound(v1.Resource(\"oauth\"), name)\n\t}\n\treturn obj.(*v1.OAuth), nil\n}\n\nfunc NewOAuthLister(indexer cache.Indexer) OAuthLister ", "output": "{\n\treturn &oAuthLister{indexer: indexer}\n}"}
{"input": "package server\n\nimport \"net/url\"\n\n\n\n\n\nfunc PathEscape(str string) string ", "output": "{\n\tu := &url.URL{Path: str}\n\treturn u.String()\n}"}
{"input": "package lsb \n\n\ntype Friendly interface {\n\tIndex(i int) byte \n\tAppend(c byte)    \n\tUnpend()          \n\tString() string   \n\tPos() int         \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype LazyStringBuffer struct {\n\tori string \n\tbuf []byte \n\tw   int    \n}\n\n\nfunc New(s string) *LazyStringBuffer {\n\treturn &LazyStringBuffer{ori: s}\n}\n\n\nfunc (b *LazyStringBuffer) Index(i int) byte {\n\tswitch {\n\tcase b.buf == nil:\n\t\treturn b.ori[i]\n\tdefault:\n\t\treturn b.buf[i]\n\t}\n}\n\n\nfunc (b *LazyStringBuffer) Append(c byte) {\n\tif b.buf == nil {\n\t\tif b.w < len(b.ori) && b.ori[b.w] == c {\n\t\t\tb.w++\n\t\t\treturn\n\t\t}\n\t\tb.buf = make([]byte, len(b.ori))\n\t\tcopy(b.buf, b.ori[:b.w])\n\t}\n\tb.buf[b.w] = c\n\tb.w++\n}\n\n\n\n\n\nfunc (b *LazyStringBuffer) String() string {\n\tswitch {\n\tcase b.buf == nil:\n\t\treturn b.ori[:b.w]\n\tdefault:\n\t\treturn string(b.buf[:b.w])\n\t}\n}\n\n\nfunc (b *LazyStringBuffer) Pos() int {\n\treturn b.w\n}\n\nfunc (b *LazyStringBuffer) Unpend() ", "output": "{\n\tb.w--\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/libgit2/git2go\"\n\t\"log\"\n)\n\ntype Branch struct {\n\tName    string   `json:\"name\"`\n\tIsHead  bool     `json:\"isHead\"`\n\tCommits []Commit `json:\"commits\"`\n}\n\nfunc GetBranches(repo *git.Repository) ([]Branch, error) {\n\tvar branch Branch\n\tvar branches []Branch\n\n\titr, _ := repo.NewReferenceIterator()\n\trefs := getReferences(itr)\n\n\trevWalk, err := repo.Walk()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn branches, err\n\t}\n\n\tfor i := 0; i < len(refs); i++ {\n\t\tbranch = getBranch(refs[i], revWalk)\n\t\tbranches = append(branches, branch)\n\t}\n\n\treturn branches, nil\n}\n\nfunc getReferences(itr *git.ReferenceIterator) []*git.Reference {\n\tvar ref *git.Reference\n\tvar refs []*git.Reference\n\tvar err error\n\tfor {\n\t\tref, err = itr.Next()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\trefs = append(refs, ref)\n\t}\n\treturn refs\n}\n\n\n\nfunc GetBranchByName(name string, repo *git.Repository) (Branch, bool) {\n\tvar branch Branch\n\tgitBranch, err := repo.LookupBranch(name, git.BranchLocal)\n\tif err != nil {\n\t\treturn branch, false\n\t}\n\n\trevWalk, err := repo.Walk()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn branch, false\n\t}\n\treturn getBranch(gitBranch.Reference, revWalk), true\n}\n\nfunc getBranch(ref *git.Reference, revWalk *git.RevWalk) Branch ", "output": "{\n\tvar branch Branch\n\tb := ref.Branch()\n\tname, err := b.Name()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\tisHead, err := b.IsHead()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\tcommits := GetCommits(ref.Target(), revWalk)\n\tbranch = Branch{Name: name, IsHead: isHead, Commits: commits}\n\treturn branch\n}"}
{"input": "package service\n\nimport \"github.com/hzwy23/dbobj\"\n\n\n\nfunc init() ", "output": "{\n\tdefdb := dbobj.GetDefaultName()\n\tif \"oracle\" == defdb {\n\t\thauth_service_001 = `insert into sys_handle_logs(uuid,user_id,handle_time,client_ip,status_code,method,url,domain_id,data) values(sys_guid(),:1,sysdate,:2,:3,:4,:5,:6,:7)`\n\t}\n}"}
{"input": "package buildings\n\ntype store struct {\n\tbasicBuilding\n\timprovementLvl int8\n\tsales          int\n\tprice          int\n}\n\nfunc (*store) GetType() string   { return \"store\" }\nfunc (b *store) GetRevenue() int { return b.sales * b.price }\nfunc (b *store) GetRent() int    { return [4]int{1, 2, 3, 5}[b.improvementLvl] }\nfunc (b *store) GetInternalInt(name string) int {\n\tswitch name {\n\tcase \"improvementLvl\":\n\t\treturn int(b.improvementLvl)\n\tcase \"sales\":\n\t\treturn b.sales\n\tcase \"price\":\n\t\treturn b.price\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc (b *store) ToString(x, y int) string {\n\treturn \"store,\" + string(b.improvementLvl) + \",\" + string(b.sales) + \",\" + string(b.price) + \",\" + b.basicBuilding.ToString(x, y)\n}\n\nfunc (b *store) SetInternalInt(name string, val int) ", "output": "{\n\tswitch name {\n\tcase \"improvementLvl\":\n\t\tb.improvementLvl = int8(val)\n\tcase \"sales\":\n\t\tb.sales = val\n\tcase \"price\":\n\t\tb.price = val\n\t}\n}"}
{"input": "package goxtremio\n\nimport xmsv3 \"github.com/emccode/goxtremio/api/v3\"\n\n\nfunc GetInitiator(id string, name string) (*xmsv3.Initiator, error) {\n\tinitiator, err := xms.GetInitiator(id, name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn initiator.Content, nil\n}\n\n\nfunc GetInitiators() ([]*xmsv3.Ref, error) {\n\tinitiators, err := xms.GetInitiators()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn initiators.Initiators, nil\n}\n\n\n\n\n\nfunc DeleteInitiator(id string, name string) error {\n\treturn xms.DeleteInitiators(id, name)\n}\n\nfunc NewInitiator(opts *xmsv3.PostInitiatorsReq) (resp *xmsv3.PostInitiatorsResp, err error) ", "output": "{\n\treturn xms.PostInitiators(opts)\n}"}
{"input": "package design\n\nimport (\n\t\"github.com/pkg/errors\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc CreateFromFolder(folder string) (d *Design, err error) ", "output": "{\n\td = NewDesign()\n\terr = d.ImportDesignFolder(folder, \"\")\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"in design.CreateFromFolder: \"+folder+\"\\n\")\n\t}\n\treturn\n}"}
{"input": "package console\n\nimport \"github.com/cgrates/cgrates/engine\"\n\n\n\n\ntype CmdGetSharedGroup struct {\n\tname      string\n\trpcMethod string\n\trpcParams *StringWrapper\n\t*CommandExecuter\n}\n\nfunc (self *CmdGetSharedGroup) Name() string {\n\treturn self.name\n}\n\nfunc (self *CmdGetSharedGroup) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\nfunc (self *CmdGetSharedGroup) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &StringWrapper{}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *CmdGetSharedGroup) PostprocessRpcParams() error {\n\treturn nil\n}\n\nfunc (self *CmdGetSharedGroup) RpcResult() interface{} {\n\treturn &engine.SharedGroup{}\n}\n\nfunc init() ", "output": "{\n\tc := &CmdGetSharedGroup{\n\t\tname:      \"sharedgroup\",\n\t\trpcMethod: \"ApierV1.GetSharedGroup\",\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}"}
{"input": "package armmanagementpartner_test\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azidentity\"\n\t\"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/managementpartner/armmanagementpartner\"\n)\n\n\n\n\nfunc ExamplePartnersClient_Get() ", "output": "{\n\tcred, err := azidentity.NewDefaultAzureCredential(nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to obtain a credential: %v\", err)\n\t}\n\tctx := context.Background()\n\tclient := armmanagementpartner.NewPartnersClient(cred, nil)\n\tres, err := client.Get(ctx,\n\t\tnil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"Response result: %#v\\n\", res.PartnersClientGetResult)\n}"}
{"input": "package token_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/hyperledger/fabric/core/handlers/validation/token\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestValidationFactory_New(t *testing.T) {\n\tfactory := &token.ValidationFactory{}\n\tplugin := factory.New()\n\tassert.NotNil(t, plugin)\n}\n\n\n\nfunc TestValidation_Validate(t *testing.T) ", "output": "{\n\tfactory := &token.ValidationFactory{}\n\tplugin := factory.New()\n\n\terr := plugin.Init()\n\tassert.NoError(t, err)\n\n\terr = plugin.Validate(nil, \"\", 0, 0, nil)\n\tassert.NoError(t, err)\n}"}
{"input": "package fs\n\nimport (\n\t\"os\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n\n\nconst (\n\tkFALLOC_FL_KEEP_SIZE  = 0x01\n\tkFALLOC_FL_PUNCH_HOLE = 0x02\n)\n\nfunc (iot ioType) flag() int {\n\tswitch iot {\n\tcase normalIO:\n\t\treturn 0\n\tcase directIO:\n\t\treturn unix.O_DIRECT\n\tdefault:\n\t\tpanic(\"bad ioType\")\n\t}\n}\n\n\n\nfunc (lt lockType) getType() int16 {\n\tswitch lt {\n\tcase sharedLock:\n\t\treturn unix.F_RDLCK\n\tdefault:\n\t\treturn unix.F_WRLCK\n\t}\n}\n\nfunc lock(fh *os.File, lt lockType) error {\n\tflock := unix.Flock_t{\n\t\tType:   lt.getType(),\n\t\tWhence: 0, \n\t\tStart:  0, \n\t\tLen:    0, \n\t}\n\treturn unix.FcntlFlock(fh.Fd(), unix.F_SETLKW, &flock)\n}\n\nfunc punchHole(fh *os.File, offset, size int64) error ", "output": "{\n\tconst flags = kFALLOC_FL_KEEP_SIZE | kFALLOC_FL_PUNCH_HOLE\n\terr := unix.Fallocate(int(fh.Fd()), flags, offset, size)\n\tvar errno error\n\tswitch e := err.(type) {\n\tcase *os.SyscallError:\n\t\terrno = e.Err\n\tcase *os.PathError:\n\t\terrno = e.Err\n\t}\n\tif errno == unix.ENOSYS || errno == unix.EOPNOTSUPP {\n\t\treturn ErrNotSupported\n\t}\n\treturn err\n}"}
{"input": "package route\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"controller\"\n\t\"route/middleware\"\n\t\"route/routewrapper\"\n\t\"shared\"\n\n\t\"github.com/gorilla/context\"\n\t\"github.com/josephspurrier/csrfbanana\"\n)\n\n\nfunc Load() http.Handler {\n\tlog.Println(\"Load all handlers\")\n\treturn middlewareHandler(routewrapper.Instance())\n}\n\n\nfunc LoadHTTPS() http.Handler {\n\tlog.Println(\"Load HTTPS handlers\")\n\treturn middlewareHandler(routewrapper.Instance())\n}\n\n\nfunc LoadHTTP() http.Handler {\n\tlog.Println(\"Load HTTP handlers\")\n\treturn middlewareHandler(routewrapper.Instance())\n}\n\n\n\n\n\nfunc middlewareHandler(h http.Handler) http.Handler {\n\tif shared.EnableCors && shared.Name != \"\" && shared.Store != nil {\n\t\tlog.Fatal(\"Cors and Session conflit\")\n\t} else if shared.Name != \"\" && shared.Store != nil {\n\t\tlog.Println(\"Prevents CSRF, Double Submits\")\n\t\tcs := csrfbanana.New(h, shared.Store, shared.Name)\n\t\tcs.FailureHandler(http.HandlerFunc(controller.InvalidToken))\n\t\tcs.ClearAfterUsage(true)\n\t\tcs.ExcludeRegexPaths([]string{\"/static(.*)\"})\n\t\tcsrfbanana.TokenLength = 32\n\t\tcsrfbanana.TokenName = \"token\"\n\t\tcsrfbanana.SingleToken = false\n\t\th = cs\n\t} else if shared.EnableCors {\n\t\tlog.Println(\"Prevents Cors\")\n\t\th = shared.CorsHandler(h)\n\t}\n\n\tlog.Println(\"Logger request activated\")\n\th = middleware.LogrequestHandler(h)\n\n\tlog.Println(\"Clear handler for Gorilla Context\")\n\th = context.ClearHandler(h)\n\n\treturn h\n}\n\nfunc redirectToHTTPS(w http.ResponseWriter, req *http.Request) ", "output": "{\n\tlog.Println(\"Redirect to https\")\n\thttp.Redirect(w, req, \"https://\"+req.Host, http.StatusMovedPermanently)\n}"}
{"input": "package apps\n\nimport (\n\t\"encoding/base64\"\n\n\t\"github.com/astaxie/beego/orm\"\n\n\t\"github.com/Michael2008S/oauth2beego\"\n)\n\ntype BaseProvider struct {\n\tApp            social.Provider\n\tClientId       string\n\tClientSecret   string\n\tScope          string\n\tAuthURL        string\n\tTokenURL       string\n\tRedirectURL    string\n\tAccessType     string\n\tApprovalPrompt string\n}\n\n\n\nfunc (p *BaseProvider) GetConfig() *social.Config {\n\treturn &social.Config{\n\t\tClientId:       p.ClientId,\n\t\tClientSecret:   p.ClientSecret,\n\t\tScope:          p.Scope,\n\t\tAuthURL:        p.AuthURL,\n\t\tTokenURL:       p.TokenURL,\n\t\tRedirectURL:    p.RedirectURL,\n\t\tAccessType:     p.AccessType,\n\t\tApprovalPrompt: p.ApprovalPrompt,\n\t}\n}\n\nfunc (p *BaseProvider) CanConnect(tok *social.Token, userSocial *social.UserSocial) (bool, error) {\n\tidentify, err := p.App.GetIndentify(tok)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif err := social.UserSocials().Filter(\"Identify\", identify).Filter(\"Type\", p.App.GetType()).One(userSocial); err == orm.ErrNoRows {\n\t\treturn true, nil\n\t} else if err == nil {\n\t\treturn false, nil\n\t} else {\n\t\treturn false, err\n\t}\n}\n\nfunc (p *BaseProvider) getBasicAuth() string ", "output": "{\n\treturn \"Basic \" + base64.StdEncoding.EncodeToString([]byte(p.ClientId+\":\"+p.ClientSecret))\n}"}
{"input": "package vips\n\nimport (\n\t\"github.com/mitchellh/mapstructure\"\n\n\t\"github.com/rackspace/gophercloud\"\n\t\"github.com/rackspace/gophercloud/pagination\"\n)\n\n\ntype VIP struct {\n\tAddress string  `json:\"address,omitempty\"`\n\tID      int     `json:\"id,omitempty\"`\n\tType    Type    `json:\"type,omitempty\"`\n\tVersion Version `json:\"ipVersion,omitempty\" mapstructure:\"ipVersion\"`\n}\n\n\ntype Version string\n\n\nconst (\n\tIPV4 Version = \"IPV4\"\n\tIPV6 Version = \"IPV6\"\n)\n\n\ntype Type string\n\nconst (\n\tPUBLIC Type = \"PUBLIC\"\n\n\tPRIVATE Type = \"SERVICENET\"\n)\n\n\n\ntype VIPPage struct {\n\tpagination.SinglePageBase\n}\n\n\nfunc (p VIPPage) IsEmpty() (bool, error) {\n\tis, err := ExtractVIPs(p)\n\tif err != nil {\n\t\treturn true, nil\n\t}\n\treturn len(is) == 0, nil\n}\n\n\n\n\nfunc ExtractVIPs(page pagination.Page) ([]VIP, error) {\n\tvar resp struct {\n\t\tVIPs []VIP `mapstructure:\"virtualIps\" json:\"virtualIps\"`\n\t}\n\n\terr := mapstructure.Decode(page.(VIPPage).Body, &resp)\n\n\treturn resp.VIPs, err\n}\n\ntype commonResult struct {\n\tgophercloud.Result\n}\n\n\n\n\ntype CreateResult struct {\n\tcommonResult\n}\n\n\ntype DeleteResult struct {\n\tgophercloud.ErrResult\n}\n\nfunc (r commonResult) Extract() (*VIP, error) ", "output": "{\n\tif r.Err != nil {\n\t\treturn nil, r.Err\n\t}\n\n\tresp := &VIP{}\n\terr := mapstructure.Decode(r.Body, resp)\n\n\treturn resp, err\n}"}
{"input": "package main\n\n\n\n\nimport \"C\"\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"runtime\"\n\t\"runtime/pprof\"\n\t\"time\"\n\t\"unsafe\"\n)\n\nfunc init() {\n\tregister(\"CgoPprofThread\", CgoPprofThread)\n\tregister(\"CgoPprofThreadNoTraceback\", CgoPprofThreadNoTraceback)\n}\n\nfunc CgoPprofThread() {\n\truntime.SetCgoTraceback(0, unsafe.Pointer(C.pprofCgoThreadTraceback), nil, nil)\n\tpprofThread()\n}\n\nfunc CgoPprofThreadNoTraceback() {\n\tpprofThread()\n}\n\n\n\nfunc pprofThread() ", "output": "{\n\tf, err := ioutil.TempFile(\"\", \"prof\")\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(2)\n\t}\n\n\tif err := pprof.StartCPUProfile(f); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(2)\n\t}\n\n\tC.runCPUHogThread()\n\n\tt0 := time.Now()\n\tfor C.getCPUHogThreadCount() < 2 && time.Since(t0) < time.Second {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\n\tpprof.StopCPUProfile()\n\n\tname := f.Name()\n\tif err := f.Close(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(2)\n\t}\n\n\tfmt.Println(name)\n}"}
{"input": "package auth\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/andrewslotin/michael/dashboard\"\n\tjwt \"github.com/dgrijalva/jwt-go\"\n)\n\ntype ChannelAuthenticator struct {\n\thandler http.Handler\n\tauth    TokenAuthenticator\n\tsecret  []byte\n}\n\n\n\n\n\nfunc TokenAuthenticationMiddleware(h http.Handler, authenticator TokenAuthenticator, jwtSecret []byte) http.Handler {\n\treturn &ChannelAuthenticator{\n\t\thandler: h,\n\t\tauth:    authenticator,\n\t\tsecret:  jwtSecret,\n\t}\n}\n\nfunc (h *ChannelAuthenticator) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tchannelID := dashboard.ChannelIDFromRequest(r)\n\tif channelID == \"\" {\n\t\th.handler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\n\tif token := r.FormValue(\"token\"); token == \"\" || !h.auth.Authenticate(token) {\n\t\th.handler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\n\th.grantChannelAccess(channelID, w, r)\n\n\turl := *r.URL\n\tq := url.Query()\n\tq.Del(\"token\")\n\turl.RawQuery = q.Encode()\n\n\thttp.Redirect(w, r, url.String(), http.StatusFound)\n}\n\n\n\nfunc (h *ChannelAuthenticator) grantChannelAccess(channelID string, w http.ResponseWriter, r *http.Request) error ", "output": "{\n\tif channelID == \"\" {\n\t\treturn nil\n\t}\n\n\tvar claims *JWTChannelClaims\n\tif token := ChannelAccessTokenFromRequest(r); token != \"\" {\n\t\tif existingClaims, err := ParseChannelAccessTokenClaims(token, h.secret); err == nil { \n\t\t\tclaims = existingClaims\n\t\t}\n\t}\n\n\tif claims == nil {\n\t\tclaims = new(JWTChannelClaims)\n\t\tclaims.Channels = make(map[string]time.Time, 1)\n\t}\n\n\tissueTime := time.Now()\n\texpirationTime := issueTime.Add(ChannelAccessTokenExpirationPeriod)\n\n\tclaims.IssuedAt = issueTime.Unix()\n\tclaims.ExpiresAt = expirationTime.Unix()\n\tclaims.Channels[channelID] = expirationTime\n\n\ttokenString, err := jwt.NewWithClaims(jwt.SigningMethodHS256, claims).SignedString(h.secret)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tStoreChannelAccessToken(w, tokenString, expirationTime)\n\n\treturn nil\n}"}
{"input": "package prometheus\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n\n\ntype TelemetryServer struct {\n\tserver    *http.Server\n\tsubsystem string\n\tsync      time.Duration\n}\n\n\n\n\n\n\nfunc (s *TelemetryServer) Listen(ctx context.Context) {\n\tgo func() {\n\t\tlog.Infof(\"started prometheus metric listener %s\", s.server.Addr)\n\t\ts.server.ListenAndServe()\n\t}()\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\t\tdefer cancel()\n\n\t\tlog.Infof(\"stopping prometheus metric listener\")\n\t\ts.server.Shutdown(ctx)\n\t}()\n}\n\nfunc NewServer(subsystem, listenAddr string, syncInterval time.Duration) *TelemetryServer ", "output": "{\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/metrics\", promhttp.Handler())\n\n\tserver := &http.Server{\n\t\tAddr:    listenAddr,\n\t\tHandler: mux,\n\t}\n\n\treturn &TelemetryServer{server: server, subsystem: subsystem, sync: syncInterval}\n}"}
{"input": "package runtimeemitter_test\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n)\n\n\n\nfunc TestRuntimeemitter(t *testing.T) ", "output": "{\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Runtime Emitter Suite\")\n}"}
{"input": "package x509\n\nfunc (s SignatureAlgorithm) String() string {\n\tif s >= total_signature_algorithms || s < 0 {\n\t\ts = UnknownSignatureAlgorithm\n\t}\n\treturn signatureAlgorithmNames[s]\n}\n\nfunc (p PublicKeyAlgorithm) String() string {\n\tif p >= total_key_algorithms || p < 0 {\n\t\tp = UnknownPublicKeyAlgorithm\n\t}\n\treturn keyAlgorithmNames[p]\n}\n\nfunc (c *Certificate) SignatureAlgorithmName() string {\n\tswitch c.SignatureAlgorithm {\n\tcase UnknownSignatureAlgorithm:\n\t\treturn c.SignatureAlgorithmOID.String()\n\tdefault:\n\t\treturn c.SignatureAlgorithm.String()\n\t}\n}\n\n\n\nfunc (c *Certificate) PublicKeyAlgorithmName() string ", "output": "{\n\tswitch c.PublicKeyAlgorithm {\n\tcase UnknownPublicKeyAlgorithm:\n\t\treturn c.PublicKeyAlgorithmOID.String()\n\tdefault:\n\t\treturn c.PublicKeyAlgorithm.String()\n\t}\n}"}
{"input": "package version\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/coreos/go-semver/semver\"\n)\n\nvar (\n\tMinClusterVersion = \"3.0.0\"\n\tVersion           = \"3.2.1\"\n\tAPIVersion        = \"unknown\"\n\n\tGitSHA = \"Not provided (use ./build instead of go build)\"\n)\n\nfunc init() {\n\tver, err := semver.NewVersion(Version)\n\tif err == nil {\n\t\tAPIVersion = fmt.Sprintf(\"%d.%d\", ver.Major, ver.Minor)\n\t}\n}\n\ntype Versions struct {\n\tServer  string `json:\"etcdserver\"`\n\tCluster string `json:\"etcdcluster\"`\n}\n\n\n\n\nfunc Cluster(v string) string ", "output": "{\n\tvs := strings.Split(v, \".\")\n\tif len(vs) <= 2 {\n\t\treturn v\n\t}\n\treturn fmt.Sprintf(\"%s.%s\", vs[0], vs[1])\n}"}
{"input": "package user\n\nfunc New(id int, username, password, firstname, lastname, role string) User {\n\treturn User{id, username, password, firstname, lastname, role}\n}\n\n\ntype User struct {\n\tid        int\n\tusername  string\n\tpassword  string\n\tfirstname string\n\tlastname  string\n\trole      string\n}\n\nfunc (u User) Id() int {\n\treturn u.id\n}\n\nfunc (u User) Username() string {\n\treturn u.username\n}\n\nfunc (u User) Password() string {\n\treturn u.password\n}\n\nfunc (u User) Firstname() string {\n\treturn u.firstname\n}\n\nfunc (u User) Lastname() string {\n\treturn u.lastname\n}\n\n\n\nfunc (u User) Role() string ", "output": "{\n\treturn u.role\n}"}
{"input": "package contexts\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"time\"\n)\n\n\ntype ContextHook struct {\n\tstart       time.Time\n\tCtx         context.Context\n\tSQL         string        \n\tArgs        []interface{} \n\tResult      sql.Result\n\tExecuteTime time.Duration\n\tErr         error \n}\n\n\nfunc NewContextHook(ctx context.Context, sql string, args []interface{}) *ContextHook {\n\treturn &ContextHook{\n\t\tstart: time.Now(),\n\t\tCtx:   ctx,\n\t\tSQL:   sql,\n\t\tArgs:  args,\n\t}\n}\n\nfunc (c *ContextHook) End(ctx context.Context, result sql.Result, err error) {\n\tc.Ctx = ctx\n\tc.Result = result\n\tc.Err = err\n\tc.ExecuteTime = time.Now().Sub(c.start)\n}\n\ntype Hook interface {\n\tBeforeProcess(c *ContextHook) (context.Context, error)\n\tAfterProcess(c *ContextHook) error\n}\n\ntype Hooks struct {\n\thooks []Hook\n}\n\n\n\nfunc (h *Hooks) BeforeProcess(c *ContextHook) (context.Context, error) {\n\tctx := c.Ctx\n\tfor _, h := range h.hooks {\n\t\tvar err error\n\t\tctx, err = h.BeforeProcess(c)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn ctx, nil\n}\n\nfunc (h *Hooks) AfterProcess(c *ContextHook) error {\n\tfirstErr := c.Err\n\tfor _, h := range h.hooks {\n\t\terr := h.AfterProcess(c)\n\t\tif err != nil && firstErr == nil {\n\t\t\tfirstErr = err\n\t\t}\n\t}\n\treturn firstErr\n}\n\nfunc (h *Hooks) AddHook(hooks ...Hook) ", "output": "{\n\th.hooks = append(h.hooks, hooks...)\n}"}
{"input": "package routers\n\nimport (\n\t\"fmt\"\n\t\"github.com/gorilla/websocket\"\n\t\"net/http\"\n)\n\nvar connections map[*websocket.Conn]bool\n\nfunc InitConnections() {\n\tconnections = make(map[*websocket.Conn]bool)\n}\n\nfunc WSHandler(w http.ResponseWriter, r *http.Request) {\n\tconn, err := websocket.Upgrade(w, r, nil, 1024, 1024)\n\n\tif _, ok := err.(websocket.HandshakeError); ok {\n\t\thttp.Error(w, \"Not a websocket handleshake\", 400)\n\t\treturn\n\t} else if err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tconnections[conn] = true\n\tfmt.Println(\"A new connection added...\")\n}\n\n\n\nfunc sendAll(msg []byte) ", "output": "{\n\tfmt.Println(\"Send data to all clients...\")\n\tfor conn := range connections {\n\t\tif err := conn.WriteMessage(websocket.TextMessage, msg); err != nil {\n\t\t\tdelete(connections, conn)\n\t\t}\n\t}\n}"}
{"input": "package ovf\n\nimport (\n\tvboxcommon \"github.com/hashicorp/packer/builder/virtualbox/common\"\n\t\"github.com/mitchellh/multistep\"\n\t\"testing\"\n)\n\n\n\nfunc TestStepImport(t *testing.T) {\n\tstate := testState(t)\n\tc := testConfig(t)\n\tconfig, _, _ := NewConfig(c)\n\tstate.Put(\"vm_path\", \"foo\")\n\tstate.Put(\"config\", config)\n\tstep := new(StepImport)\n\tstep.Name = \"bar\"\n\n\tdriver := state.Get(\"driver\").(*vboxcommon.DriverMock)\n\n\tif action := step.Run(state); action != multistep.ActionContinue {\n\t\tt.Fatalf(\"bad action: %#v\", action)\n\t}\n\tif _, ok := state.GetOk(\"error\"); ok {\n\t\tt.Fatal(\"should NOT have error\")\n\t}\n\n\tif !driver.ImportCalled {\n\t\tt.Fatal(\"import should be called\")\n\t}\n\tif driver.ImportName != step.Name {\n\t\tt.Fatalf(\"bad: %#v\", driver.ImportName)\n\t}\n\n\tif name, ok := state.GetOk(\"vmName\"); !ok {\n\t\tt.Fatal(\"vmName should be set\")\n\t} else if name != \"bar\" {\n\t\tt.Fatalf(\"bad: %#v\", name)\n\t}\n\n\tconfig.KeepRegistered = true\n\tstep.Cleanup(state)\n\n\tif driver.DeleteCalled {\n\t\tt.Fatal(\"delete should not be called\")\n\t}\n\n\tconfig.KeepRegistered = false\n\tstep.Cleanup(state)\n\tif !driver.DeleteCalled {\n\t\tt.Fatal(\"delete should be called\")\n\t}\n\tif driver.DeleteName != \"bar\" {\n\t\tt.Fatalf(\"bad: %#v\", driver.DeleteName)\n\t}\n}\n\nfunc TestStepImport_impl(t *testing.T) ", "output": "{\n\tvar _ multistep.Step = new(StepImport)\n}"}
{"input": "package allowanypassword\n\nimport (\n\t\"strings\"\n\n\t\"github.com/golang/glog\"\n\n\tauthapi \"github.com/openshift/origin/pkg/auth/api\"\n\t\"github.com/openshift/origin/pkg/auth/authenticator\"\n\t\"k8s.io/apiserver/pkg/authentication/user\"\n)\n\n\ntype alwaysAcceptPasswordAuthenticator struct {\n\tproviderName   string\n\tidentityMapper authapi.UserIdentityMapper\n}\n\n\n\n\n\nfunc (a alwaysAcceptPasswordAuthenticator) AuthenticatePassword(username, password string) (user.Info, bool, error) {\n\tusername = strings.TrimSpace(username)\n\n\tif username == \"\" || password == \"\" {\n\t\treturn nil, false, nil\n\t}\n\n\tidentity := authapi.NewDefaultUserIdentityInfo(a.providerName, username)\n\tuser, err := a.identityMapper.UserFor(identity)\n\tif err != nil {\n\t\tglog.V(4).Infof(\"Error creating or updating mapping for: %#v due to %v\", identity, err)\n\t\treturn nil, false, err\n\t}\n\tglog.V(4).Infof(\"Got userIdentityMapping: %#v\", user)\n\n\treturn user, true, nil\n}\n\nfunc New(providerName string, identityMapper authapi.UserIdentityMapper) authenticator.Password ", "output": "{\n\treturn &alwaysAcceptPasswordAuthenticator{providerName, identityMapper}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"go.opentelemetry.io/collector/service\"\n\t\"golang.org/x/sys/windows/svc\"\n)\n\n\n\nfunc runService(params service.CollectorSettings) error {\n\tif err := svc.Run(\"\", service.NewWindowsService(params)); err != nil {\n\t\treturn fmt.Errorf(\"failed to start service: %w\", err)\n\t}\n\n\treturn nil\n}\n\nfunc run(params service.CollectorSettings) error ", "output": "{\n\tisInteractive, err := svc.IsAnInteractiveSession()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to determine if we are running in an interactive session: %w\", err)\n\t}\n\n\tif isInteractive {\n\t\treturn runInteractive(params)\n\t}\n\treturn runService(params)\n}"}
{"input": "package coreoslib\n\nimport (\n\t\"fmt\"\n\t\"github.com/coreos/locksmith/lock\"\n\t\"os\"\n)\n\n\n\nfunc CoreOsLocksmith(machines []string, max int) error ", "output": "{\n\n\telc, err := lock.NewEtcdLockClient(machines)\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"Error initializing etcd client:\", err)\n\t\treturn err\n\t}\n\tl := lock.New(\"hi\", elc)\n\n\tsem, old, err := l.SetMax(max)\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"Error setting value:\", err)\n\t\treturn err\n\t}\n\n\tfmt.Println(\"Old-Max:\", old)\n\tfmt.Println(\"Max:\", sem.Max)\n\n\treturn nil\n}"}
{"input": "package openstack\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\t\"github.com/go-ini/ini\"\n\t\"github.com/rancher/types/apis/management.cattle.io/v3\"\n)\n\nconst (\n\tOpenstackCloudProviderName = \"openstack\"\n)\n\ntype CloudProvider struct {\n\tConfig *v3.OpenstackCloudProvider\n\tName   string\n}\n\nfunc GetInstance() *CloudProvider {\n\treturn &CloudProvider{}\n}\n\n\n\nfunc (p *CloudProvider) GetName() string {\n\treturn p.Name\n}\n\nfunc (p *CloudProvider) GenerateCloudConfigFile() (string, error) {\n\tbuf := new(bytes.Buffer)\n\tcloudConfig, _ := ini.LoadSources(ini.LoadOptions{IgnoreInlineComment: true}, []byte(\"\"))\n\tif err := ini.ReflectFrom(cloudConfig, p.Config); err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to parse Openstack cloud config\")\n\t}\n\tif _, err := cloudConfig.WriteTo(buf); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn buf.String(), nil\n}\n\nfunc (p *CloudProvider) Init(cloudProviderConfig v3.CloudProvider) error ", "output": "{\n\tif cloudProviderConfig.OpenstackCloudProvider == nil {\n\t\treturn fmt.Errorf(\"Openstack Cloud Provider Config is empty\")\n\t}\n\tp.Name = OpenstackCloudProviderName\n\tif cloudProviderConfig.Name != \"\" {\n\t\tp.Name = cloudProviderConfig.Name\n\t}\n\tp.Config = cloudProviderConfig.OpenstackCloudProvider\n\treturn nil\n}"}
{"input": "package request\n\nimport (\n\t\"errors\"\n\t\"github.com/vx-labs/go-rest-api\"\n\t\"github.com/vx-labs/go-rest-api/opts\"\n)\n\ntype APIRequest struct {\n\taction   api.Verb\n\tpayload  interface{}\n\tresponse interface{}\n\tresource api.ClientResource\n\topts     opts.Values\n\theaders  map[string][]string\n}\n\nfunc (r *APIRequest) Payload() interface{} {\n\treturn r.payload\n}\nfunc (r *APIRequest) Response() interface{} {\n\treturn r.response\n}\n\nfunc (r *APIRequest) Headers() map[string][]string {\n\treturn r.headers\n}\nfunc (r *APIRequest) Resource() api.ClientResource {\n\treturn r.resource\n}\n\nfunc (r *APIRequest) WithOptions(opts opts.Values) api.ClientRequest {\n\tr.opts = opts\n\treturn r\n}\nfunc (r *APIRequest) WithHeader(name, value string) api.ClientRequest {\n\tif _, found := r.headers[name]; !found {\n\t\tr.headers[name] = []string{value}\n\t\treturn r\n\t}\n\tr.headers[name] = append(r.headers[name], value)\n\treturn r\n}\n\nfunc (r *APIRequest) Options() opts.Values {\n\treturn r.opts\n}\n\nfunc (r *APIRequest) Validate() error {\n\tif r.action > 5 {\n\t\treturn errors.New(\"invalid API verb\")\n\t}\n\treturn nil\n}\n\nfunc New(action api.Verb, payload interface{}, response interface{}, resource api.ClientResource) api.ClientRequest {\n\treturn &APIRequest{\n\t\taction:   action,\n\t\tpayload:  payload,\n\t\tresponse: response,\n\t\tresource: resource,\n\t\topts:     opts.New(),\n\t}\n}\n\nfunc (r *APIRequest) Action() api.Verb ", "output": "{\n\treturn r.action\n}"}
{"input": "package memo\n\nimport (\n\t\"encoding/binary\"\n\t\"reflect\"\n\n\t. \"github.com/pingcap/check\"\n\t\"github.com/pingcap/tidb/expression\"\n\tplannercore \"github.com/pingcap/tidb/planner/core\"\n)\n\n\n\nfunc (s *testMemoSuite) TestGroupExprFingerprint(c *C) {\n\tp := &plannercore.LogicalLimit{Count: 3}\n\texpr := NewGroupExpr(p)\n\tchildGroup := NewGroupWithSchema(nil, expression.NewSchema())\n\texpr.SetChildren(childGroup)\n\tplanHash := p.HashCode()\n\tbuffer := make([]byte, 10+len(planHash))\n\tbinary.BigEndian.PutUint16(buffer, 1)\n\tbinary.BigEndian.PutUint64(buffer[2:], uint64(reflect.ValueOf(childGroup).Pointer()))\n\tcopy(buffer[10:], planHash)\n\tc.Assert(expr.FingerPrint(), Equals, string(buffer))\n}\n\nfunc (s *testMemoSuite) TestNewGroupExpr(c *C) ", "output": "{\n\tp := &plannercore.LogicalLimit{}\n\texpr := NewGroupExpr(p)\n\tc.Assert(expr.ExprNode, Equals, p)\n\tc.Assert(expr.Children, IsNil)\n\tc.Assert(expr.Explored, IsFalse)\n}"}
{"input": "package config\n\nimport (\n\t\"encoding/json\"\n\t\"path/filepath\"\n)\n\nconst secretToken = \"<secret>\"\n\n\ntype Secret string\n\n\n\n\n\nfunc (s *Secret) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\ttype plain Secret\n\treturn unmarshal((*plain)(s))\n}\n\n\nfunc (s Secret) MarshalJSON() ([]byte, error) {\n\tif len(s) == 0 {\n\t\treturn json.Marshal(\"\")\n\t}\n\treturn json.Marshal(secretToken)\n}\n\n\n\ntype DirectorySetter interface {\n\tSetDirectory(dir string)\n}\n\n\n\nfunc JoinDir(dir, path string) string {\n\tif path == \"\" || filepath.IsAbs(path) {\n\t\treturn path\n\t}\n\treturn filepath.Join(dir, path)\n}\n\nfunc (s Secret) MarshalYAML() (interface{}, error) ", "output": "{\n\tif s != \"\" {\n\t\treturn secretToken, nil\n\t}\n\treturn nil, nil\n}"}
{"input": "package main\n\nimport (\n\t\"time\"\n\n\t\"github.com/golang/glog\"\n\n\t\"k8s.io/test-infra/velodrome/sql\"\n)\n\n\ntype OpenToClose struct {\n\tDB   InfluxDatabase\n\tlast time.Time\n\topen map[string]time.Time\n}\n\n\n\n\n\n\nfunc (o *OpenToClose) ReceiveIssue(issue sql.Issue) error {\n\tif _, ok := o.open[issue.ID]; ok {\n\t\treturn nil\n\t}\n\n\tif !issue.IsPR {\n\t\treturn nil\n\t}\n\n\to.open[issue.ID] = issue.IssueCreatedAt\n\treturn nil\n}\n\n\nfunc (*OpenToClose) ReceiveComment(sql.Comment) error {\n\treturn nil\n}\n\n\nfunc (o *OpenToClose) ReceiveIssueEvent(event sql.IssueEvent) error {\n\tif event.Event != \"closed\" {\n\t\treturn nil\n\t}\n\tif !event.EventCreatedAt.After(o.last) {\n\t\treturn nil\n\t}\n\n\topen, ok := o.open[event.IssueId]\n\tif !ok {\n\t\treturn nil\n\t}\n\n\topen_to_close := event.EventCreatedAt.Sub(open)\n\treturn o.DB.Push(\n\t\t\"open_to_close\",\n\t\tnil,\n\t\tmap[string]interface{}{\"value\": int(open_to_close / time.Minute)},\n\t\tevent.EventCreatedAt,\n\t)\n}\n\nfunc NewOpenToClosePlugin(DB InfluxDatabase) *OpenToClose ", "output": "{\n\tlast, err := DB.GetLastMeasurement(\"open_to_close\")\n\tif err != nil {\n\t\tglog.Fatal(\"Failed to create OpenToClose plugin: \", err)\n\t}\n\treturn &OpenToClose{\n\t\tDB:   DB,\n\t\tlast: last,\n\t\topen: map[string]time.Time{},\n\t}\n}"}
{"input": "package transport\n\nimport (\n\t\"circuit/use/circuit\"\n\t\"encoding/gob\"\n\t\"net\"\n\t\"sync\"\n)\n\n\n\ntype Addr struct {\n\tID   circuit.WorkerID\n\tPID  int\n\tAddr *net.TCPAddr\n}\n\nfunc init() {\n\tgob.Register(&Addr{})\n}\n\nfunc NewAddr(id circuit.WorkerID, pid int, hostport string) (circuit.Addr, error) {\n\ta, err := net.ResolveTCPAddr(\"tcp\", hostport)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Addr{ID: id, PID: pid, Addr: a}, nil\n}\n\nfunc (a *Addr) Host() string {\n\treturn a.Addr.IP.String()\n}\n\n\n\nfunc (a *Addr) WorkerID() circuit.WorkerID {\n\treturn a.ID\n}\n\ntype addrTabl struct {\n\tlk   sync.Mutex\n\ttabl map[circuit.WorkerID]*Addr\n}\n\nfunc makeAddrTabl() *addrTabl {\n\treturn &addrTabl{tabl: make(map[circuit.WorkerID]*Addr)}\n}\n\nfunc (t *addrTabl) Normalize(addr *Addr) *Addr {\n\tt.lk.Lock()\n\tdefer t.lk.Unlock()\n\n\ta, ok := t.tabl[addr.ID]\n\tif ok {\n\t\treturn a\n\t}\n\tt.tabl[addr.ID] = addr\n\treturn addr\n}\n\nfunc (a *Addr) String() string ", "output": "{\n\treturn a.ID.String() + \"@\" + a.Addr.String()\n}"}
{"input": "package lib\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\n\n\n\n\n\ntype StopChannelContext struct {\n\tStopCh <-chan struct{}\n}\n\nfunc (c *StopChannelContext) Deadline() (deadline time.Time, ok bool) {\n\tok = false\n\treturn\n}\n\n\n\nfunc (c *StopChannelContext) Err() error {\n\tselect {\n\tcase <-c.StopCh:\n\t\treturn context.Canceled\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc (c *StopChannelContext) Value(key interface{}) interface{} {\n\treturn nil\n}\n\nfunc (c *StopChannelContext) Done() <-chan struct{} ", "output": "{\n\treturn c.StopCh\n}"}
{"input": "package main\n\n\n\nfunc Solve(data []int) []int ", "output": "{\n\tvar res []int\n\tuniques := make(map[int]bool)\n\tfor i := 0; i < len(data); i++ {\n\t\tif _, ok := uniques[data[i]]; !ok {\n\t\t\tuniques[data[i]] = true\n\t\t\tres = append(res, data[i])\n\t\t}\n\t}\n\treturn res\n}"}
{"input": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"runtime/pprof\"\n\t\"syscall\"\n\n\t\"github.com/brentp/bix\"\n\t\"github.com/brentp/irelate\"\n\tI \"github.com/brentp/irelate/interfaces\"\n)\n\nfunc init() {\n\tdone := make(chan os.Signal, 1)\n\n\tsignal.Notify(done, os.Interrupt, syscall.SIGIO, syscall.SIGPIPE)\n\tgo func() {\n\t\tfor _ = range done {\n\t\t\tos.Exit(0)\n\t\t}\n\t}()\n}\n\n\n\nfunc main() {\n\tf, err := os.Create(\"irelate.cpu.pprof\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tpprof.StartCPUProfile(f)\n\tdefer pprof.StopCPUProfile()\n\tfiles := os.Args[1:]\n\tbuf := bufio.NewWriter(os.Stdout)\n\tb, err := bix.New(files[0], 1)\n\tcheck(err)\n\tbx, err := b.Query(nil)\n\tcheck(err)\n\n\tqueryables := make([]I.Queryable, len(files)-1)\n\tfor i, f := range files[1:] {\n\t\tq, err := bix.New(f, 1)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tqueryables[i] = q\n\t}\n\n\tfor interval := range irelate.PIRelate(4000, 25000, bx, false, nil, queryables...) {\n\t\tfmt.Fprintf(buf, \"%s\\t%d\\t%d\\t%d\\n\", interval.Chrom(), interval.Start(), interval.End(), len(interval.Related()))\n\t}\n\tbuf.Flush()\n}\n\nfunc check(e error) ", "output": "{\n\tif e != nil {\n\t\tlog.Fatal(e)\n\t}\n}"}
{"input": "package underscore\n\nimport (\n\t\"testing\"\n)\n\nfunc TestReduce(t *testing.T) {\n\tv := Reduce([]int{ 1, 2 }, func (memo []int, n, _ int) []int {\n\t\tmemo = append(memo, n)\n\t\tmemo = append(memo, n + 10)\n\t\treturn memo\n\t}, make([]int, 0))\n\tres, ok := v.([]int)\n\tif !(ok && len(res) == 4) {\n\t\tt.Error(\"wrong length\")\n\t}\n\n\tif !(res[0] == 1 && res[1] == 11 && res[2] == 2 && res[3] == 12) {\n\t\tt.Error(\"wrong result\")\n\t}\n}\n\n\n\nfunc TestChain_Reduce(t *testing.T) ", "output": "{\n\tv := Chain([]int{ 1, 2 }).Reduce(func (memo []int, n, _ int) []int {\n\t\tmemo = append(memo, n)\n\t\tmemo = append(memo, n + 10)\n\t\treturn memo\n\t}, make([]int, 0)).Value()\t\n\tres, ok := v.([]int)\n\tif !(ok && len(res) == 4) {\n\t\tt.Error(\"wrong length\")\n\t}\n\n\tif !(res[0] == 1 && res[1] == 11 && res[2] == 2 && res[3] == 12) {\n\t\tt.Error(\"wrong result\")\n\t}\n}"}
{"input": "package algorithms\n\nimport \"strings\"\n\n\n\nfunc reverseWords(s string) string ", "output": "{\n\tfileds := strings.Fields(s)\n\tfor i, j := 0, len(fileds)-1; i < j; i, j = i+1, j-1 {\n\t\tfileds[i], fileds[j] = fileds[j], fileds[i]\n\t}\n\treturn strings.Join(fileds, \" \")\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"go-common/app/job/main/relation/conf\"\n\t\"go-common/app/job/main/relation/http\"\n\t\"go-common/app/job/main/relation/service\"\n\t\"go-common/library/log\"\n)\n\nvar (\n\tsrv *service.Service\n)\n\nfunc main() {\n\tflag.Parse()\n\tif err := conf.Init(); err != nil {\n\t\tlog.Error(\"conf.Init() error(%v)\", err)\n\t\tpanic(err)\n\t}\n\tlog.Init(conf.Conf.Xlog)\n\tdefer log.Close()\n\tlog.Info(\"go-common/app/job/main/relation start\")\n\tsrv = service.New(conf.Conf)\n\thttp.Init(conf.Conf, srv)\n\tsignalHandler()\n}\n\n\n\nfunc signalHandler() ", "output": "{\n\tvar (\n\t\terr error\n\t\tch  = make(chan os.Signal, 1)\n\t)\n\tsignal.Notify(ch, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)\n\tfor {\n\t\tsi := <-ch\n\t\tswitch si {\n\t\tcase syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:\n\t\t\tlog.Info(\"get a signal %s, stop the consume process\", si.String())\n\t\t\tif err = srv.Close(); err != nil {\n\t\t\t\tlog.Error(\"srv close consumer error(%v)\", err)\n\t\t\t}\n\t\t\tsrv.Wait()\n\t\t\treturn\n\t\tcase syscall.SIGHUP:\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"input": "package jsonapi\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n)\n\ntype Denaturer interface {\n\tDenature() interface{}\n}\n\nfunc DenatureObject(data interface{}) map[string]interface{} {\n\tfor {\n\t\tif d, found := data.(Denaturer); found {\n\t\t\tdata = d.Denature()\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tv := reflect.Indirect(reflect.ValueOf(data))\n\tt := v.Type()\n\n\tvalues := make(map[string]interface{}, t.NumField())\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tvar f string\n\t\tif f = t.Field(i).Tag.Get(\"marshal-json\"); len(f) == 0 {\n\t\t\tf = t.Field(i).Tag.Get(\"json\")\n\t\t}\n\t\ttag := strings.Split(f, \",\")\n\t\tif len(tag[0]) == 0 {\n\t\t\ttag[0] = t.Field(i).Name\n\t\t}\n\t\tif tag[0] == \"-\" {\n\t\t\tcontinue\n\t\t}\n\t\tif len(tag) > 1 {\n\t\t\tif len(tag[1]) > 0 && tag[1] == \"omitempty\" {\n\t\t\t\tif IsZeroOfUnderlyingType(v.Field(i).Interface()) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvalues[tag[0]] = v.Field(i).Interface()\n\t}\n\n\treturn values\n}\n\n\n\nfunc IsZeroOfUnderlyingType(x interface{}) bool ", "output": "{\n\treturn x == reflect.Zero(reflect.TypeOf(x)).Interface()\n}"}
{"input": "package zfs\n\nimport (\n\t\"os\"\n\t\"sync\"\n\n\t\"github.com/cerana/cerana/pkg/errors\"\n)\n\n\n\nvar zfsFD *os.File\nvar once sync.Once\n\nfunc openZFS() {\n\tz, err := os.OpenFile(\"/dev/zfs\", os.O_RDWR, 0)\n\tif err != nil {\n\t\tpanic(errors.Wrap(err))\n\t}\n\tzfsFD = z\n}\n\n\n\nfunc zfs() *os.File ", "output": "{\n\tonce.Do(openZFS)\n\treturn zfsFD\n}"}
{"input": "package vcl\n\n\n\n\nimport (\n\t. \"github.com/ying32/govcl/vcl/api\"\n\t. \"github.com/ying32/govcl/vcl/types\"\n)\n\ntype (\n\tNSObject uintptr\n\n\tNSWindow uintptr\n\n\tNSURL uintptr\n)\n\n\nfunc HandleToPlatformHandle(h HWND) NSObject {\n\treturn NSObject(h)\n}\n\nfunc (f *TForm) PlatformWindow() NSWindow {\n\tr, _, _ := NSWindow_FromForm.Call(f.instance)\n\treturn NSWindow(r)\n}\n\nfunc (n NSWindow) TitleVisibility() NSWindowTitleVisibility {\n\tr, _, _ := NSWindow_titleVisibility.Call(uintptr(n))\n\treturn NSWindowTitleVisibility(r)\n}\n\nfunc (n NSWindow) SetTitleVisibility(flag NSWindowTitleVisibility) {\n\tNSWindow_setTitleVisibility.Call(uintptr(n), uintptr(flag))\n}\n\nfunc (n NSWindow) TitleBarAppearsTransparent() bool {\n\tr, _, _ := NSWindow_titlebarAppearsTransparent.Call(uintptr(n))\n\treturn DBoolToGoBool(r)\n}\n\nfunc (n NSWindow) SetTitleBarAppearsTransparent(flag bool) {\n\tNSWindow_setTitlebarAppearsTransparent.Call(uintptr(n), GoBoolToDBool(flag))\n}\n\nfunc (n NSWindow) SetRepresentedURL(url NSURL) {\n\tNSWindow_setRepresentedURL.Call(uintptr(n), uintptr(url))\n}\n\n\n\nfunc (n NSWindow) SetStyleMask(mask uint) {\n\tNSWindow_setStyleMask.Call(uintptr(n), uintptr(mask))\n}\n\nfunc (n NSWindow) StyleMask() uint ", "output": "{\n\tr, _, _ := NSWindow_styleMask.Call(uintptr(n))\n\treturn uint(r)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\n\t\"github.com/sky-uk/newrelic-go-agent/Godeps/_workspace/src/github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\trouter := gin.Default()\n\trouter.SetHTMLTemplate(html)\n\n\trouter.GET(\"/room/:roomid\", roomGET)\n\trouter.POST(\"/room/:roomid\", roomPOST)\n\trouter.DELETE(\"/room/:roomid\", roomDELETE)\n\trouter.GET(\"/stream/:roomid\", stream)\n\n\trouter.Run(\":8080\")\n}\n\nfunc stream(c *gin.Context) {\n\troomid := c.Param(\"roomid\")\n\tlistener := openListener(roomid)\n\tdefer closeListener(roomid, listener)\n\n\tc.Stream(func(w io.Writer) bool {\n\t\tc.SSEvent(\"message\", <-listener)\n\t\treturn true\n\t})\n}\n\nfunc roomGET(c *gin.Context) {\n\troomid := c.Param(\"roomid\")\n\tuserid := fmt.Sprint(rand.Int31())\n\tc.HTML(200, \"chat_room\", gin.H{\n\t\t\"roomid\": roomid,\n\t\t\"userid\": userid,\n\t})\n}\n\nfunc roomPOST(c *gin.Context) {\n\troomid := c.Param(\"roomid\")\n\tuserid := c.PostForm(\"user\")\n\tmessage := c.PostForm(\"message\")\n\troom(roomid).Submit(userid + \": \" + message)\n\n\tc.JSON(200, gin.H{\n\t\t\"status\":  \"success\",\n\t\t\"message\": message,\n\t})\n}\n\n\n\nfunc roomDELETE(c *gin.Context) ", "output": "{\n\troomid := c.Param(\"roomid\")\n\tdeleteBroadcast(roomid)\n}"}
{"input": "package chaincode\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/spf13/cobra\"\n)\n\nvar chaincodeInvokeCmd *cobra.Command\n\n\n\n\nfunc chaincodeInvoke(cmd *cobra.Command, args []string, cf *ChaincodeCmdFactory) error {\n\tvar err error\n\tif cf == nil {\n\t\tcf, err = InitCmdFactory()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tdefer cf.BroadcastClient.Close()\n\n\treturn chaincodeInvokeOrQuery(cmd, args, true, cf)\n}\n\nfunc invokeCmd(cf *ChaincodeCmdFactory) *cobra.Command ", "output": "{\n\tchaincodeInvokeCmd = &cobra.Command{\n\t\tUse:       \"invoke\",\n\t\tShort:     fmt.Sprintf(\"Invoke the specified %s.\", chainFuncName),\n\t\tLong:      fmt.Sprintf(`Invoke the specified %s. It will try to commit the endorsed transaction to the network.`, chainFuncName),\n\t\tValidArgs: []string{\"1\"},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn chaincodeInvoke(cmd, args, cf)\n\t\t},\n\t}\n\n\treturn chaincodeInvokeCmd\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/julienschmidt/httprouter\"\n\t\"net/http\"\n)\n\ntype Login struct {\n\t*Controller\n}\n\n\n\nfunc NewLoginController(c *Controller, router *httprouter.Router) {\n\tlogin := &Login{\n\t\tc,\n\t}\n\tlogin.Register(router)\n}\n\n\n\nfunc (l *Login) Register(router *httprouter.Router) {\n\trouter.GET(\"/login\", l.Get)\n\trouter.POST(\"/login\", l.Post)\n}\n\n\n\n\n\nfunc (l *Login) Post(res http.ResponseWriter, req *http.Request, _ httprouter.Params) {\n\tinfo, err := l.Login.ParseBodyInfo(req)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t}\n\terr = l.Authentication.ValidateCredentials(info.Email, info.Password)\n\tif err != nil {\n\t\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n\t\treturn\n\t} else {\n\t\tl.Authentication.LogInUser(info.Email, res)\n\t}\n\thttp.Redirect(res, req, \"/admin\", http.StatusFound)\n}\n\nfunc (l *Login) Get(res http.ResponseWriter, req *http.Request, _ httprouter.Params) ", "output": "{\n\temail, _ := l.Authentication.GetEmail(req)\n\tif email != \"\" {\n\t\thttp.Redirect(res, req, \"/admin\", http.StatusFound)\n\t\treturn\n\t}\n\tpayload := &Payload{\n\t\tPage: &Page{\n\t\t\tTitle: \"Login | Miguel Cervantes Jr.\",\n\t\t},\n\t\tLayout: \"login-layout\",\n\t}\n\terr := l.Render.HTML(res, http.StatusOK, \"login\", payload)\n\tif err != nil {\n\t\tl.RenderErr(res, req, &err)\n\t\treturn\n\t}\n}"}
{"input": "package data\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/keybase/client/go/kbfs/kbfsblock\"\n)\n\n\n\ntype NameExistsError struct {\n\tName string\n}\n\n\nfunc (e NameExistsError) Error() string {\n\treturn fmt.Sprintf(\"%s already exists\", e.Name)\n}\n\n\ntype BadSplitError struct {\n}\n\n\n\n\n\ntype BadDataError struct {\n\tID kbfsblock.ID\n}\n\n\nfunc (e BadDataError) Error() string {\n\treturn fmt.Sprintf(\"Bad data for block %v\", e.ID)\n}\n\n\ntype NoSuchBlockError struct {\n\tID kbfsblock.ID\n}\n\n\nfunc (e NoSuchBlockError) Error() string {\n\treturn fmt.Sprintf(\"Couldn't get block %v\", e.ID)\n}\n\n\n\n\ntype NotDirectFileBlockError struct {\n}\n\nfunc (e NotDirectFileBlockError) Error() string {\n\treturn \"Unexpected block type; expected a direct file block\"\n}\n\n\n\ntype CachePutCacheFullError struct {\n\tBlockID kbfsblock.ID\n}\n\nfunc (e CachePutCacheFullError) Error() string {\n\treturn fmt.Sprintf(\"failed to put block due to full cache. Block: %s\",\n\t\te.BlockID)\n}\n\n\ntype ShutdownHappenedError struct {\n}\n\n\nfunc (e ShutdownHappenedError) Error() string {\n\treturn \"Shutdown happened\"\n}\n\nfunc (e BadSplitError) Error() string ", "output": "{\n\treturn \"Unexpected bad block split\"\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype LookupResponse map[string]User\n\ntype User struct {\n\tProfile       Profile\n\tVerifications []Verification\n}\n\nfunc (u User) String() string {\n\tret := fmt.Sprint(u.Profile.String())\n\tret += \"\\n\\tVerifications: \"\n\tret += fmt.Sprint(u.Verifications)\n\treturn ret\n}\n\ntype Verification struct {\n\tIdentifier string `json:\"identifier\"`\n\tProofURL   string `json:\"proof_url\"`\n\tService    string `json:\"service\"`\n\tValid      bool   `json:\"valid\"`\n}\n\n\n\n\nfunc (c *client) GetUsers(usernames []string) (LookupResponse, error) {\n\turl := c.BaseUrl + \"/users/\" + strings.Join(usernames, \",\")\n\treturn c.GetUserObjects(url)\n}\n\n\nfunc (c *client) GetUserObjects(url string) (LookupResponse, error) {\n\tvar jsonObj LookupResponse\n\tjsonBytes, err := c.GetRequest(url)\n\tif err != nil {\n\t\treturn jsonObj, err\n\t}\n\terr = json.Unmarshal(jsonBytes, &jsonObj)\n\tif err != nil {\n\t\treturn jsonObj, JSONRead(err, jsonBytes)\n\t}\n\tif _, errorPresent := jsonObj[\"error\"]; errorPresent {\n\t\tvar errResp OneNameErrorResponse\n\t\terr = json.Unmarshal(jsonBytes, &errResp)\n\t\tif err == nil && errResp.Error != nil {\n\t\t\terr = errors.New(\"Error: \" + errResp.Error.Type + \" - \" + errResp.Error.Message)\n\t\t}\n\t}\n\treturn jsonObj, err\n}\n\nfunc (v Verification) String() string ", "output": "{\n\tret := \"\\n\"\n\tret += \"\\t\\tidentifier: \" + v.Identifier + \"\\n\"\n\tret += \"\\t\\tproof_url: \" + v.ProofURL + \"\\n\"\n\tret += \"\\t\\tservice: \" + v.Service + \"\\n\"\n\tret += \"\\t\\tvalid: \" + fmt.Sprint(v.Valid) + \"\\n\"\n\treturn ret\n}"}
{"input": "package sacloud\n\n\ntype propInterfaceDriver struct {\n\tInterfaceDriver EInterfaceDriver `json:\",omitempty\"` \n}\n\n\n\n\n\nfunc (p *propInterfaceDriver) GetInterfaceDriver() EInterfaceDriver {\n\treturn p.InterfaceDriver\n}\n\n\nfunc (p *propInterfaceDriver) SetInterfaceDriverByString(v string) {\n\tp.InterfaceDriver = EInterfaceDriver(v)\n}\n\n\nfunc (p *propInterfaceDriver) GetInterfaceDriverString() string {\n\treturn string(p.InterfaceDriver)\n}\n\nfunc (p *propInterfaceDriver) SetInterfaceDriver(v EInterfaceDriver) ", "output": "{\n\tp.InterfaceDriver = v\n}"}
{"input": "package main\n\nimport \"github.com/mkromkamp/BeaconD/sinks\"\nimport \"os\"\nimport \"os/signal\"\nimport \"sync\"\n\ntype beaconD struct {\n\tconfig    *configuration\n\tsinks     []sinks.LogSink\n\twaitGroup sync.WaitGroup\n}\n\nfunc main() {\n\tapp := beaconD{\n\t\tconfig: getConfig(),\n\t}\n\n\tapp.createSinks()\n\tapp.start()\n\n\tcancel := make(chan os.Signal)\n\tsignal.Notify(cancel, os.Interrupt)\n\n\tfor {\n\t\tselect {\n\t\tcase <-cancel:\n\t\t\tfor _, logSink := range app.sinks {\n\t\t\t\tlogSink.Stop()\n\t\t\t\tapp.waitGroup.Wait()\n\t\t\t\tos.Exit(3)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (app *beaconD) createSinks() (err error) {\n\tif app.config.enableFileSink() {\n\t\tfs, err := sinks.NewFileSink(app.config.SinksFileLog, app.config.SinksFileMaxSize, app.config.SinksFileMaxAge)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tapp.sinks = append(app.sinks, fs)\n\t}\n\n\tif app.config.enableSyslog() {\n\t\tss, err := sinks.NewSyslogSink()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tapp.sinks = append(app.sinks, ss)\n\t}\n\n\tif app.config.enableRSyslog() {\n\t\tss, err := sinks.NewRemoteSyslogSink(app.config.syslogAddress())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tapp.sinks = append(app.sinks, ss)\n\t}\n\n\treturn err\n}\n\n\n\nfunc (app *beaconD) start() ", "output": "{\n\tfor _, sink := range app.sinks {\n\t\tapp.waitGroup.Add(1)\n\t\tgo sink.Start(&app.waitGroup)\n\t}\n\n\tif app.config.Debug {\n\t\tgo startPprof()\n\t}\n\n\tgo startAPI(app.config.Debug, app.config.address(), app.sinks, app.config.CORS)\n}"}
{"input": "package types\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n\ntype Enablable interface {\n\tEnable() error\n\tDisable() error\n}\n\n\ntype Readable interface {\n\tValue() (bool, error)\n}\n\n\ntype JSONTime time.Time\n\n\n\n\n\ntype JSONDuration time.Duration\n\n\nfunc (d JSONDuration) MarshalJSON() ([]byte, error) {\n\tstamp := fmt.Sprintf(\"%f\", time.Duration(d).Seconds())\n\treturn []byte(stamp), nil\n}\n\n\ntype Point struct {\n\tLatitude  float64  `json:\"latitude\"`\n\tLongitude float64  `json:\"longitude\"`\n\tTime      JSONTime `json:\"time\"`\n}\n\nfunc (t JSONTime) MarshalJSON() ([]byte, error) ", "output": "{\n\tstamp := fmt.Sprintf(\"%d\", time.Time(t).Unix())\n\treturn []byte(stamp), nil\n}"}
{"input": "package reaperlog\n\nimport (\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"github.com/rifflock/lfshook\"\n\t\"go.mozilla.org/mozlogrus\"\n)\n\nvar config LogConfig\n\ntype LogConfig struct {\n\tExtras bool\n}\n\nfunc EnableExtras() {\n\tconfig.Extras = true\n}\n\nfunc EnableMozlog() {\n\tmozlogrus.Enable(\"Reaper\")\n}\n\nfunc Extras() bool {\n\treturn config.Extras\n}\n\nfunc SetConfig(c *LogConfig) {\n\tconfig = *c\n}\n\nfunc AddLogFile(filename string) {\n\tlog.AddHook(lfshook.NewHook(lfshook.PathMap{\n\t\tlog.DebugLevel: filename,\n\t\tlog.InfoLevel:  filename,\n\t\tlog.WarnLevel:  filename,\n\t\tlog.ErrorLevel: filename,\n\t\tlog.FatalLevel: filename,\n\t\tlog.PanicLevel: filename,\n\t}))\n}\n\nfunc Debug(format string, args ...interface{}) {\n\tlog.Debugf(format, args...)\n}\n\nfunc Info(format string, args ...interface{}) {\n\tlog.Infof(format, args...)\n}\n\nfunc Warning(format string, args ...interface{}) {\n\tlog.Warningf(format, args...)\n}\n\nfunc Fatal(format string, args ...interface{}) {\n\tlog.Fatalf(format, args...)\n}\n\nfunc Panic(format string, args ...interface{}) {\n\tlog.Panicf(format, args...)\n}\n\n\n\nfunc Error(format string, args ...interface{}) ", "output": "{\n\tlog.Errorf(format, args...)\n}"}
{"input": "package factor\n\nimport (\n\t\"github.com/jesand/stats\"\n\t\"github.com/jesand/stats/dist\"\n\t\"github.com/jesand/stats/variable\"\n)\n\n\n\n\ntype Factor interface {\n\n\tAdjacent() []variable.RandomVariable\n\n\tScore() float64\n}\n\n\n\n\nfunc NewDistFactor(vars []variable.RandomVariable, distr dist.Dist) *DistFactor {\n\treturn &DistFactor{\n\t\tVars: vars,\n\t\tDist: distr,\n\t}\n}\n\n\ntype DistFactor struct {\n\tVars []variable.RandomVariable\n\tDist dist.Dist\n}\n\n\nfunc (factor DistFactor) Adjacent() []variable.RandomVariable {\n\treturn factor.Vars\n}\n\n\n\n\n\nfunc NewConstFactor(vars []variable.RandomVariable, value float64) *ConstFactor {\n\treturn &ConstFactor{\n\t\tVars:  vars,\n\t\tValue: value,\n\t}\n}\n\n\ntype ConstFactor struct {\n\tVars  []variable.RandomVariable\n\tValue float64\n}\n\n\nfunc (factor ConstFactor) Adjacent() []variable.RandomVariable {\n\treturn factor.Vars\n}\n\n\nfunc (factor ConstFactor) Score() float64 {\n\treturn factor.Value\n}\n\nfunc (factor DistFactor) Score() float64 ", "output": "{\n\tvar (\n\t\tnumVars   = factor.Dist.NumVars()\n\t\tnumParams = factor.Dist.NumParams()\n\t)\n\tif len(factor.Vars) != numVars+numParams {\n\t\tpanic(stats.ErrfFactorVarNum(numVars, numParams, len(factor.Vars)))\n\t}\n\tvar (\n\t\tvars   = make([]float64, numVars)\n\t\tparams = make([]float64, numParams)\n\t)\n\tfor i, rv := range factor.Vars {\n\t\tif i < len(vars) {\n\t\t\tvars[i] = rv.Val()\n\t\t} else {\n\t\t\tparams[i-len(vars)] = rv.Val()\n\t\t}\n\t}\n\treturn factor.Dist.Score(vars, params)\n}"}
{"input": "package fabric\n\n\n\n\nfunc containsVirtual(s []Virtual, i Virtual) bool {\n\tfor _, v := range s {\n\t\tif i.ID() == v.ID() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc ContainsNode(l NodeList, n Node) bool {\n\tfor _, v := range l {\n\t\tif v.ID() == n.ID() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc ContainsEdge(l EdgeList, e Edge) bool {\n\tfor _, v := range l {\n\t\tif v.ID() == e.ID() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc contains(s []DGNode, i DGNode) bool ", "output": "{\n\tfor _, v := range s {\n\t\tif i.ID() == v.ID() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"}
{"input": "package provider\n\nimport (\n\t\"io\"\n\n\t\"github.com/jfbus/impressionist/filter\"\n\t\"github.com/jfbus/impressionist/img\"\n)\n\ntype Writer interface {\n\tWrite(i img.Img, quality int, w io.Writer) error\n}\n\ntype Provider interface {\n\tDecode(r io.Reader) (img.Img, error)\n\tFilterMap() map[string]filter.FilterBuilder\n\tWriterMap() map[string]Writer\n}\n\nvar provider Provider\n\nfunc Set(p Provider) {\n\tprovider = p\n}\n\nfunc Decode(r io.Reader) (img.Img, error) {\n\treturn provider.Decode(r)\n}\n\nfunc GetWriter(format string) Writer {\n\treturn provider.WriterMap()[format]\n}\n\nfunc GetFilterMap() map[string]filter.FilterBuilder ", "output": "{\n\treturn provider.FilterMap()\n}"}
{"input": "package cmd\n\nimport (\n\t\"testing\"\n\n\t\"github.com/docker/machine/libmachine\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc Test_unix_oc_path(t *testing.T) ", "output": "{\n\tapi := libmachine.NewClient(\"foo\", \"foo\")\n\tdefer api.Close()\n\tshellConfig, err := getOcShellConfig(api, \"/Users/john/.minishift/cache/oc/v1.5.0/oc\", \"bash\", false)\n\n\tassert.NoError(t, err)\n\texpectedOcDirPath := \"/Users/john/.minishift/cache/oc/v1.5.0\"\n\tassert.Equal(t, shellConfig.OcDirPath, expectedOcDirPath)\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSCloudFrontDistribution_ViewerCertificate struct {\n\n\tAcmCertificateArn string `json:\"AcmCertificateArn,omitempty\"`\n\n\tCloudFrontDefaultCertificate bool `json:\"CloudFrontDefaultCertificate,omitempty\"`\n\n\tIamCertificateId string `json:\"IamCertificateId,omitempty\"`\n\n\tMinimumProtocolVersion string `json:\"MinimumProtocolVersion,omitempty\"`\n\n\tSslSupportMethod string `json:\"SslSupportMethod,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) AWSCloudFormationType() string {\n\treturn \"AWS::CloudFront::Distribution.ViewerCertificate\"\n}\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) SetDeletionPolicy(policy policies.DeletionPolicy) ", "output": "{\n\tr._deletionPolicy = policy\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/135yshr/goracom\"\n\t\"github.com/135yshr/goracom/subscriber\"\n)\n\nvar (\n\temail    string\n\tpassword string\n\timsi     string\n)\n\nfunc init() {\n\tflag.Usage = func() {\n\t\tfmt.Println(\"Usage: subscriber <imsi>\")\n\t\tflag.PrintDefaults()\n\t}\n\tflag.StringVar(&email, \"email\", os.Getenv(\"SORACOM_EMAIL\"), \"Registered E-Mail\")\n\tflag.StringVar(&password, \"pw\", os.Getenv(\"SORACOM_PASSWORD\"), \"Login Password\")\n}\n\nfunc main() {\n\tflag.Parse()\n\n\tif email == \"\" || password == \"\" {\n\t\tflag.Usage()\n\t\tos.Exit(-1)\n\t}\n\n\tif 0 < flag.NArg() {\n\t\timsi = flag.Arg(0)\n\t}\n\n\tc, err := goracom.NewClient(email, password)\n\terrToPanic(err)\n\n\ts := c.NewSubscriber()\n\tif imsi != \"\" {\n\t\tsub, err := s.Sim(imsi)\n\t\terrToPanic(err)\n\t\tprintSubscriber(*sub)\n\t} else {\n\t\tss, err := s.FindAll()\n\t\terrToPanic(err)\n\n\t\tfmt.Println(\"===============================\")\n\t\tfor _, sub := range *ss {\n\t\t\tprintSubscriber(sub)\n\t\t\tfmt.Println(\"===============================\")\n\t\t}\n\t}\n}\n\nfunc errToPanic(err error) {\n\tif err != nil {\n\t\tfmt.Printf(\"%s\\n\\n\", err)\n\t\tflag.Usage()\n\t\tos.Exit(-1)\n\t}\n}\n\n\n\nfunc printSubscriber(sub subscriber.Subscriber) ", "output": "{\n\tfmt.Println(\"IMSI=\", sub.IMSI)\n\tfmt.Println(\"SpeedClass=\", sub.SpeedClass)\n\tfmt.Println(\"GroupID=\", sub.GroupId)\n\tfmt.Println(\"OperatorID=\", sub.OperatorId)\n\tfmt.Println(\"ModuleType=\", sub.ModuleType)\n\tfmt.Println(\"APN=\", sub.APN)\n}"}
{"input": "package gorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"github.com/jinzhu/gorm\"\n)\n\n\ntype GR struct {\n\tDB         *gorm.DB\n\tServerInfo \n}\n\n\n\ntype ServerInfo struct {\n\thost   string\n\tport   uint16\n\tdbname string\n\tuser   string\n\tpass   string\n}\n\nvar dbInfo GR\n\n\nfunc New(host, dbname, user, pass string, port uint16) error {\n\n\tvar err error\n\tif dbInfo.DB == nil {\n\t\tdbInfo.host = host\n\t\tdbInfo.port = port\n\t\tdbInfo.dbname = dbname\n\t\tdbInfo.user = user\n\t\tdbInfo.pass = pass\n\n\t\tdbInfo.DB, err = dbInfo.Connection()\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\n\nfunc (gr *GR) getDsn() string {\n\tparam := \"?charset=utf8&parseTime=True&loc=Local\"\n\treturn fmt.Sprintf(\"%s:%s@tcp(%s:%d)/%s%s\",\n\t\tgr.user, gr.pass, gr.host, gr.port, gr.dbname, param)\n}\n\n\n\nfunc (gr *GR) Connection() (*gorm.DB, error) {\n\treturn gorm.Open(\"mysql\", gr.getDsn())\n}\n\n\nfunc (gr *GR) Close() {\n\tgr.DB.Close()\n}\n\nfunc GetDB() *GR ", "output": "{\n\tif dbInfo.DB == nil {\n\t\tpanic(errors.New(\"DB instance is nil\"))\n\t}\n\treturn &dbInfo\n}"}
{"input": "package leveldb\n\nimport (\n\t\"github.com/gopkg/database/leveldb/cache\"\n\t\"github.com/gopkg/database/leveldb/filter\"\n\t\"github.com/gopkg/database/leveldb/opt\"\n)\n\n\n\nfunc (s *session) setOptions(o *opt.Options) ", "output": "{\n\ts.o = &opt.Options{}\n\tif o != nil {\n\t\t*s.o = *o\n\t}\n\tif filters := o.GetAltFilters(); len(filters) > 0 {\n\t\ts.o.AltFilters = make([]filter.Filter, len(filters))\n\t\tfor i, filter := range filters {\n\t\t\ts.o.AltFilters[i] = &iFilter{filter}\n\t\t}\n\t}\n\tswitch o.GetBlockCache() {\n\tcase nil:\n\t\ts.o.BlockCache = cache.NewLRUCache(opt.DefaultBlockCacheSize)\n\tcase opt.NoCache:\n\t\ts.o.BlockCache = nil\n\t}\n\ts.icmp = &iComparer{o.GetComparer()}\n\ts.o.Comparer = s.icmp\n\tif filter := o.GetFilter(); filter != nil {\n\t\ts.o.Filter = &iFilter{filter}\n\t}\n}"}
{"input": "package logging\n\nimport (\n\t\"log\"\n)\n\nvar VERBOSITY int = 1\n\nfunc Lg(level int, format string, a ...interface{}) {\n\tif level <= VERBOSITY {\n\t\tlog.Printf(format, a...)\n\t}\n}\n\n\n\nfunc FailOnError(err error, format string, a ...interface{}) ", "output": "{\n\tif err != nil {\n\t\tlog.Fatalf(format, a...)\n\t}\n}"}
{"input": "package netx\n\nimport (\n\t\"io\"\n\n\t\"github.com/simia-tech/netx/value\"\n)\n\ntype multicast struct {\n\tlistener io.ReadCloser\n\tconn     io.WriteCloser\n}\n\n\n\nfunc ListenAndDialMulticast(network, readAddress, writeAddress string, options ...value.Option) (io.ReadWriteCloser, error) {\n\tlistener, err := ListenMulticast(network, readAddress, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconn, err := DialMulticast(network, writeAddress, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &multicast{listener: listener, conn: conn}, nil\n}\n\nfunc (m *multicast) Read(buffer []byte) (int, error) {\n\treturn m.listener.Read(buffer)\n}\n\nfunc (m *multicast) Write(buffer []byte) (int, error) {\n\treturn m.conn.Write(buffer)\n}\n\n\n\nfunc (m *multicast) Close() error ", "output": "{\n\tif err := m.listener.Close(); err != nil {\n\t\treturn err\n\t}\n\tif err := m.conn.Close(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package node\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n\n\n\nfunc (n *Node) String() string ", "output": "{\n\ts := fmt.Sprintf(`  <node id=\"%d\" timestamp=\"%s\" uid=\"%d\" user=\"%s\" visible=\"%t\" version=\"%d\" changeset=\"%d\" lat=\"%f\" lon=\"%f\"`,\n\t\tn.Id_, n.Timestamp_.Format(time.RFC3339), n.User_.Id, n.User_.Name, n.Visible_,\n\t\tn.Version_, n.Changeset_, n.Position_.Lat, n.Position_.Lon)\n\tt := n.Tags_.String()\n\tif t == \"\" {\n\t\treturn s + \" />\\n\"\n\t}\n\treturn s + \">\\n\" + t + \"  </node>\\n\"\n}"}
{"input": "package latest\n\nimport (\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/apimachinery/pkg/runtime/serializer/json\"\n\t\"k8s.io/apimachinery/pkg/runtime/serializer/versioning\"\n\t\"k8s.io/client-go/tools/clientcmd/api\"\n\t\"k8s.io/client-go/tools/clientcmd/api/v1\"\n)\n\n\nconst Version = \"v1\"\n\nvar ExternalVersion = schema.GroupVersion{Group: \"\", Version: \"v1\"}\n\n\n\nconst OldestVersion = \"v1\"\n\n\n\n\n\nvar Versions = []string{\"v1\"}\n\nvar (\n\tCodec  runtime.Codec\n\tScheme *runtime.Scheme\n)\n\n\n\nfunc init() ", "output": "{\n\tScheme = runtime.NewScheme()\n\tif err := api.AddToScheme(Scheme); err != nil {\n\t\tpanic(err)\n\t}\n\tif err := v1.AddToScheme(Scheme); err != nil {\n\t\tpanic(err)\n\t}\n\tyamlSerializer := json.NewYAMLSerializer(json.DefaultMetaFactory, Scheme, Scheme)\n\tCodec = versioning.NewDefaultingCodecForScheme(\n\t\tScheme,\n\t\tyamlSerializer,\n\t\tyamlSerializer,\n\t\tschema.GroupVersion{Version: Version},\n\t\truntime.InternalGroupVersioner,\n\t)\n}"}
{"input": "package openshift\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/openshift/origin/pkg/oc/bootstrap/docker/errors\"\n)\n\n\nfunc ErrOpenShiftFailedToStart(container string) errors.Error {\n\treturn errors.NewError(\"could not start OpenShift container %q\", container)\n}\n\n\n\nfunc ErrTimedOutWaitingForStart(container string) errors.Error {\n\treturn errors.NewError(\"timed out waiting for OpenShift container %q\", container)\n}\n\ntype errPortsNotAvailable struct {\n\tports []int\n}\n\n\n\nfunc ErrPortsNotAvailable(ports []int) error {\n\treturn &errPortsNotAvailable{\n\t\tports: ports,\n\t}\n}\n\nfunc IsPortsNotAvailableErr(err error) bool {\n\t_, ok := err.(*errPortsNotAvailable)\n\treturn ok\n}\n\nfunc UnavailablePorts(err error) []int {\n\te, ok := err.(*errPortsNotAvailable)\n\tif !ok {\n\t\treturn []int{}\n\t}\n\treturn e.ports\n}\n\nfunc (e *errPortsNotAvailable) Error() string ", "output": "{\n\treturn fmt.Sprintf(\"ports in use: %v\", e.ports)\n}"}
{"input": "package gospell\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype Match struct {\n\tWord     []rune\n\tDistance int\n\tWeight   int\n}\n\ntype Matches []Match\n\nfunc (m1 Match) Equal(m2 Match) bool {\n\treturn string(m1.Word) == string(m2.Word) &&\n\t\tm1.Distance == m2.Distance && m1.Weight == m2.Weight\n}\n\nfunc (m Match) String() string {\n\treturn fmt.Sprintf(\"{%v %d %d}\", string(m.Word), m.Distance, m.Weight)\n}\n\nfunc (s Matches) Len() int      { return len(s) }\nfunc (s Matches) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\n\n\nfunc (s Matches) Strings() []string {\n\tstrings := make([]string, len(s))\n\tsort.Sort(ByDistance{s})\n\tfor i, r := range s {\n\t\tstrings[i] = string(r.Word)\n\t}\n\n\treturn strings\n}\n\ntype ByDistance struct {\n\tMatches\n}\n\nfunc (s ByDistance) Less(i, j int) bool {\n\td1 := s.Matches[i].Distance\n\td2 := s.Matches[j].Distance\n\tif d1 == d2 {\n\t\treturn string(s.Matches[i].Word) < string(s.Matches[j].Word)\n\t}\n\treturn d1 < d2\n}\n\n\n\nfunc (m *Match) update(r rune, distance, weight int) Match ", "output": "{\n\tm2 := Match{}\n\tif r != 0 {\n\t\tm2.Word = []rune{r}\n\t\tm2.Word = append(m2.Word, m.Word...)\n\t} else {\n\t\tm2.Word = m.Word[:]\n\t}\n\tm2.Distance = m.Distance + distance\n\tm2.Weight = m.Weight + weight\n\treturn m2\n}"}
{"input": "package blocks\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\tmh \"github.com/ipfs/go-ipfs/Godeps/_workspace/src/github.com/jbenet/go-multihash\"\n\tu \"github.com/ipfs/go-ipfs/util\"\n)\n\n\ntype Block struct {\n\tMultihash mh.Multihash\n\tData      []byte\n}\n\n\nfunc NewBlock(data []byte) *Block {\n\treturn &Block{Data: data, Multihash: u.Hash(data)}\n}\n\n\n\n\nfunc NewBlockWithHash(data []byte, h mh.Multihash) (*Block, error) {\n\tif u.Debug {\n\t\tchk := u.Hash(data)\n\t\tif string(chk) != string(h) {\n\t\t\treturn nil, errors.New(\"Data did not match given hash!\")\n\t\t}\n\t}\n\treturn &Block{Data: data, Multihash: h}, nil\n}\n\n\nfunc (b *Block) Key() u.Key {\n\treturn u.Key(b.Multihash)\n}\n\nfunc (b *Block) String() string {\n\treturn fmt.Sprintf(\"[Block %s]\", b.Key())\n}\n\n\n\nfunc (b *Block) Loggable() map[string]interface{} ", "output": "{\n\treturn map[string]interface{}{\n\t\t\"block\": b.Key().String(),\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/russmack/cloudsigma\"\n\t\"github.com/russmack/replizer\"\n\t\"github.com/russmack/statemachiner\"\n)\n\ntype CommandUsage struct {\n\tchannels *replizer.Channels\n}\n\nfunc NewUsage() *CommandUsage {\n\treturn &CommandUsage{}\n}\n\nfunc (m *CommandUsage) Start(channels *replizer.Channels) {\n\tm.channels = channels\n\tstateMachine := &statemachiner.StateMachine{}\n\tstateMachine.StartState = m.getUsage\n\tcargo := CommandUsage{}\n\tstateMachine.Start(cargo)\n}\n\n\n\nfunc (m *CommandUsage) getUsage(cargo interface{}) statemachiner.StateFn ", "output": "{\n\to := cloudsigma.NewUsage()\n\targs := o.NewList()\n\tm.channels.MessageChan <- fmt.Sprintf(\"Using username: %s\", session.Username)\n\targs.Username = session.Username\n\targs.Password = session.Password\n\targs.Location = session.Location\n\t_ = sendRequest(m.channels, args)\n\treturn nil\n}"}
{"input": "package args\n\nimport (\n\t\"fmt\"\n\t\"path\"\n\n\t\"github.com/spf13/pflag\"\n\tcodegenutil \"k8s.io/code-generator/pkg/util\"\n\t\"k8s.io/gengo/args\"\n)\n\n\ntype CustomArgs struct{}\n\n\n\n\n\nfunc (ca *CustomArgs) AddFlags(fs *pflag.FlagSet) {}\n\n\nfunc Validate(genericArgs *args.GeneratorArgs) error {\n\t_ = genericArgs.CustomArgs.(*CustomArgs)\n\n\tif len(genericArgs.OutputPackagePath) == 0 {\n\t\treturn fmt.Errorf(\"output package cannot be empty\")\n\t}\n\n\treturn nil\n}\n\nfunc NewDefaults() (*args.GeneratorArgs, *CustomArgs) ", "output": "{\n\tgenericArgs := args.Default().WithoutDefaultFlagParsing()\n\tcustomArgs := &CustomArgs{}\n\tgenericArgs.CustomArgs = customArgs\n\n\tif pkg := codegenutil.CurrentPackage(); len(pkg) != 0 {\n\t\tgenericArgs.OutputPackagePath = path.Join(pkg, \"pkg/client/listers\")\n\t}\n\n\treturn genericArgs, customArgs\n}"}
{"input": "package calendar\n\nimport (\n\t\"time\"\n)\n\nvar (\n\tentries = make(map[int]Entry)\n\tindex   int\n)\n\ntype Entry struct {\n\tID       int\n\tTitle    string\n\tStarts   time.Time\n\tFinishes time.Time\n}\n\nfunc (e Entry) Duration() time.Duration {\n\treturn e.Finishes.Sub(e.Starts)\n}\n\nfunc Lookup(id int) (Entry, bool) {\n\te, isPresent := entries[id]\n\treturn e, isPresent\n}\n\nfunc Add(e Entry) Entry {\n\tindex++\n\te.ID = index\n\tUpdate(e)\n\treturn e\n}\n\nfunc Update(e Entry) {\n\tentries[e.ID] = e\n}\n\n\n\nfunc Count() int {\n\treturn len(entries)\n}\n\nfunc All() []Entry {\n\tall := []Entry{}\n\tfor _, e := range entries {\n\t\tall = append(all, e)\n\t}\n\treturn all\n}\n\nfunc Remove(id int) ", "output": "{\n\tdelete(entries, id)\n}"}
{"input": "package proto\n\nimport ()\n\ntype getdata struct {\n\tCount     uint64\n\tInventory []byte\n}\n\nfunc NewGetdata() (*getdata, error) {\n\treturn nil, nil\n}\n\n\n\nfunc (v *getdata) Deserialize(packet []byte) error {\n\treturn nil\n}\n\nfunc (v *getdata) Serialize() ([]byte, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "func IPv6() (*JSONIP, error) {\n\treturn fetch(ipv6Endpoint)\n}\n\n\n\n\nfunc fetch(target string) (*JSONIP, error) ", "output": "{\n\tresp, err := http.Get(target)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar ip *JSONIP\n\terr = json.NewDecoder(resp.Body).Decode(&ip)\n\treturn ip, err\n}"}
{"input": "package minecraft\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"github.com/LilyPad/GoLilyPad/packet\"\n)\n\ntype PacketServerPluginMessage struct {\n\tChannel string\n\tData []byte\n}\n\nfunc NewPacketServerPluginMessage(channel string, data []byte) (this *PacketServerPluginMessage) {\n\tthis = new(PacketServerPluginMessage)\n\tthis.Channel = channel\n\tthis.Data = data\n\treturn\n}\n\n\n\ntype packetServerPluginMessageCodec struct {\n\n}\n\nfunc (this *packetServerPluginMessageCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\n\tpacketServerPluginMessage := new(PacketServerPluginMessage)\n\tpacketServerPluginMessage.Channel, err = packet.ReadString(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\tpacketServerPluginMessage.Data, err = ioutil.ReadAll(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\tdecode = packetServerPluginMessage\n\treturn\n}\n\nfunc (this *packetServerPluginMessageCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\n\tpacketServerPluginMessage := encode.(*PacketServerPluginMessage)\n\terr = packet.WriteString(writer, packetServerPluginMessage.Channel)\n\tif err != nil {\n\t\treturn\n\t}\n\t_, err = writer.Write(packetServerPluginMessage.Data)\n\treturn\n}\n\nfunc (this *PacketServerPluginMessage) Id() int ", "output": "{\n\treturn PACKET_SERVER_PLUGIN_MESSAGE\n}"}
{"input": "package security\n\nimport \"github.com/e-XpertSolutions/f5-rest-client/f5\"\n\n\ntype IPIntelligenseCategoryConfigList struct {\n\tItems    []IPIntelligenseCategoryConfig `json:\"items\"`\n\tKind     string                         `json:\"kind\"`\n\tSelfLink string                         `json:\"selflink\"`\n}\n\n\ntype IPIntelligenseCategoryConfig struct {\n}\n\n\nconst IPIntelligenseCategoryEndpoint = \"/ip-intelligence/category\"\n\n\ntype IPIntelligenseCategoryResource struct {\n\tc *f5.Client\n}\n\n\nfunc (r *IPIntelligenseCategoryResource) ListAll() (*IPIntelligenseCategoryConfigList, error) {\n\tvar list IPIntelligenseCategoryConfigList\n\tif err := r.c.ReadQuery(BasePath+IPIntelligenseCategoryEndpoint, &list); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &list, nil\n}\n\n\nfunc (r *IPIntelligenseCategoryResource) Get(id string) (*IPIntelligenseCategoryConfig, error) {\n\tvar item IPIntelligenseCategoryConfig\n\tif err := r.c.ReadQuery(BasePath+IPIntelligenseCategoryEndpoint, &item); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &item, nil\n}\n\n\nfunc (r *IPIntelligenseCategoryResource) Create(item IPIntelligenseCategoryConfig) error {\n\tif err := r.c.ModQuery(\"POST\", BasePath+IPIntelligenseCategoryEndpoint, item); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc (r *IPIntelligenseCategoryResource) Delete(id string) error {\n\tif err := r.c.ModQuery(\"DELETE\", BasePath+IPIntelligenseCategoryEndpoint+\"/\"+id, nil); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (r *IPIntelligenseCategoryResource) Edit(id string, item IPIntelligenseCategoryConfig) error ", "output": "{\n\tif err := r.c.ModQuery(\"PUT\", BasePath+IPIntelligenseCategoryEndpoint+\"/\"+id, item); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package secrets\n\nimport (\n\t\"sync\"\n\n\t\"github.com/docker/swarmkit/agent/exec\"\n\t\"github.com/docker/swarmkit/api\"\n)\n\n\n\ntype secrets struct {\n\tmu sync.RWMutex\n\tm  map[string]*api.Secret\n}\n\n\nfunc NewManager() exec.SecretsManager {\n\treturn &secrets{\n\t\tm: make(map[string]*api.Secret),\n\t}\n}\n\n\nfunc (s *secrets) Get(secretID string) *api.Secret {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\tif s, ok := s.m[secretID]; ok {\n\t\treturn s\n\t}\n\treturn nil\n}\n\n\nfunc (s *secrets) Add(secrets ...api.Secret) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tfor _, secret := range secrets {\n\t\ts.m[secret.ID] = secret.Copy()\n\t}\n}\n\n\n\nfunc (s *secrets) Remove(secrets []string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tfor _, secret := range secrets {\n\t\tdelete(s.m, secret)\n\t}\n}\n\n\nfunc (s *secrets) Reset() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.m = make(map[string]*api.Secret)\n}\n\n\ntype taskRestrictedSecretsProvider struct {\n\tsecrets   exec.SecretGetter\n\tsecretIDs map[string]struct{} \n}\n\nfunc (sp *taskRestrictedSecretsProvider) Get(secretID string) *api.Secret {\n\tif _, ok := sp.secretIDs[secretID]; !ok {\n\t\treturn nil\n\t}\n\n\treturn sp.secrets.Get(secretID)\n}\n\n\n\n\n\nfunc Restrict(secrets exec.SecretGetter, t *api.Task) exec.SecretGetter ", "output": "{\n\tsids := map[string]struct{}{}\n\n\tcontainer := t.Spec.GetContainer()\n\tif container != nil {\n\t\tfor _, ref := range container.Secrets {\n\t\t\tsids[ref.SecretID] = struct{}{}\n\t\t}\n\t}\n\n\treturn &taskRestrictedSecretsProvider{secrets: secrets, secretIDs: sids}\n}"}
{"input": "package model\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n)\n\nvar separator = []byte{0}\n\n\n\ntype Metric LabelSet\n\n\nfunc (m Metric) Equal(o Metric) bool {\n\treturn LabelSet(m).Equal(LabelSet(o))\n}\n\n\nfunc (m Metric) Before(o Metric) bool {\n\treturn LabelSet(m).Before(LabelSet(o))\n}\n\n\nfunc (m Metric) Clone() Metric {\n\tclone := Metric{}\n\tfor k, v := range m {\n\t\tclone[k] = v\n\t}\n\treturn clone\n}\n\n\n\n\nfunc (m Metric) Fingerprint() Fingerprint {\n\treturn LabelSet(m).Fingerprint()\n}\n\n\n\nfunc (m Metric) FastFingerprint() Fingerprint {\n\treturn LabelSet(m).FastFingerprint()\n}\n\n\ntype COWMetric struct {\n\tCopied bool\n\tMetric Metric\n}\n\n\n\nfunc (m *COWMetric) Set(ln LabelName, lv LabelValue) {\n\tm.doCOW()\n\tm.Metric[ln] = lv\n}\n\n\n\nfunc (m *COWMetric) Del(ln LabelName) {\n\tm.doCOW()\n\tdelete(m.Metric, ln)\n}\n\n\nfunc (m *COWMetric) doCOW() {\n\tif !m.Copied {\n\t\tm.Metric = m.Metric.Clone()\n\t\tm.Copied = true\n\t}\n}\n\n\nfunc (m COWMetric) String() string {\n\treturn m.Metric.String()\n}\n\n\nfunc (m COWMetric) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(m.Metric)\n}\n\nfunc (m Metric) String() string ", "output": "{\n\tmetricName, hasName := m[MetricNameLabel]\n\tnumLabels := len(m) - 1\n\tif !hasName {\n\t\tnumLabels = len(m)\n\t}\n\tlabelStrings := make([]string, 0, numLabels)\n\tfor label, value := range m {\n\t\tif label != MetricNameLabel {\n\t\t\tlabelStrings = append(labelStrings, fmt.Sprintf(\"%s=%q\", label, value))\n\t\t}\n\t}\n\n\tswitch numLabels {\n\tcase 0:\n\t\tif hasName {\n\t\t\treturn string(metricName)\n\t\t}\n\t\treturn \"{}\"\n\tdefault:\n\t\tsort.Strings(labelStrings)\n\t\treturn fmt.Sprintf(\"%s{%s}\", metricName, strings.Join(labelStrings, \", \"))\n\t}\n}"}
{"input": "package template\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n)\n\n\n\n\n\n\n\nfunc Must(t *Template, err error) *Template {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn t\n}\n\n\n\n\n\nfunc ParseFiles(filenames ...string) (*Template, error) {\n\treturn parseFiles(nil, filenames...)\n}\n\n\n\n\n\n\n\n\n\nfunc (t *Template) ParseFiles(filenames ...string) (*Template, error) {\n\tt.init()\n\treturn parseFiles(t, filenames...)\n}\n\n\n\n\n\n\n\n\n\n\nfunc ParseGlob(pattern string) (*Template, error) {\n\treturn parseGlob(nil, pattern)\n}\n\n\n\n\n\n\nfunc (t *Template) ParseGlob(pattern string) (*Template, error) {\n\tt.init()\n\treturn parseGlob(t, pattern)\n}\n\n\nfunc parseGlob(t *Template, pattern string) (*Template, error) {\n\tfilenames, err := filepath.Glob(pattern)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(filenames) == 0 {\n\t\treturn nil, fmt.Errorf(\"template: pattern matches no files: %#q\", pattern)\n\t}\n\treturn parseFiles(t, filenames...)\n}\n\nfunc parseFiles(t *Template, filenames ...string) (*Template, error) ", "output": "{\n\tif len(filenames) == 0 {\n\t\treturn nil, fmt.Errorf(\"template: no files named in call to ParseFiles\")\n\t}\n\tfor _, filename := range filenames {\n\t\tb, err := ioutil.ReadFile(filename)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ts := string(b)\n\t\tname := filepath.Base(filename)\n\t\tvar tmpl *Template\n\t\tif t == nil {\n\t\t\tt = New(name)\n\t\t}\n\t\tif name == t.Name() {\n\t\t\ttmpl = t\n\t\t} else {\n\t\t\ttmpl = t.New(name)\n\t\t}\n\t\t_, err = tmpl.Parse(s)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn t, nil\n}"}
{"input": "package framework\n\nimport \"github.com/onsi/gomega\"\n\n\nfunc ExpectEqual(actual interface{}, extra interface{}, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1, actual).To(gomega.Equal(extra), explain...)\n}\n\n\nfunc ExpectNotEqual(actual interface{}, extra interface{}, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1, actual).NotTo(gomega.Equal(extra), explain...)\n}\n\n\nfunc ExpectError(err error, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1, err).To(gomega.HaveOccurred(), explain...)\n}\n\n\nfunc ExpectNoError(err error, explain ...interface{}) {\n\tExpectNoErrorWithOffset(1, err, explain...)\n}\n\n\n\nfunc ExpectNoErrorWithOffset(offset int, err error, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1+offset, err).NotTo(gomega.HaveOccurred(), explain...)\n}\n\n\nfunc ExpectConsistOf(actual interface{}, extra interface{}, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1, actual).To(gomega.ConsistOf(extra), explain...)\n}\n\n\nfunc ExpectHaveKey(actual interface{}, key interface{}, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1, actual).To(gomega.HaveKey(key), explain...)\n}\n\n\n\n\nfunc ExpectEmpty(actual interface{}, explain ...interface{}) ", "output": "{\n\tgomega.ExpectWithOffset(1, actual).To(gomega.BeEmpty(), explain...)\n}"}
{"input": "package evoli\n\nimport \"math/rand\"\n\ntype crosserMock struct {\n}\n\nfunc (c crosserMock) Cross(parent1, parent2 Individual) (child1, child2 Individual, err error) {\n\tw := 0.1 + 0.8*rand.Float64()\n\treturn NewIndividual(w*parent1.Fitness() + (1-w)*parent2.Fitness()),\n\t\tNewIndividual((1-w)*parent1.Fitness() + w*parent2.Fitness()),\n\t\tnil\n}\n\ntype evaluaterMock struct {\n}\n\n\n\ntype mutaterMock struct {\n}\n\nfunc (m mutaterMock) Mutate(individual Individual, p float64) (Individual, error) {\n\treturn individual, nil\n}\n\ntype positionerMock struct {\n}\n\nfunc (p positionerMock) Position(indiv, pBest, gBest Individual, c1, c2 float64) (Individual, error) {\n\treturn NewIndividual((indiv.Fitness() + pBest.Fitness() + gBest.Fitness()) / 3), nil\n}\n\nfunc (e evaluaterMock) Evaluate(individual Individual) (Fitness float64, err error) ", "output": "{\n\treturn individual.Fitness(), nil\n}"}
{"input": "package markdownutils\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n)\n\n\n\n\n\nfunc CreateGitLabAnchor(text string) string {\n\tvar anchorName []rune\n\tvar lastWasDash = false\n\n\tfor _, r := range []rune(strings.TrimSpace(text)) {\n\t\tswitch {\n\t\tcase r == ' ' || r == '-':\n\t\t\tif !lastWasDash {\n\t\t\t\tanchorName = append(anchorName, '-')\n\t\t\t\tlastWasDash = true\n\t\t\t}\n\t\tcase unicode.IsLetter(r) || unicode.IsNumber(r):\n\t\t\tanchorName = append(anchorName, unicode.ToLower(r))\n\t\t\tlastWasDash = false\n\t\tdefault:\n\t\t}\n\t}\n\n\treturn string(anchorName)\n}\n\nfunc CreateGitHubAnchor(text string) string ", "output": "{\n\tvar anchorName []rune\n\n\tfor _, r := range []rune(strings.TrimSpace(text)) {\n\t\tswitch {\n\t\tcase r == ' ' || r == '-':\n\t\t\tanchorName = append(anchorName, '-')\n\t\tcase unicode.IsLetter(r) || unicode.IsNumber(r):\n\t\t\tanchorName = append(anchorName, unicode.ToLower(r))\n\t\tdefault:\n\t\t}\n\t}\n\n\treturn string(anchorName)\n}"}
{"input": "package clients\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"cloud.google.com/go/pubsub\"\n)\n\n\ntype PubSub struct {\n\tclient *pubsub.Client\n}\n\n\n\n\n\nfunc (p *PubSub) Topic(id string) *pubsub.Topic {\n\treturn p.client.Topic(id)\n}\n\n\nfunc (p *PubSub) Publish(ctx context.Context, topic *pubsub.Topic, message *pubsub.Message) (string, error) {\n\tdefer topic.Stop()\n\treturn topic.Publish(ctx, message).Get(ctx)\n}\n\nfunc NewPubSub(ctx context.Context, projectID string) (*PubSub, error) ", "output": "{\n\tclient, err := pubsub.NewClient(ctx, projectID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to init pubsub: %q\", err)\n\t}\n\treturn &PubSub{client: client}, nil\n}"}
{"input": "package udp\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n)\n\nconst (\n\tsenderAddr   = \"localhost:8090\"\n\treceiverAddr = \"localhost:8080\"\n)\n\nfunc TestUDPConnectionless(t *testing.T) {\n\tfmt.Println(\"Beginning test\")\n\n\trecChan := make(chan int, 1)\n\tla, err := net.ResolveUDPAddr(\"udp\", receiverAddr)\n\tif err != nil {\n\t\tt.Fatalf(\"Error resolving receiver address: %v\", err)\n\t}\n\n\tgo runReceiver(recChan, la, t)\n\ttime.Sleep(time.Second * 1)\n\trunSender(la, t)\n\n\t<-recChan\n\n\tfmt.Println(\"Exiting.\")\n\n}\n\nfunc runReceiver(recChan chan int, la *net.UDPAddr, t *testing.T) {\n\tfmt.Println(\"Getting listener\")\n\n\trecConn, err := net.ListenUDP(\"udp\", la)\n\tif err != nil {\n\t\tt.Fatalf(\"Error getting receiver's connection established: %v\", err)\n\t}\n\tdefer recConn.Close()\n\n\tfmt.Println(\"Starting receiver\")\n\n\tbuf := make([]byte, 1024)\n\t_, _, err = recConn.ReadFromUDP(buf)\n\tif err != nil {\n\t\tt.Fatalf(\"Error reading from UDP: %v\", err)\n\t}\n\tfmt.Println(\"Buffer said: \", string(buf))\n\trecChan <- 0\n}\n\n\n\n\nfunc runSender(la *net.UDPAddr, t *testing.T) ", "output": "{\n\tfmt.Println(\"Getting sender\")\n\tsendConn, err := net.ListenPacket(\"udp\", senderAddr) \n\tif err != nil {\n\t\tt.Fatalf(\"Error getting sender's connection established: %v\", err)\n\t}\n\tdefer sendConn.Close()\n\n\t_, err = sendConn.(*net.UDPConn).WriteToUDP([]byte(\"Hello receiver!\"), la) \n\tif err != nil {\n\t\tt.Fatalf(\"Error writing to UDP: %v\", err)\n\t}\n\tfmt.Println(\"Wrote to UDP connection\")\n}"}
{"input": "package service\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n)\n\n\ntype StandardErrorRespModel struct {\n\tErrorMessage string `json:\"error\"`\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc RespondWithSuccessOK(w http.ResponseWriter, respModel interface{}) {\n\tRespondWith(w, http.StatusOK, respModel)\n}\n\n\n\n\n\nfunc RespondWithBadRequestError(w http.ResponseWriter, errMsg string) {\n\tRespondWithError(w, http.StatusBadRequest, errMsg)\n}\n\n\nfunc RespondWithNotFoundError(w http.ResponseWriter, errMsg string) {\n\tRespondWithError(w, http.StatusNotFound, errMsg)\n}\n\n\nfunc RespondWithError(w http.ResponseWriter, httpErrCode int, errMsg string) {\n\tresp := StandardErrorRespModel{\n\t\tErrorMessage: errMsg,\n\t}\n\tRespondWithErrorJSON(w, httpErrCode, resp)\n}\n\n\nfunc RespondWithErrorJSON(w http.ResponseWriter, httpErrCode int, respModel interface{}) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(httpErrCode)\n\tif err := json.NewEncoder(w).Encode(&respModel); err != nil {\n\t\tlog.Println(\" [!] Exception: RespondWithErrorJSON: Error: \", err)\n\t}\n}\n\nfunc RespondWith(w http.ResponseWriter, httpStatusCode int, respModel interface{}) ", "output": "{\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(httpStatusCode)\n\tif err := json.NewEncoder(w).Encode(&respModel); err != nil {\n\t\tlog.Println(\" [!] Exception: RespondWith: Error: \", err)\n\t}\n}"}
{"input": "package evoli\n\nimport \"math/rand\"\n\ntype crosserMock struct {\n}\n\nfunc (c crosserMock) Cross(parent1, parent2 Individual) (child1, child2 Individual, err error) {\n\tw := 0.1 + 0.8*rand.Float64()\n\treturn NewIndividual(w*parent1.Fitness() + (1-w)*parent2.Fitness()),\n\t\tNewIndividual((1-w)*parent1.Fitness() + w*parent2.Fitness()),\n\t\tnil\n}\n\ntype evaluaterMock struct {\n}\n\nfunc (e evaluaterMock) Evaluate(individual Individual) (Fitness float64, err error) {\n\treturn individual.Fitness(), nil\n}\n\ntype mutaterMock struct {\n}\n\n\n\ntype positionerMock struct {\n}\n\nfunc (p positionerMock) Position(indiv, pBest, gBest Individual, c1, c2 float64) (Individual, error) {\n\treturn NewIndividual((indiv.Fitness() + pBest.Fitness() + gBest.Fitness()) / 3), nil\n}\n\nfunc (m mutaterMock) Mutate(individual Individual, p float64) (Individual, error) ", "output": "{\n\treturn individual, nil\n}"}
{"input": "package properties\n\nimport (\n\t\"fmt\"\n\t\"log\"\n)\n\nfunc ExampleLoad_iso88591() {\n\tbuf := []byte(\"key = ISO-8859-1 value with unicode literal \\\\u2318 and umlaut \\xE4\") \n\tp, _ := Load(buf, ISO_8859_1)\n\tv, ok := p.Get(\"key\")\n\tfmt.Println(ok)\n\tfmt.Println(v)\n}\n\nfunc ExampleLoad_utf8() {\n\tp, _ := Load([]byte(\"key = UTF-8 value with unicode character ⌘ and umlaut ä\"), UTF8)\n\tv, ok := p.Get(\"key\")\n\tfmt.Println(ok)\n\tfmt.Println(v)\n}\n\n\n\nfunc ExampleProperties_GetString() {\n\tp, _ := Load([]byte(\"key=value\"), ISO_8859_1)\n\tv := p.GetString(\"another key\", \"default value\")\n\tfmt.Println(v)\n}\n\nfunc Example() {\n\tp, err := Load([]byte(\"key=value\\nkey2=${key}\"), ISO_8859_1)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif v, ok := p.Get(\"key\"); ok {\n\t\tfmt.Println(v)\n\t}\n\n\tif _, ok := p.Get(\"does not exist\"); !ok {\n\t\tfmt.Println(\"invalid key\")\n\t}\n\n\tv := p.GetString(\"does not exist\", \"some value\")\n\tfmt.Println(v)\n\n\tfmt.Println(\"Expanded key/value pairs\")\n\tfmt.Println(p)\n\n}\n\nfunc ExampleProperties_GetBool() ", "output": "{\n\tvar input = `\n\tkey=1\n\tkey2=On\n\tkey3=YES\n\tkey4=true`\n\tp, _ := Load([]byte(input), ISO_8859_1)\n\tfmt.Println(p.GetBool(\"key\", false))\n\tfmt.Println(p.GetBool(\"key2\", false))\n\tfmt.Println(p.GetBool(\"key3\", false))\n\tfmt.Println(p.GetBool(\"key4\", false))\n\tfmt.Println(p.GetBool(\"keyX\", false))\n}"}
{"input": "package trafficmanager\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype ManagementClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) ManagementClient {\n\treturn ManagementClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}\n\nfunc New(subscriptionID string) ManagementClient ", "output": "{\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}"}
{"input": "package virtualbox\n\nimport \"net\"\n\n\n\n\n\nfunc ParseIPv4Mask(s string) net.IPMask ", "output": "{\n\tmask := net.ParseIP(s)\n\tif mask == nil {\n\t\treturn nil\n\t}\n\treturn net.IPv4Mask(mask[12], mask[13], mask[14], mask[15])\n}"}
{"input": "package points \n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype CartesianPoint struct {\n\tx, y float64\n}\n\ntype PolarPoint struct {\n\tr, θ float64\n}\n\nfunc (p CartesianPoint) X() float64 { return p.x }\nfunc (p CartesianPoint) Y() float64 { return p.y }\nfunc (p *CartesianPoint) SetX(x float64) { p.x = x }\nfunc (p *CartesianPoint) SetY(y float64) { p.y = y }\n\nfunc (p PolarPoint) X() float64 { return p.r * math.Cos(p.θ) }\nfunc (p PolarPoint) Y() float64 { return p.r * math.Sin(p.θ) }\nfunc (p *PolarPoint) SetX(num float64) { p.r = num / math.Cos(p.θ) }\nfunc (p *PolarPoint) SetY(num float64) { p.θ = num / math.Sin(p.θ) }\n\n\n\n\nfunc (self PolarPoint) Print() {\n\tfmt.Printf(\"(%f, %f)\\n\", self.r, self.θ)\n}\n\nfunc NewPoint(type_string string) Point {\n\tvar p Point\n\tif type_string == \"CartesianPoint\" { \n\t\tp = &CartesianPoint{}\n\t} else {\n\t\tp = &PolarPoint{}\n\t}\n\treturn p\n}\n\ntype Point interface {\n\tPrinter\n\tX() float64\n\tY() float64\n\tSetX(x float64) \n\tSetY(y float64) \n}\n\ntype Printer interface {\n\tPrint()\n}\n\nfunc (self CartesianPoint) Print() ", "output": "{\n\tfmt.Printf(\"(%f, %f)\\n\", self.x, self.y)\n}"}
{"input": "package constants\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/zxh0/jvm.go/instructions/base\"\n\t\"github.com/zxh0/jvm.go/rtda\"\n\t\"github.com/zxh0/jvm.go/rtda/heap\"\n)\n\n\ntype LDC struct{ base.Index8Instruction }\n\nfunc (instr *LDC) Execute(frame *rtda.Frame) {\n\t_ldc(frame, instr.Index)\n}\n\n\ntype LDC_W struct{ base.Index16Instruction }\n\nfunc (instr *LDC_W) Execute(frame *rtda.Frame) {\n\t_ldc(frame, instr.Index)\n}\n\nfunc _ldc(frame *rtda.Frame, index uint) {\n\tc := frame.GetConstantPool().GetConstant(index)\n\n\tswitch x := c.(type) {\n\tcase int32:\n\t\tframe.PushInt(x)\n\tcase float32:\n\t\tframe.PushFloat(x)\n\tcase *heap.ConstantString: \n\t\tframe.PushRef(x.GetJString())\n\tcase *heap.ConstantClass:\n\t\tframe.PushRef(x.GetClass().JClass)\n\tdefault:\n\t\tpanic(fmt.Errorf(\"todo: ldc! %v\", c))\n\t}\n}\n\n\ntype LDC2_W struct{ base.Index16Instruction }\n\n\n\nfunc (instr *LDC2_W) Execute(frame *rtda.Frame) ", "output": "{\n\tc := frame.GetConstantPool().GetConstant(instr.Index)\n\n\tswitch c.(type) {\n\tcase int64:\n\t\tframe.PushLong(c.(int64))\n\tcase float64:\n\t\tframe.PushDouble(c.(float64))\n\tdefault:\n\t\tpanic(fmt.Errorf(\"ldc2_w! %v\", c))\n\t}\n}"}
{"input": "package handlers\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/go-openapi/runtime\"\n\n\t\"github.com/sapcc/kubernikus/pkg/api/models\"\n)\n\ntype ErrorResponse interface {\n\tSetStatusCode(code int)\n\tSetPayload(payload *models.Error)\n\tWriteResponse(rw http.ResponseWriter, producer runtime.Producer)\n}\n\n\n\nfunc NewErrorResponse(resp ErrorResponse, code int, msg string, a ...interface{}) ErrorResponse ", "output": "{\n\tresp.SetStatusCode(code)\n\tm := fmt.Sprintf(msg, a...)\n\tc := int64(code)\n\n\tresp.SetPayload(&models.Error{\n\t\tMessage: m,\n\t\tCode:    c,\n\t})\n\treturn resp\n}"}
{"input": "package backend\n\nimport (\n\t\"net/http\"\n)\n\nconst (\n\tCONSENT_SAMPLE_PATH = \"/\" + CATEGORY_SAMPLE_TEMPLATES + \"/consent/\"\n)\n\nfunc InitAmpConsent() {\n\tRegisterHandler(CONSENT_SAMPLE_PATH+\"getConsent\", onlyPost(submitConsentXHR))\n}\n\n\n\nfunc submitConsentXHR(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tSendJsonResponse(w, map[string]bool{\n\t\t\"promptIfUnknown\": true,\n\t})\n}"}
{"input": "package model\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n)\n\ntype ClusterInfo struct {\n\tId         string `json:\"id\"`\n\tVersion    string `json:\"version\"`\n\tConfigHash string `json:\"config_hash\"`\n\tIpAddress  string `json:\"ipaddress\"`\n\tHostname   string `json:\"hostname\"`\n}\n\nfunc (ci *ClusterInfo) ToJson() string {\n\tb, _ := json.Marshal(ci)\n\treturn string(b)\n}\n\nfunc ClusterInfoFromJson(data io.Reader) *ClusterInfo {\n\tvar ci *ClusterInfo\n\tjson.NewDecoder(data).Decode(&ci)\n\treturn ci\n}\n\nfunc ClusterInfosToJson(objmap []*ClusterInfo) string {\n\tb, _ := json.Marshal(objmap)\n\treturn string(b)\n}\n\n\n\nfunc ClusterInfosFromJson(data io.Reader) []*ClusterInfo ", "output": "{\n\tdecoder := json.NewDecoder(data)\n\n\tvar objmap []*ClusterInfo\n\tif err := decoder.Decode(&objmap); err != nil {\n\t\treturn make([]*ClusterInfo, 0)\n\t}\n\treturn objmap\n}"}
{"input": "package fake\n\nimport (\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n\n\tv1beta1 \"kubevirt.io/client-go/generated/containerized-data-importer/clientset/versioned/typed/core/v1beta1\"\n)\n\ntype FakeCdiV1beta1 struct {\n\t*testing.Fake\n}\n\nfunc (c *FakeCdiV1beta1) CDIs() v1beta1.CDIInterface {\n\treturn &FakeCDIs{c}\n}\n\nfunc (c *FakeCdiV1beta1) CDIConfigs() v1beta1.CDIConfigInterface {\n\treturn &FakeCDIConfigs{c}\n}\n\nfunc (c *FakeCdiV1beta1) DataImportCrons(namespace string) v1beta1.DataImportCronInterface {\n\treturn &FakeDataImportCrons{c, namespace}\n}\n\n\n\nfunc (c *FakeCdiV1beta1) DataVolumes(namespace string) v1beta1.DataVolumeInterface {\n\treturn &FakeDataVolumes{c, namespace}\n}\n\nfunc (c *FakeCdiV1beta1) ObjectTransfers() v1beta1.ObjectTransferInterface {\n\treturn &FakeObjectTransfers{c}\n}\n\nfunc (c *FakeCdiV1beta1) StorageProfiles() v1beta1.StorageProfileInterface {\n\treturn &FakeStorageProfiles{c}\n}\n\n\n\nfunc (c *FakeCdiV1beta1) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakeCdiV1beta1) DataSources(namespace string) v1beta1.DataSourceInterface ", "output": "{\n\treturn &FakeDataSources{c, namespace}\n}"}
{"input": "package http\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\n\ntype Client interface {\n\tSend(*HttpRequest) (*HttpResponse, error)\n}\n\n\ntype HttpClient struct {\n}\n\n\nfunc NewHttpClient() HttpClient {\n\treturn HttpClient{}\n}\n\n\nfunc (c *HttpClient) Send(req *HttpRequest) (*HttpResponse, error) {\n\thttpClient, err := c.buildHTTPClient(req.GetTimeout())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thttpReq, err := req.buildHTTPRequest()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := c.doHTTPRequest(httpClient, httpReq)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, nil\n}\n\n\n\nfunc (c *HttpClient) doHTTPRequest(client *http.Client, req *http.Request) (*HttpResponse, error) {\n\thttpResp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer httpResp.Body.Close()\n\n\tif httpResp.StatusCode >= 400 {\n\t\treturn nil, NewStatusError(httpResp.StatusCode, httpResp.Status)\n\t}\n\n\tbody, err := ioutil.ReadAll(httpResp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp := NewHttpResponse()\n\tresp.setHttpResponse(httpResp)\n\tresp.SetBody(body)\n\treturn resp, nil\n}\n\nfunc (c *HttpClient) buildHTTPClient(timeout time.Duration) (*http.Client, error) ", "output": "{\n\thttpClient := http.Client{}\n\tif timeout != 0 {\n\t\thttpClient = http.Client{Timeout: timeout}\n\t}\n\treturn &httpClient, nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/sendgrid/sendgrid-go\"\n\t\"os\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc UpdatesNewRelicpartnersettings() {\n  apiKey := os.Getenv(\"YOUR_SENDGRID_APIKEY\")\n  host := \"https://api.sendgrid.com\"\n  request := sendgrid.GetRequest(apiKey, \"/v3/partner_settings/new_relic\", host)\n  request.Method = \"PATCH\"\n  request.Body = []byte(` {\n  \"enable_subuser_statistics\": true, \n  \"enabled\": true, \n  \"license_key\": \"\"\n}`)\n  response, err := sendgrid.API(request)\n  if err != nil {\n    fmt.Println(err)\n  } else {\n    fmt.Println(response.StatusCode)\n    fmt.Println(response.Body)\n    fmt.Println(response.Headers)\n  }\n}\n\n\n\n\n\nfunc ReturnsallNewRelicpartnersettings() {\n  apiKey := os.Getenv(\"YOUR_SENDGRID_APIKEY\")\n  host := \"https://api.sendgrid.com\"\n  request := sendgrid.GetRequest(apiKey, \"/v3/partner_settings/new_relic\", host)\n  request.Method = \"GET\"\n  response, err := sendgrid.API(request)\n  if err != nil {\n    fmt.Println(err)\n  } else {\n    fmt.Println(response.StatusCode)\n    fmt.Println(response.Body)\n    fmt.Println(response.Headers)\n  }\n}\n\nfunc main() {\n    \n}\n\nfunc Returnsalistofallpartnersettings() ", "output": "{\n  apiKey := os.Getenv(\"YOUR_SENDGRID_APIKEY\")\n  host := \"https://api.sendgrid.com\"\n  request := sendgrid.GetRequest(apiKey, \"/v3/partner_settings\", host)\n  request.Method = \"GET\"\n  queryParams := make(map[string]string)\n  queryParams[\"limit\"] = \"1\"\n  queryParams[\"offset\"] = \"1\"\n  request.QueryParams = queryParams\n  response, err := sendgrid.API(request)\n  if err != nil {\n    fmt.Println(err)\n  } else {\n    fmt.Println(response.StatusCode)\n    fmt.Println(response.Body)\n    fmt.Println(response.Headers)\n  }\n}"}
{"input": "package dockerfile\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/docker/docker/pkg/system\"\n)\n\n\n\n\n\nfunc errNotJSON(command, original string) error {\n\textra := \"\"\n\toriginal = filepath.FromSlash(strings.ToLower(strings.Replace(strings.ToLower(original), strings.ToLower(command)+\" \", \"\", -1)))\n\tif len(regexp.MustCompile(`\"[a-z]:\\\\.*`).FindStringSubmatch(original)) > 0 &&\n\t\t!strings.Contains(original, `\\\\`) &&\n\t\tstrings.Contains(original, \"[\") &&\n\t\tstrings.Contains(original, \"]\") {\n\t\textra = fmt.Sprintf(`. It looks like '%s' includes a file path without an escaped back-slash. JSON requires back-slashes to be escaped such as [\"c:\\\\path\\\\to\\\\file.exe\", \"/parameter\"]`, original)\n\t}\n\treturn fmt.Errorf(\"%s requires the arguments to be in JSON form%s\", command, extra)\n}\n\nfunc normaliseWorkdir(current string, requested string) (string, error) ", "output": "{\n\tif requested == \"\" {\n\t\treturn \"\", fmt.Errorf(\"cannot normalise nothing\")\n\t}\n\n\tcurrent = filepath.FromSlash(current)\n\trequested = filepath.FromSlash(requested)\n\n\tif len(current) == 0 || system.IsAbs(requested) {\n\t\tif (requested[0] == os.PathSeparator) ||\n\t\t\t(len(requested) > 1 && string(requested[1]) != \":\") ||\n\t\t\t(len(requested) == 1) {\n\t\t\trequested = filepath.Join(`C:\\`, requested)\n\t\t}\n\t} else {\n\t\trequested = filepath.Join(current, requested)\n\t}\n\treturn (strings.ToUpper(string(requested[0])) + requested[1:]), nil\n}"}
{"input": "package cat\n\nimport (\n\t\"time\"\n)\n\nvar (\n\taggregator_message_channel chan Message\n\taggregator_max_batch_size  int\n)\n\nfunc cat_aggregator_init() {\n\taggregator_message_channel = make(chan Message, 1<<10)\n\taggregator_max_batch_size = 1 << 8\n\tgo aggregator_run()\n}\n\nfunc aggregator_run() {\n\tfor {\n\t\tif aggregator_collect() {\n\t\t\ttime.Sleep(1 << 16 * time.Microsecond)\n\t\t}\n\t}\n}\n\n\nfunc aggregator_collect() bool {\n\tmessages := make(chan Message, sender_max_batch_size)\n\tvar count = 0\ncollect:\n\tfor count < aggregator_max_batch_size {\n\t\tselect {\n\t\tcase message := <-aggregator_message_channel:\n\t\t\tmessages <- message\n\t\t\tcount++\n\t\tdefault:\n\t\t\tbreak collect\n\t\t}\n\t}\n\tclose(messages)\n\tif count > 0 {\n\t\taggregator_transfer(messages)\n\t\treturn false\n\t} else {\n\t\treturn true\n\t}\n}\n\n\n\nfunc aggregator_transfer(messages <-chan Message) ", "output": "{\n\tt := NewTransaction(\"_CatMergeTree\", \"_CatMergeTree\", nil)\n\tfor message := range messages {\n\t\tt.AddChild(message)\n\t}\n\tt.SetStatus(\"0\")\n\tt.Complete()\n\tsender_transaction_channel <- t\n}"}
{"input": "package format\n\nimport (\n\t\"reflect\"\n\t\"strconv\"\n)\n\n\nfunc Any(value interface{}) string {\n\treturn formatAtom(reflect.ValueOf(value))\n}\n\n\n\n\nfunc formatAtom(v reflect.Value) string ", "output": "{\n\tswitch v.Kind() {\n\tcase reflect.Invalid:\n\t\treturn \"invalid\"\n\tcase reflect.Int, reflect.Int8, reflect.Int16,\n\t\treflect.Int32, reflect.Int64:\n\t\treturn strconv.FormatInt(v.Int(), 10)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16,\n\t\treflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn strconv.FormatUint(v.Uint(), 10)\n\tcase reflect.Bool:\n\t\treturn strconv.FormatBool(v.Bool())\n\tcase reflect.String:\n\t\treturn strconv.Quote(v.String())\n\tcase reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:\n\t\treturn v.Type().String() + \" 0x\" +\n\t\t\tstrconv.FormatUint(uint64(v.Pointer()), 16)\n\tdefault: \n\t\treturn v.Type().String() + \" value\"\n\t}\n}"}
{"input": "package goleveldb\n\nimport (\n\t\"github.com/astutesparrow/rockslevel/store\"\n\t\"github.com/syndtr/goleveldb/leveldb\"\n)\n\ntype WriteBatch struct {\n\tdb     *DB\n\twbatch *leveldb.Batch\n}\n\nfunc (w *WriteBatch) Put(key, value []byte) {\n\tw.wbatch.Put(key, value)\n}\n\nfunc (w *WriteBatch) Delete(key []byte) {\n\tw.wbatch.Delete(key)\n}\n\n\n\nfunc (w *WriteBatch) SyncCommit() error {\n\treturn w.db.db.Write(w.wbatch, w.db.syncOpts)\n}\n\nfunc (w *WriteBatch) Rollback() error {\n\tw.wbatch.Reset()\n\treturn nil\n}\n\nfunc (w *WriteBatch) Close() {\n\tw.wbatch.Reset()\n}\n\nfunc (w *WriteBatch) Data() []byte {\n\treturn w.wbatch.Dump()\n}\n\nfunc (w *WriteBatch) BatchData() *store.BatchData {\n\treturn nil\n}\n\nfunc (w *WriteBatch) Commit() error ", "output": "{\n\treturn w.db.db.Write(w.wbatch, nil)\n}"}
{"input": "package main\n\n\nimport \"C\"\nimport \"unsafe\"\n\n\nfunc journal_open() int {\n\n\treturn int(C.journal_open())\n}\n\nfunc journal_close() int {\n\n\treturn int(C.journal_close())\n}\n\n\n\n\n\nfunc journal_next() int {\n\n\treturn int(C.journal_next())\n}\n\nfunc journal_previous() int {\n\n\treturn int(C.journal_previous())\n}\n\n\nfunc journal_get_data(data *string) int {\n\n\tvar r int\n\tvar n *C.char\n\n\tdefer C.free(unsafe.Pointer(n))\n\tr = int(C.journal_get_data(&n))\n\t*data = C.GoString(n)\n\n\treturn r\n}\n\n\nfunc journal_get_cursor(cursor *string) int {\n\n\tvar r int\n\tvar n *C.char\n\n\tdefer C.free(unsafe.Pointer(n))\n\tr = int(C.journal_get_cursor(&n))\n\t*cursor = C.GoString(n)\n\n\treturn r\n}\n\nfunc journal_test_cursor(cursor string) int {\n\n\treturn int(C.journal_test_cursor(C.CString(cursor)))\n}\n\n\nfunc journal_add_match(m string) int {\n\n\treturn int(C.journal_add_match(C.CString(m)))\n}\n\nfunc journal_add_disjunction() int {\n\n\treturn int(C.journal_add_disjunction())\n}\n\nfunc journal_add_conjunction() int {\n\n\treturn int(C.journal_add_disjunction())\n}\n\nfunc journal_flush_matches() int {\n\n\treturn int(C.journal_flush_matches())\n}\n\nfunc journal_seek_tail() int ", "output": "{\n\n\treturn int(C.journal_seek_tail())\n}"}
{"input": "package docker\n\nimport (\n\t\"docker.io/go-docker/api/types\"\n\t\"docker.io/go-docker/api/types/swarm\"\n\t\"golang.org/x/net/context\"\n)\n\ntype TasksBySlot []swarm.Task\n\n\n\nfunc (t TasksBySlot) Swap(i, j int) {\n\tt[i], t[j] = t[j], t[i]\n}\n\nfunc (t TasksBySlot) Less(i, j int) bool {\n\tif t[i].Slot != t[j].Slot {\n\t\treturn t[i].Slot < t[j].Slot\n\t}\n\n\treturn t[j].Meta.CreatedAt.Before(t[i].CreatedAt)\n}\n\n\nfunc (d *Docker) TaskList(ctx context.Context, options types.TaskListOptions) ([]swarm.Task, error) {\n\treturn d.client.TaskList(ctx, options)\n}\n\nfunc (t TasksBySlot) Len() int ", "output": "{\n\treturn len(t)\n}"}
{"input": "package cmd\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/spf13/cobra\"\n\n\t\"github.com/spf13/viper\"\n)\n\nvar (\n\tcfgFile  string\n\tproject  string\n\tinstance string\n\tdatabase string\n\n\trootCmd = &cobra.Command{\n\t\tUse:   \"gcsb\",\n\t\tShort: \"Like YCSB but for spanner\",\n\t\tLong:  ``,\n\t}\n)\n\n\n\nfunc Execute() {\n\tif err := rootCmd.Execute(); err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}\n\n\n\n\nfunc initConfig() {\n\tif cfgFile != \"\" {\n\t\tviper.SetConfigFile(cfgFile)\n\t} else {\n\t\tviper.AddConfigPath(\".\")\n\t\tviper.SetConfigName(\"gcsb\")\n\t}\n\n\tviper.AutomaticEnv() \n\tviper.SetEnvPrefix(\"GCSB\")\n\tviper.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\"))\n\n\n\tviper.ReadInConfig() \n}\n\nfunc init() ", "output": "{\n\tcobra.OnInitialize(initConfig)\n\n\tflags := rootCmd.PersistentFlags()\n\tflags.StringVar(&cfgFile, \"config\", \"\", \"config file (default is ./gcsb.yaml)\")\n\n\tflags.StringVarP(&project, \"project\", \"p\", \"\", \"GCP Project\")\n\tviper.BindPFlag(\"project\", flags.Lookup(\"project\")) \n\n\tflags.StringVarP(&instance, \"instance\", \"i\", \"\", \"Spanner Instance\")\n\tviper.BindPFlag(\"instance\", flags.Lookup(\"instance\"))\n\n\tflags.StringVarP(&database, \"database\", \"d\", \"\", \"Spanner Database\")\n\tviper.BindPFlag(\"database\", flags.Lookup(\"database\"))\n}"}
{"input": "package cabf_br\n\n\n\nimport (\n\t\"testing\"\n\n\t\"github.com/zmap/zlint/v3/lint\"\n\t\"github.com/zmap/zlint/v3/test\"\n)\n\n\n\nfunc TestDNSNameNotEmptyLabel(t *testing.T) {\n\tinputPath := \"dnsNameNotEmptyLabel.pem\"\n\texpected := lint.Pass\n\tout := test.TestLint(\"e_dnsname_empty_label\", inputPath)\n\tif out.Status != expected {\n\t\tt.Errorf(\"%s: expected %s, got %s\", inputPath, expected, out.Status)\n\t}\n}\n\nfunc TestDNSNameEmptyLabel(t *testing.T) ", "output": "{\n\tinputPath := \"dnsNameEmptyLabel.pem\"\n\texpected := lint.Error\n\tout := test.TestLint(\"e_dnsname_empty_label\", inputPath)\n\tif out.Status != expected {\n\t\tt.Errorf(\"%s: expected %s, got %s\", inputPath, expected, out.Status)\n\t}\n}"}
{"input": "package jobs\n\nimport (\n\t\"github.com/simplemvc/gocorelib/cron\"\n\t\"github.com/simplemvc/gocorelib/revel\"\n\t\"strings\"\n\t\"time\"\n)\n\n\n\n\n\n\ntype Func func()\n\nfunc (r Func) Run() { r() }\n\nfunc Schedule(spec string, job cron.Job) {\n\tif strings.HasPrefix(spec, \"cron.\") {\n\t\tconfSpec, found := revel.Config.String(spec)\n\t\tif !found {\n\t\t\tpanic(\"Cron spec not found: \" + spec)\n\t\t}\n\t\tspec = confSpec\n\t}\n\tMainCron.Schedule(cron.Parse(spec), New(job))\n}\n\n\n\n\n\n\n\nfunc Now(job cron.Job) {\n\tgo New(job).Run()\n}\n\n\nfunc In(duration time.Duration, job cron.Job) {\n\tgo func() {\n\t\ttime.Sleep(duration)\n\t\tNew(job).Run()\n\t}()\n}\n\nfunc Every(duration time.Duration, job cron.Job) ", "output": "{\n\tMainCron.Schedule(cron.Every(duration), New(job))\n}"}
{"input": "package net_sniff\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/bettercap/bettercap/session\"\n\n\t\"github.com/evilsocket/islazy/tui\"\n\t\"github.com/google/gopacket/layers\"\n)\n\nfunc vIP(ip net.IP) string {\n\tif session.I.Interface.IP.Equal(ip) {\n\t\treturn tui.Dim(\"local\")\n\t} else if session.I.Gateway.IP.Equal(ip) {\n\t\treturn \"gateway\"\n\t}\n\n\taddress := ip.String()\n\thost := session.I.Lan.GetByIp(address)\n\tif host != nil {\n\t\tif host.Hostname != \"\" {\n\t\t\treturn host.Hostname\n\t\t}\n\t}\n\n\treturn address\n}\n\n\n\nvar maxUrlSize = 80\n\nfunc vURL(u string) string {\n\tul := len(u)\n\tif ul > maxUrlSize {\n\t\tu = fmt.Sprintf(\"%s...\", u[0:maxUrlSize-3])\n\t}\n\treturn u\n}\n\nfunc vPort(p interface{}) string ", "output": "{\n\tsp := fmt.Sprintf(\"%d\", p)\n\tif tcp, ok := p.(layers.TCPPort); ok {\n\t\tif name, found := layers.TCPPortNames[tcp]; found {\n\t\t\tsp = tui.Yellow(name)\n\t\t}\n\t} else if udp, ok := p.(layers.UDPPort); ok {\n\t\tif name, found := layers.UDPPortNames[udp]; found {\n\t\t\tsp = tui.Yellow(name)\n\t\t}\n\t}\n\n\treturn sp\n}"}
{"input": "package kegg\n\nimport (\n\t\"fmt\"\n)\n\n\n\nfunc ExampleGet() {\n\tinfo, err := New().Get(\"drug\", \"D00341\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(info != \"\")\n}\n\nfunc ExampleFind() {\n\tmatch, err := New().Find(\"drug\", \"D00341\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(match != \"\")\n}\n\nfunc ExampleLink() {\n\tcompoundID, err := New().Link(\"drug\", \"compound\", \"D00341\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(compoundID)\n}\n\nfunc ExampleConvert() ", "output": "{\n\tdrugID, err := New().Convert(\"pubchem\", \"drug\", \"313046637\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(drugID)\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/swag\"\n)\n\n\n\ntype OpenpitrixCreateReleaseRequest struct {\n\n\tAppID string `json:\"app_id,omitempty\"`\n\n\tNamespace string `json:\"namespace,omitempty\"`\n\n\tReleaseName string `json:\"release_name,omitempty\"`\n\n\tRuntimeID string `json:\"runtime_id,omitempty\"`\n\n\tVersionID string `json:\"version_id,omitempty\"`\n}\n\n\n\n\n\nfunc (m *OpenpitrixCreateReleaseRequest) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\nfunc (m *OpenpitrixCreateReleaseRequest) UnmarshalBinary(b []byte) error {\n\tvar res OpenpitrixCreateReleaseRequest\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *OpenpitrixCreateReleaseRequest) Validate(formats strfmt.Registry) error ", "output": "{\n\tvar res []error\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package target\n\nimport (\n\t\"os\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Glob(dst string, globs ...string) (bool, error) {\n\tstat, err := os.Stat(os.ExpandEnv(dst))\n\tif os.IsNotExist(err) {\n\t\treturn true, nil\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn GlobNewer(stat.ModTime(), globs...)\n}\n\n\n\n\n\n\n\nfunc Dir(dst string, sources ...string) (bool, error) {\n\tdst = os.ExpandEnv(dst)\n\tstat, err := os.Stat(dst)\n\tif os.IsNotExist(err) {\n\t\treturn true, nil\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdestTime := stat.ModTime()\n\tif stat.IsDir() {\n\t\tdestTime, err = NewestModTime(dst)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn DirNewer(destTime, sources...)\n}\n\nfunc Path(dst string, sources ...string) (bool, error) ", "output": "{\n\tstat, err := os.Stat(os.ExpandEnv(dst))\n\tif os.IsNotExist(err) {\n\t\treturn true, nil\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn PathNewer(stat.ModTime(), sources...)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tif !Exists(\"redis.tar.gz\") {\n\t\tDownload(\"http://download.redis.io/redis-stable.tar.gz\", \"redis.tar.gz\")\n\t}\n\tif Exists(\"redis\") {\n\t\tV(os.RemoveAll(\"redis\"))\n\t}\n\tV(os.MkdirAll(\"redis\", 0755))\n\tRun(\"tar zxvf redis.tar.gz -C redis --strip-components=1\")\n\tV(os.Chdir(\"redis\"))\n\tRun(\"make\")\n}\n\nfunc V(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n\n\nfunc Download(fileURL string, filename string) {\n\tresp, err := http.Get(fileURL)\n\tV(err)\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tV(err)\n\tV(ioutil.WriteFile(filename, body, 0644))\n}\n\nfunc Run(command string) {\n\tfmt.Printf(\"run: %s\\n\", command)\n\targs := strings.Split(command, \" \")\n\tcmd := exec.Command(args[0], args[1:]...)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tif err := cmd.Run(); err != nil {\n\t\tfmt.Printf(\"command failed: %s\\n\", command)\n\t\tV(err)\n\t}\n}\n\nfunc Exists(path string) bool ", "output": "{\n\tif _, err := os.Stat(path); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn false\n\t\t}\n\t\tV(err)\n\t}\n\treturn true\n}"}
{"input": "package process\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype process struct {\n\tpid, uid, gid int\n}\n\n\n\nfunc (p *process) Uid() int {\n\treturn p.uid\n}\n\nfunc (p *process) Gid() int {\n\treturn p.gid\n}\n\ntype Process interface {\n\tPid() int\n\tExe() string\n\tCmdline() []string\n\tUid() int\n\tGid() int\n\tParent() Process\n\tChildren() ProcessList\n\tString() string\n}\n\ntype Match struct {\n\tName string\n}\n\nfunc Filter(cb func(Process) bool) (ProcessList, error) {\n\tlist, err := List()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn list.Filter(cb), nil\n}\n\nfunc FindName(name string) (ProcessList, error) {\n\treturn Filter(func(p Process) bool {\n\t\treturn strings.Contains(p.Cmdline()[0], name)\n\t})\n}\n\nfunc FindPid(pid int) (Process, error) {\n\treturn get(pid)\n}\n\nfunc getFallback(pid int) (Process, error) {\n\tlist, err := Filter(func(p Process) bool {\n\t\treturn p.Pid() == pid\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(list) == 0 {\n\t\treturn nil, fmt.Errorf(\"pid %d not found\", pid)\n\t}\n\treturn list[0], nil\n}\n\nfunc (p *process) Pid() int ", "output": "{\n\treturn p.pid\n}"}
{"input": "package common\n\nimport (\n\t\"fmt\"\n\n\tv3 \"github.com/rancher/rancher/pkg/generated/norman/management.cattle.io/v3\"\n\t\"github.com/rancher/rancher/pkg/ref\"\n\t\"github.com/sirupsen/logrus\"\n)\n\nfunc GetRuleID(groupID string, ruleName string) string {\n\treturn fmt.Sprintf(\"%s_%s\", groupID, ruleName)\n}\n\nfunc GetGroupID(namespace, name string) string {\n\treturn fmt.Sprintf(\"%s:%s\", namespace, name)\n}\n\nfunc GetAlertManagerSecretName(appName string) string {\n\treturn fmt.Sprintf(\"alertmanager-%s\", appName)\n}\n\nfunc GetAlertManagerDaemonsetName(appName string) string {\n\treturn fmt.Sprintf(\"alertmanager-%s\", appName)\n}\n\nfunc formatProjectDisplayName(projectDisplayName, projectID string) string {\n\treturn fmt.Sprintf(\"%s (ID: %s)\", projectDisplayName, projectID)\n}\n\n\n\nfunc GetClusterDisplayName(clusterName string, clusterLister v3.ClusterLister) string {\n\tcluster, err := clusterLister.Get(\"\", clusterName)\n\tif err != nil {\n\t\tlogrus.Warnf(\"Failed to get cluster for %s: %v\", clusterName, err)\n\t\treturn clusterName\n\t}\n\n\treturn formatClusterDisplayName(cluster.Spec.DisplayName, clusterName)\n}\n\nfunc GetProjectDisplayName(projectID string, projectLister v3.ProjectLister) string {\n\tclusterName, projectName := ref.Parse(projectID)\n\tproject, err := projectLister.Get(clusterName, projectName)\n\tif err != nil {\n\t\tlogrus.Warnf(\"Failed to get project %s: %v\", projectID, err)\n\t\treturn projectID\n\t}\n\n\treturn formatProjectDisplayName(project.Spec.DisplayName, projectID)\n}\n\nfunc formatClusterDisplayName(clusterDisplayName, clusterID string) string ", "output": "{\n\treturn fmt.Sprintf(\"%s (ID: %s)\", clusterDisplayName, clusterID)\n}"}
{"input": "package matchers\n\nimport (\n\t\"fmt\"\n\t\"github.com/bfontaine/go-tchoutchou/Godeps/_workspace/src/github.com/onsi/gomega/format\"\n\t\"regexp\"\n)\n\ntype MatchRegexpMatcher struct {\n\tRegexp string\n\tArgs   []interface{}\n}\n\nfunc (matcher *MatchRegexpMatcher) Match(actual interface{}) (success bool, err error) {\n\tactualString, ok := toString(actual)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"RegExp matcher requires a string or stringer.\\nGot:%s\", format.Object(actual, 1))\n\t}\n\n\tmatch, err := regexp.Match(matcher.regexp(), []byte(actualString))\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"RegExp match failed to compile with error:\\n\\t%s\", err.Error())\n\t}\n\n\treturn match, nil\n}\n\n\n\nfunc (matcher *MatchRegexpMatcher) NegatedFailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, \"not to match regular expression\", matcher.regexp())\n}\n\nfunc (matcher *MatchRegexpMatcher) regexp() string {\n\tre := matcher.Regexp\n\tif len(matcher.Args) > 0 {\n\t\tre = fmt.Sprintf(matcher.Regexp, matcher.Args...)\n\t}\n\treturn re\n}\n\nfunc (matcher *MatchRegexpMatcher) FailureMessage(actual interface{}) (message string) ", "output": "{\n\treturn format.Message(actual, \"to match regular expression\", matcher.regexp())\n}"}
{"input": "package sentinel\n\nimport (\n\t\"time\"\n\n\t\"github.com/mdevilliers/redishappy/types\"\n)\n\ntype SentinelTopology struct {\n\tSentinels map[string]*SentinelInfo `json:\"sentinels\"`\n}\n\ntype SentinelInfo struct {\n\tSentinelLocation string    `json:\"sentinelLocation\"`\n\tLastUpdated      time.Time `json:\"lastUpdated\"`\n\tClusters         []string  `json:\"clusters\"`\n\tState            int       `json:\"state\"`\n}\n\ntype TopologyRequest struct {\n\tReplyChannel chan SentinelTopology\n}\n\ntype SentinelEvent interface {\n\tGetSentinel() types.Sentinel\n}\n\ntype SentinelAdded struct {\n\tSentinel types.Sentinel\n}\n\ntype SentinelLost struct {\n\tSentinel types.Sentinel\n}\n\ntype SentinelUnknown struct {\n\tSentinel types.Sentinel\n}\n\ntype SentinelPing struct {\n\tSentinel types.Sentinel\n}\n\ntype SentinelClustersMonitoredUpdate struct {\n\tSentinel types.Sentinel\n\tClusters []string\n}\n\n\n\nfunc (s SentinelLost) GetSentinel() types.Sentinel {\n\treturn s.Sentinel\n}\n\nfunc (s SentinelPing) GetSentinel() types.Sentinel {\n\treturn s.Sentinel\n}\n\nfunc (s SentinelUnknown) GetSentinel() types.Sentinel {\n\treturn s.Sentinel\n}\n\nfunc (s SentinelClustersMonitoredUpdate) GetSentinel() types.Sentinel {\n\treturn s.Sentinel\n}\n\nfunc (topology SentinelTopology) FindSentinelInfo(sentinel types.Sentinel) (*SentinelInfo, bool) {\n\tkey := topology.createKey(sentinel)\n\tinfo, ok := topology.Sentinels[key]\n\treturn info, ok\n}\nfunc (topology SentinelTopology) createKey(sentinel types.Sentinel) string {\n\treturn sentinel.GetLocation()\n}\n\nfunc (s SentinelAdded) GetSentinel() types.Sentinel ", "output": "{\n\treturn s.Sentinel\n}"}
{"input": "package lints\n\n\n\nimport (\n\t\"github.com/zmap/zcrypto/x509\"\n\t\"github.com/zmap/zlint/util\"\n)\n\n\n\ntype basicConstCrit struct{}\n\nfunc (l *basicConstCrit) Initialize() error {\n\treturn nil\n}\n\nfunc (l *basicConstCrit) CheckApplies(c *x509.Certificate) bool {\n\treturn c.IsCA && util.IsExtInCert(c, util.BasicConstOID)\n}\n\nfunc (l *basicConstCrit) Execute(c *x509.Certificate) *LintResult {\n\tif e := util.GetExtFromCert(c, util.BasicConstOID); e != nil {\n\t\tif e.Critical {\n\t\t\treturn &LintResult{Status: Pass}\n\t\t} else {\n\t\t\treturn &LintResult{Status: Error}\n\t\t}\n\t} else {\n\t\treturn &LintResult{Status: NA}\n\t}\n}\n\n\n\nfunc init() ", "output": "{\n\tRegisterLint(&Lint{\n\t\tName:          \"e_basic_constraints_not_critical\",\n\t\tDescription:   \"basicConstraints MUST appear as a critical extension\",\n\t\tCitation:      \"RFC 5280: 4.2.1.9\",\n\t\tSource:        RFC5280,\n\t\tEffectiveDate: util.RFC2459Date,\n\t\tLint:          &basicConstCrit{},\n\t})\n}"}
{"input": "package limiter\n\ntype SimpleLimiter chan struct{}\n\nfunc (l SimpleLimiter) Enter() { l <- struct{}{} }\nfunc (l SimpleLimiter) Leave() { <-l }\n\n\n\nfunc NewSimpleLimiter(l int) SimpleLimiter ", "output": "{\n\treturn make(chan struct{}, l)\n}"}
{"input": "package gensupport\n\nimport (\n\t\"io\"\n\t\"time\"\n)\n\n\ntype errReader struct {\n\tbuf []byte\n\terr error\n}\n\nfunc (er *errReader) Read(p []byte) (int, error) {\n\tif len(er.buf) == 0 {\n\t\tif er.err == nil {\n\t\t\treturn 0, io.EOF\n\t\t}\n\t\treturn 0, er.err\n\t}\n\tn := copy(p, er.buf)\n\ter.buf = er.buf[n:]\n\treturn n, nil\n}\n\n\ntype UniformPauseStrategy time.Duration\n\n\nfunc (p UniformPauseStrategy) Reset()                       {}\n\n\nconst NoPauseStrategy = UniformPauseStrategy(0)\n\n\ntype LimitRetryStrategy struct {\n\tMax      int\n\tStrategy BackoffStrategy\n\tn        int\n}\n\nfunc (l *LimitRetryStrategy) Pause() (time.Duration, bool) {\n\tl.n++\n\tif l.n > l.Max {\n\t\treturn 0, false\n\t}\n\treturn l.Strategy.Pause()\n}\n\nfunc (l *LimitRetryStrategy) Reset() {\n\tl.n = 0\n\tl.Strategy.Reset()\n}\n\nfunc (p UniformPauseStrategy) Pause() (time.Duration, bool) ", "output": "{ return time.Duration(p), true }"}
{"input": "package steward\n\nimport (\n\t\"database/sql\"\n\n\t_ \"github.com/lib/pq\"\n)\n\nfunc createSchema(db *sql.DB) error {\n\n\terr := createFlagTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createAdvisoryTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createCapturedFlagTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createTeamTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createServiceTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createStatusTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createRoundTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createRoundResultTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\n\n\nfunc CleanDatabase(db *sql.DB) (err error) {\n\n\ttables := []string{\"team\", \"advisory\", \"captured_flag\", \"flag\",\n\t\t\"service\", \"status\", \"round\", \"round_result\"}\n\n\tfor _, table := range tables {\n\n\t\t_, err = db.Exec(\"DELETE FROM \" + table)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = db.Exec(\"ALTER SEQUENCE \" + table + \"_id_seq RESTART WITH 1;\")\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc OpenDatabase(path string) (db *sql.DB, err error) ", "output": "{\n\n\tdb, err = sql.Open(\"postgres\", path)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = createSchema(db)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}"}
{"input": "package builder\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"owl/common/tsdb/go-kairosdb/builder/utils\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype sampling_aggr_desc struct {\n\taggrFunc func(int, utils.TimeUnit) Aggregator\n\tname     string\n}\n\n\n\nvar samplingAggrDescArray = []sampling_aggr_desc{\n\t{CreateMinAggregator, \"min\"},\n\t{CreateMaxAggregator, \"max\"},\n\t{CreateAverageAggregator, \"avg\"},\n\t{CreateStandardDeviationAggregator, \"dev\"},\n\t{CreateSumAggregator, \"sum\"},\n\t{CreateCountAggregator, \"count\"},\n\t{CreateLastAggregator, \"last\"},\n\t{CreateFirstAggregator, \"first\"},\n\t{CreateDataGapsMarkingAggregator, \"gaps\"},\n\t{CreateLeastSquaresAggregator, \"least_squares\"},\n}\n\n\n\n\nfunc TestSamplingAggregatorFuncs(t *testing.T) ", "output": "{\n\tfor _, adesc := range samplingAggrDescArray {\n\t\ta := adesc.aggrFunc(1, utils.MINUTES)\n\t\terr := a.Validate()\n\n\t\tassert.Nil(t, err, \"No error expected\")\n\t\tassert.EqualValues(t, adesc.name, a.Name(), fmt.Sprintf(\"Aggregator name must be set to '%s'\", adesc.name))\n\t}\n}"}
{"input": "package pythagorean\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nconst targetTestVersion = 1\n\n\n\nvar rangeTests = []struct {\n\tmin, max int\n\tts       []Triplet\n}{\n\t{1, 10, []Triplet{{3, 4, 5}, {6, 8, 10}}},\n\t{11, 20, []Triplet{{12, 16, 20}}},\n}\n\nfunc TestRange(t *testing.T) {\n\tfor _, test := range rangeTests {\n\t\tts := Range(test.min, test.max)\n\t\tif !reflect.DeepEqual(ts, test.ts) {\n\t\t\tt.Fatalf(\"Range(%d, %d) = %v, want %v\",\n\t\t\t\ttest.min, test.max, ts, test.ts)\n\t\t}\n\t}\n}\n\nvar sumTests = []struct {\n\tsum int\n\tts  []Triplet\n}{\n\t{180, []Triplet{{18, 80, 82}, {30, 72, 78}, {45, 60, 75}}},\n\t{1000, []Triplet{{200, 375, 425}}},\n}\n\nfunc TestSum(t *testing.T) {\n\tfor _, test := range sumTests {\n\t\tts := Sum(test.sum)\n\t\tif !reflect.DeepEqual(ts, test.ts) {\n\t\t\tt.Fatalf(\"Sum(%d) = %v, want %v\",\n\t\t\t\ttest.sum, ts, test.ts)\n\t\t}\n\t}\n}\n\nfunc BenchmarkRange(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tRange(1, 100)\n\t}\n}\n\nfunc BenchmarkSum(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSum(1000)\n\t}\n}\n\nfunc TestTestVersion(t *testing.T) ", "output": "{\n\tif testVersion != targetTestVersion {\n\t\tt.Fatalf(\"Found testVersion = %v, want %v\", testVersion, targetTestVersion)\n\t}\n}"}
{"input": "package autobackup\n\nimport (\n\t\"context\"\n\n\t\"github.com/sacloud/libsacloud/v2/helper/service\"\n\t\"github.com/sacloud/libsacloud/v2/sacloud\"\n)\n\n\n\nfunc (s *Service) DeleteWithContext(ctx context.Context, req *DeleteRequest) error {\n\tif err := req.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tclient := sacloud.NewAutoBackupOp(s.caller)\n\tif err := client.Delete(ctx, req.Zone, req.ID); err != nil {\n\t\treturn service.HandleNotFoundError(err, !req.FailIfNotFound)\n\t}\n\treturn nil\n}\n\nfunc (s *Service) Delete(req *DeleteRequest) error ", "output": "{\n\treturn s.DeleteWithContext(context.Background(), req)\n}"}
{"input": "package onewire\n\nimport (\n\t\"fmt\"\n)\n\ntype Dev [8]byte\n\n\n\ntype Type byte\n\nfunc (d Dev) Type() Type {\n\treturn Type(d[0])\n}\n\nfunc (d Dev) Format(f fmt.State, _ rune) ", "output": "{\n\ttyp := d[0]\n\tcrc := d[7]\n\ta1 := uint32(d[1])<<16 + uint32(d[2])<<8 + uint32(d[3])\n\ta2 := uint32(d[4])<<16 + uint32(d[5])<<8 + uint32(d[6])\n\tfmt.Fprintf(f, \"%02x-%06x-%06x-%02x\", typ, a1, a2, crc)\n}"}
{"input": "package apmcontrolplane\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetWorkRequestRequest struct {\n\n\tWorkRequestId *string `mandatory:\"true\" contributesTo:\"path\" name:\"workRequestId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetWorkRequestRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request GetWorkRequestRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request GetWorkRequestRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetWorkRequestResponse struct {\n\n\tRawResponse *http.Response\n\n\tWorkRequest `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n\n\tRetryAfter *float32 `presentIn:\"header\" name:\"retry-after\"`\n}\n\nfunc (response GetWorkRequestResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response GetWorkRequestResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request GetWorkRequestRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) ", "output": "{\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}"}
{"input": "package crypto\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\n\t. \"github.com/tendermint/go-common\"\n\t\"golang.org/x/crypto/openpgp/armor\"\n)\n\n\n\nfunc DecodeArmor(armorStr string) (blockType string, headers map[string]string, data []byte, err error) {\n\tbuf := bytes.NewBufferString(armorStr)\n\tblock, err := armor.Decode(buf)\n\tif err != nil {\n\t\treturn \"\", nil, nil, err\n\t}\n\tdata, err = ioutil.ReadAll(block.Body)\n\tif err != nil {\n\t\treturn \"\", nil, nil, err\n\t}\n\treturn block.Type, block.Header, data, nil\n}\n\nfunc EncodeArmor(blockType string, headers map[string]string, data []byte) string ", "output": "{\n\tbuf := new(bytes.Buffer)\n\tw, err := armor.Encode(buf, blockType, headers)\n\tif err != nil {\n\t\tPanicSanity(\"Error encoding ascii armor: \" + err.Error())\n\t}\n\t_, err = w.Write(data)\n\tif err != nil {\n\t\tPanicSanity(\"Error encoding ascii armor: \" + err.Error())\n\t}\n\terr = w.Close()\n\tif err != nil {\n\t\tPanicSanity(\"Error encoding ascii armor: \" + err.Error())\n\t}\n\treturn string(buf.Bytes())\n}"}
{"input": "package problems\n\nimport \"fmt\"\n\nfunc partitionDfs(data []byte, i int, buf *[]string, out *[][]string) {\n\tif i == len(data) {\n\t\tm := make([]string, len(*buf))\n\t\tcopy(m, *buf)\n\t\t*out = append(*out, m)\n\t\treturn\n\t}\n\n\tvar isPalindrome func (data []byte, s int, e int) bool\n\tisPalindrome = func (data []byte, s int, e int) bool {\n\t\ti, j := s, e\n\t\tfor i < j {\n\t\t\tif data[i] != data[j] {\n\t\t\t\treturn false\n\t\t\t} else {\n\t\t\t\ti++\n\t\t\t\tj--\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\tfor k := i; k < len(data); k++ {\n\t\tif isPalindrome(data, i, k) {\n\t\t\t*buf = append(*buf, string(data[i:k + 1]))\n\t\t\tpartitionDfs(data, k + 1, buf, out)\n\t\t\t*buf = (*buf)[:len(*buf) - 1]\n\t\t}\n\t}\n}\n\nfunc partition(s string) [][]string {\n\tvar buf []string\n\tvar out [][]string\n\n\tpartitionDfs([]byte(s), 0, &buf, &out)\n\n\treturn out\n}\n\n\n\nfunc Partition() ", "output": "{\n\tfmt.Printf(\"<131> \")\n\tfmt.Println(partition(\"aabc\"))\n}"}
{"input": "package main\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\n\n\nfunc main() {\n\tfd, _ := os.Open(\"a.txt\")\n\techo(fd)\n}\n\nfunc echo(fd io.ReadWriterCloser) ", "output": "{ \n\tvar buf [1024]byte\n\tfor {\n\t\tn, err := fd.Read(buf)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tfd.Write(buf[0:n])\n\t}\n}"}
{"input": "package characteristic\n\nimport (\n\t\"github.com/brutella/hc/model\"\n)\n\ntype HeatingCoolingMode struct {\n\t*ByteCharacteristic\n}\n\nfunc NewHeatingCoolingMode(current model.HeatCoolModeType, charType CharType, permissions []string) *HeatingCoolingMode {\n\tc := HeatingCoolingMode{NewByteCharacteristic(byte(current), permissions)}\n\tc.Type = charType\n\n\treturn &c\n}\n\nfunc NewCurrentHeatingCoolingMode(current model.HeatCoolModeType) *HeatingCoolingMode {\n\treturn NewHeatingCoolingMode(current, CharTypeHeatingCoolingModeCurrent, PermsRead())\n}\n\nfunc NewTargetHeatingCoolingMode(current model.HeatCoolModeType) *HeatingCoolingMode {\n\treturn NewHeatingCoolingMode(current, CharTypeHeatingCoolingModeTarget, PermsAll())\n}\n\nfunc (c *HeatingCoolingMode) SetHeatingCoolingMode(mode model.HeatCoolModeType) {\n\tc.SetByte(byte(mode))\n}\n\n\n\nfunc (c *HeatingCoolingMode) HeatingCoolingMode() model.HeatCoolModeType ", "output": "{\n\treturn model.HeatCoolModeType(c.Byte())\n}"}
{"input": "package converters\n\nimport (\n\t\"fmt\"\n\t\"github.com/astaxie/beego/orm\"\n\t\"strings\"\n)\n\ntype TableRows struct {\n\tRows int64\n}\n\nfunc NumOfRows(o orm.Ormer, sql string) (int64, error) {\n\ttype tableRows struct {\n\t\tRows int64\n\t}\n\tvar rows tableRows\n\tif err := o.Raw(sql).QueryRow(&rows); err != nil {\n\t\treturn 0, err\n\t}\n\treturn rows.Rows, nil\n}\n\nfunc RunPreImportMySQLSettings(o orm.Ormer) {\n\tconst sql = `/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;\n/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;\n/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;\n/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;`\n\tvar cmds = strings.Split(sql, \"\\n\")\n\tfor _, cmd := range cmds {\n\t\tif _, err := o.Raw(cmd).Exec(); err != nil {\n\t\t\tfmt.Println(\"PreImportSettings: \", err)\n\t\t}\n\t}\n}\n\nfunc cutString(str string, length int) string {\n\tchars := []rune(str)\n\tif len(chars) <= length {\n\t\treturn str\n\t}\n\treturn string(chars[0:length])\n}\n\nfunc Btoi(b bool) int {\n\tif b {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\n\n\nfunc Map2InsertSql(o orm.Ormer, table string, data map[string]interface{}) error ", "output": "{\n\tvar values []interface{}\n\tvar keys []string\n\tvar valuesPlaceHolders []string\n\tfor k, v := range data {\n\t\tvaluesPlaceHolders = append(valuesPlaceHolders, \"? \")\n\t\tkeys = append(keys, fmt.Sprintf(\"`%s`\", k))\n\t\tvalues = append(values, v) \n\t}\n\tsql := fmt.Sprintf(\"INSERT INTO `%s` (%s) VALUES(%s)\", table, strings.Join(keys, \",\"), strings.Join(valuesPlaceHolders, \",\"))\n\t_, err := o.Raw(sql, values...).Exec()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package fs\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/pkg/errors\"\n)\n\n\ntype DumpFlags int\n\n\nconst (\n\tDumpHeaders DumpFlags = 1 << iota\n\tDumpBodies\n\tDumpRequests\n\tDumpResponses\n\tDumpAuth\n\tDumpFilters\n\tDumpGoRoutines\n\tDumpOpenFiles\n)\n\nvar dumpFlags = []struct {\n\tflag DumpFlags\n\tname string\n}{\n\t{DumpHeaders, \"headers\"},\n\t{DumpBodies, \"bodies\"},\n\t{DumpRequests, \"requests\"},\n\t{DumpResponses, \"responses\"},\n\t{DumpAuth, \"auth\"},\n\t{DumpFilters, \"filters\"},\n\t{DumpGoRoutines, \"goroutines\"},\n\t{DumpOpenFiles, \"openfiles\"},\n}\n\n\nvar DumpFlagsList string\n\nfunc init() {\n\tvar out []string\n\tfor _, info := range dumpFlags {\n\t\tout = append(out, info.name)\n\t}\n\tDumpFlagsList = strings.Join(out, \",\")\n}\n\n\nfunc (f DumpFlags) String() string {\n\tvar out []string\n\tfor _, info := range dumpFlags {\n\t\tif f&info.flag != 0 {\n\t\t\tout = append(out, info.name)\n\t\t\tf &^= info.flag\n\t\t}\n\t}\n\tif f != 0 {\n\t\tout = append(out, fmt.Sprintf(\"Unknown-0x%X\", int(f)))\n\t}\n\treturn strings.Join(out, \",\")\n}\n\n\n\n\n\nfunc (f *DumpFlags) Type() string {\n\treturn \"DumpFlags\"\n}\n\nfunc (f *DumpFlags) Set(s string) error ", "output": "{\n\tvar flags DumpFlags\n\tparts := strings.Split(s, \",\")\n\tfor _, part := range parts {\n\t\tfound := false\n\t\tpart = strings.ToLower(strings.TrimSpace(part))\n\t\tif part == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, info := range dumpFlags {\n\t\t\tif part == info.name {\n\t\t\t\tfound = true\n\t\t\t\tflags |= info.flag\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn errors.Errorf(\"Unknown dump flag %q\", part)\n\t\t}\n\t}\n\t*f = flags\n\treturn nil\n}"}
{"input": "package mocks\n\nimport mock \"github.com/stretchr/testify/mock\"\n\n\ntype Allow struct {\n\tmock.Mock\n}\n\n\n\n\n\nfunc (_m *Allow) Member(email string) bool {\n\tret := _m.Called(email)\n\n\tvar r0 bool\n\tif rf, ok := ret.Get(0).(func(string) bool); ok {\n\t\tr0 = rf(email)\n\t} else {\n\t\tr0 = ret.Get(0).(bool)\n\t}\n\n\treturn r0\n}\n\nfunc (_m *Allow) Emails() []string ", "output": "{\n\tret := _m.Called()\n\n\tvar r0 []string\n\tif rf, ok := ret.Get(0).(func() []string); ok {\n\t\tr0 = rf()\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).([]string)\n\t\t}\n\t}\n\n\treturn r0\n}"}
{"input": "package nes\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype APUDebugAudio struct {\n\tfrequency  int\n\tsampleSize int\n\tinput      chan int16\n}\n\n\n\nfunc (audio *APUDebugAudio) Input() chan int16 {\n\treturn audio.input\n}\n\nfunc (audio *APUDebugAudio) Run() {\n\tprint := time.NewTicker(1 * time.Second)\n\tstart := time.Now()\n\tsamples := 0\n\tfor {\n\t\tselect {\n\t\tcase <-audio.input:\n\t\t\tsamples++\n\t\tcase <-print.C:\n\t\t\tt := time.Since(start)\n\t\t\tfmt.Println(\"\\nAPU DEBUG:\")\n\t\t\tfmt.Println(\"Total samples:\", samples)\n\t\t\tfmt.Println(\"Total time:\", t)\n\t\t\tfmt.Printf(\"%f samples/sec\\n\", float64(samples)/t.Seconds())\n\t\t}\n\t}\n}\n\nfunc (audio *APUDebugAudio) TogglePaused() {\n}\n\nfunc (audio *APUDebugAudio) SetSpeed(speed float32) {\n}\n\nfunc (audio *APUDebugAudio) Close() {\n}\n\nfunc NewAudio(frequency int, sampleSize int) (audio *APUDebugAudio, err error) ", "output": "{\n\taudio = &APUDebugAudio{\n\t\tfrequency:  frequency,\n\t\tsampleSize: sampleSize,\n\t\tinput:      make(chan int16),\n\t}\n\treturn\n}"}
{"input": "package error\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\nvar errors map[int]string\n\nconst ()\n\nfunc init() {\n\terrors = make(map[int]string)\n\n\terrors[100] = \"Key Not Found\"\n\terrors[101] = \"The given PrevValue is not equal to the value of the key\"\n\terrors[102] = \"Not A File\"\n\terrors[103] = \"Reached the max number of machines in the cluster\"\n\n\terrors[200] = \"Value is Required in POST form\"\n\terrors[201] = \"PrevValue is Required in POST form\"\n\terrors[202] = \"The given TTL in POST form is not a number\"\n\terrors[203] = \"The given index in POST form is not a number\"\n\n\terrors[300] = \"Raft Internal Error\"\n\terrors[301] = \"During Leader Election\"\n\n\terrors[400] = \"The prefix of the given key is a keyword in etcd\"\n\n\terrors[500] = \"watcher is cleared due to etcd recovery\"\n\n}\n\ntype Error struct {\n\tErrorCode int    `json:\"errorCode\"`\n\tMessage   string `json:\"message\"`\n\tCause     string `json:\"cause,omitempty\"`\n}\n\nfunc NewError(errorCode int, cause string) Error {\n\treturn Error{\n\t\tErrorCode: errorCode,\n\t\tMessage:   errors[errorCode],\n\t\tCause:     cause,\n\t}\n}\n\nfunc Message(code int) string {\n\treturn errors[code]\n}\n\n\nfunc (e Error) Error() string {\n\treturn e.Message\n}\n\nfunc (e Error) toJsonString() string {\n\tb, _ := json.Marshal(e)\n\treturn string(b)\n}\n\n\n\nfunc (e Error) Write(w http.ResponseWriter) ", "output": "{\n\tif e.ErrorCode/100 == 3 {\n\t\thttp.Error(w, e.toJsonString(), http.StatusInternalServerError)\n\t} else {\n\t\thttp.Error(w, e.toJsonString(), http.StatusBadRequest)\n\t}\n}"}
{"input": "package cloud\n\nimport (\n\t\"fmt\"\n)\n\nconst (\n\tVMNotFoundError       = \"Bosh::Clouds::VMNotFound\"\n\tDiskNotFoundError     = \"Bosh::Clouds::DiskNotFound\"\n\tStemcellNotFoundError = \"Bosh::Clouds::StemcellNotFound\"\n\tNotImplementedError   = \"Bosh::Clouds::NotImplemented\"\n)\n\ntype Error interface {\n\terror\n\tMethod() string\n\tType() string\n\tMessage() string\n\tOkToRetry() bool\n}\n\ntype cpiError struct {\n\tmethod   string\n\tcmdError CmdError\n}\n\nfunc NewCPIError(method string, cmdError CmdError) Error {\n\treturn cpiError{\n\t\tmethod:   method,\n\t\tcmdError: cmdError,\n\t}\n}\n\nfunc (e cpiError) Error() string {\n\treturn fmt.Sprintf(\"CPI '%s' method responded with error: %s\", e.method, e.cmdError)\n}\n\n\n\nfunc (e cpiError) Type() string {\n\treturn e.cmdError.Type\n}\n\nfunc (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\n\nfunc (e cpiError) OkToRetry() bool {\n\treturn e.cmdError.OkToRetry\n}\n\nfunc (e cpiError) Method() string ", "output": "{\n\treturn e.method\n}"}
{"input": "package system\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\nfunc MkdirAllWithACL(path string, perm os.FileMode, sddl string) error {\n\treturn MkdirAll(path, perm, sddl)\n}\n\n\n\n\n\n\nfunc IsAbs(path string) bool {\n\treturn filepath.IsAbs(path)\n}\n\n\n\n\n\n\n\n\n\nfunc CreateSequential(name string) (*os.File, error) {\n\treturn os.Create(name)\n}\n\n\n\n\n\nfunc OpenSequential(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\n\n\n\n\n\nfunc OpenFileSequential(name string, flag int, perm os.FileMode) (*os.File, error) {\n\treturn os.OpenFile(name, flag, perm)\n}\n\n\n\n\n\n\n\n\n\n\nfunc TempFileSequential(dir, prefix string) (f *os.File, err error) {\n\treturn ioutil.TempFile(dir, prefix)\n}\n\nfunc MkdirAll(path string, perm os.FileMode, sddl string) error ", "output": "{\n\treturn os.MkdirAll(path, perm)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n\n\nfunc main() {\n\tfmt.Println(\"starting server\")\n\thttp.HandleFunc(\"/\", DoRequest)\n\thttp.ListenAndServe(\":9090\", nil)\n\tfmt.Println(\"ending server\")\n}\n\nfunc DoRequest(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tr.ParseForm()\n\tw.WriteHeader(200)\n\tfor key, values := range r.Form {\n\t\tw.Write([]byte(fmt.Sprintf(\"%s: %s \\n\", key, values)))\n\t}\n}"}
{"input": "package log\n\n\nfunc (me *Logging) Prefix() string {\n\treturn me.prefix\n}\n\n\nfunc (me *Logging) SetPrefix(value string) {\n\tme.prefix = value\n\tif me.console != nil {\n\t\tme.console.SetPrefix(me.prefix)\n\t}\n\tif me.dailyfile != nil {\n\t\tme.dailyfile.SetPrefix(me.prefix)\n\t}\n}\n\n\n\n\n\nfunc (me *Logging) SetPriority(value int) {\n\tme.setPriority = true\n\tme.priority = value\n\tif me.console != nil {\n\t\tme.console.SetPriority(me.priority)\n\t}\n\tif me.dailyfile != nil {\n\t\tme.dailyfile.SetPriority(me.priority)\n\t}\n}\n\n\nfunc (me *Logging) Layouts() int {\n\treturn me.layouts\n}\n\n\nfunc (me *Logging) SetLayouts(value int) {\n\tme.setLayouts = true\n\tme.layouts = value\n\tif me.console != nil {\n\t\tme.console.SetLayouts(me.layouts)\n\t}\n\tif me.dailyfile != nil {\n\t\tme.dailyfile.SetLayouts(me.layouts)\n\t}\n}\n\n\nfunc (me *Logging) Outputs() int {\n\treturn me.outputs\n}\n\n\nfunc (me *Logging) SetOutputs(value int) {\n\tme.setOutputs = true\n\tme.outputs = value\n}\n\nfunc (me *Logging) Priority() int ", "output": "{\n\treturn me.priority\n}"}
{"input": "package accountlink\n\nimport (\n\t\"net/http\"\n\n\tstripe \"github.com/stripe/stripe-go/v72\"\n)\n\n\ntype Client struct {\n\tB   stripe.Backend\n\tKey string\n}\n\n\nfunc New(params *stripe.AccountLinkParams) (*stripe.AccountLink, error) {\n\treturn getC().New(params)\n}\n\n\nfunc (c Client) New(params *stripe.AccountLinkParams) (*stripe.AccountLink, error) {\n\taccountlink := &stripe.AccountLink{}\n\terr := c.B.Call(\n\t\thttp.MethodPost,\n\t\t\"/v1/account_links\",\n\t\tc.Key,\n\t\tparams,\n\t\taccountlink,\n\t)\n\treturn accountlink, err\n}\n\n\n\nfunc getC() Client ", "output": "{\n\treturn Client{stripe.GetBackend(stripe.APIBackend), stripe.Key}\n}"}
{"input": "package util\n\nimport (\n\t\"github.com/jsix/gof/algorithm/iterator\"\n\t\"go2o/core/domain/interface/content\"\n\t\"go2o/core/domain/interface/sale\"\n)\n\ntype CategoryFormatFunc func(c *sale.Category, level int)\n\n\n\n\n\nfunc WalkSaleCategory(cs []*sale.Category, v *sale.Category,\n\tstart iterator.WalkFunc, over iterator.WalkFunc) {\n\tvar condition iterator.Condition = func(v, v1 interface{}) bool {\n\t\treturn v1.(*sale.Category).ParentId == v.(*sale.Category).Id\n\t}\n\tvar arr []interface{} = make([]interface{}, len(cs))\n\tfor i, v := range cs {\n\t\tarr[i] = v\n\t}\n\titerator.Walk(arr, v, condition, start, over, 0)\n}\n\n\nfunc WalkArticleCategory(cs []*content.ArticleCategory, v *content.ArticleCategory,\n\tstart iterator.WalkFunc, over iterator.WalkFunc) {\n\tvar condition iterator.Condition = func(v, v1 interface{}) bool {\n\t\treturn v1.(*content.ArticleCategory).ParentId ==\n\t\t\tv.(*content.ArticleCategory).Id\n\t}\n\tvar arr []interface{} = make([]interface{}, len(cs))\n\tfor i, v := range cs {\n\t\tarr[i] = v\n\t}\n\titerator.Walk(arr, v, condition, start, over, 0)\n}\n\nfunc IterateCategory(categories []*sale.Category, c *sale.Category,\n\titerateFunc CategoryFormatFunc, finishFunc CategoryFormatFunc, level int) ", "output": "{\n\tif c.Id != 0 {\n\t\titerateFunc(c, level)\n\t}\n\n\tfor _, k := range categories {\n\t\tif k.ParentId == c.Id {\n\t\t\tIterateCategory(categories, k, iterateFunc, finishFunc, level+1)\n\t\t}\n\t}\n\n\tif finishFunc != nil {\n\t\tfinishFunc(c, level)\n\t}\n\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\ntype MainTests struct {\n\tBaseTests\n}\n\nvar _ = Suite(&MainTests{})\n\nfunc (t *MainTests) TestPrompt(c *C) {\n\tt.in.WriteString(\"test\\n\")\n\tres, err := t.d.promptPassword(\"Foo: \")\n\tc.Assert(t.out.Bytes(), DeepEquals, []byte(\"Foo: \"))\n\tc.Assert(err, IsNil)\n\tc.Assert(res, DeepEquals, []byte(\"test\"))\n}\n\nfunc (t *MainTests) TestPromptTwice(c *C) {\n\tt.in.WriteString(\"test\\nfoo\\n\")\n\tres, err := t.d.promptPassword(\"Foo: \")\n\tc.Assert(t.out.Bytes(), DeepEquals, []byte(\"Foo: \"))\n\tc.Assert(err, IsNil)\n\tc.Assert(res, DeepEquals, []byte(\"test\"))\n\n\tres, err = t.d.promptPassword(\"Bar: \")\n\tc.Assert(t.out.Bytes(), DeepEquals, []byte(\"Foo: Bar: \"))\n\tc.Assert(err, IsNil)\n\tc.Assert(res, DeepEquals, []byte(\"foo\"))\n}\n\n\n\nfunc (t *MainTests) TestNoArg(c *C) {\n\tc.Assert(t.d.run([]string{}), Equals, 1)\n}\n\nfunc (t *MainTests) TestHelpOnUnknownCommand(c *C) {\n\tc.Assert(t.d.run([]string{\"help\", \"non-existant-command\"}), Equals, 1)\n}\n\nfunc (t *MainTests) TestNonExistentCommand(c *C) {\n\tc.Assert(t.d.run([]string{\"non-existant-command\"}), Equals, 1)\n}\n\nfunc (t *MainTests) TestArgHandling(c *C) ", "output": "{\n\tc.Assert(t.d.run([]string{\"help\", \"sync\"}), Equals, 0)\n\tfmt.Println(t.out.String())\n\tc.Assert(strings.Index(t.out.String(), \"sync\"), Not(Equals), -1)\n}"}
{"input": "package main\n\nimport \"code.google.com/p/go.exp/utf8string\"\n\n\n\nfunc init() ", "output": "{\n\tfuncMap[\"slice\"] = &tmplFuncStruct{\n\t\tshort:    \"Construct a substring from a string.\",\n\t\texamples: []string{`{{ \"ᛁᚳ᛫ᛗᚨᚷ᛫ᚷᛚᚨᛋ᛫\" | %s 3 7 }}`},\n\t\tfn: func(low int, high int, in string) string {\n\t\t\ts := utf8string.NewString(in)\n\t\t\treturn s.Slice(low, high)\n\t\t},\n\t}\n}"}
{"input": "package sysfs\n\nimport (\n\t\"strings\"\n)\n\ntype Object string\n\nfunc (obj Object) Exists() bool {\n\treturn dirExists(string(obj))\n}\n\nfunc (obj Object) Name() string {\n\treturn string(obj)[strings.LastIndex(string(obj), \"/\")+1:]\n}\n\nfunc (obj Object) SubObjects() []Object {\n\tpath := string(obj) + \"/\"\n\tobjects := make([]Object, 0)\n\tlsDirs(path, func(name string) {\n\t\tobjects = append(objects, Object(path+name))\n\t})\n\treturn objects\n}\n\nfunc (obj Object) SubObject(name string) Object {\n\treturn Object(string(obj) + \"/\" + name)\n}\n\n\n\nfunc (obj Object) Attribute(name string) *Attribute {\n\treturn &Attribute{Path: string(obj) + \"/\" + name}\n}\n\nfunc (obj Object) Attributes() []Attribute ", "output": "{\n\tpath := string(obj) + \"/\"\n\tattribs := make([]Attribute, 0)\n\tlsFiles(path, func(name string) {\n\t\tattribs = append(attribs, Attribute{Path: path + name})\n\t})\n\treturn attribs\n}"}
{"input": "package reporters\n\nimport (\n\t\"time\"\n\n\t\"github.com/coreos/mantle/harness/testresult\"\n)\n\ntype Reporters []Reporter\n\nfunc (reps Reporters) ReportTest(name string, result testresult.TestResult, duration time.Duration, b []byte) {\n\tfor _, r := range reps {\n\t\tr.ReportTest(name, result, duration, b)\n\t}\n}\n\n\n\nfunc (reps Reporters) SetResult(s testresult.TestResult) {\n\tfor _, r := range reps {\n\t\tr.SetResult(s)\n\t}\n}\n\ntype Reporter interface {\n\tReportTest(string, testresult.TestResult, time.Duration, []byte)\n\tOutput(string) error\n\tSetResult(testresult.TestResult)\n}\n\nfunc (reps Reporters) Output(path string) error ", "output": "{\n\tfor _, r := range reps {\n\t\terr := r.Output(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package plugin\n\nimport \"github.com/docker/docker/api/server/router\"\n\n\ntype pluginRouter struct {\n\tbackend Backend\n\troutes  []router.Route\n}\n\n\n\n\n\nfunc (r *pluginRouter) Routes() []router.Route {\n\treturn r.routes\n}\n\nfunc (r *pluginRouter) initRoutes() {\n\tr.routes = []router.Route{\n\t\trouter.NewGetRoute(\"/plugins\", r.listPlugins),\n\t\trouter.NewGetRoute(\"/plugins/{name:.*}/json\", r.inspectPlugin),\n\t\trouter.NewGetRoute(\"/plugins/privileges\", r.getPrivileges),\n\t\trouter.NewDeleteRoute(\"/plugins/{name:.*}\", r.removePlugin),\n\t\trouter.NewPostRoute(\"/plugins/{name:.*}/enable\", r.enablePlugin), \n\t\trouter.NewPostRoute(\"/plugins/{name:.*}/disable\", r.disablePlugin),\n\t\trouter.NewPostRoute(\"/plugins/pull\", r.pullPlugin),\n\t\trouter.NewPostRoute(\"/plugins/{name:.*}/push\", r.pushPlugin),\n\t\trouter.NewPostRoute(\"/plugins/{name:.*}/set\", r.setPlugin),\n\t\trouter.NewPostRoute(\"/plugins/create\", r.createPlugin),\n\t}\n}\n\nfunc NewRouter(b Backend) router.Router ", "output": "{\n\tr := &pluginRouter{\n\t\tbackend: b,\n\t}\n\tr.initRoutes()\n\treturn r\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSConfigConfigurationAggregator_AccountAggregationSource struct {\n\n\tAccountIds []string `json:\"AccountIds,omitempty\"`\n\n\tAllAwsRegions bool `json:\"AllAwsRegions,omitempty\"`\n\n\tAwsRegions []string `json:\"AwsRegions,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSConfigConfigurationAggregator_AccountAggregationSource) AWSCloudFormationType() string {\n\treturn \"AWS::Config::ConfigurationAggregator.AccountAggregationSource\"\n}\n\n\n\nfunc (r *AWSConfigConfigurationAggregator_AccountAggregationSource) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSConfigConfigurationAggregator_AccountAggregationSource) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\n\n\n\n\nfunc (r *AWSConfigConfigurationAggregator_AccountAggregationSource) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSConfigConfigurationAggregator_AccountAggregationSource) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSConfigConfigurationAggregator_AccountAggregationSource) Metadata() map[string]interface{} ", "output": "{\n\treturn r._metadata\n}"}
{"input": "package jump\n\nimport \"testing\"\n\n\n\nfunc TestCanJump(t *testing.T) ", "output": "{\n    st := []struct {\n        name string\n        arr  []int\n        exp  bool\n    }{\n        {\"nil slice\", nil, false},\n        {\"single one\", []int{0}, true},\n        {\"more than one but starts with 0\", []int{0, 1, 2, 3}, false},\n        {\"testcase1\", []int{2, 3, 1, 1, 4}, true},\n        {\"testcase2\", []int{2, 0, 2, 0, 0}, true},\n    }\n    for _, tt := range st {\n        out := canJump(tt.arr)\n        if out != tt.exp {\n            t.Fatalf(\"with input arr:%v wanted %t but got %t\", tt.arr, tt.exp, out)\n        }\n        t.Log(\"pass\")\n    }\n}"}
{"input": "package messages\n\ntype LocVelDistTraveledMessage struct {\n\tX  float64\n\tY  float64\n\tZ  float64\n\tXv float64\n\tYv float64\n\tZv float64\n}\n\nfunc NewLocVelDistTraveledMessage(data []float32) LocVelDistTraveledMessage {\n\treturn LocVelDistTraveledMessage{\n\t\tY:  float64(data[0]),\n\t\tZ:  -float64(data[1]),\n\t\tX:  -float64(data[2]),\n\t\tYv: float64(data[3]),\n\t\tZv: -float64(data[4]),\n\t\tXv: -float64(data[5]),\n\t}\n}\n\n\n\nfunc (m LocVelDistTraveledMessage) Type() uint ", "output": "{\n\treturn LocVelDistTraveledMessageType\n}"}
{"input": "package txthrottler\n\nimport (\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n\ntype MockTopologyWatcherInterface struct {\n\tctrl     *gomock.Controller\n\trecorder *_MockTopologyWatcherInterfaceRecorder\n}\n\n\ntype _MockTopologyWatcherInterfaceRecorder struct {\n\tmock *MockTopologyWatcherInterface\n}\n\nfunc NewMockTopologyWatcherInterface(ctrl *gomock.Controller) *MockTopologyWatcherInterface {\n\tmock := &MockTopologyWatcherInterface{ctrl: ctrl}\n\tmock.recorder = &_MockTopologyWatcherInterfaceRecorder{mock}\n\treturn mock\n}\n\nfunc (_m *MockTopologyWatcherInterface) EXPECT() *_MockTopologyWatcherInterfaceRecorder {\n\treturn _m.recorder\n}\n\nfunc (_m *MockTopologyWatcherInterface) Stop() {\n\t_m.ctrl.Call(_m, \"Stop\")\n}\n\n\n\nfunc (_m *MockTopologyWatcherInterface) WaitForInitialTopology() error {\n\tret := _m.ctrl.Call(_m, \"WaitForInitialTopology\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\nfunc (_mr *_MockTopologyWatcherInterfaceRecorder) WaitForInitialTopology() *gomock.Call {\n\treturn _mr.mock.ctrl.RecordCall(_mr.mock, \"WaitForInitialTopology\")\n}\n\nfunc (_mr *_MockTopologyWatcherInterfaceRecorder) Stop() *gomock.Call ", "output": "{\n\treturn _mr.mock.ctrl.RecordCall(_mr.mock, \"Stop\")\n}"}
{"input": "package mongostore\n\nimport (\n\t\"golang.org/x/net/context\"\n\t\"gopkg.in/mgo.v2\"\n)\n\ntype key int\n\nconst (\n\tsessionKey key = iota\n)\n\nfunc WithSession(ctx context.Context, s *mgo.Session) context.Context {\n\treturn context.WithValue(ctx, sessionKey, s)\n}\n\n\n\nfunc Session(ctx context.Context) *mgo.Session ", "output": "{\n\ts, ok := ctx.Value(sessionKey).(*mgo.Session)\n\tif !ok || s == nil {\n\t\tpanic(\"no Session set in context\")\n\t}\n\treturn s\n}"}
{"input": "package migration\n\nimport \"time\"\n\n\ntype IssueContext interface {\n\tLocalID() int64\n\tForeignID() int64\n}\n\n\ntype BasicIssueContext int64\n\n\nfunc (c BasicIssueContext) LocalID() int64 {\n\treturn int64(c)\n}\n\n\nfunc (c BasicIssueContext) ForeignID() int64 {\n\treturn int64(c)\n}\n\n\ntype Issue struct {\n\tNumber      int64        `json:\"number\"`\n\tPosterID    int64        `yaml:\"poster_id\" json:\"poster_id\"`\n\tPosterName  string       `yaml:\"poster_name\" json:\"poster_name\"`\n\tPosterEmail string       `yaml:\"poster_email\" json:\"poster_email\"`\n\tTitle       string       `json:\"title\"`\n\tContent     string       `json:\"content\"`\n\tRef         string       `json:\"ref\"`\n\tMilestone   string       `json:\"milestone\"`\n\tState       string       `json:\"state\"` \n\tIsLocked    bool         `yaml:\"is_locked\" json:\"is_locked\"`\n\tCreated     time.Time    `json:\"created\"`\n\tUpdated     time.Time    `json:\"updated\"`\n\tClosed      *time.Time   `json:\"closed\"`\n\tLabels      []*Label     `json:\"labels\"`\n\tReactions   []*Reaction  `json:\"reactions\"`\n\tAssignees   []string     `json:\"assignees\"`\n\tContext     IssueContext `yaml:\"-\"`\n}\n\n\n\n\n\nfunc (i *Issue) GetExternalID() int64 { return i.PosterID }\n\nfunc (i *Issue) GetExternalName() string ", "output": "{ return i.PosterName }"}
{"input": "package assertions\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/smartystreets/gunit\"\n)\n\n\n\nfunc TestAssertionsFixture(t *testing.T) {\n\tgunit.Run(new(AssertionsFixture), t)\n}\n\ntype AssertionsFixture struct {\n\t*gunit.Fixture\n}\n\nfunc (this *AssertionsFixture) Setup() {\n\tserializer = this\n}\n\nfunc (self *AssertionsFixture) serialize(expected, actual interface{}, message string) string {\n\treturn fmt.Sprintf(\"%v|%v|%s\", expected, actual, message)\n}\n\nfunc (self *AssertionsFixture) serializeDetailed(expected, actual interface{}, message string) string {\n\treturn fmt.Sprintf(\"%v|%v|%s\", expected, actual, message)\n}\n\nfunc (this *AssertionsFixture) pass(result string) {\n\tthis.Assert(result == success, result)\n}\n\nfunc (this *AssertionsFixture) fail(actual string, expected string) {\n\tactual = format(actual)\n\texpected = format(expected)\n\n\tif actual != expected {\n\t\tif actual == \"\" {\n\t\t\tactual = \"(empty)\"\n\t\t}\n\t\tthis.Errorf(\"Expected: %s\\nActual:   %s\\n\", expected, actual)\n\t}\n}\n\n\n\n\ntype Thing1 struct {\n\ta string\n}\ntype Thing2 struct {\n\ta string\n}\n\ntype ThingInterface interface {\n\tHi()\n}\n\ntype ThingImplementation struct{}\n\nfunc (self *ThingImplementation) Hi() {}\n\ntype IntAlias int\ntype StringAlias string\ntype StringSliceAlias []string\ntype StringStringMapAlias map[string]string\n\n\n\ntype ThingWithEqualMethod struct {\n\ta string\n}\n\nfunc (this ThingWithEqualMethod) Equal(that ThingWithEqualMethod) bool {\n\treturn this.a == that.a\n}\n\nfunc format(message string) string ", "output": "{\n\tmessage = strings.Replace(message, \"\\n\", \" \", -1)\n\tfor strings.Contains(message, \"  \") {\n\t\tmessage = strings.Replace(message, \"  \", \" \", -1)\n\t}\n\treturn message\n}"}
{"input": "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"golang.org/x/oauth2\"\n)\n\n\nvar Endpoint = oauth2.Endpoint{\n\tAuthURL:  \"https://accounts.spotify.com/authorize\",\n\tTokenURL: \"https://accounts.spotify.com/api/token\",\n}\n\n\ntype ClientCredentials struct {\n\tconfig  *oauth2.Config\n\tcontext context.Context\n}\n\n\n\n\n\nfunc (c ClientCredentials) Token(state string, r *http.Request) (*oauth2.Token, error) {\n\tvalues := r.URL.Query()\n\tqueriedState := values.Get(\"state\")\n\tif queriedState != state {\n\t\treturn nil, errors.New(\"auth: states are different - cannot authenticate\")\n\t}\n\tcode := values.Get(\"code\")\n\tif code == \"\" {\n\t\treturn nil, errors.New(\"auth: didn't get access code\")\n\t}\n\treturn c.config.Exchange(c.context, code)\n}\n\nfunc CreateClientCredentials(redirectURL string, scopes []string) ClientCredentials ", "output": "{\n\tauthcfg := &oauth2.Config{\n\t\tClientID:     os.Getenv(\"SPOTIFY_ID\"),\n\t\tClientSecret: os.Getenv(\"SPOTIFY_SECRET\"),\n\t\tRedirectURL:  redirectURL,\n\t\tScopes:       scopes,\n\t\tEndpoint:     Endpoint,\n\t}\n\n\ttr := &http.Transport{\n\t\tTLSNextProto: map[string]func(authority string, c *tls.Conn) http.RoundTripper{},\n\t}\n\tctx := context.WithValue(context.Background(), oauth2.HTTPClient, &http.Client{Transport: tr})\n\n\treturn ClientCredentials{\n\t\tconfig:  authcfg,\n\t\tcontext: ctx,\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc main() {\n\tif !Exists(\"redis.tar.gz\") {\n\t\tDownload(\"http://download.redis.io/redis-stable.tar.gz\", \"redis.tar.gz\")\n\t}\n\tif Exists(\"redis\") {\n\t\tV(os.RemoveAll(\"redis\"))\n\t}\n\tV(os.MkdirAll(\"redis\", 0755))\n\tRun(\"tar zxvf redis.tar.gz -C redis --strip-components=1\")\n\tV(os.Chdir(\"redis\"))\n\tRun(\"make\")\n}\n\nfunc V(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Exists(path string) bool {\n\tif _, err := os.Stat(path); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn false\n\t\t}\n\t\tV(err)\n\t}\n\treturn true\n}\n\n\n\nfunc Run(command string) {\n\tfmt.Printf(\"run: %s\\n\", command)\n\targs := strings.Split(command, \" \")\n\tcmd := exec.Command(args[0], args[1:]...)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tif err := cmd.Run(); err != nil {\n\t\tfmt.Printf(\"command failed: %s\\n\", command)\n\t\tV(err)\n\t}\n}\n\nfunc Download(fileURL string, filename string) ", "output": "{\n\tresp, err := http.Get(fileURL)\n\tV(err)\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tV(err)\n\tV(ioutil.WriteFile(filename, body, 0644))\n}"}
{"input": "package udp_vs_tcp\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"time\"\n)\n\ntype UDPServer struct {\n\tladdr   string\n\tgen     Generator\n\ttimeout time.Duration\n}\n\nfunc NewUDPServer(laddr string, timeout time.Duration, gen Generator) Server {\n\treturn &UDPServer{laddr, gen, timeout}\n}\n\nfunc (u *UDPServer) Measure(bufferSize int, kill chan struct{}) (chan *ServerMeasure, error) {\n\tladdr, err := net.ResolveUDPAddr(\"udp\", u.laddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"resolving addr, %v\", err)\n\t}\n\tconn, err := net.ListenUDP(\"udp\", laddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"listening, %v\", err)\n\t}\n\n\tgo func() {\n\t\t<-kill\n\t\tlog.Printf(\"Server received kill request\")\n\t\terr := conn.Close()\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Closing connection, %v\", err)\n\t\t}\n\t}()\n\n\tmeasures := make(chan *ServerMeasure)\n\tgo func(mChan chan *ServerMeasure) {\n\t\tdefer conn.Close()\n\t\tdefer close(mChan)\n\n\t\tbuf := make([]byte, bufferSize)\n\t\tvar last time.Time\n\t\tfor {\n\t\t\tlast = time.Now()\n\t\t\tm, err := u.read(conn, buf, last)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tmChan <- m\n\t\t}\n\t}(measures)\n\treturn measures, nil\n}\n\n\n\nfunc (u *UDPServer) read(conn *net.UDPConn, buf []byte, last time.Time) (*ServerMeasure, error) ", "output": "{\n\terr := conn.SetDeadline(time.Now().Add(u.timeout))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"setting deadline for next read, %v\", err)\n\t}\n\n\tn, err := conn.Read(buf)\n\tnow := time.Now()\n\n\tm := &ServerMeasure{now, now.Sub(last), n, buf[:n], err}\n\n\tif err != nil && err != io.EOF {\n\t\treturn m, fmt.Errorf(\"reading, %v\", err)\n\t}\n\n\tif err == io.EOF && !u.gen.HasNext() {\n\t\treturn m, errors.New(\"expected next sequence but got EOF\")\n\t}\n\n\treturn m, nil\n}"}
{"input": "package version\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n\ntype Command struct {\n\tName       string\n\tW          io.Writer\n\tWErr       io.Writer\n\tAppName    string\n\tAppVersion string\n\tGitCommit  string\n}\n\n\n\n\n\nfunc (c *Command) Key() string {\n\treturn c.Name\n}\n\n\n\nfunc (c *Command) Aliases() map[string]struct{} {\n\treturn map[string]struct{}{\n\t\t\"version\": struct{}{},\n\t}\n}\n\n\nfunc (c *Command) Description() string {\n\treturn \"Print the version.\"\n}\n\nfunc (c *Command) Run(args []string) (int, error) ", "output": "{\n\tfmt.Fprintln(c.W, c.AppName, c.AppVersion, c.GitCommit)\n\treturn 0, nil\n}"}
{"input": "package sftpd_test\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/sandreas/graft/sftpd\"\n)\n\n\n\nfunc TestFileTreeIntegrate(t *testing.T) ", "output": "{\n\texpect := assert.New(t)\n\tfileTree := sftpd.NewFileTree(\"data/fixtures\")\n\texpect.NotNil(fileTree)\n\n}"}
{"input": "package dsn\n\nimport (\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\n\n\nfunc TestParseDSN(t *testing.T) ", "output": "{\n\tConvey(\"test parsedsn\", t, func() {\n\t\tvar (\n\t\t\ts = \"key:secret@group/topic=1&role=2&color=red\"\n\t\t\tt = &DSN{\n\t\t\t\tKey:    \"key\",\n\t\t\t\tSecret: \"secret\",\n\t\t\t\tGroup:  \"group\",\n\t\t\t\tTopic:  \"1\",\n\t\t\t\tRole:   \"2\",\n\t\t\t\tColor:  \"red\",\n\t\t\t}\n\t\t)\n\t\td, err := ParseDSN(s)\n\t\tSo(err, ShouldBeNil)\n\t\tSo(d, ShouldResemble, t)\n\t\ts = \"key:secret@group/top:ic=1&role=2\"\n\t\t_, err = ParseDSN(s)\n\t\tSo(err, ShouldNotBeNil)\n\t})\n}"}
{"input": "package midi\n\nimport \"fmt\"\n\ntype Track struct {\n\tevents []Event\n}\n\n\n\nfunc (t *Track) String() string {\n\treturn fmt.Sprintf(\n\t\t\"Track [Events=%v]\",\n\t\tt.Events())\n}\n\nfunc NewTrack(e []Event) *Track {\n\treturn &Track{e}\n}\n\nfunc (t *Track) Events() []Event ", "output": "{\n\treturn t.events\n}"}
{"input": "package lb\n\nimport (\n\t\"database/sql\"\n\t\"testing\"\n\n\t_ \"github.com/lib/pq\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDBPortAllocator_Get(t *testing.T) {\n\tdb := newDB(t)\n\ta := &DBPortAllocator{\n\t\tdb: db,\n\t}\n\n\tport, err := a.Get()\n\tassert.NoError(t, err)\n\tassert.NotEqual(t, 0, port)\n\n\terr = a.Put(port)\n\tassert.NoError(t, err)\n}\n\n\n\nfunc newDB(t testing.TB) *sql.DB ", "output": "{\n\tdb, err := sql.Open(\"postgres\", \"postgres://localhost/empire?sslmode=disable\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn db\n}"}
{"input": "package main\nimport (\n\t\"github.com/samcrosoft/waveform-json\"\n\t\"github.com/samcrosoft/waveform-json/fetchers\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"flag\"\n\t\"strings\"\n\t\"runtime\"\n)\n\nfunc main() {\n\n\truntime.GOMAXPROCS(runtime.NumCPU())\n\n\tvar sOutputFileName string\n\tvar sSource string\n\tvar oFetcher fetchers.IMAGEFetcher\n\tflag.StringVar(&sOutputFileName, \"o\", \"output.json\", \"the outfile filename, default is output.json\")\n\tflag.StringVar(&sSource, \"s\", \"\", \"the source of the waveform, e.g ./corpus/sample.png\")\n\tflag.Parse()\n\n\tif(sSource == \"\"){\n\t\tos.Stderr.WriteString(\"Source Of Waveform cannot be empty\")\n\t\tos.Exit(0)\n\t}\n\toFetcher = determineFetcherTypeFromSource(sSource)\n\toWave := waveformjson.New(sSource, oFetcher)\n\n\tif oJson, err := oWave.GetWaveformJson(); err == nil{\n\t\tif err2 := ioutil.WriteFile(sOutputFileName, oJson, os.FileMode(os.O_WRONLY)); err2 != nil{\n\t\t}\n\t}else{\n\t\tos.Stderr.WriteString(\"Not A Valid Png\")\n\t}\n\n}\n\n\n\n\nfunc determineFetcherTypeFromSource(sSource string) fetchers.IMAGEFetcher", "output": "{\n\tif sSource != \"\" && strings.HasPrefix(sSource, \"http\"){\n\t\treturn &fetchers.URLFetcher{}\n\t}else{\n\t\treturn &fetchers.FILEFetcher{}\n\t}\n}"}
{"input": "package api\n\nimport (\n\t\"bytes\"\n\t\"github.com/globocom/tsuru/app\"\n\t\"github.com/globocom/tsuru/db\"\n\t\"labix.org/v2/mgo/bson\"\n\t. \"launchpad.net/gocheck\"\n)\n\n\n\nfunc (s *S) TestLogWriterShouldReturnsTheDataSize(c *C) {\n\tvar b bytes.Buffer\n\ta := app.App{Name: \"newApp\"}\n\terr := db.Session.Apps().Insert(a)\n\tc.Assert(err, IsNil)\n\tdefer db.Session.Apps().Remove(bson.M{\"name\": a.Name})\n\twriter := LogWriter{&a, &b}\n\tdata := []byte(\"ble\")\n\tn, err := writer.Write(data)\n\tc.Assert(err, IsNil)\n\tc.Assert(n, Equals, len(data))\n}\n\nfunc (s *S) TestLogWriter(c *C) ", "output": "{\n\tvar b bytes.Buffer\n\ta := app.App{Name: \"newApp\"}\n\terr := db.Session.Apps().Insert(a)\n\tc.Assert(err, IsNil)\n\tdefer db.Session.Apps().Remove(bson.M{\"name\": a.Name})\n\twriter := LogWriter{&a, &b}\n\tdata := []byte(\"ble\")\n\t_, err = writer.Write(data)\n\tc.Assert(err, IsNil)\n\tc.Assert(b.Bytes(), DeepEquals, data)\n\tinstance := app.App{}\n\terr = db.Session.Apps().Find(bson.M{\"name\": a.Name}).One(&instance)\n\tlogLen := len(instance.Logs)\n\tc.Assert(instance.Logs[logLen-1].Message, Equals, string(data))\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n\t\"net/http\"\n)\n\n\ntype GetVolumeRequest struct {\n\n\tVolumeId *string `mandatory:\"true\" contributesTo:\"path\" name:\"volumeId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetVolumeRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request GetVolumeRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetVolumeResponse struct {\n\n\tRawResponse *http.Response\n\n\tVolume `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response GetVolumeResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response GetVolumeResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request GetVolumeRequest) HTTPRequest(method, path string) (http.Request, error) ", "output": "{\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}"}
{"input": "package grpc\n\nimport (\n\t\"reflect\"\n\n\t\"github.com/asim/go-micro/v3/registry\"\n\t\"github.com/asim/go-micro/v3/server\"\n)\n\ntype rpcHandler struct {\n\tname      string\n\thandler   interface{}\n\tendpoints []*registry.Endpoint\n\topts      server.HandlerOptions\n}\n\nfunc newRpcHandler(handler interface{}, opts ...server.HandlerOption) server.Handler {\n\toptions := server.HandlerOptions{\n\t\tMetadata: make(map[string]map[string]string),\n\t}\n\n\tfor _, o := range opts {\n\t\to(&options)\n\t}\n\n\ttyp := reflect.TypeOf(handler)\n\thdlr := reflect.ValueOf(handler)\n\tname := reflect.Indirect(hdlr).Type().Name()\n\n\tvar endpoints []*registry.Endpoint\n\n\tfor m := 0; m < typ.NumMethod(); m++ {\n\t\tif e := extractEndpoint(typ.Method(m)); e != nil {\n\t\t\te.Name = name + \".\" + e.Name\n\n\t\t\tfor k, v := range options.Metadata[e.Name] {\n\t\t\t\te.Metadata[k] = v\n\t\t\t}\n\n\t\t\tendpoints = append(endpoints, e)\n\t\t}\n\t}\n\n\treturn &rpcHandler{\n\t\tname:      name,\n\t\thandler:   handler,\n\t\tendpoints: endpoints,\n\t\topts:      options,\n\t}\n}\n\nfunc (r *rpcHandler) Name() string {\n\treturn r.name\n}\n\nfunc (r *rpcHandler) Handler() interface{} {\n\treturn r.handler\n}\n\n\n\nfunc (r *rpcHandler) Options() server.HandlerOptions {\n\treturn r.opts\n}\n\nfunc (r *rpcHandler) Endpoints() []*registry.Endpoint ", "output": "{\n\treturn r.endpoints\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tflag.Parse()\n\n\tvar p []float64\n\tfor _, v := range flag.Args() {\n\t\tq, _ := strconv.ParseFloat(v, 64)\n\t\tp = append(p, q)\n\t}\n\tif len(p) == 0 {\n\t\tos.Exit(0)\n\t}\n\tx := p[len(p)-1]\n\tp = p[:len(p)-1]\n\tfmt.Printf(\"poly: %v\\n\", p)\n\tfmt.Printf(\"x:    %v\\n\", x)\n\tfmt.Println(horner(p, x))\n}\n\n\n\nfunc horner(p []float64, x float64) float64 ", "output": "{\n\tif len(p) == 0 {\n\t\treturn x\n\t}\n\tr := p[0]\n\tfor _, z := range p[1:] {\n\t\tr = r*x + z\n\t}\n\treturn r\n}"}
{"input": "package goanna\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n\t\"runtime/debug\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst LogRequestTemplate = `\n----------------------------------------------------------------------\n%s\n\nUrl: %s\nMethod: %s\nTimestamp: %s\n\nRequest Headers:\n%s\n\nRequest Body:\n%s\n\nStack trace:\n%s\n----------------------------------------------------------------------\n`\n\nvar Logger *log.Logger\n\n\nfunc LogRequest(r *Request, v ...string) {\n\tserializedHeaders := bytes.Buffer{}\n\tr.Header.Write(&serializedHeaders)\n\n\tprintf := log.Printf\n\tif Logger != nil {\n\t\tprintf = Logger.Printf\n\t}\n\n\tprintf(\n\t\tLogRequestTemplate,\n\t\tstrings.Join(v, \" \"),\n\t\tr.URL.String(),\n\t\tr.Method,\n\t\ttime.Now(),\n\t\tserializedHeaders.String(),\n\t\tstring(r.BodyData()),\n\t\tdebug.Stack(),\n\t)\n}\n\n\n\n\nfunc LogHttpRequest(r *http.Request, v ...string) ", "output": "{\n\tserializedHeaders := bytes.Buffer{}\n\tr.Header.Write(&serializedHeaders)\n\n\tprintf := log.Printf\n\tif Logger != nil {\n\t\tprintf = Logger.Printf\n\t}\n\n\tprintf(\n\t\tLogRequestTemplate,\n\t\tstrings.Join(v, \" \"),\n\t\tr.URL.String(),\n\t\tr.Method,\n\t\ttime.Now(),\n\t\tserializedHeaders.String(),\n\t\t\"<hidden>\",\n\t\tdebug.Stack(),\n\t)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/docker/go-connections/sockets\"\n\t\"github.com/gostor/gotgt/cmd\"\n\t\"github.com/gostor/gotgt/pkg/api/client\"\n\t\"github.com/gostor/gotgt/pkg/version\"\n)\n\nfunc main() {\n\n\thost := \"tcp://127.0.0.1:23457\"\n\thttpClient, err := newHTTPClient(host)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"%v\", err)\n\t\tos.Exit(1)\n\t}\n\n\tcli, err := client.NewClient(host, version.Version, httpClient, nil)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"%v\", err)\n\t\tos.Exit(1)\n\t}\n\tif err := cmd.NewCommand(cli).Execute(); err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(-1)\n\t}\n}\n\n\n\nfunc newHTTPClient(host string) (*http.Client, error) ", "output": "{\n\ttr := &http.Transport{\n\t\tTLSClientConfig: nil,\n\t}\n\tproto, addr, _, err := client.ParseHost(host)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsockets.ConfigureTransport(tr, proto, addr)\n\n\treturn &http.Client{\n\t\tTransport: tr,\n\t}, nil\n}"}
{"input": "package quantity\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n\ntype Offset Size\n\nconst (\n\tOffsetKiB = Offset(1 << 10)\n\tOffsetMiB = Offset(1 << 20)\n)\n\n\n\n\n\n\nfunc (o *Offset) IECString() string {\n\treturn iecSizeString(int64(*o))\n}\n\nfunc (o *Offset) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\tvar gs string\n\tif err := unmarshal(&gs); err != nil {\n\t\treturn errors.New(`cannot unmarshal gadget offset`)\n\t}\n\n\tvar err error\n\t*o, err = ParseOffset(gs)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"cannot parse offset %q: %v\", gs, err)\n\t}\n\treturn err\n}\n\n\n\nfunc ParseOffset(gs string) (Offset, error) {\n\toffs, err := parseSizeOrOffset(gs)\n\tif offs < 0 {\n\t\treturn 0, errors.New(\"offset cannot be negative\")\n\t}\n\treturn Offset(offs), err\n}\n\nfunc (o *Offset) String() string ", "output": "{\n\treturn (*Size)(o).String()\n}"}
{"input": "package web\n\nimport (\n\t\"io/fs\"\n\t\"log\"\n\t\"net/http\"\n)\n\n\nfunc Serve(addr string, data fs.FS) error {\n\tdata, err := fs.Sub(data, \"docs\")\n\tif err != nil {\n\t\treturn err\n\t}\n\thttp.Handle(\"/\", http.FileServer(http.FS(data)))\n\treturn http.ListenAndServe(addr, logRequest(http.DefaultServeMux))\n}\n\n\n\n\nfunc logRequest(handler http.Handler) http.Handler ", "output": "{\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlog.Printf(\"%s %s %s\\n\", r.RemoteAddr, r.Method, r.URL)\n\t\thandler.ServeHTTP(w, r)\n\t})\n}"}
{"input": "package protocol\n\n\ntype LogoutRequestMessageData struct {\n}\n\n\ntype LogoutRequestMessage struct {\n\tBaseMessage\n\tData LogoutRequestMessageData `json:\"data\"`\n}\n\n\nfunc NewLogoutRequesMessage(session string) *LogoutRequestMessage {\n\tmessage := LogoutRequestMessage{}\n\tmessage.Type = LogoutRequestMessageType\n\tmessage.Session = session\n\treturn &message\n}\n\n\n\n\n\nfunc (m *LogoutRequestMessage) GetSession() string {\n\treturn m.Session\n}\n\n\nfunc (m *LogoutRequestMessage) GetData() interface{} {\n\treturn m.Data\n}\n\n\nfunc (m *LogoutRequestMessage) SetSession(session string) {\n\tm.BaseMessage.Session = session\n}\n\nfunc (m *LogoutRequestMessage) GetType() string ", "output": "{\n\treturn m.Type\n}"}
{"input": "package main\n\nvar log string\n\ntype T int\n\nfunc (t T) a(s string) T {\n\tlog += \"a(\" + s + \")\"\n\treturn t\n}\n\nfunc (T) b(s string) string {\n\tlog += \"b\"\n\treturn s\n}\n\ntype F func(s string) F\n\nfunc a(s string) F {\n\tlog += \"a(\" + s + \")\"\n\treturn F(a)\n}\n\nfunc b(s string) string {\n\tlog += \"b\"\n\treturn s\n}\n\ntype I interface {\n\ta(s string) I\n\tb(s string) string\n}\n\ntype T1 int\n\nfunc (t T1) a(s string) I {\n\tlog += \"a(\" + s + \")\"\n\treturn t\n}\n\nfunc (T1) b(s string) string {\n\tlog += \"b\"\n\treturn s\n}\n\nvar ok = true\n\n\n\nfunc main() {\n\tvar t T\n\tif t.a(\"1\").a(t.b(\"2\")); log != \"a(1)ba(2)\" {\n\t\tbad()\n\t}\n\tlog = \"\"\n\tif a(\"3\")(b(\"4\"))(b(\"5\")); log != \"a(3)ba(4)ba(5)\" {\n\t\tbad()\n\t}\n\tlog = \"\"\n\tvar i I = T1(0)\n\tif i.a(\"6\").a(i.b(\"7\")).a(i.b(\"8\")).a(i.b(\"9\")); log != \"a(6)ba(7)ba(8)ba(9)\" {\n\t\tbad()\n\t}\n}\n\nfunc bad() ", "output": "{\n\tif !ok {\n\t\tprintln(\"BUG\")\n\t\tok = false\n\t}\n\tprintln(log)\n}"}
{"input": "package auth\n\nimport (\n\t\"sync\"\n\n\t\"github.com/google/martian/session\"\n)\n\nconst key = \"auth.Context\"\n\n\ntype Context struct {\n\tmu  sync.RWMutex\n\tid  string\n\terr error\n}\n\n\nfunc FromContext(ctx *session.Context) *Context {\n\tif v, ok := ctx.GetSession().Get(key); ok {\n\t\treturn v.(*Context)\n\t}\n\n\tactx := &Context{}\n\tctx.GetSession().Set(key, actx)\n\n\treturn actx\n}\n\n\nfunc (ctx *Context) ID() string {\n\tctx.mu.RLock()\n\tctx.mu.RUnlock()\n\n\treturn ctx.id\n}\n\n\nfunc (ctx *Context) SetID(id string) {\n\tctx.mu.Lock()\n\tctx.mu.Unlock()\n\n\tctx.err = nil\n\n\tif id == \"\" {\n\t\treturn\n\t}\n\n\tctx.id = id\n}\n\n\n\n\n\nfunc (ctx *Context) Error() error {\n\tctx.mu.RLock()\n\tdefer ctx.mu.RUnlock()\n\n\treturn ctx.err\n}\n\nfunc (ctx *Context) SetError(err error) ", "output": "{\n\tctx.mu.Lock()\n\tdefer ctx.mu.Unlock()\n\n\tctx.id = \"\"\n\tctx.err = err\n}"}
{"input": "package acho\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestMapToString(t *testing.T) {\n\tm := NewMap(3, 3)\n\n\tm.SetTile(0, 1, Tile{TileGround})\n\tm.SetTile(0, 2, Tile{TileGround})\n\tm.SetTile(1, 1, Tile{TileGround})\n\n\texpected := \"~ O O \\n~ O ~ \\n~ ~ ~ \\n\"\n\toutput := m.ToString()\n\n\tif output != expected {\n\t\tt.Errorf(\"expected:\\n%s\\n\\ngot:\\n%s\", expected, output)\n\t}\n}\n\nfunc TestMapCreation(t *testing.T) ", "output": "{\n\tm := NewMap(10, 10)\n\n\tif m.Data[3][5].Type != TileWater {\n\t\tt.Error(\"m.Data[3][5] should equal to\", TileWater, \", not\", m.Data[3][5].Type)\n\t}\n}"}
{"input": "package http\n\nimport (\n\t\"io/ioutil\"\n\t\"strings\"\n\t\"testing\"\n)\n\n\n\nfunc TestClientHead(t *testing.T) {\n\tr, err := Head(\"http://www.google.com/robots.txt\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, ok := r.Header[\"Last-Modified\"]; !ok {\n\t\tt.Error(\"Last-Modified header not found.\")\n\t}\n}\n\nfunc TestClient(t *testing.T) ", "output": "{\n\n\tr, _, err := Get(\"http://www.google.com/robots.txt\")\n\tvar b []byte\n\tif err == nil {\n\t\tb, err = ioutil.ReadAll(r.Body)\n\t\tr.Body.Close()\n\t}\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if s := string(b); !strings.HasPrefix(s, \"User-agent:\") {\n\t\tt.Errorf(\"Incorrect page body (did not begin with User-agent): %q\", s)\n\t}\n}"}
{"input": "package api\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/mozilla/doorman/doorman\"\n)\n\n\n\n\nfunc SetupRoutes(r *gin.Engine, d doorman.Doorman) ", "output": "{\n\tr.Use(ContextMiddleware(d))\n\n\ta := r.Group(\"\")\n\ta.Use(AuthnMiddleware(d))\n\ta.POST(\"/allowed\", allowedHandler)\n\n\tsources := d.ConfigSources()\n\tr.POST(\"/__reload__\", reloadHandler(sources))\n\n\tr.GET(\"/__lbheartbeat__\", lbHeartbeatHandler)\n\tr.GET(\"/__heartbeat__\", heartbeatHandler)\n\tr.GET(\"/__version__\", versionHandler)\n\tr.GET(\"/__api__\", YAMLAsJSONHandler(\"api/openapi.yaml\"))\n\tr.GET(\"/contribute.json\", YAMLAsJSONHandler(\"api/contribute.yaml\"))\n}"}
{"input": "package app\n\nimport \"github.com/containerd/containerd/cmd/ctr/commands/shim\"\n\n\n\nfunc init() ", "output": "{\n\textraCmds = append(extraCmds, shim.Command)\n}"}
{"input": "package conformance\n\n\n\nfunc stringLen(s string) int {\n\treturn len(s)\n}\n\nfunc substring(s string, low, high int) string {\n\tswitch {\n\tcase low >= 0 && high >= 0:\n\t\treturn s[low:high]\n\tcase low >= 0:\n\t\treturn s[low:]\n\tcase high >= 0:\n\t\treturn s[:high]\n\tdefault:\n\t\treturn s\n\t}\n}\n\nfunc stringGet(s string, index int) byte ", "output": "{\n\treturn s[index]\n}"}
{"input": "package sha256\n\nfunc cpuid(op uint32) (eax, ebx, ecx, edx uint32) {\n\treturn 0, 0, 0, 0\n}\n\n\n\nfunc xgetbv(index uint32) (eax, edx uint32) {\n\treturn 0, 0\n}\n\nfunc haveArmSha() bool {\n\treturn false\n}\n\nfunc cpuidex(op, op2 uint32) (eax, ebx, ecx, edx uint32) ", "output": "{\n\treturn 0, 0, 0, 0\n}"}
{"input": "package driver\n\nimport \"database/sql/driver\"\n\nvar _ driver.Stmt = stmt{}\n\ntype stmt struct {\n\tconn *conn\n\tstmt string\n}\n\nfunc (stmt) Close() error {\n\treturn nil\n}\n\nfunc (stmt) NumInput() int {\n\treturn -1\n}\n\nfunc (s stmt) Exec(args []driver.Value) (driver.Result, error) {\n\treturn s.conn.Exec(s.stmt, args)\n}\n\n\n\nfunc (s stmt) Query(args []driver.Value) (driver.Rows, error) ", "output": "{\n\treturn s.conn.Query(s.stmt, args)\n}"}
{"input": "package mdt\n\nimport \"bytes\"\n\ntype rows []row\n\n\n\nfunc (r rows) lengthAt(index int) int {\n\tvar max int\n\tfor _, row := range r {\n\t\tif n := row.lengthAt(index); n > max {\n\t\t\tmax = n\n\t\t}\n\t}\n\tif max < 3 {\n\t\tmax = 3\n\t}\n\treturn max\n}\n\nfunc (r rows) toMarkdown() string {\n\tcolNum := r.colNum()\n\tlens := []int{}\n\tfor i := 0; i < colNum; i++ {\n\t\tlens = append(lens, r.lengthAt(i))\n\t}\n\n\tvar buf bytes.Buffer\n\tfor _, row := range r {\n\t\tbuf.WriteString(row.toMarkdown(colNum, lens) + \"\\n\")\n\t}\n\treturn buf.String()\n}\n\nfunc (r rows) colNum() int ", "output": "{\n\tvar max int\n\tfor _, row := range r {\n\t\tif n := row.colNum(); n > max {\n\t\t\tmax = n\n\t\t}\n\t}\n\treturn max\n}"}
{"input": "package main\n\nimport (\n\t\"bytes\"\n\n\t\"github.com/bitly/go-nsq\"\n)\n\n\n\ntype BackendQueue interface {\n\tPut([]byte) error\n\tReadChan() chan []byte \n\tClose() error\n\tDelete() error\n\tDepth() int64\n\tEmpty() error\n}\n\ntype DummyBackendQueue struct {\n\treadChan chan []byte\n}\n\nfunc NewDummyBackendQueue() BackendQueue {\n\treturn &DummyBackendQueue{readChan: make(chan []byte)}\n}\n\nfunc (d *DummyBackendQueue) Put([]byte) error {\n\treturn nil\n}\n\nfunc (d *DummyBackendQueue) ReadChan() chan []byte {\n\treturn d.readChan\n}\n\nfunc (d *DummyBackendQueue) Close() error {\n\treturn nil\n}\n\nfunc (d *DummyBackendQueue) Delete() error {\n\treturn nil\n}\n\n\n\nfunc (d *DummyBackendQueue) Empty() error {\n\treturn nil\n}\n\nfunc WriteMessageToBackend(buf *bytes.Buffer, msg *nsq.Message, bq BackendQueue) error {\n\tbuf.Reset()\n\terr := msg.Write(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = bq.Put(buf.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (d *DummyBackendQueue) Depth() int64 ", "output": "{\n\treturn int64(0)\n}"}
{"input": "package entityUtils\n\nfunc CreateRelatedField(fieldName string, canRelatedSel bool) *RelatedField {\n\treturn &RelatedField{\n\t\tFieldName:     fieldName,\n\t\tCanRelatedSel: canRelatedSel,\n\t}\n}\n\nfunc CreateRelatedFieldsToLoad(relatedFields ...*RelatedField) *RelatedFieldsToLoad {\n\treturn &RelatedFieldsToLoad{\n\t\tfields: relatedFields,\n\t}\n}\n\ntype RelatedField struct {\n\tFieldName string\n\n\tCanRelatedSel bool\n}\n\ntype RelatedFieldsToLoad struct {\n\tfields []*RelatedField\n}\n\n\n\nfunc (this *RelatedFieldsToLoad) GetFieldNames(includeCanRelatedSel, includeNOTcanRelatedSel bool) []string {\n\tfieldNames := []string{}\n\tfor _, rl := range this.fields {\n\t\tif !includeCanRelatedSel && rl.CanRelatedSel {\n\t\t\tcontinue\n\t\t}\n\t\tif !includeNOTcanRelatedSel && !rl.CanRelatedSel {\n\t\t\tcontinue\n\t\t}\n\t\tfieldNames = append(fieldNames, rl.FieldName)\n\t}\n\treturn fieldNames\n}\n\nfunc (this *RelatedFieldsToLoad) AppendIfTrue(checkIfTrue bool, relatedFieldToAppend *RelatedField) ", "output": "{\n\tif !checkIfTrue {\n\t\treturn\n\t}\n\tthis.fields = append(this.fields, relatedFieldToAppend)\n}"}
{"input": "package taskmanager\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n\nfunc NewAgent(t TaskManagerInterface, callerName string) *Agent {\n\treturn &Agent{\n\t\tkillTaskPoller:  make(chan bool, 1),\n\t\tprocessComplete: make(chan bool, 1),\n\t\ttaskPollEmitter: make(chan bool, 1),\n\t\tstatusEmitter:   make(chan string, 1),\n\t\ttaskManager:     t,\n\t\ttask:            t.NewTask(callerName, TaskAgentLongRunning, AgentTaskStatusInitializing),\n\t}\n}\n\n\n\n\n\nfunc (s *Agent) GetTask() *Task {\n\treturn s.task\n}\n\n\nfunc (s *Agent) GetStatus() chan string {\n\treturn s.statusEmitter\n}\n\nfunc (s *Agent) startTaskPoller() {\nForLoop:\n\tfor {\n\t\tselect {\n\t\tcase <-s.killTaskPoller:\n\t\t\ts.processComplete <- true\n\t\t\tbreak ForLoop\n\t\tdefault:\n\t\t\ts.taskPollEmitter <- true\n\t\t}\n\t\ttime.Sleep(AgentTaskPollerInterval)\n\t}\n}\n\nfunc (s *Agent) listenForPoll() {\n\tfor <-s.taskPollEmitter {\n\t\ts.task.Expires = time.Now().Add(AgentTaskPollerTimeout).UnixNano()\n\t\ts.taskManager.SaveTask(s.task)\n\t}\n\ts.killTaskPoller <- true\n}\n\nfunc (s *Agent) Run(process func(*Agent) error) ", "output": "{\n\ts.task.Status = AgentTaskStatusRunning\n\ts.statusEmitter <- s.task.Status\n\ts.taskManager.SaveTask(s.task)\n\tgo s.startTaskPoller()\n\tgo s.listenForPoll()\n\n\tgo func(agent Agent) {\n\t\ts := &agent\n\t\terr := process(s)\n\t\ts.taskPollEmitter <- false\n\n\t\tselect {\n\t\tcase <-s.processComplete:\n\t\t\tif err == nil {\n\t\t\t\ts.task.Status = AgentTaskStatusComplete\n\n\t\t\t} else {\n\t\t\t\ts.task.Status = fmt.Sprintf(\"status: %s, error: %s\", AgentTaskStatusFailed, err.Error())\n\t\t\t}\n\t\t\ts.task.Expires = 0\n\t\t\ts.taskManager.SaveTask(s.task)\n\t\t\ts.statusEmitter <- s.task.Status\n\t\t}\n\t}(*s)\n}"}
{"input": "package fake\n\nimport (\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n\tv1beta1 \"knative.dev/serving/pkg/client/clientset/versioned/typed/serving/v1beta1\"\n)\n\ntype FakeServingV1beta1 struct {\n\t*testing.Fake\n}\n\nfunc (c *FakeServingV1beta1) Configurations(namespace string) v1beta1.ConfigurationInterface {\n\treturn &FakeConfigurations{c, namespace}\n}\n\nfunc (c *FakeServingV1beta1) Revisions(namespace string) v1beta1.RevisionInterface {\n\treturn &FakeRevisions{c, namespace}\n}\n\nfunc (c *FakeServingV1beta1) Routes(namespace string) v1beta1.RouteInterface {\n\treturn &FakeRoutes{c, namespace}\n}\n\nfunc (c *FakeServingV1beta1) Services(namespace string) v1beta1.ServiceInterface {\n\treturn &FakeServices{c, namespace}\n}\n\n\n\n\n\nfunc (c *FakeServingV1beta1) RESTClient() rest.Interface ", "output": "{\n\tvar ret *rest.RESTClient\n\treturn ret\n}"}
{"input": "package elastic\n\n\n\n\ntype LimitFilter struct {\n    Filter\n    limit int\n}\n\n\n\nfunc (f LimitFilter) Source() interface{} {\n    \n    \n    \n    \n    \n    source := make(map[string]interface{})\n    params := make(map[string]interface{})\n    source[\"limit\"] = params\n    params[\"value\"] = f.limit\n    return source\n}\n\nfunc NewLimitFilter(limit int) LimitFilter ", "output": "{\n    f := LimitFilter{limit: limit}\n    return f\n}"}
{"input": "package set\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIntSetCreate(t *testing.T) {\n\tis := NewIntSet()\n\tassert.NotNil(t, is)\n}\n\nfunc TestIntSetAddContains(t *testing.T) {\n\tis := NewIntSet()\n\tis.Add(42)\n\tassert.True(t, is.Contains(42))\n}\n\nfunc TestIntSetRemove(t *testing.T) {\n\tis := NewIntSet()\n\tis.Add(42)\n\tassert.True(t, is.Contains(42))\n\tis.Remove(42)\n\tassert.False(t, is.Contains(42))\n}\n\nfunc TestIntSetSize(t *testing.T) {\n\tis := NewIntSet()\n\tassert.Equal(t, 0, is.Size())\n\tis.Add(42)\n\tassert.Equal(t, 1, is.Size())\n}\n\n\n\nfunc TestIntSetIterate(t *testing.T) ", "output": "{\n\tis := NewIntSet()\n\tis.Add(42)\n\tfor x := range is.Iterate() {\n\t\tassert.Equal(t, 42, x)\n\t}\n}"}
{"input": "package ai\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype Loader func(context.Context) (map[int64]int64, error)\n\ntype AI struct {\n\twhites map[int64]int64\n\tsync.RWMutex\n}\n\n\n\nfunc (a *AI) White(mid int64) (num int64, ok bool) {\n\ta.RLock()\n\tdefer a.RUnlock()\n\tnum, ok = a.whites[mid]\n\treturn\n}\n\nfunc (a *AI) LoadWhite(c context.Context, loader Loader) (err error) {\n\tvar (\n\t\twhites map[int64]int64\n\t)\n\tif whites, err = loader(c); err != nil {\n\t\treturn\n\t}\n\ta.Lock()\n\ta.whites = whites\n\ta.Unlock()\n\treturn\n}\n\nfunc New() (a *AI) ", "output": "{\n\treturn &AI{\n\t\twhites: make(map[int64]int64),\n\t}\n}"}
{"input": "package models\n\nimport (\n\t\"time\"\n)\n\n\ntype MapLayer struct {\n\tId          int64         `json:\"id\"`\n\tName        string        `json:\"name\" validate:\"max=254;required\"`\n\tDescription string        `json:\"description\"`\n\tMap         *Map          `json:\"map\"`\n\tMapId       int64         `json:\"map_id\" validate:\"required\"`\n\tStatus      string        `json:\"status\" validate:\"required\"`\n\tWeight      int64         `json:\"weight\"`\n\tElements    []*MapElement `json:\"elements\"`\n\tCreatedAt   time.Time     `json:\"created_at\"`\n\tUpdatedAt   time.Time     `json:\"updated_at\"`\n}\n\n\ntype SortMapLayersByWeight []*MapLayer\n\n\nfunc (l SortMapLayersByWeight) Len() int { return len(l) }\n\n\n\n\n\nfunc (l SortMapLayersByWeight) Less(i, j int) bool { return l[i].Weight < l[j].Weight }\n\n\ntype SortMapLayer struct {\n\tId     int64 `json:\"id\"`\n\tWeight int64 `json:\"weight\"`\n}\n\nfunc (l SortMapLayersByWeight) Swap(i, j int) ", "output": "{ l[i], l[j] = l[j], l[i] }"}
{"input": "package sudokuBotDlx\n\nimport (\n  \"bytes\"\n  \"errors\"\n  \"strconv\"\n  \"strings\"\n  \"github.com/evjrob/sudokuDlx\"\n)\n\n\ntype Solver struct {\n  puzzle string\n  blockXDim int\n  blockYDim int\n  delimiter string\n}\n\n\n\n\n\nfunc (s *Solver) Solve() (string, error) {\n\n  puzzleSlice, err := convertToSlice(s.puzzle, s.blockXDim, s.blockYDim, s.delimiter)\n  if err != nil {\n     return \"\", err\n  }\n\n  solvedPuzzle, success := sudokuDlx.Solve(puzzleSlice, s.blockXDim, s.blockYDim)\n  if success {\n    solution := convertToString(solvedPuzzle, s.delimiter)\n    return solution, nil\n  }\n\n  \n  return \"\", nil\n}\n\n\n\n\n\n\nfunc convertToString(puzzle [][]int, delimiter string) string {\n  puzzleDim := len(puzzle)\n  var buffer bytes.Buffer\n\n  for r := range puzzle {\n\t\tfor c := range puzzle[r] {\n      value := strconv.Itoa(puzzle[r][c])\n\t\t  buffer.WriteString(value)\n      if !(r == (puzzleDim - 1) && c == (puzzleDim - 1)) {\n        buffer.WriteString(delimiter)\n      }\n\t\t}\n\t}\n  return buffer.String()\n}\n\n\nfunc NewSolver(puzzle string, blockXDim int, blockYDim int, delimiter string) *Solver {\n  return &Solver{ puzzle, blockXDim, blockYDim, delimiter }\n}\n\nfunc convertToSlice(providedPuzzle string, blockXDim, blockYDim int, delimiter string) ([][]int, error) ", "output": "{\n\n  \n  puzzleElements := strings.Split(providedPuzzle,delimiter)\n  puzzleDim := blockXDim * blockYDim\n\n  if (len(puzzleElements) != puzzleDim * puzzleDim) {\n    err := errors.New(\"InputError: providedPuzzle was not the correct dimension.\")\n    return nil, err\n  }\n\n  puzzle := make([][]int, puzzleDim)\n\n  for i := 0; i < puzzleDim; i++ {\n    puzzle[i] = make([]int, puzzleDim)\n    for j := 0; j < puzzleDim; j++ {\n      element := puzzleElements[(i*puzzleDim)+j]\n      value, err := strconv.Atoi(element)\n      if err == nil {\n        puzzle[i][j] = value\n      }\n    }\n  }\n\n  return puzzle, nil\n}"}
{"input": "package ftp\n\nimport \"io\"\n\ntype debugWrapper struct {\n\tconn io.ReadWriteCloser\n\tio.Reader\n\tio.Writer\n}\n\nfunc newDebugWrapper(conn io.ReadWriteCloser, w io.Writer) io.ReadWriteCloser {\n\treturn &debugWrapper{\n\t\tReader: io.TeeReader(conn, w),\n\t\tWriter: io.MultiWriter(w, conn),\n\t\tconn:   conn,\n\t}\n}\n\nfunc (w *debugWrapper) Close() error {\n\treturn w.conn.Close()\n}\n\ntype streamDebugWrapper struct {\n\tio.Reader\n\tcloser io.ReadCloser\n}\n\n\n\nfunc (w *streamDebugWrapper) Close() error {\n\treturn w.closer.Close()\n}\n\nfunc newStreamDebugWrapper(rd io.ReadCloser, w io.Writer) io.ReadCloser ", "output": "{\n\treturn &streamDebugWrapper{\n\t\tReader: io.TeeReader(rd, w),\n\t\tcloser: rd,\n\t}\n}"}
{"input": "package crypto\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n)\n\ntype SHA256Sum [32]byte\n\nfunc (s SHA256Sum) B64Encode() string {\n\treturn B64Encode(s[:])\n}\n\nfunc (s SHA256Sum) String() string {\n\tn := -1\n\tfor i, b := range s[:] {\n\t\tif b == 0 {\n\t\t\tbreak\n\t\t}\n\t\tn = i\n\t}\n\treturn string(s[:n+1])\n}\n\nfunc CertcoinHash(b []byte) SHA256Sum {\n\thash1 := sha256.Sum256(b)\n\thash2 := sha256.Sum256(hash1[:])\n\n\treturn hash2\n}\n\nfunc CertcoinHashStr(s string) SHA256Sum {\n\treturn CertcoinHash([]byte(s))\n}\n\nfunc B64Encode(b []byte) string {\n\treturn base64.StdEncoding.EncodeToString(b)\n}\n\n\n\nfunc B64Decode(s string) ([]byte, error) ", "output": "{\n\treturn base64.StdEncoding.DecodeString(s)\n}"}
{"input": "package fs\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\n\tlog \"github.com/Sirupsen/logrus\"\n)\n\n\ntype VolumeDevSpec struct {\n\tUnit                    string\n\tControllerPciSlotNumber string\n}\n\n\nfunc Mkdir(path string) error {\n\tstat, err := os.Lstat(path)\n\tif os.IsNotExist(err) {\n\t\tlog.WithField(\"path\", path).Info(\"Directory doesn't exist, creating it \")\n\t\tif err := os.MkdirAll(path, 0755); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"path\": path,\n\t\t\t\t\"err\": err}).Error(\"Failed to create directory \")\n\t\t\treturn err\n\t\t}\n\t} else if err != nil {\n\t\tlog.WithFields(log.Fields{\"path\": path,\n\t\t\t\"err\": err}).Error(\"Failed to test directory existence \")\n\t\treturn err\n\t}\n\n\tif stat != nil && !stat.IsDir() {\n\t\tmsg := fmt.Sprintf(\"%v already exists and it's not a directory\", path)\n\t\tlog.Error(msg)\n\t\treturn fmt.Errorf(msg)\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc GetMountRootEntries(mountRoot string) ([]string, error) {\n\tvar vols []string\n\tvolumes, err := ioutil.ReadDir(mountRoot)\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to read entries from %s (%v)\", mountRoot, err)\n\t\treturn vols, err\n\t}\n\n\tfor _, vol := range volumes {\n\t\tvols = append(vols, vol.Name())\n\t}\n\treturn vols, nil\n}\n\nfunc Rmdir(path string) error ", "output": "{\n\treturn os.Remove(path)\n}"}
{"input": "package treemap\n\nimport \"github.com/emirpasic/gods/containers\"\n\n\n\n\nfunc (m *Map) ToJSON() ([]byte, error) {\n\treturn m.tree.ToJSON()\n}\n\n\nfunc (m *Map) FromJSON(data []byte) error {\n\treturn m.tree.FromJSON(data)\n}\n\nfunc assertSerializationImplementation() ", "output": "{\n\tvar _ containers.JSONSerializer = (*Map)(nil)\n\tvar _ containers.JSONDeserializer = (*Map)(nil)\n}"}
{"input": "package disk\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n)\n\n\n\n\nfunc GetInfo(path string) (info Info, err error) ", "output": "{\n\ts := syscall.Statfs_t{}\n\terr = syscall.Statfs(path, &s)\n\tif err != nil {\n\t\treturn Info{}, err\n\t}\n\treservedBlocks := s.Bfree - uint64(s.Bavail)\n\tinfo = Info{\n\t\tTotal:  uint64(s.Bsize) * (s.Blocks - reservedBlocks),\n\t\tFree:   uint64(s.Bsize) * uint64(s.Bavail),\n\t\tFiles:  s.Files,\n\t\tFfree:  uint64(s.Ffree),\n\t\tFSType: getFSType(s.Fstypename[:]),\n\t}\n\tif info.Free > info.Total {\n\t\treturn info, fmt.Errorf(\"detected free space (%d) > total disk space (%d), fs corruption at (%s). please run 'fsck'\", info.Free, info.Total, path)\n\t}\n\tinfo.Used = info.Total - info.Free\n\treturn info, nil\n}"}
{"input": "package v1\n\n\n\n\n\n\n\n\n\n\n\n\nvar map_TokenReview = map[string]string{\n\t\"\":       \"TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver.\",\n\t\"spec\":   \"Spec holds information about the request being evaluated\",\n\t\"status\": \"Status is filled in by the server and indicates whether the request can be authenticated.\",\n}\n\nfunc (TokenReview) SwaggerDoc() map[string]string {\n\treturn map_TokenReview\n}\n\nvar map_TokenReviewSpec = map[string]string{\n\t\"\":      \"TokenReviewSpec is a description of the token authentication request.\",\n\t\"token\": \"Token is the opaque bearer token.\",\n}\n\nfunc (TokenReviewSpec) SwaggerDoc() map[string]string {\n\treturn map_TokenReviewSpec\n}\n\nvar map_TokenReviewStatus = map[string]string{\n\t\"\":              \"TokenReviewStatus is the result of the token authentication request.\",\n\t\"authenticated\": \"Authenticated indicates that the token was associated with a known user.\",\n\t\"user\":          \"User is the UserInfo associated with the provided token.\",\n\t\"error\":         \"Error indicates that the token couldn't be checked\",\n}\n\nfunc (TokenReviewStatus) SwaggerDoc() map[string]string {\n\treturn map_TokenReviewStatus\n}\n\nvar map_UserInfo = map[string]string{\n\t\"\":         \"UserInfo holds the information about the user needed to implement the user.Info interface.\",\n\t\"username\": \"The name that uniquely identifies this user among all active users.\",\n\t\"uid\":      \"A unique value that identifies this user across time. If this user is deleted and another user by the same name is added, they will have different UIDs.\",\n\t\"groups\":   \"The names of groups this user is a part of.\",\n\t\"extra\":    \"Any additional information provided by the authenticator.\",\n}\n\n\n\nfunc (UserInfo) SwaggerDoc() map[string]string ", "output": "{\n\treturn map_UserInfo\n}"}
{"input": "package config\n\nimport (\n\t\"log\"\n\n\t\"github.com/nofdev/fastforward/Godeps/_workspace/src/github.com/alyu/configparser\"\n)\n\n\ntype Configure interface {\n\tLoadConf() (conf *configparser.Configuration)\n}\n\n\ntype Conf struct {\n\tDEFAULT map[string]string\n\tPLAYBACK map[string]string\n}\n\n\nfunc (c *Conf) LoadConf() *Conf {\n\tpath := \"/etc/fastforward/fastforward.conf\"\n\tconf, err := configparser.Read(path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tDefaultSection, err := conf.Section(\"DEFAULT\")\n\tcheckErr(err)\n\n\tPlaybackSection, err := conf.Section(\"PLAYBACK\")\n\tcheckErr(err)\n\n\tFFconf := &Conf{\n\t\tDEFAULT: map[string]string{\"provisioning_driver\": DefaultSection.Options()[\"provisioning_driver\"],\n\t\t\t\"orchestration_driver\": DefaultSection.Options()[\"orchestration_driver\"],\n\t\t\t\"monitoring_driver\":    DefaultSection.Options()[\"monitoring_driver\"]},\n\t\tPLAYBACK: map[string]string{\"use_ansible\": PlaybackSection.Options()[\"use_ansible\"],\n\t\t\t\"ansible_cfg\": PlaybackSection.Options()[\"ansible_cfg\"],\n\t\t\t\"private_key\": PlaybackSection.Options()[\"private_key\"]},\n\t}\n\treturn FFconf\n}\n\n\n\nfunc checkErr(err error) ", "output": "{\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"input": "package http\n\nimport (\n\t\"go-common/app/admin/main/tv/model\"\n\tbm \"go-common/library/net/http/blademaster\"\n)\n\n\n\nfunc mangoAdd(c *bm.Context) {\n\tparam := new(struct {\n\t\tIDs   []int64 `form:\"rids,split\" validate:\"required,min=1,dive,gt=0\"`\n\t\tRType int     `form:\"rtype\" validate:\"required,min=1,max=2\"` \n\t})\n\tif err := c.Bind(param); err != nil {\n\t\treturn\n\t}\n\tc.JSON(tvSrv.MangoAdd(c, param.RType, param.IDs))\n}\n\nfunc mangoEdit(c *bm.Context) {\n\tparam := new(model.ReqMangoEdit)\n\tif err := c.Bind(param); err != nil {\n\t\treturn\n\t}\n\tc.JSON(nil, tvSrv.MangoEdit(c, param))\n}\n\nfunc mangoDel(c *bm.Context) {\n\tparam := new(struct {\n\t\tID int64 `form:\"id\" validate:\"required,min=1,gt=0\"`\n\t})\n\tif err := c.Bind(param); err != nil {\n\t\treturn\n\t}\n\tc.JSON(nil, tvSrv.MangoDel(c, param.ID))\n}\n\nfunc mangoPub(c *bm.Context) {\n\tparam := new(struct {\n\t\tIDs []int64 `form:\"ids,split\" validate:\"required,min=1,dive,gt=0\"`\n\t})\n\tif err := c.Bind(param); err != nil {\n\t\treturn\n\t}\n\tc.JSON(nil, tvSrv.MangoPub(c, param.IDs))\n}\n\nfunc mangoList(c *bm.Context) ", "output": "{\n\tc.JSON(tvSrv.MangoList(c))\n}"}
{"input": "package handler\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/cosiner/zerver\"\n)\n\ntype MethodHandler interface {\n\tGet(zerver.Request, zerver.Response)\n\tPost(zerver.Request, zerver.Response)\n\tDelete(zerver.Request, zerver.Response)\n\tPut(zerver.Request, zerver.Response)\n\tPatch(zerver.Request, zerver.Response)\n}\n\ntype methodHandler struct {\n\tzerver.Component\n\tMethodHandler\n}\n\nfunc WrapMethodHandler(m MethodHandler) zerver.Handler {\n\treturn &methodHandler{\n\t\tComponent:     zerver.NopComponent{},\n\t\tMethodHandler: m,\n\t}\n}\n\n\n\ntype NopMethodHandler struct{}\n\nfunc (NopMethodHandler) Get(_ zerver.Request, resp zerver.Response) {\n\tresp.StatusCode(http.StatusMethodNotAllowed)\n}\n\nfunc (NopMethodHandler) Post(_ zerver.Request, resp zerver.Response) {\n\tresp.StatusCode(http.StatusMethodNotAllowed)\n}\n\nfunc (NopMethodHandler) Delete(_ zerver.Request, resp zerver.Response) {\n\tresp.StatusCode(http.StatusMethodNotAllowed)\n}\n\nfunc (NopMethodHandler) Put(_ zerver.Request, resp zerver.Response) {\n\tresp.StatusCode(http.StatusMethodNotAllowed)\n}\n\nfunc (NopMethodHandler) Patch(_ zerver.Request, resp zerver.Response) {\n\tresp.StatusCode(http.StatusMethodNotAllowed)\n}\n\nfunc (s methodHandler) Handler(method string) zerver.HandleFunc ", "output": "{\n\tswitch method {\n\tcase zerver.METHOD_GET:\n\t\treturn s.Get\n\tcase zerver.METHOD_POST:\n\t\treturn s.Post\n\tcase zerver.METHOD_DELETE:\n\t\treturn s.Delete\n\tcase zerver.METHOD_PUT:\n\t\treturn s.Put\n\tcase zerver.METHOD_PATCH:\n\t\treturn s.Patch\n\t}\n\n\treturn nil\n}"}
{"input": "package quicktemplate\n\nimport (\n\t\"github.com/valyala/bytebufferpool\"\n)\n\n\n\n\n\n\n\ntype ByteBuffer bytebufferpool.ByteBuffer\n\n\nfunc (b *ByteBuffer) Write(p []byte) (int, error) {\n\treturn bb(b).Write(p)\n}\n\n\nfunc (b *ByteBuffer) Reset() {\n\tbb(b).Reset()\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc ReleaseByteBuffer(b *ByteBuffer) {\n\tbyteBufferPool.Put(bb(b))\n}\n\nfunc bb(b *ByteBuffer) *bytebufferpool.ByteBuffer {\n\treturn (*bytebufferpool.ByteBuffer)(b)\n}\n\nvar byteBufferPool bytebufferpool.Pool\n\nfunc AcquireByteBuffer() *ByteBuffer ", "output": "{\n\treturn (*ByteBuffer)(byteBufferPool.Get())\n}"}
{"input": "package progress\n\n\n\nfunc Tee(s1, s2 Sinker) Sinker {\n\tfn := func() chan<- Report {\n\t\td1 := s1.Sink()\n\t\td2 := s2.Sink()\n\t\tu := make(chan Report)\n\t\tgo tee(u, d1, d2)\n\t\treturn u\n\t}\n\n\treturn SinkFunc(fn)\n}\n\n\n\nfunc tee(u <-chan Report, d1, d2 chan<- Report) ", "output": "{\n\tdefer close(d1)\n\tdefer close(d2)\n\n\tfor r := range u {\n\t\td1 <- r\n\t\td2 <- r\n\t}\n}"}
{"input": "package shell\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/chrislusf/seaweedfs/weed/pb\"\n\t\"io\"\n\n\t\"github.com/chrislusf/seaweedfs/weed/storage/needle\"\n)\n\n\n\ntype commandVolumeMark struct {\n}\n\nfunc (c *commandVolumeMark) Name() string {\n\treturn \"volume.mark\"\n}\n\nfunc (c *commandVolumeMark) Help() string {\n\treturn `Mark volume writable or readonly from one volume server\n\n\tvolume.mark -node <volume server host:port> -volumeId <volume id> -writable or -readonly\n`\n}\n\nfunc (c *commandVolumeMark) Do(args []string, commandEnv *CommandEnv, writer io.Writer) (err error) {\n\n\tvolMarkCommand := flag.NewFlagSet(c.Name(), flag.ContinueOnError)\n\tvolumeIdInt := volMarkCommand.Int(\"volumeId\", 0, \"the volume id\")\n\tnodeStr := volMarkCommand.String(\"node\", \"\", \"the volume server <host>:<port>\")\n\twritable := volMarkCommand.Bool(\"writable\", false, \"volume mark writable\")\n\treadonly := volMarkCommand.Bool(\"readonly\", false, \"volume mark readonly\")\n\tif err = volMarkCommand.Parse(args); err != nil {\n\t\treturn nil\n\t}\n\tmarkWritable := false\n\tif (*writable && *readonly) || (!*writable && !*readonly) {\n\t\treturn fmt.Errorf(\"use -readonly or -writable\")\n\t} else if *writable {\n\t\tmarkWritable = true\n\t}\n\n\tif err = commandEnv.confirmIsLocked(args); err != nil {\n\t\treturn\n\t}\n\n\tsourceVolumeServer := pb.ServerAddress(*nodeStr)\n\n\tvolumeId := needle.VolumeId(*volumeIdInt)\n\n\treturn markVolumeWritable(commandEnv.option.GrpcDialOption, volumeId, sourceVolumeServer, markWritable)\n}\n\nfunc init() ", "output": "{\n\tCommands = append(Commands, &commandVolumeMark{})\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n\n\nfunc partition(array []int, p uint, q uint, pivotLocation uint) uint {\n\n\tpivot := array[pivotLocation]\n\tswap(&array[pivotLocation], &array[q])\n\ti := p\n\tfor j := p; j < q; j++ {\n\t\tif array[j] <= pivot {\n\t\t\tswap(&array[i], &array[j])\n\t\t\ti++\n\t\t}\n\t}\n\tswap(&array[q], &array[i])\n\treturn i\n}\n\nfunc quicksort(array []int, start uint, end uint) {\n\tif start < end {\n\t\tpivot := (end + start) / 2\n\t\tr := partition(array, start, end, pivot)\n\t\tif r > start {\n\t\t\tquicksort(array, start, r-1)\n\t\t}\n\t\tquicksort(array, r+1, end)\n\t}\n}\n\nfunc main() {\n\ta1 := make([]int, 100000000)\n\n\tfor i := 0; i < 100000000; i++ {\n\t\ta1[i] = rand.Int()\n\t}\n\n\tfmt.Printf(\"a1[0]: %d, a1[1]: %d, a1[2]: %d\\n\", a1[0], a1[1], a1[2])\n\n\tt0 := time.Now()\n\tquicksort(a1, 0, 100000000-1)\n\tt1 := time.Now()\n\tfmt.Printf(\"n of %v took %v to run.\\n\", len(a1), t1.Sub(t0))\n\tfmt.Printf(\"a1[0]: %d, a1[1]: %d, a1[2]: %d\\n\", a1[0], a1[1], a1[2])\n}\n\nfunc swap(x *int, y *int) ", "output": "{\n\ttemp := *y\n\t*y = *x\n\t*x = temp\n}"}
{"input": "package xapi_test\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/softlayer/xapi-go\"\n)\n\n\n\nfunc TestLogin(t *testing.T) ", "output": "{\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, `<?xml version=\"1.0\"?>\n<methodResponse>\n<params>\n<param>\n<value>\n<struct>\n<member>\n<name>Status</name>\n<value>Success</value>\n</member>\n<member>\n<name>Value</name>\n<value>OpaqueRef:de305d54-75b4-431b-adb2-eb6b9e546013</value>\n</member>\n</struct>\n</value>\n</param>\n</params>\n</methodResponse>`)\n\t}))\n\tdefer ts.Close()\n\n\tx := xapi.NewClient(ts.URL, \"username\", \"password\", \"1.2\")\n\terr := x.Login()\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n}"}
{"input": "package services\n\nimport (\n\t\"log\"\n\n\t\"cjdavis.me/elysium/library\"\n\t\"cjdavis.me/elysium/repositories\"\n)\n\ntype BookService struct {\n}\n\nfunc NewBookService() *BookService {\n\treturn &BookService{}\n}\n\n\n\nfunc (self *BookService) GetBooksByAuthor(authorID int) []library.Book {\n\tbooks, err := repositories.GetBookRepository().GetBooksByAuthor(authorID)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\treturn books\n}\n\nfunc (self *BookService) GetAllBooks() []library.Book ", "output": "{\n\tbooks, err := repositories.GetBookRepository().GetAllBooks()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\treturn books\n}"}
{"input": "package test\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\n\ntype Fixture struct {\n\tName string\n\tPath string\n\tSource string\n}\n\n\nvar Fixtures map[string]Fixture = make(map[string]Fixture)\n\nfunc BuildFixture(name string) Fixture {\n\tif f, ok := Fixtures[name]; ok {\n\t\treturn f\n\t}\n\tparent := \"..\"\n\tfixturesDir := \"_fixtures\"\n\tfor depth := 0; depth < 10; depth++ {\n\t\tif _, err := os.Stat(fixturesDir); err == nil {\n\t\t\tbreak\n\t\t}\n\t\tfixturesDir = filepath.Join(parent, fixturesDir)\n\t}\n\n\tr := make([]byte, 4)\n\trand.Read(r)\n\tpath := filepath.Join(fixturesDir, name+\".go\")\n\ttmpfile := filepath.Join(os.TempDir(), fmt.Sprintf(\"%s.%s\", name, hex.EncodeToString(r)))\n\n\tif err := exec.Command(\"go\", \"build\", \"-gcflags=-N -l\", \"-o\", tmpfile, path).Run(); err != nil {\n\t\tfmt.Printf(\"Error compiling %s: %s\\n\", path, err)\n\t\tos.Exit(1)\n\t}\n\n\tsource, _ := filepath.Abs(path)\n\tFixtures[name] = Fixture{Name: name, Path: tmpfile, Source: source}\n\treturn Fixtures[name]\n}\n\n\n\n\n\nfunc RunTestsWithFixtures(m *testing.M) int ", "output": "{\n\tstatus := m.Run()\n\n\tfor _, f := range Fixtures {\n\t\tos.Remove(f.Path)\n\t}\n\treturn status\n}"}
{"input": "package cwl\n\nimport (\n\t\"github.com/mitchellh/mapstructure\"\n)\n\ntype ShockRequirement struct {\n\tBaseRequirement `bson:\",inline\" yaml:\",inline\" json:\",inline\" `\n\tShock_api_url   string `yaml:\"shock_api_url,omitempty\" bson:\"shock_api_url,omitempty\" json:\"shock_api_url,omitempty\" mapstructure:\"shock_api_url,omitempty\"`\n}\n\nfunc (s ShockRequirement) GetID() string { return \"None\" }\n\nfunc NewShockRequirement(url string) (requirement_ptr *ShockRequirement, err error) {\n\tvar requirement ShockRequirement\n\trequirement.Class = \"ShockRequirement\"\n\trequirement.Shock_api_url = url\n\trequirement_ptr = &requirement\n\treturn\n}\n\n\n\nfunc NewShockRequirementFromInterface(original interface{}) (r *ShockRequirement, err error) ", "output": "{\n\tvar requirement ShockRequirement\n\tr = &requirement\n\terr = mapstructure.Decode(original, &requirement)\n\n\trequirement.Class = \"ShockRequirement\"\n\n\treturn\n}"}
{"input": "package logwriter \n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/fatih/color\"\n)\n\n\ntype Writer struct {\n\tio.Writer\n\n\tLogFile       string\n\tEnableLogging bool\n\tEnableColour  bool\n\tCleanup       func()\n}\n\n\n\n\n\nfunc New(w io.Writer, enableLogging, enableColour bool) *Writer {\n\treturn &Writer{\n\t\tWriter:        w,\n\t\tEnableLogging: enableLogging,\n\t\tEnableColour:  enableColour,\n\t}\n}\n\n\nfunc (w *Writer) Create() error {\n\tcolor.NoColor = !w.EnableColour\n\tif !w.EnableLogging {\n\t\tw.Writer = ioutil.Discard\n\t\tw.Cleanup = func() {}\n\t\treturn nil\n\t}\n\tif w.Writer != nil {\n\t\tw.Cleanup = func() {}\n\t\treturn nil\n\t}\n\tif w.LogFile != \"\" {\n\t\tif f, err := os.Create(w.LogFile); err != nil {\n\t\t\treturn fmt.Errorf(\"Failed to create log file: %s\", err)\n\t\t} else {\n\t\t\tbufWriter := bufio.NewWriter(f)\n\t\t\tw.Writer = bufWriter\n\t\t\tw.Cleanup = func() {\n\t\t\t\tif err := bufWriter.Flush(); err != nil {\n\t\t\t\t\tlog.Printf(\"flush: %s\", err)\n\t\t\t\t}\n\t\t\t\tif err := f.Close(); err != nil {\n\t\t\t\t\tlog.Printf(\"close: %s\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else { \n\t\tw.Writer = os.Stdout\n\t\tw.Cleanup = func() {}\n\t}\n\treturn nil\n}\n\nfunc NewFile(logfile string, enableLogging, enableColour bool) *Writer ", "output": "{\n\treturn &Writer{\n\t\tLogFile:       logfile,\n\t\tEnableLogging: enableLogging,\n\t\tEnableColour:  enableColour,\n\t}\n}"}
{"input": "package healthcheck\n\nimport \"golang.org/x/sys/unix\"\n\n\n\nfunc AvailableDiskSpaceRatio(path string) (float64, error) {\n\ts := unix.Statvfs_t{}\n\terr := unix.Statvfs(path, &s)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn float64(s.Bfree) / float64(s.Blocks), nil\n}\n\n\n\n\n\nfunc AvailableDiskSpace(path string) (uint64, error) ", "output": "{\n\ts := unix.Statvfs_t{}\n\terr := unix.Statvfs(path, &s)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn s.Bavail * uint64(s.Bsize), nil\n}"}
{"input": "package persist\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\n\ntype Database struct {\n\tuser     string\n\tpassword string\n\tdatabase string\n\thost     string\n}\n\n\nfunc NewDatabase(username string, password string, database string, host string) Database {\n\treturn Database{username, password, database, host}\n}\n\n\n\n\nfunc (db Database) getConnection() (*sql.DB, error) {\n\tcon, err := sql.Open(\"mysql\", fmt.Sprintf(\"%v:%v@tcp(%v:3306)/%v?parseTime=true\", db.user, db.password, db.host, db.database))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn con, nil\n}\n\n\nfunc (db Database) GetConnectionString() string {\n\treturn fmt.Sprintf(\"Data Source=%s;Database=%s;User ID=%s;Password=%s;Old Guids=true;\", db.host, db.database, db.user, db.password)\n}\n\nfunc (db Database) TestConnection() error ", "output": "{\n\tcon, err := db.getConnection()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer con.Close()\n\n\terr = con.Ping()\n\treturn err\n}"}
{"input": "package collection\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCollection_Push(t *testing.T) {\n\tcollection := GetCollection().Push(&Model{GrizzlyId: 10, GrizzlyName: \"test\"})\n\n\tassert.Len(t, collection.Items, 5)\n\tassert.Equal(t, collection.Get(4).GrizzlyId, 10)\n}\n\nfunc TestCollection_Pop(t *testing.T) {\n\tcollection := GetCollection()\n\titem := collection.Pop()\n\n\tassert.Equal(t, item.GrizzlyId, 4)\n\tassert.Len(t, collection.Items, 3)\n\tassert.Equal(t, collection.Get(2).GrizzlyId, 3)\n}\n\n\n\nfunc TestCollection_Shift(t *testing.T) {\n\tcollection := GetCollection()\n\titem := collection.Shift()\n\n\tassert.Equal(t, item.GrizzlyId, 1)\n\tassert.Len(t, collection.Items, 3)\n\tassert.Equal(t, collection.Get(2).GrizzlyId, 4)\n}\n\nfunc TestByGrizzlyIdAsc_Len(t *testing.T) {\n\tcollection := GetCollection()\n\n\tassert.Equal(t, collection.Len(), 4)\n\n\tcollection.Shift()\n\n\tassert.Equal(t, collection.Len(), 3)\n}\n\nfunc TestCollection_Unshift(t *testing.T) ", "output": "{\n\tcollection := GetCollection().Unshift(&Model{GrizzlyId: 10, GrizzlyName: \"test\"})\n\n\tassert.Len(t, collection.Items, 5)\n\tassert.Equal(t, collection.Get(0).GrizzlyId, 10)\n}"}
{"input": "package probe_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/minio/mc/pkg/probe\"\n\t. \"gopkg.in/check.v1\"\n)\n\nfunc Test(t *testing.T) { TestingT(t) }\n\ntype MySuite struct{}\n\nvar _ = Suite(&MySuite{})\n\nfunc testDummy0() *probe.Error {\n\t_, e := os.Stat(\"this-file-cannot-exit\")\n\treturn probe.NewError(e)\n}\n\nfunc testDummy1() *probe.Error {\n\treturn testDummy0().Trace(\"DummyTag1\")\n}\n\nfunc testDummy2() *probe.Error {\n\treturn testDummy1().Trace(\"DummyTag2\")\n}\n\nfunc (s *MySuite) TestProbe(c *C) {\n\tprobe.Init() \n\tprobe.SetAppInfo(\"Commit-ID\", \"7390cc957239\")\n\tes := testDummy2().Trace(\"TopOfStack\")\n\tc.Assert(es, Not(Equals), nil)\n\n\tnewES := es.Trace()\n\tc.Assert(newES, Not(Equals), nil)\n}\n\n\n\nfunc (s *MySuite) TestWrappedError(c *C) ", "output": "{\n\t_, e := os.Stat(\"this-file-cannot-exit\")\n\tes := probe.NewError(e) \n\te = probe.WrapError(es) \n\t_, ok := probe.UnwrapError(e)\n\tc.Assert(ok, Equals, true)\n}"}
{"input": "package cache\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"time\"\n)\n\ntype Cache struct {\n\tmemoryCache map[string][]byte\n\trefreshTime int\n}\n\nfunc NewCache(t int) *Cache {\n\treturn &Cache{\n\t\tmemoryCache: make(map[string][]byte),\n\t\trefreshTime: t,\n\t}\n}\n\n\n\nfunc (c *Cache) GetCache(name string) ([]byte, error) {\n\tif dat, ok := c.memoryCache[name]; ok {\n\t\treturn dat, nil\n\t}\n\n\tf, err := os.Stat(\"/tmp/\" + name)\n\tif os.IsNotExist(err) {\n\t\treturn nil, err\n\t}\n\n\tif time.Since(f.ModTime()).Minutes() > float64(c.refreshTime) {\n\t\treturn nil, fmt.Errorf(\"[GetCache] %s\", \"cache invalidate\")\n\t}\n\n\tdat, err := ioutil.ReadFile(\"/tmp/\" + name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn dat, nil\n}\n\nfunc (c *Cache) SetCache(name string, data []byte) error ", "output": "{\n\terr := ioutil.WriteFile(\"/tmp/\"+name, data, 0644)\n\tif err == nil {\n\t\tc.memoryCache[name] = data\n\t}\n\treturn err\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc isHTTPS(r *http.Request) bool {\n\tif r.URL.Scheme == \"https\" {\n\t\treturn true\n\t}\n\tif strings.HasPrefix(r.Proto, \"HTTPS\") {\n\t\treturn true\n\t}\n\tif r.Header.Get(\"X-Forwarded-Proto\") == \"https\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n\nfunc ForceHTTPS(h http.Handler) http.Handler ", "output": "{\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\turl := r.URL\n\t\tif !isHTTPS(r) {\n\t\t\turl.Scheme = \"https\"\n\t\t\turl.Host = r.Host\n\t\t\thttp.Redirect(w, r, url.String(), http.StatusMovedPermanently)\n\t\t\treturn\n\t\t}\n\n\t\th.ServeHTTP(w, r)\n\t})\n}"}
{"input": "package slapi_test\n\nimport (\n\t\"log\"\n\n\tsoftlayer_account \"github.com/sudorandom/softlayer-go-gen/methods/softlayer_account\"\n\tgentypes \"github.com/sudorandom/softlayer-go-gen/types\"\n\tslapi \"github.com/sudorandom/softlayer-go/slapi\"\n)\n\nvar (\n\tusername = \"INSERT_USERNAME\"\n\tapiKey   = \"INSERT_API_KEY\"\n)\n\n\n\n\n\nfunc ExampleClient_Call_customAPICall() {\n\tclient := slapi.Client{\n\t\tEndpoint: \"https://api.softlayer.com/rest/v3.1/\",\n\t\tAuth:     slapi.BasicAuth{Username: username, APIKey: apiKey},\n\t}\n\n\treq := softlayer_account.GetObject()\n\treq.Mask = `mask[id,virtualGuests,companyName]`\n\n\ttype myCustomAccount struct {\n\t\tID          int64  `json:\"id\"`\n\t\tCompanyName string `json:\"companyName\"`\n\n\t\tVirtualGuests []*gentypes.SoftLayer_Virtual_Guest `json:\"virtualGuests\"`\n\t}\n\n\tcustomAccount := &myCustomAccount{}\n\terr := client.Call(req, customAccount)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Println(\"Custom Extended:\")\n\tlog.Println(customAccount.ID)\n\tlog.Println(customAccount.CompanyName)\n\tlog.Println(customAccount.VirtualGuests)\n}\n\nfunc ExampleClient_Call_basicAPICall() ", "output": "{\n\tclient := slapi.Client{\n\t\tEndpoint: \"https://api.softlayer.com/rest/v3.1/\",\n\t\tAuth:     slapi.BasicAuth{Username: username, APIKey: apiKey},\n\t}\n\n\treq := softlayer_account.GetObject()\n\treq.Mask = `mask[id,companyName]`\n\n\tbasicAccount := &gentypes.SoftLayer_Account{}\n\terr := client.Call(req, basicAccount)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Println(\"Basic:\")\n\tlog.Println(basicAccount.Id)\n\tlog.Println(basicAccount.CompanyName)\n}"}
{"input": "package main\n\n\n\n\nfunc nor_ssa(a, b bool) bool {\n\tvar c bool\n\tif a {\n\t\tc = true\n\t}\n\tif b {\n\t\tc = true\n\t}\n\tif c {\n\t\treturn false\n\t}\n\treturn true\n}\n\n\n\nvar failed = false\n\nfunc main() {\n\ttestPhiControl()\n\tif failed {\n\t\tpanic(\"failed\")\n\t}\n}\n\nfunc testPhiControl() ", "output": "{\n\ttests := [...][3]bool{ \n\t\t{false, false, true},\n\t\t{true, false, false},\n\t\t{false, true, false},\n\t\t{true, true, false},\n\t}\n\tfor _, test := range tests {\n\t\ta, b := test[0], test[1]\n\t\tgot := nor_ssa(a, b)\n\t\twant := test[2]\n\t\tif want != got {\n\t\t\tprint(\"nor(\", a, \", \", b, \")=\", want, \" got \", got, \"\\n\")\n\t\t\tfailed = true\n\t\t}\n\t}\n}"}
{"input": "package ftpclient\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\n\ntype Logger interface {\n\tLog(v ...interface{})\n\tLogf(format string, v ...interface{})\n}\n\n\nfunc NewDefaultLogger() Logger {\n\treturn &defaultLogger{\n\t\tlogger: log.New(os.Stdout, \"\", log.LstdFlags),\n\t}\n}\n\ntype defaultLogger struct {\n\tlogger *log.Logger\n}\n\n\n\nfunc (l defaultLogger) Logf(format string, args ...interface{}) {\n\tl.logger.Printf(format, args...)\n}\n\nfunc (l defaultLogger) Log(args ...interface{}) ", "output": "{\n\tl.logger.Println(args...)\n}"}
{"input": "package cmd\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/tsaikd/gogstash/config/goglog\"\n)\n\n\n\nfunc waitSignals(ctx context.Context) error ", "output": "{\n\tosSignalChan := make(chan os.Signal, 1)\n\tsignal.Notify(osSignalChan, os.Interrupt, syscall.SIGTERM)\n\n\tselect {\n\tcase <-ctx.Done():\n\tcase sig := <-osSignalChan:\n\t\tgoglog.Logger.Info(sig)\n\t}\n\treturn nil\n}"}
{"input": "package engine\n\nimport (\n    \"vector\"\n)\n\ntype WorldMap struct {\n    width uint\n    height uint\n    grid [][] *GameChunk\n}\n\nfunc MakeWorldMap(width, height uint) *WorldMap {\n    grid := make([][] *GameChunk, width)\n    for x := range grid {\n        grid[x] = make([]*GameChunk, height)\n    }\n    return &WorldMap {\n        width,\n        height,\n        grid,\n    }\n}\n\n\n\nfunc (wm *WorldMap) GetGameChunk(pos vector.Vector2) *GameChunk {\n    x, y := pos.Values()\n    return wm.grid[x][y]\n}\n\nfunc (wm *WorldMap) SetGameChunk(pos vector.Vector2, gm *GameChunk) ", "output": "{\n    x, y := pos.Values()\n    wm.grid[x][y] = gm\n}"}
{"input": "package labmeasure\n\ntype BodyStat struct {\n\tExamined         int\n\tBothEmpty        int\n\tDiffbotEmpty     int\n\tLabEmpty         int\n\tQualified        int\n\tAcceptable       int\n\tUnacceptable     int\n\tIncorrectRecords []PBodyRecord\n\tTotalRecall      float32\n\tTotalPrecision   float32\n\tConfiguration    Config\n}\n\nfunc (st BodyStat) GetIncorrectRecords() interface{} {\n\treturn st.IncorrectRecords\n}\n\n\n\nfunc (st BodyStat) Incorrect() int {\n\treturn st.Unacceptable + st.DiffbotEmpty + st.LabEmpty\n}\n\nfunc (st BodyStat) Accuracy() float32 {\n\treturn float32(st.Correct()) / float32(st.Examined)\n}\n\nfunc (st BodyStat) AverageRecall() float32 {\n\treturn float32(st.TotalRecall) / float32(st.Qualified)\n}\n\nfunc (st BodyStat) AveragePrecision() float32 {\n\treturn float32(st.TotalPrecision) / float32(st.Qualified)\n}\n\nfunc (st BodyStat) PrecisionThreshold() float32 {\n\treturn st.Configuration.PrecisionThreshold\n}\n\nfunc (st BodyStat) RecallThreshold() float32 {\n\treturn st.Configuration.RecallThreshold\n}\n\nfunc (st BodyStat) Correct() int ", "output": "{\n\treturn st.Acceptable + st.BothEmpty\n}"}
{"input": "package handlers\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\n\tcontr \"github.com/goaltools/contrib/controllers/static\"\n\n\t\"github.com/goaltools/goal/strconv\"\n)\n\n\n\n\n\n\n\nvar Static tStatic\n\n\nvar context = url.Values{}\n\n\ntype tStatic struct {\n}\n\n\n\nfunc (t tStatic) New(w http.ResponseWriter, r *http.Request, ctr, act string) *contr.Static {\n\tc := &contr.Static{}\n\treturn c\n}\n\n\n\nfunc (t tStatic) Before(c *contr.Static, w http.ResponseWriter, r *http.Request) http.Handler {\n\n\treturn nil\n}\n\n\n\nfunc (t tStatic) After(c *contr.Static, w http.ResponseWriter, r *http.Request) (h http.Handler) {\n\n\treturn\n}\n\n\n\n\n\n\n\n\n\nfunc (t tStatic) Serve(w http.ResponseWriter, r *http.Request) {\n\tvar h http.Handler\n\tc := Static.New(w, r, \"Static\", \"Serve\")\n\tdefer func() {\n\t\tif h != nil {\n\t\t\th.ServeHTTP(w, r)\n\t\t}\n\t}()\n\tdefer Static.After(c, w, r)\n\tif res := Static.Before(c, w, r); res != nil {\n\t\th = res\n\t\treturn\n\t}\n\tif res := c.Serve(\n\t\tstrconv.String(r.Form, \"filepath\"),\n\t); res != nil {\n\t\th = res\n\t\treturn\n\t}\n}\n\n\n\n\nfunc Init() (routes []struct {\n\tMethod, Pattern, Label string\n\tHandler                http.HandlerFunc\n}) {\n\n\troutes = append(routes, initStatic()...)\n\n\treturn\n}\n\n\n\nfunc init() {\n\t_ = strconv.MeaningOfLife\n}\n\nfunc initStatic() (rs []struct {\n\tMethod, Pattern, Label string\n\tHandler                http.HandlerFunc\n}) ", "output": "{\n\tcontext.Add(\"Static\", \"Serve\")\n\trs = append(rs, []struct {\n\t\tMethod, Pattern, Label string\n\t\tHandler                http.HandlerFunc\n\t}{\n\t\t{\n\t\t\tMethod:  \"GET\",\n\t\t\tPattern: \"/*filepath\",\n\t\t\tLabel:   \"\",\n\t\t\tHandler: Static.Serve,\n\t\t},\n\t}...)\n\treturn\n}"}
{"input": "package models\n\nimport (\n\t\"sync\"\n\n\t\"github.com/eaciit/orm\"\n)\n\ntype FuelTransport struct {\n\tsync.RWMutex\n\torm.ModelBase `bson:\"-\" json:\"-\"`\n\tPlant         string  `bson:\"Plant\" json:\"Plant\"`\n\tYear          int     `bson:\"Year\" json:\"Year\"`\n\tTransportCost float64 `bson:\"TransportCost\" json:\"TransportCost\"`\n}\n\n\n\nfunc (m *FuelTransport) TableName() string ", "output": "{\n\treturn \"FuelTransport\"\n}"}
{"input": "package features\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\n\n\n\nfunc Version() string {\n\treturn version.Number\n}\n\nfunc UserAgent() string ", "output": "{\n\treturn \"Azure-SDK-For-Go/\" + Version() + \" features/2021-07-01\"\n}"}
{"input": "package bgp\n\nconst (\n\tEVPN_ROUTE_TYPE_ETHERNET_AUTO_DISCOVERY = 1\n\tEVPN_ROUTE_TYPE_MAC_IP_ADVERTISEMENT    = 2\n\tEVPN_INCLUSIVE_MULTICAST_ETHERNET_TAG   = 3\n\tEVPN_ETHERNET_SEGMENT_ROUTE             = 4\n\tEVPN_IP_PREFIX                          = 5\n)\n\ntype EvpnRouteTypeInterface interface {\n\tDecodeFromBytes([]byte) error\n}\n\ntype EvpnNlri struct {\n\tRouteType     uint8\n\tLength        uint8\n\tRouteTypeData EvpnRouteTypeInterface\n}\n\n\n\nfunc (n *EvpnNlri) Serialize() ([]byte, error) {\n\treturn nil, nil\n}\n\ntype RouteDistinguisherInterface interface {\n\tDecodeFromBytes([]byte) error\n\tSerialize() ([]byte, error)\n\tLen() int\n\tString() string\n\tMarshalJSON() ([]byte, error)\n}\n\ntype EsiType uint8\n\nconst (\n\tESI_ARBITRARY EsiType = iota\n\tESI_LACP\n\tESI_MSTP\n\tESI_MAC\n\tESI_ROUTERID\n\tESI_AS\n)\n\ntype EthernetSegmentIdentifier struct {\n\tType  EsiType\n\tValue []byte\n}\n\ntype EvpnEthernetAutoDiscoveryRoute struct {\n\tRd    RouteDistinguisherInterface\n\tEsi   EthernetSegmentIdentifier\n\tEtag  uint32\n\tLabel uint32\n}\n\nfunc (e *EvpnEthernetAutoDiscoveryRoute) DecodeFromBytes([]byte) error {\n\treturn nil\n}\n\nfunc (n *EvpnNlri) DecodeFromBytes(data []byte) error ", "output": "{\n\tn.RouteType = data[0]\n\tn.Length = data[1]\n\tdata = data[2:]\n\n\tvar rdata EvpnRouteTypeInterface\n\tswitch n.RouteType {\n\tcase EVPN_ROUTE_TYPE_ETHERNET_AUTO_DISCOVERY:\n\t\trdata = &EvpnEthernetAutoDiscoveryRoute{}\n\tcase EVPN_ROUTE_TYPE_MAC_IP_ADVERTISEMENT:\n\tcase EVPN_INCLUSIVE_MULTICAST_ETHERNET_TAG:\n\tcase EVPN_ETHERNET_SEGMENT_ROUTE:\n\tcase EVPN_IP_PREFIX:\n\tdefault:\n\t}\n\trdata.DecodeFromBytes(data)\n\treturn nil\n}"}
{"input": "package ldp\n\nimport \"testing\"\n\n\n\nfunc Test_maxProfit4(t *testing.T) ", "output": "{\n\tinput := [][]int{[]int{7, 1, 5, 3, 6, 4}, []int{1, 2, 1, 2, 4, 2, 5, 3}}\n\tresult := []int{7, 6}\n\n\tfor i := 0; i < len(input); i++ {\n\t\tif r := maxProfit4(2, input[i]); r != result[i] {\n\t\t\tt.Fatal(input[i], r, \"Expected:\", result[i])\n\t\t}\n\t}\n}"}
{"input": "package mcquery_test\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/sean-callahan/mcquery\"\n)\n\n\n\nfunc ExampleMcQuery_GetStatus() {\n\tmcq, err := mcquery.Dial(\"127.0.0.1:25565\", time.Second)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tstatus, _, err := mcq.GetStatus()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(status[\"game_id\"])\n}\n\nfunc ExampleDial() ", "output": "{\n\t_, err := mcquery.Dial(\"127.0.0.1:25565\", time.Second)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"input": "package spinc_test\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/square/spincycle/v2/spinc\"\n\t\"github.com/square/spincycle/v2/spinc/app\"\n)\n\n\n\nfunc TestArgsHelpCommand(t *testing.T) {\n\tctx := app.Context{\n\t\tIn:        os.Stdin,\n\t\tOut:       &bytes.Buffer{},\n\t\tHooks:     app.Hooks{},\n\t\tFactories: app.Factories{},\n\t}\n\tos.Args = []string{\"spinc\", \"--help\"}\n\terr := spinc.Run(ctx)\n\tif err != app.ErrHelp {\n\t\tt.Errorf(\"got error '%v', expected ErrHelp\", err)\n\t}\n}\n\nfunc TestArgsNoCommand(t *testing.T) ", "output": "{\n\tctx := app.Context{\n\t\tIn:        os.Stdin,\n\t\tOut:       &bytes.Buffer{},\n\t\tHooks:     app.Hooks{},\n\t\tFactories: app.Factories{},\n\t}\n\tos.Args = []string{\"spinc\", \"--env\", \"staging\", \"--addr\", \"http://localhost\"}\n\terr := spinc.Run(ctx)\n\tif err != app.ErrHelp {\n\t\tt.Errorf(\"got error '%v', expected ErrHelp\", err)\n\t}\n}"}
{"input": "package janitor\n\nimport (\n\t\"errors\"\n\t\"math\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/youtube/vitess/go/vt/wrangler\"\n)\n\n\n\ntype testJanitor struct {\n\trun       func(bool) error\n\tconfigure func(wr *wrangler.Wrangler, keyspace, shard string) error\n}\n\nfunc (janitor *testJanitor) Configure(wr *wrangler.Wrangler, keyspace, shard string) error {\n\treturn janitor.configure(wr, keyspace, shard)\n}\n\nfunc (janitor *testJanitor) Run(active bool) error {\n\treturn janitor.run(active)\n}\n\nfunc newTestJanitor() *testJanitor {\n\treturn &testJanitor{\n\t\trun: func(bool) error { return nil },\n\t\tconfigure: func(wr *wrangler.Wrangler, keyspace, shard string) error {\n\t\t\treturn nil\n\t\t},\n\t}\n}\n\nfunc aroundSameDuration(d1, d2, delta time.Duration) bool {\n\treturn math.Abs(float64(d1-d2)) < float64(delta)\n}\n\nfunc TestJanitorInfo(t *testing.T) {\n\tjan := newJanitorInfo(nil)\n\tjan.RecordSuccess(time.Now().Add(-10 * time.Second))\n\tjan.RecordSuccess(time.Now().Add(-20 * time.Second))\n\tjan.RecordSuccess(time.Now().Add(-30 * time.Second))\n\n\tif got, want := jan.AverageRuntime(), 20*time.Second; !aroundSameDuration(want, got, 500*time.Millisecond) {\n\t\tt.Errorf(\"jan.AverageRuntime: want %v, got %v\", want, got)\n\t}\n}\n\n\n\nfunc TestRunJanitor(t *testing.T) ", "output": "{\n\tscheduler, _ := New(\"a\", \"a\", nil, nil, 0)\n\tjan := newTestJanitor()\n\tji := newJanitorInfo(jan)\n\tscheduler.janitors[\"test\"] = ji\n\n\tscheduler.runJanitor(\"test\")\n\n\tif ji.Runs() != 1 {\n\t\tt.Errorf(\"jan.Runs: want 1, got %v\", ji.Runs())\n\t}\n\n\tif ji.ErrorCount() != 0 {\n\t\tt.Errorf(\"ji.ErrorCount: want 0, got %v\", ji.ErrorCount())\n\t}\n\n\tjan.run = func(bool) error {\n\t\treturn errors.New(\"error\")\n\t}\n\n\tscheduler.runJanitor(\"test\")\n\n\tif ji.ErrorCount() != 1 {\n\t\tt.Errorf(\"ji.ErrorCount: want 0, got %v\", ji.ErrorCount())\n\t}\n\n}"}
{"input": "package v1\n\nimport (\n\t\"testing\"\n\n\t\"github.com/rackspace/gophercloud\"\n\t\"github.com/rackspace/gophercloud/rackspace/lb/v1/lbs\"\n\t\"github.com/rackspace/gophercloud/rackspace/lb/v1/monitors\"\n\tth \"github.com/rackspace/gophercloud/testhelper\"\n)\n\n\n\nfunc getMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\thm, err := monitors.Get(client, lbID).Extract()\n\tth.AssertNoErr(t, err)\n\tt.Logf(\"Health monitor for LB %d: Type [%s] Delay [%d] Timeout [%d] AttemptLimit [%d]\",\n\t\tlbID, hm.Type, hm.Delay, hm.Timeout, hm.AttemptLimit)\n}\n\nfunc updateMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\topts := monitors.UpdateHTTPMonitorOpts{\n\t\tAttemptLimit: 3,\n\t\tDelay:        10,\n\t\tTimeout:      10,\n\t\tBodyRegex:    \"hello is it me you're looking for\",\n\t\tPath:         \"/foo\",\n\t\tStatusRegex:  \"200\",\n\t\tType:         monitors.HTTP,\n\t}\n\n\terr := monitors.Update(client, lbID, opts).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Updated monitor for LB %d\", lbID)\n}\n\nfunc deleteMonitor(t *testing.T, client *gophercloud.ServiceClient, lbID int) {\n\terr := monitors.Delete(client, lbID).ExtractErr()\n\tth.AssertNoErr(t, err)\n\n\twaitForLB(client, lbID, lbs.ACTIVE)\n\tt.Logf(\"Deleted monitor for LB %d\", lbID)\n}\n\nfunc TestMonitors(t *testing.T) ", "output": "{\n\tclient := setup(t)\n\n\tids := createLB(t, client, 1)\n\tlbID := ids[0]\n\n\tgetMonitor(t, client, lbID)\n\n\tupdateMonitor(t, client, lbID)\n\n\tdeleteMonitor(t, client, lbID)\n\n\tdeleteLB(t, client, lbID)\n}"}
{"input": "package api\n\nimport (\n\t\"errors\"\n\t\"os/user\"\n)\n\nconst (\n\tcountOfColumnsInGroup = 3\n\n\tnameColumnNumberInGroup = 0\n\n\tpasswordFlagColumnNumberInGroup = 1\n\n\tgidColumnNumberInGroup = 2\n\n\tusersColumnNumberInGroup = 3\n)\n\nfunc (linux *Linux) groupLookup(groupName string) (*user.Group, error) {\n\tgroupInfo, err := linux.getEntity(\"group\", groupName)\n\n\tif err != nil {\n\t\treturn nil, user.UnknownGroupError(groupName)\n\t}\n\n\tif len(groupInfo) < countOfColumnsInGroup {\n\t\treturn nil, errors.New(\"Wrong format of /etc/group\")\n\t}\n\n\tgroup := user.Group{\n\t\tGid:  groupInfo[gidColumnNumberInGroup],\n\t\tName: groupInfo[nameColumnNumberInGroup],\n\t}\n\n\treturn &group, err\n}\n\nfunc (linux *Linux) groupLookupByID(groupID string) (*user.Group, error) {\n\tgroupInfo, err := linux.getEntity(\"group\", groupID)\n\n\tif err != nil {\n\t\treturn nil, user.UnknownGroupIdError(groupID)\n\t}\n\n\tif len(groupInfo) < countOfColumnsInGroup {\n\t\treturn nil, errors.New(\"Wrong format of /etc/group\")\n\t}\n\n\tgroup := user.Group{\n\t\tGid:  groupInfo[gidColumnNumberInGroup],\n\t\tName: groupInfo[nameColumnNumberInGroup],\n\t}\n\n\treturn &group, err\n}\n\n\n\n\nfunc (linux *Linux) groupExistsByID(groupID string) bool {\n\tgroup, _ := linux.groupLookupByID(groupID)\n\treturn group != nil\n}\n\nfunc (linux *Linux) GroupExists(groupName string) bool ", "output": "{\n\tgroup, _ := linux.groupLookup(groupName)\n\treturn group != nil\n}"}
{"input": "package rlp\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype MyCoolType struct {\n\tName string\n\ta, b uint\n}\n\n\n\n\nfunc ExampleEncoder() {\n\tvar t *MyCoolType \n\tbytes, _ := EncodeToBytes(t)\n\tfmt.Printf(\"%v → %X\\n\", t, bytes)\n\n\tt = &MyCoolType{Name: \"foobar\", a: 5, b: 6}\n\tbytes, _ = EncodeToBytes(t)\n\tfmt.Printf(\"%v → %X\\n\", t, bytes)\n\n}\n\nfunc (x *MyCoolType) EncodeRLP(w io.Writer) (err error) ", "output": "{\n\treturn Encode(w, []uint{x.a, x.b})\n}"}
{"input": "package convert\n\n\n\nfunc Union(s []string, a []string) []string {\n\tfor _, entry := range a {\n\t\tfound := false\n\t\tfor _, existing := range s {\n\t\t\tif entry == existing {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\ts = append(s, entry)\n\t\t}\n\t}\n\treturn s\n}\n\nfunc Uniq(s []string) (r []string) {\n\tfor _, entry := range s {\n\t\tfound := false\n\t\tfor _, existing := range r {\n\t\t\tif existing == entry {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tr = append(r, entry)\n\t\t}\n\t}\n\treturn\n}\n\nfunc Add(s []string, a string) []string ", "output": "{\n\tfor _, existing := range s {\n\t\tif a == existing {\n\t\t\treturn s\n\t\t}\n\t}\n\treturn append(s, a)\n}"}
{"input": "package goosinfo\n\nimport (\n    \"io/ioutil\"\n    \"strings\"\n    \"os\"\n    \"fmt\"\n    \"syscall\"\n)\n\ntype OSRelease struct {\n    Name string\n    PrettyName string\n    Version string\n    VersionID string\n    ID string\n}\n\nfunc uname_chars_to_string(ca [65]int8) string {\n    s := make([]byte, len(ca))\n    var lens int\n    for ; lens < len(ca); lens++ {\n        if ca[lens] == 0 {\n            break\n        }\n        s[lens] = uint8(ca[lens])\n    }\n    return string(s[0:lens])\n}\n\n\n\nfunc read_os_release () (*OSRelease, error) {\n    file, err := os.Open(\"/etc/os-release\")\n    if err != nil {\n        return nil, err\n    }\n    c, err := ioutil.ReadAll(file)\n    if err != nil {\n        return nil, err\n    }\n    file.Close()\n    return parse_os_release(string(c))\n}\n\nfunc get_kernel_version_uname() (string, error) {\n    uts := syscall.Utsname{}\n    err := syscall.Uname(&uts)\n    if err != nil {\n        return \"\", fmt.Errorf(\"Could not get Linux version\")\n    }\n    y, _ := read_os_release()\n    fmt.Println(y)\n    return uname_chars_to_string(uts.Release), nil\n}\n\nfunc GetOSVersion() (string, error) {\n    osr, err := read_os_release()\n    if err != nil {\n        kver, err := get_kernel_version_uname()\n        if err != nil {\n            return \"\", err\n        }\n        return kver, nil\n    }\n    return osr.Version, nil\n}\n\nfunc parse_os_release (contents string) (*OSRelease, error) ", "output": "{\n    osr := OSRelease{}\n    contents = strings.TrimSpace(contents)\n    lines := strings.Split(contents, \"\\n\")\n    for _, line := range(lines) {\n        spl := strings.Split(line, \"=\")\n        k := strings.ToUpper(spl[0])\n        v := strings.Trim(spl[1], \"\\\"\")\n        if k == \"NAME\" {\n            osr.Name = v\n        } else if k == \"PRETTY_NAME\" {\n            osr.PrettyName = v\n        } else if k == \"VERSION\" {\n            osr.Version = v\n        } else if k == \"VERSION_ID\" {\n            osr.VersionID = v\n        } else if k == \"ID\" {\n            osr.ID = v\n        }\n    }\n    return &osr, nil\n}"}
{"input": "package fs\n\nimport (\n\t\"testing\"\n\n\t\"github.com/chzyer/test\"\n)\n\n\n\nfunc TestMagic(t *testing.T) ", "output": "{\n\tdefer test.New(t)\n\ttest.Equal(MagicInode.String(), \"Inode\")\n\ttest.Equal(Magic((&[4]byte{})[:]).String(), \"unknown: 00000000\")\n}"}
{"input": "package circular\n\nimport (\n\t\"errors\"\n)\n\n\ntype Buffer struct {\n\tsize        int    \n\tn           int    \n\tdata        []byte \n\twrite, read int    \n}\n\n\nfunc NewBuffer(size int) *Buffer {\n\n\treturn &Buffer{\n\t\tsize: size,\n\t\tdata: make([]byte, size),\n\t}\n}\n\n\nfunc (b *Buffer) ReadByte() (byte, error) {\n\tif b.n == 0 {\n\t\treturn 0, errors.New(\"no bytes read\")\n\t}\n\td := b.data[b.read]\n\tb.read = (b.read + 1) % b.size\n\tb.n--\n\treturn d, nil\n}\n\n\nfunc (b *Buffer) WriteByte(c byte) error {\n\tif b.write == b.read && b.n > 0 {\n\t\treturn errors.New(\"buffer is full\")\n\t}\n\tb.Overwrite(c)\n\treturn nil\n}\n\n\n\n\n\nfunc (b *Buffer) Reset() {\n\t*b = Buffer{\n\t\tsize: b.size,\n\t\tdata: make([]byte, b.size),\n\t}\n}\n\nfunc (b *Buffer) Overwrite(c byte) ", "output": "{\n\tif b.read == b.write && b.n > 0 {\n\t\tb.read = (b.read + 1) % b.size\n\t\tb.n--\n\t}\n\tb.data[b.write] = c\n\tb.write = (b.write + 1) % b.size\n\tb.n++\n}"}
{"input": "package gtka\n\nimport (\n\t\"github.com/twstrike/coyim/Godeps/_workspace/src/github.com/gotk3/gotk3/gtk\"\n\t\"github.com/twstrike/coyim/Godeps/_workspace/src/github.com/twstrike/gotk3adapter/gtki\"\n)\n\ntype box struct {\n\t*container\n\tinternal *gtk.Box\n}\n\n\n\nfunc wrapBox(v *gtk.Box, e error) (*box, error) {\n\treturn wrapBoxSimple(v), e\n}\n\nfunc unwrapBox(v gtki.Box) *gtk.Box {\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn v.(*box).internal\n}\n\nfunc (v *box) PackEnd(v1 gtki.Widget, v2, v3 bool, v4 uint) {\n\tv.internal.PackEnd(unwrapWidget(v1), v2, v3, v4)\n}\n\nfunc (v *box) PackStart(v1 gtki.Widget, v2, v3 bool, v4 uint) {\n\tv.internal.PackStart(unwrapWidget(v1), v2, v3, v4)\n}\n\nfunc (v *box) SetChildPacking(v1 gtki.Widget, v2, v3 bool, v4 uint, v5 gtki.PackType) {\n\tv.internal.SetChildPacking(unwrapWidget(v1), v2, v3, v4, gtk.PackType(v5))\n}\n\nfunc wrapBoxSimple(v *gtk.Box) *box ", "output": "{\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn &box{wrapContainerSimple(&v.Container), v}\n}"}
{"input": "package store\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/Sirupsen/logrus\"\n\t\"github.com/go-chat/gochat/apperror\"\n\t\"github.com/go-chat/gochat/model\"\n)\n\ntype MessageStore struct {\n\t*Store\n}\n\nfunc NewMessageStore(store *Store) *MessageStore {\n\treturn &MessageStore{store}\n}\n\n\n\nfunc (gs *MessageStore) Save(message *model.Message) *apperror.AppError ", "output": "{\n\tif err := gs.SQLStore.Create(message).Error; err != nil {\n\t\tlogrus.Errorf(\"cannot store message, err = %v\", err)\n\t\treturn apperror.NewAppError(err, \"cannot store message\", http.StatusInternalServerError)\n\t}\n\n\treturn nil\n}"}
{"input": "package automanage\n\n\n\n\n\n\n\n\ntype ActionType string\n\nconst (\n\tActionTypeInternal ActionType = \"Internal\"\n)\n\n\n\n\n\ntype CreatedByType string\n\nconst (\n\tCreatedByTypeApplication CreatedByType = \"Application\"\n\tCreatedByTypeKey CreatedByType = \"Key\"\n\tCreatedByTypeManagedIdentity CreatedByType = \"ManagedIdentity\"\n\tCreatedByTypeUser CreatedByType = \"User\"\n)\n\n\nfunc PossibleCreatedByTypeValues() []CreatedByType {\n\treturn []CreatedByType{CreatedByTypeApplication, CreatedByTypeKey, CreatedByTypeManagedIdentity, CreatedByTypeUser}\n}\n\n\ntype Origin string\n\nconst (\n\tOriginSystem Origin = \"system\"\n\tOriginUser Origin = \"user\"\n\tOriginUsersystem Origin = \"user,system\"\n)\n\n\nfunc PossibleOriginValues() []Origin {\n\treturn []Origin{OriginSystem, OriginUser, OriginUsersystem}\n}\n\nfunc PossibleActionTypeValues() []ActionType ", "output": "{\n\treturn []ActionType{ActionTypeInternal}\n}"}
{"input": "package controller_test\n\nimport \"testing\"\n\n\n\n\n\nfunc AssertNotNil(t *testing.T, actualValue interface{}) {\n\tif actualValue == nil {\n\t\tt.Errorf(\"\\n got: %v\\ndidn't want: %v\", actualValue, nil)\n\t}\n}\n\nfunc AssertEqual(t *testing.T, actualValue interface{}, expectedValue interface{}) ", "output": "{\n\tif actualValue != expectedValue {\n\t\tt.Errorf(\"\\n got: %v\\nwant: %v\", actualValue, expectedValue)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/djthorpe/gopi/v3\"\n\n\t_ \"github.com/djthorpe/gopi/v3/pkg/dev/chromecast\"\n\t_ \"github.com/djthorpe/gopi/v3/pkg/event\"\n\t_ \"github.com/djthorpe/gopi/v3/pkg/log\"\n\t_ \"github.com/djthorpe/gopi/v3/pkg/mdns\"\n)\n\n\n\n\ntype app struct {\n\tgopi.Unit\n\tgopi.Logger\n\tgopi.CastManager\n\tgopi.Publisher\n}\n\n\n\n\n\n\nfunc (this *app) Run(ctx context.Context) error ", "output": "{\n\tthis.Require(this.Logger, this.CastManager)\n\n\tctx2, cancel := context.WithTimeout(ctx, time.Second)\n\tdefer cancel()\n\tif devices, err := this.Devices(ctx2); err != nil {\n\t\treturn err\n\t} else {\n\t\tfmt.Println(devices)\n\t}\n\n\tch := this.Subscribe()\n\tdefer this.Unsubscribe(ch)\n\n\tfmt.Println(\"Press CTRL+C to end\")\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tcase evt := <-ch:\n\t\t\tif evt, ok := evt.(gopi.CastEvent); ok {\n\t\t\t\tfmt.Println(evt)\n\t\t\t}\n\t\t}\n\t}\n}"}
{"input": "package lines\n\nimport \"github.com/ts2/ts2-sim-server/simulation\"\n\n\ntype StandardManager struct{}\n\n\n\n\n\nfunc (sm StandardManager) Name() string {\n\treturn \"Standard Manager\"\n}\n\nvar _ simulation.LineItemManager = StandardManager{}\n\nfunc init() {\n\tsimulation.RegisterLineItemManager(StandardManager{})\n}\n\nfunc (sm StandardManager) IsFailed(p *simulation.LineItem) bool ", "output": "{\n\treturn false\n}"}
{"input": "package filestorage\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n)\n\n\ntype MountTargetSummary struct {\n\n\tCompartmentId *string `mandatory:\"true\" json:\"compartmentId\"`\n\n\tDisplayName *string `mandatory:\"true\" json:\"displayName\"`\n\n\tId *string `mandatory:\"true\" json:\"id\"`\n\n\tLifecycleState MountTargetSummaryLifecycleStateEnum `mandatory:\"true\" json:\"lifecycleState\"`\n\n\tPrivateIpIds []string `mandatory:\"true\" json:\"privateIpIds\"`\n\n\tSubnetId *string `mandatory:\"true\" json:\"subnetId\"`\n\n\tTimeCreated *common.SDKTime `mandatory:\"true\" json:\"timeCreated\"`\n\n\tAvailabilityDomain *string `mandatory:\"false\" json:\"availabilityDomain\"`\n\n\tExportSetId *string `mandatory:\"false\" json:\"exportSetId\"`\n}\n\n\n\n\ntype MountTargetSummaryLifecycleStateEnum string\n\n\nconst (\n\tMountTargetSummaryLifecycleStateCreating MountTargetSummaryLifecycleStateEnum = \"CREATING\"\n\tMountTargetSummaryLifecycleStateActive   MountTargetSummaryLifecycleStateEnum = \"ACTIVE\"\n\tMountTargetSummaryLifecycleStateDeleting MountTargetSummaryLifecycleStateEnum = \"DELETING\"\n\tMountTargetSummaryLifecycleStateDeleted  MountTargetSummaryLifecycleStateEnum = \"DELETED\"\n\tMountTargetSummaryLifecycleStateFailed   MountTargetSummaryLifecycleStateEnum = \"FAILED\"\n)\n\nvar mappingMountTargetSummaryLifecycleState = map[string]MountTargetSummaryLifecycleStateEnum{\n\t\"CREATING\": MountTargetSummaryLifecycleStateCreating,\n\t\"ACTIVE\":   MountTargetSummaryLifecycleStateActive,\n\t\"DELETING\": MountTargetSummaryLifecycleStateDeleting,\n\t\"DELETED\":  MountTargetSummaryLifecycleStateDeleted,\n\t\"FAILED\":   MountTargetSummaryLifecycleStateFailed,\n}\n\n\nfunc GetMountTargetSummaryLifecycleStateEnumValues() []MountTargetSummaryLifecycleStateEnum {\n\tvalues := make([]MountTargetSummaryLifecycleStateEnum, 0)\n\tfor _, v := range mappingMountTargetSummaryLifecycleState {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}\n\nfunc (m MountTargetSummary) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package certificates\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gophercloud/gophercloud\"\n)\n\n\n\ntype CreateOptsBuilder interface {\n\tToCertificateCreateMap() (map[string]interface{}, error)\n}\n\n\ntype CreateOpts struct {\n\tClusterUUID string `json:\"cluster_uuid,omitempty\" xor:\"BayUUID\"`\n\tBayUUID     string `json:\"bay_uuid,omitempty\" xor:\"ClusterUUID\"`\n\tCSR         string `json:\"csr\" required:\"true\"`\n}\n\n\nfunc (opts CreateOpts) ToCertificateCreateMap() (map[string]interface{}, error) {\n\treturn gophercloud.BuildRequestBody(opts, \"\")\n}\n\n\nfunc Get(client *gophercloud.ServiceClient, clusterID string) (r GetResult) {\n\turl := getURL(client, clusterID)\n\n\t_, r.Err = client.Get(url, &r.Body, &gophercloud.RequestOpts{\n\t\tOkCodes: []int{200},\n\t})\n\n\treturn\n}\n\n\n\n\n\nfunc Update(client *gophercloud.ServiceClient, clusterID string) (r UpdateResult) {\n\t_, r.Err = client.Patch(updateURL(client, clusterID), nil, &r.Body, &gophercloud.RequestOpts{\n\t\tOkCodes: []int{202},\n\t})\n\n\treturn\n}\n\nfunc Create(client *gophercloud.ServiceClient, opts CreateOptsBuilder) (r CreateResult) ", "output": "{\n\tb, err := opts.ToCertificateCreateMap()\n\tif err != nil {\n\t\tr.Err = err\n\t\treturn\n\t}\n\n\tvar result *http.Response\n\tresult, r.Err = client.Post(createURL(client), b, &r.Body, &gophercloud.RequestOpts{\n\t\tOkCodes: []int{201},\n\t})\n\n\tif r.Err == nil {\n\t\tr.Header = result.Header\n\t}\n\n\treturn\n}"}
{"input": "package processor_test\n\nimport (\n\t\"github.com/google/webpackager/exchange\"\n\t\"github.com/google/webpackager/processor\"\n)\n\n\n\nfunc newTestingProcessor(value string) processor.Processor {\n\treturn &testingProcessor{value}\n}\n\ntype testingProcessor struct {\n\tvalue string\n}\n\nfunc (p *testingProcessor) Process(resp *exchange.Response) error {\n\tresp.Header.Add(\"X-Testing\", p.value)\n\treturn nil\n}\n\n\nfunc newFailingProcessor(err error) processor.Processor {\n\treturn &failingProcessor{err}\n}\n\ntype failingProcessor struct {\n\terr error\n}\n\n\n\nfunc (p *failingProcessor) Process(resp *exchange.Response) error ", "output": "{\n\treturn p.err\n}"}
{"input": "package AbstractFactory\n\nimport (\n\t\"fmt\"\n)\n\n\ntype BaseFactory interface {\n\tProduction(text *string)\n}\n\ntype CreatorFactory interface {\n\tCreateText() BaseFactory\n}\n\ntype JsonFactory struct {\n}\n\ntype HtmlFactory struct {\n}\n\ntype Result struct {\n}\n\nfunc (r *Result) Production(text *string) {\n\tfmt.Printf(\"依赖于抽象而不依赖于具体 %v\", *text)\n}\n\n\n\nfunc (H *HtmlFactory) CreateText() BaseFactory {\n\treturn new(Result)\n}\n\nfunc (J *JsonFactory) CreateText() BaseFactory ", "output": "{\n\treturn new(Result)\n}"}
{"input": "package connect\n\nimport (\n\t\"github.com/LilyPad/GoLilyPad/packet\"\n\t\"io\"\n)\n\ntype PacketRedirectEvent struct {\n\tServer string\n\tPlayer string\n}\n\nfunc NewPacketRedirectEvent(server string, player string) (this *PacketRedirectEvent) {\n\tthis = new(PacketRedirectEvent)\n\tthis.Server = server\n\tthis.Player = player\n\treturn\n}\n\nfunc (this *PacketRedirectEvent) Id() int {\n\treturn PACKET_REDIRECT_EVENT\n}\n\ntype packetRedirectEventCodec struct {\n}\n\n\n\nfunc (this *packetRedirectEventCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\n\tpacketRedirectEvent := encode.(*PacketRedirectEvent)\n\terr = packet.WriteString(writer, packetRedirectEvent.Server)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = packet.WriteString(writer, packetRedirectEvent.Player)\n\treturn\n}\n\nfunc (this *packetRedirectEventCodec) Decode(reader io.Reader) (decode packet.Packet, err error) ", "output": "{\n\tpacketRedirectEvent := new(PacketRedirectEvent)\n\tpacketRedirectEvent.Server, err = packet.ReadString(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\tpacketRedirectEvent.Player, err = packet.ReadString(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\tdecode = packetRedirectEvent\n\treturn\n}"}
{"input": "package coinbasepro\n\nimport (\n\t\"fmt\"\n)\n\ntype WithdrawalCrypto struct {\n\tCurrency      string `json:\"currency\"`\n\tAmount        string `json:\"amount\"`\n\tCryptoAddress string `json:\"crypto_address\"`\n}\n\ntype WithdrawalCoinbase struct {\n\tCurrency          string `json:\"currency\"`\n\tAmount            string `json:\"amount\"`\n\tCoinbaseAccountID string `json:\"coinbase_account_id\"`\n}\n\nfunc (c *Client) CreateWithdrawalCrypto(newWithdrawalCrypto *WithdrawalCrypto) (WithdrawalCrypto, error) {\n\tvar savedWithdrawal WithdrawalCrypto\n\turl := fmt.Sprintf(\"/withdrawals/crypto\")\n\t_, err := c.Request(\"POST\", url, newWithdrawalCrypto, &savedWithdrawal)\n\treturn savedWithdrawal, err\n}\n\n\n\nfunc (c *Client) CreateWithdrawalCoinbase(newWithdrawalCoinbase *WithdrawalCoinbase) (WithdrawalCoinbase, error) ", "output": "{\n\tvar savedWithdrawal WithdrawalCoinbase\n\turl := fmt.Sprintf(\"/withdrawals/coinbase-account\")\n\t_, err := c.Request(\"POST\", url, newWithdrawalCoinbase, &savedWithdrawal)\n\treturn savedWithdrawal, err\n}"}
{"input": "package wutil\n\n\n\nfunc GetIntFromMap(m map[string]interface{}, k string) int {\n\tvar i int\n\n\tv, ok := m[k]\n\n\tif ok {\n\t\ti = v.(int)\n\t}\n\n\treturn i\n}\n\nfunc GetStringFromMap(m map[string]interface{}, k string) string {\n\tvar s string\n\n\tv, ok := m[k]\n\n\tif ok {\n\t\ts = v.(string)\n\t}\n\n\treturn s\n}\n\nfunc GetMapFromMap(m map[string]interface{}, k string) map[string]interface{} {\n\tvar m2 map[string]interface{}\n\n\tv, ok := m[k]\n\n\tif ok {\n\t\tm2 = v.(map[string]interface{})\n\t}\n\n\treturn m2\n}\n\nfunc GetFloat64FromMap(m map[string]interface{}, k string) float64 ", "output": "{\n\tvar f float64\n\n\tv, ok := m[k]\n\n\tif ok {\n\t\tf = v.(float64)\n\t}\n\n\treturn f\n}"}
{"input": "package main\n\nimport \"github.com/augustoroman/serial_lcd\"\n\ntype FakeLcd struct{}\n\nfunc (f FakeLcd) SetBG(r, g, b uint8) error      { return nil }\nfunc (f FakeLcd) SetOn(On bool) error            { return nil }\nfunc (f FakeLcd) SetBrightness(b uint8) error    { return nil }\n\nfunc (f FakeLcd) SetAutoscroll(On bool) error    { return nil }\nfunc (f FakeLcd) SetSize(cols, rows uint8) error { return nil }\nfunc (f FakeLcd) Clear() error                   { return nil }\nfunc (f FakeLcd) Home() error                    { return nil }\nfunc (f FakeLcd) MoveTo(col, row uint8) error    { return nil }\nfunc (f FakeLcd) MoveForward() error             { return nil }\nfunc (f FakeLcd) MoveBack() error                { return nil }\nfunc (f FakeLcd) Write(b []byte) (int, error)    { return len(b), nil }\n\nfunc (f FakeLcd) CreateCustomChar(spot uint8, c serial_lcd.Char) error { return nil }\n\nfunc (f FakeLcd) SetContrast(c uint8) error      ", "output": "{ return nil }"}
{"input": "package core\n\nimport (\n\t\"container/list\"\n\t\"fmt\"\n\n\t\"github.com/soilcurrency/go-ethereum/core/types\"\n\n\t\"github.com/soilcurrency/go-ethereum/ethdb\"\n\t\"github.com/soilcurrency/go-ethereum/event\"\n)\n\n\ntype TestManager struct {\n\teventMux *event.TypeMux\n\n\tdb         ethdb.Database\n\ttxPool     *TxPool\n\tblockChain *BlockChain\n\tBlocks     []*types.Block\n}\n\nfunc (s *TestManager) IsListening() bool {\n\treturn false\n}\n\nfunc (s *TestManager) IsMining() bool {\n\treturn false\n}\n\nfunc (s *TestManager) PeerCount() int {\n\treturn 0\n}\n\n\n\nfunc (s *TestManager) BlockChain() *BlockChain {\n\treturn s.blockChain\n}\n\nfunc (tm *TestManager) TxPool() *TxPool {\n\treturn tm.txPool\n}\n\n\n\n\n\nfunc (tm *TestManager) EventMux() *event.TypeMux {\n\treturn tm.eventMux\n}\n\n\n\n\n\nfunc (tm *TestManager) Db() ethdb.Database {\n\treturn tm.db\n}\n\nfunc NewTestManager() *TestManager {\n\tdb, err := ethdb.NewMemDatabase()\n\tif err != nil {\n\t\tfmt.Println(\"Could not create mem-db, failing\")\n\t\treturn nil\n\t}\n\n\ttestManager := &TestManager{}\n\ttestManager.eventMux = new(event.TypeMux)\n\ttestManager.db = db\n\n\treturn testManager\n}\n\nfunc (s *TestManager) Peers() *list.List ", "output": "{\n\treturn list.New()\n}"}
{"input": "package protocol\n\nimport \"fmt\"\n\ntype Compression int\n\nconst (\n\tCompressMetadata Compression = iota \n\tCompressNever\n\tCompressAlways\n\n\tcompressionThreshold = 128 \n)\n\nvar compressionMarshal = map[Compression]string{\n\tCompressNever:    \"never\",\n\tCompressMetadata: \"metadata\",\n\tCompressAlways:   \"always\",\n}\n\nvar compressionUnmarshal = map[string]Compression{\n\t\"false\": CompressNever,\n\t\"true\":  CompressMetadata,\n\n\t\"never\":    CompressNever,\n\t\"metadata\": CompressMetadata,\n\t\"always\":   CompressAlways,\n}\n\nfunc (c Compression) String() string {\n\ts, ok := compressionMarshal[c]\n\tif !ok {\n\t\treturn fmt.Sprintf(\"unknown:%d\", c)\n\t}\n\treturn s\n}\n\nfunc (c Compression) GoString() string {\n\treturn fmt.Sprintf(\"%q\", c.String())\n}\n\nfunc (c Compression) MarshalText() ([]byte, error) {\n\treturn []byte(compressionMarshal[c]), nil\n}\n\n\n\nfunc (c *Compression) UnmarshalText(bs []byte) error ", "output": "{\n\t*c = compressionUnmarshal[string(bs)]\n\treturn nil\n}"}
{"input": "package problems\n\nimport \"fmt\"\n\nfunc numTrees(n int) int {\n\tdp := make([]int, n + 1)\n\n\tdp[0] = 1\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tdp[i] += dp[j] * dp[i - 1 - j]\n\t\t}\n\t}\n\n\treturn dp[n]\n}\n\n\n\nfunc NumTrees() ", "output": "{\n\tfmt.Printf(\"<096> \")\n\tfmt.Println(numTrees(3))\n}"}
{"input": "package vanity\n\nimport (\n\t\"github.com/gogo/protobuf/gogoproto\"\n\t\"github.com/gogo/protobuf/proto\"\n\tdescriptor \"github.com/gogo/protobuf/protoc-gen-gogo/descriptor\"\n)\n\nfunc FieldHasBoolExtension(field *descriptor.FieldDescriptorProto, extension *proto.ExtensionDesc) bool {\n\tif field.Options == nil {\n\t\treturn false\n\t}\n\tvalue, err := proto.GetExtension(field.Options, extension)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif value == nil {\n\t\treturn false\n\t}\n\tif value.(*bool) == nil {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc SetBoolFieldOption(extension *proto.ExtensionDesc, value bool) func(field *descriptor.FieldDescriptorProto) {\n\treturn func(field *descriptor.FieldDescriptorProto) {\n\t\tif FieldHasBoolExtension(field, extension) {\n\t\t\treturn\n\t\t}\n\t\tif field.Options == nil {\n\t\t\tfield.Options = &descriptor.FieldOptions{}\n\t\t}\n\t\tif err := proto.SetExtension(field.Options, extension, &value); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc TurnOffNullable(field *descriptor.FieldDescriptorProto) {\n\tif field.IsRepeated() && !field.IsMessage() {\n\t\treturn\n\t}\n\tSetBoolFieldOption(gogoproto.E_Nullable, false)(field)\n}\n\n\n\nfunc TurnOffNullableForNativeTypesWithoutDefaultsOnly(field *descriptor.FieldDescriptorProto) ", "output": "{\n\tif field.IsRepeated() || field.IsMessage() {\n\t\treturn\n\t}\n\tif field.DefaultValue != nil {\n\t\treturn\n\t}\n\tSetBoolFieldOption(gogoproto.E_Nullable, false)(field)\n}"}
{"input": "package syscall\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Getpagesize() int { return 4096 }\n\nfunc Gettimeofday(tv *Timeval) (err error)\nfunc Time(t *Time_t) (tt Time_t, err error)\n\nfunc TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }\n\nfunc NsecToTimespec(nsec int64) (ts Timespec) {\n\tts.Sec = nsec / 1e9\n\tts.Nsec = nsec % 1e9\n\treturn\n}\n\nfunc TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }\n\n\n\nfunc (r *PtraceRegs) PC() uint64 { return r.Rip }\n\nfunc (r *PtraceRegs) SetPC(pc uint64) { r.Rip = pc }\n\nfunc (iov *Iovec) SetLen(length int) {\n\tiov.Len = uint64(length)\n}\n\nfunc (msghdr *Msghdr) SetControllen(length int) {\n\tmsghdr.Controllen = uint64(length)\n}\n\nfunc (cmsg *Cmsghdr) SetLen(length int) {\n\tcmsg.Len = uint64(length)\n}\n\nfunc NsecToTimeval(nsec int64) (tv Timeval) ", "output": "{\n\tnsec += 999 \n\ttv.Sec = nsec / 1e9\n\ttv.Usec = nsec % 1e9 / 1e3\n\treturn\n}"}
{"input": "package itertools\n\nimport (\n\t\"reflect\"\n)\n\ntype Pair struct {\n\tFirst  interface{}\n\tSecond interface{}\n}\n\nfunc unpack(pairVal, ptr interface{}) {\n\tptrVal := reflect.ValueOf(ptr)\n\tptrElem := ptrVal.Elem()\n\tptrElem.Set(reflect.ValueOf(pairVal))\n\tptr = ptrElem.Interface()\n}\n\n\n\nfunc PairUnPack(pair Pair, first, second interface{}) ", "output": "{\n\tunpack(pair.First, first)\n\tunpack(pair.Second, second)\n}"}
{"input": "package mapd\n\nimport (\n\t. \"common\"\n\t\"fmt\"\n\t\"net\"\n\t\"rpc\"\n)\n\ntype MapdConnection struct {\n\tBinaryConnection\n\trpcEncoder rpc.RPCEncoder\n\trpcDecoder rpc.RPCDecoder\n}\n\nfunc NewMapdConnection(conn net.Conn) MapdConnection {\n\tbinaryConn := NewBinaryConnection(conn)\n\tmapdCon := MapdConnection{BinaryConnection: binaryConn}\n\tmapdCon.rpcEncoder = rpc.NewCustomRPCEncoder(mapdCon)\n\tmapdCon.rpcDecoder = rpc.NewCustomRPCDecoder(mapdCon)\n\treturn mapdCon\n}\n\nfunc (self *MapdConnection) RecvCmd() (byte, error) {\n\tb, err := self.RecvByte()\n\treturn b, err\n}\n\nfunc (self *MapdConnection) SendCmd(cmd byte) error {\n\treturn self.SendByte(cmd)\n}\n\n\n\nfunc (self *MapdConnection) RecvReplyOk() error {\n\tb, err := self.RecvByte()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif b != REPLY_OK {\n\t\treturn fmt.Errorf(\"expect REPLY_OK but received %v\", b)\n\t}\n\treturn nil\n}\n\nfunc (self *MapdConnection) SendRPC(eid Eid, method string, args []interface{}) error {\n\treturn self.rpcEncoder.Encode(string(eid), method, args)\n}\n\nfunc (self *MapdConnection) RecvRPC(eid *Eid, method *string, args *[]interface{}) error {\n\treturn self.rpcDecoder.Decode((*string)(eid), method, args)\n}\n\nfunc (self *MapdConnection) SendPid(pid int) error {\n\treturn self.SendUint16(uint16(pid))\n}\n\nfunc (self *MapdConnection) RecvPid() (int, error) {\n\tv, err := self.RecvUint16()\n\treturn int(v), err\n}\n\nfunc (self *MapdConnection) SendReplyOk() error ", "output": "{\n\treturn self.SendByte(REPLY_OK)\n}"}
{"input": "package virtualboxclient\n\nimport (\n\t\"github.com/appropriate/go-virtualboxclient/vboxwebsrv\"\n)\n\ntype StorageController struct {\n\tvirtualbox      *VirtualBox\n\tmanagedObjectId string\n}\n\n\n\nfunc (sc *StorageController) GetPortCount() (uint32, error) {\n\trequest := vboxwebsrv.IStorageControllergetPortCount{This: sc.managedObjectId}\n\n\tresponse, err := sc.virtualbox.IStorageControllergetPortCount(&request)\n\tif err != nil {\n\t\treturn 0, err \n\t}\n\n\treturn response.Returnval, nil\n}\n\nfunc (sc *StorageController) GetName() (string, error) ", "output": "{\n\trequest := vboxwebsrv.IStorageControllergetName{This: sc.managedObjectId}\n\n\tresponse, err := sc.virtualbox.IStorageControllergetName(&request)\n\tif err != nil {\n\t\treturn \"\", err \n\t}\n\n\treturn response.Returnval, nil\n}"}
{"input": "package pongo2_ext\n\nimport (\n\t\"io/ioutil\"\n\n\t\"gopkg.in/flosch/pongo2.v3\"\n)\n\nfunc init() {\n\tpongo2.RegisterFilter(\"read\", filterRead)\n}\n\n\n\nfunc filterRead(in *pongo2.Value, param *pongo2.Value) (*pongo2.Value, *pongo2.Error) ", "output": "{\n\tdata, err := ioutil.ReadFile(in.String())\n\tif err != nil {\n\t\treturn nil, &pongo2.Error{\n\t\t\tSender:   \"filter:read\",\n\t\t\tErrorMsg: err.Error(),\n\t\t}\n\t}\n\n\treturn pongo2.AsSafeValue(string(data)), nil\n}"}
{"input": "package iso20022\n\n\ntype MiFIDClassification1 struct {\n\n\tClassification *OrderOriginatorEligibility1Code `xml:\"Clssfctn\"`\n\n\tNarrative *Max350Text `xml:\"Nrrtv,omitempty\"`\n}\n\n\n\nfunc (m *MiFIDClassification1) SetNarrative(value string) {\n\tm.Narrative = (*Max350Text)(&value)\n}\n\nfunc (m *MiFIDClassification1) SetClassification(value string) ", "output": "{\n\tm.Classification = (*OrderOriginatorEligibility1Code)(&value)\n}"}
{"input": "package ut4updater\n\n\n\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\nfunc CopyFile(source string, dest string) (err error) {\n\tsourcefile, err := os.Open(source)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer sourcefile.Close()\n\n\tdestfile, err := os.Create(dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer destfile.Close()\n\n\t_, err = io.Copy(destfile, sourcefile)\n\tif err == nil {\n\t\tsourceinfo, err := os.Stat(source)\n\t\tif err != nil {\n\t\t\tos.Chmod(dest, sourceinfo.Mode())\n\t\t}\n\t}\n\treturn\n}\n\n\n\n\nfunc CopyDir(source string, dest string) (err error) ", "output": "{\n\n\tsourceinfo, err := os.Stat(source)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = os.MkdirAll(dest, sourceinfo.Mode())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdirectory, _ := os.Open(source)\n\n\tobjects, err := directory.Readdir(-1)\n\tfor _, obj := range objects {\n\t\tsourcefilepointer := filepath.Join(source, obj.Name())\n\t\tdestinationfilepointer := filepath.Join(dest, obj.Name())\n\t\tif obj.IsDir() {\n\t\t\terr = CopyDir(sourcefilepointer, destinationfilepointer)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t}\n\t\t} else {\n\t\t\terr = CopyFile(sourcefilepointer, destinationfilepointer)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t}\n\t\t}\n\n\t}\n\treturn\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ListCrossConnectLocationsRequest struct {\n\n\tCompartmentId *string `mandatory:\"true\" contributesTo:\"query\" name:\"compartmentId\"`\n\n\tLimit *int `mandatory:\"false\" contributesTo:\"query\" name:\"limit\"`\n\n\tPage *string `mandatory:\"false\" contributesTo:\"query\" name:\"page\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\n\n\n\nfunc (request ListCrossConnectLocationsRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request ListCrossConnectLocationsRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request ListCrossConnectLocationsRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ListCrossConnectLocationsResponse struct {\n\n\tRawResponse *http.Response\n\n\tItems []CrossConnectLocation `presentIn:\"body\"`\n\n\tOpcNextPage *string `presentIn:\"header\" name:\"opc-next-page\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response ListCrossConnectLocationsResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response ListCrossConnectLocationsResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request ListCrossConnectLocationsRequest) String() string ", "output": "{\n\treturn common.PointerString(request)\n}"}
{"input": "package log15\n\nimport (\n\t\"sync/atomic\"\n\t\"unsafe\"\n)\n\n\n\ntype swapHandler struct {\n\thandler unsafe.Pointer\n}\n\nfunc (h *swapHandler) Log(r *Record) error {\n\treturn (*(*Handler)(atomic.LoadPointer(&h.handler))).Log(r)\n}\n\n\n\nfunc (h *swapHandler) Swap(newHandler Handler) ", "output": "{\n\tatomic.StorePointer(&h.handler, unsafe.Pointer(&newHandler))\n}"}
{"input": "package visualization_model\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/swag\"\n)\n\n\n\ntype APIVisualization struct {\n\n\tArguments string `json:\"arguments,omitempty\"`\n\n\tError string `json:\"error,omitempty\"`\n\n\tHTML string `json:\"html,omitempty\"`\n\n\tSource string `json:\"source,omitempty\"`\n\n\tType APIVisualizationType `json:\"type,omitempty\"`\n}\n\n\nfunc (m *APIVisualization) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateType(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n\n\n\nfunc (m *APIVisualization) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\nfunc (m *APIVisualization) UnmarshalBinary(b []byte) error {\n\tvar res APIVisualization\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *APIVisualization) validateType(formats strfmt.Registry) error ", "output": "{\n\n\tif swag.IsZero(m.Type) { \n\t\treturn nil\n\t}\n\n\tif err := m.Type.Validate(formats); err != nil {\n\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\treturn ve.ValidateName(\"type\")\n\t\t}\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package pdf\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"testing\"\n)\n\n\n\nfunc TestDownload(t *testing.T) ", "output": "{\n\tcmd := getPdfCommand(\"www.github.com\")\n\tdat, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\tlog.Fatal(\"could not get ouput\", err)\n\t\tt.Fail()\n\t}\n\tfmt.Print(\"got all this data!?\", dat)\n}"}
{"input": "package main \n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"golang.org/x/net/html\"\n)\n\nvar Counts = make(map[string]int)\n\n\n\nfunc main(){\n\tdoc, err := html.Parse(os.Stdin)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"outline: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\toutline(nil, doc)\n\tfmt.Printf(\"str\\tcount\\n\")\n\tfor s, n := range Counts {\n\t\tfmt.Printf(\"%s\\t%d\", s, n)\n\t}\n}\n\nfunc outline(stack []string, n *html.Node) ", "output": "{\n\tif n.Type == html.ElementNode {\n\t\tstack = append(stack, n.Data)\n\t\tif strings.Contains(n.Data, \"p\") {\n\t\t\tCounts[\"p\"]++\n\t\t} \n\t\tif strings.Contains(n.Data, \"div\") {\n\t\t\tCounts[\"div\"]++\n\t\t}\n\t\tif strings.Contains(n.Data, \"span\") {\n\t\t\tCounts[\"span\"]++\n\t\t}\n\t\tfmt.Println(stack)\n\t}\n\n\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\toutline(stack, c)\n\t}\n}"}
{"input": "package azidentity\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy\"\n)\n\nfunc TestUsernamePasswordCredential_InvalidTenantID(t *testing.T) {\n\tcred, err := NewUsernamePasswordCredential(badTenantID, fakeClientID, \"username\", \"password\", nil)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error but received none\")\n\t}\n\tif cred != nil {\n\t\tt.Fatalf(\"Expected a nil credential value. Received: %v\", cred)\n\t}\n}\n\nfunc TestUsernamePasswordCredential_GetTokenSuccess(t *testing.T) {\n\tcred, err := NewUsernamePasswordCredential(fakeTenantID, fakeClientID, \"username\", \"password\", nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\tcred.client = fakePublicClient{}\n\t_, err = cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif err != nil {\n\t\tt.Fatalf(\"Expected an empty error but received: %s\", err.Error())\n\t}\n}\n\nfunc TestUsernamePasswordCredential_Live(t *testing.T) {\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, liveUser.password, &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttestGetTokenSuccess(t, cred)\n}\n\n\n\nfunc TestUsernamePasswordCredential_InvalidPasswordLive(t *testing.T) ", "output": "{\n\to, stop := initRecording(t)\n\tdefer stop()\n\topts := UsernamePasswordCredentialOptions{ClientOptions: o}\n\tcred, err := NewUsernamePasswordCredential(liveUser.tenantID, developerSignOnClientID, liveUser.username, \"invalid password\", &opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to create credential. Received: %v\", err)\n\t}\n\ttk, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{Scopes: []string{liveTestScope}})\n\tif tk != nil {\n\t\tt.Fatal(\"GetToken returned a token\")\n\t}\n\tvar e AuthenticationFailedError\n\tif !errors.As(err, &e) {\n\t\tt.Fatal(\"expected AuthenticationFailedError\")\n\t}\n\tif e.RawResponse == nil {\n\t\tt.Fatal(\"expected a non-nil RawResponse\")\n\t}\n}"}
{"input": "package influx\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"log\"\n\n\t\"github.com/influxdata/telegraf\"\n)\n\n\ntype reader struct {\n\tmetrics    []telegraf.Metric\n\tserializer *Serializer\n\toffset     int\n\tbuf        *bytes.Buffer\n}\n\n\nfunc NewReader(metrics []telegraf.Metric, serializer *Serializer) io.Reader {\n\treturn &reader{\n\t\tmetrics:    metrics,\n\t\tserializer: serializer,\n\t\toffset:     0,\n\t\tbuf:        bytes.NewBuffer(make([]byte, 0, serializer.maxLineBytes)),\n\t}\n}\n\n\n\n\n\n\n\n\n\n\nfunc (r *reader) Read(p []byte) (int, error) {\n\tif r.buf.Len() > 0 {\n\t\treturn r.buf.Read(p)\n\t}\n\n\tif r.offset >= len(r.metrics) {\n\t\treturn 0, io.EOF\n\t}\n\n\tfor _, metric := range r.metrics[r.offset:] {\n\t\t_, err := r.serializer.Write(r.buf, metric)\n\t\tr.offset += 1\n\t\tif err != nil {\n\t\t\tr.buf.Reset()\n\t\t\tif _, ok := err.(*MetricError); ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlog.Printf(\"E! [serializers.influx] could not serialize metric: %v; discarding metric\", err)\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\treturn r.buf.Read(p)\n}\n\nfunc (r *reader) SetMetrics(metrics []telegraf.Metric) ", "output": "{\n\tr.metrics = metrics\n\tr.offset = 0\n\tr.buf.Reset()\n}"}
{"input": "package conv\n\nimport (\n\t\"reflect\"\n)\n\n\n\nfunc UintPtrTo64(ptr interface{}) (value uint64) {\n\tif v := reflect.ValueOf(ptr); v.Kind() == reflect.Ptr {\n\t\tp := v.Elem()\n\t\tswitch p.Kind() {\n\t\tcase reflect.Uint:\n\t\t\tvalue = uint64(*ptr.(*uint))\n\t\tcase reflect.Uint8:\n\t\t\tvalue = uint64(*ptr.(*uint8))\n\t\tcase reflect.Uint16:\n\t\t\tvalue = uint64(*ptr.(*uint16))\n\t\tcase reflect.Uint32:\n\t\t\tvalue = uint64(*ptr.(*uint32))\n\t\tcase reflect.Uint64:\n\t\t\tvalue = *ptr.(*uint64)\n\t\t}\n\t}\n\treturn\n}\n\nfunc IntPtrTo64(ptr interface{}) (value int64) ", "output": "{\n\tif v := reflect.ValueOf(ptr); v.Kind() == reflect.Ptr {\n\t\tp := v.Elem()\n\t\tswitch p.Kind() {\n\t\tcase reflect.Int:\n\t\t\tvalue = int64(*ptr.(*int))\n\t\tcase reflect.Int8:\n\t\t\tvalue = int64(*ptr.(*int8))\n\t\tcase reflect.Int16:\n\t\t\tvalue = int64(*ptr.(*int16))\n\t\tcase reflect.Int32:\n\t\t\tvalue = int64(*ptr.(*int32))\n\t\tcase reflect.Int64:\n\t\t\tvalue = *ptr.(*int64)\n\t\t}\n\t}\n\treturn\n}"}
{"input": "package conf\n\nimport (\n\t\"errors\"\n\t\"github.com/spf13/viper\"\n)\n\nfunc ReadConfig(filename string) error {\n\n\tviper.SetConfigFile(filename)\n\terr := viper.ReadInConfig()\n\tif err != nil {\n\t\treturn errors.New(err.Error() + (\"Fatal error in config file.\"))\n\t}\n\treturn nil\n}\n\n\n\nfunc GetBoolValue(key string) bool {\n\treturn viper.GetBool(key)\n}\n\nfunc GetIntValue(key string) int {\n\treturn viper.GetInt(key)\n}\n\nfunc GetStringArrayValue(key string) []string {\n\treturn viper.GetStringSlice(key)\n}\n\nfunc GetStringMapString(key string) map[string]string {\n\treturn viper.GetStringMapString(key)\n}\n\nfunc GetStringValue(key string) string ", "output": "{\n\treturn viper.GetString(key)\n}"}
{"input": "package console\n\nimport \"github.com/cgrates/cgrates/engine\"\n\nfunc init() {\n\tc := &CmdGetSharedGroup{\n\t\tname:      \"sharedgroup\",\n\t\trpcMethod: \"ApierV1.GetSharedGroup\",\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}\n\n\ntype CmdGetSharedGroup struct {\n\tname      string\n\trpcMethod string\n\trpcParams *StringWrapper\n\t*CommandExecuter\n}\n\nfunc (self *CmdGetSharedGroup) Name() string {\n\treturn self.name\n}\n\n\n\nfunc (self *CmdGetSharedGroup) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &StringWrapper{}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *CmdGetSharedGroup) PostprocessRpcParams() error {\n\treturn nil\n}\n\nfunc (self *CmdGetSharedGroup) RpcResult() interface{} {\n\treturn &engine.SharedGroup{}\n}\n\nfunc (self *CmdGetSharedGroup) RpcMethod() string ", "output": "{\n\treturn self.rpcMethod\n}"}
{"input": "package singularity\n\n\n\nfunc (client *Client) Start() (err error) ", "output": "{\n\tpathParamMap := map[string]interface{}{}\n\n\tqueryParamMap := map[string]interface{}{}\n\n\t_, err = client.Request(\"POST\", \"/api/test/start\", pathParamMap, queryParamMap)\n\n\treturn\n}"}
{"input": "package chiron_test\n\nimport (\n\t\"testing\"\n\n\t\"istio.io/istio/pkg/test/framework\"\n\t\"istio.io/istio/pkg/test/framework/components/istio\"\n\t\"istio.io/istio/pkg/test/framework/label\"\n\t\"istio.io/istio/pkg/test/framework/resource\"\n)\n\nvar inst istio.Instance\n\nfunc TestMain(m *testing.M) {\n\tframework.NewSuite(m).\n\t\tLabel(label.CustomSetup).\n\t\tRequireMaxVersion(21).\n\t\tRequireMultiPrimary().\n\t\tSetup(istio.Setup(&inst, setupConfig)).\n\t\tRun()\n}\n\n\n\nfunc setupConfig(_ resource.Context, cfg *istio.Config) ", "output": "{\n\tif cfg == nil {\n\t\treturn\n\t}\n\n\tcfg.ControlPlaneValues = `\nvalues:\n  meshConfig:\n    certificates:\n      - dnsNames: [istio-pilot.istio-system.svc, istio-pilot.istio-system]\n      - secretName: dns.istio-galley-service-account\n        dnsNames: [istio-galley.istio-system.svc, istio-galley.istio-system]\n      - secretName: dns.istio-sidecar-injector-service-account\n        dnsNames: [istio-sidecar-injector.istio-system.svc, istio-sidecar-injector.istio-system]\n`\n}"}
{"input": "package client\n\nimport (\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/api\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/labels\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/watch\"\n)\n\n\n\ntype FakeReplicationControllers struct {\n\tFake      *Fake\n\tNamespace string\n}\n\nfunc (c *FakeReplicationControllers) List(selector labels.Selector) (*api.ReplicationControllerList, error) {\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"list-controllers\"})\n\treturn api.Scheme.CopyOrDie(&c.Fake.CtrlList).(*api.ReplicationControllerList), nil\n}\n\n\n\nfunc (c *FakeReplicationControllers) Create(controller *api.ReplicationController) (*api.ReplicationController, error) {\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"create-controller\", Value: controller})\n\treturn &api.ReplicationController{}, nil\n}\n\nfunc (c *FakeReplicationControllers) Update(controller *api.ReplicationController) (*api.ReplicationController, error) {\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"update-controller\", Value: controller})\n\treturn &api.ReplicationController{}, nil\n}\n\nfunc (c *FakeReplicationControllers) Delete(controller string) error {\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"delete-controller\", Value: controller})\n\treturn nil\n}\n\nfunc (c *FakeReplicationControllers) Watch(label, field labels.Selector, resourceVersion string) (watch.Interface, error) {\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"watch-controllers\", Value: resourceVersion})\n\treturn c.Fake.Watch, nil\n}\n\nfunc (c *FakeReplicationControllers) Get(name string) (*api.ReplicationController, error) ", "output": "{\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"get-controller\", Value: name})\n\treturn api.Scheme.CopyOrDie(&c.Fake.Ctrl).(*api.ReplicationController), nil\n}"}
{"input": "package serverrpc\n\nimport (\n\t\"github.com/hyperhq/hyperd/types\"\n\t\"golang.org/x/net/context\"\n)\n\n\n\n\nfunc (s *ServerRPC) TTYResize(c context.Context, req *types.TTYResizeRequest) (*types.TTYResizeResponse, error) ", "output": "{\n\terr := s.daemon.TtyResize(req.ContainerID, req.ExecID, int(req.Height), int(req.Width))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &types.TTYResizeResponse{}, nil\n}"}
{"input": "package terms\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n)\n\ntype URI struct {\n}\n\nfunc NewURI() *URI {\n\tret := &URI{}\n\treturn ret\n}\n\nfunc (m *URI) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tstart.Name.Local = \"URI\"\n\te.EncodeToken(start)\n\te.EncodeToken(xml.EndElement{Name: start.Name})\n\treturn nil\n}\n\n\n\n\nfunc (m *URI) Validate() error {\n\treturn m.ValidateWithPath(\"URI\")\n}\n\n\nfunc (m *URI) ValidateWithPath(path string) error {\n\treturn nil\n}\n\nfunc (m *URI) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error ", "output": "{\n\tfor {\n\t\ttok, err := d.Token()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing URI: %s\", err)\n\t\t}\n\t\tif el, ok := tok.(xml.EndElement); ok && el.Name == start.Name {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package stringutil\n\nimport \"testing\"\n\n\n\nfunc TestSetSuffix(t *testing.T) {\n\ttests := []struct {\n\t\toriginal string\n\t\tsuffix   string\n\t\texpected string\n\t}{\n\t\t{\"Go\", \"\", \"Go\"},\n\t\t{\"\", \"pher\", \"pher\"},\n\t\t{\"Go\", \"pher\", \"Gopher\"},\n\t\t{\"Gopher\", \"pher\", \"Gopher\"},\n\t\t{\"Gopherpher\", \"pher\", \"Gopherpher\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tret := SetSuffix(test.original, test.suffix)\n\t\tif ret != test.expected {\n\t\t\tt.Errorf(\"Expected: %s, Got: %s\\n\", test.expected, ret)\n\t\t}\n\t}\n}\n\nfunc TestSetPrefix(t *testing.T) ", "output": "{\n\ttests := []struct {\n\t\toriginal string\n\t\tprefix   string\n\t\texpected string\n\t}{\n\t\t{\"Ford Prefect\", \"\", \"Ford Prefect\"},\n\t\t{\"\", \"Mr.\", \"Mr.\"},\n\t\t{\"Ford Prefect\", \"Mr. \", \"Mr. Ford Prefect\"},\n\t\t{\"Mr. Ford Prefect\", \"Mr. \", \"Mr. Ford Prefect\"},\n\t\t{\"Mr. Mr. Ford Prefect\", \"Mr. \", \"Mr. Mr. Ford Prefect\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tret := SetPrefix(test.original, test.prefix)\n\t\tif ret != test.expected {\n\t\t\tt.Errorf(\"Expected: %s, Got: %s\\n\", test.expected, ret)\n\t\t}\n\t}\n}"}
{"input": "package base58_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/roasbeef/btcutil/base58\"\n)\n\n\nfunc ExampleDecode() {\n\tencoded := \"25JnwSn7XKfNQ\"\n\tdecoded := base58.Decode(encoded)\n\n\tfmt.Println(\"Decoded Data:\", string(decoded))\n\n}\n\n\n\n\n\n\nfunc ExampleCheckDecode() {\n\tencoded := \"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa\"\n\tdecoded, version, err := base58.CheckDecode(encoded)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Decoded data: %x\\n\", decoded)\n\tfmt.Println(\"Version Byte:\", version)\n\n}\n\n\n\nfunc ExampleCheckEncode() {\n\tdata := []byte(\"Test data\")\n\tencoded := base58.CheckEncode(data, 0)\n\n\tfmt.Println(\"Encoded Data:\", encoded)\n\n}\n\nfunc ExampleEncode() ", "output": "{\n\tdata := []byte(\"Test data\")\n\tencoded := base58.Encode(data)\n\n\tfmt.Println(\"Encoded Data:\", encoded)\n\n}"}
{"input": "package translators_test\n\nimport (\n\t\"github.com/gobuffalo/pop/fizz\"\n\t\"github.com/gobuffalo/pop/fizz/translators\"\n)\n\nfunc (s *SchemaSuite) buildSchema() translators.Schema {\n\tschema := map[string]*fizz.Table{}\n\tta := &fizz.Table{Name: \"testTable\"}\n\tta.Column(\"testColumn\", \"type\", nil)\n\tta.Indexes = append(ta.Indexes, fizz.Index{Name: \"testIndex\"})\n\tschema[\"testTable\"] = ta\n\treturn translators.CreateSchema(\"name\", \"url\", schema)\n}\n\nfunc (s *SchemaSuite) Test_Schema_TableInfo() {\n\tr := s.Require()\n\tts := s.buildSchema()\n\tt, err := ts.TableInfo(\"testTable\")\n\tr.NoError(err)\n\tr.Equal(\"testTable\", t.Name)\n}\n\n\n\nfunc (s *SchemaSuite) Test_Schema_IndexInfo() {\n\tr := s.Require()\n\tts := s.buildSchema()\n\tc, err := ts.IndexInfo(\"testTable\", \"testindEX\")\n\tr.NoError(err)\n\tr.Equal(\"testIndex\", c.Name)\n}\n\nfunc (s *SchemaSuite) Test_Schema_ColumnInfo() ", "output": "{\n\tr := s.Require()\n\tts := s.buildSchema()\n\tc, err := ts.ColumnInfo(\"testTable\", \"testCOLUMN\")\n\tr.NoError(err)\n\tr.Equal(\"testColumn\", c.Name)\n}"}
{"input": "package iso20022\n\n\ntype ATMEnvironment3 struct {\n\n\tAcquirer *Acquirer7 `xml:\"Acqrr,omitempty\"`\n\n\tATMManagerIdentification *Max35Text `xml:\"ATMMgrId,omitempty\"`\n\n\tHostingEntity *TerminalHosting1 `xml:\"HstgNtty,omitempty\"`\n\n\tATM *AutomatedTellerMachine1 `xml:\"ATM\"`\n\n\tCustomer *ATMCustomer3 `xml:\"Cstmr\"`\n\n\tCard *PaymentCard17 `xml:\"Card,omitempty\"`\n}\n\n\n\nfunc (a *ATMEnvironment3) SetATMManagerIdentification(value string) {\n\ta.ATMManagerIdentification = (*Max35Text)(&value)\n}\n\nfunc (a *ATMEnvironment3) AddHostingEntity() *TerminalHosting1 {\n\ta.HostingEntity = new(TerminalHosting1)\n\treturn a.HostingEntity\n}\n\nfunc (a *ATMEnvironment3) AddATM() *AutomatedTellerMachine1 {\n\ta.ATM = new(AutomatedTellerMachine1)\n\treturn a.ATM\n}\n\nfunc (a *ATMEnvironment3) AddCustomer() *ATMCustomer3 {\n\ta.Customer = new(ATMCustomer3)\n\treturn a.Customer\n}\n\nfunc (a *ATMEnvironment3) AddCard() *PaymentCard17 {\n\ta.Card = new(PaymentCard17)\n\treturn a.Card\n}\n\nfunc (a *ATMEnvironment3) AddAcquirer() *Acquirer7 ", "output": "{\n\ta.Acquirer = new(Acquirer7)\n\treturn a.Acquirer\n}"}
{"input": "package oglemock\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n\n\n\nfunc Invoke(f interface{}) Action {\n\tfv := reflect.ValueOf(f)\n\tfk := fv.Kind()\n\n\tif fk != reflect.Func {\n\t\tdesc := \"<nil>\"\n\t\tif fk != reflect.Invalid {\n\t\t\tdesc = fv.Type().String()\n\t\t}\n\n\t\tpanic(fmt.Sprintf(\"Invoke: expected function, got %s\", desc))\n\t}\n\n\treturn &invokeAction{fv}\n}\n\ntype invokeAction struct {\n\tf reflect.Value\n}\n\n\n\nfunc (a *invokeAction) Invoke(vals []interface{}) []interface{} {\n\tin := make([]reflect.Value, len(vals))\n\tfor i, x := range vals {\n\t\tin[i] = reflect.ValueOf(x)\n\t}\n\n\tout := a.f.Call(in)\n\tresult := make([]interface{}, len(out))\n\tfor i, v := range out {\n\t\tresult[i] = v.Interface()\n\t}\n\n\treturn result\n}\n\nfunc (a *invokeAction) SetSignature(signature reflect.Type) error ", "output": "{\n\tft := a.f.Type()\n\tif ft != signature {\n\t\treturn errors.New(fmt.Sprintf(\"Invoke: expected %v, got %v\", signature, ft))\n\t}\n\n\treturn nil\n}"}
{"input": "package schedulercache\n\nimport (\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/labels\"\n\t\"k8s.io/kubernetes/plugin/pkg/scheduler/schedulercache\"\n)\n\n\ntype FakeCache struct {\n\tAssumeFunc func(*api.Pod)\n}\n\nfunc (f *FakeCache) AssumePod(pod *api.Pod) error {\n\tf.AssumeFunc(pod)\n\treturn nil\n}\n\nfunc (f *FakeCache) AddPod(pod *api.Pod) error { return nil }\n\nfunc (f *FakeCache) UpdatePod(oldPod, newPod *api.Pod) error { return nil }\n\nfunc (f *FakeCache) RemovePod(pod *api.Pod) error { return nil }\n\nfunc (f *FakeCache) AddNode(node *api.Node) error { return nil }\n\n\n\nfunc (f *FakeCache) RemoveNode(node *api.Node) error { return nil }\n\nfunc (f *FakeCache) UpdateNodeNameToInfoMap(infoMap map[string]*schedulercache.NodeInfo) error {\n\treturn nil\n}\n\nfunc (f *FakeCache) List(s labels.Selector) ([]*api.Pod, error) { return nil, nil }\n\nfunc (f *FakeCache) UpdateNode(oldNode, newNode *api.Node) error ", "output": "{ return nil }"}
{"input": "package force\n\ntype Limits map[string]Limit\n\ntype Limit struct {\n\tRemaining float64\n\tMax       float64\n}\n\n\n\nfunc (forceApi *ForceApi) GetLimits() (limits *Limits, err error) ", "output": "{\n\turi := forceApi.apiResources[limitsKey]\n\n\tlimits = &Limits{}\n\terr = forceApi.Get(uri, nil, limits)\n\n\treturn\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/grsakea/kappastat/common\"\n\t\"github.com/mrshankly/go-twitch/twitch\"\n\t\"log\"\n\t\"time\"\n)\n\n\n\nfunc fetchViewers(client *twitch.Client, cBroadcast chan Message, chanName string, online map[string]bool) kappastat.ViewerCount {\n\n\tchannel, err := client.Streams.Channel(chanName)\n\tif err != nil {\n\t\tchannel, err = client.Streams.Channel(chanName)\n\t\tif err != nil {\n\t\t\tlog.Print(\"Error fetching viewer : \", err)\n\t\t}\n\t}\n\n\tif channel.Stream.Viewers != 0 && online[chanName] == false {\n\t\tonline[chanName] = true\n\t\tcBroadcast <- Message{StartBroadcast, chanName}\n\t} else if channel.Stream.Viewers == 0 && online[chanName] == true {\n\t\tonline[chanName] = false\n\t\tcBroadcast <- Message{EndBroadcast, chanName}\n\t}\n\n\treturn kappastat.ViewerCount{chanName, time.Now(), channel.Stream.Viewers}\n}\n\nfunc loopViewers(client *twitch.Client, c chan Message, cBroadcast chan Message, infos chan kappastat.ViewerCount) ", "output": "{\n\tfollowed := []string{}\n\tonline := make(map[string]bool)\n\tticker := time.NewTicker(time.Minute).C\n\tloop := true\n\n\tfor loop {\n\t\tselect {\n\t\tcase msg := <-c:\n\t\t\tfollowed, loop = followedHandler(followed, msg)\n\t\tcase <-ticker:\n\t\t\tfor _, v := range followed {\n\t\t\t\tinfos <- fetchViewers(client, cBroadcast, v, online)\n\t\t\t}\n\t\t}\n\t}\n\tlog.Print(\"Viewer loop stopped\")\n}"}
{"input": "package binmsg\n\nimport (\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/juju/errors\"\n)\n\nvar referenceTime time.Time\n\nconst refTimeString = \"2305-01-01T00:00:00Z\"\n\nfunc init() {\n\tinitBinMsg()\n}\n\n\n\nfunc initBinMsg() ", "output": "{\n\treferenceTime, _ = time.Parse(time.RFC3339, refTimeString)\n\treferenceTime = referenceTime.UTC()\n\tErrPayloadSizeTooSmall = errors.New(\n\t\t\"The payload size is less than \" + strconv.Itoa(PayloadOctets) +\n\t\t\t\" bytes long.\")\n}"}
{"input": "package thrift\n\nimport (\n\t\"net\"\n)\n\n\ntype socketConn struct {\n\tnet.Conn\n\n\tbuffer [1]byte\n}\n\nvar _ net.Conn = (*socketConn)(nil)\n\n\n\nfunc createSocketConnFromReturn(conn net.Conn, err error) (*socketConn, error) {\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &socketConn{\n\t\tConn: conn,\n\t}, nil\n}\n\n\nfunc wrapSocketConn(conn net.Conn) *socketConn {\n\tif sc, ok := conn.(*socketConn); ok {\n\t\treturn sc\n\t}\n\n\treturn &socketConn{\n\t\tConn: conn,\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (sc *socketConn) IsOpen() bool {\n\tif !sc.isValid() {\n\t\treturn false\n\t}\n\treturn sc.checkConn() == nil\n}\n\n\n\n\n\n\n\n\n\n\nfunc (sc *socketConn) Read(p []byte) (n int, err error) {\n\tif len(p) == 0 {\n\t\treturn 0, sc.read0()\n\t}\n\n\treturn sc.Conn.Read(p)\n}\n\nfunc (sc *socketConn) isValid() bool ", "output": "{\n\treturn sc != nil && sc.Conn != nil\n}"}
{"input": "package packer\n\nimport (\n\t\"fmt\"\n)\n\nconst BuilderId = \"packer.post-processor.packer-registry\"\n\ntype RegistryArtifact struct {\n\tBucketSlug  string\n\tIterationID string\n\tBuildName   string\n}\n\nfunc (a *RegistryArtifact) BuilderId() string {\n\treturn BuilderId\n}\n\n\n\nfunc (a *RegistryArtifact) Files() []string {\n\treturn []string{}\n}\n\nfunc (a *RegistryArtifact) String() string {\n\treturn fmt.Sprintf(\"Published metadata to HCP Packer registry packer/%s/iterations/%s\", a.BucketSlug, a.IterationID)\n}\n\nfunc (*RegistryArtifact) State(name string) interface{} {\n\treturn nil\n}\n\nfunc (a *RegistryArtifact) Destroy() error {\n\treturn nil\n}\n\nfunc (*RegistryArtifact) Id() string ", "output": "{\n\treturn \"\"\n}"}
{"input": "package localdir\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/pkg/errors\"\n)\n\n\nfunc (s *Store) GetIndex(nodeID string) ([]byte, error) {\n\tindexFile := s.indexFilename(nodeID)\n\tindexBlock, err := ioutil.ReadFile(indexFile)\n\tif os.IsNotExist(err) {\n\t\treturn nil, nil\n\t} else if err != nil {\n\t\treturn nil, errors.Wrap(err, \"Read index file failed\")\n\t}\n\treturn indexBlock, nil\n}\n\n\nfunc (s *Store) StoreIndex(nodeID string, indexBlock []byte) error {\n\tindexFile := s.indexFilename(nodeID)\n\tif err := os.MkdirAll(filepath.Dir(indexFile), 0700); err != nil {\n\t\treturn errors.Wrap(err, \"Create indexes directory failed\")\n\t}\n\tif err := ioutil.WriteFile(indexFile, indexBlock, 0600); err != nil {\n\t\treturn errors.Wrap(err, \"Writing index file failed\")\n\t}\n\treturn nil\n}\n\n\n\nfunc (s *Store) indexFilename(nodeID string) string ", "output": "{\n\treturn filepath.Join(s.baseDir, \"indexes\", nodeID)\n}"}
{"input": "package image\n\nimport (\n\t\"github.com/thoas/gostorages\"\n\t\"mime\"\n\t\"path\"\n\t\"strings\"\n)\n\ntype ImageFile struct {\n\tSource    []byte\n\tProcessed []byte\n\tKey       string\n\tHeaders   map[string]string\n\tFilepath  string\n\tStorage   gostorages.Storage\n}\n\nfunc (i *ImageFile) Content() []byte {\n\tif i.Processed != nil {\n\t\treturn i.Processed\n\t}\n\n\treturn i.Source\n}\n\nfunc (i *ImageFile) URL() string {\n\treturn i.Storage.URL(i.Filepath)\n}\n\n\n\nfunc (i *ImageFile) Save() error {\n\treturn i.Storage.Save(i.Filepath, gostorages.NewContentFile(i.Content()))\n}\n\nfunc (i *ImageFile) Format() string {\n\treturn Extensions[i.ContentType()]\n}\n\nfunc (i *ImageFile) ContentType() string {\n\treturn mime.TypeByExtension(i.FilenameExt())\n}\n\nfunc (i *ImageFile) Filename() string {\n\treturn i.Filepath[strings.LastIndex(i.Filepath, \"/\")+1:]\n}\n\nfunc (i *ImageFile) FilenameExt() string {\n\treturn path.Ext(i.Filename())\n}\n\nfunc (i *ImageFile) Path() string ", "output": "{\n\treturn i.Storage.Path(i.Filepath)\n}"}
{"input": "package common\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\n\t\"github.com/pkg/errors\"\n)\n\n\n\ntype NodeMetastate struct {\n\n\tLedgerHeight uint64\n}\n\n\nfunc NewNodeMetastate(height uint64) *NodeMetastate {\n\treturn &NodeMetastate{height}\n}\n\n\n\n\n\nfunc (n *NodeMetastate) Height() uint64 {\n\treturn n.LedgerHeight\n}\n\n\nfunc (n *NodeMetastate) Update(height uint64) {\n\tn.LedgerHeight = height\n}\n\n\nfunc FromBytes(buf []byte) (*NodeMetastate, error) {\n\tstate := NodeMetastate{}\n\treader := bytes.NewReader(buf)\n\terr := binary.Read(reader, binary.BigEndian, &state)\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\treturn &state, nil\n}\n\nfunc (n *NodeMetastate) Bytes() ([]byte, error) ", "output": "{\n\tbuffer := new(bytes.Buffer)\n\terr := binary.Write(buffer, binary.BigEndian, *n)\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\treturn buffer.Bytes(), nil\n}"}
{"input": "package containerengine\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ListWorkRequestLogsRequest struct {\n\n\tCompartmentId *string `mandatory:\"true\" contributesTo:\"query\" name:\"compartmentId\"`\n\n\tWorkRequestId *string `mandatory:\"true\" contributesTo:\"path\" name:\"workRequestId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request ListWorkRequestLogsRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request ListWorkRequestLogsRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request ListWorkRequestLogsRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request ListWorkRequestLogsRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ListWorkRequestLogsResponse struct {\n\n\tRawResponse *http.Response\n\n\tItems []WorkRequestLogEntry `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\n\n\n\nfunc (response ListWorkRequestLogsResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response ListWorkRequestLogsResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package uber\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\tistioconfig \"istio.io/api/istio/config/v1\"\n\n\t\"istio.io/mixer/pkg/aspectsupport\"\n\t\"istio.io/mixer/pkg/attribute\"\n\t\"istio.io/mixer/pkg/expr\"\n)\n\ntype (\n\tfakereg struct {\n\t\tRegistryQuerier\n\t}\n\n\tfakemgr struct {\n\t\tkind string\n\t\taspectsupport.Manager\n\t}\n\n\tfakebag struct {\n\t\tattribute.Bag\n\t}\n\n\tfakeevaluator struct {\n\t\texpr.Evaluator\n\t}\n)\n\n\n\nfunc TestManager(t *testing.T) {\n\tr := &fakereg{}\n\tmgrs := []aspectsupport.Manager{&fakemgr{kind: \"k1\"}, &fakemgr{kind: \"k2\"}}\n\tm := NewManager(r, mgrs)\n\tcfg := &aspectsupport.CombinedConfig{\n\t\tAspect:  &istioconfig.Aspect{},\n\t\tAdapter: &istioconfig.Adapter{},\n\t}\n\tattrs := &fakebag{}\n\tmapper := &fakeevaluator{}\n\tif _, err := m.Execute(cfg, attrs, mapper); err != nil {\n\t\tif !strings.Contains(err.Error(), \"could not find aspect manager\") {\n\t\t\tt.Error(\"excute errored out: \", err)\n\t\t}\n\n\t}\n}\n\nfunc (m *fakemgr) Kind() string ", "output": "{\n\treturn m.kind\n}"}
{"input": "package danmu\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/smartystreets/goconvey/convey\"\n\tgock \"gopkg.in/h2non/gock.v1\"\n)\n\n\n\nfunc TestDanmuProtectApplyVideoList(t *testing.T) {\n\tvar (\n\t\tc   = context.TODO()\n\t\tmid = int64(2089809)\n\t\tip  = \"127.0.0.1\"\n\t)\n\tconvey.Convey(\"ProtectApplyVideoList\", t, func(ctx convey.C) {\n\t\tresult, err := d.ProtectApplyVideoList(c, mid, ip)\n\t\tctx.Convey(\"Then err should be nil.result should not be nil.\", func(ctx convey.C) {\n\t\t\tctx.So(err, convey.ShouldBeNil)\n\t\t\tctx.So(result, convey.ShouldNotBeNil)\n\t\t})\n\t})\n}\n\nfunc TestDanmuProtectOper(t *testing.T) {\n\tvar (\n\t\tc      = context.TODO()\n\t\tmid    = int64(2089809)\n\t\tstatus = int64(0)\n\t\tids    = \"1,2\"\n\t\tip     = \"127.0.0.1\"\n\t)\n\tconvey.Convey(\"ProtectOper\", t, func(ctx convey.C) {\n\t\tdefer gock.OffAll()\n\t\thttpMock(\"POST\", d.dmProtectApplyStatusURL).Reply(200).JSON(`{\"code\":20043,\"data\":\"\"}`)\n\t\terr := d.ProtectOper(c, mid, status, ids, ip)\n\t\tctx.Convey(\"Then err should be nil.\", func(ctx convey.C) {\n\t\t\tctx.So(err, convey.ShouldNotBeNil)\n\t\t})\n\t})\n}\n\nfunc TestDanmuProtectApplyList(t *testing.T) ", "output": "{\n\tvar (\n\t\tc      = context.TODO()\n\t\tmid    = int64(2089809)\n\t\tpage   = int64(0)\n\t\taidStr = \"1\"\n\t\tsort   = \"ctime\"\n\t\tip     = \"127.0.0.1\"\n\t)\n\tconvey.Convey(\"ProtectApplyList\", t, func(ctx convey.C) {\n\t\tresult, err := d.ProtectApplyList(c, mid, page, aidStr, sort, ip)\n\t\tctx.Convey(\"Then err should be nil.result should not be nil.\", func(ctx convey.C) {\n\t\t\tctx.So(err, convey.ShouldBeNil)\n\t\t\tctx.So(result, convey.ShouldNotBeNil)\n\t\t})\n\t})\n}"}
{"input": "package v1\n\n\n\n\n\n\n\n\n\n\n\n\nvar map_TokenReview = map[string]string{\n\t\"\":       \"TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver.\",\n\t\"spec\":   \"Spec holds information about the request being evaluated\",\n\t\"status\": \"Status is filled in by the server and indicates whether the request can be authenticated.\",\n}\n\nfunc (TokenReview) SwaggerDoc() map[string]string {\n\treturn map_TokenReview\n}\n\nvar map_TokenReviewSpec = map[string]string{\n\t\"\":      \"TokenReviewSpec is a description of the token authentication request.\",\n\t\"token\": \"Token is the opaque bearer token.\",\n}\n\nfunc (TokenReviewSpec) SwaggerDoc() map[string]string {\n\treturn map_TokenReviewSpec\n}\n\nvar map_TokenReviewStatus = map[string]string{\n\t\"\":              \"TokenReviewStatus is the result of the token authentication request.\",\n\t\"authenticated\": \"Authenticated indicates that the token was associated with a known user.\",\n\t\"user\":          \"User is the UserInfo associated with the provided token.\",\n\t\"error\":         \"Error indicates that the token couldn't be checked\",\n}\n\n\n\nvar map_UserInfo = map[string]string{\n\t\"\":         \"UserInfo holds the information about the user needed to implement the user.Info interface.\",\n\t\"username\": \"The name that uniquely identifies this user among all active users.\",\n\t\"uid\":      \"A unique value that identifies this user across time. If this user is deleted and another user by the same name is added, they will have different UIDs.\",\n\t\"groups\":   \"The names of groups this user is a part of.\",\n\t\"extra\":    \"Any additional information provided by the authenticator.\",\n}\n\nfunc (UserInfo) SwaggerDoc() map[string]string {\n\treturn map_UserInfo\n}\n\nfunc (TokenReviewStatus) SwaggerDoc() map[string]string ", "output": "{\n\treturn map_TokenReviewStatus\n}"}
{"input": "package utils\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\n\n\n\nfunc reload() {\n}\n\nfunc Signal() ", "output": "{\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)\n\tfor {\n\t\ts := <-c\n\t\tswitch s {\n\t\tcase syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:\n\t\t\treturn\n\t\tcase syscall.SIGHUP:\n\t\t\treload()\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"input": "package ldp\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc Test_minCut(t *testing.T) ", "output": "{\n\tassert := assert.New(t)\n\n\tassert.Equal(1, minCut(\"aab\"))\n\tassert.Equal(0, minCut(\"aa\"))\n}"}
{"input": "package viewmodel\n\nimport \"github.com/airlingo/airlingo/model\"\n\ntype Settings struct {\n\tCurrentUser          *model.User\n\tName                 string\n\tTranslationLanguage  *model.Language\n\tTranslationLanguages []*model.Language\n}\n\nfunc NewSettings(currentUser *model.User, name string, translationLanguageID *string, translationLanguages []*model.Language) *Settings {\n\tsettings := &Settings{\n\t\tCurrentUser:          currentUser,\n\t\tName:                 name,\n\t\tTranslationLanguages: translationLanguages,\n\t}\n\n\tif translationLanguageID != nil {\n\t\tfor _, language := range translationLanguages {\n\t\t\tif language.ID == *translationLanguageID {\n\t\t\t\tsettings.TranslationLanguage = language\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn settings\n}\n\n\n\nfunc (c *Settings) GetTranslationLanguageID() string ", "output": "{\n\tif c.TranslationLanguage == nil {\n\t\treturn \"\"\n\t}\n\n\treturn c.TranslationLanguage.ID\n}"}
{"input": "package config\n\ntype Dependencies interface {\n\tConfigurator\n\tInstalls() []string\n\tmerge(other Dependencies)\n}\n\n\n\nconst exists = true\n\ntype dependencies struct {\n\tset map[string]bool\n}\n\nfunc (d dependencies) Installs() []string {\n\tkeys := make([]string, len(d.set))\n\n\ti := 0\n\tfor k := range d.set {\n\t\tkeys[i] = k\n\t\ti++\n\t}\n\n\treturn keys\n}\n\nfunc (d dependencies) Configure(cfg Configurable) {\n\tcfg.Config().Dependencies.merge(d)\n}\n\nfunc (d dependencies) merge(other Dependencies) {\n\tfor _, dep := range other.Installs() {\n\t\td.set[dep] = exists\n\t}\n}\n\nfunc NewDependencies(deps ...string) Dependencies ", "output": "{\n\ts := make(map[string]bool, len(deps))\n\tfor _, dep := range deps {\n\t\ts[dep] = exists\n\t}\n\treturn dependencies{\n\t\tset: s,\n\t}\n}"}
{"input": "package main\n\nimport \"fmt\"\n\nconst (\n\tBig   = 1 << 100\n\tSmall = Big >> 99\n)\n\nfunc needInt(x int) int {\n\treturn x*10 + 1\n}\n\n\n\nfunc main() {\n\tfmt.Println(needInt(Small))\n\tfmt.Println(needFloat(Small))\n\tfmt.Println(needFloat(Big))\n}\n\nfunc needFloat(x float64) float64 ", "output": "{\n\treturn x * 0.1\n}"}
{"input": "package dashboard\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"text/template\"\n\n\t\"github.com/pkg/errors\"\n\n\ttm \"github.com/supergiant/control/pkg/templatemanager\"\n\t\"github.com/supergiant/control/pkg/workflows/steps\"\n)\n\nconst StepName = \"dashboard\"\n\ntype Step struct {\n\tscript *template.Template\n}\n\nfunc (s *Step) Rollback(context.Context, io.Writer, *steps.Config) error {\n\treturn nil\n}\n\nfunc Init() {\n\ttpl, err := tm.GetTemplate(StepName)\n\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"template %s not found\", StepName))\n\t}\n\n\tsteps.RegisterStep(StepName, New(tpl))\n}\n\nfunc New(script *template.Template) *Step {\n\tt := &Step{\n\t\tscript: script,\n\t}\n\n\treturn t\n}\n\nfunc (s *Step) Run(ctx context.Context, out io.Writer, config *steps.Config) error {\n\terr := steps.RunTemplate(ctx, s.script, config.Runner, out, nil)\n\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"install kubernetes dashboard\")\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (s *Step) Description() string {\n\treturn \"Install kubernetes dashboard\"\n}\n\nfunc (s *Step) Depends() []string {\n\treturn nil\n}\n\nfunc (s *Step) Name() string ", "output": "{\n\treturn StepName\n}"}
{"input": "package cubbyhole\n\nimport \"testing\"\n\nfunc TestCubbyholePut(t *testing.T) {\n\tc := Cubbyhole{}\n\n\tif c.Message != \"\" {\n\t\tt.Error(`Cubbyhole must be \"\" before the first put`)\n\t}\n\n\tc.Put(\"test!\")\n\tif c.Message != \"test!\" {\n\t\tt.Errorf(`Cubbyhole should be \"test!\" but is: %s`, c.Message)\n\t}\n}\n\nfunc TestCubbyholeDrop(t *testing.T) {\n\tc := Cubbyhole{}\n\n\tc.Drop()\n\tif c.Message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Drop didn't drop the message: %s`, c.Message)\n\t}\n\n\tc.Message = \"foobar\"\n\n\tc.Drop()\n\tif c.Message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Drop didn't drop the message: %s`, c.Message)\n\t}\n}\n\n\n\nfunc TestCubbyholeGet(t *testing.T) {\n\tc := Cubbyhole{}\n\n\tif message := c.Get(); message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Get didn't return an empty message: %s`, message)\n\t}\n\n\tc.Message = \"NPA\"\n\tif message := c.Get(); message != \"NPA\" {\n\t\tt.Errorf(`Cubbyhole.Look didn't return the correct message \"NPA\" != %s`, message)\n\t}\n\n\tif message := c.Get(); message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Get didn't return an empty message: %s`, message)\n\t}\n}\n\nfunc TestCubbyholeLook(t *testing.T) ", "output": "{\n\tc := Cubbyhole{}\n\n\tif message := c.Look(); message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Look didn't return an empty message: %s`, message)\n\t}\n\n\tc.Message = \"NPA\"\n\tif message := c.Look(); message != \"NPA\" {\n\t\tt.Errorf(`Cubbyhole.Look didn't return the correct message \"NPA\" != %s`, message)\n\t}\n}"}
{"input": "package route\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar ()\n\n\ntype Route struct {\n\tPath   string\n\tSystem int\n\tS0     NullRoute\n\tS1     StringRoute\n\tS2     ControllerRoute\n\tS3     FilesystemRoute\n\tS4     FunctionRoute\n}\n\n\n\n\n\nfunc (r *Route) Read(w http.ResponseWriter, req *http.Request) {\n\tresult := \"\"\n\tswitch r.System {\n\tcase 0:\n\t\tresult = \"\"\n\tcase 1:\n\t\tresult = r.S1.String\n\tcase 2:\n\tcase 3:\n\t\tresult = r.S3.FileContent\n\tcase 4:\n\t\tresult = r.S4.Function()\n\t}\n\tio.Copy(w, strings.NewReader(result))\n}\n\n\nfunc ValidStringRoute(str string) bool {\n\trouteStringRegexp := `^\\/([a-zA-Z0-9](\\/)*)*\\s(null|str .*|fs .*)$`\n\tr, _ := regexp.Compile(routeStringRegexp)\n\tif r.MatchString(str) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc NewRoute(path string, system int) Route ", "output": "{\n\treturn Route{path, system, NullRoute{}, StringRoute{}, ControllerRoute{}, FilesystemRoute{}, FunctionRoute{}}\n}"}
{"input": "package tweetharvest\n\nimport (\n\t\"time\"\n\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/appengine/datastore\"\n\t\"google.golang.org/appengine/log\"\n)\n\nconst tweetKey string = \"Tweets\"\nconst tweetKeyID string = \"default_tweetstore\"\n\n\n\nfunc GetAllNewTweets(since time.Time, c context.Context) LinkTweets {\n\tlog.Infof(c, \"Getting all tweets newer than: %v\", since)\n\tq := datastore.NewQuery(linkTweetKind).Ancestor(getTweetKey(c)).Filter(\"CreatedTime >\", since)\n\tout := make(LinkTweets, 0, 15)\n\tq.GetAll(c, &out)\n\treturn out\n}\n\nfunc getNewestTweet(c context.Context) time.Time {\n\tvar latest LinkTweet\n\n\tq := datastore.NewQuery(linkTweetKind).Order(\"-CreatedTime\").Project(\"CreatedTime\").Limit(1)\n\tq.GetAll(c, latest)\n\ti := q.Run(c)\n\ti.Next(&latest)\n\ttime, _ := latest.CreatedAtTime()\n\treturn time\n}\n\n\n\n\n\nfunc LinkTweetFromDatastore(tweetID int64, c context.Context) *LinkTweet {\n\tq := datastore.NewQuery(linkTweetKind).\n\t\tFilter(\"TweetID =\", tweetID).\n\t\tLimit(1)\n\n\titerator := q.Run(c)\n\tlinkTweet := &LinkTweet{}\n\t_, err := iterator.Next(linkTweet)\n\tif err != nil {\n\t\treturn nil\n\t}\n\treturn linkTweet\n}\n\nfunc getTweetKey(c context.Context) *datastore.Key ", "output": "{\n\treturn datastore.NewKey(c, tweetKey, tweetKeyID, 0, nil)\n}"}
{"input": "package chaosmonkey_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/Netflix/chaosmonkey\"\n)\n\n\n\nfunc TestExceptionMatches(t *testing.T) ", "output": "{\n\tex := chaosmonkey.Exception{Account: \"test\", Stack: \"*\", Detail: \"*\", Region: \"*\"}\n\n\tif !ex.Matches(\"test\", \"cl\", \"app-cl-test\", \"us-east-1\") {\n\t\tt.Error(\"Expected exception match\")\n\t}\n}"}
{"input": "package dml_test\n\nimport (\n\t\"encoding/xml\"\n\t\"testing\"\n\n\t\"baliance.com/gooxml/schema/soo/dml\"\n)\n\nfunc TestEG_LineJoinPropertiesConstructor(t *testing.T) {\n\tv := dml.NewEG_LineJoinProperties()\n\tif v == nil {\n\t\tt.Errorf(\"dml.NewEG_LineJoinProperties must return a non-nil value\")\n\t}\n\tif err := v.Validate(); err != nil {\n\t\tt.Errorf(\"newly constructed dml.EG_LineJoinProperties should validate: %s\", err)\n\t}\n}\n\n\n\nfunc TestEG_LineJoinPropertiesMarshalUnmarshal(t *testing.T) ", "output": "{\n\tv := dml.NewEG_LineJoinProperties()\n\tbuf, _ := xml.Marshal(v)\n\tv2 := dml.NewEG_LineJoinProperties()\n\txml.Unmarshal(buf, v2)\n}"}
{"input": "package service\n\nimport \"os\"\n\nvar (\n\tuuid     string\n\thostname string\n\tpid      int\n)\n\n\n\nfunc init() ", "output": "{\n\thn, _ := os.Hostname()\n\thostname = hn\n\n\tpid = os.Getpid()\n}"}
{"input": "package minecraft\n\nimport (\n\t\"io\"\n\t\"github.com/LilyPad/GoLilyPad/packet\"\n)\n\ntype PacketServerLoginStart struct {\n\tName string\n}\n\nfunc NewPacketServerLoginStart(name string) (this *PacketServerLoginStart) {\n\tthis = new(PacketServerLoginStart)\n\tthis.Name = name\n\treturn\n}\n\nfunc (this *PacketServerLoginStart) Id() int {\n\treturn PACKET_SERVER_LOGIN_START\n}\n\ntype packetServerLoginStartCodec struct {\n\n}\n\n\n\nfunc (this *packetServerLoginStartCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\n\tpacketServerLoginStart := encode.(*PacketServerLoginStart)\n\terr = packet.WriteString(writer, packetServerLoginStart.Name)\n\treturn\n}\n\nfunc (this *packetServerLoginStartCodec) Decode(reader io.Reader) (decode packet.Packet, err error) ", "output": "{\n\tpacketServerLoginStart := new(PacketServerLoginStart)\n\tpacketServerLoginStart.Name, err = packet.ReadString(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\tdecode = packetServerLoginStart\n\treturn\n}"}
{"input": "package header\n\nimport \"github.com/google/netstack/tcpip\"\n\n\n\n\n\ntype NDPNeighborSolicit []byte\n\nconst (\n\tNDPNSMinimumSize = 20\n\n\tndpNSTargetAddessOffset = 4\n\n\tndpNSOptionsOffset = ndpNSTargetAddessOffset + IPv6AddressSize\n)\n\n\n\n\n\nfunc (b NDPNeighborSolicit) SetTargetAddress(addr tcpip.Address) {\n\tcopy(b[ndpNSTargetAddessOffset:][:IPv6AddressSize], addr)\n}\n\n\nfunc (b NDPNeighborSolicit) Options() NDPOptions {\n\treturn NDPOptions(b[ndpNSOptionsOffset:])\n}\n\nfunc (b NDPNeighborSolicit) TargetAddress() tcpip.Address ", "output": "{\n\treturn tcpip.Address(b[ndpNSTargetAddessOffset:][:IPv6AddressSize])\n}"}
{"input": "package sync\n\nimport (\n\t\"context\"\n\t\"strings\"\n\n\t\"github.com/fluxcd/flux/pkg/git\"\n)\n\n\ntype GitTagSyncProvider struct {\n\trepo       *git.Repo\n\tsyncTag    string\n\tsigningKey string\n\tverifyTag  bool\n\tconfig     git.Config\n}\n\n\nfunc NewGitTagSyncProvider(\n\trepo *git.Repo,\n\tsyncTag string,\n\tsigningKey string,\n\tverifyTag bool,\n\tconfig git.Config,\n) (GitTagSyncProvider, error) {\n\treturn GitTagSyncProvider{\n\t\trepo:       repo,\n\t\tsyncTag:    syncTag,\n\t\tsigningKey: signingKey,\n\t\tverifyTag:  verifyTag,\n\t\tconfig:     config,\n\t}, nil\n}\n\nfunc (p GitTagSyncProvider) String() string {\n\treturn \"tag \" + p.syncTag\n}\n\n\n\n\n\nfunc (p GitTagSyncProvider) UpdateMarker(ctx context.Context, revision string) error {\n\tcheckout, err := p.repo.Clone(ctx, p.config)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn checkout.MoveTagAndPush(ctx, git.TagAction{\n\t\tTag:        p.syncTag,\n\t\tRevision:   revision,\n\t\tMessage:    \"Sync pointer\",\n\t\tSigningKey: p.signingKey,\n\t})\n}\n\n\nfunc (p GitTagSyncProvider) DeleteMarker(ctx context.Context) error {\n\treturn p.repo.DeleteTag(ctx, p.syncTag)\n}\n\nfunc isUnknownRevision(err error) bool {\n\treturn err != nil &&\n\t\t(strings.Contains(err.Error(), \"unknown revision or path not in the working tree.\") ||\n\t\t\tstrings.Contains(err.Error(), \"bad revision\"))\n}\n\nfunc (p GitTagSyncProvider) GetRevision(ctx context.Context) (string, error) ", "output": "{\n\trev, err := p.repo.Revision(ctx, p.syncTag)\n\tif isUnknownRevision(err) {\n\t\treturn \"\", nil\n\t}\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif p.verifyTag {\n\t\tif _, err := p.repo.VerifyTag(ctx, p.syncTag); err != nil {\n\t\t\tif strings.Contains(err.Error(), \"not found.\") {\n\t\t\t\treturn \"\", nil\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn rev, nil\n}"}
{"input": "package getter\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/goharbor/harbor/src/lib/orm\"\n\t\"github.com/goharbor/harbor/src/pkg/joblog\"\n\n\t\"github.com/goharbor/harbor/src/jobservice/errs\"\n)\n\n\ntype DBGetter struct {\n}\n\n\nfunc NewDBGetter() *DBGetter {\n\treturn &DBGetter{}\n}\n\n\n\n\nfunc (dbg *DBGetter) Retrieve(logID string) ([]byte, error) ", "output": "{\n\tif len(logID) == 0 {\n\t\treturn nil, errors.New(\"empty log identify\")\n\t}\n\n\tjobLog, err := joblog.Mgr.Get(orm.Context(), logID)\n\tif err != nil {\n\t\treturn nil, errs.NoObjectFoundError(fmt.Sprintf(\"log entity: %s\", logID))\n\t}\n\n\treturn []byte(jobLog.Content), nil\n}"}
{"input": "package endpoint\n\nimport (\n\t\"fmt\"\n)\n\nconst (\n\t_PlaceholderCreationEncryptionPropertyName_0 = \"unspecifiedinherit\"\n\t_PlaceholderCreationEncryptionPropertyName_1 = \"off\"\n)\n\nvar (\n\t_PlaceholderCreationEncryptionPropertyIndex_0 = [...]uint8{0, 11, 18}\n\t_PlaceholderCreationEncryptionPropertyIndex_1 = [...]uint8{0, 3}\n)\n\n\n\nvar _PlaceholderCreationEncryptionPropertyValues = []PlaceholderCreationEncryptionProperty{1, 2, 4}\n\nvar _PlaceholderCreationEncryptionPropertyNameToValueMap = map[string]PlaceholderCreationEncryptionProperty{\n\t_PlaceholderCreationEncryptionPropertyName_0[0:11]:  1,\n\t_PlaceholderCreationEncryptionPropertyName_0[11:18]: 2,\n\t_PlaceholderCreationEncryptionPropertyName_1[0:3]:   4,\n}\n\n\n\nfunc PlaceholderCreationEncryptionPropertyString(s string) (PlaceholderCreationEncryptionProperty, error) {\n\tif val, ok := _PlaceholderCreationEncryptionPropertyNameToValueMap[s]; ok {\n\t\treturn val, nil\n\t}\n\treturn 0, fmt.Errorf(\"%s does not belong to PlaceholderCreationEncryptionProperty values\", s)\n}\n\n\nfunc PlaceholderCreationEncryptionPropertyValues() []PlaceholderCreationEncryptionProperty {\n\treturn _PlaceholderCreationEncryptionPropertyValues\n}\n\n\nfunc (i PlaceholderCreationEncryptionProperty) IsAPlaceholderCreationEncryptionProperty() bool {\n\tfor _, v := range _PlaceholderCreationEncryptionPropertyValues {\n\t\tif i == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (i PlaceholderCreationEncryptionProperty) String() string ", "output": "{\n\tswitch {\n\tcase 1 <= i && i <= 2:\n\t\ti -= 1\n\t\treturn _PlaceholderCreationEncryptionPropertyName_0[_PlaceholderCreationEncryptionPropertyIndex_0[i]:_PlaceholderCreationEncryptionPropertyIndex_0[i+1]]\n\tcase i == 4:\n\t\treturn _PlaceholderCreationEncryptionPropertyName_1\n\tdefault:\n\t\treturn fmt.Sprintf(\"PlaceholderCreationEncryptionProperty(%d)\", i)\n\t}\n}"}
{"input": "package parser\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/uol/gobol\"\n\n\t\"github.com/uol/mycenae/lib/tserr\"\n)\n\n\n\nfunc errParams(f, m string, e error) gobol.Error {\n\treturn errBasic(f, m, e)\n}\n\nfunc errDoubleFunc(f, ef string) gobol.Error {\n\ts := fmt.Sprintf(\"You can use only one %s function per expression\", ef)\n\treturn errBasic(f, s, errors.New(s))\n}\n\nfunc errGroup(s string) gobol.Error {\n\treturn errBasic(\"parseGroup\", s, errors.New(s))\n}\n\nfunc errBadUnit() gobol.Error {\n\ts := \"Invalid unit\"\n\treturn errBasic(\"GetRelativeStart\", s, errors.New(s))\n}\n\nfunc errGRT(e error) gobol.Error {\n\tvar es string\n\tif e != nil {\n\t\tes = e.Error()\n\t}\n\treturn errBasic(\"GetRelativeStart\", es, e)\n}\n\nfunc errParseMap(s string) gobol.Error {\n\treturn errBasic(\"parseMap\", s, errors.New(s))\n}\n\nfunc errRateCounter(e error) gobol.Error {\n\treturn errBasic(\"parseRate\", \"rate counter, the 1st parameter, needs to be a boolean\", e)\n}\n\nfunc errRateCounterMax(e error) gobol.Error {\n\treturn errBasic(\"parseRate\", `rate counterMax, the 2nd parameter, needs to be an integer or the string 'null'`, e)\n}\n\nfunc errRateResetValue(e error) gobol.Error {\n\treturn errBasic(\"parseRate\", \"rate resetValue, the 3rd parameter, needs to be an integer\", e)\n}\n\nfunc errUnkFunc(s string) gobol.Error {\n\treturn errBasic(\"parseExpression\", s, errors.New(s))\n}\n\nfunc errBasic(f, s string, e error) gobol.Error ", "output": "{\n\tif e != nil {\n\t\treturn tserr.New(\n\t\t\te,\n\t\t\ts,\n\t\t\thttp.StatusBadRequest,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"package\": \"parse\",\n\t\t\t\t\"func\":    f,\n\t\t\t},\n\t\t)\n\t}\n\treturn nil\n}"}
{"input": "package matrix\n\n\nfunc IsZeros(m Matrix) bool {\n\treturn !m.NonZeros().HasNext()\n}\n\n\n\n\n\nfunc IsDiagonal(m Matrix) bool {\n\tmatch := func(element float64, row, column int) bool {\n\t\treturn row == column || element == 0\n\t}\n\n\treturn isSpecialDiagonal(m, match)\n}\n\n\nfunc IsIdentity(m Matrix) bool {\n\tmatch := func(element float64, row, column int) bool {\n\t\tif row == column {\n\t\t\treturn element == 1\n\t\t} else {\n\t\t\treturn element == 0\n\t\t}\n\t}\n\n\treturn isSpecialDiagonal(m, match)\n}\n\n\nfunc IsScalar(m Matrix) bool {\n\tscalar := m.Get(0, 0)\n\n\tmatch := func(element float64, row, column int) bool {\n\t\tif row == column {\n\t\t\treturn element == scalar\n\t\t} else {\n\t\t\treturn element == 0\n\t\t}\n\t}\n\n\treturn isSpecialDiagonal(m, match)\n}\n\n\ntype matchFunc func(element float64, row, column int) bool\n\n\nfunc isSpecialDiagonal(m Matrix, match matchFunc) bool {\n\tif !IsSquare(m) {\n\t\treturn false\n\t}\n\n\telements := m.All()\n\n\tfor elements.HasNext() {\n\t\telement, row, column := elements.Get()\n\t\tif !match(element, row, column) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc IsSquare(m Matrix) bool ", "output": "{\n\treturn m.Rows() == m.Columns()\n}"}
{"input": "package gomegamatchers\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/onsi/gomega/types\"\n)\n\nfunc BeAnOsIsNotExistError() types.GomegaMatcher {\n\treturn &osIsNotExistErrorMatcher{}\n}\n\ntype osIsNotExistErrorMatcher struct{}\n\nfunc (matcher *osIsNotExistErrorMatcher) Match(actual interface{}) (success bool, err error) {\n\terr, ok := actual.(error)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"BeAnOsIsNotExistError matcher expects an error, got %#v\", actual)\n\t}\n\treturn os.IsNotExist(err), nil\n}\n\n\n\nfunc (matcher *osIsNotExistErrorMatcher) NegatedFailureMessage(actual interface{}) (message string) {\n\treturn fmt.Sprintf(\"Expected %#v\\nnot to be an os.IsNotExist error\", actual)\n}\n\nfunc (matcher *osIsNotExistErrorMatcher) FailureMessage(actual interface{}) (message string) ", "output": "{\n\treturn fmt.Sprintf(\"Expected %#v\\nto be an os.IsNotExist error\", actual)\n}"}
{"input": "package output\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/jutkko/mindown/util\"\n)\n\nconst DEPTH_LIMIT int = 6\n\n\n\nfunc writeMarkdownRecursively(depth int, file *os.File, node *util.Node) error {\n\terr := appendToFile(fmt.Sprintf(\"%s%s\\n\", getHash(depth), node.GetTitle()), file)\n\n\tif err != nil || len(node.GetChildren()) == 0 {\n\t\treturn err\n\t}\n\n\tfor _, node := range node.GetChildren() {\n\t\terr := writeMarkdownRecursively(depth+1, file, node)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc getHash(level int) (result string) {\n\tresult = \"\"\n\n\tif level <= DEPTH_LIMIT {\n\t\tfor i := 0; i < level; i++ {\n\t\t\tresult += \"#\"\n\t\t}\n\t\tresult += \" \"\n\t}\n\n\treturn\n}\n\nfunc appendToFile(data string, file *os.File) error {\n\tif _, err := file.WriteString(data); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc WriteMarkdown(filename string, forceWrite bool, graph *util.Graph) error ", "output": "{\n\tif !forceWrite {\n\t\tif _, err := os.Stat(filename); !os.IsNotExist(err) {\n\t\t\treturn errors.New(\"File exists\")\n\t\t}\n\t}\n\n\tos.Remove(filename)\n\n\tfile, err := os.OpenFile(filename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0600)\n\tif err != nil {\n\t\treturn errors.New(\"Failed to open file\")\n\t}\n\tdefer file.Close()\n\n\tif graph == nil {\n\t\treturn errors.New(\"Graph is nil\")\n\t}\n\n\tfor _, node := range graph.GetNodes() {\n\t\terr := writeMarkdownRecursively(1, file, node)\n\n\t\tif err != nil {\n\t\t\treturn errors.New(fmt.Sprintf(\"Failed to write file: %s %s\", filename, err.Error()))\n\t\t}\n\t}\n\n\treturn nil\n}"}
{"input": "package proxy\n\nimport (\n\t\"log\"\n\t\"strconv\"\n\n\t\"../util\"\n)\n\nfunc (s *ProxyServer) handleGetWorkRPC(cs *Session, diff, id string) (reply []string, errorReply *ErrorReply) {\n\tt := s.currentBlockTemplate()\n\tif len(t.Header) == 0 {\n\t\treturn nil, &ErrorReply{Code: -1, Message: \"Work not ready\"}\n\t}\n\ttargetHex := t.Target\n\n\tif !s.rpc().Pool {\n\t\tminerDifficulty, err := strconv.ParseFloat(diff, 64)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Invalid difficulty %v from %v@%v \", diff, id, cs.ip)\n\t\t\tminerDifficulty = 5\n\t\t}\n\t\ttargetHex = util.MakeTargetHex(minerDifficulty)\n\t}\n\treply = []string{t.Header, t.Seed, targetHex}\n\treturn\n}\n\nfunc (s *ProxyServer) handleSubmitRPC(cs *Session, diff string, id string, params []string) (reply bool, errorReply *ErrorReply) {\n\tminer, ok := s.miners.Get(id)\n\tif !ok {\n\t\tminer = NewMiner(id, cs.ip)\n\t\ts.registerMiner(miner)\n\t}\n\n\tt := s.currentBlockTemplate()\n\treply = miner.processShare(s, t, diff, params)\n\treturn\n}\n\nfunc (s *ProxyServer) handleSubmitHashrate(cs *Session, req *JSONRpcReq) bool {\n\treply, _ := s.rpc().SubmitHashrate(req.Params)\n\treturn reply\n}\n\n\n\nfunc (s *ProxyServer) handleUnknownRPC(cs *Session, req *JSONRpcReq) *ErrorReply ", "output": "{\n\tlog.Printf(\"Unknown RPC method: %v\", req)\n\treturn &ErrorReply{Code: -1, Message: \"Invalid method\"}\n}"}
{"input": "package weibo\n\nimport \"github.com/7sDream/rikka/common/util\"\n\n\n\nfunc (wbp weiboPlugin) Init() ", "output": "{\n\tl.Info(\"Start plugin weibo\")\n\n\tcookiesStr := util.GetEnvWithCheck(\"Cookies\", cookiesEnvKey, l)\n\n\tclient = newWeiboClient()\n\n\tif err := updateCookies(cookiesStr); err != nil {\n\t\tl.Fatal(\"Error happened when create cookies:\", err)\n\t}\n\n\tl.Info(\"Arg update cookies password =\", *argUpdateCookiesPassword)\n\n\tl.Info(\"Weibo plugin start successfully\")\n}"}
{"input": "package schedule_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/donutloop/toolkit/schedule\"\n)\n\n\n\nfunc Example() ", "output": "{\n\ts := schedule.NewFIFOScheduler()\n\tdefer s.Stop()\n\n\tjob := func(ctx context.Context) {\n\t\tfmt.Println(\"create db entry\")\n\t}\n\n\tif err := s.Schedule(job); err != nil {\n\t\tfmt.Printf(\"error: (%v) \\n\", err)\n\t}\n\n\ts.WaitFinish(1)\n\n}"}
{"input": "package unix\n\n\nfunc Major(dev uint64) uint32 {\n\treturn uint32((dev >> 8) & 0xff)\n}\n\n\n\n\n\n\nfunc Mkdev(major, minor uint32) uint64 {\n\treturn (uint64(major) << 8) | uint64(minor)\n}\n\nfunc Minor(dev uint64) uint32 ", "output": "{\n\treturn uint32(dev & 0xffff00ff)\n}"}
{"input": "package utils\n\nimport \"time\"\n\nconst (\n\tDateFormat = \"yyyy-MM-dd hh:mm:ss\"\n\tTimeLayout = \"2006-01-02 15:04:05\"\n\tDateLayout = \"2006-01-02\"\n)\n\n\n\nfunc Date() string {\n\treturn time.Now().Format(\"2006-01-02\")\n}\n\nfunc Now() string ", "output": "{\n\treturn time.Now().Format(\"2006-01-02 15:04:05\")\n}"}
{"input": "package keymutex\n\nimport (\n\t\"hash/fnv\"\n\t\"runtime\"\n\t\"sync\"\n)\n\n\n\n\n\n\nfunc NewHashed(n int) KeyMutex {\n\tif n <= 0 {\n\t\tn = runtime.NumCPU()\n\t}\n\treturn &hashedKeyMutex{\n\t\tmutexes: make([]sync.Mutex, n),\n\t}\n}\n\ntype hashedKeyMutex struct {\n\tmutexes []sync.Mutex\n}\n\n\nfunc (km *hashedKeyMutex) LockKey(id string) {\n\tkm.mutexes[km.hash(id)%len(km.mutexes)].Lock()\n}\n\n\n\n\nfunc (km *hashedKeyMutex) hash(id string) int {\n\th := fnv.New32a()\n\th.Write([]byte(id))\n\treturn int(h.Sum32())\n}\n\nfunc (km *hashedKeyMutex) UnlockKey(id string) error ", "output": "{\n\tkm.mutexes[km.hash(id)%len(km.mutexes)].Unlock()\n\treturn nil\n}"}
{"input": "package exec\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\n\t\"github.com/concourse/atc\"\n\t\"github.com/tedsuo/ifrit\"\n)\n\ntype FileNotFoundError struct {\n\tPath string\n}\n\nfunc (err FileNotFoundError) Error() string {\n\treturn fmt.Sprintf(\"file not found: %s\", err.Path)\n}\n\n\n\ntype Step interface {\n\tifrit.Runner\n\n\tRelease()\n\tResult(interface{}) bool\n}\n\ntype SourceName string\n\n\n\ntype ArtifactSource interface {\n\tStreamTo(ArtifactDestination) error\n\tStreamFile(path string) (io.ReadCloser, error)\n}\n\n\n\ntype ArtifactDestination interface {\n\tStreamIn(string, io.Reader) error\n}\n\ntype Success bool\n\ntype ExitStatus int\n\ntype VersionInfo struct {\n\tVersion  atc.Version\n\tMetadata []atc.MetadataField\n}\n\ntype NoopStep struct{}\n\nfunc (NoopStep) Run(<-chan os.Signal, chan<- struct{}) error {\n\treturn nil\n}\n\nfunc (NoopStep) Release() {}\n\nfunc (NoopStep) Result(interface{}) bool {\n\treturn false\n}\n\n\n\nfunc (NoopStep) StreamFile(path string) (io.ReadCloser, error) {\n\treturn nil, FileNotFoundError{Path: path}\n}\n\nfunc (NoopStep) StreamTo(ArtifactDestination) error ", "output": "{\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/minio/cli\"\n\t\"github.com/minio/mc/pkg/console\"\n\t\"github.com/minio/minio-xl/pkg/probe\"\n)\n\n\nvar versionCmd = cli.Command{\n\tName:   \"version\",\n\tUsage:  \"Print version.\",\n\tAction: mainVersion,\n\tCustomHelpTemplate: `NAME:\n   mc {{.Name}} - {{.Usage}}\n\nUSAGE:\n   mc {{.Name}}\n\n`,\n}\n\n\n\nfunc mainVersion(ctx *cli.Context) {\n\tif ctx.Args().First() == \"help\" {\n\t\tcli.ShowCommandHelpAndExit(ctx, \"version\", 1) \n\t}\n\n\tsetVersionPalette(ctx.GlobalString(\"colors\"))\n\n\tif globalJSONFlag {\n\t\ttB, e := json.Marshal(\n\t\t\tstruct {\n\t\t\t\tVersion struct {\n\t\t\t\t\tValue  string `json:\"value\"`\n\t\t\t\t\tFormat string `json:\"format\"`\n\t\t\t\t} `json:\"version\"`\n\t\t\t}{\n\t\t\t\tVersion: struct {\n\t\t\t\t\tValue  string `json:\"value\"`\n\t\t\t\t\tFormat string `json:\"format\"`\n\t\t\t\t}{\n\t\t\t\t\tValue:  mcVersion,\n\t\t\t\t\tFormat: \"RFC2616\",\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\t\tfatalIf(probe.NewError(e), \"Unable to construct version string.\")\n\t\tconsole.Println(string(tB))\n\t\treturn\n\t}\n\tmsg := console.Colorize(\"Version\", fmt.Sprintf(\"Version: %s\\n\", mcVersion))\n\tmsg += console.Colorize(\"Version\", fmt.Sprintf(\"Release-Tag: %s\", mcReleaseTag))\n\tconsole.Println(msg)\n}\n\nfunc setVersionPalette(style string) ", "output": "{\n\tconsole.SetCustomPalette(map[string]*color.Color{\n\t\t\"Version\": color.New(color.FgGreen, color.Bold),\n\t})\n\tif style == \"light\" {\n\t\tconsole.SetCustomPalette(map[string]*color.Color{\n\t\t\t\"Version\": color.New(color.FgWhite, color.Bold),\n\t\t})\n\t\treturn\n\t}\n\tif style == \"nocolor\" {\n\t\tconsole.SetNoColor()\n\t}\n}"}
{"input": "package cmd\n\nimport (\n\t\"errors\"\n\t\"os\"\n\n\t\"github.com/codegangsta/cli\"\n\n\t\"github.com/DevMine/srctool/config\"\n\t\"github.com/DevMine/srctool/log\"\n)\n\n\nfunc Delete(c *cli.Context) {\n\tif !c.Args().Present() {\n\t\tdeleteAll(c.Bool(\"dry\"))\n\t} else {\n\t\tif err := deleteParser(genParserName(c.Args().First()), c.Bool(\"dry\"), true); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc deleteAll(dryMode bool) {\n\tparsers := getInstalledParsers()\n\tfor _, parser := range parsers {\n\t\tif err := deleteParser(genParserName(parser), dryMode, true); err != nil {\n\t\t\tlog.Fail(err)\n\t\t}\n\t}\n}\n\n\n\nfunc deleteParser(parserName string, dryMode bool, verbose bool) error ", "output": "{\n\tparserPath := config.ParserPath(parserName)\n\n\tif _, err := os.Stat(parserPath); os.IsNotExist(err) {\n\t\tlog.Debug(err)\n\t\treturn errors.New(parserName + \" is not installed\")\n\t}\n\n\tif dryMode {\n\t\tlog.Info(\"parser path:\", parserPath)\n\t\treturn nil\n\t}\n\n\tlog.Debug(\"removing \", parserPath)\n\tif err := os.RemoveAll(parserPath); err != nil {\n\t\tlog.Debug(err)\n\t\treturn errors.New(\"failed to remove \" + parserName)\n\t}\n\n\tif verbose {\n\t\tlog.Success(parserName, \" successfully removed\")\n\t}\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/tobscher/kiss/configuration\"\n)\n\nfunc main() {\n\tbio := bufio.NewReader(os.Stdin)\n\tbytes, _, err := bio.ReadLine()\n\tif err != nil {\n\t\texitWithError(err)\n\t}\n\n\tvar task configuration.Task\n\terr = json.Unmarshal(bytes, &task)\n\tif err != nil {\n\t\texitWithError(err)\n\t}\n\n\terr = RunTask(&task)\n\tif err != nil {\n\t\texitWithError(err)\n\t}\n\n\tos.Exit(0)\n}\n\n\n\nfunc exitWithError(err error) ", "output": "{\n\tfmt.Fprintln(os.Stderr, err)\n\tos.Exit(1)\n}"}
{"input": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\n\t\"gopkg.in/yaml.v2\"\n)\n\nvar configFileOptions map[string]interface{}\n\nfunc LoadConfigFile(file string) error {\n\tconfigFileOptions = nil\n\tif _, err := os.Stat(file); err != nil {\n\t\treturn nil\n\t}\n\tif s, err := ioutil.ReadFile(file); err != nil {\n\t\treturn err\n\t} else if err := yaml.Unmarshal(s, &configFileOptions); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc getConfigFileValue(key string) interface{} {\n\tif v, ok := configFileOptions[key]; ok {\n\t\treturn v\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc IsKeyInConfig(key string) bool {\n\t_, ok := configFileOptions[key]\n\treturn ok\n}\n\n\n\n\n\nfunc GetConfigFileSlice(key string) []string {\n\tif v, ok := configFileOptions[key].([]interface{}); ok {\n\t\tretVal := []string{}\n\t\tfor _, e := range v {\n\t\t\tif strV, ok := e.(string); ok {\n\t\t\t\tretVal = append(retVal, strV)\n\t\t\t}\n\t\t}\n\t\treturn retVal\n\t} else {\n\t\treturn []string{}\n\t}\n}\n\nfunc GetConfigFileString(key string) string {\n\tv, _ := getConfigFileValue(key).(string)\n\treturn v\n}\n\nfunc GetConfigFileStringWithDefault(key string, defaultValue interface{}) string {\n\tv, _ := getConfigFileValueWithDefault(key, defaultValue).(string)\n\treturn v\n}\n\nfunc getConfigFileValueWithDefault(key string, defaultValue interface{}) interface{} ", "output": "{\n\tif v := getConfigFileValue(key); v != nil {\n\t\treturn v\n\t} else {\n\t\treturn defaultValue\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/niubaoshu/gotiny\"\n)\n\ntype A struct {\n\tName     string\n\tBirthDay time.Time\n\tPhone    string\n\tSiblings int\n\tSpouse   bool\n\tMoney    float64\n}\n\nfunc BenchmarkGotinyMarshal(b *testing.B) {\n\tb.StopTimer()\n\tdata := generate()\n\tb.ReportAllocs()\n\te := gotiny.NewEncoder(A{})\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\te.Encode(data[rand.Intn(len(data))])\n\t}\n}\n\nfunc generate() []*A {\n\ta := make([]*A, 0, 1000)\n\tfor i := 0; i < 1000; i++ {\n\t\ta = append(a, &A{\n\t\t\tName:     randString(16),\n\t\t\tBirthDay: time.Now(),\n\t\t\tPhone:    randString(10),\n\t\t\tSiblings: rand.Intn(5),\n\t\t\tSpouse:   rand.Intn(2) == 1,\n\t\t\tMoney:    rand.Float64(),\n\t\t})\n\t}\n\treturn a\n}\n\n\n\nfunc randString(l int) string ", "output": "{\n\tbuf := make([]byte, l)\n\tfor i := 0; i < (l+1)/2; i++ {\n\t\tbuf[i] = byte(rand.Intn(256))\n\t}\n\treturn fmt.Sprintf(\"%x\", buf)[:l]\n}"}
{"input": "package abcjson\n\nconst (\n\tAccountBalanceNtfnMethod = \"accountbalance\"\n\n\tBtcdConnectedNtfnMethod = \"abcdconnected\"\n\n\tWalletLockStateNtfnMethod = \"walletlockstate\"\n\n\tNewTxNtfnMethod = \"newtx\"\n)\n\n\ntype AccountBalanceNtfn struct {\n\tAccount   string\n\tBalance   float64 \n\tConfirmed bool    \n}\n\n\n\nfunc NewAccountBalanceNtfn(account string, balance float64, confirmed bool) *AccountBalanceNtfn {\n\treturn &AccountBalanceNtfn{\n\t\tAccount:   account,\n\t\tBalance:   balance,\n\t\tConfirmed: confirmed,\n\t}\n}\n\n\ntype BtcdConnectedNtfn struct {\n\tConnected bool\n}\n\n\n\nfunc NewBtcdConnectedNtfn(connected bool) *BtcdConnectedNtfn {\n\treturn &BtcdConnectedNtfn{\n\t\tConnected: connected,\n\t}\n}\n\n\ntype WalletLockStateNtfn struct {\n\tLocked bool\n}\n\n\n\n\n\n\ntype NewTxNtfn struct {\n\tAccount string\n\tDetails ListTransactionsResult\n}\n\n\n\nfunc NewNewTxNtfn(account string, details ListTransactionsResult) *NewTxNtfn {\n\treturn &NewTxNtfn{\n\t\tAccount: account,\n\t\tDetails: details,\n\t}\n}\n\nfunc init() {\n\tflags := UFWalletOnly | UFWebsocketOnly | UFNotification\n\n\tMustRegisterCmd(AccountBalanceNtfnMethod, (*AccountBalanceNtfn)(nil), flags)\n\tMustRegisterCmd(BtcdConnectedNtfnMethod, (*BtcdConnectedNtfn)(nil), flags)\n\tMustRegisterCmd(WalletLockStateNtfnMethod, (*WalletLockStateNtfn)(nil), flags)\n\tMustRegisterCmd(NewTxNtfnMethod, (*NewTxNtfn)(nil), flags)\n}\n\nfunc NewWalletLockStateNtfn(locked bool) *WalletLockStateNtfn ", "output": "{\n\treturn &WalletLockStateNtfn{\n\t\tLocked: locked,\n\t}\n}"}
{"input": "package sandbox\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"text/template\"\n\n\t\"ireul.com/com\"\n)\n\nconst tplSeedSSH = `#!/bin/bash\n# create /root/.ssh\nmkdir -p /root/.ssh\nchmod 700 /root/.ssh\ncd /root/.ssh\n\n# write keys\necho \"{{.PublicKey}}\"  > id_rsa.pub\nchmod 644 id_rsa.pub\necho \"{{.PrivateKey}}\" > id_rsa\nchmod 600 id_rsa\n\n# write README\necho \"id_rsa 和 id_rsa.pub 受 Bunker 管理，请勿修改\" > README\n`\n\nconst tplSSHConfig = `#!/bin/bash\n# remove .ssh/config\nrm -f /root/.ssh/config\n\n# create new .ssh/config\n{{range .Entries}}\necho \"Host {{.Name}}\" >> /root/.ssh/config\necho \"  HostName {{.Host}}\" >> /root/.ssh/config\necho \"  Port {{.Port}}\" >> /root/.ssh/config\necho \"  User {{.User}}\" >> /root/.ssh/config\n{{end}}\n`\n\n\ntype SSHEntry struct {\n\tName string\n\tHost string\n\tPort uint\n\tUser string\n}\n\nfunc createScript(name string, tmpl string, data com.Map) string {\n\tt, err := template.New(name).Parse(tmpl)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tbuf := &bytes.Buffer{}\n\tt.Execute(buf, data)\n\treturn buf.String()\n}\n\nfunc scriptSeedSSH(publicKey string, privateKey string) string {\n\treturn createScript(\n\t\t\"seed-ssh\",\n\t\ttplSeedSSH,\n\t\tcom.NewMap(\"PublicKey\", publicKey, \"PrivateKey\", privateKey),\n\t)\n}\n\n\n\n\nfunc ScriptSeedSSHConfig(entries []SSHEntry) string ", "output": "{\n\treturn createScript(\n\t\t\"seed-ssh-config\",\n\t\ttplSSHConfig,\n\t\tcom.NewMap(\"Entries\", entries),\n\t)\n}"}
{"input": "package res\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/jinzhu/gorm\"\n)\n\ntype Error struct {\n\tTitle         string `json:\"title\"`\n\tDetail        string `json:\"detail\"`\n\tOriginalError error  `json:\"original-error\"`\n}\n\nfunc Data(data interface{}) gin.H {\n\tif dbData, ok := data.(*gorm.DB); ok {\n\t\tdata = dbData.Value\n\t}\n\n\treturn gin.H{\n\t\t\"data\": data,\n\t}\n}\n\n\n\nfunc Err(errs ...Error) gin.H ", "output": "{\n\tvar allErrs []Error\n\tfor _, err := range errs {\n\t\tallErrs = append(allErrs, err)\n\t}\n\n\treturn gin.H{\n\t\t\"errors\": allErrs,\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\ntype ErrorResponse struct {\n\tErrors []string `json:\"errors\"`\n}\n\n\n\nfunc ReturnError(w http.ResponseWriter, r *http.Request, status int, e ...error) ", "output": "{\n\ter := &ErrorResponse{Errors: make([]string, len(e))}\n\tfor i, err := range e {\n\t\ter.Errors[i] = err.Error()\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"text/json; charset=utf-8\")\n\tw.WriteHeader(status)\n\tjsonResponse, _ := json.Marshal(er)\n\tw.Write(jsonResponse)\n}"}
{"input": "package schema\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/GoogleCloudPlatform/heapster/store\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\nfunc TestLatestTimestamp(t *testing.T) {\n\tassert := assert.New(t)\n\tpast := time.Unix(1434212566, 0)\n\tfuture := time.Unix(1434212800, 0)\n\tassert.Equal(latestTimestamp(past, future), future)\n\tassert.Equal(latestTimestamp(future, past), future)\n\tassert.Equal(latestTimestamp(future, future), future)\n}\n\n\n\n\nfunc TestNewInfoType(t *testing.T) ", "output": "{\n\tvar (\n\t\tmetrics = make(map[string]*store.TimeStore)\n\t\tlabels  = make(map[string]string)\n\t)\n\tnew_store := store.NewGCStore(store.NewTimeStore(), time.Hour)\n\tmetrics[\"test\"] = &new_store\n\tlabels[\"name\"] = \"test\"\n\tassert := assert.New(t)\n\n\tnew_infotype := newInfoType(nil, nil)\n\tassert.Empty(new_infotype.Metrics)\n\tassert.Empty(new_infotype.Labels)\n\n\tnew_infotype = newInfoType(metrics, labels)\n\tassert.Equal(new_infotype.Metrics, metrics)\n\tassert.Equal(new_infotype.Labels, labels)\n}"}
{"input": "package types\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nvar (\n\t_TriggerTypeNameToValue = map[string]TriggerType{\n\t\t\"TriggerTypeDefault\": TriggerTypeDefault,\n\t\t\"TriggerTypePoll\":    TriggerTypePoll,\n\t}\n\n\t_TriggerTypeValueToName = map[TriggerType]string{\n\t\tTriggerTypeDefault: \"TriggerTypeDefault\",\n\t\tTriggerTypePoll:    \"TriggerTypePoll\",\n\t}\n)\n\nfunc init() {\n\tvar v TriggerType\n\tif _, ok := interface{}(v).(fmt.Stringer); ok {\n\t\t_TriggerTypeNameToValue = map[string]TriggerType{\n\t\t\tinterface{}(TriggerTypeDefault).(fmt.Stringer).String(): TriggerTypeDefault,\n\t\t\tinterface{}(TriggerTypePoll).(fmt.Stringer).String():    TriggerTypePoll,\n\t\t}\n\t}\n}\n\n\n\n\n\nfunc (r *TriggerType) UnmarshalJSON(data []byte) error {\n\tvar s string\n\tif err := json.Unmarshal(data, &s); err != nil {\n\t\treturn fmt.Errorf(\"TriggerType should be a string, got %s\", data)\n\t}\n\tv, ok := _TriggerTypeNameToValue[s]\n\tif !ok {\n\t\treturn fmt.Errorf(\"invalid TriggerType %q\", s)\n\t}\n\t*r = v\n\treturn nil\n}\n\nfunc (r TriggerType) MarshalJSON() ([]byte, error) ", "output": "{\n\tif s, ok := interface{}(r).(fmt.Stringer); ok {\n\t\treturn json.Marshal(s.String())\n\t}\n\ts, ok := _TriggerTypeValueToName[r]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"invalid TriggerType: %d\", r)\n\t}\n\treturn json.Marshal(s)\n}"}
{"input": "package cache\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gopkg.in/mgo.v2/bson\"\n\t\"github.com/garyburd/redigo/redis\"\n)\n\nvar (\n\tnewsIndexKeySlice = []string{\"index\", \"ids\", \"jp\"}\n)\n\n\n\n\n\n\nfunc RetrieveCachedNews(key string, redisPool *redis.Pool) ([]bson.ObjectId, error) {\n\tstart := time.Now()\n\tfmt.Println(\"retrieving news index ids from cached news\")\n\tconn := redisPool.Get()\n\tdefer conn.Close()\n\n\tresult, err := redis.Strings(conn.Do(\"LRANGE\", key, 0, -1))\n\tif err != nil {\n\t\tvar x []bson.ObjectId\n\t\treturn x, err\n\t}\n\tfmt.Println(\"indexnewsids took: \", time.Since(start))\n\treversed := ReverseSlice(result...)\n\treturn convStrID(reversed...), nil\n}\n\n\n\nfunc RedisKeyGen(keys ...string) string {\n\treturn strings.Join(keys, \":\")\n}\n\n\nfunc convStrID(IDs ...string) []bson.ObjectId {\n\tvar objID []bson.ObjectId\n\tfor _, i := range IDs {\n\t\tobjID = append(objID, bson.ObjectIdHex(i))\n\t}\n\treturn objID\n}\n\n\nfunc ReverseSlice(s ...string) []string {\n\tfor i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n\t\ts[i], s[j] = s[j], s[i]\n\t}\n\treturn s\n}\n\nfunc IndexNewsIDS(redisPool *redis.Pool, newsIDChan chan []bson.ObjectId) ", "output": "{\n\tstart := time.Now()\n\tfmt.Println(\"retrieving news index ids on TODO\")\n\tconn := redisPool.Get()\n\tdefer conn.Close()\n\n\tkey := RedisKeyGen(newsIndexKeySlice...)\n\tresult, err := redis.Strings(conn.Do(\"LRANGE\", key, 0, -1))\n\tif err != nil {\n\t\tvar x []bson.ObjectId\n\t\tnewsIDChan <- x\n\t}\n\tfmt.Println(\"indexnewsids took: \", time.Since(start))\n\treversed := ReverseSlice(result...)\n\tnewsIDChan <- convStrID(reversed...)\n}"}
{"input": "package glacier\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/rdwilliamson/aws\"\n)\n\n\ntype Connection struct {\n\tClient *http.Client\n\n\tSignature *aws.Signature\n}\n\nfunc (c *Connection) client() *http.Client {\n\tif c.Client == nil {\n\t\treturn http.DefaultClient\n\t}\n\treturn c.Client\n}\n\n\nfunc (c *Connection) vault(vault string) string {\n\treturn \"https://\" + c.Signature.Region.Glacier + \"/-/vaults/\" + vault\n}\n\n\nfunc (c *Connection) policy(policy string) string {\n\treturn \"https://\" + c.Signature.Region.Glacier + \"/-/policies/\" + policy\n}\n\n\n\nfunc NewConnection(secret, access string, r *aws.Region) *Connection {\n\treturn &Connection{\n\t\tSignature: aws.NewSignature(secret, access, r, \"glacier\"),\n\t}\n}\n\n\n\n\nfunc toHex(x []byte) string {\n\treturn fmt.Sprintf(\"%x\", x)\n}\n\n\n\ntype parameters url.Values\n\n\n\nfunc (p parameters) add(key, value string) {\n\turl.Values(p).Add(key, value)\n}\n\n\n\n\n\nfunc (p parameters) encode() string ", "output": "{\n\tif encoded := url.Values(p).Encode(); encoded != \"\" {\n\t\treturn \"?\" + encoded\n\t}\n\treturn \"\"\n}"}
{"input": "package big\n\nfunc mulWW(x, y Word) (z1, z0 Word) {\n\treturn mulWW_g(x, y)\n}\n\n\n\nfunc addVV(z, x, y []Word) (c Word) {\n\treturn addVV_g(z, x, y)\n}\n\nfunc subVV(z, x, y []Word) (c Word) {\n\treturn subVV_g(z, x, y)\n}\n\nfunc addVW(z, x []Word, y Word) (c Word) {\n\treturn addVW_g(z, x, y)\n}\n\nfunc subVW(z, x []Word, y Word) (c Word) {\n\treturn subVW_g(z, x, y)\n}\n\nfunc shlVU(z, x []Word, s uint) (c Word) {\n\treturn shlVU_g(z, x, s)\n}\n\nfunc shrVU(z, x []Word, s uint) (c Word) {\n\treturn shrVU_g(z, x, s)\n}\n\nfunc mulAddVWW(z, x []Word, y, r Word) (c Word) {\n\treturn mulAddVWW_g(z, x, y, r)\n}\n\nfunc addMulVVW(z, x []Word, y Word) (c Word) {\n\treturn addMulVVW_g(z, x, y)\n}\n\nfunc divWVW(z []Word, xn Word, x []Word, y Word) (r Word) {\n\treturn divWVW_g(z, xn, x, y)\n}\n\nfunc bitLen(x Word) (n int) {\n\treturn bitLen_g(x)\n}\n\nfunc divWW(x1, x0, y Word) (q, r Word) ", "output": "{\n\treturn divWW_g(x1, x0, y)\n}"}
{"input": "package feedfind\n\nimport (\n\t\"testing\"\n)\n\nfunc find(gots []string, expecteds ...string) bool {\n\tcount := 0\n\tfor _, expected := range expecteds {\n\t\tfor _, got := range gots {\n\t\t\tif expected == got {\n\t\t\t\tcount++\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif count == len(expecteds) {\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}\n\nfunc TestHatenablog(t *testing.T) {\n\tfeeds, err := Find(\"http://shibayu36.hatenablog.com/\")\n\tif err != nil {\n\t\tt.Errorf(\"Can't find rss at hatenablog\")\n\t}\n\n\texpecteds := []string{\n\t\t\"http://shibayu36.hatenablog.com/feed\",\n\t\t\"http://shibayu36.hatenablog.com/rss\",\n\t}\n\n\tif !find(feeds, expecteds...) {\n\t\tt.Errorf(\"Can't find '/feed' and '/rss'\")\n\t}\n}\n\n\n\nfunc TestMattn(t *testing.T) {\n\tfeeds, err := Find(\"http://mattn.kaoriya.net/\")\n\tif err != nil {\n\t\tt.Errorf(\"Can't find rss at mattn blog\")\n\t}\n\n\texpecteds := []string{\n\t\t\"http://mattn.kaoriya.net/index.rss\",\n\t}\n\tif !find(feeds, expecteds...) {\n\t\tt.Errorf(\"Can't find feed URL\")\n\t}\n}\n\nfunc TestLivedoor(t *testing.T) ", "output": "{\n\tfeeds, err := Find(\"http://blog.livedoor.jp/xaicron\")\n\tif err != nil {\n\t\tt.Errorf(\"Can't find rss at livedoor blog\")\n\t}\n\n\texpecteds := []string{\n\t\t\"http://blog.livedoor.jp/xaicron/index.rdf\",\n\t\t\"http://blog.livedoor.jp/xaicron/atom.xml\",\n\t}\n\tif !find(feeds, expecteds...) {\n\t\tt.Errorf(\"Can't find 'rss' and 'atom'\")\n\t}\n}"}
{"input": "package filetype\n\nimport (\n\t\"encoding/json\"\n\n\tyaml \"gopkg.in/yaml.v2\"\n)\n\n\n\nfunc IsYAML(in string) bool {\n\tvar y yaml.MapSlice\n\treturn yaml.Unmarshal([]byte(in), &y) == nil\n}\n\nfunc IsJSON(in string) bool ", "output": "{\n\tvar js json.RawMessage\n\treturn json.Unmarshal([]byte(in), &js) == nil\n}"}
{"input": "package ble\n\nimport (\n\t\"bytes\"\n\n\t\"gobot.io/x/gobot\"\n)\n\n\ntype BatteryDriver struct {\n\tname       string\n\tconnection gobot.Connection\n\tgobot.Eventer\n}\n\n\nfunc NewBatteryDriver(a *ClientAdaptor) *BatteryDriver {\n\tn := &BatteryDriver{\n\t\tname:       gobot.DefaultName(\"Battery\"),\n\t\tconnection: a,\n\t\tEventer:    gobot.NewEventer(),\n\t}\n\n\treturn n\n}\n\n\n\n\n\nfunc (b *BatteryDriver) Name() string { return b.name }\n\n\nfunc (b *BatteryDriver) SetName(n string) { b.name = n }\n\n\nfunc (b *BatteryDriver) adaptor() *ClientAdaptor {\n\treturn b.Connection().(*ClientAdaptor)\n}\n\n\nfunc (b *BatteryDriver) Start() (err error) {\n\treturn\n}\n\n\nfunc (b *BatteryDriver) Halt() (err error) { return }\n\n\nfunc (b *BatteryDriver) GetBatteryLevel() (level uint8) {\n\tvar l uint8\n\tc, _ := b.adaptor().ReadCharacteristic(\"2a19\")\n\tbuf := bytes.NewBuffer(c)\n\tval, _ := buf.ReadByte()\n\tl = uint8(val)\n\treturn l\n}\n\nfunc (b *BatteryDriver) Connection() gobot.Connection ", "output": "{ return b.connection }"}
{"input": "package deb\n\nimport (\n\t\"encoding/binary\"\n\t\"github.com/smira/aptly/aptly\"\n\t\"github.com/smira/aptly/utils\"\n\t\"hash/fnv\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n)\n\n\ntype PackageFile struct {\n\tFilename string\n\tChecksums utils.ChecksumInfo\n\tdownloadPath string\n}\n\n\nfunc (f *PackageFile) Verify(packagePool aptly.PackagePool) (bool, error) {\n\tpoolPath, err := packagePool.Path(f.Filename, f.Checksums.MD5)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tst, err := os.Stat(poolPath)\n\tif err != nil {\n\t\treturn false, nil\n\t}\n\n\treturn st.Size() == f.Checksums.Size, nil\n}\n\n\nfunc (f *PackageFile) DownloadURL() string {\n\treturn filepath.Join(f.downloadPath, f.Filename)\n}\n\n\ntype PackageFiles []PackageFile\n\n\nfunc (files PackageFiles) Hash() uint64 {\n\tsort.Sort(files)\n\n\th := fnv.New64a()\n\n\tfor _, f := range files {\n\t\th.Write([]byte(f.Filename))\n\t\tbinary.Write(h, binary.BigEndian, f.Checksums.Size)\n\t\th.Write([]byte(f.Checksums.MD5))\n\t\th.Write([]byte(f.Checksums.SHA1))\n\t\th.Write([]byte(f.Checksums.SHA256))\n\t}\n\n\treturn h.Sum64()\n}\n\n\n\n\n\nfunc (files PackageFiles) Swap(i, j int) {\n\tfiles[i], files[j] = files[j], files[i]\n}\n\n\nfunc (files PackageFiles) Less(i, j int) bool {\n\treturn files[i].Filename < files[j].Filename\n}\n\nfunc (files PackageFiles) Len() int ", "output": "{\n\treturn len(files)\n}"}
{"input": "package fake\n\nimport (\n\tv1 \"github.com/kubeflow/training-operator/pkg/client/clientset/versioned/typed/tensorflow/v1\"\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n)\n\ntype FakeKubeflowV1 struct {\n\t*testing.Fake\n}\n\n\n\n\n\nfunc (c *FakeKubeflowV1) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakeKubeflowV1) TFJobs(namespace string) v1.TFJobInterface ", "output": "{\n\treturn &FakeTFJobs{c, namespace}\n}"}
{"input": "package parser\n\nimport (\n\t\"sip/core\"\n\t\"sip/header\"\n\t\"strings\"\n)\n\n\ntype SubjectParser struct {\n\tHeaderParser\n}\n\n\nfunc NewSubjectParser(subject string) *SubjectParser {\n\tthis := &SubjectParser{}\n\tthis.HeaderParser.super(subject)\n\treturn this\n}\n\n\nfunc NewSubjectParserFromLexer(lexer core.Lexer) *SubjectParser {\n\tthis := &SubjectParser{}\n\tthis.HeaderParser.superFromLexer(lexer)\n\treturn this\n}\n\n\n\n\nfunc (this *SubjectParser) Parse() (sh header.Header, ParseException error) ", "output": "{\n\tsubject := header.NewSubject()\n\n\tlexer := this.GetLexer()\n\tthis.HeaderName(TokenTypes_SUBJECT)\n\n\tlexer.SPorHT()\n\n\ts := lexer.GetRest()\n\tsubject.SetSubject(strings.TrimSpace(s))\n\n\treturn subject, nil\n}"}
{"input": "package hpdf\n\n\nimport \"C\"\n\ntype TransMatrix struct {\n\tA float32\n\tB float32\n\tC float32\n\tD float32\n\tX float32\n\tY float32\n}\n\n\n\nfunc transMatrixFromHPDFTransMatrix(transMatrix C.HPDF_TransMatrix) *TransMatrix ", "output": "{\n\treturn &TransMatrix{\n\t\tfloat32(transMatrix.a),\n\t\tfloat32(transMatrix.b),\n\t\tfloat32(transMatrix.c),\n\t\tfloat32(transMatrix.d),\n\t\tfloat32(transMatrix.x),\n\t\tfloat32(transMatrix.y),\n\t}\n}"}
{"input": "package backend\n\nimport \"github.com/DiscoViking/roguemike/api\"\n\ntype Action interface {\n\tapply(actor *Actor, state *GameState)\n}\n\n\ntype ActionMove struct {\n\tDX int\n\tDY int\n}\n\n\n\nfunc (action *ActionMove) apply(actor *Actor, state *GameState) ", "output": "{\n    if (state.IsTraversable(api.Coords{actor.X + action.DX, actor.Y + action.DY})) {\n        actor.X += action.DX\n        actor.Y += action.DY\n    }\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSCloudFrontDistribution_ViewerCertificate struct {\n\n\tAcmCertificateArn string `json:\"AcmCertificateArn,omitempty\"`\n\n\tCloudFrontDefaultCertificate bool `json:\"CloudFrontDefaultCertificate,omitempty\"`\n\n\tIamCertificateId string `json:\"IamCertificateId,omitempty\"`\n\n\tMinimumProtocolVersion string `json:\"MinimumProtocolVersion,omitempty\"`\n\n\tSslSupportMethod string `json:\"SslSupportMethod,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) AWSCloudFormationType() string {\n\treturn \"AWS::CloudFront::Distribution.ViewerCertificate\"\n}\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\n\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSCloudFrontDistribution_ViewerCertificate) Metadata() map[string]interface{} ", "output": "{\n\treturn r._metadata\n}"}
{"input": "package oauth\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-martini/martini\"\n\t\"github.com/itpkg/web/settings\"\n\t\"github.com/itpkg/web/token\"\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/martini-contrib/render\"\n)\n\n\nconst ADMIN = \"admin\"\n\n\nfunc GoogleHandler(c martini.Context, sp settings.Provider, r render.Render) {\n\tvar g Google\n\tif err := sp.Get(\"oauth.google\", &g); err == nil {\n\t\tc.Map(&g)\n\t} else {\n\t\tr.Text(http.StatusInternalServerError, err.Error())\n\t}\n}\n\n\n\n\n\nfunc AdminHandler(u *User, dao *Dao, r render.Render) {\n\tif !dao.Is(u.ID, ADMIN) {\n\t\tr.Error(http.StatusUnauthorized)\n\t}\n}\n\nfunc CurrentUserHandler(req *http.Request, db *gorm.DB, c martini.Context, j *token.Jwt, r render.Render) ", "output": "{\n\td, e := j.ParseFromRequest(req)\n\tvar u User\n\tif e == nil {\n\t\te = db.Where(\"uid = ?\", d[\"id\"]).First(&u).Error\n\t}\n\tif e == nil {\n\t\tif u.IsAvailable() {\n\t\t\tc.Map(&u)\n\t\t} else {\n\t\t\tr.Error(http.StatusUnauthorized)\n\t\t}\n\n\t} else {\n\t\tr.Text(http.StatusInternalServerError, e.Error())\n\t}\n}"}
{"input": "package gnuflag\n\nimport (\n\t\"strconv\"\n)\n\n\ntype uintValue uint\n\n\n\nfunc (u uintValue) Get() interface{} { return uint(u) }\n\nfunc (u uintValue) String() string { return strconv.FormatUint(uint64(u), 10) }\n\n\n\nfunc (f *FlagSet) Uint(name string, usage string, options ...Option) *uint {\n\tp := new(uint)\n\tif err := f.Var((*uintValue)(p), name, usage, options...); err != nil {\n\t\tpanic(err)\n\t}\n\treturn p\n}\n\n\n\nfunc Uint(name string, usage string, options ...Option) *uint {\n\treturn CommandLine.Uint(name, usage, options...)\n}\n\n\ntype uint64Value uint64\n\nfunc (u *uint64Value) Set(s string) error {\n\tv, err := strconv.ParseUint(s, 0, 64)\n\t*u = uint64Value(v)\n\treturn err\n}\n\nfunc (u uint64Value) Get() interface{} { return uint64(u) }\n\nfunc (u uint64Value) String() string { return strconv.FormatUint(uint64(u), 10) }\n\n\n\nfunc (f *FlagSet) Uint64(name string, usage string, options ...Option) *uint64 {\n\tp := new(uint64)\n\tif err := f.Var((*uint64Value)(p), name, usage, options...); err != nil {\n\t\tpanic(err)\n\t}\n\treturn p\n}\n\n\n\nfunc Uint64(name string, usage string, options ...Option) *uint64 {\n\treturn CommandLine.Uint64(name, usage, options...)\n}\n\nfunc (u *uintValue) Set(s string) error ", "output": "{\n\tv, err := strconv.ParseUint(s, 0, strconv.IntSize)\n\t*u = uintValue(v)\n\treturn err\n}"}
{"input": "package main\n\nimport (\n\t\"bytes\"\n\t\"github.com/murlokswarm/app\"\n)\n\n\ntype MenuWindow struct{}\n\n\n\n\nfunc (m *MenuWindow) Render() string {\n\tvar content bytes.Buffer\n\terr := Templates.ExecuteTemplate(&content, \"menu-window\", m)\n\tif err != nil {\n\t\tStderr.Println(err)\n\t}\n\n\treturn content.String()\n}\n\nfunc init() ", "output": "{\n\tapp.RegisterComponent(&MenuWindow{})\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\ntype ContainerInstanceAttribute struct {\n\n\tName *string `json:\"name\"`\n\n\tValue *string `json:\"value\"`\n}\n\n\nfunc (m *ContainerInstanceAttribute) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateName(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateValue(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *ContainerInstanceAttribute) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (m *ContainerInstanceAttribute) validateValue(formats strfmt.Registry) error ", "output": "{\n\n\tif err := validate.Required(\"value\", \"body\", m.Value); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package main\n\nimport . \"g2d\"\n\nvar arena = NewArena(Point{480, 360})\nvar a1 = NewAlien(arena, Point{40, 40})\nvar a2 = NewAlien(arena, Point{80, 80})\n\ntype Alien struct {\n    arena      *Arena\n    x, y, w, h int\n    xmin, xmax int\n    dx, dy     int\n}\n\n\n\nfunc (a *Alien) Move() {\n    if a.xmin <= a.x+a.dx && a.x+a.dx <= a.xmax {\n        a.x += a.dx\n    } else {\n        a.dx = -a.dx\n        a.y += a.dy\n    }\n}\n\nfunc (a *Alien) Position() Point {\n    return Point{a.x, a.y}\n}\n\nfunc (a *Alien) Size() Point {\n    return Point{a.w, a.h}\n}\n\nfunc (a *Alien) Symbol() Point {\n    return Point{0, 0}\n}\n\nfunc (a *Alien) Collide(other Actor) {\n}\n\nfunc tick() {\n    ClearCanvas()\n    arena.MoveAll()\n    for _, actor := range arena.Actors()  {\n        FillRect(actor.Position(), actor.Size())\n    }\n}\n\nfunc main() {\n    InitCanvas(arena.Size())\n    MainLoop(tick)\n}\n\nfunc NewAlien(arena *Arena, pos Point) *Alien ", "output": "{\n    a := &Alien{arena, pos.X, pos.Y, 20, 20, pos.X, pos.X+150, 5, 5}\n    arena.Add(a)\n    return a\n}"}
{"input": "package libra\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n)\n\ntype validator struct {\n\tname string\n\tprogram\n\tstdin io.Reader\n}\n\nfunc (v validator) Name() string {\n\treturn v.name\n}\n\nfunc (v validator) Run() Status {\n\tstdout := new(bytes.Buffer)\n\tstderr := new(bytes.Buffer)\n\tv.program.cmd.Stdin = v.stdin\n\tv.program.cmd.Stdout = stdout\n\tv.program.cmd.Stderr = stderr\n\tres := v.program.Run()\n\tif res.Code != OK {\n\t\treturn Status{\n\t\t\tCode: RE,\n\t\t\tMsg:  fmt.Sprintf(\"%v\", stderr.String()),\n\t\t}\n\t}\n\treturn res\n}\n\ntype valJob struct {\n\tabstractJob\n\tinputs []Input\n}\n\n\ntype Input interface {\n\tName() string\n\tReader() io.Reader\n}\n\n\n\n\nfunc ValJob(src Src, inputs []Input) Job {\n\tret := valJob{}\n\tret.src = src\n\tret.inputs = inputs\n\treturn ret\n}\n\nfunc (job valJob) Subtasks() []Task ", "output": "{\n\tret := make([]Task, len(job.inputs))\n\tfor i, v := range job.inputs {\n\t\tprog, _ := newProgram(job.src.Exec)\n\t\tret[i] = validator{name: v.Name(), program: prog, stdin: v.Reader()}\n\t}\n\treturn ret\n}"}
{"input": "package usecases\n\nimport (\n\t\"errors\"\n\t\"github.com/GerardSoleCa/PubKeyManager/domain\"\n)\n\n\ntype KeyInteractor struct {\n\tKeyRepository domain.KeyRepository\n}\n\n\n\n\n\nfunc (interactor KeyInteractor) GetKeys() []domain.Key {\n\treturn interactor.KeyRepository.GetKeys()\n}\n\n\nfunc (interactor KeyInteractor) GetUserKeys(user string) []domain.Key {\n\treturn interactor.KeyRepository.GetUserKeys(user)\n}\n\n\nfunc (interactor KeyInteractor) DeleteKey(id int64) error {\n\treturn interactor.KeyRepository.Delete(id)\n}\n\nfunc (interactor KeyInteractor) AddKey(key *domain.Key) error ", "output": "{\n\tif len(key.Title) == 0 {\n\t\treturn errors.New(\"A title is required to store a ssh key\")\n\t}\n\tif len(key.User) == 0 {\n\t\treturn errors.New(\"A user is required to store a ssh key\")\n\t}\n\tif len(key.Key) == 0 {\n\t\treturn errors.New(\"A key is required\")\n\t}\n\tif err := key.CalculateFingerprint(); err != nil {\n\t\treturn err\n\t}\n\treturn interactor.KeyRepository.Store(key)\n}"}
{"input": "package githubsource\n\nimport (\n\tcontext \"context\"\n\n\tv1 \"k8s.io/api/core/v1\"\n\tv1alpha1 \"knative.dev/eventing-github/pkg/apis/sources/v1alpha1\"\n\tgithubsource \"knative.dev/eventing-github/pkg/client/injection/reconciler/sources/v1alpha1/githubsource\"\n\treconciler \"knative.dev/pkg/reconciler\"\n)\n\n\n\n\n\n\n\n\ntype Reconciler struct {\n}\n\n\nvar _ githubsource.Interface = (*Reconciler)(nil)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (r *Reconciler) ReconcileKind(ctx context.Context, o *v1alpha1.GitHubSource) reconciler.Event {\n\n\n\treturn newReconciledNormal(o.Namespace, o.Name)\n}\n\nfunc newReconciledNormal(namespace, name string) reconciler.Event ", "output": "{\n\treturn reconciler.NewEvent(v1.EventTypeNormal, \"GitHubSourceReconciled\", \"GitHubSource reconciled: \\\"%s/%s\\\"\", namespace, name)\n}"}
{"input": "package parser\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n)\n\ntype GoFile struct {\n\tPackage    string\n\tPath       string\n\tStructs    []*GoStruct\n\tInterfaces []*GoInterface\n\tImports    []*GoImport\n}\n\n\n\ntype GoImport struct {\n\tFile *GoFile\n\tName string\n\tPath string\n}\n\ntype GoInterface struct {\n\tFile    *GoFile\n\tName    string\n\tMethods []*GoMethod\n}\n\ntype GoMethod struct {\n\tName    string\n\tParams  []*GoType\n\tResults []*GoType\n}\n\ntype GoType struct {\n\tName       string\n\tType       string\n\tUnderlying string\n\tInner      []*GoType\n}\n\ntype GoStruct struct {\n\tFile   *GoFile\n\tName   string\n\tFields []*GoField\n}\n\ntype GoField struct {\n\tStruct *GoStruct\n\tName   string\n\tType   string\n\tTag    *GoTag\n}\n\ntype GoTag struct {\n\tField *GoField\n\tValue string\n}\n\nfunc (g *GoTag) Get(key string) string {\n\ttag := strings.Replace(g.Value, \"`\", \"\", -1)\n\treturn reflect.StructTag(tag).Get(key)\n}\n\n\n\n\n\n\n\nfunc (g *GoImport) Prefix() string {\n\tif g.Name != \"\" {\n\t\treturn g.Name\n\t}\n\n\tpath := strings.Trim(g.Path, \"\\\"\")\n\tlastSlash := strings.LastIndex(path, \"/\")\n\tif lastSlash == -1 {\n\t\treturn path\n\t}\n\n\treturn path[lastSlash+1:]\n}\n\nfunc (g *GoFile) ImportPath() (string, error) ", "output": "{\n\timportPath, err := filepath.Abs(g.Path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\timportPath = strings.Replace(importPath, \"\\\\\", \"/\", -1)\n\n\tgoPath := strings.Replace(os.Getenv(\"GOPATH\"), \"\\\\\", \"/\", -1)\n\timportPath = strings.TrimPrefix(importPath, goPath)\n\timportPath = strings.TrimPrefix(importPath, \"/src/\")\n\n\timportPath = strings.TrimSuffix(importPath, filepath.Base(importPath))\n\timportPath = strings.TrimSuffix(importPath, \"/\")\n\n\treturn importPath, nil\n}"}
{"input": "package healthcareapis\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\nfunc New(subscriptionID string) BaseClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient ", "output": "{\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}"}
{"input": "\n\nfunc mergeSort(nums []int, start, end int) int {\n    if end - start <= 1 {\n        return 0\n    }\n    mid := (start + end) >> 1\n    count := mergeSort(nums, start, mid) + mergeSort(nums, mid, end)\n    \n    buf := make([]int, end-start)\n    bufTail := 0\n    j, k := mid, mid\n    for i := start; i < mid; i++ {\n        for k < end && 2*nums[k] < nums[i] {\n            k++\n        }\n        for j < end && nums[j] < nums[i] {\n            buf[bufTail] = nums[j]\n            bufTail++\n            j++\n        }\n        buf[bufTail] = nums[i]\n        bufTail++\n        \n        count += k - mid\n    }\n    copy(nums[start:], buf[:bufTail])\n    \n    return count\n}\n\nfunc reversePairs(nums []int) int ", "output": "{\n    return mergeSort(nums, 0, len(nums))\n}"}
{"input": "package mw\n\nimport \"net/http\"\n\n\n\nfunc CorsHandler(h http.Handler) http.Handler ", "output": "{\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif origin := r.Header.Get(\"Origin\"); origin != \"\" {\n\t\t\tw.Header().Set(\"Access-Control-Allow-Origin\", origin)\n\t\t}\n\t\tw.Header().Set(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, PUT, PATCH, DELETE\")\n\t\tw.Header().Set(\"Access-Control-Request-Method\", \"*\")\n\t\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Origin, X-Requested-With, Accept, Authorization\")\n\t\tw.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\t\th.ServeHTTP(w, r)\n\t})\n}"}
{"input": "package s0045\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Answer() interface{} ", "output": "{\n\n\n\th := 143 + 1 \n\tp := 165\n\n\tfor {\n\t\thexa := h * (2*h - 1)\n\t\tpent := p * (3*p - 1) / 2\n\t\tif hexa < pent {\n\t\t\th++\n\t\t} else if pent < hexa {\n\t\t\tp++\n\t\t} else {\n\t\t\treturn pent\n\t\t}\n\t}\n}"}
{"input": "package iso20022\n\n\ntype TransactionTotals6 struct {\n\n\tAuthorisation *Number `xml:\"Authstn,omitempty\"`\n\n\tAuthorisationReversal *Number `xml:\"AuthstnRvsl,omitempty\"`\n\n\tInquiry *Number `xml:\"Nqry,omitempty\"`\n\n\tInquiryReversal *Number `xml:\"NqryRvsl,omitempty\"`\n\n\tPayments *Number `xml:\"Pmts,omitempty\"`\n\n\tPaymentReversal *Number `xml:\"PmtRvsl,omitempty\"`\n\n\tTransfer *Number `xml:\"Trf,omitempty\"`\n\n\tTransferReversal *Number `xml:\"TrfRvsl,omitempty\"`\n\n\tFeeCollection *Number `xml:\"FeeColltn,omitempty\"`\n}\n\nfunc (t *TransactionTotals6) SetAuthorisation(value string) {\n\tt.Authorisation = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetAuthorisationReversal(value string) {\n\tt.AuthorisationReversal = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetInquiry(value string) {\n\tt.Inquiry = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetInquiryReversal(value string) {\n\tt.InquiryReversal = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetPayments(value string) {\n\tt.Payments = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetPaymentReversal(value string) {\n\tt.PaymentReversal = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetTransfer(value string) {\n\tt.Transfer = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetTransferReversal(value string) {\n\tt.TransferReversal = (*Number)(&value)\n}\n\n\n\nfunc (t *TransactionTotals6) SetFeeCollection(value string) ", "output": "{\n\tt.FeeCollection = (*Number)(&value)\n}"}
{"input": "package proto\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/NebulousLabs/Sia/crypto\"\n\t\"github.com/NebulousLabs/Sia/modules\"\n\t\"github.com/NebulousLabs/Sia/types\"\n)\n\n\ntype (\n\ttransactionBuilder interface {\n\t\tAddFileContract(types.FileContract) uint64\n\t\tAddMinerFee(types.Currency) uint64\n\t\tAddParents([]types.Transaction)\n\t\tAddSiacoinInput(types.SiacoinInput) uint64\n\t\tAddSiacoinOutput(types.SiacoinOutput) uint64\n\t\tAddTransactionSignature(types.TransactionSignature) uint64\n\t\tFundSiacoins(types.Currency) error\n\t\tSign(bool) ([]types.Transaction, error)\n\t\tUnconfirmedParents() ([]types.Transaction, error)\n\t\tView() (types.Transaction, []types.Transaction)\n\t\tViewAdded() (parents, coins, funds, signatures []int)\n\t}\n\n\ttransactionPool interface {\n\t\tAcceptTransactionSet([]types.Transaction) error\n\t\tFeeEstimation() (min types.Currency, max types.Currency)\n\t}\n\n\thostDB interface {\n\t\tIncrementSuccessfulInteractions(key types.SiaPublicKey)\n\t\tIncrementFailedInteractions(key types.SiaPublicKey)\n\t}\n)\n\n\ntype ContractParams struct {\n\tHost          modules.HostDBEntry\n\tFunding       types.Currency\n\tStartHeight   types.BlockHeight\n\tEndHeight     types.BlockHeight\n\tRefundAddress types.UnlockHash\n}\n\n\n\ntype revisionSaver func(types.FileContractRevision, []crypto.Hash) error\n\n\n\ntype recentRevisionError struct {\n\tours, theirs uint64\n}\n\nfunc (e *recentRevisionError) Error() string {\n\treturn fmt.Sprintf(\"our revision number (%v) does not match the host's (%v)\", e.ours, e.theirs)\n}\n\n\n\n\n\nfunc IsRevisionMismatch(err error) bool ", "output": "{\n\t_, ok := err.(*recentRevisionError)\n\treturn ok\n}"}
{"input": "package limit\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n\n\th \"github.com/bakins/test-helpers\"\n)\n\n\n\n\n\nfunc TestHandler(t *testing.T) {\n\tl := New(time.Second, 2)\n\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tfmt.Fprint(w, \"Hello World\\n\")\n\t})\n\n\tw := httptest.NewRecorder()\n\n\tl.Handler(handler).ServeHTTP(w, newRequest(\"GET\", \"/foo\"))\n\n\th.Assert(t, w.Body.String() == \"Hello World\\n\", \"body does not match\")\n\n}\n\nfunc newRequest(method, url string) *http.Request ", "output": "{\n\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn req\n}"}
{"input": "package blake2b\n\nimport \"golang.org/x/sys/cpu\"\n\n\n\n\nfunc hashBlocksAVX2(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)\n\n\nfunc hashBlocksAVX(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)\n\n\nfunc hashBlocksSSE4(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)\n\nfunc hashBlocks(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte) {\n\tswitch {\n\tcase useAVX2:\n\t\thashBlocksAVX2(h, c, flag, blocks)\n\tcase useAVX:\n\t\thashBlocksAVX(h, c, flag, blocks)\n\tcase useSSE4:\n\t\thashBlocksSSE4(h, c, flag, blocks)\n\tdefault:\n\t\thashBlocksGeneric(h, c, flag, blocks)\n\t}\n}\n\nfunc init() ", "output": "{\n\tuseAVX2 = cpu.X86.HasAVX2\n\tuseAVX = cpu.X86.HasAVX\n\tuseSSE4 = cpu.X86.HasSSE41\n}"}
{"input": "package test\n\nimport (\n\t\"io/ioutil\"\n)\n\n\n\nfunc Fixture(path string) string ", "output": "{\n\tcontents, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(contents)\n}"}
{"input": "package task\n\nimport (\n\t\"nirenjan.org/overlord/cli\"\n\t\"nirenjan.org/overlord/util\"\n)\n\nfunc registerShowHandler(root *cli.Command) error {\n\tcmd := cli.Cmd{\n\t\tCommand:   \"show\",\n\t\tUsage:     \"[id]\",\n\t\tBriefHelp: \"show task detailed view\",\n\t\tLongHelp: `\nShow the detailed view of the specified task. If the ID is not specified,\nthen show all pending tasks.\n`,\n\t\tHandler: showHandler,\n\t\tArgs:    cli.AtMost,\n\t\tCount:   1,\n\t}\n\n\t_, err := cli.RegisterCommand(root, cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\nfunc showHandler(cmd *cli.Command, args []string) error ", "output": "{\n\terr := LoadDb()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tout := util.NewPager()\n\tdefer out.Show()\n\n\tif len(args) == 1 {\n\t\ttasks := sortedTaskList()\n\n\t\tfor _, task := range tasks {\n\t\t\ttask, err = ReadFile(task.Path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\ttask.Show(out)\n\t\t}\n\t} else {\n\t\tvar task Task\n\t\ttask, err = getTask(args[1])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttask.Show(out)\n\t}\n\n\treturn nil\n}"}
{"input": "package handler\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/goharbor/harbor/src/jobservice/job\"\n\tlibhttp \"github.com/goharbor/harbor/src/lib/http\"\n\t\"github.com/goharbor/harbor/src/pkg/task\"\n)\n\n\nfunc NewJobStatusHandler() http.Handler {\n\treturn &jobStatusHandler{\n\t\thandler: task.HkHandler,\n\t}\n}\n\ntype jobStatusHandler struct {\n\thandler *task.HookHandler\n}\n\n\n\nfunc (j *jobStatusHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tdefer r.Body.Close()\n\n\tsc := &job.StatusChange{}\n\tif err := json.NewDecoder(r.Body).Decode(sc); err != nil {\n\t\tlibhttp.SendError(w, err)\n\t\treturn\n\t}\n\tif err := j.handler.Handle(r.Context(), sc); err != nil {\n\t\tlibhttp.SendError(w, err)\n\t\treturn\n\t}\n}"}
{"input": "package util\n\nimport (\n\t\"reflect\"\n\n\t\"k8s.io/kubernetes/pkg/api/v1\"\n)\n\n\n\n\nfunc ObjectMetaIsEquivalent(m1, m2 v1.ObjectMeta) bool ", "output": "{\n\tm1.SelfLink = m2.SelfLink                   \n\tm1.UID = m2.UID                             \n\tm1.ResourceVersion = m2.ResourceVersion     \n\tm1.Generation = m2.Generation               \n\tm1.CreationTimestamp = m2.CreationTimestamp \n\tm1.DeletionTimestamp = m2.DeletionTimestamp \n\tm1.OwnerReferences = nil                    \n\tm2.OwnerReferences = nil\n\tm1.Finalizers = nil \n\tm2.Finalizers = nil\n\n\treturn reflect.DeepEqual(m1, m2)\n}"}
{"input": "package kasper\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestTopicProcessorConfig_producerClientID(t *testing.T) {\n\tc := &Config{\n\t\tTopicProcessorName: \"ford-prefect\",\n\t}\n\tassert.Equal(t, \"kasper-topic-processor-ford-prefect\", c.producerClientID())\n}\n\nfunc TestTopicProcessorConfig_kafkaConsumerGroup(t *testing.T) ", "output": "{\n\tc := &Config{\n\t\tTopicProcessorName: \"hari-seldon\",\n\t}\n\tassert.Equal(t, \"kasper-topic-processor-hari-seldon\", c.kafkaConsumerGroup())\n}"}
{"input": "package mocks\n\nimport (\n\t\"io\"\n\n\t\"github.com/crawsible/crawsibot/irc\"\n\t\"github.com/crawsible/crawsibot/irc/message\"\n)\n\ntype FakeSender struct {\n\tStartSendingCalls  int\n\tStartSendingWriter io.Writer\n\tStartSendingEcdr   irc.Encoder\n\tSendCh             chan *message.Message\n\n\tSendCalls int\n\tSendArgs  [][]string\n}\n\n\n\nfunc (s *FakeSender) Send(cmd, fprms, prms string) {\n\ts.SendCalls += 1\n\ts.SendArgs = append(s.SendArgs, []string{cmd, fprms, prms})\n}\n\nfunc (s *FakeSender) StartSending(wtr io.Writer, ecdr irc.Encoder) ", "output": "{\n\ts.StartSendingCalls += 1\n\ts.StartSendingWriter = wtr\n\ts.StartSendingEcdr = ecdr\n}"}
{"input": "package commands\n\nimport (\n    \"errors\"\n\n    \"../wski18n\"\n    \"../../go-whisk/whisk\"\n)\n\nfunc entityNameError(entityName string) (error) {\n    errMsg := wski18n.T(\n        \"An entity name, '{{.name}}', was provided instead of a namespace. Valid namespaces are of the following format: /NAMESPACE.\",\n        map[string]interface{}{\n            \"name\": entityName,\n        })\n\n    return whisk.MakeWskError(errors.New(errMsg), whisk.EXITCODE_ERR_GENERAL, whisk.DISPLAY_MSG, whisk.DISPLAY_USAGE)\n}\n\n\n\nfunc parseQualifiedNameError(entityName string, err error) (error) ", "output": "{\n    whisk.Debug(whisk.DbgError, \"parseQualifiedName(%s) failed: %s\\n\", entityName, err)\n\n    errMsg := wski18n.T(\n        \"'{{.name}}' is not a valid qualified name: {{.err}}\",\n        map[string]interface{}{\n            \"name\": entityName,\n            \"err\": err,\n        })\n\n    return whisk.MakeWskError(errors.New(errMsg), whisk.EXITCODE_ERR_GENERAL, whisk.DISPLAY_MSG, whisk.DISPLAY_USAGE)\n}"}
{"input": "package filter\n\nimport \"reflect\"\n\ntype Filter interface {\n\tCompare(Filter) bool\n\tTrigger(data interface{})\n}\n\ntype FilterEvent struct {\n\tfilter Filter\n\tdata   interface{}\n}\n\ntype Filters struct {\n\tid       int\n\twatchers map[int]Filter\n\tch       chan FilterEvent\n\n\tquit chan struct{}\n}\n\nfunc New() *Filters {\n\treturn &Filters{\n\t\tch:       make(chan FilterEvent),\n\t\twatchers: make(map[int]Filter),\n\t\tquit:     make(chan struct{}),\n\t}\n}\n\nfunc (self *Filters) Start() {\n\tgo self.loop()\n}\n\nfunc (self *Filters) Stop() {\n\tclose(self.quit)\n}\n\nfunc (self *Filters) Notify(filter Filter, data interface{}) {\n\tself.ch <- FilterEvent{filter, data}\n}\n\nfunc (self *Filters) Install(watcher Filter) int {\n\tself.watchers[self.id] = watcher\n\tself.id++\n\n\treturn self.id - 1\n}\n\nfunc (self *Filters) Uninstall(id int) {\n\tdelete(self.watchers, id)\n}\n\n\n\nfunc (self *Filters) Match(a, b Filter) bool {\n\treturn reflect.TypeOf(a) == reflect.TypeOf(b) && a.Compare(b)\n}\n\nfunc (self *Filters) Get(i int) Filter {\n\treturn self.watchers[i]\n}\n\nfunc (self *Filters) loop() ", "output": "{\nout:\n\tfor {\n\t\tselect {\n\t\tcase <-self.quit:\n\t\t\tbreak out\n\t\tcase event := <-self.ch:\n\t\t\tfor _, watcher := range self.watchers {\n\t\t\t\tif reflect.TypeOf(watcher) == reflect.TypeOf(event.filter) {\n\t\t\t\t\tif watcher.Compare(event.filter) {\n\t\t\t\t\t\twatcher.Trigger(event.data)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}
{"input": "package update\n\nimport (\n\t\"os\"\n\n\t\"github.com/pkg/term\"\n\t\"golang.org/x/sys/unix\"\n)\n\n\n\n\nfunc getChar() (ascii int, keyCode int, err error) {\n\tt, _ := term.Open(\"/dev/tty\")\n\tterm.RawMode(t)\n\tbs := make([]byte, 3)\n\n\tvar numRead int\n\tnumRead, err = t.Read(bs)\n\tif err != nil {\n\t\treturn\n\t}\n\tif numRead == 3 && bs[0] == 27 && bs[1] == 91 {\n\n\t\tif bs[2] == 65 {\n\t\t\tkeyCode = 38\n\t\t} else if bs[2] == 66 {\n\t\t\tkeyCode = 40\n\t\t} else if bs[2] == 67 {\n\t\t\tkeyCode = 39\n\t\t} else if bs[2] == 68 {\n\t\t\tkeyCode = 37\n\t\t}\n\t} else if numRead == 1 {\n\t\tascii = int(bs[0])\n\t} else {\n\t}\n\tt.Restore()\n\tt.Close()\n\treturn\n}\n\nfunc terminalWidth() uint16 ", "output": "{\n\tws, _ := unix.IoctlGetWinsize(int(os.Stdout.Fd()), unix.TIOCGWINSZ)\n\tif ws != nil && ws.Col != 0 {\n\t\treturn ws.Col\n\t}\n\treturn 9999\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\n\tbh \"github.com/kandoo/beehive\"\n)\n\nconst (\n\thelloDict = \"HelloDictionary\"\n\n\treplicationFactor = 2\n)\n\n\ntype Hello struct {\n\tName string \n}\n\n\ntype Broad struct {\n\tID int \n}\n\n\n\n\nfunc hmapf(msg bh.Msg, ctx bh.MapContext) bh.MappedCells {\n\treturn bh.MappedCells{\n\t\tbh.CellKey{\n\t\t\tDict: helloDict,\n\t\t\tKey:  msg.Data().(Hello).Name,\n\t\t},\n\t}\n}\n\nfunc brcvf(msg bh.Msg, ctx bh.RcvContext) error {\n\tctx.Printf(\"broad[%v] message %d was received\\n\", msg.IsBroadCast(), msg.Data().(Broad).ID)\n\n\treturn nil\n}\n\nfunc bmapf(msg bh.Msg, ctx bh.MapContext) bh.MappedCells {\n\treturn bh.MappedCells{{}}\n}\n\nfunc main() {\n\tapp := bh.NewApp(\"hello-world\", bh.Persistent(replicationFactor))\n\n\tif err := app.HandleFunc(Hello{}, hmapf, hrcvf); err != nil {\n\t\tlog.Fatalf(\"Hello Handle Func: %s\", err)\n\t}\n\n\tif err := app.HandleFunc(Broad{}, bmapf, brcvf); err != nil {\n\t\tlog.Fatalf(\"Board Handle Func: %s\", err)\n\t}\n\n\tgo bh.Emit(Hello{Name: \"Parham Alvani\"})\n\n\tgo bh.Emit(Hello{Name: \"HamidReza Alvani\"})\n\n\tgo bh.Emit(Broad{ID: 1})\n\n\tif err := bh.Start(); err != nil {\n\t\tlog.Fatalf(\"Start: %s\", err)\n\t}\n}\n\nfunc hrcvf(msg bh.Msg, ctx bh.RcvContext) error ", "output": "{\n\thello := msg.Data().(Hello)\n\n\tdict := ctx.Dict(helloDict)\n\n\tv, err := dict.Get(hello.Name)\n\n\tcnt := 0\n\tif err == nil {\n\t\tcnt = v.(int)\n\t}\n\n\tcnt++\n\n\tctx.Printf(\"hello %s (%d)!\\n\", hello.Name, cnt)\n\n\treturn dict.Put(hello.Name, cnt)\n}"}
{"input": "package app\n\nimport (\n\t\"k8s.io/kubernetes/pkg/controller/disruption\"\n\t\"k8s.io/kubernetes/pkg/runtime/schema\"\n)\n\n\n\nfunc startDisruptionController(ctx ControllerContext) (bool, error) ", "output": "{\n\tif !ctx.AvailableResources[schema.GroupVersionResource{Group: \"policy\", Version: \"v1beta1\", Resource: \"poddisruptionbudgets\"}] {\n\t\treturn false, nil\n\t}\n\tgo disruption.NewDisruptionController(\n\t\tctx.InformerFactory.Pods().Informer(),\n\t\tctx.ClientBuilder.ClientOrDie(\"disruption-controller\"),\n\t).Run(ctx.Stop)\n\treturn true, nil\n}"}
{"input": "package itsyouonline\n\nimport (\n\t\"net/http\"\n)\n\nconst (\n\tdefaultBaseURI = \"https://itsyou.online/api\"\n)\n\ntype Itsyouonline struct {\n\tclient     http.Client\n\tAuthHeader string \n\tBaseURI    string\n\tcommon     service \n\n\tOrganizations *OrganizationsService\n\tUsers         *UsersService\n}\n\ntype service struct {\n\tclient *Itsyouonline\n}\n\n\n\nfunc NewItsyouonline() *Itsyouonline ", "output": "{\n\tc := &Itsyouonline{\n\t\tBaseURI: defaultBaseURI,\n\t\tclient:  http.Client{},\n\t}\n\tc.common.client = c\n\n\tc.Organizations = (*OrganizationsService)(&c.common)\n\tc.Users = (*UsersService)(&c.common)\n\n\treturn c\n}"}
{"input": "package format\n\nimport (\n\t\"encoding/base64\"\n\n\t\"gollum/core\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype Base64Encode struct {\n\tcore.SimpleFormatter `gollumdoc:\"embed_type\"`\n\tdictionary           *base64.Encoding\n}\n\nfunc init() {\n\tcore.TypeRegistry.Register(Base64Encode{})\n}\n\n\nfunc (format *Base64Encode) Configure(conf core.PluginConfigReader) {\n\tdict := conf.GetString(\"Dictionary\", \"\")\n\tif dict == \"\" {\n\t\tformat.dictionary = base64.StdEncoding\n\t} else {\n\t\tif len(dict) != 64 {\n\t\t\tconf.Errors.Pushf(\"Base64 dictionary must contain 64 characters.\")\n\t\t}\n\t\tformat.dictionary = base64.NewEncoding(dict)\n\t}\n}\n\n\n\n\nfunc (format *Base64Encode) getEncodedContent(content []byte) []byte {\n\tencodedLen := format.dictionary.EncodedLen(len(content))\n\tencoded := make([]byte, encodedLen)\n\n\tformat.dictionary.Encode(encoded, content)\n\treturn encoded\n}\n\nfunc (format *Base64Encode) ApplyFormatter(msg *core.Message) error ", "output": "{\n\tencoded := format.getEncodedContent(format.GetSourceDataAsBytes(msg))\n\tformat.SetTargetData(msg, encoded)\n\n\treturn nil\n}"}
{"input": "package netest\n\nimport \"net\"\n\n\nfunc Listen() net.Listener {\n\tlistener, err := net.Listen(\"tcp\", \"[::1]:\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn listener\n}\n\n\nfunc BrokenListener(err error) net.Listener {\n\treturn broken{err}\n}\n\nfunc (b broken) Accept() (net.Conn, error) {\n\treturn nil, b.error\n}\n\nfunc (broken) Addr() net.Addr {\n\treturn nil\n}\n\n\n\ntype broken struct {\n\terror\n}\n\nfunc (broken) Close() error ", "output": "{\n\treturn nil\n}"}
{"input": "package kms\n\nimport (\n\t\"os\"\n\n\t\"github.com/denverdino/aliyungo/common\"\n)\n\nconst (\n\tKMSDefaultEndpoint = \"https://kms.cn-hangzhou.aliyuncs.com\"\n\tKMSAPIVersion      = \"2016-01-20\"\n\tKMSServiceCode     = \"kms\"\n)\n\ntype Client struct {\n\tcommon.Client\n}\n\n\nfunc NewClient(accessKeyId, accessKeySecret string) *Client {\n\tendpoint := os.Getenv(\"KMS_ENDPOINT\")\n\tif endpoint == \"\" {\n\t\tendpoint = KMSDefaultEndpoint\n\t}\n\treturn NewClientWithEndpoint(endpoint, accessKeyId, accessKeySecret)\n}\n\nfunc NewClientWithRegion(accessKeyId string, accessKeySecret string, regionID common.Region) *Client {\n\tendpoint := os.Getenv(\"KMS_ENDPOINT\")\n\tif endpoint == \"\" {\n\t\tendpoint = KMSDefaultEndpoint\n\t}\n\tclient := &Client{}\n\tclient.NewInit(endpoint, KMSAPIVersion, accessKeyId, accessKeySecret, KMSServiceCode, regionID)\n\treturn client\n}\n\nfunc NewClientWithEndpoint(endpoint string, accessKeyId string, accessKeySecret string) *Client {\n\tclient := &Client{}\n\tclient.Init(endpoint, KMSAPIVersion, accessKeyId, accessKeySecret)\n\treturn client\n}\n\n\n\nfunc NewKMSClientWithEndpointAndSecurityToken(endpoint string, accessKeyId string, accessKeySecret string, securityToken string, regionID common.Region) *Client {\n\tclient := &Client{}\n\tclient.WithEndpoint(endpoint).\n\t\tWithVersion(KMSAPIVersion).\n\t\tWithAccessKeyId(accessKeyId).\n\t\tWithAccessKeySecret(accessKeySecret).\n\t\tWithSecurityToken(securityToken).\n\t\tWithServiceCode(KMSServiceCode).\n\t\tWithRegionID(regionID).\n\t\tInitClient()\n\treturn client\n}\n\nfunc NewECSClientWithSecurityToken(accessKeyId string, accessKeySecret string, securityToken string, regionID common.Region) *Client ", "output": "{\n\tendpoint := os.Getenv(\"KMS_ENDPOINT\")\n\tif endpoint == \"\" {\n\t\tendpoint = KMSDefaultEndpoint\n\t}\n\n\treturn NewKMSClientWithEndpointAndSecurityToken(endpoint, accessKeyId, accessKeySecret, securityToken, regionID)\n}"}
{"input": "package chroot\n\nimport (\n\t\"io\"\n\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/pkg/errors\"\n)\n\n\n\n\nfunc RunUsingChroot(spec *specs.Spec, bundlePath string, stdin io.Reader, stdout, stderr io.Writer) (err error) ", "output": "{\n\treturn errors.Errorf(\"--isolation chroot is not supported on this platform\")\n}"}
{"input": "package time2\n\nimport (\n\t\"time\"\n)\n\ntype Timer struct {\n\tC <-chan time.Time\n\tr *timer\n}\n\n\n\nfunc Sleep(d time.Duration) {\n\tdefaultWheel.Sleep(d)\n}\n\nfunc AfterFunc(d time.Duration, f func()) *Timer {\n\treturn defaultWheel.AfterFunc(d, f)\n}\n\nfunc NewTimer(d time.Duration) *Timer {\n\treturn defaultWheel.NewTimer(d)\n}\n\nfunc (t *Timer) Reset(d time.Duration) {\n\tt.r.w.resetTimer(t.r, d, 0)\n}\n\nfunc (t *Timer) Stop() {\n\tt.r.w.delTimer(t.r)\n}\n\nfunc After(d time.Duration) <-chan time.Time ", "output": "{\n\treturn defaultWheel.After(d)\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n\t\"net/http\"\n)\n\n\ntype ListFastConnectProviderVirtualCircuitBandwidthShapesRequest struct {\n\n\tProviderServiceId *string `mandatory:\"true\" contributesTo:\"path\" name:\"providerServiceId\"`\n\n\tLimit *int `mandatory:\"false\" contributesTo:\"query\" name:\"limit\"`\n\n\tPage *string `mandatory:\"false\" contributesTo:\"query\" name:\"page\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request ListFastConnectProviderVirtualCircuitBandwidthShapesRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request ListFastConnectProviderVirtualCircuitBandwidthShapesRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ListFastConnectProviderVirtualCircuitBandwidthShapesResponse struct {\n\n\tRawResponse *http.Response\n\n\tItems []VirtualCircuitBandwidthShape `presentIn:\"body\"`\n\n\tOpcNextPage *string `presentIn:\"header\" name:\"opc-next-page\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response ListFastConnectProviderVirtualCircuitBandwidthShapesResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response ListFastConnectProviderVirtualCircuitBandwidthShapesResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request ListFastConnectProviderVirtualCircuitBandwidthShapesRequest) HTTPRequest(method, path string) (http.Request, error) ", "output": "{\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}"}
{"input": "package dataModels\n\nimport \"testing\"\n\n\n\nfunc TestNewVacancyStats_PassNotNullToBothSalaries_InitSalaries(t *testing.T) {\n\tsalaryFrom := 1000.0\n\tsalaryTo := 10000.0\n\tstat := NewVacancyStats(\"1\", \"example.com\", &salaryFrom, &salaryTo, \"RUB\", \"css\")\n\tif stat.SalaryFrom != salaryFrom || stat.SalaryTo != salaryTo {\n\t\tt.Errorf(\"Salaries expected to be %f and %f, but were %f and %f\",\n\t\t\tsalaryFrom, salaryTo, stat.SalaryFrom, salaryTo)\n\t}\n}\n\nfunc TestNewVacancyStats_PassNotNullToSalaryFrom_SalaryFromMustBeEqualSalaryTo(t *testing.T) {\n\tsalaryTo := 10000.0\n\tstat := NewVacancyStats(\"1\", \"example.com\", nil, &salaryTo, \"RUB\", \"css\")\n\tif stat.SalaryFrom != stat.SalaryTo {\n\t\tt.Errorf(\"SalaryFrom expected to be %f, but was %f\", stat.SalaryTo, stat.SalaryFrom)\n\t}\n}\n\nfunc TestNewVacancyStats_PassNotNullToSalaryTo_SalaryToMustBeEqualSalaryFrom(t *testing.T) {\n\tsalaryFrom := 10000.0\n\tstat := NewVacancyStats(\"1\", \"example.com\", &salaryFrom, nil, \"RUB\", \"css\")\n\tif stat.SalaryTo != stat.SalaryFrom {\n\t\tt.Errorf(\"SalaryTo expected to be %f, but was %f\", stat.SalaryFrom, stat.SalaryTo)\n\t}\n}\n\nfunc TestNewVacancyStats_PassNullToBothSalaries_SalariesEqualZero(t *testing.T) ", "output": "{\n\tstat := NewVacancyStats(\"1\", \"example.com\", nil, nil, \"RUB\", \"css\")\n\tif stat.SalaryFrom != 0 || stat.SalaryTo != 0 {\n\t\tt.Error(\"Salaries expected to be zeros\")\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os/exec\"\n)\n\n\n\n\nfunc getPythonVersion() (string, error) ", "output": "{\n\tpy, err := exec.LookPath(\"python\")\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\n\t\t\t\"gopy: could not locate 'python' executable (err: %v)\",\n\t\t\terr,\n\t\t)\n\t}\n\n\tout, err := exec.Command(py, \"--version\").Output()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\n\t\t\t\"gopy: error retrieving python version (err: %v)\",\n\t\t\terr,\n\t\t)\n\t}\n\n\tvers := \"\"\n\tswitch {\n\tcase bytes.HasPrefix(out, []byte(\"Python 2\")):\n\t\tvers = \"py2\"\n\tcase bytes.HasPrefix(out, []byte(\"Python 3\")):\n\t\tvers = \"py3\"\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\n\t\t\t\"gopy: invalid python version (%s)\",\n\t\t\tstring(out),\n\t\t)\n\t}\n\n\treturn vers, nil\n}"}
{"input": "package readline\n\nimport \"io\"\n\ntype Instance struct {\n\tt *Terminal\n\to *Operation\n}\n\ntype Config struct {\n\tPrompt      string\n\tHistoryFile string\n}\n\nfunc NewEx(cfg *Config) (*Instance, error) {\n\tt, err := NewTerminal(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trl := t.Readline()\n\treturn &Instance{\n\t\tt: t,\n\t\to: rl,\n\t}, nil\n}\n\nfunc New(prompt string) (*Instance, error) {\n\treturn NewEx(&Config{Prompt: prompt})\n}\n\nfunc (i *Instance) Stdout() io.Writer {\n\treturn i.o.Stdout()\n}\n\n\n\nfunc (i *Instance) Readline() (string, error) {\n\treturn i.o.String()\n}\n\nfunc (i *Instance) ReadSlice() ([]byte, error) {\n\treturn i.o.Slice()\n}\n\nfunc (i *Instance) Close() error {\n\tif err := i.t.Close(); err != nil {\n\t\treturn err\n\t}\n\ti.o.Close()\n\treturn nil\n}\n\nfunc (i *Instance) Stderr() io.Writer ", "output": "{\n\treturn i.o.Stderr()\n}"}
{"input": "package readline\n\nimport \"io\"\n\ntype Instance struct {\n\tt *Terminal\n\to *Operation\n}\n\ntype Config struct {\n\tPrompt      string\n\tHistoryFile string\n}\n\nfunc NewEx(cfg *Config) (*Instance, error) {\n\tt, err := NewTerminal(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trl := t.Readline()\n\treturn &Instance{\n\t\tt: t,\n\t\to: rl,\n\t}, nil\n}\n\n\n\nfunc (i *Instance) Stderr() io.Writer {\n\treturn i.o.Stderr()\n}\n\nfunc (i *Instance) Readline() (string, error) {\n\treturn i.o.String()\n}\n\nfunc (i *Instance) ReadSlice() ([]byte, error) {\n\treturn i.o.Slice()\n}\n\nfunc (i *Instance) Close() error {\n\ti.o.Close()\n\treturn i.t.Close()\n}\n\nfunc (i *Instance) Write(b []byte) (int, error) {\n\treturn i.o.Stderr().Write(b)\n}\n\nfunc New(prompt string) (*Instance, error) ", "output": "{\n\treturn NewEx(&Config{Prompt: prompt})\n}"}
{"input": "package stateful\n\nimport \"sync\"\n\n\n\n\ntype ScopePool interface {\n\tGet() *Scope\n\tPut(scope *Scope)\n\n\tReferenceVariables() []string\n}\n\ntype scopePool struct {\n\treferenceVariables []string\n\tpool               sync.Pool\n}\n\n\nfunc NewScopePool(referenceVariables []string) ScopePool {\n\tscopePool := &scopePool{\n\t\treferenceVariables: referenceVariables,\n\t}\n\n\tscopePool.pool = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\tscope := NewScope()\n\t\t\tfor _, refVariable := range scopePool.referenceVariables {\n\t\t\t\tscope.Set(refVariable, empty)\n\t\t\t}\n\n\t\t\treturn scope\n\t\t},\n\t}\n\n\treturn scopePool\n}\n\n\n\n\n\nfunc (s *scopePool) Get() *Scope {\n\treturn s.pool.Get().(*Scope)\n}\n\n\nfunc (s *scopePool) Put(scope *Scope) {\n\tscope.Reset()\n\ts.pool.Put(scope)\n}\n\nfunc (s *scopePool) ReferenceVariables() []string ", "output": "{\n\treturn s.referenceVariables\n}"}
{"input": "package misc\n\nimport \"jvmgo/ch11/native\"\nimport \"jvmgo/ch11/rtda\"\n\n\n\n\n\nfunc getLookupCacheURLs(frame *rtda.Frame) {\n\tframe.OperandStack().PushRef(nil)\n}\n\nfunc init() ", "output": "{\n\tnative.Register(\"sun/misc/URLClassPath\", \"getLookupCacheURLs\", \"(Ljava/lang/ClassLoader;)[Ljava/net/URL;\", getLookupCacheURLs)\n}"}
{"input": "package test\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype MockProcess struct {\n\tname      string\n\texitAfter time.Duration\n\texitError error\n\tdelayCh   <-chan time.Time\n}\n\n\n\nfunc (p *MockProcess) Stop() error {\n\tp.delayCh = nil\n\treturn p.exitError\n}\n\nfunc (p *MockProcess) WaitRunning() bool {\n\treturn true\n}\n\nfunc (p *MockProcess) Wait() error {\n\tif p.exitAfter > time.Duration(0) {\n\t\t<-p.delayCh\n\t\tp.delayCh = nil\n\t} else {\n\t\t<-make(chan bool)\n\t}\n\treturn p.exitError\n}\n\nfunc (p *MockProcess) String() string {\n\treturn fmt.Sprintf(\"mock:%s\", p.name)\n}\n\nfunc (p *MockProcess) Logf(msg string, v ...interface{}) string {\n\tv = append([]interface{}{p.String()}, v...)\n\treturn fmt.Sprintf(\"[%s] \"+msg, v...)\n}\n\nfunc (p *MockProcess) Start() error ", "output": "{\n\tif p.delayCh != nil {\n\t\treturn fmt.Errorf(\"delayCh is already set\")\n\t}\n\tif p.exitAfter > time.Duration(0) {\n\t\tp.delayCh = time.After(p.exitAfter)\n\t}\n\treturn nil\n}"}
{"input": "package configuration\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/urfave/cli\"\n)\n\n\ntype Config struct {\n\tRunDelay   time.Duration `yaml:\"delay\"`\n\tDryRun     bool          `yaml:\"dry_run\"`\n\tRepository string        `yaml:\"repository\"`\n\tToken      string        `yaml:\"token\"`\n\tTokenFile  string        `yaml:\"token_file\"`\n}\n\n\ntype OperationConfiguration struct {\n\tType     string                 `yaml:\"type\"`\n\tFilters  map[string]interface{} `yaml:\"filters\"`\n\tSettings map[string]interface{} `yaml:\"settings\"`\n}\n\n\n\n\n\nfunc (c *Config) Validate() error {\n\tif _, _, err := getRepository(c.Repository); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\nfunc (c *Config) Delay() time.Duration {\n\treturn time.Duration(c.RunDelay.Seconds()) * time.Second\n}\n\n\nfunc FromGlobalFlags(c *cli.Context) *Config {\n\tconfig := &Config{\n\t\tDryRun:     c.GlobalBool(\"dry-run\"),\n\t\tRepository: c.GlobalString(\"repository\"),\n\t\tToken:      c.GlobalString(\"token\"),\n\t\tTokenFile:  c.GlobalString(\"token-file\"),\n\t}\n\treturn config\n}\n\nfunc getRepository(repository string) (string, string, error) {\n\ts := strings.SplitN(repository, \"/\", 2)\n\tif len(s) != 2 {\n\t\treturn \"\", \"\", errors.Errorf(\"invalid repository %q\", repository)\n\t}\n\treturn s[0], s[1], nil\n}\n\nfunc (c *Config) SplitRepository() (string, string) ", "output": "{\n\tusername, repository, err := getRepository(c.Repository)\n\tif err != nil {\n\t\tpanic(\"invalid repository\")\n\t}\n\treturn username, repository\n}"}
{"input": "package minus\n\nimport (\n  \"RETIA/unit\"\n  \"RETIA/messages\"\n)\n\n\nfunc Create(lrelation, rrelation *unit.Relation) *unit.MinusStatement {\n  if lrelation != nil && rrelation != nil && relationsTypeMatches(lrelation, rrelation) {\n    statement := new(unit.MinusStatement)\n\n    statement.Lrelation = lrelation\n    statement.Rrelation = rrelation\n\n    return statement\n  } else {\n    return nil\n  }\n}\n\n\nfunc Eval(statement *unit.MinusStatement) *unit.Relation {\n  if statement != nil {\n    relation := new(unit.Relation)\n\n    relation.Tname = statement.Lrelation.Tname\n\n    for _, l_tuple := range statement.Lrelation.Tuples {\n      present := false\n\n      for _, r_tuple := range statement.Rrelation.Tuples {\n        if l_tuple.Hash == r_tuple.Hash {\n          present = true\n          break\n        }\n      }\n\n      if !present {\n        relation.Tuples = append(relation.Tuples, l_tuple)\n      }\n    }\n\n    return relation\n  } else {\n    return nil\n  }\n}\n\n\n\n\nfunc relationsTypeMatches(lrelation, rrelation *unit.Relation) bool ", "output": "{\n  if lrelation.Tname == rrelation.Tname {\n    return true\n  } else {\n    messages.TypesMismatch()\n    return true\n  }\n}"}
{"input": "package installer\n\nimport (\n\t\"github.com/wx13/genesis\"\n)\n\n\n\ntype Custom struct {\n\tTask genesis.Doer\n\tS    func() (genesis.Status, error)\n\tD    func() (bool, error)\n\tU    func() (bool, error)\n\tI    func() string\n\tF    func() []string\n}\n\nfunc NewCustom(task genesis.Doer) *Custom {\n\tcustom := Custom{\n\t\tTask: task,\n\t\tS:    task.Status,\n\t\tD:    task.Do,\n\t\tU:    task.Undo,\n\t\tI:    task.ID,\n\t\tF:    task.Files,\n\t}\n\treturn &custom\n}\n\n\n\nfunc (custom Custom) Do() (bool, error) {\n\treturn custom.D()\n}\n\nfunc (custom Custom) Undo() (bool, error) {\n\treturn custom.U()\n}\n\nfunc (custom Custom) ID() string {\n\treturn custom.I()\n}\n\nfunc (custom Custom) Files() []string {\n\treturn custom.F()\n}\n\nfunc (custom Custom) Status() (genesis.Status, error) ", "output": "{\n\treturn custom.S()\n}"}
{"input": "package configparser\n\nimport (\n\t\"github.com/bigkevmcd/go-configparser/chainmap\"\n\n\t\"strings\"\n)\n\nfunc (p *ConfigParser) getInterpolated(section, option string, c *chainmap.ChainMap) (string, error) {\n\tval, err := p.Get(section, option)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn p.interpolate(val, c), nil\n}\n\n\n\n\n\nfunc (p *ConfigParser) GetInterpolated(section, option string) (string, error) {\n\to, err := p.Items(section)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tc := chainmap.New(chainmap.Dict(p.Defaults()), chainmap.Dict(o))\n\treturn p.getInterpolated(section, option, c)\n}\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (p *ConfigParser) interpolate(value string, options *chainmap.ChainMap) string {\n\n\tfor i := 0; i < maxInterpolationDepth; i++ {\n\t\tif strings.Contains(value, \"%(\") {\n\t\t\tvalue = interpolater.ReplaceAllStringFunc(value, func(m string) string {\n\t\t\t\tmatch := interpolater.FindAllStringSubmatch(m, 1)[0][1]\n\t\t\t\treplacement := options.Get(match)\n\t\t\t\treturn replacement\n\t\t\t})\n\t\t}\n\t}\n\treturn value\n}\n\n\nfunc (p *ConfigParser) ItemsWithDefaultsInterpolated(section string) (Dict, error) {\n\ts, err := p.ItemsWithDefaults(section)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor k, v := range s {\n\t\tv, err = p.GetInterpolated(section, k)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ts[k] = v\n\t}\n\treturn s, nil\n}\n\nfunc (p *ConfigParser) GetInterpolatedWithVars(section, option string, v Dict) (string, error) ", "output": "{\n\to, err := p.Items(section)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tc := chainmap.New(chainmap.Dict(p.Defaults()), chainmap.Dict(o), chainmap.Dict(v))\n\treturn p.getInterpolated(section, option, c)\n\n}"}
{"input": "package apihelper\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"github.com/mediocregopher/mediocre-api/common\"\n\t\"github.com/mediocregopher/mediocre-api/pickyjson\"\n)\n\n\n\n\nfunc ErrUnlessMethod(\n\tw http.ResponseWriter, r *http.Request, methods ...string,\n) bool {\n\tfor i := range methods {\n\t\tif r.Method == methods[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\thttp.Error(w, \"invalid method\", 400)\n\treturn false\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Prepare(\n\tw http.ResponseWriter, r *http.Request, params interface{},\n\tbodySizeLimit int64,\n) bool {\n\tr.Body = http.MaxBytesReader(w, r.Body, bodySizeLimit)\n\tif params != nil {\n\t\tif err := json.NewDecoder(r.Body).Decode(params); err != nil {\n\t\t\thttp.Error(w, err.Error(), 400)\n\t\t\treturn false\n\t\t}\n\t\tif err := pickyjson.CheckRequired(params); err != nil {\n\t\t\tcommon.HTTPError(w, r, err)\n\t\t\treturn false\n\t\t}\n\t\tif err := pickyjson.CheckRequired(&params); err != nil {\n\t\t\tcommon.HTTPError(w, r, err)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n\n\n\n\nfunc JSONSuccess(w io.Writer, i interface{}) ", "output": "{\n\tjson.NewEncoder(w).Encode(i)\n\tfmt.Fprintf(w, \"\\n\")\n}"}
{"input": "package airplane_mode\n\nfunc getRadioModule(key RadioType) BaseRadioModule {\n\tvar module BaseRadioModule\n\tswitch key {\n\tcase BluetoothRadioType:\n\t\tmodule = &BluetoothRadio{GeneralRadioModule{typ: BluetoothRadioType, name: \"bluetooth\"}}\n\tcase WlanRadioType:\n\t\tmodule = &WlanRadio{GeneralRadioModule{typ: WlanRadioType, name: \"wlan\"}}\n\tcase AllRadioType:\n\t\tmodule = &AllRadio{GeneralRadioModule{typ: AllRadioType, name: \"all\"}}\n\tdefault:\n\t\tpanic(\"radio type not exist\")\n\t}\n\treturn module\n}\n\ntype GeneralRadioModule struct {\n\ttyp  RadioType\n\tname string\n}\n\nfunc (Op *GeneralRadioModule) Type() RadioType {\n\treturn Op.typ\n}\n\nfunc (Op *GeneralRadioModule) Module() string {\n\treturn Op.name\n}\n\nfunc (Op *GeneralRadioModule) Len() int {\n\tstate, err := rfkillState(Op.typ)\n\tif err != nil {\n\t\tlogger.Warningf(\"check rfkill blocked state failed, err: %v\", err)\n\t\tstate.count = 0\n\t}\n\treturn state.count\n}\n\n\n\nfunc (Op *GeneralRadioModule) Unblock() error {\n\treturn rfkillAction(Op.typ, UnblockRadioAction)\n}\n\nfunc (Op *GeneralRadioModule) IsBlocked() bool {\n\tstate, err := rfkillState(Op.typ)\n\tif err != nil {\n\t\tlogger.Warningf(\"check rfkill blocked state failed, err: %v\", err)\n\t\tstate.blocked = false\n\t}\n\treturn state.blocked\n}\n\n\ntype BluetoothRadio struct {\n\tGeneralRadioModule\n}\n\n\ntype WlanRadio struct {\n\tGeneralRadioModule\n}\n\n\ntype AllRadio struct {\n\tGeneralRadioModule\n}\n\nfunc (Op *GeneralRadioModule) Block() error ", "output": "{\n\treturn rfkillAction(Op.typ, BlockRadioAction)\n}"}
{"input": "package hashio \n\nimport (\n\t\"io\"\n)\n\nfunc NewHasherWriter(hash string, target io.Writer) (io.Writer, *Hasher, error) {\n\thw, err := NewHasher(hash)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tendWriter := io.MultiWriter(target, hw)\n\treturn endWriter, hw, nil\n}\n\nfunc NewHasherWriters(hashes []string, target io.Writer) (io.Writer, []*Hasher, error) {\n\thashers := []*Hasher{}\n\twriters := []io.Writer{}\n\n\tfor _, hash := range hashes {\n\t\thw, err := NewHasher(hash)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\thashers = append(hashers, hw)\n\t\twriters = append(writers, hw)\n\t}\n\n\tendWriter := io.MultiWriter(append(writers, target)...)\n\treturn endWriter, hashers, nil\n}\n\nfunc NewHasherReader(hash string, target io.Reader) (io.Reader, *Hasher, error) {\n\thw, err := NewHasher(hash)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tendReader := io.TeeReader(target, hw)\n\treturn endReader, hw, nil\n}\n\n\n\nfunc NewHasherReaders(hashes []string, target io.Reader) (io.Reader, []*Hasher, error) ", "output": "{\n\thashers := []*Hasher{}\n\twriters := []io.Writer{}\n\n\tfor _, hash := range hashes {\n\t\thw, err := NewHasher(hash)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\thashers = append(hashers, hw)\n\t\twriters = append(writers, hw)\n\t}\n\tendReader := io.TeeReader(target, io.MultiWriter(writers...))\n\treturn endReader, hashers, nil\n}"}
{"input": "package rpc\n\nimport (\n\t\"github.com/mitchellh/packer/packer\"\n\t\"log\"\n\t\"net/rpc\"\n)\n\n\n\ntype hook struct {\n\tclient *rpc.Client\n\tmux    *muxBroker\n}\n\n\n\ntype HookServer struct {\n\thook packer.Hook\n\tmux  *muxBroker\n}\n\ntype HookRunArgs struct {\n\tName     string\n\tData     interface{}\n\tStreamId uint32\n}\n\nfunc (h *hook) Run(name string, ui packer.Ui, comm packer.Communicator, data interface{}) error {\n\tnextId := h.mux.NextId()\n\tserver := newServerWithMux(h.mux, nextId)\n\tserver.RegisterCommunicator(comm)\n\tserver.RegisterUi(ui)\n\tgo server.Serve()\n\n\targs := HookRunArgs{\n\t\tName:     name,\n\t\tData:     data,\n\t\tStreamId: nextId,\n\t}\n\n\treturn h.client.Call(\"Hook.Run\", &args, new(interface{}))\n}\n\nfunc (h *hook) Cancel() {\n\terr := h.client.Call(\"Hook.Cancel\", new(interface{}), new(interface{}))\n\tif err != nil {\n\t\tlog.Printf(\"Hook.Cancel error: %s\", err)\n\t}\n}\n\n\n\nfunc (h *HookServer) Cancel(args *interface{}, reply *interface{}) error {\n\th.hook.Cancel()\n\treturn nil\n}\n\nfunc (h *HookServer) Run(args *HookRunArgs, reply *interface{}) error ", "output": "{\n\tclient, err := newClientWithMux(h.mux, args.StreamId)\n\tif err != nil {\n\t\treturn NewBasicError(err)\n\t}\n\tdefer client.Close()\n\n\tif err := h.hook.Run(args.Name, client.Ui(), client.Communicator(), args.Data); err != nil {\n\t\treturn NewBasicError(err)\n\t}\n\n\t*reply = nil\n\treturn nil\n}"}
{"input": "package tikv\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t. \"github.com/pingcap/check\"\n)\n\ntype testBackoffSuite struct {\n\tOneByOneSuite\n\tstore *tikvStore\n}\n\nvar _ = Suite(&testBackoffSuite{})\n\n\n\nfunc (s *testBackoffSuite) TearDownTest(c *C) {\n\ts.store.Close()\n}\n\nfunc (s *testBackoffSuite) TestBackoffWithMax(c *C) {\n\tb := NewBackoffer(context.TODO(), 2000)\n\terr := b.BackoffWithMaxSleep(boTxnLockFast, 30, errors.New(\"test\"))\n\tc.Assert(err, IsNil)\n\tc.Assert(b.totalSleep, Equals, 30)\n}\n\nfunc (s *testBackoffSuite) SetUpTest(c *C) ", "output": "{\n\ts.store = NewTestStore(c).(*tikvStore)\n}"}
{"input": "package smtpio\n\nimport (\n\t\"bytes\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/mailslurper/libmailslurper/smtpconstants\"\n)\n\ntype SmtpReader struct {\n\tConnection net.Conn\n}\n\n\nfunc (this *SmtpReader) Read() string {\n\tvar raw bytes.Buffer\n\tvar bytesRead int\n\n\tbytesRead = 1\n\n\tfor bytesRead > 0 {\n\t\tthis.Connection.SetReadDeadline(time.Now().Add(time.Millisecond * smtpconstants.CONN_TIMEOUT_MILLISECONDS))\n\n\t\tbuffer := make([]byte, smtpconstants.RECEIVE_BUFFER_LEN)\n\t\tbytesRead, err := this.Connection.Read(buffer)\n\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif bytesRead > 0 {\n\t\t\traw.WriteString(string(buffer[:bytesRead]))\n\t\t}\n\t}\n\n\treturn raw.String()\n}\n\n\n\n\nfunc (this *SmtpReader) ReadDataBlock() string ", "output": "{\n\tvar dataBuffer bytes.Buffer\n\n\tfor {\n\t\tdataResponse := this.Read()\n\n\t\tterminatorPos := strings.Index(dataResponse, smtpconstants.SMTP_DATA_TERMINATOR)\n\t\tif terminatorPos <= -1 {\n\t\t\tdataBuffer.WriteString(dataResponse)\n\t\t} else {\n\t\t\tdataBuffer.WriteString(dataResponse[0:terminatorPos])\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn dataBuffer.String()\n}"}
{"input": "package libcontainerd\n\nimport \"strings\"\n\n\n\n\n\n\nfunc (s *LCOWOption) Apply(interface{}) error {\n\treturn nil\n}\n\nfunc setupEnvironmentVariables(a []string) map[string]string ", "output": "{\n\tr := make(map[string]string)\n\tfor _, s := range a {\n\t\tarr := strings.SplitN(s, \"=\", 2)\n\t\tif len(arr) == 2 {\n\t\t\tr[arr[0]] = arr[1]\n\t\t}\n\t}\n\treturn r\n}"}
{"input": "package main\n\nimport (\n    \"flag\"\n    \"net/http\"\n    \"time\"\n\n    \"go-websiteskeleton/app/common\"\n    \"go-websiteskeleton/app/home\"\n    \"go-websiteskeleton/app/user\"\n    \"go-websiteskeleton/app/contact\"\n    \"go-websiteskeleton/app/blog\"\n\n    \"github.com/golang/glog\"\n    \"github.com/gorilla/mux\"\n)\n\nfunc main() {\n    flag.Parse()\n    defer glog.Flush()\n\n    router := mux.NewRouter()\n    http.Handle(\"/\", httpInterceptor(router))\n\n    router.HandleFunc(\"/\", home.GetHomePage).Methods(\"GET\")\n    router.HandleFunc(\"/users{_:/?}\", user.GetHomePage).Methods(\"GET\")\n\n    router.HandleFunc(\"/user/view/{id:[0-9]+}\", user.GetViewPage).Methods(\"GET\")\n    router.HandleFunc(\"/user/{id:[0-9]+}\", user.GetViewPage).Methods(\"GET\")\n\n    router.HandleFunc(\"/contact\", contact.GetHomePage).Methods(\"GET\")\n    router.HandleFunc(\"/contact\", contact.SubmitContactForm).Methods(\"POST\")\n\n    router.HandleFunc(\"/blog/{title:[a-z0-9-]+}\", blog.GetViewPage).Methods(\"GET\")\n\n    fileServer := http.StripPrefix(\"/dist/\", http.FileServer(http.Dir(\"web/dist\")))\n    http.Handle(\"/dist/\", fileServer)\n\n    http.ListenAndServe(\":8181\", nil)\n}\n\n\n\nfunc httpInterceptor(router http.Handler) http.Handler ", "output": "{\n    return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n        startTime := time.Now()\n\n        router.ServeHTTP(w, req)\n\n        finishTime := time.Now()\n        elapsedTime := finishTime.Sub(startTime)\n\n        switch req.Method {\n        case \"GET\":\n            \n            \n            common.LogAccess(w, req, elapsedTime)\n        case \"POST\":\n            \n        }\n\n    })\n}"}
{"input": "package dev\n\nimport \"fmt\"\n\n\n\ntype Configuration struct {\n\tid    uint32\n\tnodes []*Node\n\tn     int\n\tmgr   *Manager\n\tqspec QuorumSpec\n\terrs  chan CallGRPCError\n}\n\n\n\nfunc (c *Configuration) SubError() <-chan CallGRPCError {\n\treturn c.errs\n}\n\n\nfunc (c *Configuration) ID() uint32 {\n\treturn c.id\n}\n\n\n\n\nfunc (c *Configuration) NodeIDs() []uint32 {\n\tids := make([]uint32, len(c.nodes))\n\tfor i, node := range c.nodes {\n\t\tids[i] = node.ID()\n\t}\n\treturn ids\n}\n\n\n\nfunc (c *Configuration) Nodes() []*Node {\n\treturn c.nodes\n}\n\n\nfunc (c *Configuration) Size() int {\n\treturn c.n\n}\n\nfunc (c *Configuration) String() string {\n\treturn fmt.Sprintf(\"configuration %d\", c.id)\n}\n\nfunc (c *Configuration) tstring() string {\n\treturn fmt.Sprintf(\"config-%d\", c.id)\n}\n\n\n\nfunc Equal(a, b *Configuration) bool { return a.id == b.id }\n\n\n\n\n\n\nfunc NewTestConfiguration(q, n int) *Configuration ", "output": "{\n\treturn &Configuration{\n\t\tnodes: make([]*Node, n),\n\t}\n}"}
{"input": "package repl\n\n\n\n\nfunc (shell *Shell) Create(args []string) (string, error) ", "output": "{\n\tif !shell.IsConnected() {\n\t\treturn \"\", ErrNotConnected\n\t}\n\treturn \"\", nil\n}"}
{"input": "package parse\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gcrtnst/mugen/ast\"\n\t\"github.com/gcrtnst/mugen/spec\"\n\t\"github.com/gcrtnst/mugen/token\"\n)\n\n\nfunc (p *parser) lookupRdir() (*spec.Rdir, bool) {\n\tif p.kind() != token.WORD {\n\t\treturn nil, false\n\t}\n\n\tfor _, r := range p.spec.Rdir {\n\t\tif p.matchRdir(r) {\n\t\t\treturn r, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc (p *parser) parseRdirExpr(s *spec.Rdir) ast.Expr {\n\tif false ||\n\t\tp.kind() != token.WORD ||\n\t\t!p.matchRdir(s) {\n\t\tp.errorExpected(strconv.Quote(s.ID))\n\t\treturn p.badVoid()\n\t}\n\tvar r = &ast.RdirExpr{}\n\n\tr.ID, r.IDPos = p.lit(), p.next()\n\n\tif s.Paren && !s.NoParen && p.kind() != token.LPAREN {\n\t\tp.errorExpected(\"parenthesis\")\n\t}\n\tif !s.Paren && p.kind() == token.LPAREN {\n\t\tp.error(\"unexpected parenthesis\")\n\t}\n\tif p.kind() == token.LPAREN {\n\t\tr.Paren = p.parseParenArg(spec.PrExpr)\n\t}\n\n\tif !p.expect(token.COMMA) {\n\t\treturn p.badEnd(r.IDPos)\n\t}\n\tr.Comma = p.next()\n\n\tr.X = p.parseWord()\n\n\treturn r\n}\n\nfunc (p *parser) matchRdir(s *spec.Rdir) bool ", "output": "{\n\treturn p.kind() == token.WORD && strings.EqualFold(p.lit(), s.ID)\n}"}
{"input": "package goapp\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestEq(t *testing.T) {\n\tt.Parallel()\n\n\teqHelper(t, true, 1, 1)\n\teqHelper(t, true, 1, 1, 1)\n\teqHelper(t, false, 1, 1, 3)\n\teqHelper(t, false, 1, 2)\n\teqHelper(t, false, 1, 2, 3)\n}\n\nfunc eqHelper(t *testing.T, expectedEq bool, args ...interface{}) ", "output": "{\n\tif expectedEq {\n\t\tif !eq(args...) {\n\t\t\tt.Errorf(\"Expected %v to be equal, got false\", args)\n\t\t}\n\t} else {\n\t\tif eq(args...) {\n\t\t\tt.Errorf(\"Expected %v to not be equal, got true\", args)\n\t\t}\n\t}\n}"}
{"input": "package golisp\n\nimport ()\n\nfunc RegisterMutatorPrimitives() {\n\tMakeSpecialForm(\"set!\", \"2\", SetVarImpl)\n\tMakeSpecialForm(\"set-car!\", \"2\", SetCarImpl)\n\tMakeSpecialForm(\"set-cdr!\", \"2\", SetCdrImpl)\n\tMakeSpecialForm(\"set-nth!\", \"3\", SetNthImpl)\n}\n\nfunc SetVarImpl(args *Data, env *SymbolTableFrame) (result *Data, err error) {\n\tsymbol := Car(args)\n\tif !SymbolP(symbol) {\n\t\terr = ProcessError(\"set! requires a raw (unevaluated) symbol as it's first argument.\", env)\n\t}\n\tvalue, err := Eval(Cadr(args), env)\n\tif err != nil {\n\t\treturn\n\t}\n\treturn env.SetTo(symbol, value)\n}\n\nfunc SetCarImpl(args *Data, env *SymbolTableFrame) (result *Data, err error) {\n\tpair, err := Eval(Car(args), env)\n\tif !PairP(pair) {\n\t\terr = ProcessError(\"set-car! requires a pair as it's first argument.\", env)\n\t}\n\tvalue, err := Eval(Cadr(args), env)\n\tif err != nil {\n\t\treturn\n\t}\n\tConsValue(pair).Car = value\n\treturn value, nil\n}\n\nfunc SetCdrImpl(args *Data, env *SymbolTableFrame) (result *Data, err error) {\n\tpair, err := Eval(Car(args), env)\n\tif !PairP(pair) {\n\t\terr = ProcessError(\"set-cdr! requires a pair as it's first argument.\", env)\n\t}\n\tvalue, err := Eval(Cadr(args), env)\n\tif err != nil {\n\t\treturn\n\t}\n\tConsValue(pair).Cdr = value\n\n\treturn value, nil\n}\n\n\n\nfunc SetNthImpl(args *Data, env *SymbolTableFrame) (result *Data, err error) ", "output": "{\n\tl, err := Eval(First(args), env)\n\tif !ListP(l) {\n\t\terr = ProcessError(\"set-nth! requires a list as it's first argument.\", env)\n\t}\n\tindex, err := Eval(Second(args), env)\n\tif err != nil {\n\t\treturn\n\t}\n\tvalue, err := Eval(Third(args), env)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn SetNth(l, int(IntegerValue(index)), value), nil\n}"}
{"input": "package dba\n\nimport \"testing\"\n\n\n\nfunc TestMeta(t *testing.T) ", "output": "{\n\ttable := NewTable(\"users\")\n\ttable.SetMeta(\"primary_key\", \"user_id\")\n\tif table.MustGetMeta(\"primary_key\") != \"user_id\" {\n\t\tt.Error(\"expected primary_key meta field to be user_id\")\n\t}\n\n\tif table.meta.Name != \"users\" {\n\t\tt.Error(\"expected table name to be users\")\n\t}\n}"}
{"input": "package libvirttools\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\n\tlibvirtxml \"github.com/libvirt/libvirt-go-xml\"\n\n\t\"github.com/Mirantis/virtlet/pkg/metadata/types\"\n)\n\n\ntype filesystemVolume struct {\n\tvolumeBase\n\tmount            types.VMMount\n\tvolumeMountPoint string\n\tchownRecursively bool\n}\n\nvar _ VMVolume = &filesystemVolume{}\n\nfunc (v *filesystemVolume) IsDisk() bool { return false }\n\nfunc (v *filesystemVolume) UUID() string { return \"\" }\n\nfunc (v *filesystemVolume) Setup() (*libvirtxml.DomainDisk, *libvirtxml.DomainFilesystem, error) {\n\tfsys := v.owner.FileSystem()\n\terr := os.MkdirAll(v.volumeMountPoint, 0777)\n\tif err == nil {\n\t\terr = fsys.ChownForEmulator(v.volumeMountPoint, false)\n\t}\n\tif err == nil {\n\t\terr = fsys.Mount(v.mount.HostPath, v.volumeMountPoint, \"bind\", true)\n\t}\n\tif err == nil {\n\t\terr = fsys.ChownForEmulator(v.volumeMountPoint, v.chownRecursively)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to create vm pod path %q: %v\", v.volumeMountPoint, err)\n\t}\n\n\tfsDef := &libvirtxml.DomainFilesystem{\n\t\tAccessMode: \"squash\",\n\t\tSource:     &libvirtxml.DomainFilesystemSource{Mount: &libvirtxml.DomainFilesystemSourceMount{Dir: v.volumeMountPoint}},\n\t\tTarget:     &libvirtxml.DomainFilesystemTarget{Dir: path.Base(v.mount.ContainerPath)},\n\t}\n\n\treturn nil, fsDef, nil\n}\n\n\n\nfunc (v *filesystemVolume) Teardown() error ", "output": "{\n\tvar err error\n\tif _, err = os.Stat(v.volumeMountPoint); err == nil {\n\t\terr = v.owner.FileSystem().Unmount(v.volumeMountPoint, true)\n\t}\n\tif err == nil {\n\t\terr = os.Remove(v.volumeMountPoint)\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to tear down fs volume mountpoint '%s': %v\", v.volumeMountPoint, err)\n\t}\n\treturn nil\n}"}
{"input": "package miniredis\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\n\nfunc assert(tb testing.TB, condition bool, msg string, v ...interface{}) {\n\ttb.Helper()\n\n\tif !condition {\n\t\ttb.Errorf(msg, v...)\n\t}\n}\n\n\n\n\n\nfunc equals(tb testing.TB, exp, act interface{}) {\n\ttb.Helper()\n\n\tif !reflect.DeepEqual(exp, act) {\n\t\ttb.Errorf(\"expected: %#v got: %#v\", exp, act)\n\t}\n}\n\n\nfunc mustFail(tb testing.TB, err error, want string) {\n\ttb.Helper()\n\n\tif err == nil {\n\t\ttb.Errorf(\"expected an error, but got a nil\")\n\t}\n\n\tif have := err.Error(); have != want {\n\t\ttb.Errorf(\"have %q, want %q\", have, want)\n\t}\n}\n\nfunc ok(tb testing.TB, err error) ", "output": "{\n\ttb.Helper()\n\n\tif err != nil {\n\t\ttb.Errorf(\"unexpected error: %s\", err.Error())\n\t}\n}"}
{"input": "package parser\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/dockpit/assert/strategy\"\n)\n\n\n\ntype PlainT struct {\n\tvalues     map[string]E\n\tarchetypes []*strategy.Archetype\n}\n\nfunc newPlainT(ats []*strategy.Archetype) *PlainT {\n\tif ats == nil {\n\t\tats = []*strategy.Archetype{}\n\t}\n\n\treturn &PlainT{\n\t\tvalues:     map[string]E{},\n\t\tarchetypes: ats,\n\t}\n}\n\nfunc (t *PlainT) All() map[string]E {\n\treturn t.values\n}\n\nfunc (t *PlainT) Set(key string, e E) {\n\tt.values[key] = e\n}\n\nfunc (t *PlainT) Get(key string) E {\n\treturn t.values[key]\n}\n\n\n\n\n\n\ntype Plain struct {\n\tarchetypes []*strategy.Archetype\n}\n\nfunc NewPlain(ats []*strategy.Archetype) *Plain {\n\treturn &Plain{ats}\n}\n\n\nfunc (p *Plain) Parse(data []byte) (T, error) {\n\tt := newPlainT(p.archetypes)\n\n\tstr := strings.TrimRightFunc(string(data), unicode.IsSpace)\n\n\te := NewElement(str)\n\n\tt.Set(\".0\", e)\n\n\treturn t, nil\n}\n\nfunc (t *PlainT) Follows(ex T) error ", "output": "{\n\n\tactual := t.Get(\".0\")\n\texample := ex.Get(\".0\")\n\n\tafn, err := example.ToAssert(t.archetypes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn afn(actual)\n}"}
{"input": "package structs\n\nimport (\n\t\"strings\"\n)\n\ntype S struct{}\n\nfunc (S) Init() {}\n\n\nfunc FuncTest(item S) {}\n\nfunc (this S) MethodTest(item S1) {}\n\ntype S1 struct {\n\tprivate int\n}\n\ntype S2 struct {\n\tPublic  int\n\tprivate int\n}\n\ntype Dim int\n\ntype S3 struct {\n\tX Dim\n\tY Dim\n}\n\nfunc (S) Upper(s string) string ", "output": "{\n\treturn strings.ToUpper(s)\n}"}
{"input": "package code\n\nimport \"net/http\"\n\ntype TextHTTPCode struct {\n\tText     string\n\tHTTPCode int\n}\n\ntype CodeMap map[Code]TextHTTPCode\n\nfunc (s CodeMap) Get(code Code) TextHTTPCode {\n\tv, _ := s[code]\n\treturn v\n}\n\nfunc (s CodeMap) Set(code Code, text string, httpCodes ...int) CodeMap {\n\thttpCode := http.StatusOK\n\tif len(httpCodes) > 0 {\n\t\thttpCode = httpCodes[0]\n\t\tif httpCode <= 0 {\n\t\t\thttpCode = http.StatusOK\n\t\t}\n\t}\n\ts[code] = TextHTTPCode{Text: text, HTTPCode: httpCode}\n\treturn s\n}\n\n\n\nfunc (s CodeMap) GetByInt(code int) TextHTTPCode ", "output": "{\n\treturn s.Get(Code(code))\n}"}
{"input": "package build\n\nimport \"strconv\"\n\nconst _Status_name = \"SuccessFailPendingStartedFatalWarningBuilding\"\n\nvar _Status_index = [...]uint8{0, 7, 11, 18, 25, 30, 37, 45}\n\n\n\nfunc (i Status) String() string ", "output": "{\n\tif i < 0 || i >= Status(len(_Status_index)-1) {\n\t\treturn \"Status(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n\treturn _Status_name[_Status_index[i]:_Status_index[i+1]]\n}"}
{"input": "package dns\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\nfunc New(subscriptionID string) BaseClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient ", "output": "{\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype CreateNatGatewayRequest struct {\n\n\tCreateNatGatewayDetails `contributesTo:\"body\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request CreateNatGatewayRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request CreateNatGatewayRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request CreateNatGatewayRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype CreateNatGatewayResponse struct {\n\n\tRawResponse *http.Response\n\n\tNatGateway `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response CreateNatGatewayResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response CreateNatGatewayResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request CreateNatGatewayRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) ", "output": "{\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}"}
{"input": "package core\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/oci/oci-go-sdk/v43/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetServiceRequest struct {\n\n\tServiceId *string `mandatory:\"true\" contributesTo:\"path\" name:\"serviceId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\n\n\n\nfunc (request GetServiceRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request GetServiceRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request GetServiceRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetServiceResponse struct {\n\n\tRawResponse *http.Response\n\n\tService `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response GetServiceResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response GetServiceResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request GetServiceRequest) String() string ", "output": "{\n\treturn common.PointerString(request)\n}"}
{"input": "package handler\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/Unknwon/macaron\"\n\t\"github.com/macaron-contrib/binding\"\n\n\t\"github.com/astaxie/beego/logs\"\n\n\t\"github.com/containerops/wrench/utils\"\n)\n\ntype UserSignup struct {\n\tUsername string `from:\"username\" Binding:\"Required\"`\n\tEmail    string `from:\"email\" Binding:\"Required;Email\"`\n\tPasswd   string `from:\"passwd\" Binding:\"Required\"`\n\tConfirm  string `from:\"passwd_confirm\" Binding:\"Required\"`\n}\n\n\n\nfunc W1UserSignup(ctx *macaron.Context, log *logs.BeeLogger, user UserSignup) (int, []byte) {\n\treturn http.StatusOK, []byte{}\n}\n\nfunc W1UserSignin(ctx *macaron.Context, log *logs.BeeLogger) (int, []byte) {\n\treturn http.StatusOK, []byte{}\n}\n\nfunc (u *UserSignup) Validate(ctx *macaron.Context, errs binding.Errors) binding.Errors ", "output": "{\n\tif err := utils.ValidatePassword(u.Passwd); err != nil {\n\t\terrs = append(errs, binding.Error{\n\t\t\tFieldNames:     []string{\"passwd\"},\n\t\t\tClassification: \"PasswdError\",\n\t\t\tMessage:        err.Error(),\n\t\t})\n\t}\n\n\tif u.Passwd != u.Confirm {\n\t\terrs = append(errs, binding.Error{\n\t\t\tFieldNames:     []string{\"passwd_confirm\"},\n\t\t\tClassification: \"PasswdConfirmError\",\n\t\t\tMessage:        \"Confirm password is not equal password\",\n\t\t})\n\t}\n\n\treturn errs\n}"}
{"input": "package bds\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype MetricThresholdRule struct {\n\n\tDurationInMinutes *int `mandatory:\"true\" json:\"durationInMinutes\"`\n\n\tOperator MetricThresholdRuleOperatorEnum `mandatory:\"true\" json:\"operator\"`\n\n\tValue *int `mandatory:\"true\" json:\"value\"`\n}\n\nfunc (m MetricThresholdRule) String() string {\n\treturn common.PointerString(m)\n}\n\n\ntype MetricThresholdRuleOperatorEnum string\n\n\nconst (\n\tMetricThresholdRuleOperatorGt MetricThresholdRuleOperatorEnum = \"GT\"\n\tMetricThresholdRuleOperatorLt MetricThresholdRuleOperatorEnum = \"LT\"\n)\n\nvar mappingMetricThresholdRuleOperator = map[string]MetricThresholdRuleOperatorEnum{\n\t\"GT\": MetricThresholdRuleOperatorGt,\n\t\"LT\": MetricThresholdRuleOperatorLt,\n}\n\n\n\n\nfunc GetMetricThresholdRuleOperatorEnumValues() []MetricThresholdRuleOperatorEnum ", "output": "{\n\tvalues := make([]MetricThresholdRuleOperatorEnum, 0)\n\tfor _, v := range mappingMetricThresholdRuleOperator {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}"}
{"input": "package doctl\n\nimport (\n\t\"github.com/digitalocean/doctl/pkg/listen\"\n\t\"github.com/digitalocean/doctl/pkg/runner\"\n)\n\n\ntype MockRunner struct {\n\tErr error\n}\n\nvar _ runner.Runner = &MockRunner{}\n\n\nfunc (tr *MockRunner) Run() error {\n\treturn tr.Err\n}\n\n\ntype MockListener struct {\n\tErr error\n}\n\nvar _ listen.ListenerService = &MockListener{}\n\n\n\n\n\nfunc (tr *MockListener) Stop() {\n\treturn\n}\n\nfunc (tr *MockListener) Start() error ", "output": "{\n\treturn tr.Err\n}"}
{"input": "package common\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/mitchellh/packer/template/interpolate\"\n)\n\ntype FloppyConfig struct {\n\tFloppyFiles []string `mapstructure:\"floppy_files\"`\n}\n\n\n\nfunc (c *FloppyConfig) Prepare(ctx *interpolate.Context) []error ", "output": "{\n\tvar errs []error\n\n\tif c.FloppyFiles == nil {\n\t\tc.FloppyFiles = make([]string, 0)\n\t}\n\n\tfor _, path := range c.FloppyFiles {\n\t\tif _, err := os.Stat(path); err != nil {\n\t\t\terrs = append(errs, fmt.Errorf(\"Bad Floppy disk file '%s': %s\", path, err))\n\t\t}\n\t}\n\n\treturn errs\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"sort\"\n\t\"strings\"\n)\n\ntype helloTransport interface {\n\tConnect(addr string) error\n\tClose() error\n\tRequest(req string) (reply string, err error)\n}\n\ntype transGenerator func() (helloTransport, error)\n\nvar transporter map[string]transGenerator = make(map[string]transGenerator)\n\nfunc registerTransport(id string, gen transGenerator) {\n\ttransporter[id] = gen\n}\n\nfunc transportList() []string {\n\tvar transports = make([]string, 0, len(transporter))\n\tfor id := range transporter {\n\t\ttransports = append(transports, id)\n\t}\n\tsort.StringSlice(transports).Sort()\n\treturn transports\n}\n\nfunc availableTransports() string {\n\tvar transports = transportList()\n\treturn strings.Join(transports, \",\")\n}\n\n\n\nfunc defaultAddr(addr string) string {\n\treturn fmt.Sprintf(\"%s://%s\", firstTransport(), addr)\n}\n\nfunc newTransport(addr string) (helloTransport, error) {\n\tvar uri, err = url.Parse(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif generate, ok := transporter[uri.Scheme]; ok {\n\t\treturn generate()\n\t}\n\treturn nil, fmt.Errorf(\"invalid transport %q\", uri.Scheme)\n}\n\nfunc firstTransport() string ", "output": "{\n\tvar transports = transportList()\n\treturn transports[0]\n}"}
{"input": "package daemon\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-openapi/runtime/middleware\"\n)\n\n\ntype GetHealthzHandlerFunc func(GetHealthzParams) middleware.Responder\n\n\n\n\n\ntype GetHealthzHandler interface {\n\tHandle(GetHealthzParams) middleware.Responder\n}\n\n\nfunc NewGetHealthz(ctx *middleware.Context, handler GetHealthzHandler) *GetHealthz {\n\treturn &GetHealthz{Context: ctx, Handler: handler}\n}\n\n\ntype GetHealthz struct {\n\tContext *middleware.Context\n\tHandler GetHealthzHandler\n}\n\nfunc (o *GetHealthz) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n\troute, rCtx, _ := o.Context.RouteInfo(r)\n\tif rCtx != nil {\n\t\tr = rCtx\n\t}\n\tvar Params = NewGetHealthzParams()\n\n\tif err := o.Context.BindValidRequest(r, route, &Params); err != nil { \n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\n\tres := o.Handler.Handle(Params) \n\n\to.Context.Respond(rw, r, route.Produces, route, res)\n\n}\n\nfunc (fn GetHealthzHandlerFunc) Handle(params GetHealthzParams) middleware.Responder ", "output": "{\n\treturn fn(params)\n}"}
{"input": "package models\n\nimport (\n\t\"crypto/md5\"\n\t\"encoding/hex\"\n)\n\n\n\nfunc Hash(s string) string ", "output": "{\n\thash := md5.New()\n\thash.Write([]byte(s))\n\treturn hex.EncodeToString(hash.Sum(nil))\n}"}
{"input": "package zygo\n\n\ntype Closing struct {\n\tStack *Stack\n\tName  string\n\tenv   *Zlisp\n}\n\nfunc NewClosing(name string, env *Zlisp) *Closing {\n\tstk := env.linearstack.Clone()\n\n\treturn &Closing{\n\t\tStack: stk,\n\t\tName:  name,\n\t\tenv:   env}\n}\n\nfunc NewEmptyClosing(name string, env *Zlisp) *Closing {\n\treturn &Closing{\n\t\tStack: env.NewStack(0),\n\t\tName:  name,\n\t\tenv:   env}\n}\n\nfunc (c *Closing) IsStackElem() {}\n\nfunc (c *Closing) LookupSymbolUntilFunction(sym *SexpSymbol, setVal *Sexp, maximumFuncToSearch int, checkCaptures bool) (Sexp, error, *Scope) {\n\treturn c.Stack.LookupSymbolUntilFunction(sym, setVal, maximumFuncToSearch, checkCaptures)\n}\nfunc (c *Closing) LookupSymbol(sym *SexpSymbol, setVal *Sexp) (Sexp, error, *Scope) {\n\treturn c.Stack.LookupSymbol(sym, setVal)\n}\n\nfunc (c *Closing) Show(env *Zlisp, ps *PrintState, label string) (string, error) {\n\treturn c.Stack.Show(env, ps, label)\n}\n\n\n\nfunc (c *Closing) TopScope() *Scope ", "output": "{\n\treturn c.Stack.GetTop().(*Scope)\n}"}
{"input": "package query\n\n\n\nimport (\n\t\"net/url\"\n\n\trequest \"github.com/aws/aws-sdk-go-v2/aws\"\n\t\"github.com/aws/aws-sdk-go-v2/aws/awserr\"\n\t\"github.com/aws/aws-sdk-go-v2/private/protocol/query/queryutil\"\n)\n\n\nvar BuildHandler = request.NamedHandler{Name: \"awssdk.query.Build\", Fn: Build}\n\n\n\n\nfunc Build(r *request.Request) ", "output": "{\n\tbody := url.Values{\n\t\t\"Action\":  {r.Operation.Name},\n\t\t\"Version\": {r.Metadata.APIVersion},\n\t}\n\tif err := queryutil.Parse(body, r.Params, false); err != nil {\n\t\tr.Error = awserr.New(\"SerializationError\", \"failed encoding Query request\", err)\n\t\treturn\n\t}\n\n\tif r.ExpireTime == 0 {\n\t\tr.HTTPRequest.Method = \"POST\"\n\t\tr.HTTPRequest.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded; charset=utf-8\")\n\t\tr.SetBufferBody([]byte(body.Encode()))\n\t} else { \n\t\tr.HTTPRequest.Method = \"GET\"\n\t\tr.HTTPRequest.URL.RawQuery = body.Encode()\n\t}\n}"}
{"input": "package databasemigration\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype MigrationCollection struct {\n\n\tItems []MigrationSummary `mandatory:\"true\" json:\"items\"`\n}\n\n\n\nfunc (m MigrationCollection) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package processors\n\nimport \"github.com/dailyburn/ratchet/data\"\n\n\n\n\n\ntype Passthrough struct {\n\ti int\n}\n\n\n\n\n\nfunc (r *Passthrough) ProcessData(d data.JSON, outputChan chan data.JSON, killChan chan error) {\n\toutputChan <- d\n}\n\n\nfunc (r *Passthrough) Finish(outputChan chan data.JSON, killChan chan error) {\n}\n\nfunc (r *Passthrough) String() string {\n\treturn \"Passthrough\"\n}\n\nfunc NewPassthrough() *Passthrough ", "output": "{\n\treturn &Passthrough{}\n}"}
{"input": "package s3\n\nimport (\n\t\"net/http\"\n\n\t\"gopkg.in/amz.v3/aws\"\n)\n\nvar originalStrategy = attempts\n\nfunc BuildError(resp *http.Response) error {\n\treturn buildError(resp)\n}\n\nfunc SetAttemptStrategy(s *aws.AttemptStrategy) {\n\tif s == nil {\n\t\tattempts = originalStrategy\n\t} else {\n\t\tattempts = *s\n\t}\n}\n\nfunc AttemptStrategy() aws.AttemptStrategy {\n\treturn attempts\n}\n\n\n\nfunc SetListMultiMax(n int) {\n\tlistMultiMax = n\n}\n\nfunc SetListPartsMax(n int) ", "output": "{\n\tlistPartsMax = n\n}"}
{"input": "package user\n\nimport (\n\tapi \"code.gitea.io/sdk/gitea\"\n\n\t\"code.gitea.io/gitea/models\"\n\t\"code.gitea.io/gitea/modules/context\"\n)\n\n\n\nfunc ListAccessTokens(ctx *context.APIContext) {\n\ttokens, err := models.ListAccessTokens(ctx.User.ID)\n\tif err != nil {\n\t\tctx.Error(500, \"ListAccessTokens\", err)\n\t\treturn\n\t}\n\n\tapiTokens := make([]*api.AccessToken, len(tokens))\n\tfor i := range tokens {\n\t\tapiTokens[i] = &api.AccessToken{tokens[i].Name, tokens[i].Sha1}\n\t}\n\tctx.JSON(200, &apiTokens)\n}\n\n\n\n\n\nfunc CreateAccessToken(ctx *context.APIContext, form api.CreateAccessTokenOption) ", "output": "{\n\tt := &models.AccessToken{\n\t\tUID:  ctx.User.ID,\n\t\tName: form.Name,\n\t}\n\tif err := models.NewAccessToken(t); err != nil {\n\t\tctx.Error(500, \"NewAccessToken\", err)\n\t\treturn\n\t}\n\tctx.JSON(201, &api.AccessToken{t.Name, t.Sha1})\n}"}
{"input": "package model\n\nimport (\n\t\"encoding/json\"\n\n\t\"strings\"\n)\n\n\ntype Flavor struct {\n\tId string `json:\"id\"`\n\tName string `json:\"name\"`\n\tVcpus string `json:\"vcpus\"`\n\tRam int32 `json:\"ram\"`\n\tDisk string `json:\"disk\"`\n\tSwap string `json:\"swap\"`\n\tOSFLVEXTDATAephemeral int32 `json:\"OS-FLV-EXT-DATA:ephemeral\"`\n\tOSFLVDISABLEDdisabled bool `json:\"OS-FLV-DISABLED:disabled\"`\n\tRxtxFactor float32 `json:\"rxtx_factor\"`\n\tRxtxQuota string `json:\"rxtx_quota\"`\n\tRxtxCap string `json:\"rxtx_cap\"`\n\tOsFlavorAccessisPublic bool `json:\"os-flavor-access:is_public\"`\n\tLinks              []FlavorLink              `json:\"links\"`\n\tOsExtraSpecs       *FlavorExtraSpec          `json:\"os_extra_specs\"`\n\tAttachableQuantity *ServerAttachableQuantity `json:\"attachableQuantity,omitempty\"`\n}\n\n\n\nfunc (o Flavor) String() string ", "output": "{\n\tdata, _ := json.Marshal(o)\n\treturn strings.Join([]string{\"Flavor\", string(data)}, \" \")\n}"}
{"input": "package engine\n\nimport (\n\t\"time\"\n\n\t\"github.com/aws/amazon-ecs-agent/agent/api\"\n)\n\n\n\ntype impossibleTransitionError struct {\n\tstate api.ContainerStatus\n}\n\nfunc (err *impossibleTransitionError) Error() string {\n\treturn \"Cannot transition to \" + err.state.String()\n}\nfunc (err *impossibleTransitionError) ErrorName() string { return \"ImpossibleStateTransitionError\" }\n\ntype DockerTimeoutError struct {\n\tduration   time.Duration\n\ttransition string\n}\n\nfunc (err *DockerTimeoutError) Error() string {\n\treturn \"Could not transition to \" + err.transition + \"; timed out after waiting \" + err.duration.String()\n}\nfunc (err *DockerTimeoutError) ErrorName() string { return \"DockerTimeoutError\" }\n\ntype ContainerVanishedError struct{}\n\nfunc (err ContainerVanishedError) Error() string     { return \"No container matching saved ID found\" }\nfunc (err ContainerVanishedError) ErrorName() string { return \"ContainerVanishedError\" }\n\ntype CannotXContainerError struct {\n\ttransition string\n\tmsg        string\n}\n\nfunc (err CannotXContainerError) Error() string { return err.msg }\nfunc (err CannotXContainerError) ErrorName() string {\n\treturn \"Cannot\" + err.transition + \"ContainerError\"\n}\n\ntype OutOfMemoryError struct{}\n\nfunc (err OutOfMemoryError) Error() string     { return \"Container killed due to memory usage\" }\nfunc (err OutOfMemoryError) ErrorName() string { return \"OutOfMemoryError\" }\n\n\ntype DockerStateError struct {\n\tdockerError string\n\tname        string\n}\n\nfunc NewDockerStateError(err string) DockerStateError {\n\treturn DockerStateError{\n\t\tdockerError: err,\n\t\tname:        \"DockerStateError\",\n\t}\n}\n\nfunc (err DockerStateError) Error() string {\n\treturn err.dockerError\n}\n\n\nfunc (err DockerStateError) ErrorName() string ", "output": "{\n\treturn err.name\n}"}
{"input": "package selinux\n\nimport (\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/apis/extensions\"\n\t\"k8s.io/kubernetes/pkg/util/validation/field\"\n)\n\n\ntype runAsAny struct{}\n\nvar _ SELinuxStrategy = &runAsAny{}\n\n\n\n\n\nfunc (s *runAsAny) Generate(pod *api.Pod, container *api.Container) (*api.SELinuxOptions, error) {\n\treturn nil, nil\n}\n\n\nfunc (s *runAsAny) Validate(pod *api.Pod, container *api.Container) field.ErrorList {\n\treturn field.ErrorList{}\n}\n\nfunc NewRunAsAny(options *extensions.SELinuxStrategyOptions) (SELinuxStrategy, error) ", "output": "{\n\treturn &runAsAny{}, nil\n}"}
{"input": "package abi\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/energicryptocurrency/energi/common\"\n\t\"github.com/energicryptocurrency/energi/crypto\"\n)\n\n\n\n\ntype Event struct {\n\tName      string\n\tAnonymous bool\n\tInputs    Arguments\n}\n\n\n\n\n\nfunc (e Event) Id() common.Hash {\n\ttypes := make([]string, len(e.Inputs))\n\ti := 0\n\tfor _, input := range e.Inputs {\n\t\ttypes[i] = input.Type.String()\n\t\ti++\n\t}\n\treturn common.BytesToHash(crypto.Keccak256([]byte(fmt.Sprintf(\"%v(%v)\", e.Name, strings.Join(types, \",\")))))\n}\n\nfunc (e Event) String() string ", "output": "{\n\tinputs := make([]string, len(e.Inputs))\n\tfor i, input := range e.Inputs {\n\t\tinputs[i] = fmt.Sprintf(\"%v %v\", input.Type, input.Name)\n\t\tif input.Indexed {\n\t\t\tinputs[i] = fmt.Sprintf(\"%v indexed %v\", input.Type, input.Name)\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"event %v(%v)\", e.Name, strings.Join(inputs, \", \"))\n}"}
{"input": "package graceful\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"github.com/zenazn/goji/graceful/listener\"\n)\n\n\n\n\ntype gracefulServer struct {\n\tnet.Listener\n\ts *http.Server\n}\n\n\n\n\ntype connState func(net.Conn, http.ConnState)\n\nfunc (c connState) Wrap(nc net.Conn, s http.ConnState) {\n\tswitch s {\n\tcase http.StateIdle:\n\t\tif err := listener.MarkIdle(nc); err != nil {\n\t\t\tlog.Printf(\"error marking conn as idle: %v\", err)\n\t\t}\n\tcase http.StateHijacked:\n\t\tif err := listener.Disown(nc); err != nil {\n\t\t\tlog.Printf(\"error disowning hijacked conn: %v\", err)\n\t\t}\n\t}\n\tif c != nil {\n\t\tc(nc, s)\n\t}\n}\n\nfunc (srv *Server) Serve(l net.Listener) error {\n\tshadow := *(*http.Server)(srv)\n\tshadow.ConnState = connState(shadow.ConnState).Wrap\n\n\tl = gracefulServer{l, &shadow}\n\twrap := listener.Wrap(l, listener.Automatic)\n\tappendListener(wrap)\n\n\terr := shadow.Serve(wrap)\n\treturn peacefulError(err)\n}\n\nfunc (g gracefulServer) Close() error ", "output": "{\n\tg.s.SetKeepAlivesEnabled(false)\n\treturn g.Listener.Close()\n}"}
{"input": "package qr\n\nimport (\n\t\"errors\"\n\n\t\"github.com/henrylee2cn/faygo/ext/barcode/utils\"\n)\n\n\n\nfunc encodeUnicode(content string, ecl ErrorCorrectionLevel) (*utils.BitList, *versionInfo, error) ", "output": "{\n\tdata := []byte(content)\n\n\tvi := findSmallestVersionInfo(ecl, byteMode, len(data)*8)\n\tif vi == nil {\n\t\treturn nil, nil, errors.New(\"To much data to encode\")\n\t}\n\n\tres := new(utils.BitList)\n\tres.AddBits(int(byteMode), 4)\n\tres.AddBits(len(content), vi.charCountBits(byteMode))\n\tfor _, b := range data {\n\t\tres.AddByte(b)\n\t}\n\taddPaddingAndTerminator(res, vi)\n\treturn res, vi, nil\n}"}
{"input": "package search\n\nimport (\n  \"log\"\n)\n\ntype Result struct {\n  Field     string\n  Content   string\n}\n\ntype Matcher interface {\n  Search(feed *Feed, searchTerm string) ([]*Result, error)\n}\n\n\n\nfunc Display(results chan *Result)  {\n  for result := range results {\n    log.Printf(\"%s:\\n%s\\n\\n\", result.Field, result.Content)\n  }\n}\n\nfunc Match(matcher Matcher, feed *Feed, searchTerm string, results chan<- *Result)  ", "output": "{\n  searchResults, err := matcher.Search(feed, searchTerm)\n  if err != nil {\n    log.Println(err)\n    return\n  }\n\n  for _,result := range searchResults {\n    results <- result\n  }\n}"}
{"input": "package utils\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\n\n\nfunc CheckConnection() bool ", "output": "{\n\tsuccess := \"<HTML><HEAD><TITLE>Success</TITLE></HEAD>\" +\n\t\t\"<BODY>Success</BODY></HTML>\"\n\n\tres, err := http.Get(\"http://www.apple.com/library/test/success.html\")\n\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tdefer res.Body.Close()\n\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn string(body) == success\n}"}
{"input": "package geth\n\nimport (\n\t\"errors\"\n\n\t\"github.com/matthieu/go-ethereum/core/types\"\n)\n\n\n\ntype Log struct {\n\tlog *types.Log\n}\n\nfunc (l *Log) GetAddress() *Address  { return &Address{l.log.Address} }\nfunc (l *Log) GetTopics() *Hashes    { return &Hashes{l.log.Topics} }\nfunc (l *Log) GetData() []byte       { return l.log.Data }\nfunc (l *Log) GetBlockNumber() int64 { return int64(l.log.BlockNumber) }\nfunc (l *Log) GetTxHash() *Hash      { return &Hash{l.log.TxHash} }\n\nfunc (l *Log) GetBlockHash() *Hash   { return &Hash{l.log.BlockHash} }\nfunc (l *Log) GetIndex() int         { return int(l.log.Index) }\n\n\ntype Logs struct{ logs []*types.Log }\n\n\nfunc (l *Logs) Size() int {\n\treturn len(l.logs)\n}\n\n\nfunc (l *Logs) Get(index int) (log *Log, _ error) {\n\tif index < 0 || index >= len(l.logs) {\n\t\treturn nil, errors.New(\"index out of bounds\")\n\t}\n\treturn &Log{l.logs[index]}, nil\n}\n\nfunc (l *Log) GetTxIndex() int       ", "output": "{ return int(l.log.TxIndex) }"}
{"input": "package nests\n\nimport \"math/rand\"\n\n\ntype FoodGroup struct {\n\ty float64\n\tx float64\n}\n\n\ntype Food struct {\n\tX         float64 `json:\"x\"`\n\tY         float64 `json:\"y\"`\n\tcarried   bool\n\tfoodGroup *FoodGroup\n}\n\n\n\nfunc (f *Food) renew() {\n\tf.X = f.foodGroup.x + 10 - rand.Float64()*20\n\tf.Y = f.foodGroup.y + 10 - rand.Float64()*20\n}\n\nfunc newFood(fg *FoodGroup) *Food ", "output": "{\n\tfood := &Food{foodGroup: fg}\n\tfood.renew()\n\treturn food\n}"}
{"input": "package entity\n\nfunc (s *Constellation) GetName(lang string) string {\n\tfor _, lt := range s.Names {\n\t\tif *lt.Lang == lang {\n\t\t\treturn *lt.Text\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc (s *Region) GetName(lang string) string {\n\tfor _, lt := range s.Names {\n\t\tif *lt.Lang == lang {\n\t\t\treturn *lt.Text\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc (s *SolarSystem) GetName(lang string) string {\n\tfor _, lt := range s.Names {\n\t\tif *lt.Lang == lang {\n\t\t\treturn *lt.Text\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc (s *InvCategory) GetName(lang string) string {\n\tfor _, lt := range s.Names {\n\t\tif *lt.Lang == lang {\n\t\t\treturn *lt.Text\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc (s *InvGroup) GetName(lang string) string {\n\tfor _, lt := range s.Names {\n\t\tif *lt.Lang == lang {\n\t\t\treturn *lt.Text\n\t\t}\n\t}\n\treturn \"\"\n}\n\n\n\nfunc (s *InvType) GetName(lang string) string ", "output": "{\n\tfor _, lt := range s.Names {\n\t\tif *lt.Lang == lang {\n\t\t\treturn *lt.Text\n\t\t}\n\t}\n\treturn \"\"\n}"}
{"input": "package main\n\nimport \"go/ast\"\n\n\n\n\n\n\nfunc checkRangeLoop(f *File, node ast.Node) {\n\tn := node.(*ast.RangeStmt)\n\tkey, _ := n.Key.(*ast.Ident)\n\tval, _ := n.Value.(*ast.Ident)\n\tif key == nil && val == nil {\n\t\treturn\n\t}\n\tsl := n.Body.List\n\tif len(sl) == 0 {\n\t\treturn\n\t}\n\tvar last *ast.CallExpr\n\tswitch s := sl[len(sl)-1].(type) {\n\tcase *ast.GoStmt:\n\t\tlast = s.Call\n\tcase *ast.DeferStmt:\n\t\tlast = s.Call\n\tdefault:\n\t\treturn\n\t}\n\tlit, ok := last.Fun.(*ast.FuncLit)\n\tif !ok {\n\t\treturn\n\t}\n\tast.Inspect(lit.Body, func(n ast.Node) bool {\n\t\tid, ok := n.(*ast.Ident)\n\t\tif !ok || id.Obj == nil {\n\t\t\treturn true\n\t\t}\n\t\tif key != nil && id.Obj == key.Obj || val != nil && id.Obj == val.Obj {\n\t\t\tf.Bad(id.Pos(), \"range variable\", id.Name, \"enclosed by function\")\n\t\t}\n\t\treturn true\n\t})\n}\n\nfunc init() ", "output": "{\n\tregister(\"rangeloops\",\n\t\t\"check that range loop variables are used correctly\",\n\t\tcheckRangeLoop,\n\t\trangeStmt)\n}"}
{"input": "package marathon\n\nimport (\n\t\"fmt\"\n)\n\n\ntype Queue struct {\n\tItems []Item `json:\"queue\"`\n}\n\n\ntype Item struct {\n\tCount       int         `json:\"count\"`\n\tDelay       Delay       `json:\"delay\"`\n\tApplication Application `json:\"app\"`\n}\n\n\ntype Delay struct {\n\tOverdue         bool `json:\"overdue\"`\n\tTimeLeftSeconds int  `json:\"timeLeftSeconds\"`\n}\n\n\nfunc (r *marathonClient) Queue() (*Queue, error) {\n\tvar queue *Queue\n\terr := r.apiGet(marathonAPIQueue, nil, &queue)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn queue, nil\n}\n\n\n\n\n\nfunc (r *marathonClient) DeleteQueueDelay(appID string) error ", "output": "{\n\tpath := fmt.Sprintf(\"%s/%s/delay\", marathonAPIQueue, trimRootPath(appID))\n\treturn r.apiDelete(path, nil, nil)\n}"}
{"input": "package domain\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\ntype IssueComment struct {\n\tId           string            `json:\"id\"`\n\tMeta         *DocumentMetadata `json:\"meta\" db:\"-\"`\n\tDateCreated  time.Time         `json:\"dateCreated\"`\n\tLastModified *time.Time        `json:\"lastModified\"`\n\tIdIssue      string            `json:\"-\"`\n\tIdUser       string            `json:\"-\"`\n\tBody         string            `json:\"body\"`\n\tUser         *User             `json:\"user\" db:\"-\"`\n\tIssue        *Issue            `json:\"issue\" db:\"-\"`\n}\n\nfunc (u IssueComment) GetMeta() *DocumentMetadata {\n\treturn u.Meta\n}\n\nfunc (u IssueComment) GetId() string {\n\treturn u.Id\n}\n\n\n\nfunc (u *IssueComment) Initialize() {\n\tif u.Meta == nil {\n\t\tu.Meta = &DocumentMetadata{}\n\t}\n\tu.Meta.DocumentType = \"issueComment\"\n\tu.Meta.FriendName = \"Comment\"\n\tu.Meta.Id = u.Id\n\n\tif u.Issue != nil && len(u.Issue.Id) != 0 {\n\t\tu.IdIssue = u.Issue.Id\n\t} else if len(u.IdIssue) != 0 {\n\t\tif u.Issue == nil {\n\t\t\tu.Issue = &Issue{}\n\t\t}\n\t\tu.IdIssue = u.Issue.Id\n\t}\n\n\tif u.User != nil && len(u.User.Id) != 0 {\n\t\tu.IdUser = u.User.Id\n\t} else if len(u.IdUser) != 0 {\n\t\tif u.User == nil {\n\t\t\tu.User = &User{}\n\t\t}\n\t\tu.User.Id = u.IdUser\n\t}\n}\n\nfunc (u *IssueComment) Validate() (err error) ", "output": "{\n\tu.Initialize()\n\n\tif len(u.Body) == 0 {\n\t\terr = errors.New(\"missing body\")\n\t\treturn\n\t}\n\tif len(u.IdIssue) == 0 {\n\t\terr = errors.New(\"missing issue\")\n\t\treturn\n\t}\n\n\treturn\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"os\"\n\n\t\"github.com/gambol99/rbd-fence/pkg/rbd\"\n\n\t\"github.com/golang/glog\"\n)\n\nvar config struct {\n\taddress string\n}\n\n\n\nfunc main() {\n\tflag.Parse()\n\tif config.address == \"\" {\n\t\tglog.Errorf(\"You have not specified the ip address of the client to remove lock ownership\")\n\t\tos.Exit(1)\n\t}\n\n\tclient, err := rbd.NewRBDInterface()\n\tif err != nil {\n\t\tglog.Errorf(\"Failed to create a client interface for rbd, error: %s\", err)\n\t\tos.Exit(1)\n\t}\n\n\terr = client.UnlockClient(config.address)\n\tif err != nil {\n\t\tglog.Errorf(\"Failed to unlock the images held by %s\", config.address)\n\t\tos.Exit(1)\n\t}\n\n\tglog.Infof(\"Successfully remove any locks\")\n}\n\nfunc init() ", "output": "{\n\tflag.StringVar(&config.address, \"ip\", \"\", \"the ip address of the client which you wish to unlock\")\n}"}
{"input": "package gate\n\nimport (\n\t\"github.com/lonng/nano/component\"\n\t\"github.com/lonng/nano/examples/cluster/protocol\"\n\t\"github.com/lonng/nano/session\"\n\t\"github.com/pingcap/errors\"\n)\n\ntype BindService struct {\n\tcomponent.Base\n\tnextGateUid int64\n}\n\n\n\ntype (\n\tLoginRequest struct {\n\t\tNickname string `json:\"nickname\"`\n\t}\n\tLoginResponse struct {\n\t\tCode int `json:\"code\"`\n\t}\n)\n\nfunc (bs *BindService) Login(s *session.Session, msg *LoginRequest) error {\n\tbs.nextGateUid++\n\tuid := bs.nextGateUid\n\trequest := &protocol.NewUserRequest{\n\t\tNickname: msg.Nickname,\n\t\tGateUid:  uid,\n\t}\n\tif err := s.RPC(\"TopicService.NewUser\", request); err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\treturn s.Response(&LoginResponse{})\n}\n\nfunc (bs *BindService) BindChatServer(s *session.Session, msg []byte) error {\n\treturn errors.Errorf(\"not implement\")\n}\n\nfunc newBindService() *BindService ", "output": "{\n\treturn &BindService{}\n}"}
{"input": "package m3\n\nimport (\n\txresource \"github.com/m3db/m3/src/x/resource\"\n\txwatch \"github.com/m3db/m3/src/x/watch\"\n)\n\ntype clusterNamespacesWatcher struct {\n\twatchable xwatch.Watchable\n}\n\n\nfunc NewClusterNamespacesWatcher() ClusterNamespacesWatcher {\n\twatchable := xwatch.NewWatchable()\n\treturn &clusterNamespacesWatcher{watchable: watchable}\n}\n\n\n\nfunc (n *clusterNamespacesWatcher) Get() ClusterNamespaces {\n\tvalue := n.watchable.Get()\n\tif value == nil {\n\t\treturn nil\n\t}\n\n\treturn value.(ClusterNamespaces)\n}\n\nfunc (n *clusterNamespacesWatcher) RegisterListener(\n\tlistener ClusterNamespacesListener,\n) xresource.SimpleCloser {\n\t_, watch, _ := n.watchable.Watch()\n\n\tnamespaces := watch.Get()\n\n\tif namespaces != nil {\n\t\t<-watch.C() \n\t\tlistener.OnUpdate(namespaces.(ClusterNamespaces))\n\t}\n\n\tgo func() {\n\t\tfor range watch.C() {\n\t\t\tlistener.OnUpdate(watch.Get().(ClusterNamespaces))\n\t\t}\n\t}()\n\n\treturn watch\n}\n\nfunc (n *clusterNamespacesWatcher) Close() {\n\tn.watchable.Close()\n}\n\nfunc (n *clusterNamespacesWatcher) Update(namespaces ClusterNamespaces) error ", "output": "{\n\treturn n.watchable.Update(namespaces)\n}"}
{"input": "package config\n\nimport (\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"testing\"\n\n\t. \"github.com/pingcap/check\"\n)\n\nvar _ = Suite(&testConfigSuite{})\n\ntype testConfigSuite struct{}\n\n\n\nfunc (s *testConfigSuite) TestConfig(c *C) {\n\tconf := new(Config)\n\tconf.Binlog.Enable = true\n\tconf.Binlog.IgnoreError = true\n\tconf.TiKVClient.CommitTimeout = \"10s\"\n\n\tconfigFile := \"config.toml\"\n\t_, localFile, _, _ := runtime.Caller(0)\n\tconfigFile = path.Join(path.Dir(localFile), configFile)\n\n\tf, err := os.Create(configFile)\n\tc.Assert(err, IsNil)\n\t_, err = f.WriteString(`[performance]\n[tikv-client]\ncommit-timeout=\"41s\"`)\n\tc.Assert(err, IsNil)\n\tc.Assert(f.Sync(), IsNil)\n\n\tc.Assert(conf.Load(configFile), IsNil)\n\n\tc.Assert(conf.Binlog.Enable, Equals, true)\n\n\tc.Assert(conf.TiKVClient.CommitTimeout, Equals, \"41s\")\n\tc.Assert(f.Close(), IsNil)\n\tc.Assert(os.Remove(configFile), IsNil)\n\n\tconfigFile = path.Join(path.Dir(localFile), \"config.toml.example\")\n\tc.Assert(conf.Load(configFile), IsNil)\n\n\tc.Assert(conf, DeepEquals, GetGlobalConfig())\n}\n\nfunc TestT(t *testing.T) ", "output": "{\n\tCustomVerboseFlag = true\n\tTestingT(t)\n}"}
{"input": "package iso20022\n\n\ntype StatisticsByPredefinedTimePeriods2 struct {\n\n\tHighestPriceValue12Months *PriceValue5 `xml:\"HghstPricVal12Mnths,omitempty\"`\n\n\tLowestPriceValue12Months *PriceValue5 `xml:\"LwstPricVal12Mnths,omitempty\"`\n\n\tOneYearPriceChange *PriceValueChange1 `xml:\"OneYrPricChng,omitempty\"`\n\n\tThreeYearPriceChange *PriceValueChange1 `xml:\"ThreeYrPricChng,omitempty\"`\n\n\tFiveYearPriceChange *PriceValueChange1 `xml:\"FiveYrPricChng,omitempty\"`\n}\n\nfunc (s *StatisticsByPredefinedTimePeriods2) AddHighestPriceValue12Months() *PriceValue5 {\n\ts.HighestPriceValue12Months = new(PriceValue5)\n\treturn s.HighestPriceValue12Months\n}\n\nfunc (s *StatisticsByPredefinedTimePeriods2) AddLowestPriceValue12Months() *PriceValue5 {\n\ts.LowestPriceValue12Months = new(PriceValue5)\n\treturn s.LowestPriceValue12Months\n}\n\nfunc (s *StatisticsByPredefinedTimePeriods2) AddOneYearPriceChange() *PriceValueChange1 {\n\ts.OneYearPriceChange = new(PriceValueChange1)\n\treturn s.OneYearPriceChange\n}\n\n\n\nfunc (s *StatisticsByPredefinedTimePeriods2) AddFiveYearPriceChange() *PriceValueChange1 {\n\ts.FiveYearPriceChange = new(PriceValueChange1)\n\treturn s.FiveYearPriceChange\n}\n\nfunc (s *StatisticsByPredefinedTimePeriods2) AddThreeYearPriceChange() *PriceValueChange1 ", "output": "{\n\ts.ThreeYearPriceChange = new(PriceValueChange1)\n\treturn s.ThreeYearPriceChange\n}"}
{"input": "package vault\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n\ntype AuthType interface {\n\tDescribe() string\n\tGetType() string\n\tgetAuthConfig() map[string]interface{}\n\tgetAuthMountConfig() map[string]interface{}\n\tConfigure(c *VCClient) error\n\tTuneMount(c *VCClient, path string) error\n\tWriteUsers(c *VCClient) error\n\tWriteGroups(c *VCClient) error\n}\n\n\nfunc (c *VCClient) AuthExist(name string) bool {\n\tauth, err := c.Sys().ListAuth()\n\tif err != nil {\n\t\treturn false\n\t}\n\tfor a := range auth {\n\t\tif strings.TrimSuffix(a, \"/\") == name {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n\nfunc Path(a AuthType) string {\n\treturn fmt.Sprintf(\"auth/%s\", a.GetType())\n}\n\n\nfunc (c *VCClient) AuthEnable(a AuthType) error {\n\tif err := c.Sys().EnableAuth(a.GetType(), a.GetType(), a.Describe()); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc (c *VCClient) AuthConfigure(a AuthType) error {\n\tif err := a.WriteUsers(c); err != nil {\n\t\treturn err\n\t}\n\tif err := a.WriteGroups(c); err != nil {\n\t\treturn err\n\t}\n\tif err := a.TuneMount(c, Path(a)); err != nil {\n\t\treturn err\n\t}\n\n\tif err := a.Configure(c); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\nfunc EnableAndConfigure(a AuthType, c *VCClient) error ", "output": "{\n\tif !c.AuthExist(a.GetType()) {\n\t\tif err := c.AuthEnable(a); err != nil {\n\t\t\treturn fmt.Errorf(\"Error enabling auth mount: %v\", err)\n\t\t}\n\t}\n\tif err := c.AuthConfigure(a); err != nil {\n\t\treturn fmt.Errorf(\"Error configuring auth mount: %v\", err)\n\t}\n\n\treturn nil\n}"}
{"input": "package progressbar\n\nimport \"fmt\"\n\n\n\n\ntype Bar struct {\n\tpercent int64  \n\tcur     int64  \n\tstart   int64  \n\ttotal   int64  \n\trate    string \n\tgraph   string \n}\n\nfunc (bar *Bar) NewOption(start, total int64) {\n\tbar.cur = start\n\tbar.start = start\n\tbar.total = total\n\tbar.graph = \"█\"\n\tbar.percent = bar.getPercent()\n}\n\nfunc (bar *Bar) getPercent() int64 {\n\treturn int64(float32(bar.cur-bar.start) / float32(bar.total-bar.start) * 100)\n}\n\n\n\nfunc (bar *Bar) Finish() {\n\tfmt.Println()\n}\n\nfunc (bar *Bar) Play(cur int64) ", "output": "{\n\tbar.cur = cur\n\tlast := bar.percent\n\tbar.percent = bar.getPercent()\n\tif bar.percent != last && bar.percent%2 == 0 {\n\t\tbar.rate += bar.graph\n\t}\n\tfmt.Printf(\"\\r[%-50s]%3d%% %8d/%d\", bar.rate, bar.percent, bar.cur, bar.total)\n}"}
{"input": "package main\n\nimport \"fmt\"\nimport \"sort\"\n\ntype ByLength []string\n\n\n\nfunc (s ByLength) Swap(i, j int) {\n    s[i], s[j] = s[j], s[i]\n}\n\nfunc (s ByLength) Less(i, j int) bool {\n    return len(s[i]) < len(s[j])\n}\n\nfunc main() {\n    fruits := []string{\"peach\", \"banana\", \"kiwi\"}\n    sort.Sort(ByLength(fruits))\n    fmt.Println(fruits)\n}\n\nfunc (s ByLength) Len() int ", "output": "{\n    return len(s)\n}"}
{"input": "package openchain\n\nimport \"github.com/spf13/viper\"\n\n\n\n\nfunc GetRootNode() (string, error) ", "output": "{\n\treturn viper.GetString(\"peer.discovery.rootnode\"), nil\n}"}
{"input": "package golbStoreIpsum\n\nimport (\n\t\"github.com/cryptix/golbStore\"\n)\n\nfunc (b IpsumBlog) Latest(n int, withText bool) ([]*golbStore.Entry, error) {\n\treturn nil, nil\n}\n\nfunc (b IpsumBlog) Get(id string) (*golbStore.Entry, error) {\n\te, found := b.store[id]\n\tif !found {\n\t\treturn nil, golbStore.ErrEntryNotFound\n\t}\n\n\treturn e, nil\n}\n\nfunc (b IpsumBlog) Delete(id string) error {\n\treturn nil\n}\n\n\n\nfunc (b IpsumBlog) Save(e *golbStore.Entry) error ", "output": "{\n\tb.store[e.ID] = e\n\n\treturn nil\n}"}
{"input": "package swt\n\nimport \"github.com/timob/javabind\"\n\ntype CustomExtendedModifyListenerInterface interface {\n\n\tModifyText(a CustomExtendedModifyEventInterface) \n}\n\ntype CustomExtendedModifyListener struct {\n\t*javabind.Callable\n}\n\n\n\n\nfunc (jbobject *CustomExtendedModifyListener) ModifyText(a CustomExtendedModifyEventInterface)  ", "output": "{\n\tconv_a := javabind.NewGoToJavaCallable()\n\tif err := conv_a.Convert(a); err != nil {\n\t\tpanic(err)\n\t}\n\t_, err := jbobject.CallMethod(javabind.GetEnv(), \"modifyText\", javabind.Void, conv_a.Value().Cast(\"org/eclipse/swt/custom/ExtendedModifyEvent\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tconv_a.CleanUp()\n\n}"}
{"input": "package macaron\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\n\t\"gitea.com/macaron/inject\"\n)\n\n\n\n\n\ntype ReturnHandler func(*Context, []reflect.Value)\n\nfunc canDeref(val reflect.Value) bool {\n\treturn val.Kind() == reflect.Interface || val.Kind() == reflect.Ptr\n}\n\nfunc isError(val reflect.Value) bool {\n\t_, ok := val.Interface().(error)\n\treturn ok\n}\n\n\n\nfunc defaultReturnHandler() ReturnHandler {\n\treturn func(ctx *Context, vals []reflect.Value) {\n\t\trv := ctx.GetVal(inject.InterfaceOf((*http.ResponseWriter)(nil)))\n\t\tresp := rv.Interface().(http.ResponseWriter)\n\t\tvar respVal reflect.Value\n\t\tif len(vals) > 1 && vals[0].Kind() == reflect.Int {\n\t\t\tresp.WriteHeader(int(vals[0].Int()))\n\t\t\trespVal = vals[1]\n\t\t} else if len(vals) > 0 {\n\t\t\trespVal = vals[0]\n\n\t\t\tif isError(respVal) {\n\t\t\t\terr := respVal.Interface().(error)\n\t\t\t\tif err != nil {\n\t\t\t\t\tctx.internalServerError(ctx, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if canDeref(respVal) {\n\t\t\t\tif respVal.IsNil() {\n\t\t\t\t\treturn \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif canDeref(respVal) {\n\t\t\trespVal = respVal.Elem()\n\t\t}\n\t\tif isByteSlice(respVal) {\n\t\t\t_, _ = resp.Write(respVal.Bytes())\n\t\t} else {\n\t\t\t_, _ = resp.Write([]byte(respVal.String()))\n\t\t}\n\t}\n}\n\nfunc isByteSlice(val reflect.Value) bool ", "output": "{\n\treturn val.Kind() == reflect.Slice && val.Type().Elem().Kind() == reflect.Uint8\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/veandco/go-sdl2/sdl\"\n\t\"lsystem/turt\"\n)\n\ntype SiriTriangle struct {\n\tcur []Symbol\n\tpen *turt.Turtle\n}\n\nfunc NewSiriTriangle() *SiriTriangle {\n\treturn &SiriTriangle{\n\t\tcur: []Symbol{F, Minus, G, Minus, G},\n\t\tpen: turt.NewTurtle(300, 200, 10),\n\t}\n}\n\nfunc (s *SiriTriangle) currentSymbolSet() []Symbol {\n\treturn s.cur\n}\n\nfunc (st *SiriTriangle) setCurrentSymbolSet(s []Symbol) {\n\tst.cur = s\n}\n\nfunc (st *SiriTriangle) applyDrawRule(s Symbol, surf *sdl.Surface) {\n\tswitch s {\n\tcase F, G:\n\t\tst.pen.Forward()\n\t\trect := sdl.Rect{int32(st.pen.Location.X), int32(st.pen.Location.Y), 1, 1}\n\t\tsurf.FillRect(&rect, 0xffff0000)\n\tcase Minus:\n\t\tst.pen.Turn(turt.RIGHT, 120)\n\tcase Plus:\n\t\tst.pen.Turn(turt.LEFT, 120)\n\tdefault:\n\t\treturn\n\t}\n}\n\n\n\n\n\n\n\n\n\nfunc (st *SiriTriangle) String() string {\n\tvar s string\n\tbod := st.currentSymbolSet()\n\tlbod := len(bod)\n\tfor i := 0; i < lbod; i++ {\n\t\tsym := bod[i]\n\t\tswitch sym {\n\t\tcase F:\n\t\t\ts += \"F \"\n\t\tcase G:\n\t\t\ts += \"G \"\n\t\tcase Minus:\n\t\t\ts += \"Minus \"\n\t\tcase Plus:\n\t\t\ts += \"Plus \"\n\t\t}\n\t}\n\treturn s\n}\n\nfunc (st *SiriTriangle) applyRule(s Symbol) []Symbol ", "output": "{\n\tswitch s {\n\tcase F:\n\t\treturn []Symbol{F, Minus, G, Plus, F, Plus, G, Minus, F}\n\tcase G:\n\t\treturn []Symbol{G, G}\n\tcase Minus:\n\t\treturn []Symbol{Minus}\n\tcase Plus:\n\t\treturn []Symbol{Plus}\n\tdefault:\n\t\treturn []Symbol{s}\n\t}\n}"}
{"input": "package util\n\nimport (\n\t\"os\"\n\t\"testing\"\n)\n\n\n\n\n\nfunc TestGetPIDLimit(t *testing.T) ", "output": "{\n\tt.Parallel()\n\trunTest := os.Getenv(\"CEPH_CSI_RUN_ALL_TESTS\")\n\tif runTest == \"\" {\n\t\tt.Skip(\"not running test that requires root permissions and cgroup support\")\n\t}\n\n\tlimit, err := GetPIDLimit()\n\tif err != nil {\n\t\tt.Errorf(\"no error should be returned, got: %v\", err)\n\t}\n\tif limit == 0 {\n\t\tt.Error(\"a PID limit of 0 is invalid\")\n\t}\n\n\terr = SetPIDLimit(4096)\n\tif err != nil {\n\t\tt.Log(\"failed to set PID limit, are you running as root?\")\n\t} else {\n\t\terr = SetPIDLimit(limit)\n\t\tif err != nil {\n\t\t\tt.Logf(\"failed to reset PID to original limit %d\", limit)\n\t\t}\n\t}\n}"}
{"input": "package migrations\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"strconv\"\n)\n\n\n\nfunc withTransaction(db *sql.DB, handler func(tx *sql.Tx) error) error {\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"beginning transaction: %s\", err.Error())\n\t}\n\n\thandleErr := handler(tx)\n\tif handleErr != nil {\n\t\tif err := tx.Rollback(); err != nil {\n\t\t\treturn fmt.Errorf(\"handler AND rollback failed: %s (rollback error: %s)\", handleErr.Error(), err.Error())\n\t\t}\n\t\treturn fmt.Errorf(\"handler failed: %s\", handleErr.Error())\n\t}\n\n\tif err := tx.Commit(); err != nil {\n\t\treturn fmt.Errorf(\"commit failed: %s\", err.Error())\n\t}\n\n\treturn nil\n}\n\nfunc writeRepoVer(repoPath string, version int) error {\n\tf1, err := os.Create(path.Join(repoPath, \"repover\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = f1.Write([]byte(strconv.Itoa(version)))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn f1.Close()\n}\n\nfunc writeIPFSVer(repoPath string, version int) error {\n\tf1, err := os.Create(path.Join(repoPath, \"version\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = f1.Write([]byte(strconv.Itoa(version)))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn f1.Close()\n}\n\nfunc OpenDB(repoPath string, dbPassword string, testnet bool) (*sql.DB, error) ", "output": "{\n\tvar dbPath string\n\tif testnet {\n\t\tdbPath = path.Join(repoPath, \"datastore\", \"testnet.db\")\n\t} else {\n\t\tdbPath = path.Join(repoPath, \"datastore\", \"mainnet.db\")\n\t}\n\tdb, err := sql.Open(\"sqlite3\", dbPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif dbPassword != \"\" {\n\t\tp := \"pragma key='\" + dbPassword + \"';\"\n\t\t_, err = db.Exec(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn db, nil\n}"}
{"input": "package configuration_test\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n)\n\n\n\nfunc TestConfig(t *testing.T) ", "output": "{\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Config Suite\")\n}"}
{"input": "package resources\n\nimport \"github.com/cloudfoundry/cli/cf/models\"\n\ntype PaginatedSpaceQuotaResources struct {\n\tResources []SpaceQuotaResource\n}\n\ntype SpaceQuotaResource struct {\n\tResource\n\tEntity models.SpaceQuotaResponse\n}\n\n\n\nfunc (resource SpaceQuotaResource) ToModel() models.SpaceQuota ", "output": "{\n\tentity := resource.Entity\n\n\tappInstanceLimit := UnlimitedAppInstances\n\tif entity.AppInstanceLimit != \"\" {\n\t\ti, err := entity.AppInstanceLimit.Int64()\n\t\tif err == nil {\n\t\t\tappInstanceLimit = int(i)\n\t\t}\n\t}\n\n\treturn models.SpaceQuota{\n\t\tGuid:                    resource.Metadata.Guid,\n\t\tName:                    entity.Name,\n\t\tMemoryLimit:             entity.MemoryLimit,\n\t\tInstanceMemoryLimit:     entity.InstanceMemoryLimit,\n\t\tRoutesLimit:             entity.RoutesLimit,\n\t\tServicesLimit:           entity.ServicesLimit,\n\t\tNonBasicServicesAllowed: entity.NonBasicServicesAllowed,\n\t\tOrgGuid:                 entity.OrgGuid,\n\t\tAppInstanceLimit:        appInstanceLimit,\n\t}\n}"}
{"input": "package handler\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"github.com/openshift/ansible-service-broker/pkg/broker\"\n)\n\n\n\nfunc writeResponse(w http.ResponseWriter, code int, obj interface{}) error {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(code)\n\n\tb, err := json.Marshal(obj)\n\tif err != nil {\n\t\treturn err\n\t}\n\ti := bytes.Buffer{}\n\tjson.Indent(&i, b, \"\", \"  \")\n\ti.WriteString(\"\\n\")\n\t_, err = w.Write(i.Bytes())\n\treturn err\n}\n\nfunc writeDefaultResponse(w http.ResponseWriter, code int, resp interface{}, err error) error {\n\tif err == nil {\n\t\treturn writeResponse(w, code, resp)\n\t}\n\n\treturn writeResponse(w, http.StatusInternalServerError, broker.ErrorResponse{Description: err.Error()})\n}\n\nfunc readRequest(r *http.Request, obj interface{}) error ", "output": "{\n\tif r.Header.Get(\"Content-Type\") != \"application/json\" {\n\t\treturn errors.New(\"error: invalid content-type\")\n\t}\n\n\treturn json.NewDecoder(r.Body).Decode(&obj)\n}"}
{"input": "package packer\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\n\n\nvar GitCommit string\n\n\nconst Version = \"0.5.3\"\n\n\n\n\nconst VersionPrerelease = \"dev\"\n\ntype versionCommand byte\n\nfunc (versionCommand) Help() string {\n\treturn `usage: packer version\n\nOutputs the version of Packer that is running. There are no additional\ncommand-line flags for this command.`\n}\n\nfunc (versionCommand) Run(env Environment, args []string) int {\n\tenv.Ui().Machine(\"version\", Version)\n\tenv.Ui().Machine(\"version-prelease\", VersionPrerelease)\n\tenv.Ui().Machine(\"version-commit\", GitCommit)\n\n\tenv.Ui().Say(VersionString())\n\treturn 0\n}\n\n\n\n\n\n\nfunc VersionString() string {\n\tvar versionString bytes.Buffer\n\tfmt.Fprintf(&versionString, \"Packer v%s\", Version)\n\tif VersionPrerelease != \"\" {\n\t\tfmt.Fprintf(&versionString, \".%s\", VersionPrerelease)\n\n\t\tif GitCommit != \"\" {\n\t\t\tfmt.Fprintf(&versionString, \" (%s)\", GitCommit)\n\t\t}\n\t}\n\n\treturn versionString.String()\n}\n\nfunc (versionCommand) Synopsis() string ", "output": "{\n\treturn \"print Packer version\"\n}"}
{"input": "package queue\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype Node struct {\n\tvalue interface{}\n\tnext  *Node\n}\n\nfunc NewNode(value interface{}) *Node {\n\tnode := new(Node)\n\tnode.value = value\n\n\treturn node\n}\n\ntype Queue struct {\n\thead *Node\n\ttail *Node\n}\n\nfunc NewQueue(args ...interface{}) *Queue {\n\tlist := new(Queue)\n\n\tfor _, v := range args {\n\t\tlist.Enqueue(v)\n\t}\n\n\treturn list\n}\n\nfunc (q *Queue) String() string {\n\tnode := q.head\n\n\tvar values []string\n\n\tif node == nil {\n\t\treturn \"[]\"\n\t}\n\n\tfor node.next != nil {\n\t\tvalues = append(values, fmt.Sprintf(\"%v\", node.value))\n\n\t\tnode = node.next\n\t}\n\tvalues = append(values, fmt.Sprintf(\"%v\", node.value))\n\n\treturn fmt.Sprintf(\"[%s]\", strings.Join(values, \", \"))\n}\n\n\n\nfunc (q *Queue) Dequeue() (value interface{}, ok bool) {\n\n\tif q.head == nil {\n\t\treturn 0, false\n\t} else {\n\t\tnode := q.head\n\t\tq.head = node.next\n\t\treturn node.value, true\n\t}\n}\n\nfunc (q *Queue) Peek() (value interface{}, ok bool) {\n\tif q.head == nil {\n\t\treturn 0, false\n\t} else {\n\t\treturn q.head.value, true\n\t}\n}\n\nfunc (q *Queue) Empty() bool {\n\tif q.head == nil {\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}\n\nfunc (q *Queue) Enqueue(value interface{}) ", "output": "{\n\tnewTail := NewNode(value)\n\n\tif q.head == nil {\n\t\tq.head = newTail\n\t\tq.tail = q.head\n\t} else {\n\t\tq.tail.next = newTail\n\t\tq.tail = newTail\n\t}\n}"}
{"input": "package flavors\n\nimport (\n\t\"github.com/gophercloud/gophercloud\"\n)\n\nfunc getURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id)\n}\n\nfunc listURL(client *gophercloud.ServiceClient) string {\n\treturn client.ServiceURL(\"flavors\", \"detail\")\n}\n\nfunc createURL(client *gophercloud.ServiceClient) string {\n\treturn client.ServiceURL(\"flavors\")\n}\n\nfunc deleteURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id)\n}\n\nfunc accessURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-flavor-access\")\n}\n\nfunc accessActionURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"action\")\n}\n\nfunc extraSpecsListURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\")\n}\n\n\n\nfunc extraSpecsCreateURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\")\n}\n\nfunc extraSpecUpdateURL(client *gophercloud.ServiceClient, id, key string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\", key)\n}\n\nfunc extraSpecDeleteURL(client *gophercloud.ServiceClient, id, key string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\", key)\n}\n\nfunc extraSpecsGetURL(client *gophercloud.ServiceClient, id, key string) string ", "output": "{\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\", key)\n}"}
{"input": "package travel\n\nimport (\n\t\"os\"\n\n\t\"github.com/akerl/speculate/v2/creds\"\n)\n\n\n\nfunc stringInSlice(list []string, key string) bool {\n\tfor _, item := range list {\n\t\tif item == key {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc sliceUnion(a []string, b []string) []string {\n\tvar res []string\n\tfor _, item := range a {\n\t\tif stringInSlice(b, item) {\n\t\t\tres = append(res, item)\n\t\t}\n\t}\n\treturn res\n}\n\ntype attrFunc func(Path) string\n\nfunc uniquePathAttributes(paths []Path, af attrFunc) []string {\n\ttmpMap := map[string]bool{}\n\tfor _, item := range paths {\n\t\tattr := af(item)\n\t\ttmpMap[attr] = true\n\t}\n\ttmpList := []string{}\n\tfor item := range tmpMap {\n\t\ttmpList = append(tmpList, item)\n\t}\n\treturn tmpList\n}\n\nfunc filterPathsByAttribute(paths []Path, match string, af attrFunc) []Path {\n\tfilteredPaths := []Path{}\n\tfor _, item := range paths {\n\t\tif af(item) == match {\n\t\t\tfilteredPaths = append(filteredPaths, item)\n\t\t}\n\t}\n\treturn filteredPaths\n}\n\nfunc clearEnvironment() error ", "output": "{\n\tfor varName := range creds.Translations[\"envvar\"] {\n\t\tlogger.InfoMsgf(\"Unsetting env var: %s\", varName)\n\t\terr := os.Unsetenv(varName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package jwt\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n)\n\n\n\n\n\n\ntype Token struct {\n\tExpiryDate int64\n\tRawToken   string\n}\n\n\n\nconst expirationSkew = 30\n\n\nfunc (t *Token) Expired() bool {\n\treturn time.Now().Unix()+expirationSkew > t.ExpiryDate\n}\n\n\n\nfunc (t *Token) GetAuthenticationHeaderValue() string {\n\treturn fmt.Sprintf(\"Bearer %s\", t.RawToken)\n}\n\n\n\n\n\ntype tokenPayload struct {\n\tExpirationTime int64 `json:\"exp\"`\n}\n\n\n\n\n\nfunc New(token string) (Token, error) {\n\tif len(token) == 0 {\n\t\treturn Token{}, errors.New(\"no token given, a token should be set\")\n\t}\n\n\ttokenParts := strings.Split(token, \".\")\n\tif len(tokenParts) != 3 {\n\t\treturn Token{}, fmt.Errorf(\"invalid token '%s' given, token should exist at least of 3 parts\", token)\n\t}\n\n\tjsonBody, err := base64.RawStdEncoding.DecodeString(tokenParts[1])\n\tif err != nil {\n\t\treturn Token{}, errors.New(\"could not decode token, invalid base64\")\n\t}\n\n\tvar tokenRequest tokenPayload\n\terr = json.Unmarshal(jsonBody, &tokenRequest)\n\tif err != nil {\n\t\treturn Token{}, errors.New(\"could not read token body, invalid json\")\n\t}\n\n\treturn Token{\n\t\tRawToken:   token,\n\t\tExpiryDate: tokenRequest.ExpirationTime,\n\t}, nil\n}\n\nfunc (t *Token) String() string ", "output": "{\n\treturn t.RawToken\n}"}
{"input": "package testclient\n\nimport (\n\tkapi \"k8s.io/kubernetes/pkg/api\"\n\tktestclient \"k8s.io/kubernetes/pkg/client/unversioned/testclient\"\n\n\tuserapi \"github.com/openshift/origin/pkg/user/api\"\n)\n\n\n\ntype FakeUsers struct {\n\tFake *Fake\n}\n\nfunc (c *FakeUsers) Get(name string) (*userapi.User, error) {\n\tobj, err := c.Fake.Invokes(ktestclient.NewRootGetAction(\"users\", name), &userapi.User{})\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*userapi.User), err\n}\n\nfunc (c *FakeUsers) List(opts kapi.ListOptions) (*userapi.UserList, error) {\n\tobj, err := c.Fake.Invokes(ktestclient.NewRootListAction(\"users\", opts), &userapi.UserList{})\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*userapi.UserList), err\n}\n\n\n\nfunc (c *FakeUsers) Update(inObj *userapi.User) (*userapi.User, error) {\n\tobj, err := c.Fake.Invokes(ktestclient.NewRootUpdateAction(\"users\", inObj), inObj)\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*userapi.User), err\n}\n\nfunc (c *FakeUsers) Delete(name string) error {\n\t_, err := c.Fake.Invokes(ktestclient.NewRootDeleteAction(\"users\", name), nil)\n\treturn err\n}\n\nfunc (c *FakeUsers) Create(inObj *userapi.User) (*userapi.User, error) ", "output": "{\n\tobj, err := c.Fake.Invokes(ktestclient.NewRootCreateAction(\"users\", inObj), inObj)\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*userapi.User), err\n}"}
{"input": "package project\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTrimSpaceAndNonPrintable_unicode(t *testing.T) {\n\tt.Parallel()\n\n\textraChars := \"state\\uFEFF\"\n\twant := \"state\"\n\tgot := TrimSpaceAndNonPrintable(extraChars)\n\n\tif want != got {\n\t\tt.Fatalf(\"wrong trim, want: %q got: %q\", want, got)\n\t}\n}\n\nfunc TestTrimSpaceAndNonPrintable_space(t *testing.T) {\n\tt.Parallel()\n\n\textraChars := \" state  \\r\\t\"\n\twant := \"state\"\n\tgot := TrimSpaceAndNonPrintable(extraChars)\n\n\tif want != got {\n\t\tt.Fatalf(\"wrong trim, want: %q got: %q\", want, got)\n\t}\n}\n\nfunc TestTrimSpace_unicode(t *testing.T) {\n\tt.Parallel()\n\n\textraChars := \"state\\uFEFF\"\n\twant := \"state\"\n\tgot := TrimSpace(extraChars)\n\n\tif want != got {\n\t\tt.Fatalf(\"wrong trim, want: %q got: %q\", want, got)\n\t}\n}\n\n\n\nfunc TestTrimSpace_space(t *testing.T) ", "output": "{\n\tt.Parallel()\n\n\textraChars := \" state  \\r\\t\"\n\twant := \"state\"\n\tgot := TrimSpace(extraChars)\n\n\tif want != got {\n\t\tt.Fatalf(\"wrong trim, want: %q got: %q\", want, got)\n\t}\n}"}
{"input": "package ros\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestSystemUser(t *testing.T) ", "output": "{\n\n\ttests := []struct {\n\t\tc Command\n\t\tv string\n\t}{\n\t\t{user(\"name\"), `/user print detail where name=\"name\"`},\n\t\t{addUser(\"name\", \"group\", \"password\"), `:if ([:len [/user find group=\"group\" name=\"name\"]] = 0) do={/user add group=\"group\" name=\"name\" password=\"password\"}`},\n\t\t{removeUser(\"name\"), `/user remove [find name=\"name\"]`},\n\t\t{setUser(\"name\", \"key\", \"value\"), `/user set [find name=\"name\"] key=\"value\"`},\n\t}\n\n\tfor _, x := range tests {\n\t\tr, err := x.c.Parse()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif r != x.v {\n\t\t\tt.Errorf(\"tool romon port mismatch: got '%s', expected '%s'\", r, x.v)\n\t\t}\n\t}\n}"}
{"input": "package errors\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\tapi_errors \"k8s.io/apimachinery/pkg/api/errors\"\n\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\nfunc isCRDError(status api_errors.APIStatus) bool {\n\tfor _, cause := range status.Status().Details.Causes {\n\t\tif strings.HasPrefix(cause.Message, \"404\") && cause.Type == v1.CauseTypeUnexpectedServerResponse {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isNoRouteToHostError(err error) bool {\n\treturn strings.Contains(err.Error(), \"no route to host\") || strings.Contains(err.Error(), \"i/o timeout\")\n}\n\nfunc isEmptyConfigError(err error) bool {\n\treturn strings.Contains(err.Error(), \"no configuration has been provided\")\n}\n\n\n\nfunc GetError(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\tswitch {\n\tcase isEmptyConfigError(err):\n\t\treturn newNoKubeConfig(err.Error())\n\tcase isNoRouteToHostError(err):\n\t\treturn newNoRouteToHost(err.Error())\n\tdefault:\n\t\tapiStatus, ok := err.(api_errors.APIStatus)\n\t\tif !ok {\n\t\t\treturn err\n\t\t}\n\t\tif apiStatus.Status().Details == nil {\n\t\t\treturn err\n\t\t}\n\t\tvar knerr *KNError\n\t\tif isCRDError(apiStatus) {\n\t\t\tknerr = newInvalidCRD(apiStatus.Status().Details.Group)\n\t\t\tknerr.Status = apiStatus\n\t\t\treturn knerr\n\t\t}\n\t\treturn err\n\t}\n}\n\n\n\n\nfunc IsForbiddenError(err error) bool ", "output": "{\n\tif status, ok := err.(api_errors.APIStatus); ok {\n\t\treturn status.Status().Code == int32(http.StatusForbidden)\n\t}\n\treturn false\n}"}
{"input": "package route\n\nimport (\n\t\"os\"\n\n\t\"github.com/iron-io/functions/examples/blog/database\"\n)\n\n\n\nfunc HandlePostRead(db *database.Database, auth map[string]interface{}) ", "output": "{\n\tid := os.Getenv(\"PARAM_ID\")\n\n\tif id == \"\" {\n\t\tSendError(\"Missing post ID\")\n\t\treturn\n\t}\n\n\tpost, err := db.GetPost(id)\n\tif err != nil {\n\t\tSendError(\"Couldn't retrieve that post\")\n\t\treturn\n\t}\n\n\tSendResponse(Response{\n\t\t\"post\": post,\n\t})\n}"}
{"input": "package identity\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype cacheData struct {\n\tIdentity Identity `json:\"identity\"`\n}\n\n\ntype IdentityCache struct {\n\tFile string\n}\n\n\nfunc NewIdentityCache(dir string, jsonFile string) IdentityCacheInterface {\n\treturn &IdentityCache{\n\t\tFile: filepath.Join(dir, jsonFile),\n\t}\n}\n\n\nfunc (ic *IdentityCache) GetIdentity() (identity Identity, err error) {\n\tif !ic.cacheExists() {\n\t\terr = errors.New(\"cache file does not exist\")\n\t\treturn\n\t}\n\n\tcache, err := ic.readCache()\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn cache.Identity, nil\n}\n\n\nfunc (ic *IdentityCache) StoreIdentity(identity Identity) error {\n\tcache := cacheData{\n\t\tIdentity: identity,\n\t}\n\n\treturn ic.writeCache(cache)\n}\n\n\n\nfunc (ic *IdentityCache) readCache() (cache *cacheData, err error) {\n\tdata, err := ioutil.ReadFile(ic.File)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = json.Unmarshal(data, &cache)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (ic *IdentityCache) writeCache(cache cacheData) (err error) {\n\tcacheString, err := json.Marshal(cache)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = ioutil.WriteFile(ic.File, cacheString, 0644)\n\treturn\n}\n\nfunc (ic *IdentityCache) cacheExists() bool ", "output": "{\n\tif _, err := os.Stat(ic.File); os.IsNotExist(err) {\n\t\treturn false\n\t}\n\n\treturn true\n}"}
{"input": "package algorithm\n\nimport (\n\t\"fmt\"\n\n\t\"shadowsocks-go/pkg/crypto/algorithm/aes\"\n\t\"shadowsocks-go/pkg/crypto/algorithm/blowfish\"\n\t\"shadowsocks-go/pkg/crypto/algorithm/cast5\"\n\t\"shadowsocks-go/pkg/crypto/algorithm/chacha20\"\n\t\"shadowsocks-go/pkg/crypto/algorithm/des\"\n\t\"shadowsocks-go/pkg/crypto/algorithm/rc4md5\"\n\t\"shadowsocks-go/pkg/crypto/algorithm/salsa20\"\n)\n\nconst (\n\tAlgorithmTypeUnset = \"\"\n\tAlgorithmTypeAES128CFB = \"aes-128-cfb\"\n\tAlgorithmTypeAES192CFB = \"aes-192-cfb\"\n\tAlgorithmTypeAES256CFB = \"aes-256-cfb\"\n\tAlgorithmTypeDESCFB = \"des-cfb\"\n\tAlgorithmTypeBFCFB = \"bf-cfb\"\n\tAlgorithmTypeCAST5CFB = \"cast5-cfb\"\n\tAlgorithmTypeRC4MD5 = \"rc4-md5\"\n\tAlgorithmTypeCHACHA20 = \"chacha20\"\n\tAlgorithmTypeSALSA20 = \"salsa20\"\n)\n\n\n\n\nfunc CreateAlgorithm(algType string) (Algorithm, error) ", "output": "{\n\tswitch algType {\n\tcase AlgorithmTypeUnset, AlgorithmTypeAES256CFB:\n\t\treturn aes.NewAES(AlgorithmTypeAES256CFB)\n\tcase AlgorithmTypeAES128CFB, AlgorithmTypeAES192CFB:\n\t\treturn aes.NewAES(algType)\n\tcase AlgorithmTypeDESCFB:\n\t\treturn des.NewDes(algType)\n\tcase AlgorithmTypeBFCFB:\n\t\treturn blowfish.NewBFCFB(algType)\n\tcase AlgorithmTypeCAST5CFB:\n\t\treturn cast5.NewCast5cfb(algType)\n\tcase AlgorithmTypeRC4MD5:\n\t\treturn rc4md5.NewRC4MD5(algType)\n\tcase AlgorithmTypeCHACHA20:\n\t\treturn chacha20.NewChaCha20(algType)\n\tcase AlgorithmTypeSALSA20:\n\t\treturn salsa20.NewSalsa20(algType)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"not support type %s\\r\\n\", algType)\n\t}\n}"}
{"input": "package tournaments\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\n\t\"appengine\"\n\n\t\"github.com/taironas/gonawin/extract\"\n\t\"github.com/taironas/gonawin/helpers\"\n\ttemplateshlp \"github.com/taironas/gonawin/helpers/templates\"\n\n\tmdl \"github.com/taironas/gonawin/models\"\n)\n\n\n\ntype GroupJSON struct {\n\tName  string\n\tTeams []TeamJSON\n}\n\n\n\ntype TeamJSON struct {\n\tName   string\n\tPoints int64\n\tGoalsF int64\n\tGoalsA int64\n\tIso    string\n}\n\n\n\nfunc Groups(w http.ResponseWriter, r *http.Request, u *mdl.User) error {\n\tif r.Method != \"GET\" {\n\t\treturn &helpers.BadRequest{Err: errors.New(helpers.ErrorCodeNotSupported)}\n\t}\n\n\tc := appengine.NewContext(r)\n\tdesc := \"Tournament Group Handler:\"\n\textract := extract.NewContext(c, desc, r)\n\n\tvar err error\n\tvar tournament *mdl.Tournament\n\tif tournament, err = extract.Tournament(); err != nil {\n\t\treturn err\n\t}\n\n\tgroups := mdl.Groups(c, tournament.GroupIds)\n\tgroupsJSON := formatGroupsJSON(groups)\n\n\tdata := struct {\n\t\tGroups []GroupJSON\n\t}{\n\t\tgroupsJSON,\n\t}\n\n\treturn templateshlp.RenderJSON(w, c, data)\n}\n\n\n\n\n\nfunc formatGroupsJSON(groups []*mdl.Tgroup) []GroupJSON ", "output": "{\n\n\tgroupsJSON := make([]GroupJSON, len(groups))\n\tfor i, g := range groups {\n\t\tgroupsJSON[i].Name = g.Name\n\t\tteams := make([]TeamJSON, len(g.Teams))\n\t\tfor j, t := range g.Teams {\n\t\t\tteams[j].Name = t.Name\n\t\t\tteams[j].Points = g.Points[j]\n\t\t\tteams[j].GoalsF = g.GoalsF[j]\n\t\t\tteams[j].GoalsA = g.GoalsA[j]\n\t\t\tteams[j].Iso = t.Iso\n\t\t}\n\t\tgroupsJSON[i].Teams = teams\n\t}\n\treturn groupsJSON\n}"}
{"input": "package pes\n\nimport \"io\"\nimport \"bytes\"\nimport \"github.com/32bitkid/bitreader\"\n\n\nfunc NewPayloadReader(source io.Reader) io.Reader {\n\treturn &payloadReader{\n\t\tbr:            bitreader.NewReader(source),\n\t\tcurrentPacket: new(Packet),\n\t}\n}\n\ntype payloadReader struct {\n\tbr            bitreader.BitReader\n\tcurrentPacket *Packet\n\tremainder     bytes.Buffer\n}\n\n\n\nfunc (r *payloadReader) Read(p []byte) (n int, err error) ", "output": "{\n\tfor len(p) > 0 {\n\t\tcn, err := r.remainder.Read(p)\n\t\tn += cn\n\t\tp = p[cn:]\n\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\treturn n, err\n\t\t}\n\t}\n\n\tvar remainder []byte\n\n\tfor len(p) > 0 {\n\t\terr := r.currentPacket.Next(r.br)\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\n\t\tcn := copy(p, r.currentPacket.Payload)\n\t\tn += cn\n\t\tp = p[cn:]\n\t\tremainder = r.currentPacket.Payload[cn:]\n\t}\n\n\t_, err = r.remainder.Write(remainder)\n\n\treturn\n}"}
{"input": "package logger\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\ntype SysLogger struct {\n\twriter *log.Logger\n\tdebug  bool\n\ttrace  bool\n}\n\nfunc NewSysLogger(debug, trace bool) *SysLogger {\n\tw := log.New(os.Stdout, \"gnatsd\", log.LstdFlags)\n\n\treturn &SysLogger{\n\t\twriter: w,\n\t\tdebug:  debug,\n\t\ttrace:  trace,\n\t}\n}\n\nfunc NewRemoteSysLogger(fqn string, debug, trace bool) *SysLogger {\n\treturn NewSysLogger(debug, trace)\n}\n\nfunc (l *SysLogger) Noticef(format string, v ...interface{}) {\n\tl.writer.Println(\"NOTICE\", fmt.Sprintf(format, v...))\n}\n\nfunc (l *SysLogger) Fatalf(format string, v ...interface{}) {\n\tl.writer.Println(\"CRITICAL\", fmt.Sprintf(format, v...))\n}\n\nfunc (l *SysLogger) Errorf(format string, v ...interface{}) {\n\tl.writer.Println(\"ERROR\", fmt.Sprintf(format, v...))\n}\n\nfunc (l *SysLogger) Debugf(format string, v ...interface{}) {\n\tif l.debug {\n\t\tl.writer.Println(\"DEBUG\", fmt.Sprintf(format, v...))\n\t}\n}\n\n\n\nfunc (l *SysLogger) Tracef(format string, v ...interface{}) ", "output": "{\n\tif l.trace {\n\t\tl.writer.Println(\"NOTICE\", fmt.Sprintf(format, v...))\n\t}\n}"}
{"input": "package v1\n\n\n\ntype EnvVarSourceApplyConfiguration struct {\n\tFieldRef         *ObjectFieldSelectorApplyConfiguration   `json:\"fieldRef,omitempty\"`\n\tResourceFieldRef *ResourceFieldSelectorApplyConfiguration `json:\"resourceFieldRef,omitempty\"`\n\tConfigMapKeyRef  *ConfigMapKeySelectorApplyConfiguration  `json:\"configMapKeyRef,omitempty\"`\n\tSecretKeyRef     *SecretKeySelectorApplyConfiguration     `json:\"secretKeyRef,omitempty\"`\n}\n\n\n\nfunc EnvVarSource() *EnvVarSourceApplyConfiguration {\n\treturn &EnvVarSourceApplyConfiguration{}\n}\n\n\n\n\nfunc (b *EnvVarSourceApplyConfiguration) WithFieldRef(value *ObjectFieldSelectorApplyConfiguration) *EnvVarSourceApplyConfiguration {\n\tb.FieldRef = value\n\treturn b\n}\n\n\n\n\nfunc (b *EnvVarSourceApplyConfiguration) WithResourceFieldRef(value *ResourceFieldSelectorApplyConfiguration) *EnvVarSourceApplyConfiguration {\n\tb.ResourceFieldRef = value\n\treturn b\n}\n\n\n\n\nfunc (b *EnvVarSourceApplyConfiguration) WithConfigMapKeyRef(value *ConfigMapKeySelectorApplyConfiguration) *EnvVarSourceApplyConfiguration {\n\tb.ConfigMapKeyRef = value\n\treturn b\n}\n\n\n\n\n\n\nfunc (b *EnvVarSourceApplyConfiguration) WithSecretKeyRef(value *SecretKeySelectorApplyConfiguration) *EnvVarSourceApplyConfiguration ", "output": "{\n\tb.SecretKeyRef = value\n\treturn b\n}"}
{"input": "package tests\n\nimport (\n    log \"github.com/janekolszak/revfluent\"\n    \"github.com/revel/revel/testing\"\n)\n\ntype AppTest struct {\n    testing.TestSuite\n}\n\n\n\nfunc (t *AppTest) TestDebug() {\n    data := map[string]string{\"message\": \"Debug\"}\n    log.Debug(data)\n}\n\nfunc (t *AppTest) TestInfo() {\n    data := map[string]string{\"message\": \"Info\"}\n    log.Info(data)\n}\n\nfunc (t *AppTest) TestLog() {\n    data := map[string]string{\"message\": \"Log\"}\n    log.Log(\"tag\", data)\n}\n\nfunc (t *AppTest) TestLogger() {\n    data := map[string]string{\"message\": \"Logger\"}\n    log.Logger.Post(\"tag\", data)\n}\n\nfunc (t *AppTest) TestError() ", "output": "{\n    data := map[string]string{\"message\": \"Error\"}\n    log.Error(data)\n}"}
{"input": "package schema\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestArrayValidator(t *testing.T) {\n\tv, err := Array{ValuesValidator: &Bool{}}.Validate([]interface{}{true, false})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []interface{}{true, false}, v)\n\tv, err = Array{ValuesValidator: &Bool{}}.Validate([]interface{}{true, \"value\"})\n\tassert.EqualError(t, err, \"invalid value at #2: not a Boolean\")\n\tassert.Equal(t, nil, v)\n\tv, err = Array{ValuesValidator: &String{}}.Validate(\"value\")\n\tassert.EqualError(t, err, \"not an array\")\n\tassert.Equal(t, nil, v)\n}\n\nfunc TestArrayValidatorCompile(t *testing.T) ", "output": "{\n\tv := &Array{ValuesValidator: &String{}}\n\terr := v.Compile()\n\tassert.NoError(t, err)\n\tv = &Array{ValuesValidator: &String{Regexp: \"[invalid re\"}}\n\terr = v.Compile()\n\tassert.EqualError(t, err, \"invalid regexp: error parsing regexp: missing closing ]: `[invalid re`\")\n\n}"}
{"input": "package printer\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/resoursea/api\"\n)\n\nfunc Router(rt api.Router) {\n\tfmt.Println(\"\\n--- PRINT ROUTER ---\\n\")\n\trouter(rt, 0)\n\tfmt.Println(\"\\n--- END PRINT ---\\n\")\n}\n\n\n\nfunc handler(m api.Method, lvl int) {\n\tfmt.Printf(\"%s- Method: %s\\n\", strings.Repeat(\"\t\", lvl), m)\n}\n\nfunc router(r api.Router, lvl int) ", "output": "{\n\tfmt.Printf(\"%sRoute: %s\\n\", strings.Repeat(\"\t\", lvl), r)\n\n\tfor _, m := range r.Methods() {\n\t\thandler(m, lvl)\n\t}\n\n\tfor _, c := range r.Children() {\n\t\tif r.IsSlice() {\n\t\t\trouter(c, lvl)\n\t\t} else {\n\t\t\trouter(c, lvl+1)\n\t\t}\n\t}\n}"}
{"input": "package spew\n\nimport (\n    \"fmt\"\n    \"io\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Fprint(w io.Writer, a ...interface{}) (n int, err error) {\n    return fmt.Fprint(w, convertArgs(a)...)\n}\n\n\n\n\n\n\n\n\n\nfunc Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {\n    return fmt.Fprintf(w, format, convertArgs(a)...)\n}\n\n\n\n\n\n\n\n\nfunc Fprintln(w io.Writer, a ...interface{}) (n int, err error) {\n    return fmt.Fprintln(w, convertArgs(a)...)\n}\n\n\n\n\n\n\n\n\n\nfunc Print(a ...interface{}) (n int, err error) {\n    return fmt.Print(convertArgs(a)...)\n}\n\n\n\n\n\n\n\n\n\nfunc Printf(format string, a ...interface{}) (n int, err error) {\n    return fmt.Printf(format, convertArgs(a)...)\n}\n\n\n\n\n\n\n\n\n\nfunc Println(a ...interface{}) (n int, err error) {\n    return fmt.Println(convertArgs(a)...)\n}\n\n\n\n\n\n\n\n\nfunc Sprint(a ...interface{}) string {\n    return fmt.Sprint(convertArgs(a)...)\n}\n\n\n\n\n\n\n\n\nfunc Sprintf(format string, a ...interface{}) string {\n    return fmt.Sprintf(format, convertArgs(a)...)\n}\n\n\n\n\n\n\n\n\nfunc Sprintln(a ...interface{}) string {\n    return fmt.Sprintln(convertArgs(a)...)\n}\n\n\n\nfunc convertArgs(args []interface{}) (formatters []interface{}) {\n    formatters = make([]interface{}, len(args))\n    for index, arg := range args {\n        formatters[index] = NewFormatter(arg)\n    }\n    return formatters\n}\n\nfunc Errorf(format string, a ...interface{}) (err error) ", "output": "{\n    return fmt.Errorf(format, convertArgs(a)...)\n}"}
{"input": "package frame\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/go-git/go-git/v5/utils/merkletrie/noder\"\n)\n\n\n\ntype Frame struct {\n\tstack []noder.Noder\n}\n\ntype byName []noder.Noder\n\nfunc (a byName) Len() int      { return len(a) }\nfunc (a byName) Swap(i, j int) { a[i], a[j] = a[j], a[i] }\nfunc (a byName) Less(i, j int) bool {\n\treturn strings.Compare(a[i].Name(), a[j].Name()) < 0\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc (f *Frame) String() string {\n\tvar buf bytes.Buffer\n\t_ = buf.WriteByte('[')\n\n\tsep := \"\"\n\tfor i := f.Len() - 1; i >= 0; i-- {\n\t\t_, _ = buf.WriteString(sep)\n\t\tsep = \", \"\n\t\t_, _ = buf.WriteString(fmt.Sprintf(\"%q\", f.stack[i].Name()))\n\t}\n\n\t_ = buf.WriteByte(']')\n\n\treturn buf.String()\n}\n\n\n\n\nfunc (f *Frame) First() (noder.Noder, bool) {\n\tif f.Len() == 0 {\n\t\treturn nil, false\n\t}\n\n\ttop := f.Len() - 1\n\n\treturn f.stack[top], true\n}\n\n\n\nfunc (f *Frame) Drop() {\n\tif f.Len() == 0 {\n\t\treturn\n\t}\n\n\ttop := f.Len() - 1\n\tf.stack[top] = nil\n\tf.stack = f.stack[:top]\n}\n\n\nfunc (f *Frame) Len() int {\n\treturn len(f.stack)\n}\n\nfunc New(n noder.Noder) (*Frame, error) ", "output": "{\n\tchildren, err := n.Children()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsort.Sort(sort.Reverse(byName(children)))\n\treturn &Frame{\n\t\tstack: children,\n\t}, nil\n}"}
{"input": "package file\n\nimport (\n\t\"github.com/watermint/toolbox/essentials/collections/es_number\"\n\t\"math\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Status struct {\n\tsummary Summary\n}\n\nfunc (z *Status) start() {\n\tz.summary.Start = time.Now()\n}\n\nfunc (z *Status) finish() {\n\tz.summary.End = time.Now()\n}\n\nfunc (z *Status) error() {\n\tatomic.AddInt64(&z.summary.NumFilesError, 1)\n}\n\nfunc (z *Status) skip() {\n\tatomic.AddInt64(&z.summary.NumFilesSkip, 1)\n}\n\nfunc (z *Status) upload(size int64, chunkSize int) {\n\tatomic.AddInt64(&z.summary.NumBytes, size)\n\tatomic.AddInt64(&z.summary.NumFilesTransferred, 1)\n\n\tapiCalls := es_number.Max(math.Ceil(float64(size)/float64(chunkSize)), 0).Int64()\n\tif size == 0 || apiCalls < 1 {\n\t\tapiCalls = 1\n\t}\n\tatomic.AddInt64(&z.summary.NumApiCall, apiCalls)\n}\n\nfunc (z *Status) copy(size int64) {\n\tatomic.AddInt64(&z.summary.NumBytes, size)\n\tatomic.AddInt64(&z.summary.NumFilesTransferred, 1)\n}\n\nfunc (z *Status) download(size int64) {\n\tatomic.AddInt64(&z.summary.NumBytes, size)\n\tatomic.AddInt64(&z.summary.NumFilesTransferred, 1)\n}\n\n\n\nfunc (z *Status) delete() {\n\tatomic.AddInt64(&z.summary.NumDeleted, 1)\n}\n\nfunc (z *Status) createFolder() ", "output": "{\n\tatomic.AddInt64(&z.summary.NumFolderCreated, 1)\n}"}
{"input": "package v1alpha1\n\nimport (\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\tcorev1 \"k8s.io/api/core/v1\"\n)\n\nfunc TestBuildTemplateSpec(t *testing.T) {\n\tc := BuildTemplate{\n\t\tSpec: BuildTemplateSpec{\n\t\t\tSteps: []corev1.Container{{\n\t\t\t\tName: \"build-spec\",\n\t\t\t}},\n\t\t},\n\t}\n\n\texpectedBuildSpec := BuildTemplateSpec{Steps: []corev1.Container{{Name: \"build-spec\"}}}\n\n\tif a := cmp.Diff(c.TemplateSpec(), expectedBuildSpec); a != \"\" {\n\t\tt.Errorf(\"templateSpec mismatch; expected: %v got: %v\", expectedBuildSpec, a)\n\t}\n}\n\n\n\nfunc TestBuildTemplateGroupVersionKind(t *testing.T) ", "output": "{\n\tc := BuildTemplate{}\n\n\texpectedKind := \"BuildTemplate\"\n\tif c.GetGroupVersionKind().Kind != expectedKind {\n\t\tt.Errorf(\"GetGroupVersionKind mismatch; expected: %v got: %v\", expectedKind, c.GetGroupVersionKind().Kind)\n\t}\n}"}
{"input": "package x11\n\nimport (\n\t\"C\"\n\t\"unsafe\"\n)\n\ntype SelectionEvent C.XSelectionEvent\n\nfunc (evt *SelectionEvent) Requestor() Window {\n\treturn Window(evt.requestor)\n}\n\nfunc (evt *SelectionEvent) Selection() Atom {\n\treturn Atom(evt.selection)\n}\n\n\n\nfunc (evt *SelectionEvent) Property() Atom {\n\treturn Atom(evt.property)\n}\n\nfunc (evt *SelectionEvent) When() C.Time {\n\treturn evt.time\n}\n\nfunc (evt *SelectionEvent) ToEvent() *Event {\n\treturn (*Event)(unsafe.Pointer(evt))\n}\n\nfunc (evt *SelectionEvent) Target() Atom ", "output": "{\n\treturn Atom(evt.target)\n}"}
{"input": "package mock\n\nimport \"bytes\"\n\n\ntype Job struct {\n\tPayload, Name, GearmanHandle, ID string\n\tGearmanErr                       error\n\tGearmanWarnings                  [][]byte\n\tDataBuffer                       bytes.Buffer\n\tNumerator, Denominator           int\n}\n\n\n\n\n\nfunc (m Job) Data() []byte {\n\treturn []byte(m.Payload)\n}\n\n\nfunc (m Job) OutData() []byte {\n\treturn m.DataBuffer.Bytes()\n}\n\n\nfunc (m Job) Fn() string {\n\treturn m.Name\n}\n\n\nfunc (m Job) Err() error {\n\treturn m.GearmanErr\n}\n\n\nfunc (m Job) Handle() string {\n\treturn m.GearmanHandle\n}\n\n\nfunc (m Job) UniqueId() string {\n\treturn m.ID\n}\n\n\nfunc (m *Job) Warnings() [][]byte {\n\treturn m.GearmanWarnings\n}\n\n\nfunc (m *Job) SendWarning(warning []byte) {\n\tm.GearmanWarnings = append(m.GearmanWarnings, warning)\n}\n\n\nfunc (m *Job) SendData(data []byte) {\n\tm.DataBuffer.Write(data)\n}\n\n\nfunc (m *Job) UpdateStatus(numerator, denominator int) {\n\tm.Numerator = numerator\n\tm.Denominator = denominator\n}\n\nfunc CreateMockJob(payload string) *Job ", "output": "{\n\treturn &Job{Payload: payload}\n}"}
{"input": "package net\n\n\nimport \"C\"\n\n\n\nfunc cgoAddrInfoFlags() C.int ", "output": "{\n\treturn (C.AI_CANONNAME | C.AI_V4MAPPED | C.AI_ALL) & C.AI_MASK\n}"}
{"input": "package xen\n\nimport (\n\t\"github.com/solo-io/unik/pkg/types\"\n)\n\n\n\nfunc (p *XenProvider) ListImages() ([]*types.Image, error) ", "output": "{\n\timages := []*types.Image{}\n\tfor _, image := range p.state.GetImages() {\n\t\timages = append(images, image)\n\t}\n\treturn images, nil\n}"}
{"input": "package comparators\n\n\ntype UInt8Comparator struct {\n}\n\n\n\n\n\n\n\n\nfunc (comparator *UInt8Comparator) Compare(a, b interface{}) int {\n\taAsserted := a.(uint8)\n\tbAsserted := b.(uint8)\n\tswitch {\n\tcase aAsserted > bAsserted:\n\t\treturn 1\n\tcase aAsserted < bAsserted:\n\t\treturn -1\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc NewUInt8Comparator() *UInt8Comparator ", "output": "{\n\treturn &UInt8Comparator{}\n}"}
{"input": "package consensus\n\nimport (\n\t\"github.com/golang/glog\"\n\t\"math/rand\"\n)\n\n\n\nfunc next(view int, id int, n int) int {\n\tround := view / n\n\treturn (round+1)*n + id\n}\n\nfunc randPeer(n int, id int) int {\n\tif n == 1 {\n\t\tglog.Fatal(\"No peers present\")\n\t}\n\tc := rand.Intn(n)\n\tfor c == id {\n\t\tc = rand.Intn(n)\n\t}\n\treturn c\n}\n\nfunc mod(x int, y int) int ", "output": "{\n\tif x < y {\n\t\treturn x\n\t}\n\tdif := x - y\n\tif dif < y {\n\t\treturn dif\n\t}\n\treturn mod(dif, y)\n}"}
{"input": "package insteon\n\nimport \"context\"\n\ntype inbox struct {\n\tC chan *packet\n\n\tctx    context.Context\n\tcancel func()\n}\n\nfunc newInbox(ctx context.Context) *inbox {\n\tctx, cancel := context.WithCancel(ctx)\n\n\treturn &inbox{\n\t\tC:      make(chan *packet),\n\t\tctx:    ctx,\n\t\tcancel: cancel,\n\t}\n}\n\nfunc (i *inbox) Done() <-chan struct{} {\n\treturn i.ctx.Done()\n}\n\n\n\nfunc (i *inbox) close() ", "output": "{\n\ti.cancel()\n}"}
{"input": "package elements\n\nimport (\n\t\"strings\"\n\n\t\"github.com/spf13/afero\"\n)\n\ntype ComponentsList interface {\n\tGetFilenameByType(*Component) string\n\tParse() error\n\tExists(string) bool\n}\n\ntype CList struct {\n\tdir        string            \n\tcomponents map[string]string \n\tfs         afero.Fs          \n}\n\n\n\nfunc (cl *CList) Parse() error {\n\treturn cl.readDir()\n}\n\nfunc (cl *CList) Exists(s string) bool {\n\tif _, ok := cl.components[s]; ok {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (cl *CList) GetFilenameByType(c *Component) string {\n\tv, ok := cl.components[c.Typ]\n\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn v\n}\n\nfunc (cl *CList) readDir() error {\n\tif cl.dir != \"\" {\n\t\tfiles, err := afero.ReadDir(cl.fs, cl.dir)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, v := range files {\n\t\t\tif v.IsDir() {\n\t\t\t\tf, _ := afero.ReadDir(cl.fs, cl.dir+\"/\"+v.Name())\n\n\t\t\t\tfor _, file := range f {\n\t\t\t\t\tname := strings.Replace(file.Name(), \".svg\", \"\", 1)\n\t\t\t\t\tcl.components[v.Name()+\"_\"+name] = cl.dir + \"/\" + v.Name() + \"/\" + file.Name()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif strings.HasSuffix(v.Name(), \".svg\") {\n\t\t\t\tname := strings.Replace(v.Name(), \".svg\", \"\", 1)\n\t\t\t\tcl.components[name] = cl.dir + \"/\" + v.Name()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc NewComponentsList(s string) *CList ", "output": "{\n\tc := make(map[string]string)\n\tc[\"node\"] = \"\"\n\tc[\"actor\"] = \"\"\n\tc[\"cloud\"] = \"\"\n\tf := afero.NewOsFs()\n\tcl := &CList{dir: s, components: c, fs: f}\n\n\treturn cl\n}"}
{"input": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestServe(t *testing.T) {\n\tserver := httptest.NewServer(SetupHandler())\n\tdefer server.Close()\n\n\ttestPostMessage(t, server.URL+\"/drawer1/messages/new\", \"john\", \"testmsg1\")\n\ttestPostMessage(t, server.URL+\"/drawer2/messages/new\", \"smith\", \"testmsg2\")\n\ttestPostMessage(t, server.URL+\"/messages/new\", \"admin\", \"broadcast\")\n\n\tjsonMessages := testGetMessages(t, server.URL+\"/drawer1/messages\")\n\tif !strings.Contains(jsonMessages, \"testmsg1\") {\n\t\tt.Errorf(\"Drower1 must has %s, but does not.\", \"testmsg1\")\n\t}\n\tif !strings.Contains(jsonMessages, \"broadcast\") {\n\t\tt.Errorf(\"Drower1 must has %s, but does not.\", \"broadcast\")\n\t}\n}\n\nfunc testPostMessage(t *testing.T, requestURL, from, body string) {\n\tpostValues := url.Values{\n\t\t\"from\": {from},\n\t\t\"body\": {body},\n\t}\n\tres, err := http.PostForm(requestURL, postValues)\n\tif err != nil {\n\t\tt.Fatalf(\"Error occured: %s\", err)\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode != http.StatusOK {\n\t\tt.Logf(\"URL[%s]\", requestURL)\n\t\tt.Logf(\"Parameter:from[%s], body[%s]\", from, body)\n\t\tt.Errorf(\"res.StatusCode => %d, want %d\", res.StatusCode, http.StatusOK)\n\t}\n}\n\n\n\nfunc testGetMessages(t *testing.T, requestURL string) string ", "output": "{\n\tres, err := http.Get(requestURL)\n\tif err != nil {\n\t\tt.Fatalf(\"Error occured: %s\", err)\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode != http.StatusOK {\n\t\tt.Logf(\"URL[%s]\", requestURL)\n\t\tt.Errorf(\"res.StatusCode => %d, want %d\", res.StatusCode, http.StatusOK)\n\t}\n\n\tresMsg, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tt.Fatalf(\"Responce read error occured: %s\", err)\n\t}\n\n\treturn string(resMsg)\n}"}
{"input": "package framework\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"strings\"\n\t\"time\"\n\n\tuuid \"github.com/hashicorp/go-uuid\"\n\t\"github.com/hashicorp/vault/sdk/helper/jsonutil\"\n\t\"github.com/hashicorp/vault/sdk/logical\"\n)\n\n\nconst WALPrefix = \"wal/\"\n\ntype WALEntry struct {\n\tID        string      `json:\"-\"`\n\tKind      string      `json:\"type\"`\n\tData      interface{} `json:\"data\"`\n\tCreatedAt int64       `json:\"created_at\"`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc GetWAL(ctx context.Context, s logical.Storage, id string) (*WALEntry, error) {\n\tentry, err := s.Get(ctx, WALPrefix+id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif entry == nil {\n\t\treturn nil, nil\n\t}\n\n\tvar raw WALEntry\n\tif err := jsonutil.DecodeJSON(entry.Value, &raw); err != nil {\n\t\treturn nil, err\n\t}\n\traw.ID = id\n\n\treturn &raw, nil\n}\n\n\n\n\nfunc DeleteWAL(ctx context.Context, s logical.Storage, id string) error {\n\treturn s.Delete(ctx, WALPrefix+id)\n}\n\n\nfunc ListWAL(ctx context.Context, s logical.Storage) ([]string, error) {\n\tkeys, err := s.List(ctx, WALPrefix)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i, k := range keys {\n\t\tkeys[i] = strings.TrimPrefix(k, WALPrefix)\n\t}\n\n\treturn keys, nil\n}\n\nfunc PutWAL(ctx context.Context, s logical.Storage, kind string, data interface{}) (string, error) ", "output": "{\n\tvalue, err := json.Marshal(&WALEntry{\n\t\tKind:      kind,\n\t\tData:      data,\n\t\tCreatedAt: time.Now().UTC().Unix(),\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tid, err := uuid.GenerateUUID()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn id, s.Put(ctx, &logical.StorageEntry{\n\t\tKey:   WALPrefix + id,\n\t\tValue: value,\n\t})\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\n\n\n\ntype AddCommentToTaskParamsBody struct {\n\n\tContent *string `json:\"content\"`\n\n\tUserID *int64 `json:\"userId\"`\n}\n\n\nfunc (m *AddCommentToTaskParamsBody) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateContent(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateUserID(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *AddCommentToTaskParamsBody) validateContent(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"content\", \"body\", m.Content); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *AddCommentToTaskParamsBody) validateUserID(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"userId\", \"body\", m.UserID); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\n\n\nfunc (m *AddCommentToTaskParamsBody) UnmarshalBinary(b []byte) error {\n\tvar res AddCommentToTaskParamsBody\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *AddCommentToTaskParamsBody) MarshalBinary() ([]byte, error) ", "output": "{\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}"}
{"input": "package time2\n\nimport (\n\t\"time\"\n)\n\ntype Timer struct {\n\tC <-chan time.Time\n\tr *timer\n}\n\nfunc After(d time.Duration) <-chan time.Time {\n\treturn defaultWheel.After(d)\n}\n\nfunc Sleep(d time.Duration) {\n\tdefaultWheel.Sleep(d)\n}\n\nfunc AfterFunc(d time.Duration, f func()) *Timer {\n\treturn defaultWheel.AfterFunc(d, f)\n}\n\n\n\nfunc (t *Timer) Reset(d time.Duration) {\n\tt.r.w.resetTimer(t.r, d, 0)\n}\n\nfunc (t *Timer) Stop() {\n\tt.r.w.delTimer(t.r)\n}\n\nfunc NewTimer(d time.Duration) *Timer ", "output": "{\n\treturn defaultWheel.NewTimer(d)\n}"}
{"input": "package outputs\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/lfkeitel/spartan/event\"\n\n\ttomb \"gopkg.in/tomb.v2\"\n)\n\n\n\n\ntype OutputController struct {\n\tstart     Output\n\tbatchSize int\n\tt         tomb.Tomb\n\tin        <-chan *event.Event\n\tout       chan<- *event.Event\n}\n\n\n\n\n\n\n\n\nfunc (o *OutputController) Start(in chan *event.Event) error {\n\to.in = in\n\to.t.Go(o.run)\n\treturn nil\n}\n\n\n\n\nfunc (o *OutputController) Close() error {\n\to.t.Kill(nil)\n\treturn o.t.Wait()\n}\n\nfunc (o *OutputController) run() error {\n\tfmt.Println(\"Output Pipeline started\")\n\tfor {\n\t\tselect {\n\t\tcase <-o.t.Dying():\n\t\t\treturn nil\n\t\tdefault:\n\t\t}\n\n\t\tcurrentBatch := 0\n\t\tbatch := make([]*event.Event, o.batchSize)\n\t\tstopping := false\n\n\tCURRENT:\n\t\tfor currentBatch < o.batchSize {\n\t\t\tselect {\n\t\t\tcase event := <-o.in:\n\t\t\t\tbatch[currentBatch] = event\n\t\t\t\tcurrentBatch++\n\t\t\tcase <-o.t.Dying():\n\t\t\t\tstopping = true\n\t\t\t\tbreak CURRENT\n\t\t\t}\n\t\t}\n\n\t\tfmt.Println(\"Processing batch\")\n\t\to.start.Run(batch)\n\n\t\tif stopping {\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n\nfunc checkOptionsMap(o map[string]interface{}) map[string]interface{} {\n\tif o == nil {\n\t\to = make(map[string]interface{})\n\t}\n\treturn o\n}\n\nfunc NewOutputController(start Output, batchSize int) *OutputController ", "output": "{\n\treturn &OutputController{\n\t\tstart:     start,\n\t\tbatchSize: batchSize,\n\t}\n}"}
{"input": "package action\n\nimport (\n\tbosherr \"github.com/cloudfoundry/bosh-utils/errors\"\n\n\t. \"bosh-softlayer-cpi/softlayer/common\"\n\t\"fmt\"\n)\n\ntype DeleteVMAction struct {\n\tvmDeleterProvider DeleterProvider\n\toptions           ConcreteFactoryOptions\n}\n\nfunc NewDeleteVM(\n\tvmDeleterProvider DeleterProvider,\n\toptions ConcreteFactoryOptions,\n) (action DeleteVMAction) {\n\taction.vmDeleterProvider = vmDeleterProvider\n\taction.options = options\n\treturn\n}\n\n\n\nfunc (a DeleteVMAction) Run(vmCID VMCID) (interface{}, error) ", "output": "{\n\tvar vmDeleter VMDeleter\n\tif a.options.Softlayer.FeatureOptions.EnablePool {\n\t\tvmDeleter = a.vmDeleterProvider.Get(\"pool\")\n\n\t\terr := vmDeleter.Delete(int(vmCID))\n\t\tif err != nil {\n\t\t\treturn nil, bosherr.WrapError(err, fmt.Sprintf(\"Update vm %d to free in pool\", int(vmCID)))\n\t\t}\n\t} else {\n\t\tvmDeleter = a.vmDeleterProvider.Get(\"virtualguest\")\n\n\t\terr := vmDeleter.Delete(int(vmCID))\n\t\tif err != nil {\n\t\t\treturn nil, bosherr.WrapError(err, fmt.Sprintf(\"Deleting vm %d\", int(vmCID)))\n\t\t}\n\t}\n\n\treturn nil, nil\n}"}
{"input": "package driver\n\nimport \"database/sql/driver\"\n\nvar _ driver.Tx = tx{}\n\ntype tx struct {\n\tconn *conn\n}\n\nfunc (t tx) Commit() error {\n\t_, err := t.conn.Exec(\"COMMIT TRANSACTION\", nil)\n\treturn err\n}\n\n\n\nfunc (t tx) Rollback() error ", "output": "{\n\t_, err := t.conn.Exec(\"ROLLBACK TRANSACTION\", nil)\n\treturn err\n}"}
{"input": "package volume\n\nimport (\n\t\"runtime\"\n\n\t\"github.com/docker/docker/api/types/mount\"\n)\n\nconst (\n\tOSLinux = \"linux\"\n\tOSWindows = \"windows\"\n)\n\n\ntype Parser interface {\n\tParseMountRaw(raw, volumeDriver string) (*MountPoint, error)\n\tParseMountSpec(cfg mount.Mount) (*MountPoint, error)\n\tParseVolumesFrom(spec string) (string, string, error)\n\tDefaultPropagationMode() mount.Propagation\n\tConvertTmpfsOptions(opt *mount.TmpfsOptions, readOnly bool) (string, error)\n\tDefaultCopyMode() bool\n\tValidateVolumeName(name string) error\n\tReadWrite(mode string) bool\n\tIsBackwardCompatible(m *MountPoint) bool\n\tHasResource(m *MountPoint, absPath string) bool\n\tValidateTmpfsMountDestination(dest string) error\n\tValidateMountConfig(mt *mount.Mount) error\n}\n\n\n\n\nfunc NewParser(containerOS string) Parser ", "output": "{\n\tswitch containerOS {\n\tcase OSWindows:\n\t\treturn &windowsParser{}\n\t}\n\tif runtime.GOOS == OSWindows {\n\t\treturn &lcowParser{}\n\t}\n\treturn &linuxParser{}\n}"}
{"input": "package gxfilepath\n\nimport \"testing\"\n\n\n\n\n\nfunc TestMkdirf(t *testing.T) {\n\tdir := \"./d/b/c\"\n\tif err := Mkdirf(dir); err != nil {\n\t\tt.Logf(\"create dir %s err:%s\\n\", dir, err)\n\t}\n\tdir = \"./d/\"\n\tif err := Rmdirf(dir); err != nil {\n\t\tt.Logf(\"remove dir %s err:%s\\n\", dir, err)\n\t}\n}\n\nfunc TestDirFiles(t *testing.T) ", "output": "{\n\tfiles, err := DirFiles(\"../\", \"hello\")\n\tif err != nil {\n\t\tt.Errorf(\"err:%v\", err)\n\t}\n\tt.Logf(\"files:%v, err:%v\", files, err)\n}"}
{"input": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/alecthomas/repr\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n\n\nfunc BenchmarkParser(b *testing.B) {\n\tsrc := strings.Repeat(sample, 10)\n\tb.ReportAllocs()\n\tb.ReportMetric(float64(len(src)*b.N), \"B/s\")\n\tfor i := 0; i < b.N; i++ {\n\t\tprogram := &Program{}\n\t\t_ = parser.ParseString(\"\", src, program)\n\t}\n}\n\nfunc TestExe(t *testing.T) ", "output": "{\n\tprogram := &Program{}\n\terr := parser.ParseString(\"\", sample, program)\n\trequire.NoError(t, err)\n\trepr.Println(program)\n}"}
{"input": "package packet\n\nimport (\n\t\"crypto\"\n\t\"encoding/binary\"\n\t\"github.com/qjpcpu/sesh/golang.org/x/crypto/openpgp/errors\"\n\t\"github.com/qjpcpu/sesh/golang.org/x/crypto/openpgp/s2k\"\n\t\"io\"\n\t\"strconv\"\n)\n\n\n\ntype OnePassSignature struct {\n\tSigType    SignatureType\n\tHash       crypto.Hash\n\tPubKeyAlgo PublicKeyAlgorithm\n\tKeyId      uint64\n\tIsLast     bool\n}\n\nconst onePassSignatureVersion = 3\n\nfunc (ops *OnePassSignature) parse(r io.Reader) (err error) {\n\tvar buf [13]byte\n\n\t_, err = readFull(r, buf[:])\n\tif err != nil {\n\t\treturn\n\t}\n\tif buf[0] != onePassSignatureVersion {\n\t\terr = errors.UnsupportedError(\"one-pass-signature packet version \" + strconv.Itoa(int(buf[0])))\n\t}\n\n\tvar ok bool\n\tops.Hash, ok = s2k.HashIdToHash(buf[2])\n\tif !ok {\n\t\treturn errors.UnsupportedError(\"hash function: \" + strconv.Itoa(int(buf[2])))\n\t}\n\n\tops.SigType = SignatureType(buf[1])\n\tops.PubKeyAlgo = PublicKeyAlgorithm(buf[3])\n\tops.KeyId = binary.BigEndian.Uint64(buf[4:12])\n\tops.IsLast = buf[12] != 0\n\treturn\n}\n\n\n\n\nfunc (ops *OnePassSignature) Serialize(w io.Writer) error ", "output": "{\n\tvar buf [13]byte\n\tbuf[0] = onePassSignatureVersion\n\tbuf[1] = uint8(ops.SigType)\n\tvar ok bool\n\tbuf[2], ok = s2k.HashToHashId(ops.Hash)\n\tif !ok {\n\t\treturn errors.UnsupportedError(\"hash type: \" + strconv.Itoa(int(ops.Hash)))\n\t}\n\tbuf[3] = uint8(ops.PubKeyAlgo)\n\tbinary.BigEndian.PutUint64(buf[4:12], ops.KeyId)\n\tif ops.IsLast {\n\t\tbuf[12] = 1\n\t}\n\n\tif err := serializeHeader(w, packetTypeOnePassSignature, len(buf)); err != nil {\n\t\treturn err\n\t}\n\t_, err := w.Write(buf[:])\n\treturn err\n}"}
{"input": "package main\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"github.com/julienschmidt/httprouter\"\n\n\t\"github.com/iangudger/protobuf_rpc_example/proto/message\"\n)\n\nfunc apiHandler(res http.ResponseWriter, req *http.Request, ps httprouter.Params) {\n\tlog.Println(\"Got api request from:\", req.RemoteAddr)\n\tbuf := new(bytes.Buffer)\n\tbuf.ReadFrom(req.Body)\n\n\treqMsg := message.Message{}\n\tif err := proto.Unmarshal(buf.Bytes(), &reqMsg); err != nil {\n\t\tlog.Println(\"Error unmarshaling:\", err)\n\t\twriteRes(res, err.Error())\n\t\treturn\n\t}\n\n\tif reqMsg.GetText() == \"hello\" {\n\t\tlog.Println(\"got hello\")\n\t\twriteRes(res, \"hello back\")\n\t} else {\n\t\tlog.Println(\"not hello\")\n\t\twriteRes(res, \"not hello\")\n\t}\n}\n\nfunc staticHandler(res http.ResponseWriter, req *http.Request, ps httprouter.Params) {\n\tlog.Println(\"Got static file request from:\", req.RemoteAddr)\n\tres.Header().Set(\"cache-control\", \"public, no-transform\")\n\tpath := \"./static\" + ps.ByName(\"filepath\")\n\tlog.Println(\"Serving file:\", path)\n\thttp.ServeFile(res, req, path)\n}\n\n\n\nfunc main() {\n\trouter := httprouter.New()\n\n\trouter.POST(\"/api\", apiHandler)\n\n\trouter.GET(\n\t\t\"/*filepath\",\n\t\tstaticHandler,\n\t)\n\n\tlog.Println(\"Serving at localhost:5000...\")\n\tlog.Fatal(http.ListenAndServe(\":5000\", router))\n}\n\nfunc writeRes(res http.ResponseWriter, msgtxt string) ", "output": "{\n\tmsg := message.Message{Text: proto.String(msgtxt)}\n\tbin, err := proto.Marshal(&msg)\n\tif err != nil {\n\t\tlog.Println(\"Error marshaling:\", err)\n\t\treturn\n\t}\n\tres.Write(bin)\n}"}
{"input": "package cmd\n\n\ntype readDirOpts struct {\n\tcount int\n\tfollowDirSymlink bool\n}\n\n\n\n\n\nfunc readDirN(dirPath string, count int) (entries []string, err error) {\n\treturn readDirWithOpts(dirPath, readDirOpts{count: count})\n}\n\nfunc readDir(dirPath string) (entries []string, err error) ", "output": "{\n\treturn readDirWithOpts(dirPath, readDirOpts{count: -1})\n}"}
{"input": "package webservices\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\n\n\n\nfunc Version() string {\n\treturn version.Number\n}\n\nfunc UserAgent() string ", "output": "{\n\treturn \"Azure-SDK-For-Go/\" + Version() + \" webservices/2016-05-01-preview\"\n}"}
{"input": "package godo\n\nimport \"fmt\"\n\n\n\n\ntype ImageActionsService interface {\n\tGet(int, int) (*Action, *Response, error)\n\tTransfer(int, *ActionRequest) (*Action, *Response, error)\n}\n\n\n\ntype ImageActionsServiceOp struct {\n\tclient *Client\n}\n\n\n\n\n\nfunc (i *ImageActionsServiceOp) Get(imageID, actionID int) (*Action, *Response, error) {\n\tpath := fmt.Sprintf(\"v2/images/%d/actions/%d\", imageID, actionID)\n\n\treq, err := i.client.NewRequest(\"GET\", path, nil)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\troot := new(actionRoot)\n\tresp, err := i.client.Do(req, root)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn &root.Event, resp, err\n}\n\nfunc (i *ImageActionsServiceOp) Transfer(imageID int, transferRequest *ActionRequest) (*Action, *Response, error) ", "output": "{\n\tpath := fmt.Sprintf(\"v2/images/%d/actions\", imageID)\n\n\treq, err := i.client.NewRequest(\"POST\", path, transferRequest)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\troot := new(actionRoot)\n\tresp, err := i.client.Do(req, root)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn &root.Event, resp, err\n}"}
{"input": "package block\n\nimport (\n\t\"github.com/juju/cmd\"\n\n\t\"github.com/juju/juju/apiserver/params\"\n\t\"github.com/juju/juju/cmd/envcmd\"\n)\n\nvar (\n\tBlockClient   = &getBlockClientAPI\n\tUnblockClient = &getUnblockClientAPI\n\tListClient    = &getBlockListAPI\n\n\tNewDestroyCommand = newDestroyCommand\n\tNewRemoveCommand  = newRemoveCommand\n\tNewChangeCommand  = newChangeCommand\n\tNewListCommand    = newListCommand\n)\n\ntype MockBlockClient struct {\n\tBlockType string\n\tMsg       string\n}\n\nfunc (c *MockBlockClient) Close() error {\n\treturn nil\n}\n\nfunc (c *MockBlockClient) SwitchBlockOn(blockType, msg string) error {\n\tc.BlockType = blockType\n\tc.Msg = msg\n\treturn nil\n}\n\nfunc (c *MockBlockClient) SwitchBlockOff(blockType string) error {\n\tc.BlockType = blockType\n\tc.Msg = \"\"\n\treturn nil\n}\n\n\n\nfunc NewUnblockCommandWithClient(client UnblockClientAPI) cmd.Command {\n\treturn envcmd.Wrap(&unblockCommand{client: client})\n}\n\nfunc (c *MockBlockClient) List() ([]params.Block, error) ", "output": "{\n\tif c.BlockType == \"\" {\n\t\treturn []params.Block{}, nil\n\t}\n\n\treturn []params.Block{\n\t\tparams.Block{\n\t\t\tType:    c.BlockType,\n\t\t\tMessage: c.Msg,\n\t\t},\n\t}, nil\n}"}
{"input": "package nes\n\nimport \"fmt\"\n\nconst _Button_name = \"ABSelectStartUpDownLeftRightOne\"\n\nvar _Button_index = [...]uint8{1, 2, 8, 13, 15, 19, 23, 28, 31}\n\n\n\nfunc (i Button) String() string ", "output": "{\n\tif i >= Button(len(_Button_index)) {\n\t\treturn fmt.Sprintf(\"Button(%d)\", i)\n\t}\n\thi := _Button_index[i]\n\tlo := uint8(0)\n\tif i > 0 {\n\t\tlo = _Button_index[i-1]\n\t}\n\treturn _Button_name[lo:hi]\n}"}
{"input": "package alsa\n\nimport \"github.com/vchimishuk/chub/alsa/asoundlib\"\n\n\nvar DriverName string = \"alsa\"\n\n\ntype Alsa struct {\n\thandle *asoundlib.Handle\n\topen   bool\n}\n\n\nfunc New() *Alsa {\n\treturn &Alsa{}\n}\n\n\n\nfunc (a *Alsa) IsOpen() bool {\n\treturn a.open\n}\n\nfunc (a *Alsa) SampleRate() int {\n\treturn a.handle.SampleRate\n}\n\nfunc (a *Alsa) SetSampleRate(rate int) {\n\ta.handle.SampleRate = rate\n\ta.handle.ApplyHwParams()\n}\n\nfunc (a *Alsa) Channels() int {\n\treturn a.handle.Channels\n}\n\nfunc (a *Alsa) SetChannels(channels int) {\n\ta.handle.Channels = channels\n\ta.handle.ApplyHwParams()\n}\n\nfunc (a *Alsa) Wait(maxDelay int) (ok bool, err error) {\n\treturn a.handle.Wait(maxDelay)\n}\n\nfunc (a *Alsa) AvailUpdate() (size int, err error) {\n\treturn a.handle.AvailUpdate()\n}\n\nfunc (a *Alsa) Write(buf []byte) (written int, err error) {\n\treturn a.handle.Write(buf)\n}\n\nfunc (a *Alsa) Reset() {\n\ta.handle.Reset()\n}\n\nfunc (a *Alsa) Pause() {\n\ta.handle.Pause()\n}\n\nfunc (a *Alsa) Paused() bool {\n\treturn a.handle.Paused()\n}\n\nfunc (a *Alsa) Close() {\n\ta.handle.Close()\n\ta.open = false\n}\n\nfunc (a *Alsa) Open() error ", "output": "{\n\ta.handle = asoundlib.New()\n\terr := a.handle.Open(\"default\", asoundlib.StreamTypePlayback, asoundlib.ModeBlock)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ta.handle.SampleFormat = asoundlib.SampleFormatS16LE\n\ta.handle.SampleRate = 44100\n\ta.handle.Channels = 2\n\ta.handle.ApplyHwParams()\n\n\ta.open = true\n\n\treturn nil\n}"}
{"input": "package reminder\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"github.com/zuzuleinen/dave/config\"\n\t\"github.com/zuzuleinen/dave/email\"\n\t\"log\"\n\t\"time\"\n)\n\nfunc Remind(db *sql.DB) {\n\tfor true {\n\t\treminders := Read(db)\n\t\tfor _, r := range reminders {\n\t\t\tif shouldRemind(r) {\n\t\t\t\tsendReminderMail(r.Name)\n\t\t\t\tDelete(r.RowId, db)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc shouldRemind(r Reminder) bool {\n\tt, err := time.Parse(config.TimeFormat(), r.Time)\n\n\tif err != nil {\n\t\tlog.Fatalln(\"Cannot parse time\", err)\n\t}\n\tthisYear, thisMonth, today := time.Now().Date()\n\ty, m, d := t.Date()\n\tif thisYear == y && thisMonth == m && today == d {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n\nfunc sendReminderMail(todo string) ", "output": "{\n\tsubject := fmt.Sprintf(\"Reminder: %s\", todo)\n\tbody := fmt.Sprintf(\"Hey, you need to %s\", todo)\n\n\temail.Send(config.YourEmail(), subject, body)\n}"}
{"input": "package botReactions\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/bwmarrin/discordgo\"\n\n\t\"github.com/adayoung/ada-bot/settings\"\n)\n\ntype decide struct {\n\tTrigger string\n}\n\nfunc (d *decide) Help() string {\n\treturn \"Let the bot decide between two or more things for you!\"\n}\n\n\n\nfunc (d *decide) Reaction(m *discordgo.Message, a *discordgo.Member, mType string) Reaction {\n\tchoices := strings.Split(m.Content[len(settings.Settings.Discord.BotPrefix)+len(d.Trigger):], \" or \")\n\ttheAnswer := choices[rand.Intn(len(choices))]\n\tresponse := fmt.Sprintf(\"The correct answer is **%s**\", strings.TrimSpace(theAnswer))\n\treturn Reaction{Text: response}\n}\n\nfunc init() {\n\trand.Seed(time.Now().Unix())\n\n\t_decide := &decide{\n\t\tTrigger: \"decide\",\n\t}\n\taddReaction(_decide.Trigger, \"CREATE\", _decide)\n}\n\nfunc (d *decide) HelpDetail() string ", "output": "{\n\treturn d.Help()\n}"}
{"input": "package reconcilers\n\nimport (\n\t\"net\"\n\n\t\"k8s.io/kubernetes/pkg/api\"\n)\n\n\ntype noneEndpointReconciler struct{}\n\n\n\nfunc NewNoneEndpointReconciler() EndpointReconciler {\n\treturn &noneEndpointReconciler{}\n}\n\n\n\n\n\nfunc (r *noneEndpointReconciler) StopReconciling(serviceName string, ip net.IP, endpointPorts []api.EndpointPort) error {\n\treturn nil\n}\n\nfunc (r *noneEndpointReconciler) ReconcileEndpoints(serviceName string, ip net.IP, endpointPorts []api.EndpointPort, reconcilePorts bool) error ", "output": "{\n\treturn nil\n}"}
{"input": "package common_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"github.com/jacobsa/crypto/common\"\n\t. \"github.com/jacobsa/oglematchers\"\n\t. \"github.com/jacobsa/ogletest\"\n\t\"testing\"\n)\n\nfunc TestPadBlock(t *testing.T) { RunTests(t) }\n\n\n\n\n\ntype PadBlockTest struct{}\n\nfunc init() { RegisterTestSuite(&PadBlockTest{}) }\n\n\n\n\n\nfunc (t *PadBlockTest) FullBlock() {\n\tb := make([]byte, 16)\n\tf := func() { common.PadBlock(b) }\n\tExpectThat(f, Panics(HasSubstr(\"16 bytes\")))\n}\n\n\n\nfunc (t *PadBlockTest) OneByteMissing() {\n\tb, err := hex.DecodeString(\"deadbeeffeedfaceba5eba11cafeba\")\n\tAssertEq(nil, err)\n\tAssertEq(15, len(b))\n\n\texpected := append(b, 0x80)\n\tExpectThat(common.PadBlock(b), DeepEquals(expected))\n}\n\nfunc (t *PadBlockTest) MultipleBytesMissing() {\n\tb, err := hex.DecodeString(\"deadbeeffeedfaceba5eba11ca\")\n\tAssertEq(nil, err)\n\tAssertEq(13, len(b))\n\n\texpected := append(b, 0x80, 0x00, 0x00)\n\tExpectThat(common.PadBlock(b), DeepEquals(expected))\n}\n\nfunc (t *PadBlockTest) AllBytesMissing() {\n\tb := []byte{}\n\texpected := append([]byte{0x80}, bytes.Repeat([]byte{0x00}, 15)...)\n\tExpectThat(common.PadBlock(b), DeepEquals(expected))\n}\n\nfunc (t *PadBlockTest) LongBlock() ", "output": "{\n\tb := make([]byte, 17)\n\tf := func() { common.PadBlock(b) }\n\tExpectThat(f, Panics(HasSubstr(\"16 bytes\")))\n}"}
{"input": "package util\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc init() {\n\trand.Seed(time.Now().UnixNano())\n}\n\n\n\n\n\nfunc RandIntervalN(b1, b2 int32, n uint32) []int32 {\n\tif b1 == b2 {\n\t\treturn []int32{b1}\n\t}\n\tmin, max := int64(b1), int64(b2)\n\tif min > max {\n\t\tmin, max = max, min\n\t}\n\tl := max - min + 1\n\tif int64(n) > l {\n\t\tn = uint32(l)\n\t}\n\tr := make([]int32, n)\n\tm := make(map[int32]int32)\n\tfor i := uint32(0); i < n; i++ {\n\t\tv := int32(rand.Int63n(l) + min)\n\t\tif mv, ok := m[v]; ok {\n\t\t\tr[i] = mv\n\t\t} else {\n\t\t\tr[i] = v\n\t\t}\n\t\tlv := int32(l - 1 + min)\n\t\tif v != lv {\n\t\t\tif mv, ok := m[lv]; ok {\n\t\t\t\tm[v] = mv\n\t\t\t} else {\n\t\t\t\tm[v] = lv\n\t\t\t}\n\t\t}\n\t\tl--\n\t}\n\treturn r\n}\n\n\n\n\n\nfunc RandHit(b1, b2 int32) bool {\n\tif b1 >= b2 {\n\t\treturn true\n\t}\n\tif b1 <= 0 {\n\t\treturn false\n\t}\n\tb3 := RandInterval(1, b2)\n\tif b3 <= b1 {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc RandInterval(b1, b2 int32) int32 ", "output": "{\n\tif b1 == b2 {\n\t\treturn b1\n\t}\n\tmin, max := int64(b1), int64(b2)\n\tif min > max {\n\t\tmin, max = max, min\n\t}\n\treturn int32(rand.Int63n(max-min+1) + min)\n}"}
{"input": "package main\n\nimport (\n\t_ \"github.com/mattn/go-sqlite3\"\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype (\n\tEvent struct {\n\t\tId    int64 `db:\"id\" json:\"-\"`\n\t\tEvent string `db:\"nombre_exhibicion\" json:\"event,omitempty\"`\n\t\tTotal string `db:\"count(nombre_exhibicion)\" json:\"total,omitempty\"`\n\t}\n\n\tResourceEvent struct {\n\t\tId         int64 `json:\"id\"`\n\t\tType       string `json:\"type\"`\n\t\tAttributes Event `json:\"attributes\"`\n\t}\n\n\tResourceEvents struct {\n\t\tData  []ResourceEvent `json:\"data\"`\n\t\tLinks PaginationLinks `json:\"links\"`\n\t\tMeta  Meta `json:\"meta\"`\n\t}\n)\n\nfunc newResourceEvent (attr Event) ResourceEvent {\n\treturn ResourceEvent {\n\t\tId: attr.Id,\n\t\tType: \"events\",\n\t\tAttributes: attr,\n\t}\n}\n\n\n\n\n\nfunc GetEvents(c *gin.Context) {\n\tvar events []Event\n\tpage := c.DefaultQuery(\"page\", \"1\")\n\n\tquery := PaginateQuery(groupByQuery(\"SELECT id, %s, count(%s) FROM exhibiciones\", \"event\"), page)\n\t_, err := dbmap.Select(&events, query)\n\tcheckErr(err)\n\n\tif err == nil {\n\t\tcontent := newResourceEvents(events, \"events\", page)\n\t\tc.JSON(200, content)\n\t} else {\n\t\tjsonErr := &Error{\"not_found\", 404, \"Not Found Error\", \"No event found.\"}\n\t\tc.JSON(404, jsonErr)\n\t}\n}\n\nfunc newResourceEvents (events []Event, endpoint string, pg string) ResourceEvents ", "output": "{\n\tresources := make([]ResourceEvent, 0)\n\tfor l := range events {\n\t\tresources = append(resources, newResourceEvent(events[l]))\n\t}\n\n\tlinks := PaginationLinks {\n\t\tFirst: paginationLink(endpoint, firstPage, \"first\"),\n\t\tLast: paginationLink(endpoint, lastPage, \"last\"),\n\t\tPrev: paginationLink(endpoint, pg, \"prev\"),\n\t\tNext: paginationLink(endpoint, pg, \"next\"),\n\t}\n\n\treturn ResourceEvents{Data: resources, Links: links, Meta: Meta{TotalPages: \"3\"}}\n}"}
{"input": "package rel\n\nimport (\n\t\"reflect\"\n)\n\ntype BinNode UnaryNode\n\n\n\nfunc (node BinNode) Eq(other BinNode) bool ", "output": "{\n\treturn reflect.DeepEqual(node, other)\n}"}
{"input": "package peco\n\nimport \"testing\"\n\n\n\nfunc TestSelection(t *testing.T) ", "output": "{\n\ts := NewSelection()\n\n\talice := NewRawLine(\"Alice\", false)\n\ts.Add(alice)\n\tif s.Len() != 1 {\n\t\tt.Errorf(\"expected Len = 1, got %d\", s.Len())\n\t}\n\ts.Add(NewRawLine(\"Bob\", false))\n\tif s.Len() != 2 {\n\t\tt.Errorf(\"expected Len = 2, got %d\", s.Len())\n\t}\n\ts.Add(alice)\n\tif s.Len() != 2 {\n\t\tt.Errorf(\"expected Len = 2, got %d\", s.Len())\n\t}\n\ts.Remove(alice)\n\tif s.Len() != 1 {\n\t\tt.Errorf(\"expected Len = 1, got %d\", s.Len())\n\t}\n}"}
{"input": "package wire\n\nimport (\n\t\"bytes\"\n\t\"io\"\n)\n\n\n\ntype fixedWriter struct {\n\tb   []byte\n\tpos int\n}\n\n\n\n\n\n\nfunc (w *fixedWriter) Write(p []byte) (n int, err error) {\n\tlenp := len(p)\n\tif w.pos+lenp > cap(w.b) {\n\t\treturn 0, io.ErrShortWrite\n\t}\n\tn = lenp\n\tw.pos += copy(w.b[w.pos:], p)\n\treturn\n}\n\n\nfunc (w *fixedWriter) Bytes() []byte {\n\treturn w.b\n}\n\n\n\nfunc newFixedWriter(max int) io.Writer {\n\tb := make([]byte, max)\n\tfw := fixedWriter{b, 0}\n\treturn &fw\n}\n\n\n\ntype fixedReader struct {\n\tbuf   []byte\n\tpos   int\n\tiobuf *bytes.Buffer\n}\n\n\n\n\n\n\n\n\n\n\nfunc newFixedReader(max int, buf []byte) io.Reader {\n\tb := make([]byte, max)\n\tif buf != nil {\n\t\tcopy(b, buf)\n\t}\n\n\tiobuf := bytes.NewBuffer(b)\n\tfr := fixedReader{b, 0, iobuf}\n\treturn &fr\n}\n\nfunc (fr *fixedReader) Read(p []byte) (n int, err error) ", "output": "{\n\tn, err = fr.iobuf.Read(p)\n\tfr.pos += n\n\treturn\n}"}
{"input": "package rsets\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pingcap/tidb/context\"\n\t\"github.com/pingcap/tidb/plan\"\n\t\"github.com/pingcap/tidb/plan/plans\"\n)\n\nvar (\n\t_ plan.Planner = (*LimitRset)(nil)\n\t_ plan.Planner = (*OffsetRset)(nil)\n)\n\n\ntype OffsetRset struct {\n\tCount uint64\n\tSrc   plan.Plan\n}\n\n\nfunc (r *OffsetRset) Plan(ctx context.Context) (plan.Plan, error) {\n\treturn &plans.OffsetDefaultPlan{Count: r.Count, Src: r.Src, Fields: r.Src.GetFields()}, nil\n}\n\nfunc (r *OffsetRset) String() string {\n\treturn fmt.Sprintf(\" OFFSET %d\", r.Count)\n}\n\n\ntype LimitRset struct {\n\tCount uint64\n\tSrc   plan.Plan\n}\n\n\nfunc (r *LimitRset) Plan(ctx context.Context) (plan.Plan, error) {\n\treturn &plans.LimitDefaultPlan{Count: r.Count, Src: r.Src, Fields: r.Src.GetFields()}, nil\n}\n\n\n\nfunc (r *LimitRset) String() string ", "output": "{\n\treturn fmt.Sprintf(\" LIMIT %d\", r.Count)\n}"}
{"input": "package graph\n\ntype vertexDistance struct {\n\tvertex   string\n\tdistance float64\n}\n\n\n\n\ntype vertexDistanceHeap []vertexDistance\n\nfunc (h vertexDistanceHeap) Len() int           { return len(h) }\nfunc (h vertexDistanceHeap) Less(i, j int) bool { return h[i].distance < h[j].distance } \n\n\nfunc (h *vertexDistanceHeap) Push(x interface{}) {\n\t*h = append(*h, x.(vertexDistance))\n}\n\nfunc (h *vertexDistanceHeap) Pop() interface{} {\n\theapSize := len(*h)\n\tlastVertex := (*h)[heapSize-1]\n\t*h = (*h)[0 : heapSize-1]\n\treturn lastVertex\n}\n\nfunc (h *vertexDistanceHeap) updateDistance(vtx string, val float64) {\n\tfor i := 0; i < len(*h); i++ {\n\t\tif (*h)[i].vertex == vtx {\n\t\t\t(*h)[i].distance = val\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (h vertexDistanceHeap) Swap(i, j int)      ", "output": "{ h[i], h[j] = h[j], h[i] }"}
{"input": "package iso20022\n\n\ntype DeliveringPartiesAndAccount4 struct {\n\n\tDelivererDetails *InvestmentAccount24 `xml:\"DlvrrDtls,omitempty\"`\n\n\tDeliverersCustodianDetails *PartyIdentificationAndAccount5 `xml:\"DlvrrsCtdnDtls,omitempty\"`\n\n\tDeliverersIntermediaryDetails *PartyIdentificationAndAccount5 `xml:\"DlvrrsIntrmyDtls,omitempty\"`\n\n\tDeliveringAgentDetails *PartyIdentificationAndAccount4 `xml:\"DlvrgAgtDtls\"`\n\n\tSecuritiesSettlementSystem *Max35Text `xml:\"SctiesSttlmSys,omitempty\"`\n\n\tPlaceOfSettlementDetails *PartyIdentification21 `xml:\"PlcOfSttlmDtls\"`\n}\n\nfunc (d *DeliveringPartiesAndAccount4) AddDelivererDetails() *InvestmentAccount24 {\n\td.DelivererDetails = new(InvestmentAccount24)\n\treturn d.DelivererDetails\n}\n\nfunc (d *DeliveringPartiesAndAccount4) AddDeliverersCustodianDetails() *PartyIdentificationAndAccount5 {\n\td.DeliverersCustodianDetails = new(PartyIdentificationAndAccount5)\n\treturn d.DeliverersCustodianDetails\n}\n\nfunc (d *DeliveringPartiesAndAccount4) AddDeliverersIntermediaryDetails() *PartyIdentificationAndAccount5 {\n\td.DeliverersIntermediaryDetails = new(PartyIdentificationAndAccount5)\n\treturn d.DeliverersIntermediaryDetails\n}\n\nfunc (d *DeliveringPartiesAndAccount4) AddDeliveringAgentDetails() *PartyIdentificationAndAccount4 {\n\td.DeliveringAgentDetails = new(PartyIdentificationAndAccount4)\n\treturn d.DeliveringAgentDetails\n}\n\nfunc (d *DeliveringPartiesAndAccount4) SetSecuritiesSettlementSystem(value string) {\n\td.SecuritiesSettlementSystem = (*Max35Text)(&value)\n}\n\n\n\nfunc (d *DeliveringPartiesAndAccount4) AddPlaceOfSettlementDetails() *PartyIdentification21 ", "output": "{\n\td.PlaceOfSettlementDetails = new(PartyIdentification21)\n\treturn d.PlaceOfSettlementDetails\n}"}
{"input": "package router\n\nimport \"net/http\"\n\n\ntype Response struct {\n\tResult interface{}\n\n\tRawResponse []byte\n\n\tHTTPResponse *http.Response\n}\n\n\n\nfunc (r *Response) reset() ", "output": "{\n\tr.RawResponse = []byte{}\n\tr.HTTPResponse = nil\n}"}
{"input": "package networkloadbalancer\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetBackendHealthRequest struct {\n\n\tNetworkLoadBalancerId *string `mandatory:\"true\" contributesTo:\"path\" name:\"networkLoadBalancerId\"`\n\n\tBackendSetName *string `mandatory:\"true\" contributesTo:\"path\" name:\"backendSetName\"`\n\n\tBackendName *string `mandatory:\"true\" contributesTo:\"path\" name:\"backendName\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetBackendHealthRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request GetBackendHealthRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request GetBackendHealthRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request GetBackendHealthRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetBackendHealthResponse struct {\n\n\tRawResponse *http.Response\n\n\tBackendHealth `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response GetBackendHealthResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\n\n\nfunc (response GetBackendHealthResponse) HTTPResponse() *http.Response ", "output": "{\n\treturn response.RawResponse\n}"}
{"input": "package apmsynthetics\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetMonitorRequest struct {\n\n\tApmDomainId *string `mandatory:\"true\" contributesTo:\"query\" name:\"apmDomainId\"`\n\n\tMonitorId *string `mandatory:\"true\" contributesTo:\"path\" name:\"monitorId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetMonitorRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request GetMonitorRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request GetMonitorRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetMonitorResponse struct {\n\n\tRawResponse *http.Response\n\n\tMonitor `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response GetMonitorResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response GetMonitorResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request GetMonitorRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) ", "output": "{\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}"}
{"input": "package google\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource\"\n\t\"github.com/hashicorp/terraform-plugin-sdk/v2/terraform\"\n)\n\n\n\nfunc testAccFirestoreIndex_firestoreIndexBasicExample(context map[string]interface{}) string {\n\treturn Nprintf(`\nresource \"google_firestore_index\" \"my-index\" {\n  project = \"%{project_id}\"\n\n  collection = \"chatrooms\"\n\n  fields {\n    field_path = \"name\"\n    order      = \"ASCENDING\"\n  }\n\n  fields {\n    field_path = \"description\"\n    order      = \"DESCENDING\"\n  }\n\n}\n`, context)\n}\n\nfunc testAccCheckFirestoreIndexDestroyProducer(t *testing.T) func(s *terraform.State) error {\n\treturn func(s *terraform.State) error {\n\t\tfor name, rs := range s.RootModule().Resources {\n\t\t\tif rs.Type != \"google_firestore_index\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif strings.HasPrefix(name, \"data.\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconfig := googleProviderConfig(t)\n\n\t\t\turl, err := replaceVarsForTest(config, rs, \"{{FirestoreBasePath}}{{name}}\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tbillingProject := \"\"\n\n\t\t\tif config.BillingProject != \"\" {\n\t\t\t\tbillingProject = config.BillingProject\n\t\t\t}\n\n\t\t\t_, err = sendRequest(config, \"GET\", billingProject, url, config.userAgent, nil)\n\t\t\tif err == nil {\n\t\t\t\treturn fmt.Errorf(\"FirestoreIndex still exists at %s\", url)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\nfunc TestAccFirestoreIndex_firestoreIndexBasicExample(t *testing.T) ", "output": "{\n\tt.Parallel()\n\n\tcontext := map[string]interface{}{\n\t\t\"project_id\":    getTestFirestoreProjectFromEnv(t),\n\t\t\"random_suffix\": randString(t, 10),\n\t}\n\n\tvcrTest(t, resource.TestCase{\n\t\tPreCheck:     func() { testAccPreCheck(t) },\n\t\tProviders:    testAccProviders,\n\t\tCheckDestroy: testAccCheckFirestoreIndexDestroyProducer(t),\n\t\tSteps: []resource.TestStep{\n\t\t\t{\n\t\t\t\tConfig: testAccFirestoreIndex_firestoreIndexBasicExample(context),\n\t\t\t},\n\t\t\t{\n\t\t\t\tResourceName:            \"google_firestore_index.my-index\",\n\t\t\t\tImportState:             true,\n\t\t\t\tImportStateVerify:       true,\n\t\t\t\tImportStateVerifyIgnore: []string{\"database\", \"collection\"},\n\t\t\t},\n\t\t},\n\t})\n}"}
{"input": "package ajax\n\nimport (\n  \"fmt\"\n  \"net/http\"\n  \"encoding/json\"\n  types \"../types\"\n  conf \"../conf\"\n)\n\n\n\ntype AjaxFunc func(http.ResponseWriter, *http.Request, *types.Page, types.UserInfo, conf.ConfigType)\n\nfunc Ajax_handler(w http.ResponseWriter, req *http.Request, p *types.Page, userinfo types.UserInfo, myconfig conf.ConfigType) {\n  funclist := map[string]AjaxFunc {\n    \"ajax_test\": ajax_test,\n  }\n\n  for key, value := range funclist {\n    if key == p.Title {\n      value(w, req, p, userinfo, myconfig)\n      if p.ErrorMsg != \"\" {\n        fmt.Fprintf(w, \"Ajax Error in %s: %s\\n\", p.Title, p.ErrorMsg)\n      }\n      return\n    }\n  }\n  \n  fmt.Fprintf(w, \"Couldn't find ajax!\")\n}\n\nfunc ajax_test(w http.ResponseWriter, req *http.Request, p *types.Page, userinfo types.UserInfo, myconfig conf.ConfigType) ", "output": "{\n  var myjson []interface{}\n\n  myjson[0] = \"test\"\n\n  \n  real_json, err := json.Marshal(myjson)\n  if err != nil {\n      p.ErrorMsg = \"Error #32148: \" + err.Error()\n      return\n  }\n  w.Header().Set(\"Content-Type\", \"application/json\")\n  w.Write(real_json)\n}"}
{"input": "package influxdb\n\nimport (\n\t\"sync\"\n)\n\ntype metricSequenceNum interface {\n\tGet(metric string) uint64\n}\n\ntype realMetricSequenceNum struct {\n\tstore map[string]uint64\n\tlock  sync.Mutex\n}\n\n\n\nfunc newMetricSequenceNum() metricSequenceNum {\n\treturn &realMetricSequenceNum{store: make(map[string]uint64)}\n}\n\nfunc (self *realMetricSequenceNum) Get(metric string) uint64 ", "output": "{\n\tself.lock.Lock()\n\tdefer self.lock.Unlock()\n\tret := self.store[metric]\n\tself.store[metric]++\n\treturn ret\n}"}
{"input": "package layer\n\nimport \"io\"\n\ntype mountedLayer struct {\n\tname          string\n\tmountID       string\n\tinitID        string\n\tparent        *roLayer\n\tpath          string\n\tlayerStore    *layerStore\n\tactivityCount int\n}\n\nfunc (ml *mountedLayer) cacheParent() string {\n\tif ml.initID != \"\" {\n\t\treturn ml.initID\n\t}\n\tif ml.parent != nil {\n\t\treturn ml.parent.cacheID\n\t}\n\treturn \"\"\n}\n\nfunc (ml *mountedLayer) TarStream() (io.ReadCloser, error) {\n\tarchiver, err := ml.layerStore.driver.Diff(ml.mountID, ml.cacheParent())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn archiver, nil\n}\n\nfunc (ml *mountedLayer) Path() (string, error) {\n\tif ml.path == \"\" {\n\t\treturn \"\", ErrNotMounted\n\t}\n\treturn ml.path, nil\n}\n\n\n\nfunc (ml *mountedLayer) Size() (int64, error) {\n\treturn ml.layerStore.driver.DiffSize(ml.mountID, ml.cacheParent())\n}\n\nfunc (ml *mountedLayer) Parent() Layer ", "output": "{\n\tif ml.parent != nil {\n\t\treturn ml.parent\n\t}\n\n\treturn nil\n}"}
{"input": "package iso20022\n\n\ntype Account20 struct {\n\n\tIdentification *Max35Text `xml:\"Id,omitempty\"`\n\n\tAccountServicer *PartyIdentification70Choice `xml:\"AcctSvcr\"`\n}\n\nfunc (a *Account20) SetIdentification(value string) {\n\ta.Identification = (*Max35Text)(&value)\n}\n\n\n\nfunc (a *Account20) AddAccountServicer() *PartyIdentification70Choice ", "output": "{\n\ta.AccountServicer = new(PartyIdentification70Choice)\n\treturn a.AccountServicer\n}"}
{"input": "package procfs\n\nimport (\n\t\"fmt\"\n)\n\n\n\n\nfunc GetFullContainerName(pid int) (string, error) ", "output": "{\n\treturn \"\", fmt.Errorf(\"GetFullContainerName is unsupported in this build\")\n}"}
{"input": "package main\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar (\n\tmessageRegex *regexp.Regexp\n)\n\n\n\nfunc parseText(text string) string {\n\tmatches := messageRegex.FindAllStringSubmatch(text, -1)\n\tfor _, matches2 := range matches {\n\n\t\tif strings.HasPrefix(matches2[1], \"http\") || strings.HasPrefix(matches2[1], \"mailto\") {\n\t\t\tstrings.Replace(text, matches2[0], \"\", -1)\n\n\t\t} else if strings.HasPrefix(matches2[1], \"@U\") {\n\t\t\tparts := strings.SplitN(matches2[1], \"|\", 2)\n\n\t\t\tif len(parts) == 2 {\n\t\t\t\ttext = strings.Replace(text, matches2[0], parts[1], -1)\n\t\t\t} else {\n\t\t\t\ttext = strings.Replace(text, matches2[0], \"\", -1)\n\t\t\t}\n\n\t\t} else if strings.HasPrefix(matches2[1], \"@\") {\n\t\t\ttext = strings.Replace(text, matches2[0], matches2[1], -1)\n\n\t\t} else if strings.HasPrefix(matches2[1], \"#\") {\n\t\t\tparts := strings.SplitN(matches2[1], \"|\", 2)\n\n\t\t\tif len(parts) == 2 {\n\t\t\t\ttext = strings.Replace(text, matches2[0], parts[1], -1)\n\t\t\t} else {\n\t\t\t\ttext = strings.Replace(text, matches2[0], \"\", -1)\n\t\t\t}\n\n\t\t}\n\n\t\ttext = strings.TrimSpace(text)\n\n\t\ttext = strings.Replace(text, \"&lt;\", \"<\", -1)\n\t\ttext = strings.Replace(text, \"&gt;\", \">\", -1)\n\t\ttext = strings.Replace(text, \"&amp;\", \"&\", -1)\n\t}\n\n\treturn text\n}\n\nfunc init() ", "output": "{\n\tmessageRegex = regexp.MustCompile(`<([^>]+)>`)\n}"}
{"input": "package main\n\nimport \"testing\"\n\nfunc TestNewSliceStack(t *testing.T) {\n\tstack := NewStack()\n\n\tif len(stack) != 0 {\n\t\tt.Error(`Expected length of stack to be 0, got`, len(stack))\n\t}\n}\n\nfunc TestSliceStackPush(t *testing.T) {\n\tstack := NewStack()\n\tstack.Push(1111)\n\tstack.Push(2345)\n\n\tif stack[0] != 1111 {\n\t\tt.Error(`Expected the first item to be 1111, got`, stack[0])\n\t}\n}\n\nfunc TestSliceStackPeek(t *testing.T) {\n\tstack := NewStack()\n\tstack.Push(1234)\n\tstack.Push(2345)\n\tvalue, _ := stack.Peek()\n\n\tif value != 2345 {\n\t\tt.Error(`Expected peeked value to be 2345, got`, value)\n\t}\n}\n\n\n\nfunc BenchmarkSliceStackPush(b *testing.B) {\n\tb.StopTimer()\n\tstack := NewStack()\n\n\tb.StartTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tstack.Push(n)\n\t}\n}\n\nfunc BenchmarkSliceStackPeek(b *testing.B) {\n\tb.StopTimer()\n\tstack := make(Stack, b.N, b.N)\n\n\tb.StartTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tstack.Peek()\n\t}\n}\n\nfunc BenchmarkSliceStackPop(b *testing.B) {\n\tb.StopTimer()\n\tstack := make(Stack, b.N, b.N)\n\tfor n := 0; n < b.N; n++ {\n\t\tstack[n] = n\n\t}\n\n\tb.StartTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tstack.Pop()\n\t}\n}\n\nfunc TestSliceStackPop(t *testing.T) ", "output": "{\n\tstack := NewStack()\n\tstack.Push(1234)\n\tstack.Push(2345)\n\tvalue, _ := stack.Pop()\n\n\tif value != 2345 {\n\t\tt.Error(`Expected peeked value to be 2345, got`, value)\n\t}\n}"}
{"input": "package vfsclientset\n\n\nimport (\n\t\"fmt\"\n\n\t_ \"k8s.io/kops/pkg/apis/kops/install\"\n\t_ \"k8s.io/kubernetes/pkg/api/install\"\n\t\"k8s.io/kubernetes/pkg/apimachinery/registered\"\n)\n\n\n\nfunc init() ", "output": "{\n\tif missingVersions := registered.ValidateEnvRequestedVersions(); len(missingVersions) != 0 {\n\t\tpanic(fmt.Sprintf(\"KUBE_API_VERSIONS contains versions that are not installed: %q.\", missingVersions))\n\t}\n}"}
{"input": "package elastic\n\n\n\n\n\ntype ChildrenAggregation struct {\n\ttyp             string\n\tsubAggregations map[string]Aggregation\n\tmeta            map[string]interface{}\n}\n\n\n\nfunc (a *ChildrenAggregation) Type(typ string) *ChildrenAggregation {\n\ta.typ = typ\n\treturn a\n}\n\nfunc (a *ChildrenAggregation) SubAggregation(name string, subAggregation Aggregation) *ChildrenAggregation {\n\ta.subAggregations[name] = subAggregation\n\treturn a\n}\n\n\nfunc (a *ChildrenAggregation) Meta(metaData map[string]interface{}) *ChildrenAggregation {\n\ta.meta = metaData\n\treturn a\n}\n\nfunc (a *ChildrenAggregation) Source() (interface{}, error) {\n\n\tsource := make(map[string]interface{})\n\topts := make(map[string]interface{})\n\tsource[\"children\"] = opts\n\topts[\"type\"] = a.typ\n\n\tif len(a.subAggregations) > 0 {\n\t\taggsMap := make(map[string]interface{})\n\t\tsource[\"aggregations\"] = aggsMap\n\t\tfor name, aggregate := range a.subAggregations {\n\t\t\tsrc, err := aggregate.Source()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\taggsMap[name] = src\n\t\t}\n\t}\n\n\tif len(a.meta) > 0 {\n\t\tsource[\"meta\"] = a.meta\n\t}\n\n\treturn source, nil\n}\n\nfunc NewChildrenAggregation() *ChildrenAggregation ", "output": "{\n\treturn &ChildrenAggregation{\n\t\tsubAggregations: make(map[string]Aggregation),\n\t}\n}"}
{"input": "package router\n\nimport (\n\t\"github.com/weaveworks/weave/mesh\"\n)\n\n\ntype NetworkOverlay interface {\n\tmesh.Overlay\n\n\tInvalidateRoutes()\n\n\tInvalidateShortIDs()\n\n\tStartConsumingPackets(*mesh.Peer, *mesh.Peers, OverlayConsumer) error\n}\n\n\n\ntype OverlayConsumer func(ForwardPacketKey) FlowOp\n\n\ntype OverlayForwarder interface {\n\tmesh.OverlayConnection\n\tForward(ForwardPacketKey) FlowOp\n}\n\ntype NullNetworkOverlay struct{ mesh.NullOverlay }\n\nfunc (NullNetworkOverlay) InvalidateRoutes() {\n}\n\nfunc (NullNetworkOverlay) InvalidateShortIDs() {\n}\n\nfunc (NullNetworkOverlay) StartConsumingPackets(*mesh.Peer, *mesh.Peers, OverlayConsumer) error {\n\treturn nil\n}\n\n\n\nfunc (NullNetworkOverlay) Forward(ForwardPacketKey) FlowOp ", "output": "{\n\treturn DiscardingFlowOp{}\n}"}
{"input": "package mysql\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype DeleteHeatWaveClusterRequest struct {\n\n\tDbSystemId *string `mandatory:\"true\" contributesTo:\"path\" name:\"dbSystemId\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request DeleteHeatWaveClusterRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request DeleteHeatWaveClusterRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request DeleteHeatWaveClusterRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request DeleteHeatWaveClusterRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype DeleteHeatWaveClusterResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n}\n\n\n\n\nfunc (response DeleteHeatWaveClusterResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response DeleteHeatWaveClusterResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package webservice\n\nimport (\n\t\"net/http\"\n\t\"github.com/codegangsta/martini\"\n)\n\n\ntype WebService interface {\n\tGetPath()string\n\n\tWebDelete(params martini.Params) (int, string)\n\n\tWebGet(params martini.Params) (int, string)\n\n\tWebPost(params martini.Params, req *http.Request) (int, string)\n}\n\n\n\n\n\nfunc RegisterWebService(webService WebService, classicMartini *martini.ClassicMartini) ", "output": "{\n\n\tpath := webService.GetPath()\n\n\tclassicMartini.Get(path, webService.WebGet)\n\tclassicMartini.Get(path+\"/:id\", webService.WebGet)\n\n\tclassicMartini.Post(path, webService.WebPost)\n\tclassicMartini.Post(path+\"/:id\", webService.WebPost)\n\n\tclassicMartini.Delete(path, webService.WebDelete)\n\tclassicMartini.Delete(path+\"/:id\", webService.WebDelete)\n}"}
{"input": "package v1beta1\n\nimport (\n\t\"k8s.io/apimachinery/pkg/conversion\"\n\t\"k8s.io/apimachinery/pkg/util/json\"\n\n\t\"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions\"\n)\n\nfunc Convert_apiextensions_JSONSchemaProps_To_v1beta1_JSONSchemaProps(in *apiextensions.JSONSchemaProps, out *JSONSchemaProps, s conversion.Scope) error {\n\tif err := autoConvert_apiextensions_JSONSchemaProps_To_v1beta1_JSONSchemaProps(in, out, s); err != nil {\n\t\treturn err\n\t}\n\tif in.Default != nil && *(in.Default) == nil {\n\t\tout.Default = nil\n\t}\n\tif in.Example != nil && *(in.Example) == nil {\n\t\tout.Example = nil\n\t}\n\treturn nil\n}\n\n\n\nfunc Convert_v1beta1_JSON_To_apiextensions_JSON(in *JSON, out *apiextensions.JSON, s conversion.Scope) error {\n\tif in != nil {\n\t\tvar i interface{}\n\t\tif err := json.Unmarshal(in.Raw, &i); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*out = i\n\t} else {\n\t\tout = nil\n\t}\n\treturn nil\n}\n\nfunc Convert_apiextensions_JSON_To_v1beta1_JSON(in *apiextensions.JSON, out *JSON, s conversion.Scope) error ", "output": "{\n\traw, err := json.Marshal(*in)\n\tif err != nil {\n\t\treturn err\n\t}\n\tout.Raw = raw\n\treturn nil\n}"}
{"input": "package gorfxtrx\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n)\n\n\ntype Wind struct {\n\tdata           []byte\n\ttypeId         byte\n\tSequenceNumber byte\n\tid             uint16\n\tDirection      uint16\n\tAverageSpeed   float64\n\tGust           float64\n\tBattery        byte\n\tRssi           byte\n}\n\nvar windTypes = map[byte]string{\n\t0x01: \"WTGR800\",\n\t0x02: \"WGR800\",\n\t0x03: \"STR918, WGR918\",\n\t0x04: \"TFA\",\n}\n\n\n\n\nfunc (self *Wind) Id() string {\n\treturn fmt.Sprintf(\"%02x:%02x\", self.id>>8, self.id&0xff)\n}\n\n\nfunc (self *Wind) Type() string {\n\treturn windTypes[self.typeId]\n}\n\nfunc (self *Wind) Receive(data []byte) ", "output": "{\n\tself.data = data\n\tself.typeId = data[2]\n\tself.SequenceNumber = data[3]\n\tself.id = binary.BigEndian.Uint16(data[4:6])\n\tself.Direction = binary.BigEndian.Uint16(data[6:8])\n\tself.AverageSpeed = float64(binary.BigEndian.Uint16(data[8:10])) / 10\n\tself.Gust = float64(binary.BigEndian.Uint16(data[10:12])) / 10\n\tif self.typeId == 0x03 {\n\t\tself.Battery = (data[16] + 1) * 10\n\t} else {\n\t\tself.Battery = (data[16] & 0x0f) * 10\n\t\tself.Rssi = data[16] >> 4\n\t}\n}"}
{"input": "package runtime\n\nimport original \"github.com/Azure/azure-sdk-for-go/services/cognitiveservices/v2.0/luis/runtime\"\n\ntype AzureRegions = original.AzureRegions\n\nconst (\n\tAustraliaeast  AzureRegions = original.Australiaeast\n\tBrazilsouth    AzureRegions = original.Brazilsouth\n\tEastasia       AzureRegions = original.Eastasia\n\tEastus         AzureRegions = original.Eastus\n\tEastus2        AzureRegions = original.Eastus2\n\tNortheurope    AzureRegions = original.Northeurope\n\tSouthcentralus AzureRegions = original.Southcentralus\n\tSoutheastasia  AzureRegions = original.Southeastasia\n\tWestcentralus  AzureRegions = original.Westcentralus\n\tWesteurope     AzureRegions = original.Westeurope\n\tWestus         AzureRegions = original.Westus\n\tWestus2        AzureRegions = original.Westus2\n)\n\nfunc PossibleAzureRegionsValues() []AzureRegions {\n\treturn original.PossibleAzureRegionsValues()\n}\n\ntype APIError = original.APIError\ntype CompositeChildModel = original.CompositeChildModel\ntype CompositeEntityModel = original.CompositeEntityModel\ntype EntityModel = original.EntityModel\ntype EntityWithResolution = original.EntityWithResolution\ntype EntityWithScore = original.EntityWithScore\ntype IntentModel = original.IntentModel\ntype LuisResult = original.LuisResult\n\nfunc UserAgent() string {\n\treturn original.UserAgent() + \" profiles/preview\"\n}\nfunc Version() string {\n\treturn original.Version()\n}\n\ntype BaseClient = original.BaseClient\n\nfunc New(azureRegion AzureRegions) BaseClient {\n\treturn original.New(azureRegion)\n}\n\n\ntype PredictionClient = original.PredictionClient\n\nfunc NewPredictionClient(azureRegion AzureRegions) PredictionClient {\n\treturn original.NewPredictionClient(azureRegion)\n}\n\nfunc NewWithoutDefaults(azureRegion AzureRegions) BaseClient ", "output": "{\n\treturn original.NewWithoutDefaults(azureRegion)\n}"}
{"input": "package sliceiterator\n\n\ntype Iterator struct {\n\tdata *[]string\n\tidx  int\n}\n\n\nfunc New(s *[]string) *Iterator {\n\treturn &Iterator{data: s, idx: -1}\n}\n\n\nfunc (a *Iterator) Size() int {\n\treturn len(*a.data)\n}\n\n\nfunc (a *Iterator) Index() int {\n\treturn a.idx\n}\n\n\nfunc (a *Iterator) Next() bool {\n\tif a.idx < len(*a.data) {\n\t\ta.idx++\n\t}\n\treturn a.idx < len(*a.data)\n}\n\n\nfunc (a *Iterator) ExistsNext() bool {\n\treturn a.idx+1 < len(*a.data)\n}\n\n\nfunc (a *Iterator) Value() string {\n\tif a.idx >= len(*a.data) {\n\t\treturn \"\"\n\t}\n\treturn (*a.data)[a.idx]\n}\n\n\nfunc (a *Iterator) PeekNextValue() (string, bool) {\n\tif a.idx+1 >= len(*a.data) {\n\t\treturn \"\", false\n\t}\n\treturn (*a.data)[a.idx+1], true\n}\n\n\nfunc (a *Iterator) IsLast() bool {\n\treturn a.idx == len(*a.data)-1\n}\n\n\n\n\n\nfunc (a *Iterator) Reset() {\n\ta.idx = -1\n}\n\nfunc (a *Iterator) Remaining() []string ", "output": "{\n\tif a.idx >= len(*a.data) {\n\t\treturn []string{}\n\t}\n\treturn (*a.data)[a.idx:]\n}"}
{"input": "package sse_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/rndz/sse\"\n)\n\nfunc Example() {\n\ts := &Server{}\n\tgo runClient()\n\tlog.Fatal(\"HTTP server error: \", http.ListenAndServe(\"localhost:3000\", s))\n}\n\ntype Server struct {\n}\n\n\n\nfunc runClient() {\n\ttime.Sleep(1 * time.Second)\n\tcfg := &sse.Config{\n\t\tURL: \"http://localhost:3000\",\n\t}\n\tclient, err := sse.New(cfg)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tclient.AddListener(\"ts\", func(e sse.Event) {\n\t\tfmt.Printf(\"%+v\\n\", e)\n\t})\n\tclient.AddListener(\"error\", func(e sse.Event) {\n\t\tfmt.Println(\"error \", e)\n\t})\n\tclient.AddListener(\"open\", func(e sse.Event) {\n\t\tfmt.Println(\"open \", e)\n\t})\n\tclient.Connect()\n}\n\nfunc (s *Server) ServeHTTP(rw http.ResponseWriter, req *http.Request) ", "output": "{\n\tflusher, ok := rw.(http.Flusher)\n\tif !ok {\n\t\thttp.Error(rw, \"Streaming unsupported!\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\trw.Header().Set(\"Content-Type\", \"text/event-stream\")\n\trw.Header().Set(\"Cache-Control\", \"no-cache\")\n\trw.Header().Set(\"Connection\", \"keep-alive\")\n\trw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tfor {\n\t\tfmt.Fprintf(rw, \"event: ts\\ndata: %s\\n\\n\", time.Now())\n\t\tfmt.Fprintf(rw, \"event: new\\ndata: %s\\n\\n\", time.Now())\n\t\tflusher.Flush()\n\t\ttime.Sleep(time.Second * 2)\n\t\treturn\n\t}\n}"}
{"input": "package models\n\n\n\n\nimport (\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\n\n\n\ntype OAuth2TokenIntrospection struct {\n\n\tActive *bool `json:\"active\"`\n\n\tAud []string `json:\"aud\"`\n\n\tClientID string `json:\"client_id,omitempty\"`\n\n\tExp int64 `json:\"exp,omitempty\"`\n\n\tExt interface{} `json:\"ext,omitempty\"`\n\n\tIat int64 `json:\"iat,omitempty\"`\n\n\tIss string `json:\"iss,omitempty\"`\n\n\tNbf int64 `json:\"nbf,omitempty\"`\n\n\tObfuscatedSubject string `json:\"obfuscated_subject,omitempty\"`\n\n\tScope string `json:\"scope,omitempty\"`\n\n\tSub string `json:\"sub,omitempty\"`\n\n\tTokenType string `json:\"token_type,omitempty\"`\n\n\tTokenUse string `json:\"token_use,omitempty\"`\n\n\tUsername string `json:\"username,omitempty\"`\n}\n\n\nfunc (m *OAuth2TokenIntrospection) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateActive(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *OAuth2TokenIntrospection) validateActive(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"active\", \"body\", m.Active); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc (m *OAuth2TokenIntrospection) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\n\n\nfunc (m *OAuth2TokenIntrospection) UnmarshalBinary(b []byte) error ", "output": "{\n\tvar res OAuth2TokenIntrospection\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}"}
{"input": "package dbconn\n\nconst (\n\tdefaultBufSize  = 10\n\tdefaultMaxConns = 10\n)\n\ntype options struct {\n\tbufSize      int\n\tshowSQL      bool\n\tmaxOpenConns int\n\tmaxIdleConns int\n}\n\n\ntype ModelOption func(*options)\n\n\nfunc ModelMaxIdleConns(i int) ModelOption {\n\treturn func(opts *options) {\n\t\topts.maxIdleConns = i\n\t}\n}\n\n\nfunc ModelMaxOpenConns(i int) ModelOption {\n\treturn func(opts *options) {\n\t\topts.maxOpenConns = i\n\t}\n}\n\n\n\n\n\nfunc ModelShowSQL(show bool) ModelOption {\n\treturn func(opts *options) {\n\t\topts.showSQL = show\n\t}\n}\n\nfunc ModelBufferSize(i int) ModelOption ", "output": "{\n\treturn func(opts *options) {\n\t\topts.maxOpenConns = i\n\t}\n}"}
{"input": "package plugins\n\nimport (\n\t\"fmt\"\n\t\"github.com/mattn/go-xmpp\"\n\t\"github.com/yetist/xmppbot/robot\"\n\t\"strings\"\n)\n\ntype Example struct {\n\tName   string\n\tOption map[string]bool\n\tbot    *robot.Bot\n}\n\nfunc NewExample(name string, opt map[string]interface{}) *Example {\n\treturn &Example{\n\t\tName:   name,\n\t\tOption: map[string]bool{},\n\t}\n}\n\nfunc (m *Example) GetName() string {\n\treturn m.Name\n}\n\nfunc (m *Example) GetSummary() string {\n\treturn \"示例模块\"\n}\n\nfunc (m *Example) Help() string {\n\tmsg := []string{\n\t\tm.GetSummary() + \": 回显消息．\",\n\t}\n\treturn strings.Join(msg, \"\\n\")\n}\n\n\n\nfunc (m *Example) CheckEnv() bool {\n\treturn true\n}\n\nfunc (m *Example) Start(bot *robot.Bot) {\n\tfmt.Printf(\"[%s] Starting...\\n\", m.GetName())\n\tm.bot = bot\n}\n\nfunc (m *Example) Stop() {\n\tfmt.Printf(\"[%s] Stop\\n\", m.GetName())\n}\n\nfunc (m *Example) Restart() {\n}\n\nfunc (m *Example) Chat(msg xmpp.Chat) {\n\tif len(msg.Text) == 0 || !msg.Stamp.IsZero() {\n\t\treturn\n\t}\n\tm.bot.ReplyAuto(msg, msg.Text)\n}\n\nfunc (m *Example) Presence(pres xmpp.Presence) {\n}\n\nfunc (m *Example) GetOptions() map[string]string {\n\topts := map[string]string{}\n\treturn opts\n}\n\nfunc (m *Example) SetOption(key, val string) {\n}\n\nfunc (m *Example) Description() string ", "output": "{\n\tmsg := []string{m.Help(),\n\t\t\"当有好友或群聊消息时将自动回复原内容。\",\n\t\t\"本模块可配置属性:\",\n\t}\n\treturn strings.Join(msg, \"\\n\")\n}"}
{"input": "package mocks\n\nimport (\n\tcli \"github.com/stackanetes/kubernetes-entrypoint/client\"\n)\n\ntype MockEntrypoint struct {\n\tclient    cli.ClientInterface\n\tnamespace string\n}\n\nfunc (m MockEntrypoint) Resolve() {\n}\n\nfunc (m MockEntrypoint) Client() (client cli.ClientInterface) {\n\treturn m.client\n}\n\nfunc (m MockEntrypoint) GetNamespace() (namespace string) {\n\treturn m.namespace\n}\n\n\n\nfunc NewEntrypoint() MockEntrypoint {\n\treturn NewEntrypointInNamespace(\"test\")\n}\n\nfunc NewEntrypointInNamespace(namespace string) MockEntrypoint ", "output": "{\n\treturn MockEntrypoint{\n\t\tclient:    NewClient(),\n\t\tnamespace: namespace,\n\t}\n}"}
{"input": "package ldb\n\nimport (\n\t\"bytes\"\n\n\t\"testing\"\n\n\t\"github.com/decred/dcrd/database\"\n\t\"github.com/decred/dcrutil\"\n\n\t\"github.com/btcsuite/golangcrypto/ripemd160\"\n)\n\nfunc TestAddrIndexKeySerialization(t *testing.T) {\n\tvar hash160Bytes [ripemd160.Size]byte\n\tvar packedIndex [35]byte\n\n\tfakeHash160 := dcrutil.Hash160([]byte(\"testing\"))\n\tcopy(fakeHash160, hash160Bytes[:])\n\n\tfakeIndex := database.TxAddrIndex{\n\t\tHash160:  hash160Bytes,\n\t\tHeight:   1,\n\t\tTxOffset: 5,\n\t\tTxLen:    360,\n\t}\n\n\tserializedKey := addrIndexToKey(&fakeIndex)\n\tcopy(packedIndex[:], serializedKey[0:35])\n\tunpackedIndex := unpackTxIndex(packedIndex)\n\n\tif unpackedIndex.Height != fakeIndex.Height {\n\t\tt.Errorf(\"Incorrect block height. Unpack addr index key\"+\n\t\t\t\"serialization failed. Expected %d, received %d\",\n\t\t\t1, unpackedIndex.Height)\n\t}\n\n\tif unpackedIndex.TxOffset != fakeIndex.TxOffset {\n\t\tt.Errorf(\"Incorrect tx offset. Unpack addr index key\"+\n\t\t\t\"serialization failed. Expected %d, received %d\",\n\t\t\t5, unpackedIndex.TxOffset)\n\t}\n\n\tif unpackedIndex.TxLen != fakeIndex.TxLen {\n\t\tt.Errorf(\"Incorrect tx len. Unpack addr index key\"+\n\t\t\t\"serialization failed. Expected %d, received %d\",\n\t\t\t360, unpackedIndex.TxLen)\n\t}\n}\n\n\n\nfunc TestBytesPrefix(t *testing.T) ", "output": "{\n\ttestKey := []byte(\"a\")\n\n\tprefixRange := bytesPrefix(testKey)\n\tif !bytes.Equal(prefixRange.Start, []byte(\"a\")) {\n\t\tt.Errorf(\"Wrong prefix start, got %d, expected %d\", prefixRange.Start,\n\t\t\t[]byte(\"a\"))\n\t}\n\n\tif !bytes.Equal(prefixRange.Limit, []byte(\"b\")) {\n\t\tt.Errorf(\"Wrong prefix end, got %d, expected %d\", prefixRange.Limit,\n\t\t\t[]byte(\"b\"))\n\t}\n}"}
{"input": "package commands\n\nimport (\n\t\"context\"\n\t\"io\"\n\n\t\"github.com/atotto/clipboard\"\n)\n\n\n\nfunc cmdClip(ctx context.Context, cmd Param) (int, error) ", "output": "{\n\tdata, err := io.ReadAll(cmd.In())\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\tclipboard.WriteAll(string(data))\n\treturn 0, nil\n}"}
{"input": "package wray\n\n\n\nfunc contains(target string, slice []string) bool ", "output": "{\n  for _, t := range(slice) {\n    if t == target {\n      return true\n    }\n  }\n  return false\n}"}
{"input": "package schema\n\nimport (\n\t\"fmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc dataSourceResourceShimAdjustSchema(schema map[string]*Schema) {\n\tfor _, s := range schema {\n\t\tif s.Required || s.Optional {\n\t\t\ts.ForceNew = true\n\t\t}\n\n\t\tif s.Elem != nil {\n\t\t\tif r, ok := s.Elem.(*Resource); ok {\n\t\t\t\tdataSourceResourceShimAdjustSchema(r.Schema)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc DataSourceResourceShim(name string, dataSource *Resource) *Resource ", "output": "{\n\tdataSourceResourceShimAdjustSchema(dataSource.Schema)\n\n\tdataSource.Create = CreateFunc(dataSource.Read)\n\tdataSource.Delete = func(d *ResourceData, meta interface{}) error {\n\t\td.SetId(\"\")\n\t\treturn nil\n\t}\n\tdataSource.Update = nil \n\n\tdataSource.DeprecationMessage = fmt.Sprintf(\n\t\t\"using %s as a resource is deprecated; consider using the data source instead\",\n\t\tname,\n\t)\n\n\treturn dataSource\n}"}
{"input": "package stores\n\nimport (\n\t\"jvm/instructions/base\"\n\t\"jvm/rtda\"\n)\n\ntype FSTORE struct{ base.Index8Instruction }\ntype FSTORE_0 struct{ base.NoOperandInstruction }\ntype FSTORE_1 struct{ base.NoOperandInstruction }\ntype FSTORE_2 struct{ base.NoOperandInstruction }\ntype FSTORE_3 struct{ base.NoOperandInstruction }\n\nfunc _fstore(frame *rtda.Frame, index uint) {\n\tval := frame.OperandStack().PopFloat()\n\tframe.LocalVars().SetFloat(index, val)\n}\n\nfunc (self *FSTORE) Execute(frame *rtda.Frame) {\n\t_fstore(frame, uint(self.Index))\n}\n\n\n\nfunc (self *FSTORE_1) Execute(frame *rtda.Frame) {\n\t_fstore(frame, 1)\n}\n\nfunc (self *FSTORE_2) Execute(frame *rtda.Frame) {\n\t_fstore(frame, 2)\n}\n\nfunc (self *FSTORE_3) Execute(frame *rtda.Frame) {\n\t_fstore(frame, 3)\n}\n\nfunc (self *FSTORE_0) Execute(frame *rtda.Frame) ", "output": "{\n\t_fstore(frame, 0)\n}"}
{"input": "package daemon\n\nimport (\n\t\"testing\"\n\n\t\"github.com/docker/docker/pkg/signal\"\n\t\"github.com/docker/docker/runconfig\"\n)\n\nfunc TestGetFullName(t *testing.T) {\n\tname, err := GetFullContainerName(\"testing\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif name != \"/testing\" {\n\t\tt.Fatalf(\"Expected /testing got %s\", name)\n\t}\n\tif _, err := GetFullContainerName(\"\"); err == nil {\n\t\tt.Fatal(\"Error should not be nil\")\n\t}\n}\n\n\n\nfunc TestContainerStopSignal(t *testing.T) {\n\tc := &Container{\n\t\tCommonContainer: CommonContainer{\n\t\t\tConfig: &runconfig.Config{},\n\t\t},\n\t}\n\n\tdef, err := signal.ParseSignal(signal.DefaultStopSignal)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ts := c.stopSignal()\n\tif s != int(def) {\n\t\tt.Fatalf(\"Expected %v, got %v\", def, s)\n\t}\n\n\tc = &Container{\n\t\tCommonContainer: CommonContainer{\n\t\t\tConfig: &runconfig.Config{StopSignal: \"SIGKILL\"},\n\t\t},\n\t}\n\ts = c.stopSignal()\n\tif s != 9 {\n\t\tt.Fatalf(\"Expected 9, got %v\", s)\n\t}\n}\n\nfunc TestValidContainerNames(t *testing.T) ", "output": "{\n\tinvalidNames := []string{\"-rm\", \"&sdfsfd\", \"safd%sd\"}\n\tvalidNames := []string{\"word-word\", \"word_word\", \"1weoid\"}\n\n\tfor _, name := range invalidNames {\n\t\tif validContainerNamePattern.MatchString(name) {\n\t\t\tt.Fatalf(\"%q is not a valid container name and was returned as valid.\", name)\n\t\t}\n\t}\n\n\tfor _, name := range validNames {\n\t\tif !validContainerNamePattern.MatchString(name) {\n\t\t\tt.Fatalf(\"%q is a valid container name and was returned as invalid.\", name)\n\t\t}\n\t}\n}"}
{"input": "package datasource \n\nimport \"fmt\"\n\ntype DatabaseID struct {\n\tprojectID    string\n\tinstanceID   string\n\tdatabaseName string\n\tid           string\n}\n\n\n\nfunc (databaseID *DatabaseID) ProjectID() string {\n\treturn databaseID.projectID\n}\n\nfunc (databaseID *DatabaseID) InstanceID() string {\n\treturn databaseID.instanceID\n}\n\nfunc (databaseID *DatabaseID) DatabaseName() string {\n\treturn databaseID.databaseName\n}\nfunc (databaseID *DatabaseID) ID() string {\n\treturn databaseID.id\n}\n\nfunc NewDatabaseID(projectID string, instanceID string, databaseName string) *DatabaseID ", "output": "{\n\treturn &DatabaseID{\n\t\tprojectID:    projectID,\n\t\tinstanceID:   instanceID,\n\t\tdatabaseName: databaseName,\n\t\tid:           fmt.Sprintf(\"projects/%v/instances/%v/databases/%v\", projectID, instanceID, databaseName),\n\t}\n}"}
{"input": "package utils\n\nimport \"fmt\"\n\nfunc ExampleStringSet_Add() {\n\tset := NewStringSet()\n\tset.Add(\"a\")\n\tset.Add(\"b\")\n\n\tfmt.Println(set)\n\tset.Add(\"a\")\n\tfmt.Println(set)\n\n}\n\nfunc ExampleNewStringSet() {\n\ta := NewStringSet()\n\ta.Add(\"a\")\n\ta.Add(\"b\")\n\n\tb := NewStringSet(\"b\", \"a\")\n\n\tfmt.Println(a.Equals(b))\n\n}\n\nfunc ExampleNewStringSetFromStringMapKeys() {\n\tm := map[string]string{\n\t\t\"a\": \"some a value\",\n\t\t\"b\": \"some b value\",\n\t}\n\n\tset := NewStringSetFromStringMapKeys(m)\n\tfmt.Println(set)\n\n}\n\n\n\nfunc ExampleStringSet_IsEmpty() {\n\ta := NewStringSet()\n\n\tfmt.Println(a.IsEmpty())\n\ta.Add(\"a\")\n\tfmt.Println(a.IsEmpty())\n\n}\n\nfunc ExampleStringSet_Equals() {\n\ta := NewStringSet(\"a\", \"b\")\n\tb := NewStringSet(\"a\", \"b\", \"c\")\n\tfmt.Println(a.Equals(b))\n\n\ta.Add(\"c\")\n\tfmt.Println(a.Equals(b))\n\n}\n\nfunc ExampleStringSet_Contains() {\n\ta := NewStringSet(\"a\", \"b\")\n\tfmt.Println(a.Contains(\"z\"))\n\tfmt.Println(a.Contains(\"a\"))\n\n}\n\nfunc ExampleStringSet_Minus() {\n\ta := NewStringSet(\"a\", \"b\")\n\tb := NewStringSet(\"b\", \"c\")\n\tdelta := a.Minus(b)\n\n\tfmt.Println(delta)\n}\n\nfunc ExampleStringSet_ToSlice() ", "output": "{\n\ta := NewStringSet()\n\ta.Add(\"z\")\n\ta.Add(\"b\")\n\n\tfmt.Println(a.ToSlice())\n\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/cloudfoundry/cli/plugin\"\n)\n\ntype Test1 struct {\n}\n\n\n\nfunc (c *Test1) GetMetadata() plugin.PluginMetadata {\n\treturn plugin.PluginMetadata{\n\t\tName: \"Test1\",\n\t\tVersion: plugin.VersionType{\n\t\t\tMajor: 1,\n\t\t\tMinor: 2,\n\t\t\tBuild: 4,\n\t\t},\n\t\tCommands: []plugin.Command{\n\t\t\t{\n\t\t\t\tName:     \"test_1_cmd1\",\n\t\t\t\tAlias:    \"test_1_cmd1_alias\",\n\t\t\t\tHelpText: \"help text for test_1_cmd1\",\n\t\t\t\tUsageDetails: plugin.Usage{\n\t\t\t\t\tUsage: \"Test plugin command\\n   cf test_1_cmd1 [-a] [-b] [--no-ouput]\",\n\t\t\t\t\tOptions: map[string]string{\n\t\t\t\t\t\t\"a\":         \"flag to do nothing\",\n\t\t\t\t\t\t\"b\":         \"another flag to do nothing\",\n\t\t\t\t\t\t\"no-output\": \"example option with no use\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"test_1_cmd2\",\n\t\t\t\tHelpText: \"help text for test_1_cmd2\",\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc theFirstCmd() {\n\tfmt.Println(\"You called cmd1 in test_1\")\n}\n\nfunc theSecondCmd() {\n\tfmt.Println(\"You called cmd2 in test_1\")\n}\n\nfunc uninstalling() {\n\tos.Remove(filepath.Join(os.TempDir(), \"uninstall-test-file-for-test_1.exe\"))\n}\n\nfunc main() {\n\tplugin.Start(new(Test1))\n}\n\nfunc (c *Test1) Run(cliConnection plugin.CliConnection, args []string) ", "output": "{\n\tif args[0] == \"test_1_cmd1\" {\n\t\ttheFirstCmd()\n\t} else if args[0] == \"test_1_cmd2\" {\n\t\ttheSecondCmd()\n\t} else if args[0] == \"CLI-MESSAGE-UNINSTALL\" {\n\t\tuninstalling()\n\t}\n}"}
{"input": "package mxgo\n\ntype AdminController struct {\n\tController\n}\n\nfunc (rest AdminController) add() Result{\n\treturn &JSONResult{}\n}\n\nfunc (rest AdminController) delete() Result{\n\treturn &JSONResult{}\n}\n\nfunc (rest AdminController) edit() Result{\n\treturn &JSONResult{}\n}\n\n\n\nfunc (rest AdminController) query() Result", "output": "{\n\treturn &JSONResult{}\n}"}
{"input": "package cmd\n\nimport (\n\t\"github.com/spf13/cobra\"\n)\n\nvar functionLogDetails bool\nvar functionLogFollow bool\nvar functionLogShowStderr bool\nvar functionLogShowStdout bool\nvar functionLogTimestamps bool\nvar functionLogSince string\nvar functionLogUntil string\nvar functionLogTail string\n\n\n\nfunc setupFunctionLogsFlags() {\n\n\tfunctionLogsCmd.PersistentFlags().StringVarP(&functionName, \"name\", \"n\", \"\", \"function name\")\n\n\tfunctionLogsCmd.PersistentFlags().BoolVarP(&functionLogDetails, \"details\", \"d\", false, \"detailes\")\n\tfunctionLogsCmd.PersistentFlags().BoolVarP(&functionLogFollow, \"follow\", \"f\", false, \"follow\")\n\tfunctionLogsCmd.PersistentFlags().BoolVarP(&functionLogShowStderr, \"stderr\", \"e\", false, \"stderr\")\n\tfunctionLogsCmd.PersistentFlags().BoolVarP(&functionLogShowStdout, \"stdout\", \"o\", true, \"stdout\")\n\tfunctionLogsCmd.PersistentFlags().BoolVarP(&functionLogTimestamps, \"timestamps\", \"t\", true, \"timestamps\")\n\n\tfunctionLogsCmd.PersistentFlags().StringVarP(&functionLogSince, \"since\", \"s\", \"\", \"since\")\n\tfunctionLogsCmd.PersistentFlags().StringVarP(&functionLogUntil, \"until\", \"u\", \"\", \"until\")\n\tfunctionLogsCmd.PersistentFlags().StringVarP(&functionLogTail, \"tail\", \"a\", \"\", \"tail\")\n\n}\n\nvar functionLogsCmd = &cobra.Command{\n\tUse:   \"logs\",\n\tShort: \"function : logs\",\n\tLong:  `function : logs`,\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tfunctionLogs(cmd, args)\n\t},\n}\n\nfunc functionLogs(cmd *cobra.Command, args []string) {\n\n\n}\n\nfunc init() ", "output": "{\n\tsetupFunctionLogsFlags()\n}"}
{"input": "package marketplace\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype CreatePublicationRequest struct {\n\n\tCreatePublicationDetails `contributesTo:\"body\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request CreatePublicationRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request CreatePublicationRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request CreatePublicationRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request CreatePublicationRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype CreatePublicationResponse struct {\n\n\tRawResponse *http.Response\n\n\tPublication `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n}\n\nfunc (response CreatePublicationResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\n\n\nfunc (response CreatePublicationResponse) HTTPResponse() *http.Response ", "output": "{\n\treturn response.RawResponse\n}"}
{"input": "package syswrap\n\nimport (\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\nvar fileCount uint64\n\n\n\nvar maxFileCount uint64 = 500000\nvar fileMu sync.RWMutex\n\nfunc SetMaxFileCount(max uint64) {\n\tfileMu.Lock()\n\tmaxFileCount = max\n\tfileMu.Unlock()\n}\n\n\n\n\n\n\nfunc OpenFile(name string, flag int, perm os.FileMode) (file *os.File, mustClose bool, err error) {\n\tfile, err = os.OpenFile(name, flag, perm)\n\tfileMu.RLock()\n\tdefer fileMu.RUnlock()\n\tif newCount := atomic.AddUint64(&fileCount, 1); newCount > maxFileCount {\n\t\tmustClose = true\n\t}\n\treturn file, mustClose, err\n}\n\n\n\n\nfunc CloseFile(f *os.File) error ", "output": "{\n\tatomic.AddUint64(&fileCount, ^uint64(0)) \n\treturn f.Close()\n}"}
{"input": "package manifestparser\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype Locator struct {\n\tFilesToCheckFor []string\n}\n\n\n\nfunc (loc Locator) Path(filepathOrDirectory string) (string, bool, error) {\n\tinfo, err := os.Stat(filepathOrDirectory)\n\tif os.IsNotExist(err) {\n\t\treturn \"\", false, nil\n\t} else if err != nil {\n\t\treturn \"\", false, err\n\t}\n\n\tresolvedFilepathOrDirectory, err := filepath.EvalSymlinks(filepathOrDirectory)\n\tif err != nil {\n\t\treturn \"\", false, err\n\t}\n\n\tif info.IsDir() {\n\t\treturn loc.handleDir(resolvedFilepathOrDirectory)\n\t}\n\n\treturn loc.handleFilepath(resolvedFilepathOrDirectory)\n}\n\nfunc (loc Locator) handleDir(dir string) (string, bool, error) {\n\tfor _, filename := range loc.FilesToCheckFor {\n\t\tfullPath := filepath.Join(dir, filename)\n\t\tif _, err := os.Stat(fullPath); err == nil {\n\t\t\treturn fullPath, true, nil\n\t\t} else if !os.IsNotExist(err) {\n\t\t\treturn \"\", false, err\n\t\t}\n\t}\n\n\treturn \"\", false, nil\n}\n\nfunc (Locator) handleFilepath(filepath string) (string, bool, error) {\n\treturn filepath, true, nil\n}\n\nfunc NewLocator() *Locator ", "output": "{\n\treturn &Locator{\n\t\tFilesToCheckFor: []string{\n\t\t\t\"manifest.yml\",\n\t\t\t\"manifest.yaml\",\n\t\t},\n\t}\n}"}
{"input": "package tristate\n\ntype StateValue int\n\nconst (\n\tTRISTATE_SUCCESS StateValue = iota\n\tTRISTATE_FAILRUE\n\tTRISTATE_UNKNOWN\n)\n\ntype TriState struct {\n\tState StateValue\n\tErr error\n}\n\nfunc NewSuccess() *TriState {\n\treturn nil\n}\n\nfunc NewUnknown(err error) *TriState {\n\tif err == nil {\n\t\tpanic(\"error not set\")\n\t}\n\treturn &TriState{TRISTATE_UNKNOWN, err}\n}\n\nfunc NewFailure(err error) *TriState {\n\tif err == nil {\n\t\tpanic(\"error not set\")\n\t}\n\treturn &TriState{TRISTATE_FAILRUE, err}\n}\n\nfunc (state *TriState) Error() string {\n\treturn state.Err.Error()\n}\n\n\n\nfunc (state *TriState) IsFailure() bool {\n\treturn state != nil && state.State == TRISTATE_FAILRUE\n}\n\nfunc (state *TriState) IsUnknown() bool {\n\treturn state != nil && state.State == TRISTATE_UNKNOWN\n}\n\nfunc (state *TriState) IsSuccess() bool ", "output": "{\n\treturn state == nil || state.State == TRISTATE_SUCCESS\n}"}
{"input": "package cryptstate\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"github.com/colek42/grumble/pkg/cryptstate/ocb2\"\n)\n\n\ntype ocb2Mode struct {\n\tcipher cipher.Block\n}\n\n\nfunc (ocb *ocb2Mode) NonceSize() int {\n\treturn ocb2.NonceSize\n}\n\n\nfunc (ocb *ocb2Mode) KeySize() int {\n\treturn aes.BlockSize\n}\n\n\n\nfunc (ocb *ocb2Mode) Overhead() int {\n\treturn 3\n}\n\n\n\n\n\nfunc (ocb *ocb2Mode) Encrypt(dst []byte, src []byte, nonce []byte) {\n\tif len(dst) <= ocb.Overhead() {\n\t\tpanic(\"cryptstate: bad dst\")\n\t}\n\n\ttag := dst[0:3]\n\tdst = dst[3:]\n\tocb2.Encrypt(ocb.cipher, dst, src, nonce, tag)\n}\n\n\n\nfunc (ocb *ocb2Mode) Decrypt(dst []byte, src []byte, nonce []byte) bool {\n\tif len(src) <= ocb.Overhead() {\n\t\tpanic(\"cryptstate: bad src\")\n\t}\n\n\ttag := src[0:3]\n\tsrc = src[3:]\n\treturn ocb2.Decrypt(ocb.cipher, dst, src, nonce, tag)\n}\n\nfunc (ocb *ocb2Mode) SetKey(key []byte) ", "output": "{\n\tif len(key) != ocb.KeySize() {\n\t\tpanic(\"cryptstate: invalid key length\")\n\t}\n\n\tcipher, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(\"cryptstate: NewCipher returned unexpected \" + err.Error())\n\t}\n\tocb.cipher = cipher\n}"}
{"input": "package types\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"sigs.k8s.io/kustomize/kyaml/resid\"\n)\n\nconst DefaultReplacementFieldPath = \"metadata.name\"\n\n\n\ntype Replacement struct {\n\tSource *SourceSelector `json:\"source\" yaml:\"source\"`\n\n\tTargets []*TargetSelector `json:\"targets\" yaml:\"targets\"`\n}\n\n\ntype SourceSelector struct {\n\tresid.ResId `json:\",inline,omitempty\" yaml:\",inline,omitempty\"`\n\n\tFieldPath string `json:\"fieldPath\" yaml:\"fieldPath\"`\n\n\tOptions *FieldOptions `json:\"options\" yaml:\"options\"`\n}\n\n\n\n\ntype TargetSelector struct {\n\tSelect *Selector `json:\"select\" yaml:\"select\"`\n\n\tReject []*Selector `json:\"reject\" yaml:\"reject\"`\n\n\tFieldPaths []string `json:\"fieldPaths\" yaml:\"fieldPaths\"`\n\n\tOptions *FieldOptions `json:\"options\" yaml:\"options\"`\n}\n\n\ntype FieldOptions struct {\n\tDelimiter string `json:\"delimiter\" yaml:\"delimiter\"`\n\n\tIndex int `json:\"index\" yaml:\"index\"`\n\n\tEncoding string `json:\"encoding\" yaml:\"encoding\"`\n\n\tCreate bool `json:\"create\" yaml:\"create\"`\n}\n\nfunc (fo *FieldOptions) String() string {\n\tif fo == nil || fo.Delimiter == \"\" {\n\t\treturn \"\"\n\t}\n\treturn fmt.Sprintf(\"%s(%d)\", fo.Delimiter, fo.Index)\n}\n\nfunc (s *SourceSelector) String() string ", "output": "{\n\tif s == nil {\n\t\treturn \"\"\n\t}\n\tresult := []string{s.ResId.String()}\n\tif s.FieldPath != \"\" {\n\t\tresult = append(result, s.FieldPath)\n\t}\n\tif opts := s.Options.String(); opts != \"\" {\n\t\tresult = append(result, opts)\n\t}\n\treturn strings.Join(result, \":\")\n}"}
{"input": "package lib\n\nimport (\n\t\"github.com/atinm/spotify\"\n)\n\nfunc ignored(device string) bool {\n\tfor _, name := range config.Ignored {\n\t\tif name == device {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc FiltersEnabled() bool {\n\treturn ParentalControlsEnabled()\n}\n\nfunc ParentalControlsEnabled() bool {\n\treturn rule.Explicit\n}\n\n\n\nfunc SetParentalControls(b bool) {\n\trule.Explicit = b\n}\n\nfunc Rules(track *spotify.FullTrack, device string) bool ", "output": "{\n\tif track != nil && rule.Explicit && track.Explicit && !ignored(device) {\n\t\treturn true\n\t}\n\treturn false\n}"}
{"input": "package appjson\n\nimport (\n\t\"path/filepath\"\n\n\t\"github.com/dokku/dokku/plugins/common\"\n)\n\nvar (\n\tDefaultProperties = map[string]string{\n\t\t\"appjson-path\": \"\",\n\t}\n\n\tGlobalProperties = map[string]bool{\n\t\t\"appjson-path\": true,\n\t}\n)\n\n\ntype AppJSON struct {\n\tCron    []CronCommand `json:\"cron\"`\n\tScripts struct {\n\t\tDokku struct {\n\t\t\tPredeploy  string `json:\"predeploy\"`\n\t\t\tPostdeploy string `json:\"postdeploy\"`\n\t\t} `json:\"dokku\"`\n\t\tPostdeploy string `json:\"postdeploy\"`\n\t} `json:\"scripts\"`\n}\n\n\ntype CronCommand struct {\n\tCommand  string `json:\"command\"`\n\tSchedule string `json:\"schedule\"`\n}\n\n\n\n\n\nfunc GetAppjsonPath(appName string) string {\n\treturn filepath.Join(GetAppjsonDirectory(appName), \"app.json\")\n}\n\nfunc GetAppjsonDirectory(appName string) string ", "output": "{\n\treturn filepath.Join(common.MustGetEnv(\"DOKKU_LIB_ROOT\"), \"data\", \"app-json\", appName)\n}"}
{"input": "package ss\n\nimport (\n\t\"sync\"\n\n\t\"github.com/willf/bloom\"\n)\n\nconst (\n\tdefaultFilterCapacity  = 100000\n\tdefaultFilterFalseRate = 0.00001\n)\n\ntype bloomFilter struct {\n\tf    *bloom.BloomFilter\n\tlock sync.Mutex\n}\n\n\n\nfunc (b *bloomFilter) Close() error {\n\tb.lock.Lock()\n\tdefer b.lock.Unlock()\n\tb.f.ClearAll()\n\treturn nil\n}\n\nfunc (b *bloomFilter) TestAndAdd(v []byte) bool {\n\tb.lock.Lock()\n\tdefer b.lock.Unlock()\n\tif b == nil || b.f == nil {\n\t\treturn false\n\t}\n\treturn b.f.TestAndAdd(v)\n}\n\nfunc newBloomFilter() bytesFilter ", "output": "{\n\treturn &bloomFilter{\n\t\tf: bloom.NewWithEstimates(uint(defaultFilterCapacity), defaultFilterFalseRate),\n\t}\n}"}
{"input": "package stree\n\n\n\ntype serial struct {\n\tstree\n}\n\n\nfunc NewSerial() Tree {\n\tt := new(serial)\n\tt.Clear()\n\treturn t\n}\n\nfunc (t *serial) BuildTree() {\n\tpanic(\"BuildTree() not supported for serial data structure\")\n}\n\n\n\nfunc (t *serial) Tree2Array() []SegmentOverlap {\n\tpanic(\"Tree2Array() not supported for serial data structure\")\n}\n\n\nfunc (t *serial) Query(from, to int) []Interval {\n\tresult := make([]Interval, 0, 10)\n\tfor _, intrvl := range t.base {\n\t\tif !intrvl.Segment.Disjoint(from, to) {\n\t\t\tresult = append(result, intrvl)\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc (t *serial) QueryArray(from, to []int) []Interval {\n\tresult := make([]Interval, 0, 10)\n\tfor i, fromvalue := range from {\n\t\tresult = append(result, t.Query(fromvalue, to[i])...)\n\t}\n\treturn result\n}\n\nfunc (t *serial) Print() ", "output": "{\n\tpanic(\"Print() not supported for serial data structure\")\n}"}
{"input": "package kafka\n\nimport (\n\t\"net\"\n)\n\n\ntype BrokerPublisher struct {\n\tbroker *Broker\n\tconn   *net.TCPConn\n}\n\n\n\n\n\nfunc (b *BrokerPublisher) Publish(message *Message) (int, error) {\n\treturn b.BatchPublish(message)\n}\n\n\nfunc (b *BrokerPublisher) BatchPublish(messages ...*Message) (int, error) {\n\trequest := b.broker.EncodePublishRequest(messages...)\n\n\tvar err error\n\tif nil == b.conn {\n\t\tb.conn, err = b.broker.connect()\n\t\tif nil != err {\n\t\t\treturn -1, err\n\t\t}\n\t}\n\tnum, err := b.conn.Write(request)\n\tif err != nil {\n\t\tb.conn, err = b.broker.connect()\n\t\tif nil != err {\n\t\t\treturn -1, err\n\t\t}\n\t\tnum, err := b.conn.Write(request)\n\t\tif nil != err {\n\t\t\treturn -1, err\n\t\t}\n\t\treturn num, err\n\t}\n\treturn num, err\n}\n\n\nfunc (b *BrokerPublisher) ProduceFromChannel(msgChan chan *Message, quit chan struct{}) (int, error) {\n\tconn, err := b.broker.connect()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tdefer conn.Close()\n\n\tnum := 0\n\tfor {\n\t\tselect {\n\t\tcase m := <-msgChan:\n\t\t\trequest := b.broker.EncodePublishRequest(m)\n\t\t\t_, err := conn.Write(request)\n\t\t\tif err != nil {\n\t\t\t\treturn num, err\n\t\t\t}\n\t\t\tnum++\n\t\tcase <-quit:\n\t\t\tbreak\n\t\t}\n\t}\n\treturn num, nil\n}\n\nfunc NewBrokerPublisher(hostname string, topic string, partition int) *BrokerPublisher ", "output": "{\n\treturn &BrokerPublisher{broker: newBroker(hostname, topic, partition)}\n}"}
{"input": "package archive\n\nimport \"golang.org/x/sys/unix\"\n\n\n\nfunc mknod(path string, mode uint32, dev uint64) error {\n\treturn unix.Mknod(path, mode, dev)\n}\n\n\n\n\nfunc lsetxattrCreate(link string, attr string, data []byte) error ", "output": "{\n\terr := unix.Lsetxattr(link, attr, data, 0)\n\tif err == unix.ENOTSUP || err == unix.EEXIST {\n\t\treturn nil\n\t}\n\treturn err\n}"}
{"input": "package collate\n\n\ntype zhPinyinTiDBASCSCollator struct {\n}\n\n\n\n\n\nfunc (py *zhPinyinTiDBASCSCollator) Key(str string) []byte {\n\tpanic(\"implement me\")\n}\n\n\nfunc (py *zhPinyinTiDBASCSCollator) Pattern() WildcardPattern {\n\tpanic(\"implement me\")\n}\n\nfunc (py *zhPinyinTiDBASCSCollator) Compare(a, b string) int ", "output": "{\n\tpanic(\"implement me\")\n}"}
{"input": "package ui\n\nimport (\n\t\"sync\"\n\n\t\"github.com/gdamore/tcell/views\"\n)\n\n\n\n\n\ntype Panel struct {\n\ttb   *TitleBar\n\tsb   *StatusBar\n\tkb   *KeyBar\n\tonce sync.Once\n\tapp  *App\n\n\tviews.Panel\n}\n\nfunc (p *Panel) SetTitle(title string) {\n\tp.tb.SetCenter(title)\n}\n\nfunc (p *Panel) SetKeys(words []string) {\n\tp.kb.SetKeys(words)\n}\n\nfunc (p *Panel) SetStatus(status string) {\n\tp.sb.SetText(status)\n}\n\nfunc (p *Panel) SetGood() {\n\tp.sb.SetGood()\n}\n\nfunc (p *Panel) SetNormal() {\n\tp.sb.SetNormal()\n}\n\nfunc (p *Panel) SetWarn() {\n\tp.sb.SetWarn()\n}\n\nfunc (p *Panel) SetError() {\n\tp.sb.SetError()\n}\n\nfunc (p *Panel) Init(app *App) {\n\tp.once.Do(func() {\n\t\tp.app = app\n\n\t\tp.tb = NewTitleBar()\n\t\tp.tb.SetRight(app.GetAppName())\n\t\tp.tb.SetCenter(\" \")\n\n\t\tp.kb = NewKeyBar()\n\n\t\tp.sb = NewStatusBar()\n\n\t\tp.Panel.SetTitle(p.tb)\n\t\tp.Panel.SetMenu(p.sb)\n\t\tp.Panel.SetStatus(p.kb)\n\t})\n}\n\n\n\nfunc NewPanel(app *App) *Panel {\n\tp := &Panel{}\n\tp.Init(app)\n\treturn p\n}\n\nfunc (p *Panel) App() *App ", "output": "{\n\treturn p.app\n}"}
{"input": "package tools\n\n\nfunc MinInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\n\treturn b\n}\n\n\nfunc MaxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\n\treturn b\n}\n\n\n\n\n\nfunc MinInt64(a, b int64) int64 {\n\tif a < b {\n\t\treturn a\n\t}\n\n\treturn b\n}\n\n\nfunc MaxInt64(a, b int64) int64 {\n\tif a > b {\n\t\treturn a\n\t}\n\n\treturn b\n}\n\nfunc ClampInt(n, min, max int) int ", "output": "{\n\treturn MinInt(max, MaxInt(min, n))\n}"}
{"input": "package main\n\nimport (\n  \"math\"\n  \"time\"\n)\n\n\n\n\n\nfunc timeToUnix(value string) int64 {\n  local, _ := time.LoadLocation(\"Local\")\n  toTime, _ := time.ParseInLocation(timeLayout, value, local)\n  return toTime.Unix()\n}\n\nfunc getTime(packet []byte, entryList *[]string, pointer *int, err *bool) ", "output": "{\n  var timeLen int\n  if len(packet) - *pointer >= 8 && !*err {\n    timeLen = 8\n  }\n  if timeLen > 0 {\n    timeByteString := string(packet[*pointer: *pointer + timeLen])\n    var cInt float64\n    for x := range timeByteString {\n      cInt += float64(timeByteString[x]) * math.Pow(256, float64(timeLen -\n         1 - x))\n    }\n    timestamp := time.Unix(int64(cInt), 0).Format(timeLayout)\n    *entryList = append(*entryList, timestamp)\n  } else {\n    *err = true\n  }\n  *pointer += 8\n}"}
{"input": "package cloud\n\nimport (\n\t\"fmt\"\n)\n\nconst (\n\tVMNotFoundError       = \"Bosh::Clouds::VMNotFound\"\n\tDiskNotFoundError     = \"Bosh::Clouds::DiskNotFound\"\n\tStemcellNotFoundError = \"Bosh::Clouds::StemcellNotFound\"\n\tNotImplementedError   = \"Bosh::Clouds::NotImplemented\"\n)\n\ntype Error interface {\n\terror\n\tMethod() string\n\tType() string\n\tMessage() string\n\tOkToRetry() bool\n}\n\ntype cpiError struct {\n\tmethod   string\n\tcmdError CmdError\n}\n\n\n\nfunc (e cpiError) Error() string {\n\treturn fmt.Sprintf(\"CPI '%s' method responded with error: %s\", e.method, e.cmdError)\n}\n\nfunc (e cpiError) Method() string {\n\treturn e.method\n}\n\nfunc (e cpiError) Type() string {\n\treturn e.cmdError.Type\n}\n\nfunc (e cpiError) Message() string {\n\treturn e.cmdError.Message\n}\n\nfunc (e cpiError) OkToRetry() bool {\n\treturn e.cmdError.OkToRetry\n}\n\nfunc NewCPIError(method string, cmdError CmdError) Error ", "output": "{\n\treturn cpiError{\n\t\tmethod:   method,\n\t\tcmdError: cmdError,\n\t}\n}"}
{"input": "package context\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gorilla/context\"\n\t\"github.com/megamsys/libgo/errors\"\n\t\"github.com/megamsys/megdcui/auth\"\n)\n\nconst (\n\ttokenContextKey int = iota\n\terrorContextKey\n\tdelayedHandlerKey\n)\n\nfunc Clear(r *http.Request) {\n\tcontext.Clear(r)\n}\n\nfunc GetAuthToken(r *http.Request) auth.Token {\n\tif v := context.Get(r, tokenContextKey); v != nil {\n\t\treturn v.(auth.Token)\n\t}\n\treturn nil\n}\n\nfunc SetAuthToken(r *http.Request, t auth.Token) {\n\tcontext.Set(r, tokenContextKey, t)\n}\n\nfunc AddRequestError(r *http.Request, err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\texistingErr := context.Get(r, errorContextKey)\n\tif existingErr != nil {\n\t\terr = &errors.CompositeError{Base: existingErr.(error), Message: err.Error()}\n\t}\n\tcontext.Set(r, errorContextKey, err)\n}\n\nfunc GetRequestError(r *http.Request) error {\n\tif v := context.Get(r, errorContextKey); v != nil {\n\t\treturn v.(error)\n\t}\n\treturn nil\n}\n\nfunc SetDelayedHandler(r *http.Request, h http.Handler) {\n\tcontext.Set(r, delayedHandlerKey, h)\n}\n\n\n\nfunc GetDelayedHandler(r *http.Request) http.Handler ", "output": "{\n\tv := context.Get(r, delayedHandlerKey)\n\tif v != nil {\n\t\treturn v.(http.Handler)\n\t}\n\treturn nil\n}"}
{"input": "package danmu\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/smartystreets/goconvey/convey\"\n\tgock \"gopkg.in/h2non/gock.v1\"\n)\n\nfunc TestDanmuProtectApplyList(t *testing.T) {\n\tvar (\n\t\tc      = context.TODO()\n\t\tmid    = int64(2089809)\n\t\tpage   = int64(0)\n\t\taidStr = \"1\"\n\t\tsort   = \"ctime\"\n\t\tip     = \"127.0.0.1\"\n\t)\n\tconvey.Convey(\"ProtectApplyList\", t, func(ctx convey.C) {\n\t\tresult, err := d.ProtectApplyList(c, mid, page, aidStr, sort, ip)\n\t\tctx.Convey(\"Then err should be nil.result should not be nil.\", func(ctx convey.C) {\n\t\t\tctx.So(err, convey.ShouldBeNil)\n\t\t\tctx.So(result, convey.ShouldNotBeNil)\n\t\t})\n\t})\n}\n\nfunc TestDanmuProtectApplyVideoList(t *testing.T) {\n\tvar (\n\t\tc   = context.TODO()\n\t\tmid = int64(2089809)\n\t\tip  = \"127.0.0.1\"\n\t)\n\tconvey.Convey(\"ProtectApplyVideoList\", t, func(ctx convey.C) {\n\t\tresult, err := d.ProtectApplyVideoList(c, mid, ip)\n\t\tctx.Convey(\"Then err should be nil.result should not be nil.\", func(ctx convey.C) {\n\t\t\tctx.So(err, convey.ShouldBeNil)\n\t\t\tctx.So(result, convey.ShouldNotBeNil)\n\t\t})\n\t})\n}\n\n\n\nfunc TestDanmuProtectOper(t *testing.T) ", "output": "{\n\tvar (\n\t\tc      = context.TODO()\n\t\tmid    = int64(2089809)\n\t\tstatus = int64(0)\n\t\tids    = \"1,2\"\n\t\tip     = \"127.0.0.1\"\n\t)\n\tconvey.Convey(\"ProtectOper\", t, func(ctx convey.C) {\n\t\tdefer gock.OffAll()\n\t\thttpMock(\"POST\", d.dmProtectApplyStatusURL).Reply(200).JSON(`{\"code\":20043,\"data\":\"\"}`)\n\t\terr := d.ProtectOper(c, mid, status, ids, ip)\n\t\tctx.Convey(\"Then err should be nil.\", func(ctx convey.C) {\n\t\t\tctx.So(err, convey.ShouldNotBeNil)\n\t\t})\n\t})\n}"}
{"input": "package commands\n\nimport (\n\t\"context\"\n\t\"errors\"\n)\n\n\n\nfunc cmdAttrib(ctx context.Context, cmd Param) (int, error) ", "output": "{\n\treturn 1, errors.New(\"not supported\")\n}"}
{"input": "package event\n\nimport \"testing\"\n\n\n\nfunc TestMemPut(t *testing.T) {\n\ttestServicePut(prepareMem, t)\n}\n\nfunc TestMemQuery(t *testing.T) {\n\ttestServiceQuery(prepareMem, t)\n}\n\nfunc prepareMem(ns string, t *testing.T) Service {\n\treturn MemService()\n}\n\nfunc TestMemCount(t *testing.T) ", "output": "{\n\ttestServiceCount(prepareMem, t)\n}"}
{"input": "package source\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (i *Info) SetCommit(commit string) ", "output": "{\n\tif i == nil {\n\t\treturn\n\t}\n\ti.commit = commit\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\t\"net/url\"\n\n\t\"github.com/ChimeraCoder/anaconda\"\n\t\"github.com/go-ini/ini\"\n)\n\nvar Config *ini.File\n\nconst (\n\tconsumerKey    = \"your key here\"\n\tconsumerSecret = \"your secret here\"\n\taccessToken    = \"your token here\"\n\taccessSecret   = \"your secret here\"\n\tmacAddress     = \"mac address of the dash button here\"\n)\n\nfunc main() {\n\tDashMacs[macAddress] = Tweet\n\n\tSnifferStart()\n}\n\n\n\nfunc Tweet() {\n\tPostTweet(\"Testing now\")\n}\n\nfunc PostTweet(tweet string) {\n\tanaconda.SetConsumerKey(consumerKey)\n\tanaconda.SetConsumerSecret(consumerSecret)\n\tapi := anaconda.NewTwitterApi(accessToken, accessSecret)\n\n\tv := url.Values{}\n\n\t_, err := api.PostTweet(tweet, v)\n\tif err != nil {\n\t\tlog.Println(\"We have an error now \", err)\n\t}\n\n}\n\nfunc NoAction() ", "output": "{\n\tlog.Println(\"No action on click.\")\n}"}
{"input": "package acmpca\n\nimport (\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/client\"\n\t\"github.com/aws/aws-sdk-go/aws/client/metadata\"\n\t\"github.com/aws/aws-sdk-go/aws/request\"\n\t\"github.com/aws/aws-sdk-go/aws/signer/v4\"\n\t\"github.com/aws/aws-sdk-go/private/protocol/jsonrpc\"\n)\n\n\n\n\n\n\n\ntype ACMPCA struct {\n\t*client.Client\n}\n\n\nvar initClient func(*client.Client)\n\n\nvar initRequest func(*request.Request)\n\n\nconst (\n\tServiceName = \"acm-pca\"   \n\tEndpointsID = ServiceName \n)\n\n\n\n\n\n\n\n\n\n\n\nfunc New(p client.ConfigProvider, cfgs ...*aws.Config) *ACMPCA {\n\tc := p.ClientConfig(EndpointsID, cfgs...)\n\treturn newClient(*c.Config, c.Handlers, c.Endpoint, c.SigningRegion, c.SigningName)\n}\n\n\n\n\n\n\nfunc (c *ACMPCA) newRequest(op *request.Operation, params, data interface{}) *request.Request {\n\treq := c.NewRequest(op, params, data)\n\n\tif initRequest != nil {\n\t\tinitRequest(req)\n\t}\n\n\treturn req\n}\n\nfunc newClient(cfg aws.Config, handlers request.Handlers, endpoint, signingRegion, signingName string) *ACMPCA ", "output": "{\n\tsvc := &ACMPCA{\n\t\tClient: client.New(\n\t\t\tcfg,\n\t\t\tmetadata.ClientInfo{\n\t\t\t\tServiceName:   ServiceName,\n\t\t\t\tSigningName:   signingName,\n\t\t\t\tSigningRegion: signingRegion,\n\t\t\t\tEndpoint:      endpoint,\n\t\t\t\tAPIVersion:    \"2017-08-22\",\n\t\t\t\tJSONVersion:   \"1.1\",\n\t\t\t\tTargetPrefix:  \"ACMPrivateCA\",\n\t\t\t},\n\t\t\thandlers,\n\t\t),\n\t}\n\n\tsvc.Handlers.Sign.PushBackNamed(v4.SignRequestHandler)\n\tsvc.Handlers.Build.PushBackNamed(jsonrpc.BuildHandler)\n\tsvc.Handlers.Unmarshal.PushBackNamed(jsonrpc.UnmarshalHandler)\n\tsvc.Handlers.UnmarshalMeta.PushBackNamed(jsonrpc.UnmarshalMetaHandler)\n\tsvc.Handlers.UnmarshalError.PushBackNamed(jsonrpc.UnmarshalErrorHandler)\n\n\tif initClient != nil {\n\t\tinitClient(svc.Client)\n\t}\n\n\treturn svc\n}"}
{"input": "package opt\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n\n\ntype AttributesToSnippetOption struct {\n\tvalue []string\n}\n\n\nfunc AttributesToSnippet(v ...string) *AttributesToSnippetOption {\n\treturn &AttributesToSnippetOption{v}\n}\n\n\nfunc (o *AttributesToSnippetOption) Get() []string {\n\tif o == nil {\n\t\treturn []string{}\n\t}\n\treturn o.value\n}\n\n\n\n\n\n\n\nfunc (o *AttributesToSnippetOption) UnmarshalJSON(data []byte) error {\n\tif string(data) == \"null\" {\n\t\to.value = []string{}\n\t\treturn nil\n\t}\n\tvar s string\n\terr := json.Unmarshal(data, &s)\n\tif err == nil {\n\t\to.value = strings.Split(s, \",\")\n\t\tif len(o.value) == 1 && o.value[0] == \"\" {\n\t\t\to.value = []string{}\n\t\t}\n\t\treturn nil\n\t}\n\treturn json.Unmarshal(data, &o.value)\n}\n\n\n\n\nfunc (o *AttributesToSnippetOption) Equal(o2 *AttributesToSnippetOption) bool {\n\tif o == nil {\n\t\treturn o2 == nil || reflect.DeepEqual(o2.value, []string{})\n\t}\n\tif o2 == nil {\n\t\treturn o == nil || reflect.DeepEqual(o.value, []string{})\n\t}\n\treturn reflect.DeepEqual(o.value, o2.value)\n}\n\n\n\n\nfunc AttributesToSnippetEqual(o1, o2 *AttributesToSnippetOption) bool {\n\treturn o1.Equal(o2)\n}\n\nfunc (o AttributesToSnippetOption) MarshalJSON() ([]byte, error) ", "output": "{\n\treturn json.Marshal(o.value)\n}"}
{"input": "package response\n\nimport \"encoding/json\"\nimport \"net/http\"\n\n\ntype Response struct {\n\tStatusCode int         `json:\"status_code\"`\n\tMessage    string      `json:\"message\"`\n\tData       interface{} `json:\"data\"`\n}\n\n\nfunc createResponse(result Response) []byte {\n\tres, _ := json.Marshal(result)\n\treturn res\n}\n\n\nfunc Success(result interface{}) []byte {\n\treturn createResponse(Response{\n\t\tStatusCode: 200,\n\t\tMessage:    \"ok\",\n\t\tData:       result,\n\t})\n}\n\n\nfunc Failed(message string) []byte {\n\treturn createResponse(Response{\n\t\tStatusCode: 500,\n\t\tMessage:    message,\n\t})\n}\n\n\n\nfunc SendJSONResponseHeader(w http.ResponseWriter) ", "output": "{\n\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\tw.WriteHeader(http.StatusOK)\n}"}
{"input": "package transformers\n\nimport (\n\t\"fmt\"\n\n\t\"sigs.k8s.io/kustomize/pkg/expansion\"\n\t\"sigs.k8s.io/kustomize/pkg/resmap\"\n\t\"sigs.k8s.io/kustomize/pkg/transformers/config\"\n)\n\ntype refvarTransformer struct {\n\tfieldSpecs []config.FieldSpec\n\tvars       map[string]string\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (rv *refvarTransformer) Transform(resources resmap.ResMap) error {\n\tfor resId := range resources {\n\t\tobjMap := resources[resId].Map()\n\t\tfor _, pc := range rv.fieldSpecs {\n\t\t\tif !resId.Gvk().IsSelected(&pc.Gvk) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\terr := mutateField(objMap, pc.PathSlice(), false, func(in interface{}) (interface{}, error) {\n\t\t\t\tvar (\n\t\t\t\t\tmappingFunc = expansion.MappingFuncFor(rv.vars)\n\t\t\t\t)\n\t\t\t\tswitch vt := in.(type) {\n\t\t\t\tcase []interface{}:\n\t\t\t\t\tvar xs []string\n\t\t\t\t\tfor _, a := range in.([]interface{}) {\n\t\t\t\t\t\txs = append(xs, expansion.Expand(a.(string), mappingFunc))\n\t\t\t\t\t}\n\t\t\t\t\treturn xs, nil\n\t\t\t\tcase interface{}:\n\t\t\t\t\ts, ok := in.(string)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"%#v is expected to be %T\", in, s)\n\t\t\t\t\t}\n\t\t\t\t\truntimeVal := expansion.Expand(s, mappingFunc)\n\t\t\t\t\treturn runtimeVal, nil\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"\", fmt.Errorf(\"invalid type encountered %T\", vt)\n\t\t\t\t}\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc NewRefVarTransformer(vars map[string]string, p []config.FieldSpec) Transformer ", "output": "{\n\treturn &refvarTransformer{\n\t\tvars:       vars,\n\t\tfieldSpecs: p,\n\t}\n}"}
{"input": "package rfc\n\n\n\nimport (\n\t\"github.com/zmap/zcrypto/x509\"\n\t\"github.com/zmap/zlint/v3/lint\"\n\t\"github.com/zmap/zlint/v3/util\"\n)\n\ntype nameConstraintOnX400 struct{}\n\n\n\nfunc init() {\n\tlint.RegisterLint(&lint.Lint{\n\t\tName:          \"w_name_constraint_on_x400\",\n\t\tDescription:   \"The name constraints extension SHOULD NOT impose constraints on the x400Address name form\",\n\t\tCitation:      \"RFC 5280: 4.2.1.10\",\n\t\tSource:        lint.RFC5280,\n\t\tEffectiveDate: util.RFC5280Date,\n\t\tLint:          NewNameConstraintOnX400,\n\t})\n}\n\nfunc NewNameConstraintOnX400() lint.LintInterface {\n\treturn &nameConstraintOnX400{}\n}\n\n\n\nfunc (l *nameConstraintOnX400) Execute(c *x509.Certificate) *lint.LintResult {\n\tif c.PermittedX400Addresses != nil || c.ExcludedX400Addresses != nil {\n\t\treturn &lint.LintResult{Status: lint.Warn}\n\t}\n\treturn &lint.LintResult{Status: lint.Pass}\n}\n\nfunc (l *nameConstraintOnX400) CheckApplies(c *x509.Certificate) bool ", "output": "{\n\treturn util.IsExtInCert(c, util.NameConstOID)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nconst (\n\tFileType_File      = 1\n\tFileType_Directory = 2\n)\n\nfunc IfString(condition bool, trueVal, falseVal string) string {\n\tif condition {\n\t\treturn trueVal\n\t}\n\treturn falseVal\n}\n\nfunc IfInt(condition bool, trueVal, falseVal int) int {\n\tif condition {\n\t\treturn trueVal\n\t}\n\treturn falseVal\n}\n\n\n\n\n\nfunc CreateDir(dir string, mode os.FileMode) error {\n\t_, err := os.Stat(dir)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn os.MkdirAll(dir, mode)\n\t\t}\n\t}\n\treturn err\n}\n\nfunc CopyFile(src, dest string, mode os.FileMode) error {\n\tdata, err := ioutil.ReadFile(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ioutil.WriteFile(dest, data, mode)\n}\n\n\nfunc GetFileType(path string) (fileType int, err error) {\n\tvar fi os.FileInfo\n\n\tfi, err = os.Stat(path)\n\tif err == nil {\n\t\tfileType = IfInt(fi.IsDir(), FileType_Directory, FileType_File)\n\t} else if os.IsNotExist(err) {\n\t\terr = fmt.Errorf(\"can not find directory or file: %s\", path)\n\t}\n\treturn\n}\n\nfunc ExpandString(s string, data map[string]string) string ", "output": "{\n\treturn os.Expand(s, func(p string) string {\n\t\tv, _ := data[p]\n\t\treturn v\n\t})\n}"}
{"input": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n)\n\ntype threadSafePrintliner struct {\n\tl sync.Mutex\n\tw io.Writer\n}\n\nfunc newThreadSafePrintliner(w io.Writer) *threadSafePrintliner {\n\treturn &threadSafePrintliner{w: w}\n}\n\nfunc (p *threadSafePrintliner) println(s string) {\n\tp.l.Lock()\n\tfmt.Fprintln(p.w, s)\n\tp.l.Unlock()\n}\n\n\n\nfunc trimEmpty(s []string) []string {\n\tvar r = make([]string, 0)\n\tfor _, str := range s {\n\t\tif str != \"\" {\n\t\t\tr = append(r, str)\n\t\t}\n\t}\n\treturn r\n}\n\nfunc awaitSignal(cancel context.CancelFunc) {\n\tsignals := make(chan os.Signal)\n\tsignal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)\n\t<-signals\n\tcancel()\n}\n\nfunc readQuery(r io.Reader) string ", "output": "{\n\ts, _ := ioutil.ReadAll(r) \n\treturn strings.TrimSpace(strings.Replace(string(s), \"\\n\", \" \", -1))\n}"}
{"input": "package readline\n\nimport \"io\"\n\ntype Instance struct {\n\tt *Terminal\n\to *Operation\n}\n\ntype Config struct {\n\tPrompt      string\n\tHistoryFile string\n}\n\n\n\nfunc New(prompt string) (*Instance, error) {\n\treturn NewEx(&Config{Prompt: prompt})\n}\n\nfunc (i *Instance) Stderr() io.Writer {\n\treturn i.o.Stderr()\n}\n\nfunc (i *Instance) Readline() (string, error) {\n\treturn i.o.String()\n}\n\nfunc (i *Instance) ReadSlice() ([]byte, error) {\n\treturn i.o.Slice()\n}\n\nfunc (i *Instance) Close() error {\n\ti.o.Close()\n\treturn i.t.Close()\n}\n\nfunc (i *Instance) Write(b []byte) (int, error) {\n\treturn i.o.Stderr().Write(b)\n}\n\nfunc NewEx(cfg *Config) (*Instance, error) ", "output": "{\n\tt, err := NewTerminal(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trl := t.Readline()\n\treturn &Instance{\n\t\tt: t,\n\t\to: rl,\n\t}, nil\n}"}
{"input": "package grpclog \n\nimport \"os\"\n\nvar logger = newLoggerV2()\n\n\nfunc V(l int) bool {\n\treturn logger.V(l)\n}\n\n\nfunc Info(args ...interface{}) {\n\tlogger.Info(args...)\n}\n\n\nfunc Infof(format string, args ...interface{}) {\n\tlogger.Infof(format, args...)\n}\n\n\nfunc Infoln(args ...interface{}) {\n\tlogger.Infoln(args...)\n}\n\n\nfunc Warning(args ...interface{}) {\n\tlogger.Warning(args...)\n}\n\n\nfunc Warningf(format string, args ...interface{}) {\n\tlogger.Warningf(format, args...)\n}\n\n\nfunc Warningln(args ...interface{}) {\n\tlogger.Warningln(args...)\n}\n\n\nfunc Error(args ...interface{}) {\n\tlogger.Error(args...)\n}\n\n\nfunc Errorf(format string, args ...interface{}) {\n\tlogger.Errorf(format, args...)\n}\n\n\nfunc Errorln(args ...interface{}) {\n\tlogger.Errorln(args...)\n}\n\n\n\nfunc Fatal(args ...interface{}) {\n\tlogger.Fatal(args...)\n\tos.Exit(1)\n}\n\n\n\nfunc Fatalf(format string, args ...interface{}) {\n\tlogger.Fatalf(format, args...)\n\tos.Exit(1)\n}\n\n\n\n\n\n\n\n\nfunc Print(args ...interface{}) {\n\tlogger.Info(args...)\n}\n\n\n\n\nfunc Printf(format string, args ...interface{}) {\n\tlogger.Infof(format, args...)\n}\n\n\n\n\nfunc Println(args ...interface{}) {\n\tlogger.Infoln(args...)\n}\n\nfunc Fatalln(args ...interface{}) ", "output": "{\n\tlogger.Fatalln(args...)\n\tos.Exit(1)\n}"}
{"input": "package server\n\nimport (\n\t\"encoding/json\"\n\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"github.com/gocaine/go-dart/game\"\n\t\"golang.org/x/net/websocket\"\n)\n\n\ntype GameHub struct {\n\tclients []*websocket.Conn\n\toutput  chan bool\n\tgame    game.Game\n}\n\n\nfunc NewGameHub(game game.Game) *GameHub {\n\thub := GameHub{game: game, clients: make([]*websocket.Conn, 0)}\n\treturn &hub\n}\n\nfunc (gh *GameHub) handle(connection *websocket.Conn) {\n\tlog.Infof(\"new ws connection for this user\")\n\tgh.clients = append(gh.clients, connection)\n\tstatus, _ := json.Marshal(gh.game.State())\n\tconnection.Write([]byte(status))\n\tconnection.Read(make([]byte, 0))\n}\n\nfunc (gh *GameHub) refresh() {\n\tstatus, err := json.Marshal(gh.game.State())\n\tif err != nil {\n\t\tlog.Info(\"cannot serialize status\")\n\t}\n\tstatusAsBytes := []byte(status)\n\tfor _, client := range gh.clients {\n\t\tlog.Info(\"sending status\")\n\t\t_, err := client.Write(statusAsBytes)\n\t\tif err != nil {\n\t\t\tlog.Infof(\"error writing %v\", err)\n\t\t}\n\t}\n}\n\n\n\nfunc (gh *GameHub) close() ", "output": "{\n\tlog.Infof(\"close all websocket connections\")\n\tfor _, client := range gh.clients {\n\t\tclient.Close()\n\t}\n}"}
{"input": "package numeric_test\n\n\nimport (\n\t\"github.com/reiver/go-numeric\"\n\n\t\"fmt\"\n)\n\n\nfunc ExampleNotInRangeComplainer() {\n\n\tr := '½'\n\n\ti64, err := numeric.Int64(r)\n\tif nil != err {\n\t\tswitch err.(type) {\n\t\tcase numeric.NotInRangeComplainer:\n\t\t\tfmt.Printf(\"Although %q is numeric, it is not in the range of an int64.\\n\", r)\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Some other error.\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tfmt.Printf(\"The int64 number is: %d.\\n\", i64)\n\n}\n\n\n\n\nfunc ExampleNotNumericComplainer() ", "output": "{\n\n\tr := '&'\n\n\ti64, err := numeric.Int64(r)\n\tif nil != err {\n\t\tswitch err.(type) {\n\t\tcase numeric.NotNumericComplainer:\n\t\t\tfmt.Printf(\"The rune %q is NOT numeric.\\n\", r)\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"Some other error.\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tfmt.Printf(\"The int64 number is: %d.\\n\", i64)\n\n}"}
{"input": "package core\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/oci/oci-go-sdk/v43/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype CreateSecurityListRequest struct {\n\n\tCreateSecurityListDetails `contributesTo:\"body\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request CreateSecurityListRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request CreateSecurityListRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request CreateSecurityListRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\n\n\n\ntype CreateSecurityListResponse struct {\n\n\tRawResponse *http.Response\n\n\tSecurityList `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response CreateSecurityListResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response CreateSecurityListResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request CreateSecurityListRequest) RetryPolicy() *common.RetryPolicy ", "output": "{\n\treturn request.RequestMetadata.RetryPolicy\n}"}
{"input": "package conversions\n\nimport \"jvmgo/ch10/instructions/base\"\nimport \"jvmgo/ch10/rtda\"\n\n\ntype L2D struct{ base.NoOperandsInstruction }\n\n\n\n\ntype L2F struct{ base.NoOperandsInstruction }\n\nfunc (self *L2F) Execute(frame *rtda.Frame) {\n\tstack := frame.OperandStack()\n\tl := stack.PopLong()\n\tf := float32(l)\n\tstack.PushFloat(f)\n}\n\n\ntype L2I struct{ base.NoOperandsInstruction }\n\nfunc (self *L2I) Execute(frame *rtda.Frame) {\n\tstack := frame.OperandStack()\n\tl := stack.PopLong()\n\ti := int32(l)\n\tstack.PushInt(i)\n}\n\nfunc (self *L2D) Execute(frame *rtda.Frame) ", "output": "{\n\tstack := frame.OperandStack()\n\tl := stack.PopLong()\n\td := float64(l)\n\tstack.PushDouble(d)\n}"}
{"input": "package examples\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\n\t\"github.com/goml/gobrain\"\n\t\"github.com/goml/gobrain/persist\"\n)\n\n\n\nfunc Load(filename string) ", "output": "{\n\trand.Seed(0)\n\n\tff := &gobrain.FeedForward{}\n\n\terr := persist.Load(filename, &ff)\n\tif err != nil {\n\t\tlog.Println(\"impossible to load network from file: \", err.Error())\n\t}\n\n\tinputs := []float64{1, 1}\n\n\tresult := ff.Update(inputs)\n\n\tfmt.Println(result)\n}"}
{"input": "package jpsplus\n\nimport (\n\t\"container/heap\"\n)\n\ntype PriorityQueue struct {\n\tpos  int\n\tnode map[int]*Node\n}\n\nfunc newPriorityQueue() *PriorityQueue {\n\tp := new(PriorityQueue)\n\tp.node = make(map[int]*Node)\n\treturn p\n}\n\nfunc (p *PriorityQueue) Len() int {\n\treturn len(p.node)\n}\n\nfunc (p *PriorityQueue) Less(i, j int) bool {\n\treturn p.node[i].finalCost < p.node[j].finalCost\n}\n\nfunc (p *PriorityQueue) Swap(i, j int) {\n\tp.node[i], p.node[j] = p.node[j], p.node[i]\n\tp.node[i].heapIndex = i\n\tp.node[j].heapIndex = j\n}\n\nfunc (p *PriorityQueue) Push(x interface{}) {\n\titem, ok := x.(*Node)\n\tif ok {\n\t\titem.heapIndex = p.pos\n\t\tp.node[p.pos] = item\n\t\tp.pos++\n\t}\n}\n\nfunc (p *PriorityQueue) Pop() interface{} {\n\tp.pos--\n\titem := p.node[p.pos]\n\tdelete(p.node, p.pos)\n\treturn item\n}\n\nfunc (p *PriorityQueue) PushNode(n *Node) {\n\theap.Push(p, n)\n}\n\nfunc (p *PriorityQueue) PopNode() *Node {\n\treturn heap.Pop(p).(*Node)\n}\n\n\n\nfunc (p *PriorityQueue) RemoveNode(n *Node) ", "output": "{\n\theap.Remove(p, n.heapIndex)\n}"}
{"input": "package tester\n\nimport \"go.etcd.io/etcd/v3/functional/rpcpb\"\n\ntype runnerChecker struct {\n\tctype              rpcpb.Checker\n\tetcdClientEndpoint string\n\terrc               chan error\n}\n\nfunc newRunnerChecker(ep string, errc chan error) Checker {\n\treturn &runnerChecker{\n\t\tctype:              rpcpb.Checker_RUNNER,\n\t\tetcdClientEndpoint: ep,\n\t\terrc:               errc,\n\t}\n}\n\nfunc (rc *runnerChecker) Type() rpcpb.Checker {\n\treturn rc.ctype\n}\n\n\n\nfunc (rc *runnerChecker) Check() error {\n\tselect {\n\tcase err := <-rc.errc:\n\t\treturn err\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc (rc *runnerChecker) EtcdClientEndpoints() []string ", "output": "{\n\treturn []string{rc.etcdClientEndpoint}\n}"}
{"input": "package nodes\n\nimport (\n\t\"github.com/gorilla/mux\"\n)\n\ntype SiteNode struct {\n\tNodeBase    `bson:\",inline\"`\n\tDomain      string `bson:\"dm\"`\n\tEntryNodeId string `bson:\"eid\"`\n}\n\n\n\n\n\nfunc (n *SiteNode) RegisterRoute(route string, router *mux.Router) {\n}\n\n\nfunc (n *SiteNode) IsChildAllowed(typeName string) bool {\n\treturn false\n}\n\n\nfunc NewSiteNode(engine *Engine) *SiteNode {\n\tnode := SiteNode{}\n\tnode.Init(node, engine)\n\treturn &node\n}\n\nfunc init() ", "output": "{\n\tRegisterNodeType(SiteNode{}, func(engine *Engine) Node {\n\t\tnode := Node(NewSiteNode(engine))\n\t\treturn node\n\t})\n}"}
{"input": "package gorouter\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc equal(t *testing.T, expected, actual interface{}) bool {\n\tif !areEqual(expected, actual) {\n\t\tt.Errorf(\"Asserts are not equal. Expected: %v, Actual: %v\", expected, actual)\n\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc notEqual(t *testing.T, expected, actual interface{}) bool {\n\tif areEqual(expected, actual) {\n\t\tt.Errorf(\"Asserts are equal. Expected: %v, Actual: %v\", expected, actual)\n\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc areEqual(expected, actual interface{}) bool {\n\tif expected == nil {\n\t\treturn isNil(actual)\n\t}\n\n\tif actual == nil {\n\t\treturn isNil(expected)\n\t}\n\n\treturn reflect.DeepEqual(expected, actual)\n}\n\nfunc isNil(value interface{}) bool {\n\tdefer func() { recover() }()\n\treturn value == nil || reflect.ValueOf(value).IsNil()\n}\n\nfunc TestRootNode(t *testing.T) {\n\tn := newRoot(\"\")\n\n\tequal(t, \"\", n.id)\n\tequal(t, \"\", n.regexpToString())\n\tequal(t, true, n.isRoot())\n\tequal(t, true, n.isLeaf())\n}\n\nfunc TestRegexNode(t *testing.T) {\n\tn := newRoot(\"\")\n\n\tregexp := \"r([a-z]+)go\"\n\tn.setRegexp(regexp)\n\tequal(t, regexp, n.regexpToString())\n\n\tif !n.regexp.MatchString(\"rzgo\") {\n\t\tt.Error(\"Regexp does not match string\")\n\t}\n}\n\n\n\nfunc TestUnknownNodesChild(t *testing.T) ", "output": "{\n\tn := newRoot(\"\")\n\n\tnode, params := n.getChild([]string{\"a\", \"b\", \"c\"})\n\n\tif node != nil || params != nil {\n\t\tt.Error(\"Node should return nil values for unknown path\")\n\t}\n}"}
{"input": "package sockets\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"syscall\"\n\t\"time\"\n)\n\nconst (\n\tdefaultTimeout        = 10 * time.Second\n\tmaxUnixSocketPathSize = len(syscall.RawSockaddrUnix{}.Path)\n)\n\n\n\nfunc configureNpipeTransport(tr *http.Transport, proto, addr string) error {\n\treturn ErrProtocolNotAvailable\n}\n\n\n\nfunc DialPipe(_ string, _ time.Duration) (net.Conn, error) {\n\treturn nil, syscall.EAFNOSUPPORT\n}\n\nfunc configureUnixTransport(tr *http.Transport, proto, addr string) error ", "output": "{\n\tif len(addr) > maxUnixSocketPathSize {\n\t\treturn fmt.Errorf(\"Unix socket path %q is too long\", addr)\n\t}\n\ttr.DisableCompression = true\n\tdialer := &net.Dialer{\n\t\tTimeout: defaultTimeout,\n\t}\n\ttr.DialContext = func(ctx context.Context, _, _ string) (net.Conn, error) {\n\t\treturn dialer.DialContext(ctx, proto, addr)\n\t}\n\treturn nil\n}"}
{"input": "package serial\n\nimport (\n\t\"errors\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n)\n\nfunc (s *serialPort) setModemControl(bits uintptr, active bool) error {\n\tvar call uintptr\n\tswitch active {\n\tcase true:\n\t\tcall = syscall.TIOCMBIS\n\tcase false:\n\t\tcall = syscall.TIOCMBIC\n\t}\n\treturn ioctlp(s.file.Fd(), call, unsafe.Pointer(&bits))\n}\n\nfunc (s *serialPort) SetRTS(active bool) error {\n\treturn s.setModemControl(syscall.TIOCM_RTS, active)\n}\n\nfunc (s *serialPort) SetDTR(active bool) error {\n\treturn s.setModemControl(syscall.TIOCM_DTR, active)\n}\n\n\n\nfunc (s *serialPort) SetBreak(active bool) error {\n\tvar call uintptr\n\tswitch active {\n\tcase true:\n\t\tcall = syscall.TIOCSBRK\n\tcase false:\n\t\tcall = syscall.TIOCCBRK\n\t}\n\treturn ioctl(s.file.Fd(), call, 0)\n}\n\nfunc timeoutSettings(ict time.Duration, mrs uint) (cc_t, cc_t, error) {\n\n\tvtime := uint(round(ict.Seconds() * 10))\n\tvmin := mrs\n\n\tif vmin == 0 && vtime < 1 {\n\t\treturn 0, 0, errors.New(\"invalid values for InterCharacterTimeout and MinimumReadSize\")\n\t}\n\n\tif vtime > 255 {\n\t\treturn 0, 0, errors.New(\"invalid value for InterCharacterTimeout\")\n\t}\n\treturn cc_t(vtime), cc_t(vmin), nil\n}\n\nfunc ioctlp(fd, request uintptr, argp unsafe.Pointer) error {\n\treturn ioctl(fd, request, uintptr(argp))\n}\n\nfunc (s *serialPort) SetRTSDTR(rtsActive, dtrActive bool) error ", "output": "{\n\tvar bits uintptr\n\tif rtsActive {\n\t\tbits |= syscall.TIOCM_RTS\n\t}\n\tif dtrActive {\n\t\tbits |= syscall.TIOCM_DTR\n\t}\n\treturn ioctlp(s.file.Fd(), syscall.TIOCMSET, unsafe.Pointer(&bits))\n}"}
{"input": "package api\n\nimport (\n\t\"github.com/golang/glog\"\n\t\"github.com/nais/naisd/api/app\"\n\t\"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\tk8smeta \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/client-go/kubernetes\"\n)\n\ntype ServiceAccountInterface interface {\n\tCreateServiceAccountIfNotExist(spec app.Spec) (*v1.ServiceAccount, error)\n\tDeleteServiceAccount(spec app.Spec) error\n}\n\nfunc NewServiceAccountInterface(client kubernetes.Interface) ServiceAccountInterface {\n\treturn clientHolder{\n\t\tclient: client,\n\t}\n}\n\nfunc (c clientHolder) DeleteServiceAccount(spec app.Spec) error {\n\tserviceAccountInterface := c.client.CoreV1().ServiceAccounts(spec.Namespace)\n\n\tif e := serviceAccountInterface.Delete(spec.ResourceName(), &k8smeta.DeleteOptions{}); e != nil && !errors.IsNotFound(e) {\n\t\treturn e\n\t} else {\n\t\treturn nil\n\t}\n}\n\n\n\nfunc createServiceAccountDef(spec app.Spec) *v1.ServiceAccount {\n\treturn &v1.ServiceAccount{\n\t\tTypeMeta: k8smeta.TypeMeta{\n\t\t\tKind:       \"ServiceAccount\",\n\t\t\tAPIVersion: \"v1\",\n\t\t},\n\t\tObjectMeta: generateObjectMeta(spec),\n\t}\n}\n\nfunc (c clientHolder) CreateServiceAccountIfNotExist(spec app.Spec) (*v1.ServiceAccount, error) ", "output": "{\n\tserviceAccountInterface := c.client.CoreV1().ServiceAccounts(spec.Namespace)\n\n\tif account, err := serviceAccountInterface.Get(spec.ResourceName(), k8smeta.GetOptions{}); err == nil {\n\t\tglog.Infof(\"Skipping service account creation. All ready exist for application: %s in namespace: %s\", spec.ResourceName(), spec.Namespace)\n\t\treturn account, nil\n\t}\n\n\treturn serviceAccountInterface.Create(createServiceAccountDef(spec))\n}"}
{"input": "package ccerror\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype ServiceOfferingNameAmbiguityError struct {\n\tServiceOfferingName string\n\tServiceBrokerNames  []string\n}\n\n\n\nfunc (e ServiceOfferingNameAmbiguityError) Error() string ", "output": "{\n\tconst msg = \"Service '%s' is provided by multiple service brokers%s\"\n\tswitch len(e.ServiceBrokerNames) {\n\tcase 0:\n\t\treturn fmt.Sprintf(msg, e.ServiceOfferingName, \".\")\n\tdefault:\n\t\treturn fmt.Sprintf(msg, e.ServiceOfferingName, \": \"+strings.Join(e.ServiceBrokerNames, \", \"))\n\t}\n}"}
{"input": "package runningclient\n\nimport (\n\t\"github.com/jukeizu/client-base\"\n\t\"github.com/jukeizu/scheduler-service/storage\"\n\t\"github.com/shawntoffel/go-restclient\"\n)\n\ntype RunRequest struct {\n\tTime int64 `json:\"time\"`\n}\n\ntype RunResponse struct {\n\tResults []RunResult `json:\"results\"`\n}\n\ntype RunResult struct {\n\tStarted bool         `json:\"started\"`\n\tError   *error       `json:\"error,omitempty\"`\n\tJob     *storage.Job `json:\"job\"`\n}\n\ntype RunningClient interface {\n\tRun(RunRequest) (RunResponse, error)\n}\n\ntype runningClient struct {\n\tClientConfig treediagramclient.ClientConfig\n}\n\nfunc NewClient(config treediagramclient.ClientConfig) RunningClient {\n\treturn &runningClient{config}\n}\n\n\n\nfunc (c *runningClient) Run(request RunRequest) (RunResponse, error) ", "output": "{\n\tresponse := RunResponse{}\n\n\terr := restclient.Post(c.ClientConfig.BaseUrl+\"/run\", request, &response)\n\n\treturn response, err\n}"}
{"input": "package net\n\nimport (\n\t\"os\"\n\t\"syscall\"\n)\n\nfunc setDefaultSockopts(s, family, sotype int, ipv6only bool) error {\n\tif family == syscall.AF_INET6 && sotype != syscall.SOCK_RAW {\n\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, boolint(ipv6only))\n\t}\n\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1))\n}\n\nfunc setDefaultListenerSockopts(s int) error {\n\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1))\n}\n\n\n\nfunc setDefaultMulticastSockopts(s int) error ", "output": "{\n\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1))\n}"}
{"input": "package fake\n\nimport (\n\tclientset \"github.com/openshift/origin/pkg/security/generated/clientset\"\n\tsecurityv1 \"github.com/openshift/origin/pkg/security/generated/clientset/typed/security/v1\"\n\tfakesecurityv1 \"github.com/openshift/origin/pkg/security/generated/clientset/typed/security/v1/fake\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n\t\"k8s.io/client-go/discovery\"\n\tfakediscovery \"k8s.io/client-go/discovery/fake\"\n\t\"k8s.io/client-go/testing\"\n)\n\n\n\n\n\nfunc NewSimpleClientset(objects ...runtime.Object) *Clientset {\n\to := testing.NewObjectTracker(scheme, codecs.UniversalDecoder())\n\tfor _, obj := range objects {\n\t\tif err := o.Add(obj); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tfakePtr := testing.Fake{}\n\tfakePtr.AddReactor(\"*\", \"*\", testing.ObjectReaction(o))\n\tfakePtr.AddWatchReactor(\"*\", testing.DefaultWatchReactor(watch.NewFake(), nil))\n\n\treturn &Clientset{fakePtr, &fakediscovery.FakeDiscovery{Fake: &fakePtr}}\n}\n\n\n\n\ntype Clientset struct {\n\ttesting.Fake\n\tdiscovery *fakediscovery.FakeDiscovery\n}\n\n\n\nvar _ clientset.Interface = &Clientset{}\n\n\nfunc (c *Clientset) SecurityV1() securityv1.SecurityV1Interface {\n\treturn &fakesecurityv1.FakeSecurityV1{Fake: &c.Fake}\n}\n\n\nfunc (c *Clientset) Security() securityv1.SecurityV1Interface {\n\treturn &fakesecurityv1.FakeSecurityV1{Fake: &c.Fake}\n}\n\nfunc (c *Clientset) Discovery() discovery.DiscoveryInterface ", "output": "{\n\treturn c.discovery\n}"}
{"input": "package controller\n\nimport (\n\t\"fmt\"\n\t\"github.com/Nainterceptor/MiniProject-Ping/config\"\n\t\"github.com/emicklei/go-restful\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n)\n\n\n\nfunc ServeStatic(req *restful.Request, resp *restful.Response) ", "output": "{\n\tactual := path.Join(config.StaticPath, req.PathParameter(\"subpath\"))\n\tif _, err := os.Stat(actual); os.IsNotExist(err) {\n\t\tactual = path.Join(config.StaticPath, \"index.html\")\n\t}\n\tfmt.Printf(\"serving %s ... (from %s)\\n\", actual, req.PathParameter(\"subpath\"))\n\thttp.ServeFile(\n\t\tresp.ResponseWriter,\n\t\treq.Request,\n\t\tactual)\n}"}
{"input": "package httpc\n\n\n\n\nfunc NewFileStore(path string, maxBytes int) Store ", "output": "{\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"math\"\n\t\"sort\"\n)\n\ntype NaiveSieve struct {\n\tsieve map[int]bool\n}\n\nfunc NewNaiveSieve(limit int) NaiveSieve {\n\n\tprimes := make(map[int]bool)\n\n\tprimes[2] = true\n\n\tfor n := 3; n < limit; n += 2 {\n\t\tif IsNaivePrime(n) {\n\t\t\tprimes[n] = true\n\t\t}\n\t}\n\n\treturn NaiveSieve{primes}\n}\n\nfunc (self *NaiveSieve) Contains(n int) bool {\n\t_, ok := self.sieve[n]\n\treturn ok\n}\n\n\n\nfunc IsNaivePrime(n int) bool {\n\tswitch {\n\tcase n == 1:\n\t\treturn false\n\tcase n == 2:\n\t\treturn true\n\tcase n%2 == 0:\n\t\treturn false\n\t}\n\n\tlimit := int(math.Sqrt(float64(n)))\n\n\tfor i := 3; i <= limit; i += 2 {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (self *NaiveSieve) Primes() []int ", "output": "{\n\tprimes := make([]int, 0, len(self.sieve))\n\tfor n, _ := range self.sieve {\n\t\tprimes = append(primes, n)\n\t}\n\tsort.Ints(primes)\n\treturn primes\n}"}
{"input": "package clif\n\nimport (\n\t\"os\"\n\t\"runtime\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\n\n\nfunc init() ", "output": "{\n\tTermWidthCall = func() (int, error) {\n\t\tw := new(termWindow)\n\t\ttio := syscall.TIOCGWINSZ\n\t\tif runtime.GOOS == \"darwin\" {\n\t\t\ttio = TERM_TIOCGWINSZ_OSX\n\t\t}\n\t\tres, _, err := syscall.Syscall(sys_ioctl,\n\t\t\tuintptr(syscall.Stdin),\n\t\t\tuintptr(tio),\n\t\t\tuintptr(unsafe.Pointer(w)),\n\t\t)\n\t\tif err != 0 || int(res) == -1 {\n\t\t\treturn TERM_DEFAULT_WIDTH, os.NewSyscallError(\"GetWinsize\", err)\n\t\t}\n\t\treturn int(w.Col) - 4, nil\n\t}\n\n\tTermWidthCurrent, _ = TermWidthCall()\n}"}
{"input": "package inject\n\nfunc As(t Any) Option {\n\treturn CurrentScope().Fold(\n\t\tfunc(x Any) Option {\n\t\t\tinstance := x.(IModule).GetInstance(t)\n\t\t\treturn instance.Fold(\n\t\t\t\tfunc(x Any) Option {\n\t\t\t\t\treturn instance\n\t\t\t\t},\n\t\t\t\tfunc() Option {\n\t\t\t\t\treturn With(t)\n\t\t\t\t},\n\t\t\t)\n\t\t},\n\t\tfunc() Option {\n\t\t\treturn With(t)\n\t\t},\n\t)\n}\n\nfunc With(t Any) Option {\n\treturn ScopeOf(t).Chain(func(x Any) Option {\n\t\treturn x.(IModule).GetInstance(t)\n\t})\n}\n\n\n\nfunc WithIn(t Any, module Any) Option ", "output": "{\n\treturn ModuleOf(module).Chain(func(x Any) Option {\n\t\treturn x.(IModule).GetInstance(t)\n\t})\n}"}
{"input": "package pgtype_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/jackc/pgx/pgtype\"\n\t\"github.com/jackc/pgx/pgtype/testutil\"\n)\n\n\n\nfunc TestBitNormalize(t *testing.T) {\n\ttestutil.TestSuccessfulNormalize(t, []testutil.NormalizeTest{\n\t\t{\n\t\t\tSQL:   \"select B'111111111'\",\n\t\t\tValue: &pgtype.Bit{Bytes: []byte{255, 128}, Len: 9, Status: pgtype.Present},\n\t\t},\n\t})\n}\n\nfunc TestBitTranscode(t *testing.T) ", "output": "{\n\ttestutil.TestSuccessfulTranscode(t, \"bit(40)\", []interface{}{\n\t\t&pgtype.Varbit{Bytes: []byte{0, 0, 0, 0, 0}, Len: 40, Status: pgtype.Present},\n\t\t&pgtype.Varbit{Bytes: []byte{0, 1, 128, 254, 255}, Len: 40, Status: pgtype.Present},\n\t\t&pgtype.Varbit{Status: pgtype.Null},\n\t})\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc sortStack(orig []int) []int {\n\tvar sorted = make([]int, 0)\n\n\tfor len(orig) != 0 {\n\t\tlastIndex := len(orig) - 1\n\t\torigTop := orig[lastIndex]\n\t\torig = orig[:lastIndex]\n\t\tfor len(sorted) != 0 {\n\t\t\tsortedTop := sorted[len(sorted)-1]\n\t\t\tif origTop <= sortedTop {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\torig = append(orig, sortedTop)\n\t\t\tsorted = sorted[0 : len(sorted)-1]\n\t\t}\n\t\tsorted = append(sorted, origTop)\n\t}\n\treturn sorted\n}\n\n\n\nfunc TestSortedStack() {\n\torig := []int{7, 1, 6, 3, 4, 5}\n\tfmt.Println(\"original:\", orig)\n\tresult := sortStack(orig)\n\tfmt.Println(\"sorted:\", printStack(result))\n}\n\nfunc printStack(stack []int) string ", "output": "{\n\ts := \"\"\n\tfor i := len(stack) - 1; i >= 0; i-- {\n\t\ts += strconv.Itoa(stack[i]) + \",\"\n\t}\n\treturn s\n}"}
{"input": "package libvirt\n\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n)\n\n\nimport \"C\"\n\ntype NetworkEventLifecycle struct {\n\tEvent NetworkEventLifecycleType\n\tDetail int\n}\n\ntype NetworkEventLifecycleCallback func(c *Connect, n *Network, event *NetworkEventLifecycle)\n\n\nfunc networkEventLifecycleCallback(c C.virConnectPtr, n C.virNetworkPtr,\n\tevent int, detail int,\n\tgoCallbackId int) {\n\n\tnetwork := &Network{ptr: n}\n\tconnection := &Connect{ptr: c}\n\n\teventDetails := &NetworkEventLifecycle{\n\t\tEvent:  NetworkEventLifecycleType(event),\n\t\tDetail: detail,\n\t}\n\n\tcallbackFunc := getCallbackId(goCallbackId)\n\tcallback, ok := callbackFunc.(NetworkEventLifecycleCallback)\n\tif !ok {\n\t\tpanic(\"Inappropriate callback type called\")\n\t}\n\tcallback(connection, network, eventDetails)\n}\n\n\n\nfunc (c *Connect) NetworkEventDeregister(callbackId int) error {\n\tif C.LIBVIR_VERSION_NUMBER < 1002001 {\n\t\treturn GetNotImplementedError(\"virConnectNetworkEventDeregisterAny\")\n\t}\n\tif i := int(C.virConnectNetworkEventDeregisterAnyCompat(c.ptr, C.int(callbackId))); i != 0 {\n\t\treturn GetLastError()\n\t}\n\treturn nil\n}\n\nfunc (e NetworkEventLifecycle) String() string {\n\tvar event string\n\tswitch e.Event {\n\tcase NETWORK_EVENT_DEFINED:\n\t\tevent = \"defined\"\n\n\tcase NETWORK_EVENT_UNDEFINED:\n\t\tevent = \"undefined\"\n\n\tcase NETWORK_EVENT_STARTED:\n\t\tevent = \"started\"\n\n\tcase NETWORK_EVENT_STOPPED:\n\t\tevent = \"stopped\"\n\n\tdefault:\n\t\tevent = \"unknown\"\n\t}\n\n\treturn fmt.Sprintf(\"Network event=%q\", event)\n}\n\nfunc (c *Connect) NetworkEventLifecycleRegister(net *Network, callback NetworkEventLifecycleCallback) (int, error) ", "output": "{\n\tgoCallBackId := registerCallbackId(callback)\n\tif C.LIBVIR_VERSION_NUMBER < 1002001 {\n\t\treturn 0, GetNotImplementedError(\"virConnectNetworkEventRegisterAny\")\n\t}\n\n\tcallbackPtr := unsafe.Pointer(C.networkEventLifecycleCallback_cgo)\n\tvar cnet C.virNetworkPtr\n\tif net != nil {\n\t\tcnet = net.ptr\n\t}\n\tret := C.virConnectNetworkEventRegisterAny_cgo(c.ptr, cnet,\n\t\tC.VIR_NETWORK_EVENT_ID_LIFECYCLE,\n\t\tC.virConnectNetworkEventGenericCallback(callbackPtr),\n\t\tC.long(goCallBackId))\n\tif ret == -1 {\n\t\tfreeCallbackId(goCallBackId)\n\t\treturn 0, GetLastError()\n\t}\n\treturn int(ret), nil\n}"}
{"input": "package cmd\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/OJ/gobuster/v3/cli\"\n\t\"github.com/OJ/gobuster/v3/gobusters3\"\n\t\"github.com/OJ/gobuster/v3/libgobuster\"\n\t\"github.com/spf13/cobra\"\n)\n\n\nvar cmdS3 *cobra.Command\n\nfunc runS3(cmd *cobra.Command, args []string) error {\n\tglobalopts, pluginopts, err := parseS3Options()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on parsing arguments: %w\", err)\n\t}\n\n\tplugin, err := gobusters3.NewGobusterS3(globalopts, pluginopts)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error on creating gobusters3: %w\", err)\n\t}\n\n\tif err := cli.Gobuster(mainContext, globalopts, plugin); err != nil {\n\t\treturn fmt.Errorf(\"error on running gobuster: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc parseS3Options() (*libgobuster.Options, *gobusters3.OptionsS3, error) {\n\tglobalopts, err := parseGlobalOptions()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tplugin := gobusters3.NewOptionsS3()\n\n\thttpOpts, err := parseBasicHTTPOptions(cmdS3)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tplugin.UserAgent = httpOpts.UserAgent\n\tplugin.Proxy = httpOpts.Proxy\n\tplugin.Timeout = httpOpts.Timeout\n\tplugin.NoTLSValidation = httpOpts.NoTLSValidation\n\n\tplugin.MaxFilesToList, err = cmdS3.Flags().GetInt(\"maxfiles\")\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"invalid value for maxfiles: %w\", err)\n\t}\n\n\treturn globalopts, plugin, nil\n}\n\n\n\n\nfunc init() ", "output": "{\n\tcmdS3 = &cobra.Command{\n\t\tUse:   \"s3\",\n\t\tShort: \"Uses aws bucket enumeration mode\",\n\t\tRunE:  runS3,\n\t}\n\n\taddBasicHTTPOptions(cmdS3)\n\tcmdS3.Flags().IntP(\"maxfiles\", \"m\", 5, \"max files to list when listing buckets (only shown in verbose mode)\")\n\n\tcmdS3.PersistentPreRun = func(cmd *cobra.Command, args []string) {\n\t\tconfigureGlobalOptions()\n\t}\n\n\trootCmd.AddCommand(cmdS3)\n}"}
{"input": "package common\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n)\n\n\n\n\nconst PackerKeyEnv = \"PACKER_KEY_INTERVAL\"\n\n\n\nconst PackerKeyDefault = 100 * time.Millisecond\n\n\n\nfunc ScrubConfig(target interface{}, values ...string) string {\n\tconf := fmt.Sprintf(\"Config: %+v\", target)\n\tfor _, value := range values {\n\t\tif value == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tconf = strings.Replace(conf, value, \"<Filtered>\", -1)\n\t}\n\treturn conf\n}\n\n\n\n\n\n\n\nfunc DownloadableURL(original string) (string, error) {\n\n\tsupported := []string{\"file\", \"http\", \"https\", \"ftp\", \"smb\"}\n\tfound := false\n\tfor _, s := range supported {\n\t\tif strings.HasPrefix(strings.ToLower(original), s+\"://\") {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif found {\n\t\toriginal = filepath.ToSlash(original)\n\n\t\turi, err := url.Parse(original)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\turi.Scheme = strings.ToLower(uri.Scheme)\n\n\t\treturn uri.String(), nil\n\t}\n\n\t_, err := os.Stat(original)\n\tif err == nil {\n\t\toriginal, err = filepath.Abs(filepath.FromSlash(original))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\toriginal, err = filepath.EvalSymlinks(original)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\toriginal = filepath.Clean(original)\n\t\toriginal = filepath.ToSlash(original)\n\t}\n\n\n\treturn \"file://\" + original, nil\n}\n\nfunc ChooseString(vals ...string) string ", "output": "{\n\tfor _, el := range vals {\n\t\tif el != \"\" {\n\t\t\treturn el\n\t\t}\n\t}\n\n\treturn \"\"\n}"}
{"input": "package container\n\ntype (\n\tLifo struct {\n\t\tFifo\n\t}\n)\n\n\n\nfunc (li *Lifo) Less(i, j int) bool ", "output": "{\n\treturn li.data[i].index > li.data[j].index\n}"}
{"input": "package jobfile\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/dshearer/jobber/common\"\n)\n\nconst (\n\tErrorHandlerStopName     = \"Stop\"\n\tErrorHandlerBackoffName  = \"Backoff\"\n\tErrorHandlerContinueName = \"Continue\"\n\n\tMaxBackoffWait = 8\n)\n\ntype ErrorHandler interface {\n\tHandle(job *Job)\n\tfmt.Stringer\n}\n\ntype ContinueErrorHandler struct{}\n\nfunc (self ContinueErrorHandler) Handle(job *Job) {\n\tjob.Status = JobGood\n}\n\nfunc (self ContinueErrorHandler) String() string {\n\treturn ErrorHandlerContinueName\n}\n\ntype StopErrorHandler struct{}\n\nfunc (self StopErrorHandler) Handle(job *Job) {\n\tjob.Status = JobFailed\n}\n\n\n\ntype BackoffErrorHandler struct{}\n\nfunc (self BackoffErrorHandler) Handle(job *Job) {\n\n\tif job.Status == JobGood {\n\t\tjob.Status = JobBackoff\n\t\tjob.backoffLevel = 1\n\t} else {\n\t\tjob.backoffLevel *= 2\n\t}\n\tif job.backoffLevel > MaxBackoffWait {\n\t\tjob.Status = JobFailed\n\t\tjob.backoffLevel = 0\n\t\tjob.skipsLeft = 0\n\t} else {\n\t\tjob.skipsLeft = job.backoffLevel\n\t}\n}\n\nfunc (self BackoffErrorHandler) String() string {\n\treturn ErrorHandlerBackoffName\n}\n\nfunc GetErrorHandler(name string) (ErrorHandler, error) {\n\tswitch name {\n\tcase ErrorHandlerStopName:\n\t\treturn StopErrorHandler{}, nil\n\tcase ErrorHandlerBackoffName:\n\t\treturn BackoffErrorHandler{}, nil\n\tcase ErrorHandlerContinueName:\n\t\treturn ContinueErrorHandler{}, nil\n\tdefault:\n\t\treturn nil, &common.Error{What: \"Invalid error handler: \" + name}\n\t}\n}\n\nfunc (self StopErrorHandler) String() string ", "output": "{\n\treturn ErrorHandlerStopName\n}"}
{"input": "package mocks\n\nimport (\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n\ntype MockContainerInstanceLoader struct {\n\tctrl     *gomock.Controller\n\trecorder *_MockContainerInstanceLoaderRecorder\n}\n\n\ntype _MockContainerInstanceLoaderRecorder struct {\n\tmock *MockContainerInstanceLoader\n}\n\nfunc NewMockContainerInstanceLoader(ctrl *gomock.Controller) *MockContainerInstanceLoader {\n\tmock := &MockContainerInstanceLoader{ctrl: ctrl}\n\tmock.recorder = &_MockContainerInstanceLoaderRecorder{mock}\n\treturn mock\n}\n\nfunc (_m *MockContainerInstanceLoader) EXPECT() *_MockContainerInstanceLoaderRecorder {\n\treturn _m.recorder\n}\n\nfunc (_m *MockContainerInstanceLoader) LoadContainerInstances() error {\n\tret := _m.ctrl.Call(_m, \"LoadContainerInstances\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n\n\nfunc (_mr *_MockContainerInstanceLoaderRecorder) LoadContainerInstances() *gomock.Call ", "output": "{\n\treturn _mr.mock.ctrl.RecordCall(_mr.mock, \"LoadContainerInstances\")\n}"}
{"input": "package fingerprint\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestSHA256(t *testing.T) ", "output": "{\n\tactual := SHA256(\"mychangingdata\")\n\texpected := \"ee867acc5d96cced9b9fe075e293604214519650065c60b42b95f1ccfbac2c97\"\n\tif actual != expected {\n\t\tt.Errorf(\"unexpected value returned from SHA256: expected=%v actual=%v\", expected, actual)\n\t}\n}"}
{"input": "package service\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"go-common/app/admin/main/upload/model\"\n\n\t\"github.com/pkg/errors\"\n)\n\n\n\n\nfunc (s *Service) UploadAdminRecord(ctx context.Context, action string, up *model.UploadParam, data []byte) (result *model.UploadResult, err error) ", "output": "{\n\tvar (\n\t\tlocation, etag string\n\t\tb              *model.Bucket\n\t\tok             bool\n\t)\n\tif b, ok = s.bucketCache[up.Bucket]; !ok {\n\t\terr = errors.Errorf(\"read bucket items failed: (%s)\", up.Bucket)\n\t\treturn\n\t}\n\tup.Auth = s.dao.Bfs.Authorize(b.KeyID, b.KeySecret, http.MethodPut, up.Bucket, up.FileName, time.Now().Unix())\n\tif up.ContentType == \"\" {\n\t\tup.ContentType = http.DetectContentType(data)\n\t}\n\tif location, etag, err = s.dao.Bfs.Upload(ctx, up, data); err != nil {\n\t\treturn\n\t}\n\tresult = &model.UploadResult{\n\t\tLocation: location,\n\t\tEtag:     etag,\n\t}\n\treturn\n}"}
{"input": "package lib\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"time\"\n)\n\nfunc BytesToUint32(data []byte) (uint32, bool) {\n\tif len(data) != 4 {\n\t\treturn 0, false\n\t}\n\treturn binary.LittleEndian.Uint32(data), true\n}\n\nfunc Uin32ToBytes(number uint32) (ret_data []byte) {\n\tret_data = make([]byte, 4)\n\tbinary.LittleEndian.PutUint32(ret_data, number)\n\treturn ret_data\n}\n\nfunc CalcPocketCount(length, pocket_length uint32) uint32 {\n\treturn ((length / pocket_length) + 1)\n}\n\n\nfunc Log(message string) {\n\tfmt.Println(message)\n}\n\nfunc CombineBytesMap(data map[uint32][]byte) (ret_data []byte) {\n\tvar keys []int\n\tfor k, _ := range data {\n\t\tkeys = append(keys, int(k))\n\t}\n\tsort.Ints(keys)\n\tfor _, k := range keys {\n\t\tret_data = append(ret_data, data[uint32(k)]...)\n\t}\n\treturn\n}\n\n\n\n\nfunc FakeData(count int) []byte {\n\tret_data := make([]byte, count)\n\tfor i := 0; i < count; i++ {\n\t\tret_data[i] = byte(15) \n\t}\n\treturn ret_data\n}\n\nfunc Random(min, max int) uint32 ", "output": "{\n\trand.Seed(time.Now().UnixNano())\n\treturn uint32(rand.Intn(max-min) + min)\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/go-kit/kit/metrics\"\n\tkitprometheus \"github.com/go-kit/kit/metrics/prometheus\"\n\t\"time\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"fmt\"\n)\n\n\nvar requestCount metrics.Counter\nvar requestLatency metrics.Histogram\n\nfunc init(){\n\tfieldKeys := []string{\"method\", \"error\",\"release\"}\n\n\trequestCount = kitprometheus.NewCounterFrom(prometheus.CounterOpts{\n\t\tNamespace: \"runyontr\",\n\t\tSubsystem: \"appinfo_service\",\n\t\tName:      \"request_count\",\n\t\tHelp:      \"Number of requests received.\",\n\t}, fieldKeys)\n\trequestLatency = kitprometheus.NewSummaryFrom(prometheus.SummaryOpts{\n\t\tNamespace: \"runyontr\",\n\t\tSubsystem: \"appinfo_service\",\n\t\tName:      \"request_latency_microseconds\",\n\t\tHelp:      \"Total duration of requests in microseconds.\",\n\t}, fieldKeys)\n}\n\n\n\ntype instrumentationAppInfo struct{\n\n\trequestCount   metrics.Counter\n\trequestLatency metrics.Histogram\n\tNext AppInfoService\n}\n\n\n\n\n\n\n\nfunc (s *instrumentationAppInfo) GetAppInfo() (info AppInfo, err error) {\n\tdefer func(startTime time.Time){\n\t\trequestCount.With(\"release\",info.Release, \"method\",\"GetAppInfo\",\"error\",fmt.Sprintf(\"%v\",err)).Add(1)\n\t\trequestLatency.With(\"release\",info.Release, \"method\",\"GetAppInfo\",\"error\",fmt.Sprintf(\"%v\",err)).Observe(float64(time.Since(startTime)))\n\t}(time.Now())\n\tinfo, err = s.Next.GetAppInfo()\n\treturn\n}\n\nfunc NewInstrumentationAppInfoService(svc AppInfoService) AppInfoService", "output": "{\n\n\treturn &instrumentationAppInfo{\n\t\tNext: svc,\n\t\trequestCount: requestCount,\n\t\trequestLatency: requestLatency,\n\t}\n}"}
{"input": "package backend\n\nimport (\n\t\"time\"\n)\n\ntype VmConfig struct {\n\tGpuCount int64  `json:\"gpu_count\"`\n\tGpuType  string `json:\"gpu_type\"`\n\tZone     string `json:\"zone\"`\n}\n\n\n\ntype StartAttributes struct {\n\tLanguage  string `json:\"language\"`\n\tOsxImage  string `json:\"osx_image\"`\n\tDist      string `json:\"dist\"`\n\tArch      string `json:\"arch\"`\n\tGroup     string `json:\"group\"`\n\tOS        string `json:\"os\"`\n\tImageName string `json:\"image_name\"`\n\n\tVMType string `json:\"-\"`\n\n\tVMConfig VmConfig `json:\"-\"`\n\n\n\tVMSize string `json:\"-\"`\n\n\n\tWarmer bool `json:\"-\"`\n\n\tHardTimeout time.Duration `json:\"-\"`\n\n\tProgressType string `json:\"-\"`\n}\n\n\n\n\nfunc (sa *StartAttributes) SetDefaults(lang, dist, arch, group, os, vmType string, vmConfig VmConfig) ", "output": "{\n\tif sa.Language == \"\" {\n\t\tsa.Language = lang\n\t}\n\n\tif sa.Dist == \"\" {\n\t\tsa.Dist = dist\n\t}\n\n\tif sa.Arch == \"\" {\n\t\tsa.Arch = arch\n\t}\n\n\tif sa.Group == \"\" {\n\t\tsa.Group = group\n\t}\n\n\tif sa.OS == \"\" {\n\t\tsa.OS = os\n\t}\n\n\tif sa.VMType == \"\" {\n\t\tsa.VMType = vmType\n\t}\n\n\tif sa.VMConfig.GpuCount == 0 {\n\t\tsa.VMConfig.GpuCount = vmConfig.GpuCount\n\t}\n\n\tif sa.VMConfig.GpuType == \"\" {\n\t\tsa.VMConfig.GpuType = vmConfig.GpuType\n\t}\n\n\tif sa.VMConfig.Zone == \"\" {\n\t\tsa.VMConfig.Zone = vmConfig.Zone\n\t}\n}"}
{"input": "package rule\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/mgechev/revive/lint\"\n)\n\n\ntype ImportsBlacklistRule struct {\n\tblacklist map[string]bool\n}\n\n\nfunc (r *ImportsBlacklistRule) Apply(file *lint.File, arguments lint.Arguments) []lint.Failure {\n\tvar failures []lint.Failure\n\n\tif file.IsTest() {\n\t\treturn failures \n\t}\n\n\tif r.blacklist == nil {\n\t\tr.blacklist = make(map[string]bool, len(arguments))\n\n\t\tfor _, arg := range arguments {\n\t\t\targStr, ok := arg.(string)\n\t\t\tif !ok {\n\t\t\t\tpanic(fmt.Sprintf(\"Invalid argument to the imports-blacklist rule. Expecting a string, got %T\", arg))\n\t\t\t}\n\t\t\tif len(argStr) > 2 && argStr[0] != '\"' && argStr[len(argStr)-1] != '\"' {\n\t\t\t\targStr = fmt.Sprintf(`%q`, argStr)\n\t\t\t}\n\t\t\tr.blacklist[argStr] = true\n\t\t}\n\t}\n\n\tfor _, is := range file.AST.Imports {\n\t\tpath := is.Path\n\t\tif path != nil && r.blacklist[path.Value] {\n\t\t\tfailures = append(failures, lint.Failure{\n\t\t\t\tConfidence: 1,\n\t\t\t\tFailure:    \"should not use the following blacklisted import: \" + path.Value,\n\t\t\t\tNode:       is,\n\t\t\t\tCategory:   \"imports\",\n\t\t\t})\n\t\t}\n\t}\n\n\treturn failures\n}\n\n\n\n\nfunc (r *ImportsBlacklistRule) Name() string ", "output": "{\n\treturn \"imports-blacklist\"\n}"}
{"input": "package api\n\nimport (\n\t\"errors\"\n\t\"os/user\"\n)\n\nconst (\n\tcountOfColumnsInGroup = 3\n\n\tnameColumnNumberInGroup = 0\n\n\tpasswordFlagColumnNumberInGroup = 1\n\n\tgidColumnNumberInGroup = 2\n\n\tusersColumnNumberInGroup = 3\n)\n\nfunc (linux *Linux) groupLookup(groupName string) (*user.Group, error) {\n\tgroupInfo, err := linux.getEntity(\"group\", groupName)\n\n\tif err != nil {\n\t\treturn nil, user.UnknownGroupError(groupName)\n\t}\n\n\tif len(groupInfo) < countOfColumnsInGroup {\n\t\treturn nil, errors.New(\"Wrong format of /etc/group\")\n\t}\n\n\tgroup := user.Group{\n\t\tGid:  groupInfo[gidColumnNumberInGroup],\n\t\tName: groupInfo[nameColumnNumberInGroup],\n\t}\n\n\treturn &group, err\n}\n\n\n\n\nfunc (linux *Linux) GroupExists(groupName string) bool {\n\tgroup, _ := linux.groupLookup(groupName)\n\treturn group != nil\n}\n\nfunc (linux *Linux) groupExistsByID(groupID string) bool {\n\tgroup, _ := linux.groupLookupByID(groupID)\n\treturn group != nil\n}\n\nfunc (linux *Linux) groupLookupByID(groupID string) (*user.Group, error) ", "output": "{\n\tgroupInfo, err := linux.getEntity(\"group\", groupID)\n\n\tif err != nil {\n\t\treturn nil, user.UnknownGroupIdError(groupID)\n\t}\n\n\tif len(groupInfo) < countOfColumnsInGroup {\n\t\treturn nil, errors.New(\"Wrong format of /etc/group\")\n\t}\n\n\tgroup := user.Group{\n\t\tGid:  groupInfo[gidColumnNumberInGroup],\n\t\tName: groupInfo[nameColumnNumberInGroup],\n\t}\n\n\treturn &group, err\n}"}
{"input": "package model\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/huaweicloud/huaweicloud-sdk-go-v3/core/utils\"\n\n\t\"errors\"\n\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/huaweicloud/huaweicloud-sdk-go-v3/core/converter\"\n\n\t\"strings\"\n)\n\n\ntype BatchRebootSeversOption struct {\n\n\tServers []ServerId `json:\"servers\"`\n\n\tType BatchRebootSeversOptionType `json:\"type\"`\n}\n\n\n\ntype BatchRebootSeversOptionType struct {\n\tvalue string\n}\n\ntype BatchRebootSeversOptionTypeEnum struct {\n\tSOFT BatchRebootSeversOptionType\n\tHARD BatchRebootSeversOptionType\n}\n\nfunc GetBatchRebootSeversOptionTypeEnum() BatchRebootSeversOptionTypeEnum {\n\treturn BatchRebootSeversOptionTypeEnum{\n\t\tSOFT: BatchRebootSeversOptionType{\n\t\t\tvalue: \"SOFT\",\n\t\t},\n\t\tHARD: BatchRebootSeversOptionType{\n\t\t\tvalue: \"HARD\",\n\t\t},\n\t}\n}\n\nfunc (c BatchRebootSeversOptionType) MarshalJSON() ([]byte, error) {\n\treturn utils.Marshal(c.value)\n}\n\nfunc (c *BatchRebootSeversOptionType) UnmarshalJSON(b []byte) error {\n\tmyConverter := converter.StringConverterFactory(\"string\")\n\tif myConverter != nil {\n\t\tval, err := myConverter.CovertStringToInterface(strings.Trim(string(b[:]), \"\\\"\"))\n\t\tif err == nil {\n\t\t\tc.value = val.(string)\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t} else {\n\t\treturn errors.New(\"convert enum data to string error\")\n\t}\n}\n\nfunc (o BatchRebootSeversOption) String() string ", "output": "{\n\tdata, err := utils.Marshal(o)\n\tif err != nil {\n\t\treturn \"BatchRebootSeversOption struct{}\"\n\t}\n\n\treturn strings.Join([]string{\"BatchRebootSeversOption\", string(data)}, \" \")\n}"}
{"input": "package jack\n\nimport \"C\"\nimport \"unsafe\"\n\ntype ProcessCallback func(uint32) int\ntype BufferSizeCallback func(uint32) int\ntype SampleRateCallback func(uint32) int\ntype PortRegistrationCallback func(PortId, bool)\ntype PortRenameCallback func(PortId, string, string) int\ntype PortConnectCallback func(PortId, PortId, bool)\ntype ShutdownCallback func()\n\n\nfunc goProcess(nframes uint, wrapper unsafe.Pointer) int {\n\tcallback := (*ProcessCallback)(wrapper)\n\treturn (*callback)(uint32(nframes))\n}\n\n\nfunc goBufferSize(nframes uint, wrapper unsafe.Pointer) int {\n\tcallback := (*BufferSizeCallback)(wrapper)\n\treturn (*callback)(uint32(nframes))\n}\n\n\nfunc goSampleRate(nframes uint, wrapper unsafe.Pointer) int {\n\tcallback := (*SampleRateCallback)(wrapper)\n\treturn (*callback)(uint32(nframes))\n}\n\n\n\n\n\nfunc goPortRename(port uint, oldName, newName *C.char, wrapper unsafe.Pointer) int {\n\tcallback := (*PortRenameCallback)(wrapper)\n\treturn (*callback)(PortId(port), C.GoString(oldName), C.GoString(newName))\n}\n\n\nfunc goPortConnect(aport, bport uint, connect int, wrapper unsafe.Pointer) {\n\tcallback := (*PortConnectCallback)(wrapper)\n\t(*callback)(PortId(aport), PortId(bport), connect != 0)\n}\n\n\nfunc goShutdown(wrapper unsafe.Pointer) {\n\tcallback := (*ShutdownCallback)(wrapper)\n\t(*callback)()\n}\n\nfunc goPortRegistration(port uint, register int, wrapper unsafe.Pointer) ", "output": "{\n\tcallback := (*PortRegistrationCallback)(wrapper)\n\t(*callback)(PortId(port), register != 0)\n}"}
{"input": "package media\n\ntype FileContent struct {\n}\n\nfunc NewFileContent() *FileContent {\n\tfile := &FileContent{}\n\treturn file\n}\n\n\n\nfunc (self *FileContent) IsDirectory() bool ", "output": "{\n\treturn false\n}"}
{"input": "package utils\n\nfunc Bool(input bool) *bool {\n\treturn &input\n}\n\nfunc Int32(input int32) *int32 {\n\treturn &input\n}\n\n\n\nfunc String(input string) *string {\n\treturn &input\n}\n\nfunc Int64(input int64) *int64 ", "output": "{\n\treturn &input\n}"}
{"input": "package flotilla\n\nimport \"github.com/simulatedsimian/flotilla-go/dock\"\n\ntype Number struct {\n\tModuleCommon\n\n\tbuffer [4]int\n\tdirty  bool\n}\n\nfunc (m *Number) Type() dock.ModuleType {\n\treturn dock.Number\n}\n\nfunc (m *Number) Set(d *dock.Dock) error {\n\tif m.dirty && m.address != nil {\n\t\tm.dirty = false\n\t\treturn d.SetModuleData(m.address.channel, m.Type(),\n\t\t\tint(m.buffer[0]), int(m.buffer[1]), int(m.buffer[2]), int(m.buffer[3]), 0)\n\t}\n\treturn nil\n}\n\n\n\nfunc (m *Number) SetInteger(i int) ", "output": "{\n\tm.dirty = true\n\tif i > 9999 {\n\t\ti = 9999\n\t}\n\n\tm.buffer[3] = dock.GetDigitPattern(i%10, false)\n\ti = i / 10\n\tm.buffer[2] = dock.GetDigitPattern(i%10, false)\n\ti = i / 10\n\tm.buffer[1] = dock.GetDigitPattern(i%10, false)\n\ti = i / 10\n\tm.buffer[0] = dock.GetDigitPattern(i%10, false)\n}"}
{"input": "package grpc\n\nimport (\n\t\"github.com/micro/go-micro/v3/client\"\n)\n\ntype grpcEvent struct {\n\ttopic       string\n\tcontentType string\n\tpayload     interface{}\n}\n\nfunc newGRPCEvent(topic string, payload interface{}, contentType string, opts ...client.MessageOption) client.Message {\n\tvar options client.MessageOptions\n\tfor _, o := range opts {\n\t\to(&options)\n\t}\n\n\tif len(options.ContentType) > 0 {\n\t\tcontentType = options.ContentType\n\t}\n\n\treturn &grpcEvent{\n\t\tpayload:     payload,\n\t\ttopic:       topic,\n\t\tcontentType: contentType,\n\t}\n}\n\nfunc (g *grpcEvent) ContentType() string {\n\treturn g.contentType\n}\n\nfunc (g *grpcEvent) Topic() string {\n\treturn g.topic\n}\n\n\n\nfunc (g *grpcEvent) Payload() interface{} ", "output": "{\n\treturn g.payload\n}"}
{"input": "package recordio\n\nimport (\n\t\"bytes\"\n\t\"reflect\"\n\t\"testing\"\n)\n\n\n\nfunc TestEncodeDecode(t *testing.T) ", "output": "{\n\ttests := []struct {\n\t\tdata []byte\n\t}{\n\t\t{[]byte(\"someData\")},\n\t\t{[]byte(\"someOtherData\")},\n\t}\n\n\tfor i, tt := range tests {\n\t\tbuf := new(bytes.Buffer)\n\t\trecordToWrite := &Record{tt.data}\n\n\t\tif err := recordToWrite.encodeTo(buf); err != nil {\n\t\t\tt.Fatalf(\"#%d: cannot encode, err: %s\", i, err)\n\t\t}\n\t\trecordToRead := new(Record)\n\t\tif err := recordToRead.decodeFrom(buf); err != nil {\n\t\t\tt.Fatalf(\"#%d: cannot decode, err: %s\", i, err)\n\t\t}\n\t\tif !reflect.DeepEqual(recordToRead, recordToWrite) {\n\t\t\tt.Fatalf(\"#%d: records are not the same, want: %v, get: %v\",\n\t\t\t\ti, recordToWrite, recordToRead)\n\t\t}\n\t}\n}"}
{"input": "package maker\n\nimport \"cf/models\"\n\nvar routeSummaryGuid func() string\n\nfunc init() {\n\trouteSummaryGuid = guidGenerator(\"route-summary\")\n}\n\n\n\nfunc NewRouteSummary(overrides Overrides) (routeSummary models.RouteSummary) ", "output": "{\n\trouteSummary.Guid = routeSummaryGuid()\n\trouteSummary.Host = \"route-host\"\n\n\tif overrides.Has(\"guid\") {\n\t\trouteSummary.Guid = overrides.Get(\"guid\").(string)\n\t}\n\n\tif overrides.Has(\"host\") {\n\t\trouteSummary.Host = overrides.Get(\"host\").(string)\n\t}\n\n\treturn\n}"}
{"input": "package builtins\n\nimport (\n\t\"fmt\"\n)\n\ntype loadError struct {\n\tfilename  string\n\tcallstack string\n\tvalueStub\n}\n\nfunc NewLoadError(name string, callstack string) *loadError {\n\treturn &loadError{filename: name, callstack: callstack}\n}\n\n\n\nfunc (err *loadError) Error() string {\n\treturn fmt.Sprintf(\"LoadError: cannot load such file -- %s\\n%s\", err.filename, err.callstack)\n}\n\nfunc (err *loadError) String() string ", "output": "{\n\treturn \"LoadError\"\n}"}
{"input": "package oauth\n\nimport (\n\t\"github.com/RichardKnop/go-oauth2-server/config\"\n\t\"github.com/RichardKnop/go-oauth2-server/oauth/roles\"\n\t\"github.com/jinzhu/gorm\"\n)\n\n\ntype Service struct {\n\tcnf          *config.Config\n\tdb           *gorm.DB\n\tallowedRoles []string\n}\n\n\nfunc NewService(cnf *config.Config, db *gorm.DB) *Service {\n\treturn &Service{\n\t\tcnf:          cnf,\n\t\tdb:           db,\n\t\tallowedRoles: []string{roles.Superuser, roles.User},\n\t}\n}\n\n\nfunc (s *Service) GetConfig() *config.Config {\n\treturn s.cnf\n}\n\n\nfunc (s *Service) RestrictToRoles(allowedRoles ...string) {\n\ts.allowedRoles = allowedRoles\n}\n\n\n\n\n\nfunc (s *Service) Close() {}\n\nfunc (s *Service) IsRoleAllowed(role string) bool ", "output": "{\n\tfor _, allowedRole := range s.allowedRoles {\n\t\tif role == allowedRole {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"}
{"input": "package expression\n\nimport \"gopkg.in/sqle/sqle.v0/sql\"\n\ntype UnresolvedColumn struct {\n\tname string\n}\n\nfunc NewUnresolvedColumn(name string) *UnresolvedColumn {\n\treturn &UnresolvedColumn{name}\n}\n\nfunc (UnresolvedColumn) Resolved() bool {\n\treturn false\n}\n\nfunc (UnresolvedColumn) IsNullable() bool {\n\treturn true\n}\n\nfunc (UnresolvedColumn) Type() sql.Type {\n\treturn sql.String \n}\n\nfunc (c UnresolvedColumn) Name() string {\n\treturn c.name\n}\n\nfunc (UnresolvedColumn) Eval(r sql.Row) interface{} {\n\treturn \"FAIL\" \n}\n\nfunc (p *UnresolvedColumn) TransformUp(f func(sql.Expression) sql.Expression) sql.Expression {\n\tn := *p\n\treturn f(&n)\n}\n\ntype UnresolvedFunction struct {\n\tname        string\n\tIsAggregate bool\n\tChildren    []sql.Expression\n}\n\nfunc NewUnresolvedFunction(name string, agg bool,\n\tchildren ...sql.Expression) *UnresolvedFunction {\n\treturn &UnresolvedFunction{name, agg, children}\n}\n\nfunc (UnresolvedFunction) Resolved() bool {\n\treturn false\n}\n\nfunc (UnresolvedFunction) IsNullable() bool {\n\treturn true\n}\n\nfunc (UnresolvedFunction) Type() sql.Type {\n\treturn sql.String \n}\n\nfunc (c UnresolvedFunction) Name() string {\n\treturn c.name\n}\n\nfunc (UnresolvedFunction) Eval(r sql.Row) interface{} {\n\treturn \"FAIL\" \n}\n\n\n\nfunc (p *UnresolvedFunction) TransformUp(f func(sql.Expression) sql.Expression) sql.Expression ", "output": "{\n\tvar rc []sql.Expression\n\tfor _, c := range p.Children {\n\t\trc = append(rc, f(c))\n\t}\n\n\treturn f(NewUnresolvedFunction(p.name, p.IsAggregate, rc...))\n}"}
{"input": "package macvlan\n\nimport (\n\t\"testing\"\n\n\t\"github.com/docker/docker/pkg/plugingetter\"\n\t\"github.com/docker/libnetwork/driverapi\"\n\t_ \"github.com/docker/libnetwork/testutils\"\n)\n\nconst testNetworkType = \"macvlan\"\n\ntype driverTester struct {\n\tt *testing.T\n\td *driver\n}\n\nfunc (dt *driverTester) GetPluginGetter() plugingetter.PluginGetter {\n\treturn nil\n}\n\nfunc (dt *driverTester) RegisterDriver(name string, drv driverapi.Driver,\n\tcap driverapi.Capability) error {\n\tif name != testNetworkType {\n\t\tdt.t.Fatalf(\"Expected driver register name to be %q. Instead got %q\",\n\t\t\ttestNetworkType, name)\n\t}\n\n\tif _, ok := drv.(*driver); !ok {\n\t\tdt.t.Fatalf(\"Expected driver type to be %T. Instead got %T\",\n\t\t\t&driver{}, drv)\n\t}\n\n\tdt.d = drv.(*driver)\n\treturn nil\n}\n\nfunc TestMacvlanInit(t *testing.T) {\n\tif err := Init(&driverTester{t: t}, nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestMacvlanNilConfig(t *testing.T) {\n\tdt := &driverTester{t: t}\n\tif err := Init(dt, nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := dt.d.initStore(nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n\n\nfunc TestMacvlanType(t *testing.T) ", "output": "{\n\tdt := &driverTester{t: t}\n\tif err := Init(dt, nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif dt.d.Type() != testNetworkType {\n\t\tt.Fatalf(\"Expected Type() to return %q. Instead got %q\", testNetworkType,\n\t\t\tdt.d.Type())\n\t}\n}"}
{"input": "package test\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestUncurry2(t *testing.T) {\n\tcurried := deriveCurryMarshal(json.Unmarshal)\n\tuncurried := deriveUncurryMarshal(curried)\n\tgot := \"\"\n\twant := `string`\n\tif err := uncurried([]byte(`\"`+want+`\"`), &got); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Fatalf(\"got %s != want %s\", got, want)\n\t}\n}\n\n\n\nfunc TestUncurryCurried(t *testing.T) {\n\tf := func(a int, b string, c bool) string {\n\t\treturn fmt.Sprintf(\"%d%s%v\", a, b, c)\n\t}\n\tcurried := deriveCurry3(f)\n\twant := `1atrue`\n\tgotcurried := curried(1)\n\tcurrycurried := deriveCurryCurried(gotcurried)\n\tuncurried := deriveUncurryCurried(currycurried)\n\tgot := uncurried(\"a\", true)\n\tif got != want {\n\t\tt.Fatalf(\"got %s != want %s\", got, want)\n\t}\n}\n\nfunc TestUncurryBlankIdentifier(t *testing.T) {\n\tcurried := func(_ string) func(_ bool, c int) string {\n\t\treturn func(_ bool, c int) string {\n\t\t\treturn \"ature1\"\n\t\t}\n\t}\n\tuncurried := deriveUncurryBlankIdentifier(curried)\n\twant := `ature1`\n\tgot := uncurried(\"z\", false, 0)\n\tif got != want {\n\t\tt.Fatalf(\"got %s != want %s\", got, want)\n\t}\n}\n\nfunc TestUncurry3(t *testing.T) ", "output": "{\n\tf := func(a int, b string, c bool) string {\n\t\treturn fmt.Sprintf(\"%d%s%v\", a, b, c)\n\t}\n\tcurried := deriveCurry3(f)\n\tuncurried := deriveUncurry3(curried)\n\twant := `1atrue`\n\tgot := uncurried(1, \"a\", true)\n\tif got != want {\n\t\tt.Fatalf(\"got %s != want %s\", got, want)\n\t}\n}"}
{"input": "package generic\n\nimport (\n\t\"github.com/actgardner/gogen-avro/v8/schema\"\n\t\"github.com/actgardner/gogen-avro/v8/vm/types\"\n)\n\ntype recordDatum struct {\n\tdef    *schema.RecordDefinition\n\tfields []Datum\n}\n\nfunc newRecordDatum(def *schema.RecordDefinition) *recordDatum {\n\treturn &recordDatum{\n\t\tdef:    def,\n\t\tfields: make([]Datum, len(def.Fields())),\n\t}\n}\n\n\n\nfunc (r *recordDatum) SetBoolean(v bool)   { panic(\"\") }\nfunc (r *recordDatum) SetInt(v int32)      { panic(\"\") }\nfunc (r *recordDatum) SetLong(v int64)     { panic(\"\") }\nfunc (r *recordDatum) SetFloat(v float32)  { panic(\"\") }\nfunc (r *recordDatum) SetDouble(v float64) { panic(\"\") }\nfunc (r *recordDatum) SetBytes(v []byte)   { panic(\"\") }\nfunc (r *recordDatum) SetString(v string)  { panic(\"\") }\nfunc (r *recordDatum) Get(i int) types.Field {\n\tfield := r.def.Fields()[i]\n\tr.fields[i] = DatumForType(field.Type())\n\treturn r.fields[i]\n}\nfunc (r *recordDatum) SetDefault(i int) {\n\tfield := r.def.Fields()[i]\n\tr.fields[i] = &primitiveDatum{field.Default()}\n}\nfunc (r *recordDatum) AppendMap(key string) types.Field { panic(\"\") }\nfunc (r *recordDatum) AppendArray() types.Field         { panic(\"\") }\nfunc (r *recordDatum) NullField(t int) {\n\tr.fields[t] = &primitiveDatum{nil}\n}\nfunc (r *recordDatum) Finalize() {}\n\nfunc (r *recordDatum) Datum() interface{} ", "output": "{\n\tm := make(map[string]interface{})\n\tfor i, f := range r.def.Fields() {\n\t\tm[f.Name()] = r.fields[i].Datum()\n\t}\n\treturn m\n}"}
{"input": "package aesample\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/mzimmerman/aesample/subpkga\"\n\t\"github.com/mzimmerman/aesample/util\"\n)\n\n\n\nfunc root(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprint(w, \"Hello, you've reached aesample, the root package does nothing\")\n}\n\nfunc init() ", "output": "{\n\thttp.HandleFunc(\"/\", root)\n\thttp.HandleFunc(\"/subpkga\", subpkga.Root)\n\tutil.Log(\"aesample init()\")\n}"}
{"input": "package k8sclient\n\nimport (\n\t\"fmt\"\n\n\tapiv1 \"k8s.io/client-go/pkg/api/v1\"\n)\n\nvar _ = K8sClient(&MockK8sClient{})\n\n\ntype MockK8sClient struct {\n\tNumOfNodes    int\n\tNumOfCores    int\n\tNumOfReplicas int\n\tConfigMap     *apiv1.ConfigMap\n}\n\n\nfunc (k *MockK8sClient) FetchConfigMap(namespace, configmap string) (*apiv1.ConfigMap, error) {\n\tif k.ConfigMap.ObjectMeta.ResourceVersion == \"\" {\n\t\treturn nil, fmt.Errorf(\"config map not exist\")\n\t}\n\treturn k.ConfigMap, nil\n}\n\n\nfunc (k *MockK8sClient) CreateConfigMap(namespace, configmap string, params map[string]string) (*apiv1.ConfigMap, error) {\n\treturn nil, nil\n}\n\n\n\n\n\nfunc (k *MockK8sClient) GetClusterStatus() (*ClusterStatus, error) {\n\treturn &ClusterStatus{int32(k.NumOfNodes), int32(k.NumOfNodes), int32(k.NumOfCores), int32(k.NumOfCores)}, nil\n}\n\n\nfunc (k *MockK8sClient) GetNamespace() string {\n\treturn \"\"\n}\n\n\nfunc (k *MockK8sClient) UpdateReplicas(expReplicas int32) (int32, error) {\n\tprevReplicas := int32(k.NumOfReplicas)\n\tk.NumOfReplicas = int(expReplicas)\n\treturn prevReplicas, nil\n}\n\nfunc (k *MockK8sClient) UpdateConfigMap(namespace, configmap string, params map[string]string) (*apiv1.ConfigMap, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "package systemd\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"strings\"\n\n\t\"github.com/golang/glog\"\n)\n\n\n\n\nfunc escapeArg(s string) string {\n\tvar b bytes.Buffer\n\n\tneedQuotes := false\n\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\n\t\tif ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') {\n\t\t\tb.WriteByte(c)\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch c {\n\t\tcase '!', '#', '$', '%', '&', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';',\n\t\t\t'<', '>', '=', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~':\n\t\t\tb.WriteByte(c)\n\n\t\tcase ' ':\n\t\t\tneedQuotes = true\n\t\t\tb.WriteByte(c)\n\n\t\tcase '\"':\n\t\t\tb.WriteString(\"\\\\\\\"\")\n\t\tcase '\\'':\n\t\t\tb.WriteString(\"\\\\'\")\n\t\tcase '\\\\':\n\t\t\tb.WriteString(\"\\\\\\\\\")\n\n\t\tdefault:\n\t\t\tglog.Warningf(\"Unusual character in systemd command: %v\", s)\n\t\t\tb.WriteString(\"\\\\x\")\n\t\t\tb.WriteString(hex.EncodeToString([]byte{c}))\n\t\t}\n\t}\n\n\tif needQuotes {\n\t\treturn \"\\\"\" + b.String() + \"\\\"\"\n\t}\n\n\treturn b.String()\n}\n\nfunc EscapeCommand(argv []string) string ", "output": "{\n\tvar escaped []string\n\tfor _, arg := range argv {\n\t\tescaped = append(escaped, escapeArg(arg))\n\t}\n\treturn strings.Join(escaped, \" \")\n}"}
{"input": "package gozzle\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestQuerySorted(t *testing.T) {\n\tp := \"/\"\n\tr1 := request{\n\t\tpath: p,\n\t\tquery: map[string]string{\n\t\t\t\"2\": \"b\",\n\t\t\t\"1\": \"a\",\n\t\t\t\"3\": \"c\",\n\t\t\t\"5\": \"e\",\n\t\t\t\"4\": \"d\",\n\t\t},\n\t}\n\tr2 := request{}\n\n\tassert.Equal(t, \"/?1=a&2=b&3=c&4=d&5=e\", r1.FullPath())\n\tassert.Empty(t, r2.FullPath())\n}\n\n\n\nfunc TestQueryEncoding(t *testing.T) ", "output": "{\n\tr1 := request{\n\t\tquery: map[string]string{\n\t\t\t\"a\":     \"b\",\n\t\t\t\"ké@lù\": \"ùl@ék\",\n\t\t},\n\t}\n\tr2 := request{}\n\n\tassert.Equal(t, \"?a=b&k%C3%A9%40l%C3%B9=%C3%B9l%40%C3%A9k\", r1.FullPath())\n\tassert.Empty(t, r2.FullPath())\n}"}
{"input": "package logr\n\nimport \"github.com/wiggin77/merror\"\n\n\ntype timeoutError struct {\n\ttext string\n}\n\n\nfunc newTimeoutError(text string) timeoutError {\n\treturn timeoutError{text: text}\n}\n\n\nfunc IsTimeoutError(err error) bool {\n\tif _, ok := err.(timeoutError); ok {\n\t\treturn true\n\t}\n\tif merr, ok := err.(*merror.MError); ok {\n\t\tfor _, e := range merr.Errors() {\n\t\t\tif IsTimeoutError(e) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n\n\nfunc (err timeoutError) Error() string ", "output": "{\n\treturn err.text\n}"}
{"input": "package core\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/oci/oci-go-sdk/v43/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetServiceRequest struct {\n\n\tServiceId *string `mandatory:\"true\" contributesTo:\"path\" name:\"serviceId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetServiceRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request GetServiceRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request GetServiceRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request GetServiceRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetServiceResponse struct {\n\n\tRawResponse *http.Response\n\n\tService `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\n\n\n\nfunc (response GetServiceResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response GetServiceResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package credentials\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype stubProvider struct {\n\tcreds Value\n\terr   error\n}\n\nfunc (s *stubProvider) Retrieve() (Value, error) {\n\ts.creds.ProviderName = \"stubProvider\"\n\treturn s.creds, s.err\n}\n\nfunc TestCredentialsGet(t *testing.T) {\n\tc := NewCredentials(&stubProvider{\n\t\tcreds: Value{\n\t\t\tAccessKeyID:     \"AKID\",\n\t\t\tSecretAccessKey: \"SECRET\",\n\t\t},\n\t})\n\n\tcreds, err := c.Get()\n\tassert.Nil(t, err, \"Expected no error\")\n\tassert.Equal(t, \"AKID\", creds.AccessKeyID, \"Expect access key ID to match\")\n\tassert.Equal(t, \"SECRET\", creds.SecretAccessKey, \"Expect secret access key to match\")\n}\n\n\n\nfunc TestCredentialsGetWithProviderName(t *testing.T) {\n\tstub := &stubProvider{}\n\n\tc := NewCredentials(stub)\n\n\tcreds, err := c.Get()\n\tassert.Nil(t, err, \"Expected no error\")\n\tassert.Equal(t, creds.ProviderName, \"stubProvider\", \"Expected provider name to match\")\n}\n\nfunc TestCredentialsGetWithError(t *testing.T) ", "output": "{\n\tc := NewCredentials(&stubProvider{err: errors.New(\"provider error\")})\n\n\t_, err := c.Get()\n\tassert.Equal(t, \"provider error\", err.Error(), \"Expected provider error\")\n}"}
{"input": "package streaming\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype DeleteStreamPoolRequest struct {\n\n\tStreamPoolId *string `mandatory:\"true\" contributesTo:\"path\" name:\"streamPoolId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request DeleteStreamPoolRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request DeleteStreamPoolRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request DeleteStreamPoolRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request DeleteStreamPoolRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype DeleteStreamPoolResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response DeleteStreamPoolResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\n\n\nfunc (response DeleteStreamPoolResponse) HTTPResponse() *http.Response ", "output": "{\n\treturn response.RawResponse\n}"}
{"input": "package schema\n\nimport (\n\t\"entgo.io/ent\"\n\t\"entgo.io/ent/dialect/entsql\"\n\t\"entgo.io/ent/schema/edge\"\n\t\"entgo.io/ent/schema/field\"\n\t\"github.com/google/uuid\"\n)\n\n\ntype AuthUser struct {\n\tent.Schema\n}\n\n\n\n\n\nfunc (AuthUser) Edges() []ent.Edge {\n\treturn []ent.Edge{\n\t\tedge.To(\"AuthUserToToken\", Token.Type).\n\t\t\tAnnotations(entsql.Annotation{\n\t\t\t\tOnDelete: entsql.Cascade,\n\t\t\t}),\n\t\tedge.From(\"AuthUserToServerTasks\", ServerTask.Type).\n\t\t\tRef(\"ServerTaskToAuthUser\").\n\t\t\tAnnotations(entsql.Annotation{\n\t\t\t\tOnDelete: entsql.Cascade,\n\t\t\t}),\n\t}\n}\n\nfunc (AuthUser) Fields() []ent.Field ", "output": "{\n\treturn []ent.Field{\n\t\tfield.UUID(\"id\", uuid.UUID{}).\n\t\t\tDefault(uuid.New),\n\t\tfield.String(\"username\"),\n\t\tfield.String(\"password\").Sensitive(),\n\t\tfield.String(\"first_name\").Default(\"\"),\n\t\tfield.String(\"last_name\").Default(\"\"),\n\t\tfield.String(\"email\").Default(\"\"),\n\t\tfield.String(\"phone\").Default(\"\"),\n\t\tfield.String(\"company\").Default(\"\"),\n\t\tfield.String(\"occupation\").Default(\"\"),\n\t\tfield.String(\"private_key_path\").Default(\"\"),\n\t\tfield.Enum(\"role\").Values(\"USER\", \"ADMIN\"),\n\t\tfield.Enum(\"provider\").Values(\"LOCAL\", \"GITHUB\", \"OPENID\"),\n\t}\n}"}
{"input": "package admission\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"sync\"\n\n\t\"github.com/golang/glog\"\n\tclient \"k8s.io/kubernetes/pkg/client/unversioned\"\n)\n\n\n\n\n\ntype Factory func(client client.Interface, config io.Reader) (Interface, error)\n\n\nvar (\n\tpluginsMutex sync.Mutex\n\tplugins      = make(map[string]Factory)\n)\n\n\nfunc GetPlugins() []string {\n\tpluginsMutex.Lock()\n\tdefer pluginsMutex.Unlock()\n\tkeys := []string{}\n\tfor k := range plugins {\n\t\tkeys = append(keys, k)\n\t}\n\treturn keys\n}\n\n\n\nfunc RegisterPlugin(name string, plugin Factory) {\n\tpluginsMutex.Lock()\n\tdefer pluginsMutex.Unlock()\n\t_, found := plugins[name]\n\tif found {\n\t\tglog.Fatalf(\"Admission plugin %q was registered twice\", name)\n\t}\n\tglog.V(1).Infof(\"Registered admission plugin %q\", name)\n\tplugins[name] = plugin\n}\n\n\n\n\n\n\nfunc GetPlugin(name string, client client.Interface, config io.Reader) (Interface, error) {\n\tpluginsMutex.Lock()\n\tdefer pluginsMutex.Unlock()\n\tf, found := plugins[name]\n\tif !found {\n\t\treturn nil, nil\n\t}\n\treturn f(client, config)\n}\n\n\n\n\nfunc InitPlugin(name string, client client.Interface, configFilePath string) Interface ", "output": "{\n\tvar (\n\t\tconfig *os.File\n\t\terr    error\n\t)\n\n\tif name == \"\" {\n\t\tglog.Info(\"No admission plugin specified.\")\n\t\treturn nil\n\t}\n\n\tif configFilePath != \"\" {\n\t\tconfig, err = os.Open(configFilePath)\n\t\tif err != nil {\n\t\t\tglog.Fatalf(\"Couldn't open admission plugin configuration %s: %#v\",\n\t\t\t\tconfigFilePath, err)\n\t\t}\n\n\t\tdefer config.Close()\n\t}\n\n\tplugin, err := GetPlugin(name, client, config)\n\tif err != nil {\n\t\tglog.Fatalf(\"Couldn't init admission plugin %q: %v\", name, err)\n\t}\n\tif plugin == nil {\n\t\tglog.Fatalf(\"Unknown admission plugin: %s\", name)\n\t}\n\n\treturn plugin\n}"}
{"input": "package logger\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/influxdata/wlog\"\n)\n\n\nfunc newTelegrafWriter(w io.Writer) io.Writer {\n\treturn &telegrafLog{\n\t\twriter: wlog.NewWriter(w),\n\t}\n}\n\ntype telegrafLog struct {\n\twriter io.Writer\n}\n\n\n\n\n\n\n\n\n\nfunc SetupLogging(debug, quiet bool, logfile string) {\n\tif debug {\n\t\twlog.SetLevel(wlog.DEBUG)\n\t}\n\tif quiet {\n\t\twlog.SetLevel(wlog.ERROR)\n\t}\n\n\tvar oFile *os.File\n\tif logfile != \"\" {\n\t\tif _, err := os.Stat(logfile); os.IsNotExist(err) {\n\t\t\tif oFile, err = os.Create(logfile); err != nil {\n\t\t\t\tlog.Printf(\"E! Unable to create %s (%s), using stdout\", logfile, err)\n\t\t\t\toFile = os.Stdout\n\t\t\t}\n\t\t} else {\n\t\t\tif oFile, err = os.OpenFile(logfile, os.O_APPEND|os.O_WRONLY, os.ModeAppend); err != nil {\n\t\t\t\tlog.Printf(\"E! Unable to append to %s (%s), using stdout\", logfile, err)\n\t\t\t\toFile = os.Stdout\n\t\t\t}\n\t\t}\n\t} else {\n\t\toFile = os.Stdout\n\t}\n\n\tlog.SetOutput(newTelegrafWriter(oFile))\n}\n\nfunc (t *telegrafLog) Write(p []byte) (n int, err error) ", "output": "{\n\treturn t.writer.Write(p)\n}"}
{"input": "package storage\n\nimport (\n\t\"path/filepath\"\n\n\t\"github.com/mitchellh/go-homedir\"\n)\n\nfunc DefaultDirectory() string {\n\thome, _ := homedir.Dir()\n\treturn filepath.Join(home, \".dispatch\")\n}\n\ntype directory string\n\nfunc (d directory) Root() string {\n\treturn string(d)\n}\n\nfunc (d directory) LetsEncrypt() string {\n\treturn filepath.Join(d.Root(), \"letsencrypt\")\n}\n\nfunc (d directory) Users() string {\n\treturn filepath.Join(d.Root(), \"users\")\n}\n\nfunc (d directory) User(username string) string {\n\treturn filepath.Join(d.Users(), username)\n}\n\nfunc (d directory) Log(username string) string {\n\treturn filepath.Join(d.User(username), \"log\")\n}\n\nfunc (d directory) Index(username string) string {\n\treturn filepath.Join(d.User(username), \"index\")\n}\n\nfunc (d directory) Certificate(username string) string {\n\treturn filepath.Join(d.User(username), \"cert.pem\")\n}\n\nfunc (d directory) Key(username string) string {\n\treturn filepath.Join(d.User(username), \"key.pem\")\n}\n\nfunc (d directory) Config() string {\n\treturn filepath.Join(d.Root(), \"config.toml\")\n}\n\n\n\nfunc (d directory) Database() string ", "output": "{\n\treturn filepath.Join(d.Root(), \"dispatch.db\")\n}"}
{"input": "package builtinhelpers\n\nimport \"strconv\"\n\nfunc _() {\n\tvar x [1]struct{}\n\t_ = x[Unknown-0]\n\t_ = x[AnnotationsTransformer-1]\n\t_ = x[ConfigMapGenerator-2]\n\t_ = x[HashTransformer-3]\n\t_ = x[ImageTagTransformer-4]\n\t_ = x[LabelTransformer-5]\n\t_ = x[LegacyOrderTransformer-6]\n\t_ = x[NamespaceTransformer-7]\n\t_ = x[PatchJson6902Transformer-8]\n\t_ = x[PatchStrategicMergeTransformer-9]\n\t_ = x[PatchTransformer-10]\n\t_ = x[PrefixSuffixTransformer-11]\n\t_ = x[ReplicaCountTransformer-12]\n\t_ = x[SecretGenerator-13]\n\t_ = x[ValueAddTransformer-14]\n\t_ = x[HelmChartInflationGenerator-15]\n\t_ = x[ReplacementTransformer-16]\n}\n\nconst _BuiltinPluginType_name = \"UnknownAnnotationsTransformerConfigMapGeneratorHashTransformerImageTagTransformerLabelTransformerLegacyOrderTransformerNamespaceTransformerPatchJson6902TransformerPatchStrategicMergeTransformerPatchTransformerPrefixSuffixTransformerReplicaCountTransformerSecretGeneratorValueAddTransformerHelmChartInflationGeneratorReplacementTransformer\"\n\nvar _BuiltinPluginType_index = [...]uint16{0, 7, 29, 47, 62, 81, 97, 119, 139, 163, 193, 209, 232, 255, 270, 289, 316, 338}\n\n\n\nfunc (i BuiltinPluginType) String() string ", "output": "{\n\tif i < 0 || i >= BuiltinPluginType(len(_BuiltinPluginType_index)-1) {\n\t\treturn \"BuiltinPluginType(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n\treturn _BuiltinPluginType_name[_BuiltinPluginType_index[i]:_BuiltinPluginType_index[i+1]]\n}"}
{"input": "package client\n\nimport (\n\tatlantis \"atlantis/common\"\n\t. \"atlantis/manager/constant\"\n)\n\ntype ManagerRPCClient struct {\n\tatlantis.RPCClient\n\tUser    string\n\tSecrets map[string]string\n}\n\ntype AuthedArg interface {\n\tSetCredentials(string, string)\n}\n\nfunc (r *ManagerRPCClient) CallAuthed(name string, arg AuthedArg, reply interface{}) error {\n\treturn r.CallAuthedMulti(name, arg, 0, reply)\n}\n\nfunc (r *ManagerRPCClient) CallAuthedMulti(name string, arg AuthedArg, region int, reply interface{}) error {\n\targ.SetCredentials(r.User, r.Secrets[r.Opts[region].RPCHostAndPort()])\n\n\treturn r.RPCClient.CallMulti(name, arg, region, reply)\n}\n\nfunc NewManagerRPCClient(hostAndPort string) *atlantis.RPCClient {\n\treturn atlantis.NewRPCClient(hostAndPort, \"ManagerRPC\", ManagerRPCVersion, true)\n}\n\n\n\nfunc NewManagerRPCClientWithConfig(cfg []atlantis.RPCServerOpts) *atlantis.RPCClient ", "output": "{\n\treturn atlantis.NewMultiRPCClientWithConfig(cfg, \"ManagerRPC\", ManagerRPCVersion, true)\n}"}
{"input": "package marketplace\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype CreatePublicationRequest struct {\n\n\tCreatePublicationDetails `contributesTo:\"body\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request CreatePublicationRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request CreatePublicationRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request CreatePublicationRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype CreatePublicationResponse struct {\n\n\tRawResponse *http.Response\n\n\tPublication `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n}\n\nfunc (response CreatePublicationResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response CreatePublicationResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request CreatePublicationRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) ", "output": "{\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}"}
{"input": "package favorite\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"os\"\n\t\"testing\"\n\n\t\"go-common/app/interface/main/app-interface/conf\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nvar (\n\tdao *Dao\n)\n\nfunc TestMain(m *testing.M) {\n\tif os.Getenv(\"DEPLOY_ENV\") != \"\" {\n\t\tflag.Set(\"app_id\", \"main.app-svr.app-interface\")\n\t\tflag.Set(\"conf_token\", \"1mWvdEwZHmCYGoXJCVIdszBOPVdtpXb3\")\n\t\tflag.Set(\"tree_id\", \"2688\")\n\t\tflag.Set(\"conf_version\", \"docker-1\")\n\t\tflag.Set(\"deploy_env\", \"uat\")\n\t\tflag.Set(\"conf_host\", \"config.bilibili.co\")\n\t\tflag.Set(\"conf_path\", \"/tmp\")\n\t\tflag.Set(\"region\", \"sh\")\n\t\tflag.Set(\"zone\", \"sh001\")\n\t} else {\n\t\tflag.Set(\"conf\", \"../../cmd/app-interface-test.toml\")\n\t}\n\tflag.Parse()\n\tif err := conf.Init(); err != nil {\n\t\tpanic(err)\n\t}\n\tdao = New(conf.Conf)\n\tos.Exit(m.Run())\n}\n\n\n\nfunc TestDao_FolderVideo(t *testing.T) {\n\tConvey(\"folder video\", t, func() {\n\t\tgotFav, err := dao.FolderVideo(context.Background(), \"\", \"\", \"\", \"\", \"\", \"\", \"\", 0, 0, 1, 20, 1, 0, 1)\n\t\tSo(gotFav, ShouldNotBeEmpty)\n\t\tSo(err, ShouldBeNil)\n\t})\n}\n\nfunc TestDao_Folders(t *testing.T) ", "output": "{\n\tConvey(\"folder\", t, func() {\n\t\tgotFs, err := dao.Folders(context.Background(), 1, 1, \"android\", 0, true)\n\t\tSo(gotFs, ShouldNotBeEmpty)\n\t\tSo(err, ShouldBeNil)\n\t})\n}"}
{"input": "package iso20022\n\n\ntype PartyIdentification102Choice struct {\n\n\tAnyBIC *AnyBICIdentifier `xml:\"AnyBIC\"`\n\n\tNameAndAddress *NameAndAddress5 `xml:\"NmAndAdr\"`\n\n\tCountry *CountryCode `xml:\"Ctry\"`\n}\n\nfunc (p *PartyIdentification102Choice) SetAnyBIC(value string) {\n\tp.AnyBIC = (*AnyBICIdentifier)(&value)\n}\n\n\n\nfunc (p *PartyIdentification102Choice) SetCountry(value string) {\n\tp.Country = (*CountryCode)(&value)\n}\n\nfunc (p *PartyIdentification102Choice) AddNameAndAddress() *NameAndAddress5 ", "output": "{\n\tp.NameAndAddress = new(NameAndAddress5)\n\treturn p.NameAndAddress\n}"}
{"input": "package airac\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/jwkohnen/airac/proto\"\n)\n\n\n\nfunc TestProtoOverflow(t *testing.T) {\n\twant := AIRAC(0)\n\tp := proto.AiracMessage{Airac19010110: math.MaxUint16 + 1}\n\tgot := FromProto(p)\n\tif got != want {\n\t\tt.Errorf(\"Want %s, got %s\", want, got)\n\t}\n}\n\nfunc TestProto(t *testing.T) ", "output": "{\n\tfor want := AIRAC(0); want < FromStringMust(\"9213\"); want++ {\n\t\tp := want.Proto()\n\t\tgot := FromProto(p)\n\t\tif want != got {\n\t\t\tt.Errorf(\"Want %v, got %x\", want, got)\n\t\t}\n\t}\n}"}
{"input": "package config\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/BurntSushi/toml\"\n\n\t\"github.com/netrack/netrack/config/environment\"\n)\n\n\ntype Config struct {\n\tID string `toml:\"instance_id\"`\n\n\tOFPEndpoint string `toml:\"openflow_endpoint\"`\n\n\tAPIEndpoint string `toml:\"api_endpoint\"`\n\n\tTLSEnable             bool   `toml:\"tls_enable\"`\n\tTLSInsecureSkipVerify bool   `toml:\"tls_insecure_skip_verify\"`\n\tTLSCertFile           string `toml:\"tls_x509_cert_file\"`\n\tTLSKeyFile            string `toml:\"tls_x509_key_file\"`\n\n\tDatabase map[string]DatabaseConfig `toml:\"database\"`\n}\n\nfunc (c *Config) ConnString() string {\n\tdbconfig := c.Database[environment.Env]\n\treturn fmt.Sprintf(\"user=%s password=%s dbname=%s sslmode=%s\",\n\t\tdbconfig.User, dbconfig.Password, dbconfig.DBName, dbconfig.SSLMode)\n}\n\n\ntype DatabaseConfig struct {\n\tUser     string `toml:\"user\"`\n\tPassword string `toml:\"password\"`\n\tDBName   string `toml:\"dbname\"`\n\tSSLMode  string `toml:\"sslmode\"`\n}\n\n\n\nfunc LoadFile(configPath string) (*Config, error) ", "output": "{\n\tvar config Config\n\t_, err := toml.DecodeFile(configPath, &config)\n\treturn &config, err\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\n\t\"github.com/pihao/desktop500px/src/app\"\n\t\"github.com/pihao/desktop500px/src/px500\"\n)\n\nfunc main() {\n\ti, u, r, d, v := getFlag()\n\tapp.Debug = *d\n\n\tif *i {\n\t\tapp.Install()\n\t} else if *u {\n\t\tapp.Uninstall()\n\t} else if *r {\n\t\tapp.Reinstall()\n\t} else if *v {\n\t\tfmt.Println(app.VERSION)\n\t} else {\n\t\tpx500.Run()\n\t}\n}\n\n\n\nfunc getFlag() (i, u, r, d, v *bool) ", "output": "{\n\ti = flag.Bool(\"i\", false, \"install.\")\n\tu = flag.Bool(\"u\", false, \"uninstall.\")\n\tr = flag.Bool(\"r\", false, \"reinstall.\")\n\td = flag.Bool(\"d\", false, \"debug mode.\")\n\tv = flag.Bool(\"v\", false, \"show version.\")\n\tflag.Parse()\n\treturn i, u, r, d, v\n}"}
{"input": "package services\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n)\n\n\n\nfunc ReadJsonConfFileServiceTest(t *testing.T) ", "output": "{\n\n\tconfFilename := \"../testdata/fixtures/system.json\"\n\tf, _ := ReadJsonConfFileService(confFilename)\n\n\tif len(f.Files) < 1 {\n\t\tt.Fatal(\"no Files found in \" + confFilename)\n\t}\n\n\tvar actual string = \"\"\n\tfor i := 0; i < len(f.Files); i++ {\n\t\tactual = f.Files[i].Pattern\t\n\t\tbreak\n\t}\n\texpected := \"installed.*\"\n\n\tassert.Equal(t, expected, actual, \"unexpected config pattern\")\n\n}"}
{"input": "package main\n\n\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n\n\nfunc Mean(x []float64) float64 {\n\tsum := 0.0\n\tn := len(x)\n\tif n == 0 {\n\t\treturn sum\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tsum = sum + x[i]\n\t}\n\treturn sum / float64(n)\n}\n\n\n\n\n\n\nfunc Std(x []float64) float64 {\n\treturn math.Sqrt(Variance(x))\n}\n\nfunc main() {\n\tx := []float64{12, 65, 91, 52, 18, 72}\n\tfmt.Println(Std(x))\n}\n\nfunc Variance(x []float64) float64 ", "output": "{\n\tvariance := 0.0\n\tn := len(x)\n\tif n == 0 {\n\t\treturn variance\n\t}\n\tmean := Mean(x)\n\tfor i := 0; i < n; i++ {\n\t\tvariance += (x[i] - mean) * (x[i] - mean)\n\t}\n\treturn variance / float64(n)\n}"}
{"input": "package disjointset\n\nimport ()\n\ntype QuickUnion struct {\n\tdisjointset\n}\n\nfunc NewQuickUnion(N int) *QuickUnion {\n\tthis := &QuickUnion{}\n\tthis.UnionFind = this\n\tthis.Init(N)\n\treturn this\n}\n\n\n\nfunc (this *QuickUnion) Union(p, q int) {\n\tpRoot := this.Find(p)\n\tqRoot := this.Find(q)\n\n\tif pRoot == qRoot {\n\t\treturn\n\t}\n\n\tthis.id[pRoot] = qRoot\n\n\tthis.count--\n}\n\nfunc (this *QuickUnion) Find(p int) int ", "output": "{\n\tfor p != this.id[p] {\n\t\tp = this.id[p]\n\t}\n\treturn p\n}"}
{"input": "package graph\n\ntype vertexDistance struct {\n\tvertex   string\n\tdistance float64\n}\n\n\n\n\ntype vertexDistanceHeap []vertexDistance\n\nfunc (h vertexDistanceHeap) Len() int           { return len(h) }\nfunc (h vertexDistanceHeap) Less(i, j int) bool { return h[i].distance < h[j].distance } \nfunc (h vertexDistanceHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *vertexDistanceHeap) Push(x interface{}) {\n\t*h = append(*h, x.(vertexDistance))\n}\n\nfunc (h *vertexDistanceHeap) Pop() interface{} {\n\theapSize := len(*h)\n\tlastVertex := (*h)[heapSize-1]\n\t*h = (*h)[0 : heapSize-1]\n\treturn lastVertex\n}\n\n\n\nfunc (h *vertexDistanceHeap) updateDistance(vtx string, val float64) ", "output": "{\n\tfor i := 0; i < len(*h); i++ {\n\t\tif (*h)[i].vertex == vtx {\n\t\t\t(*h)[i].distance = val\n\t\t\tbreak\n\t\t}\n\t}\n}"}
{"input": "package monator\n\nimport (\n    \"time\"\n    \"bytes\"\n    \"encoding/json\"\n)\n\ntype CheckDuration time.Duration\n\nfunc (d CheckDuration) Hours() float64 {\n    return time.Duration(d).Hours()\n}\n\nfunc (d CheckDuration) Minutes() float64 {\n    return time.Duration(d).Minutes()\n}\n\n\n\nfunc (d CheckDuration) Seconds() float64 {\n    return time.Duration(d).Seconds()\n}\n\nfunc (d CheckDuration) Milliseconds() int64 {\n    return time.Duration(d).Nanoseconds() / int64(time.Millisecond)\n}\n\nfunc (d CheckDuration) String() string {\n    \n    rounded := ((time.Duration(d)).Nanoseconds() / int64(time.Millisecond)) * int64(time.Millisecond)\n    return time.Duration(rounded).String()\n}\n\n\nfunc (d *CheckDuration) UnmarshalJSON(data []byte) error {\n    b := bytes.NewBuffer(data)\n    dec := json.NewDecoder(b)\n\n    var s string\n\n    if err := dec.Decode(&s); err != nil {\n        return err\n    }\n    if duration, err := time.ParseDuration(s); err != nil {\n        return err\n    } else {\n        *d = CheckDuration(duration)\n    }\n\n    return nil\n}\n\nfunc (d CheckDuration) Nanoseconds() int64 ", "output": "{\n    return time.Duration(d).Nanoseconds()\n}"}
{"input": "package flavors\n\nimport (\n\t\"github.com/gophercloud/gophercloud\"\n)\n\nfunc getURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id)\n}\n\nfunc listURL(client *gophercloud.ServiceClient) string {\n\treturn client.ServiceURL(\"flavors\", \"detail\")\n}\n\nfunc createURL(client *gophercloud.ServiceClient) string {\n\treturn client.ServiceURL(\"flavors\")\n}\n\nfunc deleteURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id)\n}\n\n\n\nfunc accessActionURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"action\")\n}\n\nfunc extraSpecsListURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\")\n}\n\nfunc extraSpecsGetURL(client *gophercloud.ServiceClient, id, key string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\", key)\n}\n\nfunc extraSpecsCreateURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\")\n}\n\nfunc extraSpecUpdateURL(client *gophercloud.ServiceClient, id, key string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\", key)\n}\n\nfunc extraSpecDeleteURL(client *gophercloud.ServiceClient, id, key string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\", key)\n}\n\nfunc accessURL(client *gophercloud.ServiceClient, id string) string ", "output": "{\n\treturn client.ServiceURL(\"flavors\", id, \"os-flavor-access\")\n}"}
{"input": "package config\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n)\n\ntype Template struct {\n\tFile   string\n\tSource string\n}\n\n\n\n\n\nfunc (t Template) Validate() []error {\n\terrors := make([]error, 0, 2)\n\tif fi, err := os.Stat(t.Source); err != nil {\n\t\tvar msg string\n\t\tswitch {\n\t\tcase os.IsNotExist(err):\n\t\t\tmsg = fmt.Sprintf(\"template source not found: %s\", t.Source)\n\t\tcase os.IsPermission(err):\n\t\t\tmsg = fmt.Sprintf(\"template source permission denied: %s\", t.Source)\n\t\tdefault:\n\t\t\tmsg = fmt.Sprintf(\"template source error: %s: %s\", err, t.Source)\n\t\t}\n\t\terrors = append(errors, ValidationError(msg))\n\t} else if !fi.Mode().IsRegular() {\n\t\tmsg := fmt.Sprintf(\"template source is not a file: %s\", t.Source)\n\t\terrors = append(errors, ValidationError(msg))\n\t}\n\n\tdir := path.Dir(t.File)\n\tif fi, err := os.Stat(dir); err != nil {\n\t\tvar msg string\n\t\tswitch {\n\t\tcase os.IsNotExist(err):\n\t\t\tmsg = fmt.Sprintf(\"template file directory not found: %s\", t.File)\n\t\tcase os.IsPermission(err):\n\t\t\tmsg = fmt.Sprintf(\"template file directory permission denied: %s\", t.File)\n\t\tdefault:\n\t\t\tmsg = fmt.Sprintf(\"template file directory error: %s: %s\", err, t.File)\n\t\t}\n\t\terrors = append(errors, ValidationError(msg))\n\t} else if !fi.Mode().IsDir() {\n\t\tmsg := fmt.Sprintf(\"template file directory is not a directory: %s\", t.File)\n\t\terrors = append(errors, ValidationError(msg))\n\t}\n\treturn errors\n}\n\nfunc (t *Template) SetYAML(tag string, value interface{}) bool ", "output": "{\n\tAssertIsMap(\"template\", value)\n\tfor file, source := range value.(map[interface{}](interface{})) {\n\t\tAssertIsString(\"file\", file)\n\t\tAssertIsString(\"source\", source)\n\t\tt.File = file.(string)\n\t\tt.Source = source.(string)\n\t\treturn true\n\t}\n\tpanic(ParseError(fmt.Sprintf(`config template %+v cannot be parsed`, value)))\n}"}
{"input": "package byteset\n\n\n\n\n\n\n\n\n\nfunc And(ms ...Matcher) Matcher {\n\tl := make([]Matcher, len(ms))\n\tcopy(l, ms)\n\treturn &mIntersection{List: l}\n}\n\ntype mIntersection struct {\n\tList []Matcher\n}\n\nvar _ Matcher = (*mIntersection)(nil)\n\n\n\nfunc (m *mIntersection) ForEach(f func(b byte)) {\n\tif len(m.List) == 0 {\n\t\tforEachByte(0, 255, f)\n\t\treturn\n\t}\n\tfirst := m.List[0]\n\trest := m.List[1:]\n\tfirst.ForEach(func(b byte) {\n\t\tfor _, sub := range rest {\n\t\t\tif !sub.Match(b) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tf(b)\n\t})\n}\n\nfunc (m *mIntersection) Optimize() Matcher {\n\tif len(m.List) == 0 {\n\t\treturn All()\n\t}\n\tif len(m.List) == 1 {\n\t\treturn m.List[0].Optimize()\n\t}\n\treturn asDense(m).Optimize()\n}\n\nfunc (m *mIntersection) String() string {\n\treturn genericString(m)\n}\n\nfunc (m *mIntersection) Match(b byte) bool ", "output": "{\n\tfor _, sub := range m.List {\n\t\tif !sub.Match(b) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"input": "package questions\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n)\n\n\ntype Questions []Question\n\n\ntype Question struct {\n\tID     string `json:\"id\"`\n\tTitle  string `json:\"title\"`\n\tAnswer string `json:\"answer\"`\n}\n\n\n\nfunc (qs *Questions) LoadFromFile(path string) error {\n\n\tconfigFile, err := os.Open(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error opening questions file: %v\", err.Error())\n\t}\n\n\tjsonParser := json.NewDecoder(configFile)\n\tif err = jsonParser.Decode(qs); err != nil {\n\t\treturn fmt.Errorf(\"Error parsing questions file: %v\", err.Error())\n\t}\n\treturn nil\n}\n\nfunc (qs Questions) GetRandomQuestion() (Question, error) ", "output": "{\n\tsize := len(qs)\n\tif size <= 0 {\n\t\treturn Question{}, errors.New(\"No questions found.\")\n\t}\n\tindex := rand.Intn(size)\n\treturn qs[index], nil\n\n}"}
{"input": "package fileapp\n\nimport (\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"os/exec\"\n)\n\nconst (\n\tgvimCmd = \"gvim\"\n)\n\n\n\ntype GVim struct {\n}\n\nfunc NewGVim() *GVim {\n\treturn &GVim{}\n}\n\nfunc (a *GVim) getInfo() FileAppInfo {\n\treturn FileAppInfo{\n\t\tID:   \"gvim\",\n\t\tName: \"GVim\",\n\t}\n}\n\nfunc (a *GVim) open(path string) int {\n\tlog.WithFields(log.Fields{\n\t\t\"path\": path,\n\t}).Info(\"GVim: open\")\n\n\tout, err := exec.Command(gvimCmd, \"-p\", \"--remote-tab-silent\", path).Output()\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\n\t\t\t\"err\": err,\n\t\t}).Error(\"GVim open error\")\n\t\treturn -1\n\t}\n\tlog.WithFields(log.Fields{\n\t\t\"out\": out,\n\t}).Info(\"GVim\")\n\treturn 0\n}\n\nfunc init() ", "output": "{\n\t_, err := exec.Command(\"which\", gvimCmd).Output()\n\tif err == nil {\n\t\tregister(NewGVim())\n\t}\n}"}
{"input": "package restic\n\nimport \"syscall\"\n\nfunc (node Node) restoreSymlinkTimestamps(path string, utimes [2]syscall.Timespec) error {\n\treturn nil\n}\n\nfunc (node Node) device() int {\n\treturn int(node.Device)\n}\n\nfunc (s statUnix) atim() syscall.Timespec { return s.Atimespec }\nfunc (s statUnix) mtim() syscall.Timespec { return s.Mtimespec }\n\n\n\nfunc Getxattr(path, name string) ([]byte, error) {\n\treturn nil, nil\n}\n\n\n\nfunc Listxattr(path string) ([]string, error) {\n\treturn nil, nil\n}\n\n\nfunc Setxattr(path, name string, data []byte) error {\n\treturn nil\n}\n\nfunc (s statUnix) ctim() syscall.Timespec ", "output": "{ return s.Ctimespec }"}
{"input": "package comm\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestQueryType_String(t *testing.T) {\n\tassert.Equal(t, \"REQUEST\", Request.String())\n\tassert.Equal(t, \"RESPONSE\", Response.String())\n}\n\nfunc TestOutcome_String(t *testing.T) {\n\tassert.Equal(t, \"SUCCESS\", Success.String())\n\tassert.Equal(t, \"ERROR\", Error.String())\n}\n\n\n\nfunc TestMetrics_Record(t *testing.T) ", "output": "{\n\tm := newScalarMetrics()\n\n\tm.Record()\n\tassert.NotEmpty(t, m.Earliest)\n\tassert.Equal(t, m.Earliest, m.Latest)\n\tassert.Equal(t, uint64(1), m.Count)\n\n\tm.Record()\n\tassert.True(t, m.Earliest.Before(m.Latest))\n\tassert.Equal(t, uint64(2), m.Count)\n}"}
{"input": "package message\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/sha1\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n)\n\n\nfunc getMD5Hash(text string) string {\n\thasher := md5.New()\n\thasher.Write([]byte(text))\n\treturn hex.EncodeToString(hasher.Sum(nil))\n}\n\n\n\n\n\nfunc getSHA256Hash(text string) string {\n\thasher := sha256.New()\n\thasher.Write([]byte(text))\n\treturn hex.EncodeToString(hasher.Sum(nil))\n}\n\nfunc getSHA1Hash(text string) string ", "output": "{\n\thasher := sha1.New()\n\thasher.Write([]byte(text))\n\treturn hex.EncodeToString(hasher.Sum(nil))\n}"}
{"input": "package json\n\nimport (\n\t\"encoding/json\"\n)\n\nvar nullValue = []byte(\"null\")\n\n\ntype JsonString string\n\n\n\n\ntype RawJsonForm string\n\nfunc (s RawJsonForm) MarshalJSON() ([]byte, error) {\n\treturn []byte(s), nil\n}\n\nfunc (s JsonString) MarshalJSON() ([]byte, error) ", "output": "{\n\tif s == \"\" {\n\t\treturn nullValue, nil\n\t}\n\n\treturn json.Marshal(string(s))\n}"}
{"input": "package z\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc TestVar(t *testing.T) ", "output": "{\n\tv := Var(33)\n\tm := v.Pos()\n\tn := v.Neg()\n\tif m.Sign() != 1 {\n\t\tt.Errorf(\"wrong sign for pos lit %d\", m.Sign())\n\t}\n\tif n.Sign() != -1 {\n\t\tt.Errorf(\"wrong sign for neg lit %d\", m.Sign())\n\t}\n\tif m.Not() != n {\n\t\tt.Errorf(\"lit pos/neg not negations\")\n\t}\n\tif m.Var() != v || n.Var() != v {\n\t\tt.Errorf(\"generated lits not same var\")\n\t}\n\tif fmt.Sprintf(\"%s\", v) != fmt.Sprintf(\"v%d\", uint32(v)) {\n\t\tt.Errorf(\"format.\")\n\t}\n}"}
{"input": "package statsd\n\nimport (\n\t\"github.com/golang/glog\"\n)\n\ntype dummyStatsdClientImpl struct {\n\tmessages []string\n}\n\n\n\nfunc (client *dummyStatsdClientImpl) close() error {\n\tglog.V(2).Infof(\"dummy statsd client close() called, doing nothing\")\n\treturn nil\n}\n\nfunc (client *dummyStatsdClientImpl) send(messages []string) error {\n\tclient.messages = messages\n\treturn nil\n}\n\nfunc (client *dummyStatsdClientImpl) open() error ", "output": "{\n\tglog.V(2).Infof(\"dummy statsd client open() called, doing nothing\")\n\treturn nil\n}"}
{"input": "package fake_command_runner_matchers\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n\n\t\"github.com/cloudfoundry/gunk/command_runner/fake_command_runner\"\n)\n\nfunc HaveKilled(spec fake_command_runner.CommandSpec) *HaveKilledMatcher {\n\treturn &HaveKilledMatcher{Spec: spec}\n}\n\ntype HaveKilledMatcher struct {\n\tSpec   fake_command_runner.CommandSpec\n\tkilled []*exec.Cmd\n}\n\n\n\nfunc (m *HaveKilledMatcher) FailureMessage(actual interface{}) (message string) {\n\treturn fmt.Sprintf(\"Expected to kill:%s\\n\\nActually killed:%s\", prettySpec(m.Spec), prettyCommands(m.killed))\n}\n\nfunc (m *HaveKilledMatcher) NegatedFailureMessage(actual interface{}) (message string) {\n\treturn fmt.Sprintf(\"Expected to not kill the following commands:%s\", prettySpec(m.Spec))\n}\n\nfunc (m *HaveKilledMatcher) Match(actual interface{}) (bool, error) ", "output": "{\n\trunner, ok := actual.(*fake_command_runner.FakeCommandRunner)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"Not a fake command runner: %#v.\", actual)\n\t}\n\n\tm.killed = runner.KilledCommands()\n\n\tmatched := false\n\tfor _, cmd := range m.killed {\n\t\tif m.Spec.Matches(cmd) {\n\t\t\tmatched = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif matched {\n\t\treturn true, nil\n\t} else {\n\t\treturn false, nil\n\t}\n}"}
{"input": "package tcp\n\n\n\n\n\ntype renoRecovery struct {\n\ts *sender\n}\n\nfunc newRenoRecovery(s *sender) *renoRecovery {\n\treturn &renoRecovery{s: s}\n}\n\n\n\nfunc (rr *renoRecovery) DoRecovery(rcvdSeg *segment, fastRetransmit bool) ", "output": "{\n\tack := rcvdSeg.ackNumber\n\tsnd := rr.s\n\n\tif !ack.InRange(snd.SndUna, snd.SndNxt+1) {\n\t\treturn\n\t}\n\n\tif rcvdSeg.logicalLen() != 0 || snd.SndWnd != rcvdSeg.window {\n\t\treturn\n\t}\n\n\tif !fastRetransmit && ack == snd.FastRecovery.First {\n\t\tif snd.SndCwnd < snd.FastRecovery.MaxCwnd {\n\t\t\tsnd.SndCwnd++\n\t\t}\n\t\treturn\n\t}\n\n\tsnd.FastRecovery.First = ack\n\tsnd.DupAckCount = 0\n\tsnd.resendSegment()\n}"}
{"input": "package floc\n\nimport \"fmt\"\n\n\ntype Result int32\n\n\nconst (\n\tNone         Result = 1\n\tCompleted    Result = 2\n\tCanceled     Result = 4\n\tFailed       Result = 8\n\tusedBitsMask Result = None | Completed | Canceled | Failed\n\tfinishedMask Result = Completed | Canceled | Failed\n)\n\n\n\n\n\nfunc (result Result) IsCompleted() bool {\n\treturn result == Completed\n}\n\n\nfunc (result Result) IsCanceled() bool {\n\treturn result == Canceled\n}\n\n\nfunc (result Result) IsFailed() bool {\n\treturn result == Failed\n}\n\n\nfunc (result Result) IsFinished() bool {\n\treturn result&finishedMask != 0\n}\n\n\nfunc (result Result) IsValid() bool {\n\treturn result == None || result == Completed || result == Canceled || result == Failed\n}\n\n\nfunc (result Result) Mask() ResultMask {\n\treturn NewResultMask(result)\n}\n\n\nfunc (result Result) i32() int32 {\n\treturn int32(result)\n}\n\nfunc (result Result) String() string {\n\tswitch result {\n\tcase None:\n\t\treturn \"None\"\n\tcase Completed:\n\t\treturn \"Completed\"\n\tcase Canceled:\n\t\treturn \"Canceled\"\n\tcase Failed:\n\t\treturn \"Failed\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"Result(%d)\", result.i32())\n\t}\n}\n\nfunc (result Result) IsNone() bool ", "output": "{\n\treturn result == None\n}"}
{"input": "package glw\n\nimport \"golang.org/x/mobile/gl\"\n\ntype A2fv gl.Attrib\n\nfunc (a A2fv) Enable()  { ctx.EnableVertexAttribArray(gl.Attrib(a)) }\nfunc (a A2fv) Disable() { ctx.DisableVertexAttribArray(gl.Attrib(a)) }\nfunc (a A2fv) Pointer() {\n\ta.Enable()\n\tctx.VertexAttribPointer(gl.Attrib(a), 2, gl.FLOAT, false, 0, 0)\n}\n\ntype A3fv gl.Attrib\n\nfunc (a A3fv) Enable()  { ctx.EnableVertexAttribArray(gl.Attrib(a)) }\nfunc (a A3fv) Disable() { ctx.DisableVertexAttribArray(gl.Attrib(a)) }\nfunc (a A3fv) Pointer() {\n\ta.Enable()\n\tctx.VertexAttribPointer(gl.Attrib(a), 3, gl.FLOAT, false, 0, 0)\n}\n\ntype A4fv gl.Attrib\n\nfunc (a A4fv) Enable()  { ctx.EnableVertexAttribArray(gl.Attrib(a)) }\n\nfunc (a A4fv) Pointer() {\n\ta.Enable()\n\tctx.VertexAttribPointer(gl.Attrib(a), 4, gl.FLOAT, false, 0, 0)\n}\n\nfunc (a A4fv) Disable() ", "output": "{ ctx.DisableVertexAttribArray(gl.Attrib(a)) }"}
{"input": "package main\n\nimport (\n\t\"go/ast\"\n\t\"strconv\"\n)\n\nfunc init() {\n\tregister(gotypesFix)\n}\n\nvar gotypesFix = fix{\n\t\"gotypes\",\n\t\"2015-07-16\",\n\tgotypes,\n\t`Change imports of golang.org/x/tools/go/{exact,types} to go/{constant,types}`,\n}\n\n\n\nfunc fixGoTypes(f *ast.File) bool {\n\treturn rewriteImport(f, \"golang.org/x/tools/go/types\", \"go/types\")\n}\n\nfunc fixGoExact(f *ast.File) bool {\n\tvar importSpec *ast.ImportSpec\n\twalk(f, func(n interface{}) {\n\t\tif importSpec != nil {\n\t\t\treturn\n\t\t}\n\t\tspec, ok := n.(*ast.ImportSpec)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tpath, err := strconv.Unquote(spec.Path.Value)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif path == \"golang.org/x/tools/go/exact\" {\n\t\t\timportSpec = spec\n\t\t}\n\n\t})\n\tif importSpec == nil {\n\t\treturn false\n\t}\n\n\texists := renameTop(f, \"constant\", \"constant\")\n\tsuffix := \"\"\n\tif exists {\n\t\tsuffix = \"_\"\n\t}\n\trenameTop(f, \"exact\", \"constant\"+suffix)\n\trewriteImport(f, \"golang.org/x/tools/go/exact\", \"go/constant\")\n\timportSpec.Name = nil\n\treturn true\n}\n\nfunc gotypes(f *ast.File) bool ", "output": "{\n\ttruth := fixGoTypes(f)\n\tif fixGoExact(f) {\n\t\ttruth = true\n\t}\n\treturn truth\n}"}
{"input": "package loads\n\nimport \"jvmgo/ch09/instructions/base\"\nimport \"jvmgo/ch09/rtda\"\n\n\ntype ILOAD struct{ base.Index8Instruction }\n\n\n\ntype ILOAD_0 struct{ base.NoOperandsInstruction }\n\nfunc (self *ILOAD_0) Execute(frame *rtda.Frame) {\n\t_iload(frame, 0)\n}\n\ntype ILOAD_1 struct{ base.NoOperandsInstruction }\n\nfunc (self *ILOAD_1) Execute(frame *rtda.Frame) {\n\t_iload(frame, 1)\n}\n\ntype ILOAD_2 struct{ base.NoOperandsInstruction }\n\nfunc (self *ILOAD_2) Execute(frame *rtda.Frame) {\n\t_iload(frame, 2)\n}\n\ntype ILOAD_3 struct{ base.NoOperandsInstruction }\n\nfunc (self *ILOAD_3) Execute(frame *rtda.Frame) {\n\t_iload(frame, 3)\n}\n\nfunc _iload(frame *rtda.Frame, index uint) {\n\tval := frame.LocalVars().GetInt(index)\n\tframe.OperandStack().PushInt(val)\n}\n\nfunc (self *ILOAD) Execute(frame *rtda.Frame) ", "output": "{\n\t_iload(frame, self.Index)\n}"}
{"input": "package admission\n\nimport (\n\t\"k8s.io/apimachinery/pkg/api/meta\"\n\t\"k8s.io/apiserver/pkg/admission\"\n\tquota \"k8s.io/kubernetes/pkg/quota/v1\"\n)\n\n\n\n\ntype WantsCloudConfig interface {\n\tSetCloudConfig([]byte)\n}\n\n\ntype WantsRESTMapper interface {\n\tSetRESTMapper(meta.RESTMapper)\n}\n\n\ntype WantsQuotaConfiguration interface {\n\tSetQuotaConfiguration(quota.Configuration)\n\tadmission.InitializationValidator\n}\n\n\ntype PluginInitializer struct {\n\tcloudConfig        []byte\n\trestMapper         meta.RESTMapper\n\tquotaConfiguration quota.Configuration\n}\n\nvar _ admission.PluginInitializer = &PluginInitializer{}\n\n\n\n\nfunc NewPluginInitializer(\n\tcloudConfig []byte,\n\trestMapper meta.RESTMapper,\n\tquotaConfiguration quota.Configuration,\n) *PluginInitializer {\n\treturn &PluginInitializer{\n\t\tcloudConfig:        cloudConfig,\n\t\trestMapper:         restMapper,\n\t\tquotaConfiguration: quotaConfiguration,\n\t}\n}\n\n\n\n\n\nfunc (i *PluginInitializer) Initialize(plugin admission.Interface) ", "output": "{\n\tif wants, ok := plugin.(WantsCloudConfig); ok {\n\t\twants.SetCloudConfig(i.cloudConfig)\n\t}\n\n\tif wants, ok := plugin.(WantsRESTMapper); ok {\n\t\twants.SetRESTMapper(i.restMapper)\n\t}\n\n\tif wants, ok := plugin.(WantsQuotaConfiguration); ok {\n\t\twants.SetQuotaConfiguration(i.quotaConfiguration)\n\t}\n}"}
{"input": "package project\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestTrimSpaceAndNonPrintable_space(t *testing.T) {\n\tt.Parallel()\n\n\textraChars := \" state  \\r\\t\"\n\twant := \"state\"\n\tgot := TrimSpaceAndNonPrintable(extraChars)\n\n\tif want != got {\n\t\tt.Fatalf(\"wrong trim, want: %q got: %q\", want, got)\n\t}\n}\n\nfunc TestTrimSpace_unicode(t *testing.T) {\n\tt.Parallel()\n\n\textraChars := \"state\\uFEFF\"\n\twant := \"state\"\n\tgot := TrimSpace(extraChars)\n\n\tif want != got {\n\t\tt.Fatalf(\"wrong trim, want: %q got: %q\", want, got)\n\t}\n}\n\nfunc TestTrimSpace_space(t *testing.T) {\n\tt.Parallel()\n\n\textraChars := \" state  \\r\\t\"\n\twant := \"state\"\n\tgot := TrimSpace(extraChars)\n\n\tif want != got {\n\t\tt.Fatalf(\"wrong trim, want: %q got: %q\", want, got)\n\t}\n}\n\nfunc TestTrimSpaceAndNonPrintable_unicode(t *testing.T) ", "output": "{\n\tt.Parallel()\n\n\textraChars := \"state\\uFEFF\"\n\twant := \"state\"\n\tgot := TrimSpaceAndNonPrintable(extraChars)\n\n\tif want != got {\n\t\tt.Fatalf(\"wrong trim, want: %q got: %q\", want, got)\n\t}\n}"}
{"input": "package transport\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\tma \"gx/ipfs/QmSWLfmj5frN9xVLMMN846dMDriy5wN5jeghUm7aTW3DAG/go-multiaddr\"\n\tmanet \"gx/ipfs/QmVCNGTyD4EkvNYaAp253uMQ9Rjsjy2oGMvcdJJUoVRfja/go-multiaddr-net\"\n\tmafmt \"gx/ipfs/QmYjJnSTfXWhYL2cV1xFphPqjqowJqH7ZKLA1As8QrPHbn/mafmt\"\n)\n\ntype FallbackDialer struct {\n\tmadialer manet.Dialer\n}\n\n\n\nfunc (fbd *FallbackDialer) Dial(a ma.Multiaddr) (Conn, error) {\n\treturn fbd.DialContext(context.Background(), a)\n}\n\nfunc (fbd *FallbackDialer) DialContext(ctx context.Context, a ma.Multiaddr) (Conn, error) {\n\tif mafmt.TCP.Matches(a) {\n\t\treturn fbd.tcpDial(ctx, a)\n\t}\n\treturn nil, fmt.Errorf(\"cannot dial %s with fallback dialer\", a)\n}\n\nfunc (fbd *FallbackDialer) tcpDial(ctx context.Context, raddr ma.Multiaddr) (Conn, error) {\n\tvar c manet.Conn\n\tvar err error\n\tc, err = fbd.madialer.DialContext(ctx, raddr)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ConnWrap{\n\t\tConn: c,\n\t}, nil\n}\n\nvar _ Dialer = (*FallbackDialer)(nil)\n\nfunc (fbd *FallbackDialer) Matches(a ma.Multiaddr) bool ", "output": "{\n\treturn mafmt.TCP.Matches(a)\n}"}
{"input": "package job\n\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"cloud.google.com/go/bigquery\"\n)\n\n\n\n\n\nfunc copyTableWithCMEK(projectID, datasetID, tableID string) error ", "output": "{\n\tctx := context.Background()\n\tclient, err := bigquery.NewClient(ctx, projectID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"bigquery.NewClient: %v\", err)\n\t}\n\tdefer client.Close()\n\n\tsrcTable := client.DatasetInProject(\"bigquery-public-data\", \"samples\").Table(\"shakespeare\")\n\tcopier := client.Dataset(datasetID).Table(tableID).CopierFrom(srcTable)\n\tcopier.DestinationEncryptionConfig = &bigquery.EncryptionConfig{\n\t\tKMSKeyName: \"projects/cloud-samples-tests/locations/us-central1/keyRings/test/cryptoKeys/test\",\n\t}\n\tjob, err := copier.Run(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tstatus, err := job.Wait(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := status.Err(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\t\"path\"\n)\n\ntype Book struct {\n\tTitle  string `json:\"title\"`\n\tAuthor string `json:\"author\"`\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", ShowBooks)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\n\n\nfunc ShowBooks(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tbook := Book{\"Building Web Apps with Go\", \"Jeremy Saenz\"}\n\n\tfp := path.Join(\"templates\", \"index.html\")\n\ttmpl, err := template.ParseFiles(fp)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif err := tmpl.Execute(w, book); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t}\n}"}
{"input": "package statebased\n\nimport \"fmt\"\n\n\ntype RoleType string\n\nconst (\n\tRoleTypeMember = RoleType(\"MEMBER\")\n\tRoleTypePeer = RoleType(\"PEER\")\n)\n\n\n\n\ntype RoleTypeDoesNotExistError struct {\n\tRoleType RoleType\n}\n\n\n\n\n\n\n\ntype KeyEndorsementPolicy interface {\n\tPolicy() ([]byte, error)\n\n\tAddOrgs(roleType RoleType, organizations ...string) error\n\n\tDelOrgs(organizations ...string)\n\n\tListOrgs() []string\n}\n\nfunc (r *RoleTypeDoesNotExistError) Error() string ", "output": "{\n\treturn fmt.Sprintf(\"role type %s does not exist\", r.RoleType)\n}"}
{"input": "package blake2b\n\nimport \"golang.org/x/sys/cpu\"\n\nfunc init() {\n\tuseAVX2 = cpu.X86.HasAVX2\n\tuseAVX = cpu.X86.HasAVX\n\tuseSSE4 = cpu.X86.HasSSE41\n}\n\n\nfunc hashBlocksAVX2(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)\n\n\nfunc hashBlocksAVX(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)\n\n\nfunc hashBlocksSSE4(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte)\n\n\n\nfunc hashBlocks(h *[8]uint64, c *[2]uint64, flag uint64, blocks []byte) ", "output": "{\n\tswitch {\n\tcase useAVX2:\n\t\thashBlocksAVX2(h, c, flag, blocks)\n\tcase useAVX:\n\t\thashBlocksAVX(h, c, flag, blocks)\n\tcase useSSE4:\n\t\thashBlocksSSE4(h, c, flag, blocks)\n\tdefault:\n\t\thashBlocksGeneric(h, c, flag, blocks)\n\t}\n}"}
{"input": "package node\n\nimport (\n\t\"fmt\"\n\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/cli\"\n\t\"github.com/docker/docker/cli/command\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype removeOptions struct {\n\tforce bool\n}\n\nfunc newRemoveCommand(dockerCli *command.DockerCli) *cobra.Command {\n\topts := removeOptions{}\n\n\tcmd := &cobra.Command{\n\t\tUse:     \"rm [OPTIONS] NODE [NODE...]\",\n\t\tAliases: []string{\"remove\"},\n\t\tShort:   \"Remove one or more nodes from the swarm\",\n\t\tArgs:    cli.RequiresMinArgs(1),\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn runRemove(dockerCli, args, opts)\n\t\t},\n\t}\n\tflags := cmd.Flags()\n\tflags.BoolVar(&opts.force, \"force\", false, \"Force remove an active node\")\n\treturn cmd\n}\n\n\n\nfunc runRemove(dockerCli *command.DockerCli, args []string, opts removeOptions) error ", "output": "{\n\tclient := dockerCli.Client()\n\tctx := context.Background()\n\tfor _, nodeID := range args {\n\t\terr := client.NodeRemove(ctx, nodeID, types.NodeRemoveOptions{Force: opts.force})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Fprintf(dockerCli.Out(), \"%s\\n\", nodeID)\n\t}\n\treturn nil\n}"}
{"input": "package elcomd\n\nimport (\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/baocaixiong/elcom/utils\"\n)\n\ntype ElcomdOptions struct {\n\tHostName          string   `flag:\"broadcast-address\" cfg:\"broadcast_address\"`\n\tLogPath           string   `flag:\"logPath\" cfg:\"log_path\"`\n\tTCPAddress        string   `flag:\"tcp-address\" cfg:\"tcp_address\"`\n\tHTTPAddress       string   `flag:\"http-address\" cfg:\"http_address\"`\n\tNSQDTCPAddresses  []string `flag:\"nsqd-tcp-addresses\" cfg:\"nsqd_tcp_addresses\"`\n\tNSQDHTTPAddresses []string `flag:\"nsqd-http-addresses\" cfg:\"nsqd_http_addresses\"`\n\tlogger            utils.LoggerI\n}\n\nfunc NewElcomdOptions() *ElcomdOptions {\n\n\thostName, err := os.Hostname()\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\to := &ElcomdOptions{\n\t\tLogPath:          \"\",\n\t\tHostName:         hostName,\n\t\tTCPAddress:       \"0.0.0.0:4230\",\n\t\tHTTPAddress:      \"0.0.0.0:4231\",\n\t\tNSQDTCPAddresses: []string{},\n\t\tlogger:           &utils.Logger{Logger: log.New(os.Stderr, \"[elcomd] \", log.Ldate|log.Ltime|log.Lmicroseconds)},\n\t}\n\n\treturn o\n}\n\nfunc (o *ElcomdOptions) HasLogPath() bool {\n\treturn \"\" != o.LogPath\n}\n\n\n\nfunc (o *ElcomdOptions) HasNSQDHTTPAddress() bool {\n\treturn len(o.NSQDHTTPAddresses) > 0\n}\n\nfunc (o *ElcomdOptions) HasNSQDTCPAddress() bool ", "output": "{\n\treturn len(o.NSQDTCPAddresses) > 0\n}"}
{"input": "package main\n\nimport (\n\t\"code.google.com/p/go.net/websocket\"\n\t\"log\"\n  \"strconv\"\n)\n\nconst bufferSize = 100\n\nvar maxId uint64 = 0\n\ntype Client struct {\n\tid   uint64\n\tws   *websocket.Conn\n\trace *Race\n\tch   chan *Message\n}\n\nfunc NewClient(ws *websocket.Conn, race *Race) *Client {\n\tmaxId++\n\tch := make(chan *Message, bufferSize)\n\treturn &Client{maxId, ws, race, ch}\n}\n\nfunc (c *Client) Conn() *websocket.Conn {\n\treturn c.ws\n}\n\nfunc (c *Client) Write(msg *Message) {\n\tselect {\n\tcase c.ch <- msg:\n\tdefault:\n\t\tc.race.Del(c)\n\t\tlog.Println(\"Client\", c.id, \"disconnected\")\n\t}\n}\n\nfunc (c *Client) Listen() {\n\tgo c.listenWrite()\n\tc.listenRead()\n}\n\n\n\nfunc (c *Client) listenRead() {\n\tfor {\n\t\tselect {\n\t\tdefault:\n\t\t\tvar msg Message\n\t\t\tif err := websocket.JSON.Receive(c.ws, &msg);err!=nil{\n        if err.Error()==\"EOF\"{\n          c.race.Del(c)\n          return\n        }\n        log.Println(\"Unhandled error:\",err)\n        return\n      }\n\t\t\tlog.Println(c.id, \"got:\", msg)\n\n      if msg.Type==\"word\"{\n        i,err:=strconv.Atoi(msg.Body)\n        if err!=nil{\n          log.Println(err)\n          continue\n        }\n        if i>c.race.best{\n          c.race.best=i\n          c.race.sendAll(&Message{\"best\",msg.Body,c.id})\n        }\n      }\n\t\t}\n\t}\n}\n\nfunc (c *Client) listenWrite() ", "output": "{\n\tfor {\n\t\tselect {\n\t\tcase msg := <-c.ch:\n\t\t\twebsocket.JSON.Send(c.ws, msg)\n\t\t\tlog.Println(\"Sending to\", c.id, \":\", msg)\n\t\t}\n\t}\n}"}
{"input": "package concurrent\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n\ntype BackgroundWorker interface {\n\tDo(f func() (interface{}, error)) error\n\tClose() ([]interface{}, error)\n}\n\n\n\n\ntype valueError struct {\n\tvalue interface{}\n\terr   error\n}\n\ntype backgroundWorker struct {\n\twg          *sync.WaitGroup\n\tvalueErrors chan *valueError\n\tdestroyable Destroyable\n}\n\nfunc newBackgroundWorker() *backgroundWorker {\n\treturn &backgroundWorker{&sync.WaitGroup{}, make(chan *valueError), NewDestroyable(nil)}\n}\n\nfunc (b *backgroundWorker) Do(f func() (interface{}, error)) error {\n\t_, err := b.destroyable.Do(func() (interface{}, error) {\n\t\tb.wg.Add(1)\n\t\tgo func() {\n\t\t\tvalue, err := f()\n\t\t\tb.valueErrors <- &valueError{value, err}\n\t\t\tb.wg.Done()\n\t\t}()\n\t\treturn nil, nil\n\t})\n\treturn err\n}\n\nfunc (b *backgroundWorker) Close() ([]interface{}, error) {\n\tvar values []interface{}\n\tvar errs []error\n\tif err := b.destroyable.Destroy(); err != nil {\n\t\terrs = append(errs, err)\n\t}\n\tgo func() {\n\t\tfor {\n\t\t\tvalueError, ok := <-b.valueErrors\n\t\t\tif !ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tvalues = append(values, valueError.value)\n\t\t\tif valueError.err != nil {\n\t\t\t\terrs = append(errs, valueError.err)\n\t\t\t}\n\t\t}\n\t}()\n\tb.wg.Wait()\n\tclose(b.valueErrors)\n\tif len(errs) == 0 {\n\t\treturn values, nil\n\t}\n\treturn values, fmt.Errorf(\"%v\", errs)\n}\n\nfunc NewBackgroundWorker() BackgroundWorker ", "output": "{\n\treturn newBackgroundWorker()\n}"}
{"input": "package common\n\nimport (\n\t\"os/exec\"\n)\n\nconst VMWARE_PLAYER_VERSION = \"6\"\n\n\n\n\ntype Player6Driver struct {\n\tPlayer5Driver\n}\n\n\n\nfunc (d *Player6Driver) Verify() error {\n\tif err := d.Player5Driver.Verify(); err != nil {\n\t\treturn err\n\t}\n\n\treturn playerVerifyVersion(VMWARE_PLAYER_VERSION)\n}\n\nfunc (d *Player6Driver) Clone(dst, src string) error ", "output": "{\n\n\tcmd := exec.Command(d.Player5Driver.VmrunPath,\n\t\t\"-T\", \"ws\",\n\t\t\"clone\", src, dst,\n\t\t\"full\")\n\n\tif _, _, err := runAndLog(cmd); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package runewidth\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar escRegex *regexp.Regexp\n\nfunc init() {\n\tescRegex = regexp.MustCompile(\"\\u001b\\\\[(?:[0-9]{1,3}(?:;[0-9]{1,3})*)?[m|K]\")\n}\n\n\nfunc Width(s string) int {\n\tvar rv int\n\ts = escRegex.ReplaceAllString(s, \"\")\n\trstr := strings.NewReader(s)\n\tfor {\n\t\tr, _, err := rstr.ReadRune()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\trv += RuneWdith(r)\n\t}\n\n\treturn rv\n}\n\n\n\n\n\n\n\nfunc RuneWdith(r rune) int ", "output": "{\n\tif 0x0021 <= r && r <= 0x007e {\n\t\treturn 1\n\t}\n\n\tif 0x4e00 <= r && r <= 0x9fff {\n\t\treturn 2\n\t}\n\n\tif 0xac00 <= r && r <= 0xd7af {\n\t\treturn 2\n\t}\n\n\tif 0x3040 <= r && r <= 0x309f {\n\t\treturn 2\n\t}\n\tif 0x30a0 <= r && r <= 0x30ff {\n\t\treturn 2\n\t}\n\n\tif 0xff01 <= r && r <= 0xff60 {\n\t\treturn 2\n\t}\n\n\tif 0x3000 <= r && r <= 0x303e {\n\t\treturn 2\n\t}\n\n\tif 0x0008 == r || 0x007f == r {\n\t\treturn -1\n\t}\n\n\tif 0x0000 <= r && r <= 0x001f {\n\t\treturn 0\n\t}\n\n\treturn 1\n}"}
{"input": "package crypto\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n)\n\n\nfunc HS512Byte(in, secret []byte) []byte {\n\th := hmac.New(sha512.New, secret)\n\th.Write(in)\n\treturn h.Sum(nil)\n}\n\n\nfunc HS512Base64(in, secret string) string {\n\tkey := []byte(secret)\n\th := hmac.New(sha512.New, key)\n\th.Write([]byte(in))\n\treturn base64.StdEncoding.EncodeToString(h.Sum(nil))\n}\n\n\nfunc HS512Hex(in, secret string) string {\n\tkey := []byte(secret)\n\th := hmac.New(sha512.New, key)\n\th.Write([]byte(in))\n\treturn hex.EncodeToString(h.Sum(nil))\n}\n\n\n\n\nfunc CompareHS512Hex(in, secret, hs512Hex string) bool ", "output": "{\n\tif HS512Hex(in, secret) == hs512Hex {\n\t\treturn true\n\t}\n\treturn false\n}"}
{"input": "package check\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n\n\n\n\nfunc Dir(path string) error ", "output": "{\n\tif info, err := os.Stat(path); err != nil {\n\t\treturn fmt.Errorf(`directory not exists: %s`, path)\n\t} else if !info.IsDir() {\n\t\treturn fmt.Errorf(`path is not directory: %s`, path)\n\t}\n\treturn nil\n}"}
{"input": "package kubeconfig\n\nimport (\n\t\"bytes\"\n\n\tyaml \"gopkg.in/yaml.v3\"\n\tkubeyaml \"sigs.k8s.io/yaml\"\n\n\t\"sigs.k8s.io/kind/pkg/errors\"\n)\n\n\n\n\n\n\nfunc normYaml(y []byte) ([]byte, error) {\n\tvar unstructured interface{}\n\tif err := kubeyaml.Unmarshal(y, &unstructured); err != nil {\n\t\treturn nil, err\n\t}\n\tencoded, err := kubeyaml.Marshal(&unstructured)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif bytes.Equal(encoded, []byte(\"{}\\n\")) {\n\t\treturn []byte{}, nil\n\t}\n\treturn encoded, nil\n}\n\nfunc Encode(cfg *Config) ([]byte, error) ", "output": "{\n\tencoded, err := yaml.Marshal(cfg)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to encode KUBECONFIG\")\n\t}\n\n\tencoded, err = normYaml(encoded)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"failed to normalize KUBECONFIG encoding\")\n\t}\n\n\treturn encoded, nil\n}"}
{"input": "package wifi\n\nvar _ = WiFi(&StubWorker{})\n\ntype StubWorker struct {\n\tOptions []Option\n\tID      string\n}\n\n\n\nfunc (w *StubWorker) GetID() (string, error) {\n\treturn w.ID, nil\n}\n\nfunc (*StubWorker) Connect(a ...string) error {\n\treturn nil\n}\n\nfunc NewStubWorker(id string, options ...Option) (WiFi, error) {\n\treturn &StubWorker{ID: id, Options: options}, nil\n}\n\nfunc (w *StubWorker) Scan() ([]Option, error) ", "output": "{\n\treturn w.Options, nil\n}"}
{"input": "package version\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n)\n\nvar (\n\tVersion = \"Not provided.\"\n\tGitSHA = \"Not provided.\"\n\tBuilt = \"Not provided.\"\n)\n\n\nfunc PrintVersionAndExit(apiVersion string) {\n\tfor _, i := range Info(apiVersion) {\n\t\tfmt.Printf(\"%v\\n\", i)\n\t}\n\tos.Exit(0)\n}\n\n\n\n\nfunc Info(apiVersion string) []string ", "output": "{\n\treturn []string{\n\t\tfmt.Sprintf(\"API Version: %s\", apiVersion),\n\t\tfmt.Sprintf(\"Version: %s\", Version),\n\t\tfmt.Sprintf(\"Git SHA: %s\", GitSHA),\n\t\tfmt.Sprintf(\"Built At: %s\", Built),\n\t\tfmt.Sprintf(\"Go Version: %s\", runtime.Version()),\n\t\tfmt.Sprintf(\"Go OS/Arch: %s/%s\", runtime.GOOS, runtime.GOARCH),\n\t}\n}"}
{"input": "package main\n\ntype Move struct {\n\tSrc  Point\n\tDest Point\n}\n\nvar EmptyMove = Move{Point{0, 0}, Point{0, 0}}\n\n\n\nfunc (m Move) String() string {\n\treturn m.Src.String() + \">\" + m.Dest.String()\n}\n\nfunc (m Move) Valid(table Table) bool {\n\tfor x := m.Src.X; x <= m.Dest.X; x++ {\n\t\tfor y := m.Src.Y; y <= m.Dest.Y; y++ {\n\t\t\tcell := table[y][x]\n\t\t\tswitch cell {\n\t\t\tcase HOLLOW, LAND:\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (m Move) Apply(t Table) {\n\tdist := m.Src.DistanceTo(m.Dest) + 1\n\tdist /= 2\n\n\tif m.Src.X == m.Dest.X {\n\t\tfor i := 0; i < dist; i++ {\n\t\t\tt.SwapY(m.Src.X, m.Src.Y+i, m.Dest.Y-i)\n\t\t}\n\n\t} else if m.Src.Y == m.Dest.Y {\n\t\tfor i := 0; i < dist; i++ {\n\t\t\tt.SwapX(m.Src.Y, m.Src.X+i, m.Dest.X-i)\n\t\t}\n\n\t} else {\n\t\tpanic(\"Diagonal move is not supported!\")\n\t}\n\n\n\n\tfor t.Resolve() > 0 {\n\t}\n}\n\nfunc NewMove(src Point, dest Point) Move ", "output": "{\n\ts, d := src, dest\n\tif s.X > d.X {\n\t\ts.X, d.X = d.X, s.X\n\t}\n\tif s.Y > d.Y {\n\t\ts.Y, d.Y = d.Y, s.Y\n\t}\n\n\treturn Move{src, dest}\n}"}
{"input": "package config\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar (\n\tCurrent = Version{\n\t\tMajor: 0,\n\t\tMinor: 15,\n\t\tPatch: 1,\n\t}\n\n\tFirst = Version{\n\t\t0, 10, 4,\n\t}\n)\n\n\ntype Version struct {\n\tMajor int `json:\"major\"`\n\tMinor int `json:\"minor\"`\n\tPatch int `json:\"patch\"`\n}\n\n\n\n\n\nfunc (v Version) String() string {\n\treturn fmt.Sprintf(\"%d.%d.%d\", v.Major, v.Minor, v.Patch)\n}\n\n\nfunc (v Version) Greater(x Version) bool {\n\tif v.Major > x.Major {\n\t\treturn true\n\t}\n\n\tif v.Major == x.Major {\n\t\tif v.Minor > x.Minor {\n\t\t\treturn true\n\t\t}\n\n\t\tif v.Minor == x.Minor {\n\t\t\tif v.Patch > x.Patch {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\treturn false\n\t\t}\n\t\treturn false\n\t}\n\n\treturn false\n}\n\nfunc VersionFromString(s string) Version ", "output": "{\n\tvs := strings.Split(s, \".\")\n\n\tif len(vs) < 3 {\n\n\t\treturn First\n\t}\n\n\ttoInt := func(s string) int {\n\t\ti, err := strconv.Atoi(s)\n\t\tif err != nil {\n\t\t\treturn 0\n\t\t}\n\t\treturn i\n\t}\n\n\treturn Version{toInt(vs[0]), toInt(vs[1]), toInt(vs[2])}\n}"}
{"input": "package main\n\ntype TopicMessage struct {\n    source *Client\n    text string\n}\n\nfunc NewTopicMessage(source *Client, text string) *TopicMessage {\n    return &TopicMessage{source, text}\n}\n\n\n\nfunc (this *TopicMessage) Text() string {\n    return this.text\n}\n\nfunc (this *TopicMessage) Source() *Client ", "output": "{\n    return this.source\n}"}
{"input": "package egoscale\n\nimport \"fmt\"\n\n\nfunc (ListTemplates) Response() interface{} {\n\treturn new(ListTemplatesResponse)\n}\n\n\n\n\n\nfunc (ls *ListTemplates) SetPage(page int) {\n\tls.Page = page\n}\n\n\nfunc (ls *ListTemplates) SetPageSize(pageSize int) {\n\tls.PageSize = pageSize\n}\n\n\nfunc (ListTemplates) Each(resp interface{}, callback IterateItemFunc) {\n\titems, ok := resp.(*ListTemplatesResponse)\n\tif !ok {\n\t\tcallback(nil, fmt.Errorf(\"wrong type, ListTemplatesResponse was expected, got %T\", resp))\n\t\treturn\n\t}\n\n\tfor i := range items.Template {\n\t\tif !callback(&items.Template[i], nil) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (ls *ListTemplates) ListRequest() (ListCommand, error) ", "output": "{\n\tif ls == nil {\n\t\treturn nil, fmt.Errorf(\"%T cannot be nil\", ls)\n\t}\n\treturn ls, nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/labstack/echo\"\n\n\t\"github.com/golang-devops/go-psexec/shared/dtos\"\n)\n\n\n\nfunc (h *handler) handleStatsFunc(c echo.Context) error ", "output": "{\n\tpath := c.QueryParam(\"path\")\n\tif strings.TrimSpace(path) == \"\" {\n\t\treturn fmt.Errorf(\"Request does not contain query 'path' value\")\n\t}\n\n\tinfo, err := os.Stat(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn c.JSON(200, &dtos.StatsDto{\n\t\t\t\tPath:   path,\n\t\t\t\tExists: false,\n\t\t\t})\n\t\t}\n\t\treturn fmt.Errorf(\"Unable to get stats of path '%s', error: %s\", path, err.Error())\n\t}\n\n\treturnDto := &dtos.StatsDto{\n\t\tPath:    path,\n\t\tExists:  true,\n\t\tIsDir:   info.IsDir(),\n\t\tModTime: info.ModTime(),\n\t\tMode:    info.Mode(),\n\t\tSize:    info.Size(),\n\t}\n\treturn c.JSON(200, returnDto)\n}"}
{"input": "package externalversions\n\nimport (\n\t\"fmt\"\n\n\tv1 \"github.com/noironetworks/aci-containers/pkg/snatpolicy/apis/aci.snat/v1\"\n\tschema \"k8s.io/apimachinery/pkg/runtime/schema\"\n\tcache \"k8s.io/client-go/tools/cache\"\n)\n\n\n\ntype GenericInformer interface {\n\tInformer() cache.SharedIndexInformer\n\tLister() cache.GenericLister\n}\n\ntype genericInformer struct {\n\tinformer cache.SharedIndexInformer\n\tresource schema.GroupResource\n}\n\n\n\n\n\nfunc (f *genericInformer) Lister() cache.GenericLister {\n\treturn cache.NewGenericLister(f.Informer().GetIndexer(), f.resource)\n}\n\n\n\nfunc (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) {\n\tswitch resource {\n\tcase v1.SchemeGroupVersion.WithResource(\"snatpolicies\"):\n\t\treturn &genericInformer{resource: resource.GroupResource(), informer: f.Aci().V1().SnatPolicies().Informer()}, nil\n\n\t}\n\n\treturn nil, fmt.Errorf(\"no informer found for %v\", resource)\n}\n\nfunc (f *genericInformer) Informer() cache.SharedIndexInformer ", "output": "{\n\treturn f.informer\n}"}
{"input": "package dfa\n\nimport (\n\t\"fmt\"\n\t\"unicode\"\n)\n\nfunc charClass(name string) (m *M, err error) {\n\tms := []*M{}\n\terr = eachRangeInCharClass(name, func(lo, hi rune) {\n\t\tms = append(ms, Between(lo, hi))\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tm, err = orMany(ms)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn m.minimize()\n}\n\n\nfunc eachRangeWithStride(lo, hi, stride rune, visit func(lo, hi rune)) {\n\tif stride == 1 {\n\t\tvisit(lo, hi)\n\t} else {\n\t\tfor c := lo; c <= hi; c += stride {\n\t\t\tvisit(c, c)\n\t\t}\n\t}\n}\n\nfunc eachRangeInCharClass(name string, visit func(lo, hi rune)) error ", "output": "{\n\ttable := unicode.Categories[name]\n\tif table == nil {\n\t\ttable = unicode.Scripts[name]\n\t\tif table == nil {\n\t\t\treturn fmt.Errorf(\"character class %s not exists\", name)\n\t\t}\n\t}\n\n\tfor _, xr := range table.R16 {\n\t\teachRangeWithStride(rune(xr.Lo), rune(xr.Hi), rune(xr.Stride), visit)\n\t}\n\tfor _, xr := range table.R32 {\n\t\teachRangeWithStride(rune(xr.Lo), rune(xr.Hi), rune(xr.Stride), visit)\n\t}\n\treturn nil\n}"}
{"input": "package http_handlers\n\nimport (\n\t\"fmt\"\n\t\"github.com/go-martini/martini\"\n\t\"net/http\"\n)\n\nfunc GetCaches() func(\n\tmartini.Context,\n\tmartini.Params,\n\thttp.ResponseWriter,\n\t*http.Request,\n) {\n\treturn HttpHandler(\n\t\t[]string{\n\t\t\tAUTH_REQUIRED,\n\t\t},\n\t\tfunc(h *Http) {\n\t\t\th.SetResponse(\n\t\t\t\th.session.Caches,\n\t\t\t)\n\t\t},\n\t)\n}\n\nfunc GetCache() func(\n\tmartini.Context,\n\tmartini.Params,\n\thttp.ResponseWriter,\n\t*http.Request,\n) {\n\treturn HttpHandler(\n\t\t[]string{\n\t\t\tAUTH_REQUIRED,\n\t\t\tCACHE_REQUIRED,\n\t\t},\n\t\tfunc(h *Http) {\n\t\t\tif c := h.session.GetCache(\n\t\t\t\th.vars[\"cache_id\"],\n\t\t\t); c != nil {\n\t\t\t\th.SetResponse(\n\t\t\t\t\tc,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\th.AddError(\n\t\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\t`Cache not found`,\n\t\t\t\t\t),\n\t\t\t\t\t404,\n\t\t\t\t)\n\t\t\t}\n\t\t},\n\t)\n}\n\n\n\nfunc RegisterCache() func(\n\tmartini.Context,\n\tmartini.Params,\n\thttp.ResponseWriter,\n\t*http.Request,\n) ", "output": "{\n\treturn HttpHandler(\n\t\t[]string{\n\t\t\tAUTH_REQUIRED,\n\t\t},\n\t\tfunc(h *Http) {\n\t\t\th.SetResponseCreatedObject(\n\t\t\t\th.session.CreateCache(),\n\t\t\t)\n\t\t},\n\t)\n}"}
{"input": "package proxy\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n)\n\ntype Response interface {\n\tStatus() int\n\tHeader() http.Header\n\tBody() []byte\n}\n\ntype WriterRecorder struct {\n\thttp.ResponseWriter\n\tstatus int\n\tbody   bytes.Buffer\n}\n\nfunc (w *WriterRecorder) WriteHeader(status int) {\n\tw.ResponseWriter.WriteHeader(status)\n\tw.status = status\n}\n\n\n\nfunc (w *WriterRecorder) Body() []byte {\n\treturn w.body.Bytes()\n}\n\nfunc (w *WriterRecorder) Status() int {\n\tif w.status == 0 {\n\t\treturn 200\n\t}\n\treturn w.status\n}\n\nfunc (w *WriterRecorder) Write(body []byte) (n int, err error) ", "output": "{\n\tif n, err := w.body.Write(body); err != nil {\n\t\treturn n, err\n\t}\n\n\treturn w.ResponseWriter.Write(body)\n}"}
{"input": "package client\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc dump(v interface{}) {\n\tencodeJSON(os.Stdout, v)\n}\n\n\n\nfunc encodeJSON(w io.Writer, v interface{}) ", "output": "{\n\tenc := json.NewEncoder(w)\n\n\tenc.SetIndent(\"\", \"  \")\n\n\tenc.Encode(v)\n}"}
{"input": "package profile\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/pingcap/tidb/util/kvcache\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n\n\ntype mockCacheKey struct {\n\thash []byte\n\tkey  int64\n}\n\nfunc (mk *mockCacheKey) Hash() []byte {\n\tif mk.hash != nil {\n\t\treturn mk.hash\n\t}\n\tmk.hash = make([]byte, 8)\n\tfor i := uint(0); i < 8; i++ {\n\t\tmk.hash[i] = byte((mk.key >> ((i - 1) * 8)) & 0xff)\n\t}\n\treturn mk.hash\n}\n\nfunc newMockHashKey(key int64) *mockCacheKey {\n\treturn &mockCacheKey{\n\t\tkey: key,\n\t}\n}\n\nfunc getRandomString(l int) string {\n\tstr := \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\tbytes := []byte(str)\n\tresult := []byte{}\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\tfor i := 0; i < l; i++ {\n\t\tresult = append(result, bytes[r.Intn(len(bytes))])\n\t}\n\treturn string(result)\n}\n\nfunc TestHeapProfileRecorder(t *testing.T) ", "output": "{\n\tt.Parallel()\n\n\tnum := 60000\n\tlru := kvcache.NewSimpleLRUCache(uint(num), 0, 0)\n\n\tkeys := make([]*mockCacheKey, num)\n\tfor i := 0; i < num; i++ {\n\t\tkeys[i] = newMockHashKey(int64(i))\n\t\tv := getRandomString(10)\n\t\tlru.Put(keys[i], v)\n\t}\n\tbytes, err := col.getFuncMemUsage(kvcache.ProfileName)\n\trequire.Nil(t, err)\n\n\tvalueSize := int(unsafe.Sizeof(getRandomString(10)))\n\tassert.LessOrEqual(t, int64(valueSize*num), bytes)\n\tfor _, k := range lru.Keys() {\n\t\tassert.Len(t, k.Hash(), 8)\n\t}\n\tfor _, v := range lru.Values() {\n\t\tassert.Len(t, v.(string), 10)\n\t}\n}"}
{"input": "package bootstrap\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"encoding/pem\"\n\n\t\"github.com/flynn/flynn/pkg/tlscert\"\n)\n\ntype GenTLSCertAction struct {\n\tID    string   `json:\"id\"`\n\tHosts []string `json:\"hosts\"`\n\n\tCACert     string `json:\"ca_cert\"`\n\tCert       string `json:\"cert\"`\n\tPrivateKey string `json:\"key\"`\n}\n\n\n\nfunc (a *GenTLSCertAction) Run(s *State) (err error) {\n\tdata := &tlscert.Cert{}\n\ts.StepData[a.ID] = data\n\n\ta.CACert = interpolate(s, a.CACert)\n\ta.Cert = interpolate(s, a.Cert)\n\ta.PrivateKey = interpolate(s, a.PrivateKey)\n\tif a.CACert != \"\" && a.Cert != \"\" && a.PrivateKey != \"\" {\n\t\tdata.CACert = a.CACert\n\t\tdata.Cert = a.Cert\n\t\tdata.PrivateKey = a.PrivateKey\n\n\t\tb, _ := pem.Decode([]byte(data.Cert))\n\t\tsha := sha256.Sum256(b.Bytes)\n\t\tdata.Pin = base64.StdEncoding.EncodeToString(sha[:])\n\t\treturn nil\n\t}\n\n\tfor i, h := range a.Hosts {\n\t\ta.Hosts[i] = interpolate(s, h)\n\t}\n\tc, err := tlscert.Generate(a.Hosts)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdata.CACert = c.CACert\n\tdata.Cert = c.Cert\n\tdata.Pin = c.Pin\n\tdata.PrivateKey = c.PrivateKey\n\n\treturn err\n}\n\nfunc init() ", "output": "{\n\tRegister(\"gen-tls-cert\", &GenTLSCertAction{})\n}"}
{"input": "package topology\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\tproto \"github.com/Cloud-Foundations/Dominator/proto/fleetmanager\"\n)\n\nfunc splitPath(path string) []string {\n\treturn strings.Split(path, string(os.PathSeparator))\n}\n\nfunc (t *Topology) findDirectory(dirname string) (*Directory, error) {\n\tdirectory := t.Root\n\tif dirname == \"\" {\n\t\treturn directory, nil\n\t}\n\tfor list := splitPath(dirname); len(list) > 0; {\n\t\tif subdir, ok := directory.nameToDirectory[list[0]]; !ok {\n\t\t\treturn nil, fmt.Errorf(\"directory: %s not found\", dirname)\n\t\t} else {\n\t\t\tdirectory = subdir\n\t\t\tlist = list[1:]\n\t\t}\n\t}\n\treturn directory, nil\n}\n\n\n\nfunc (directory *Directory) listMachines() []*proto.Machine {\n\tmachines := directory.Machines\n\tfor _, subdir := range directory.Directories {\n\t\tmachines = append(machines, subdir.listMachines()...)\n\t}\n\treturn machines\n}\n\nfunc (t *Topology) listMachines(dirname string) ([]*proto.Machine, error) ", "output": "{\n\tdirectory, err := t.findDirectory(dirname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn directory.listMachines(), nil\n}"}
{"input": "package agent\n\nimport (\n\t\"sync\"\n)\n\n\n\ntype LogHandler interface {\n\tHandleLog(string)\n}\n\n\n\n\ntype logWriter struct {\n\tsync.Mutex\n\tlogs     []string\n\tindex    int\n\thandlers map[LogHandler]struct{}\n}\n\n\nfunc NewLogWriter(buf int) *logWriter {\n\treturn &logWriter{\n\t\tlogs:     make([]string, buf),\n\t\tindex:    0,\n\t\thandlers: make(map[LogHandler]struct{}),\n\t}\n}\n\n\n\nfunc (l *logWriter) RegisterHandler(lh LogHandler) {\n\tl.Lock()\n\tdefer l.Unlock()\n\n\tif _, ok := l.handlers[lh]; ok {\n\t\treturn\n\t}\n\n\tl.handlers[lh] = struct{}{}\n\n\tif l.logs[l.index] != \"\" {\n\t\tfor i := l.index; i < len(l.logs); i++ {\n\t\t\tlh.HandleLog(l.logs[i])\n\t\t}\n\t}\n\tfor i := 0; i < l.index; i++ {\n\t\tlh.HandleLog(l.logs[i])\n\t}\n}\n\n\n\n\n\nfunc (l *logWriter) Write(p []byte) (n int, err error) {\n\tl.Lock()\n\tdefer l.Unlock()\n\n\tn = len(p)\n\tif p[n-1] == '\\n' {\n\t\tp = p[:n-1]\n\t}\n\n\tl.logs[l.index] = string(p)\n\tl.index = (l.index + 1) % len(l.logs)\n\n\tfor lh, _ := range l.handlers {\n\t\tlh.HandleLog(string(p))\n\t}\n\treturn\n}\n\nfunc (l *logWriter) DeregisterHandler(lh LogHandler) ", "output": "{\n\tl.Lock()\n\tdefer l.Unlock()\n\tdelete(l.handlers, lh)\n}"}
{"input": "package os\n\nimport (\n\t\"github.com/kardianos/osext\"\n\t\"runtime\"\n)\n\ntype OS string\n\nconst (\n\tLINUX   OS = \"linux\"\n\tDARWIN  OS = \"darwin\"\n\tWINDOWS OS = \"windows\"\n)\n\nfunc (t OS) String() string {\n\treturn string(t)\n}\n\nfunc CurrentOS() OS {\n\tswitch runtime.GOOS {\n\tcase \"windows\":\n\t\treturn WINDOWS\n\tcase \"darwin\":\n\t\treturn DARWIN\n\tcase \"linux\":\n\t\treturn LINUX\n\t}\n\tpanic(\"Unexpected OS type\")\n}\n\n\n\nfunc CurrentExecutable() (string, error) ", "output": "{\n\tcurrentExec, err := osext.Executable()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn currentExec, nil\n}"}
{"input": "package http\n\nimport (\n\t\"go-common/app/admin/main/app/model/language\"\n\tbm \"go-common/library/net/http/blademaster\"\n)\n\n\n\n\n\nfunc langByID(c *bm.Context) {\n\tv := &language.Param{}\n\tif err := c.Bind(v); err != nil {\n\t\treturn\n\t}\n\tc.JSON(langSvc.LangByID(c, v.ID))\n}\n\n\nfunc addOrup(c *bm.Context) {\n\tvar (\n\t\terr error\n\t\tv   = &language.Param{}\n\t)\n\tif err = c.Bind(v); err != nil {\n\t\treturn\n\t}\n\tif v.ID > 0 {\n\t\terr = langSvc.Update(c, v)\n\t} else {\n\t\terr = langSvc.Insert(c, v)\n\t}\n\tc.JSON(nil, err)\n}\n\nfunc languages(c *bm.Context) ", "output": "{\n\tc.JSON(langSvc.Languages(c))\n}"}
{"input": "package cmd\n\nimport (\n\tboshdir \"github.com/cloudfoundry/bosh-cli/director\"\n\tboshui \"github.com/cloudfoundry/bosh-cli/ui\"\n)\n\ntype ManifestCmd struct {\n\tui         boshui.UI\n\tdeployment boshdir.Deployment\n}\n\nfunc NewManifestCmd(ui boshui.UI, deployment boshdir.Deployment) ManifestCmd {\n\treturn ManifestCmd{ui: ui, deployment: deployment}\n}\n\n\n\nfunc (c ManifestCmd) Run() error ", "output": "{\n\tmanifest, err := c.deployment.Manifest()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.ui.PrintBlock(manifest)\n\n\treturn nil\n}"}
{"input": "package command\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/codegangsta/cli\"\n\t\"github.com/coreos/etcd/client\"\n)\n\n\n\n\n\nfunc getCommandFunc(c *cli.Context, ki client.KeysAPI) {\n\tif len(c.Args()) == 0 {\n\t\thandleError(ExitBadArgs, errors.New(\"key required\"))\n\t}\n\n\tkey := c.Args()[0]\n\tsorted := c.Bool(\"sort\")\n\tquorum := c.Bool(\"quorum\")\n\n\tctx, cancel := contextWithTotalTimeout(c)\n\tresp, err := ki.Get(ctx, key, &client.GetOptions{Sort: sorted, Quorum: quorum})\n\tcancel()\n\tif err != nil {\n\t\thandleError(ExitServerError, err)\n\t}\n\n\tif resp.Node.Dir {\n\t\tfmt.Fprintln(os.Stderr, fmt.Sprintf(\"%s: is a directory\", resp.Node.Key))\n\t\tos.Exit(1)\n\t}\n\n\tprintResponseKey(resp, c.GlobalString(\"output\"))\n}\n\nfunc NewGetCommand() cli.Command ", "output": "{\n\treturn cli.Command{\n\t\tName:      \"get\",\n\t\tUsage:     \"retrieve the value of a key\",\n\t\tArgsUsage: \"<key>\",\n\t\tFlags: []cli.Flag{\n\t\t\tcli.BoolFlag{Name: \"sort\", Usage: \"returns result in sorted order\"},\n\t\t\tcli.BoolFlag{Name: \"quorum, q\", Usage: \"require quorum for get request\"},\n\t\t},\n\t\tAction: func(c *cli.Context) {\n\t\t\tgetCommandFunc(c, mustNewKeyAPI(c))\n\t\t},\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/verdverm/frisby\"\n)\n\nfunc TestMain(m *testing.M) {\n\tsetup()\n\tretCode := m.Run()\n\tos.Exit(retCode)\n}\n\n\n\nfunc TestPing(t *testing.T) {\n\terrs := frisby.Create(\"Test ping\").\n\t\tGet(\"http://localhost:5025/ping\").\n\t\tSend().\n\t\tExpectStatus(http.StatusOK).\n\t\tExpectContent(\"pong\").\n\t\tAfterText(\n\t\tfunc(F *frisby.Frisby, text string, err error) {\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, \"pong\", text)\n\t\t}).\n\t\tErrors()\n\n\tfor _, err := range errs {\n\t\tassert.Nil(t, err)\n\t}\n}\n\nfunc setup() ", "output": "{\n\tgo main()\n\ttime.Sleep(1 * time.Second)\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\ntype JProxyFilter struct {\n\n\tID string `json:\"_id,omitempty\"`\n\n\tCreatedAt strfmt.Date `json:\"createdAt,omitempty\"`\n\n\tModifiedAt strfmt.Date `json:\"modifiedAt,omitempty\"`\n\n\tName *string `json:\"name\"`\n\n\tOwner string `json:\"owner,omitempty\"`\n\n\tRules []interface{} `json:\"rules\"`\n}\n\n\nfunc (m *JProxyFilter) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateName(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateRules(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n\n\nfunc (m *JProxyFilter) validateRules(formats strfmt.Registry) error {\n\n\tif swag.IsZero(m.Rules) { \n\t\treturn nil\n\t}\n\n\tfor i := 0; i < len(m.Rules); i++ {\n\n\t}\n\n\treturn nil\n}\n\nfunc (m *JProxyFilter) validateName(formats strfmt.Registry) error ", "output": "{\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package bson\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n)\n\nconst (\n\tMinDocumentSize = 5\n\n\tMaxDocumentSize = 16777216\n)\n\n\n\ntype ErrInvalidDocumentSize struct {\n\tDocumentSize int32\n}\n\nfunc (e ErrInvalidDocumentSize) Error() string {\n\treturn fmt.Sprintf(\"invalid document size %d\", e.DocumentSize)\n}\n\n\ntype Decoder struct {\n\tsource io.Reader\n}\n\n\n\nfunc NewDecoder(source io.Reader) *Decoder {\n\treturn &Decoder{source: source}\n}\n\n\n\nfunc (dec *Decoder) Decode(v interface{}) (err error) {\n\tvar docSize int32\n\tif err = binary.Read(dec.source, binary.LittleEndian, &docSize); err != nil {\n\t\treturn\n\t}\n\n\tif docSize < MinDocumentSize || docSize > MaxDocumentSize {\n\t\treturn ErrInvalidDocumentSize{DocumentSize: docSize}\n\t}\n\n\tdocBuffer := bytes.NewBuffer(make([]byte, 0, docSize))\n\tif err = binary.Write(docBuffer, binary.LittleEndian, docSize); err != nil {\n\t\treturn\n\t}\n\n\tif _, err = io.CopyN(docBuffer, dec.source, int64(docSize-4)); err != nil {\n\t\treturn\n\t}\n\n\tdefer handleErr(&err)\n\treturn Unmarshal(docBuffer.Bytes(), v)\n}\n\n\ntype Encoder struct {\n\ttarget io.Writer\n}\n\n\nfunc NewEncoder(target io.Writer) *Encoder {\n\treturn &Encoder{target: target}\n}\n\n\n\n\n\nfunc (enc *Encoder) Encode(v interface{}) error ", "output": "{\n\tdata, err := Marshal(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = enc.target.Write(data)\n\treturn err\n}"}
{"input": "package util\n\ntype Observable []Observer\n\nfunc (observers *Observable) Attach(observer Observer) {\n\t*observers = append(*observers, observer)\n}\n\n\n\nfunc (observers Observable) NotifyAll(args ...interface{}) ", "output": "{\n\tfor _, observer := range observers {\n\t\tobserver.Update(args...)\n\t}\n}"}
{"input": "package configmap\n\nimport (\n\t\"testing\"\n\n\tgenericapirequest \"k8s.io/apiserver/pkg/request\"\n\t\"k8s.io/kubernetes/pkg/api\"\n\tapitesting \"k8s.io/kubernetes/pkg/api/testing\"\n)\n\nfunc TestConfigMapStrategy(t *testing.T) {\n\tctx := genericapirequest.NewDefaultContext()\n\tif !Strategy.NamespaceScoped() {\n\t\tt.Errorf(\"ConfigMap must be namespace scoped\")\n\t}\n\tif Strategy.AllowCreateOnUpdate() {\n\t\tt.Errorf(\"ConfigMap should not allow create on update\")\n\t}\n\n\tcfg := &api.ConfigMap{\n\t\tObjectMeta: api.ObjectMeta{\n\t\t\tName:      \"valid-config-data\",\n\t\t\tNamespace: api.NamespaceDefault,\n\t\t},\n\t\tData: map[string]string{\n\t\t\t\"foo\": \"bar\",\n\t\t},\n\t}\n\n\tStrategy.PrepareForCreate(ctx, cfg)\n\n\terrs := Strategy.Validate(ctx, cfg)\n\tif len(errs) != 0 {\n\t\tt.Errorf(\"unexpected error validating %v\", errs)\n\t}\n\n\tnewCfg := &api.ConfigMap{\n\t\tObjectMeta: api.ObjectMeta{\n\t\t\tName:            \"valid-config-data-2\",\n\t\t\tNamespace:       api.NamespaceDefault,\n\t\t\tResourceVersion: \"4\",\n\t\t},\n\t\tData: map[string]string{\n\t\t\t\"invalidKey\": \"updatedValue\",\n\t\t},\n\t}\n\n\tStrategy.PrepareForUpdate(ctx, newCfg, cfg)\n\n\terrs = Strategy.ValidateUpdate(ctx, newCfg, cfg)\n\tif len(errs) == 0 {\n\t\tt.Errorf(\"Expected a validation error\")\n\t}\n}\n\n\n\nfunc TestSelectableFieldLabelConversions(t *testing.T) ", "output": "{\n\tapitesting.TestSelectableFieldLabelConversionsOfKind(t,\n\t\tapi.Registry.GroupOrDie(api.GroupName).GroupVersion.String(),\n\t\t\"ConfigMap\",\n\t\tConfigMapToSelectableFields(&api.ConfigMap{}),\n\t\tnil,\n\t)\n}"}
{"input": "package v1beta1\n\nimport (\n\t\"context\"\n\n\t\"knative.dev/pkg/apis\"\n\t\"knative.dev/pkg/kmp\"\n)\n\nfunc (et *EventType) Validate(ctx context.Context) *apis.FieldError {\n\treturn et.Spec.Validate(ctx).ViaField(\"spec\")\n}\n\nfunc (ets *EventTypeSpec) Validate(ctx context.Context) *apis.FieldError {\n\tvar errs *apis.FieldError\n\tif ets.Type == \"\" {\n\t\tfe := apis.ErrMissingField(\"type\")\n\t\terrs = errs.Also(fe)\n\t}\n\treturn errs\n}\n\n\n\nfunc (et *EventType) CheckImmutableFields(ctx context.Context, original *EventType) *apis.FieldError ", "output": "{\n\tif original == nil {\n\t\treturn nil\n\t}\n\n\tif diff, err := kmp.ShortDiff(original.Spec, et.Spec); err != nil {\n\t\treturn &apis.FieldError{\n\t\t\tMessage: \"Failed to diff EventType\",\n\t\t\tPaths:   []string{\"spec\"},\n\t\t\tDetails: err.Error(),\n\t\t}\n\t} else if diff != \"\" {\n\t\treturn &apis.FieldError{\n\t\t\tMessage: \"Immutable fields changed (-old +new)\",\n\t\t\tPaths:   []string{\"spec\"},\n\t\t\tDetails: diff,\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/astaxie/beego\"\n)\n\ntype MainController struct {\n\tbeego.Controller\n}\n\n\n\nfunc (this *MainController) Get() ", "output": "{\n\tthis.Layout = \"main_layout.html\"\n\tthis.TplName = \"index.tpl\"\n}"}
{"input": "package runtime\n\n\ntype Thread struct {\n\tpc    int\n\tstack *Stack\n}\n\n\nfunc NewThread() *Thread {\n\treturn &Thread{\n\t\tstack:newStack(1024),\n\t}\n}\n\nfunc (self *Thread) PC() int {\n\treturn self.pc\n}\n\nfunc (self *Thread) SetPC(pc int) {\n\tself.pc = pc\n}\n\n\nfunc (self *Thread) PushFrame(frame *Frame) {\n\tself.stack.push(frame)\n}\n\n\nfunc (self *Thread) PopFrame() *Frame {\n\treturn self.stack.pop()\n}\n\n\n\n\nfunc (self *Thread) NewFrame(maxLocals, maxStack uint) *Frame {\n\treturn newFrame(self, maxLocals, maxStack)\n}\n\nfunc (self *Thread) CurrentFrame() *Frame ", "output": "{\n\treturn self.stack.top()\n}"}
{"input": "package logic\n\nimport (\n\t\"ca/common\"\n\t\"ca/conf\"\n\t\"github.com/golang/glog\"\n\t\"net\"\n\t\"net/http\"\n)\n\n\n\nfunc startHttpServe() {\n\tglog.Info(\" start Http Serve : \", conf.GetHttpAddrConf())\n\thttp.HandleFunc(\"/getkey\", GetKeyHandler)\n\thttp.HandleFunc(\"/\", HomeHandler)\n\terr := http.ListenAndServe(conf.GetHttpAddrConf(), nil)\n\tcommon.CheckErr(err)\n}\n\nfunc startUDPServe() {\n\n\tglog.Info(\" start UDP Serve : \", conf.GetUDPAddrConf())\n\tServerAddr, err := net.ResolveUDPAddr(\"udp\", conf.GetUDPAddrConf())\n\tcommon.CheckErr(err)\n\tServerConn, err := net.ListenUDP(\"udp\", ServerAddr)\n\tcommon.CheckErr(err)\n\tdefer ServerConn.Close()\n\tbuf := make([]byte, 1024)\n\tfor {\n\t\tn, addr, err := ServerConn.ReadFromUDP(buf)\n\t\tglog.Info(\"Received rpc udp data from \", addr)\n\t\tif err != nil {\n\t\t\tglog.Info(\"Read udp error: \", err)\n\t\t}\n\n\t\tgo HandleUDPData(buf, n, ServerConn, addr)\n\t}\n}\n\nfunc StartServe() ", "output": "{\n\tglog.Info(\" logic start serve...\")\n\n\tgo startHttpServe()\n\n\tgo startUDPServe()\n}"}
{"input": "package configv3_test\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n)\n\n\n\nfunc setup() string {\n\thomeDir, err := ioutil.TempDir(\"\", \"cli-config-tests\")\n\tExpect(err).NotTo(HaveOccurred())\n\terr = os.Setenv(\"CF_HOME\", homeDir)\n\tExpect(err).NotTo(HaveOccurred())\n\treturn homeDir\n}\n\nfunc teardown(homeDir string) {\n\tif homeDir != \"\" {\n\t\terr := os.RemoveAll(homeDir)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\terr = os.Unsetenv(\"CF_HOME\")\n\t\tExpect(err).ToNot(HaveOccurred())\n\t}\n}\n\nfunc setConfig(homeDir string, rawConfig string) {\n\terr := os.MkdirAll(filepath.Join(homeDir, \".cf\"), 0777)\n\tExpect(err).ToNot(HaveOccurred())\n\terr = ioutil.WriteFile(filepath.Join(homeDir, \".cf\", \"config.json\"), []byte(rawConfig), 0644)\n\tExpect(err).ToNot(HaveOccurred())\n}\n\nfunc setPluginConfig(pluginDir string, rawConfig string) {\n\terr := os.MkdirAll(filepath.Join(pluginDir), 0777)\n\tExpect(err).ToNot(HaveOccurred())\n\terr = ioutil.WriteFile(filepath.Join(pluginDir, \"config.json\"), []byte(rawConfig), 0644)\n\tExpect(err).ToNot(HaveOccurred())\n}\n\nfunc TestConfig(t *testing.T) ", "output": "{\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Config Suite\")\n}"}
{"input": "package buffactory\n\nimport (\n\t\"testing\"\n)\n\nfunc TestInsertData(t *testing.T) {\n\tstats := make(Stats, 0, 3)\n\tstats.InsertData(0)\n\tstats.InsertData(1)\n\tstats.InsertData(2)\n\tstats.InsertData(3)\n\tfor i, s := range stats {\n\t\tif int64(i) != s {\n\t\t\tt.Fatal(\"numbers don't match\", i , s, []int64(stats))\n\t\t}\n\t}\n}\n\n\n\nfunc TestStats(t *testing.T) ", "output": "{\n\tstats := make(Stats, 0, 3)\n\tstats.InsertData(1)\n\tstats.InsertData(2)\n\tstats.InsertData(3)\n\tif stats.Min() != 1 {\n\t\tt.Fatal(\"Min failed\", stats.Min())\n\t}\n\tif stats.Max() != 3 {\n\t\tt.Fatal(\"Max failed\", stats.Max())\n\t}\n\tif stats.Average() != 2.0 {\n\t\tt.Fatal(\"Average failed\", stats.Average())\n\t}\n\tif stats.StdDev() != 1.0 {\n\t\tt.Fatal(\"StdDev failed\", stats.StdDev())\n\t}\n}"}
{"input": "package fs\n\nimport (\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/fscommon\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n)\n\ntype NetPrioGroup struct {\n}\n\nfunc (s *NetPrioGroup) Name() string {\n\treturn \"net_prio\"\n}\n\n\n\nfunc (s *NetPrioGroup) Set(path string, r *configs.Resources) error {\n\tfor _, prioMap := range r.NetPrioIfpriomap {\n\t\tif err := fscommon.WriteFile(path, \"net_prio.ifpriomap\", prioMap.CgroupString()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (s *NetPrioGroup) GetStats(path string, stats *cgroups.Stats) error {\n\treturn nil\n}\n\nfunc (s *NetPrioGroup) Apply(path string, d *cgroupData) error ", "output": "{\n\treturn join(path, d.pid)\n}"}
{"input": "package remote\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"go.uber.org/atomic\"\n)\n\n\ntype ewmaRate struct {\n\tnewEvents atomic.Int64\n\n\talpha    float64\n\tinterval time.Duration\n\tlastRate float64\n\tinit     bool\n\tmutex    sync.Mutex\n}\n\n\n\n\n\n\nfunc (r *ewmaRate) rate() float64 {\n\tr.mutex.Lock()\n\tdefer r.mutex.Unlock()\n\treturn r.lastRate\n}\n\n\nfunc (r *ewmaRate) tick() {\n\tnewEvents := r.newEvents.Swap(0)\n\tinstantRate := float64(newEvents) / r.interval.Seconds()\n\n\tr.mutex.Lock()\n\tdefer r.mutex.Unlock()\n\n\tif r.init {\n\t\tr.lastRate += r.alpha * (instantRate - r.lastRate)\n\t} else if newEvents > 0 {\n\t\tr.init = true\n\t\tr.lastRate = instantRate\n\t}\n}\n\n\nfunc (r *ewmaRate) incr(incr int64) {\n\tr.newEvents.Add(incr)\n}\n\nfunc newEWMARate(alpha float64, interval time.Duration) *ewmaRate ", "output": "{\n\treturn &ewmaRate{\n\t\talpha:    alpha,\n\t\tinterval: interval,\n\t}\n}"}
{"input": "package uptime_minutes\n\nimport (\n\t\"github.com/poblahblahblah/gofigure/lib/uptime_seconds\"\n\t\"strconv\"\n)\n\n\n\nfunc Load() string ", "output": "{\n\tuptime_in_seconds := uptime_seconds.Load()\n\tuptimeInt, err := strconv.Atoi(uptime_in_seconds)\n\tuptime_in_minutes := (uptimeInt / 60)\n\tif err != nil {\n\t\treturn string(\"\")\n\t}\n\n\treturn strconv.Itoa(uptime_in_minutes)\n\n}"}
{"input": "package util\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype CountdownLatch struct {\n\tzeroChan chan bool\n\n\tctx   context.Context\n\tonce  sync.Once\n\tm     sync.Mutex\n\tcount int32\n}\n\nfunc NewCountdownLatch(ctx context.Context, count int) *CountdownLatch {\n\treturn &CountdownLatch{\n\t\tmake(chan bool, 1),\n\t\tctx,\n\t\tsync.Once{},\n\t\tsync.Mutex{},\n\t\tint32(count),\n\t}\n}\n\n\nfunc (c *CountdownLatch) CountDown() {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tc.count -= 1\n\tif c.count <= 0 {\n\t\tc.once.Do(func() {\n\t\t\tclose(c.zeroChan)\n\t\t})\n\t\tc.count = 0\n\t}\n}\n\n\n\n\nfunc (c *CountdownLatch) Wait() ", "output": "{\n\tselect {\n\tcase <-c.zeroChan:\n\tcase <-c.ctx.Done():\n\t}\n}"}
{"input": "package soundcloud\n\nimport (\n\t\"net/url\"\n)\n\ntype PlaylistApi struct {\n\tplaylistEndpoint\n}\n\nfunc (api *Api) Playlists(params url.Values) ([]*Playlist, error) {\n\tret := make([]*Playlist, 0)\n\terr := api.get(\"/playlists\", params, &ret)\n\treturn ret, err\n}\n\n\n\nfunc (api *Api) Playlist(id uint64) *PlaylistApi ", "output": "{\n\treturn &PlaylistApi{*api.newPlaylistEndpoint(\"playlists\", id)}\n}"}
{"input": "package main\n\nimport (\n  \"container/list\"\n\n  \"github.com/go-gl/gl/v4.1-core/gl\"\n  \"github.com/go-gl/mathgl/mgl32\"\n)\n\n\ntype MatrixStack struct {\n  Current *mgl32.Mat4\n  Stack   *list.List\n}\n\n\ntype MatrixUniforms struct {\n  Model   int32\n  Normal  int32\n  Texture int32\n}\n\n\nvar InstanceMatrixStack MatrixStack\n\n\nvar InstanceMatrixUniforms MatrixUniforms\n\nfunc initializeMatrix() {\n  identityMatrix := mgl32.Ident4()\n\n  setMatrixStack(list.New())\n  setMatrix(&identityMatrix)\n}\n\nfunc getMatrix() (*mgl32.Mat4) {\n  return InstanceMatrixStack.Current\n}\n\nfunc setMatrix(matrix *mgl32.Mat4) {\n  InstanceMatrixStack.Current = matrix\n}\n\nfunc getMatrixStack() (*list.List) {\n  return InstanceMatrixStack.Stack\n}\n\nfunc setMatrixStack(matrixStack *list.List) {\n  InstanceMatrixStack.Stack = matrixStack\n}\n\nfunc pushMatrix() {\n  \n  currentMatrix := *getMatrix()\n\n  getMatrixStack().PushBack(currentMatrix)\n\n  \n  newMatrix := mgl32.Ident4().Mul4(currentMatrix)\n\n  setMatrix(&newMatrix)\n}\n\n\n\nfunc getMatrixUniforms() (*MatrixUniforms) {\n  return &InstanceMatrixUniforms\n}\n\nfunc setMatrixUniforms(program uint32) {\n  matrixUniforms := getMatrixUniforms()\n\n  matrixUniforms.Model = gl.GetUniformLocation(program, gl.Str(\"modelUniform\\x00\"))\n  matrixUniforms.Normal = gl.GetUniformLocation(program, gl.Str(\"normalUniform\\x00\"))\n  matrixUniforms.Texture = gl.GetUniformLocation(program, gl.Str(\"textureUniform\\x00\"))\n}\n\nfunc popMatrix() ", "output": "{\n  if getMatrixStack().Len() == 0 {\n    panic(\"Cannot pop: matrix stack is empty\")\n  }\n\n  lastElementList := getMatrixStack().Back()\n\n  if previousMatrix, ok := (lastElementList.Value).(mgl32.Mat4); ok {\n    \n    setMatrix(&previousMatrix)\n\n    \n    getMatrixStack().Remove(lastElementList)\n  } else {\n    panic(\"Cannot pop: error\")\n  }\n}"}
{"input": "package leetcode\n\n\n\n\nfunc myPow(x float64, n int) float64 {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tflag := false\n\tif n > 0 {\n\t\tflag = true\n\t} else {\n\t\tn = -n\n\t}\n\tres := pow(x, n)\n\tif !flag {\n\t\tres = 1 / res\n\t}\n\treturn res\n}\n\n\n\nfunc pow(x float64, n int) float64 ", "output": "{\n\tif n == 1 {\n\t\treturn x\n\t}\n\tres := pow(x*x, n/2)\n\tif n%2 == 1 {\n\t\tres *= x\n\t}\n\treturn res\n}"}
{"input": "package errors\n\nimport (\n\t\"fmt\"\n\n\t. \"github.com/nttlabs/cli/cf/i18n\"\n)\n\ntype HttpError interface {\n\terror\n\tStatusCode() int   \n\tErrorCode() string \n}\n\ntype baseHttpError struct {\n\tstatusCode   int\n\tapiErrorCode string\n\tdescription  string\n}\n\ntype HttpNotFoundError struct {\n\tbaseHttpError\n}\n\nfunc NewHttpError(statusCode int, code string, description string) error {\n\terr := baseHttpError{\n\t\tstatusCode:   statusCode,\n\t\tapiErrorCode: code,\n\t\tdescription:  description,\n\t}\n\tswitch statusCode {\n\tcase 404:\n\t\treturn &HttpNotFoundError{err}\n\tdefault:\n\t\treturn &err\n\t}\n}\n\n\n\nfunc (err *baseHttpError) Error() string {\n\treturn fmt.Sprintf(T(\"Server error, status code: {{.ErrStatusCode}}, error code: {{.ErrApiErrorCode}}, message: {{.ErrDescription}}\",\n\t\tmap[string]interface{}{\"ErrStatusCode\": err.statusCode,\n\t\t\t\"ErrApiErrorCode\": err.apiErrorCode,\n\t\t\t\"ErrDescription\":  err.description}),\n\t)\n}\n\nfunc (err *baseHttpError) ErrorCode() string {\n\treturn err.apiErrorCode\n}\n\nfunc (err *baseHttpError) StatusCode() int ", "output": "{\n\treturn err.statusCode\n}"}
{"input": "package gopter\n\nimport \"reflect\"\n\ntype GenResult struct {\n\tLabels     []string\n\tShrinker   Shrinker\n\tResultType reflect.Type\n\tresult     interface{}\n\tSieve      func(interface{}) bool\n}\n\n\n\n\n\n\n\n\n\nfunc NewEmptyResult(resultType reflect.Type) *GenResult {\n\treturn &GenResult{\n\t\tResultType: resultType,\n\t\tShrinker:   NoShrinker,\n\t}\n}\n\n\n\n\nfunc (r *GenResult) Retrieve() (interface{}, bool) {\n\tif (r.Sieve == nil && r.result != nil) || (r.Sieve != nil && r.Sieve(r.result)) {\n\t\treturn r.result, true\n\t}\n\treturn nil, false\n}\n\n\n\n\nfunc (r *GenResult) RetrieveAsValue() (reflect.Value, bool) {\n\tif r.result != nil && (r.Sieve == nil || r.Sieve(r.result)) {\n\t\treturn reflect.ValueOf(r.result), true\n\t} else if r.result == nil && r.Sieve != nil && r.Sieve(r.result) {\n\t\treturn reflect.Zero(r.ResultType), true\n\t}\n\treturn reflect.Zero(r.ResultType), false\n}\n\nfunc NewGenResult(result interface{}, shrinker Shrinker) *GenResult ", "output": "{\n\treturn &GenResult{\n\t\tShrinker:   shrinker,\n\t\tResultType: reflect.TypeOf(result),\n\t\tresult:     result,\n\t}\n}"}
{"input": "package database\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype UpdateCloudVmClusterRequest struct {\n\n\tCloudVmClusterId *string `mandatory:\"true\" contributesTo:\"path\" name:\"cloudVmClusterId\"`\n\n\tUpdateCloudVmClusterDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request UpdateCloudVmClusterRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request UpdateCloudVmClusterRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request UpdateCloudVmClusterRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype UpdateCloudVmClusterResponse struct {\n\n\tRawResponse *http.Response\n\n\tCloudVmCluster `presentIn:\"body\"`\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response UpdateCloudVmClusterResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response UpdateCloudVmClusterResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request UpdateCloudVmClusterRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) ", "output": "{\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/satori/go.uuid\"\n)\n\ntype MiddlewareContextVars struct {\n\t*BaseMiddleware\n}\n\n\n\nfunc (m *MiddlewareContextVars) IsEnabledForSpec() bool {\n\treturn m.Spec.EnableContextVars\n}\n\n\nfunc (m *MiddlewareContextVars) ProcessRequest(w http.ResponseWriter, r *http.Request, _ interface{}) (error, int) {\n\n\tif !m.Spec.EnableContextVars {\n\t\treturn nil, 200\n\t}\n\n\tcopiedRequest := CopyHttpRequest(r)\n\tcontextDataObject := make(map[string]interface{})\n\n\tcopiedRequest.ParseForm()\n\n\tcontextDataObject[\"request_data\"] = copiedRequest.Form\n\n\tcontextDataObject[\"headers\"] = map[string][]string(copiedRequest.Header)\n\n\tfor hname, vals := range copiedRequest.Header {\n\t\tn := \"headers_\" + strings.Replace(hname, \"-\", \"_\", -1)\n\t\tcontextDataObject[n] = vals[0]\n\t}\n\n\tsegmentedPathArray := strings.Split(copiedRequest.URL.Path, \"/\")\n\tcontextDataObject[\"path_parts\"] = segmentedPathArray\n\n\tcontextDataObject[\"path\"] = copiedRequest.URL.Path\n\n\tcontextDataObject[\"remote_addr\"] = copiedRequest.RemoteAddr\n\n\tcontextDataObject[\"request_id\"] = uuid.NewV4().String()\n\n\tctxSetData(r, contextDataObject)\n\n\treturn nil, 200\n}\n\nfunc (m *MiddlewareContextVars) Name() string ", "output": "{\n\treturn \"MiddlewareContextVars\"\n}"}
{"input": "package main\n\ntype Element struct {\n\tValue interface{}\n\tnext  *Element\n}\n\ntype List struct {\n\te    Element\n\tsize int\n}\n\n\n\n\nfunc (l *List) Add(e, at *Element) *Element {\n       l.e.Value == at.Value\n}\n\nfunc (l *List) Remove() *Element {\n\n}\n\nfunc (l *List) Size() int {\n\treturn l.size\n}\n\nfunc main() {\n}\n\nfunc New() *List ", "output": "{\n\tl := new(List)\n        l.e.next = &l.e\n        l.size = 0\n\treturn l\n}"}
{"input": "package dic\n\nimport (\n\t\"bytes\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestConnectionTableAt(t *testing.T) {\n\tvar ct ConnectionTable\n\tconst (\n\t\trow = 4\n\t\tcol = 5\n\t)\n\tct.Row = row\n\tct.Col = col\n\tct.Vec = make([]int16, ct.Row*ct.Col)\n\tfor i := 0; i < row; i++ {\n\t\tfor j := 0; j < col; j++ {\n\t\t\tct.Vec[i*col+j] = int16(i*col + j)\n\t\t}\n\t}\n\tfor i := 0; i < row; i++ {\n\t\tfor j := 0; j < col; j++ {\n\t\t\texpected := int16(i*col + j)\n\t\t\tif r := ct.At(i, j); r != expected {\n\t\t\t\tt.Errorf(\"got %v, expected %v\", r, expected)\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nfunc TestConnectionTableWriteTo(t *testing.T) {\n\tct := ConnectionTable{\n\t\tRow: 2,\n\t\tCol: 3,\n\t\tVec: []int16{11, 12, 13, 21, 22, 23},\n\t}\n\tvar b bytes.Buffer\n\tn, err := ct.WriteTo(&b)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\tif n != int64(b.Len()) {\n\t\tt.Errorf(\"got %v, expected %v\", n, b.Len())\n\t}\n}\n\n\n\nfunc TestLoadConnectionTable(t *testing.T) ", "output": "{\n\tsrc := ConnectionTable{\n\t\tRow: 2,\n\t\tCol: 3,\n\t\tVec: []int16{11, 12, 13, 21, 22, 23},\n\t}\n\tvar b bytes.Buffer\n\t_, err := src.WriteTo(&b)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tdst, err := LoadConnectionTable(&b)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(src, dst) {\n\t\tt.Errorf(\"got %v, expected %v\", dst, src)\n\t}\n}"}
{"input": "package api\n\nimport (\n\t\"bufio\"\n\t\"net/http\"\n\t\"os\"\n\n\tl4g \"code.google.com/p/log4go\"\n\t\"github.com/gorilla/mux\"\n\n\t\"github.com/mattermost/platform/model\"\n\t\"github.com/mattermost/platform/utils\"\n)\n\n\n\nfunc getLogs(c *Context, w http.ResponseWriter, r *http.Request) {\n\n\tif !c.HasSystemAdminPermissions(\"getLogs\") {\n\t\treturn\n\t}\n\n\tvar lines []string\n\n\tif utils.Cfg.LogSettings.FileEnable {\n\n\t\tfile, err := os.Open(utils.Cfg.LogSettings.FileLocation)\n\t\tif err != nil {\n\t\t\tc.Err = model.NewAppError(\"getLogs\", \"Error reading log file\", err.Error())\n\t\t}\n\n\t\tdefer file.Close()\n\n\t\tscanner := bufio.NewScanner(file)\n\t\tfor scanner.Scan() {\n\t\t\tlines = append(lines, scanner.Text())\n\t\t}\n\t} else {\n\t\tlines = append(lines, \"\")\n\t}\n\n\tw.Write([]byte(model.ArrayToJson(lines)))\n}\n\nfunc InitAdmin(r *mux.Router) ", "output": "{\n\tl4g.Debug(\"Initializing admin api routes\")\n\n\tsr := r.PathPrefix(\"/admin\").Subrouter()\n\tsr.Handle(\"/logs\", ApiUserRequired(getLogs)).Methods(\"GET\")\n}"}
{"input": "package language\n\n\n\nconst (\n\tcurDigitBits = 3\n\tcurDigitMask = 1<<curDigitBits - 1\n\tcurRoundBits = 0 \n)\n\ntype currencyInfo int\n\nfunc mkCurrencyInfo(round, decimal int) string {\n\treturn string([]byte{byte(round<<curDigitBits | decimal)})\n}\n\nfunc (c currencyInfo) round() int {\n\treturn int(c >> curDigitBits)\n}\n\n\n\n\ntype langAliasType int8\n\nconst (\n\tlangDeprecated langAliasType = iota\n\tlangMacro\n\tlangLegacy\n\n\tlangAliasTypeUnknown langAliasType = -1\n)\n\nfunc (c currencyInfo) decimals() int ", "output": "{\n\treturn int(c & curDigitMask)\n}"}
{"input": "package libvirt\n\nimport (\n\t\"os\"\n\n\t\"github.com/hyperhq/runv/hypervisor/network\"\n\t\"github.com/hyperhq/runv/hypervisor/pod\"\n)\n\nfunc (ld *LibvirtDriver) BuildinNetwork() bool {\n\treturn true\n}\n\nfunc (ld *LibvirtDriver) InitNetwork(bIface, bIP string, disableIptables bool) error {\n\treturn network.InitNetwork(bIface, bIP, disableIptables)\n}\n\nfunc (lc *LibvirtContext) ConfigureNetwork(vmId, requestedIP string,\n\tmaps []pod.UserContainerPort, config pod.UserInterface) (*network.Settings, error) {\n\treturn network.Configure(vmId, requestedIP, true, maps, config)\n}\n\nfunc (lc *LibvirtContext) AllocateNetwork(vmId, requestedIP string,\n\tmaps []pod.UserContainerPort) (*network.Settings, error) {\n\treturn network.Allocate(vmId, requestedIP, true, maps)\n}\n\n\n\nfunc (lc *LibvirtContext) ReleaseNetwork(vmId, releasedIP string, maps []pod.UserContainerPort,\n\tfile *os.File) error ", "output": "{\n\treturn network.Release(vmId, releasedIP, maps, nil)\n}"}
{"input": "package koalanet\n\nimport \"testing\"\n\nvar t1 *testing.T\n\nvar tkm_arg1 int\n\ntype TestKoalanetMain struct {\n\tActor\n}\n\nfunc (tkm *TestKoalanetMain) Init(args interface{}, reply interface{}) error {\n\ttkm_arg1 = 2\n\treturn nil\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Benchmark_koalanet_send(b *testing.B) {\n\tRegActor(\"TestKoalanetMain\", func() IActor {\n\t\tactor := &TestKoalanetMain{}\n\t\tactor.InitActor()\n\t\tactor.RegMethod(\"Init\", actor.Init)\n\t\tactor.RegMethod(\"SendTest\", actor.SendTest)\n\t\treturn actor\n\t})\n\n\thTKM := NewActor(\"TestKoalanetMain\", nil)\n\n\tfor i := 0; i < b.N; i++ {\n\t\tSend(hTKM, \"SendTest\", nil)\n\t}\n\n\tKillActor(hTKM, false)\n\n\tWaitActorQuit(hTKM)\n}\n\nfunc (tkm *TestKoalanetMain) SendTest(args interface{}, reply interface{}) error ", "output": "{\n\n\treturn nil\n}"}
{"input": "package certrotation\n\nimport (\n\t\"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/api/meta\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n)\n\nconst (\n\tManagedCertificateTypeLabelName = \"auth.openshift.io/managed-certificate-type\"\n)\n\ntype CertificateType string\n\nvar (\n\tCertificateTypeCABundle CertificateType = \"ca-bundle\"\n\tCertificateTypeSigner   CertificateType = \"signer\"\n\tCertificateTypeTarget   CertificateType = \"target\"\n\tCertificateTypeUnknown  CertificateType = \"unknown\"\n)\n\n\n\n\n\n\n\nfunc LabelAsManagedSecret(secret *v1.Secret, certificateType CertificateType) {\n\tif secret.Labels == nil {\n\t\tsecret.Labels = map[string]string{}\n\t}\n\tsecret.Labels[ManagedCertificateTypeLabelName] = string(certificateType)\n}\n\n\nfunc CertificateTypeFromObject(obj runtime.Object) (CertificateType, error) {\n\taccesor, err := meta.Accessor(obj)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tactualLabels := accesor.GetLabels()\n\tif actualLabels == nil {\n\t\treturn CertificateTypeUnknown, nil\n\t}\n\n\tt := CertificateType(actualLabels[ManagedCertificateTypeLabelName])\n\tswitch t {\n\tcase CertificateTypeCABundle, CertificateTypeSigner, CertificateTypeTarget:\n\t\treturn t, nil\n\tdefault:\n\t\treturn CertificateTypeUnknown, nil\n\t}\n}\n\nfunc LabelAsManagedConfigMap(config *v1.ConfigMap, certificateType CertificateType) ", "output": "{\n\tif config.Labels == nil {\n\t\tconfig.Labels = map[string]string{}\n\t}\n\tconfig.Labels[ManagedCertificateTypeLabelName] = string(certificateType)\n}"}
{"input": "package persistentvolumeclaim\n\nimport (\n\t\"testing\"\n\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/api/legacyscheme\"\n\tapitesting \"k8s.io/kubernetes/pkg/api/testing\"\n\n\t_ \"k8s.io/kubernetes/pkg/api/testapi\"\n)\n\n\n\nfunc TestSelectableFieldLabelConversions(t *testing.T) ", "output": "{\n\tapitesting.TestSelectableFieldLabelConversionsOfKind(t,\n\t\tlegacyscheme.Registry.GroupOrDie(api.GroupName).GroupVersion.String(),\n\t\t\"PersistentVolumeClaim\",\n\t\tPersistentVolumeClaimToSelectableFields(&api.PersistentVolumeClaim{}),\n\t\tmap[string]string{\"name\": \"metadata.name\"},\n\t)\n}"}
{"input": "package crypto\n\nimport (\n  \"bytes\"\n  \"crypto/hmac\"\n  \"crypto/md5\"\n  \"crypto/sha1\"\n  \"encoding/base64\"\n  )\n\n\n\nfunc Encrypt(data []byte) []byte {\n  for index, b := range data {\n    data[index] = rot13(b)\n  }\n  return data\n}\n\nfunc Decrypt(data []byte) []byte {\n  for index, b := range data {\n    data[index] = rot13(b)\n  }\n  return data\n}\n\nfunc rot13(b byte) byte {\n  if 'a' <= b && b <= 'z' {\n    b = 'a' + ((b-'a')+13)%26\n  }\n  if 'A' <= b && b <= 'Z' {\n    b = 'A' + ((b-'A')+13)%26\n  }\n  return b\n}\n\n\n\nfunc GetMD5Hash(stuff []byte) []byte {\n  md5Hash := md5.New()\n  md5Hash.Write(stuff)\n  return md5Hash.Sum(nil)\n}\n\nfunc GetSHA1HmacBase64(secretKey, stringToSign string) string {\n  return base64.StdEncoding.EncodeToString(GetSHA1Hmac(secretKey, stringToSign))\n}\n\nfunc GetSHA1Hmac(secretKey, stringToSign string) []byte {\n  mac := hmac.New(sha1.New, bytes.NewBufferString(secretKey).Bytes())\n  bytesToSign := bytes.NewBufferString(stringToSign).Bytes()\n  mac.Write(bytesToSign)\n  return mac.Sum(nil)\n}\n\nfunc GetMD5HashBase64(stuff []byte) string ", "output": "{\n  return base64.StdEncoding.EncodeToString(GetMD5Hash(stuff))\n}"}
{"input": "package messagestore\n\nimport (\n\t\"github.com/agl/ed25519\"\n\tlog \"github.com/repbin/repbin/deferconsole\"\n\t\"github.com/repbin/repbin/utils\"\n\t\"github.com/repbin/repbin/utils/keyproof\"\n\t\"github.com/repbin/repbin/utils/repproto/structs\"\n)\n\n\nfunc (store Store) TouchPeer(pubkey *[ed25519.PublicKeySize]byte) {\n\terr := store.db.TouchPeer(pubkey)\n\tif err != nil {\n\t\tlog.Errorf(\"TouchPeer: %s, %s\\n\", err, utils.B58encode(pubkey[:]))\n\t}\n}\n\n\n\n\n\nfunc (store Store) UpdatePeerNotification(pubkey *[ed25519.PublicKeySize]byte, hasError bool) {\n\terr := store.db.UpdatePeerNotification(pubkey, hasError)\n\tif err != nil {\n\t\tlog.Errorf(\"UpdatePeerNotification: %s, %s\\n\", err, utils.B58encode(pubkey[:]))\n\t}\n}\n\n\nfunc (store Store) GetPeerStat(pubkey *[ed25519.PublicKeySize]byte) *structs.PeerStruct {\n\tst, err := store.db.SelectPeer(pubkey)\n\tif err != nil {\n\t\tlog.Errorf(\"GetPeerStat: %s, %s\\n\", err, utils.B58encode(pubkey[:]))\n\t\treturn nil\n\t}\n\treturn st\n}\n\n\nfunc (store Store) UpdatePeerAuthToken(senderPubKey *[ed25519.PublicKeySize]byte, signedToken *[keyproof.ProofTokenSignedSize]byte) {\n\terr := store.db.UpdatePeerToken(senderPubKey, signedToken)\n\tif err != nil {\n\t\tlog.Errorf(\"UpdatePeerAuthToken: %s, %s\\n\", err, utils.B58encode(senderPubKey[:]))\n\t}\n}\n\nfunc (store Store) UpdatePeerFetchStat(pubkey *[ed25519.PublicKeySize]byte, lastFetch, lastPos, lastErrors uint64) ", "output": "{\n\terr := store.db.UpdatePeerStats(pubkey, lastFetch, lastPos, lastErrors)\n\tif err != nil {\n\t\tlog.Errorf(\"UpdatePeerStats: %s, %s\\n\", err, utils.B58encode(pubkey[:]))\n\t}\n}"}
{"input": "package templates\n\nimport (\n\t\"sort\"\n\n\t\"github.com/bakape/hydron/common\"\n)\n\n\nvar orderLabels = [...]string{\"None\", \"Size\", \"Width\", \"Height\", \"Duration\",\n\t\"Tag count\", \"Random\"}\n\n\nvar optionLabels = [...]string{\"Fetch tags\", \"Add tags\", \"Remove tags\",\n\t\"Set name\", \"Delete files\"}\n\ntype tagSorter []common.Tag\n\nfunc (t tagSorter) Len() int {\n\treturn len(t)\n}\n\nfunc (t tagSorter) Less(i, j int) bool {\n\treturn t[i].Tag < t[j].Tag\n}\n\n\n\n\nfunc organizeTags(src []common.Tag) map[common.TagType][]common.Tag {\n\torg := make(map[common.TagType]map[string]common.Tag)\n\n\torg[common.Undefined] = make(map[string]common.Tag, len(src))\n\n\tfor _, t := range src {\n\t\tofType := org[t.Type]\n\t\tif ofType == nil {\n\t\t\tofType = make(map[string]common.Tag)\n\t\t\torg[t.Type] = ofType\n\t\t}\n\t\texisting, ok := ofType[t.Tag]\n\t\tif !ok || t.Source < existing.Source {\n\t\t\tofType[t.Tag] = t\n\t\t}\n\t}\n\n\tout := make(map[common.TagType][]common.Tag, len(org))\n\tfor typ, tags := range org {\n\t\tsorted := make(tagSorter, 0, len(tags))\n\t\tfor _, t := range tags {\n\t\t\tsorted = append(sorted, t)\n\t\t}\n\t\tsort.Sort(sorted)\n\t\tout[typ] = []common.Tag(sorted)\n\t}\n\treturn out\n}\n\nfunc (t tagSorter) Swap(i, j int) ", "output": "{\n\tt[i], t[j] = t[j], t[i]\n}"}
{"input": "package main\n\nimport (\n\tgj \"../../\"\n\t\"fmt\"\n\t\"github.com/vmihailenco/msgpack\"\n)\n\nfunc marshal(v interface{}) (data []byte, err error) {\n\treturn msgpack.Marshal(v)\n}\n\n\n\nfunc main() {\n\tcodec := gj.Codec{marshal, unmarshal}\n\tm := map[string]interface{}{\n\t\t\"hoge\": 100,\n\t\t\"piyo\": 2.5,\n\t}\n\n\tdata, _ := msgpack.Marshal(m)\n\tv, _ := gj.NewWithCodec(data, codec)\n\n\tfmt.Println(v.Get(\"hoge\").Int())\n\tfmt.Println(v.Get(\"piyo\").Float())\n}\n\nfunc unmarshal(data []byte, v interface{}) (err error) ", "output": "{\n\treturn msgpack.Unmarshal(data, v)\n}"}
{"input": "package main\n\nimport (\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"sync\"\n)\n\n\n\n\n\n\ntype TaskPool struct {\n\twait sync.WaitGroup\n\twork chan func()\n}\n\nfunc NewTaskPool() *TaskPool {\n\tpool := &TaskPool{}\n\treturn pool\n}\n\nfunc (pool *TaskPool) AddTask(workFunc func()) {\n\tpool.work <- workFunc\n}\n\nfunc (pool *TaskPool) Start() {\n\tbindThreads := os.Getenv(\"OMP_PROC_BIND\")\n\tif bindThreads == \"TRUE\" {\n\t\truntime.LockOSThread()\n\t}\n\n\tnumThreads, err := strconv.Atoi(os.Getenv(\"OMP_NUM_THREADS\"))\n\n\tif err != nil || numThreads < 1 {\n\t\tnumThreads = runtime.NumCPU()\n\t}\n\truntime.GOMAXPROCS(numThreads)\n\n\tpool.wait.Add(numThreads)\n\tpool.work = make(chan func(), numThreads)\n\n\tfor n := numThreads; n > 0; n-- {\n\t\tgo func() {\n\t\t\tfor x := range pool.work {\n\t\t\t\tx()\n\t\t\t}\n\t\t\tpool.wait.Done()\n\t\t}()\n\t}\n}\n\n\n\nfunc (pool *TaskPool) Stop() ", "output": "{\n\tclose(pool.work)\n\tpool.wait.Wait()\n}"}
{"input": "package slices\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMapWithCorrectType(t *testing.T) {\n\tins := []int{1, 2, 3, 4}\n\tf := func(v int) string {\n\t\treturn fmt.Sprintf(\"#%d\", v)\n\t}\n\tgot := Map(f, ins).([]string)\n\twant := []string{\"#1\", \"#2\", \"#3\", \"#4\"}\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Map = %v; want %v\", got, want)\n\t}\n}\n\n\n\nfunc TestMapWithInterface(t *testing.T) ", "output": "{\n\tins := []int{1, 2, 3, 4}\n\tf := func(v interface{}) string {\n\t\treturn fmt.Sprintf(\"#%d\", v)\n\t}\n\tgot := Map(f, ins).([]string)\n\twant := []string{\"#1\", \"#2\", \"#3\", \"#4\"}\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Map = %v; want %v\", got, want)\n\t}\n}"}
{"input": "package lmath\n\n\n\nfunc smallestRangeI(A []int, K int) int ", "output": "{\n\tminV, maxV := A[0], A[0]\n\tfor _, v := range A {\n\t\tif v < minV {\n\t\t\tminV = v\n\t\t} else if v > maxV {\n\t\t\tmaxV = v\n\t\t}\n\t}\n\tif res := (maxV - K) - (minV + K); res < 0 {\n\t\treturn 0\n\t} else {\n\t\treturn res\n\t}\n}"}
{"input": "package ingester\n\nimport (\n\t\"sync\"\n\t\"unsafe\"\n\n\t\"github.com/prometheus/common/model\"\n)\n\nconst (\n\tcacheLineSize = 64\n)\n\n\ntype paddedMutex struct {\n\tsync.Mutex\n\tpad [cacheLineSize - unsafe.Sizeof(sync.Mutex{})]byte\n}\n\n\n\n\n\n\n\n\n\n\n\ntype fingerprintLocker struct {\n\tfpMtxs    []paddedMutex\n\tnumFpMtxs uint\n}\n\n\n\nfunc newFingerprintLocker(preallocatedMutexes int) *fingerprintLocker {\n\tif preallocatedMutexes < 1024 {\n\t\tpreallocatedMutexes = 1024\n\t}\n\treturn &fingerprintLocker{\n\t\tmake([]paddedMutex, preallocatedMutexes),\n\t\tuint(preallocatedMutexes),\n\t}\n}\n\n\nfunc (l *fingerprintLocker) Lock(fp model.Fingerprint) {\n\tl.fpMtxs[hashFP(fp)%l.numFpMtxs].Lock()\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc hashFP(fp model.Fingerprint) uint {\n\treturn uint(fp ^ (fp >> 32) ^ (fp >> 16))\n}\n\nfunc (l *fingerprintLocker) Unlock(fp model.Fingerprint) ", "output": "{\n\tl.fpMtxs[hashFP(fp)%l.numFpMtxs].Unlock()\n}"}
{"input": "package utils\n\nimport \"bytes\"\n\n\n\n\nfunc PopLine(in []byte) ([]byte, error) ", "output": "{\n\tr := bytes.NewBuffer(in)\n\ttotal := len(in)\n\tl, e := r.ReadString(10)\n\tif e != nil {\n\t\treturn []byte{}, e\n\t}\n\n\tremaining := make([]byte, total-len([]byte(l)))\n\n\tr.Read(remaining)\n\n\treturn remaining, nil\n}"}
{"input": "package main\n\nimport (\n\t\"time\"\n)\n\nfunc serverMonitorInit() {\n\tgo startServerMonitor()\n}\n\n\n\nfunc startServerMonitor() ", "output": "{\n\ttimer := time.NewTimer(time.Second * 30)\n\n\tselect {\n\tcase <-timer.C:\n\t\tDataManager().CheckServerTTL()\n\t}\n}"}
{"input": "package taskmq\n\ntype Stub struct{}\n\n\n\nfunc (c Stub) Push(name string, body []byte) error {\n\treturn nil\n}\n\nfunc (c Stub) InitConsumer(queue string) []byte {\n\treturn nil\n}\n\nfunc (c Stub) Pop() []byte {\n\treturn []byte{}\n}\n\nfunc (c Stub) Ack() error {\n\treturn nil\n}\n\nfunc (c Stub) Nack() error {\n\treturn nil\n}\n\nfunc (c Stub) Clone() *Stub ", "output": "{\n\treturn &Stub{}\n}"}
{"input": "package metrics_test\n\nimport (\n\t\"github.com/stripe/veneur/v14/ssf\"\n\t\"github.com/stripe/veneur/v14/trace\"\n\t\"github.com/stripe/veneur/v14/trace/metrics\"\n)\n\n\n\nfunc ExampleReportAsync() ", "output": "{\n\tsamples := []*ssf.SSFSample{}\n\n\tsamples = append(samples, ssf.Count(\"a.counter\", 2, nil))\n\tsamples = append(samples, ssf.Gauge(\"a.gauge\", 420, nil))\n\n\tdone := make(chan error)\n\tmetrics.ReportAsync(trace.DefaultClient, samples, done)\n\t<-done\n}"}
{"input": "package model\n\nimport (\n\t\"github.com/evolsnow/samaritan/common/caches\"\n\t\"github.com/evolsnow/samaritan/common/dbms\"\n\t\"time\"\n)\n\nvar cache *caches.SimpleCache\n\n\n\nfunc beforeTest() {\n\tcache = caches.NewCache()\n\tu := &User{\n\t\tSamId:    \"evol\",\n\t\tAlias:    \"evol\",\n\t\tName:     \"张三\",\n\t\tPhone:    \"13212341234\",\n\t\tPassword: \"oldpwd\",\n\t\tEmail:    \"gsc1215225@gmail.com\",\n\t}\n\tu.Save()\n\tdbms.CreateSearchIndex(u.Id, \"gsc1215225@gmail.com\", \"mail\")\n\tcache.Set(\"gsc1215225@gmail.com:code\", \"123456\", time.Minute*5)\n\n\tt := &Todo{\n\t\tOwnerId:   u.Id,\n\t\tStartTime: time.Now().Unix(),\n\t\tDesc:      \"desc here\",\n\t}\n\tt.Save()\n\tcache.Set(\"delete_test_todo_pid\", t.Pid, time.Minute*5)\n}\n\nfunc init() ", "output": "{\n\tdbms.Pool = dbms.NewPool(\"127.0.0.1:6379\", \"\", \"2\")\n\tdbms.CachePool = dbms.NewPool(\"127.0.0.1:6379\", \"\", \"9\")\n\tc := dbms.Pool.Get()\n\tdefer c.Close()\n\tc.Do(\"FLUSHDB\")\n\tcc := dbms.CachePool.Get()\n\tdefer cc.Close()\n\tcc.Do(\"FLUSHDB\")\n\tbeforeTest()\n}"}
{"input": "package lstack\n\ntype MyStack struct {\n\tq []int\n}\n\n\n\n\n\nfunc (this *MyStack) Push(x int) {\n\tthis.q = append(this.q, x)\n}\n\n\nfunc (this *MyStack) Pop() int {\n\tr := this.q[len(this.q)-1]\n\tthis.q = this.q[:len(this.q)-1]\n\treturn r\n}\n\n\nfunc (this *MyStack) Top() int {\n\treturn this.q[len(this.q)-1]\n}\n\n\nfunc (this *MyStack) Empty() bool {\n\treturn len(this.q) == 0\n}\n\nfunc MyStackConstructor() MyStack ", "output": "{\n\treturn MyStack{}\n}"}
{"input": "package sw\n\nimport (\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/hyperledger/fabric/bccsp\"\n)\n\n\n\n\n\n\ntype rsaPublicKey struct{ pubKey *rsa.PublicKey }\n\nfunc (k *rsaPublicKey) Symmetric() bool               { return false }\nfunc (k *rsaPublicKey) Private() bool                 { return false }\nfunc (k *rsaPublicKey) PublicKey() (bccsp.Key, error) { return k, nil }\n\n\nfunc (k *rsaPublicKey) Bytes() (raw []byte, err error) {\n\tif k.pubKey == nil {\n\t\treturn nil, errors.New(\"Failed marshalling key. Key is nil.\")\n\t}\n\traw, err = x509.MarshalPKIXPublicKey(k.pubKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Failed marshalling key [%s]\", err)\n\t}\n\treturn\n}\n\n\n\n\nfunc (k *rsaPublicKey) SKI() []byte ", "output": "{\n\tif k.pubKey == nil {\n\t\treturn nil\n\t}\n\n\traw := x509.MarshalPKCS1PublicKey(k.pubKey)\n\thash := sha256.Sum256(raw)\n\treturn hash[:]\n}"}
{"input": "package testing\n\nimport (\n\tgc \"launchpad.net/gocheck\"\n\n\t\"github.com/juju/juju/container\"\n\t\"github.com/juju/juju/container/lxc\"\n\t\"github.com/juju/juju/container/lxc/mock\"\n\t\"github.com/juju/juju/testing\"\n)\n\n\n\ntype TestSuite struct {\n\ttesting.FakeJujuHomeSuite\n\tFactory      mock.ContainerFactory\n\tContainerDir string\n\tRemovedDir   string\n\tLxcDir       string\n\tRestartDir   string\n}\n\n\n\nfunc (s *TestSuite) SetUpTest(c *gc.C) ", "output": "{\n\ts.FakeJujuHomeSuite.SetUpTest(c)\n\ts.ContainerDir = c.MkDir()\n\ts.PatchValue(&container.ContainerDir, s.ContainerDir)\n\ts.RemovedDir = c.MkDir()\n\ts.PatchValue(&container.RemovedContainerDir, s.RemovedDir)\n\ts.LxcDir = c.MkDir()\n\ts.PatchValue(&lxc.LxcContainerDir, s.LxcDir)\n\ts.RestartDir = c.MkDir()\n\ts.PatchValue(&lxc.LxcRestartDir, s.RestartDir)\n\ts.Factory = mock.MockFactory(s.LxcDir)\n\ts.PatchValue(&lxc.LxcObjectFactory, s.Factory)\n}"}
{"input": "package classfile\n\nimport \"encoding/binary\"\n\ntype ClassReader struct {\n\tdata []byte \n}\n\nfunc (self *ClassReader) readUint8() uint8 {\n\tval := self.data[0]\n\tself.data = self.data[1:]\n\treturn val\n}\n\nfunc (self *ClassReader) readUint16() uint16 {\n\tval := binary.BigEndian.Uint16(self.data)\n\tself.data = self.data[2:]\n\treturn val\n}\n\nfunc (self *ClassReader) readUint32() uint32 {\n\tval := binary.BigEndian.Uint32(self.data)\n\tself.data = self.data[4:]\n\treturn val\n}\n\n\n\nfunc (self *ClassReader) readUint16s() []uint16 {\n\tn := self.readUint16()\n\ts := make([]uint16, n)\n\tfor i := range s {\n\t\ts[i] = self.readUint16()\n\t}\n\treturn s\n}\n\nfunc (self *ClassReader) readBytes(n uint32) []byte {\n\tbytes := self.data[:n]\n\tself.data = self.data[n:]\n\treturn bytes\n}\n\nfunc (self *ClassReader) readUint64() uint64 ", "output": "{\n\tval := binary.BigEndian.Uint64(self.data)\n\tself.data = self.data[8:]\n\treturn val\n}"}
{"input": "package custom_commands\n\nimport (\n\t\"github.com/jmoiron/sqlx\"\n\t\"github.com/sgt-kabukiman/kabukibot/bot\"\n)\n\ntype pluginStruct struct {\n\tdb *sqlx.DB\n}\n\nfunc NewPlugin() *pluginStruct {\n\treturn &pluginStruct{}\n}\n\nfunc (self *pluginStruct) Name() string {\n\treturn \"custom_commands\"\n}\n\n\n\nfunc (self *pluginStruct) CreateWorker(channel bot.Channel) bot.PluginWorker {\n\treturn &worker{\n\t\tchannel: channel,\n\t\tacl:     channel.ACL(),\n\t\tdb:      self.db,\n\t}\n}\n\nfunc (self *pluginStruct) Setup(bot *bot.Kabukibot) ", "output": "{\n\tself.db = bot.Database()\n}"}
{"input": "package kcp\n\nimport (\n    \"time\"\n    \"net\"\n)\n\ntype BufferConn struct {\n    buf *Buffer\n    conn net.Conn\n}\n\nfunc NewBufferConn(c net.Conn) *BufferConn {\n    return &BufferConn{\n        buf: &Buffer{},\n        conn: c,\n    }\n}\n\nfunc (c *BufferConn) BufferBytes() []byte { return c.buf.Bytes() }\n\nfunc (c *BufferConn) BufferLen() int { return c.buf.Len() }\n\nfunc (c *BufferConn) ReadToBuffer(sz int) (int, error) {\n    n, err := c.conn.Read(c.buf.Extend(sz))\n    if err == nil {\n        c.buf.Truncate(c.buf.Len() - (sz - n))\n    } else {\n        c.buf.Truncate(c.buf.Len() - sz)\n    }\n    return n, err\n}\n\nfunc (c *BufferConn) Read(b []byte) (int, error) {\n    if c.buf.Len() > 0 {\n        return c.buf.Read(b)\n    }\n    return c.conn.Read(b)\n}\n\nfunc (c *BufferConn) Write(b []byte) (int, error) {\n    return c.conn.Write(b)\n}\n\nfunc (c *BufferConn) Close() error {\n    return c.conn.Close()\n}\n\nfunc (c *BufferConn) LocalAddr() net.Addr {\n    return c.conn.LocalAddr()\n}\n\nfunc (c *BufferConn) RemoteAddr() net.Addr {\n    return c.conn.RemoteAddr()\n}\n\nfunc (c *BufferConn) SetDeadline(t time.Time) error {\n    return c.conn.SetDeadline(t)\n}\n\nfunc (c *BufferConn) SetReadDeadline(t time.Time) error {\n    return c.conn.SetReadDeadline(t)\n}\n\n\n\nfunc (c *BufferConn) SetWriteDeadline(t time.Time) error ", "output": "{\n    return c.conn.SetWriteDeadline(t)\n}"}
{"input": "package tcp\n\nimport (\n\t\"io\"\n\n\t\"github.com/plgd-dev/go-coap/v2/message\"\n\t\"github.com/plgd-dev/go-coap/v2/message/codes\"\n\t\"github.com/plgd-dev/go-coap/v2/mux\"\n\t\"github.com/plgd-dev/go-coap/v2/tcp/message/pool\"\n)\n\n\n\n\ntype muxResponseWriter struct {\n\tw *ResponseWriter\n}\n\nfunc (w *muxResponseWriter) SetResponse(code codes.Code, contentFormat message.MediaType, d io.ReadSeeker, opts ...message.Option) error {\n\treturn w.w.SetResponse(code, contentFormat, d, opts...)\n}\n\nfunc (w *muxResponseWriter) Client() mux.Client {\n\treturn w.w.ClientConn().Client()\n}\n\nfunc WithMux(m mux.Handler) HandlerFuncOpt ", "output": "{\n\th := func(w *ResponseWriter, r *pool.Message) {\n\t\tmuxw := &muxResponseWriter{\n\t\t\tw: w,\n\t\t}\n\t\tmuxr, err := pool.ConvertTo(r)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tm.ServeCOAP(muxw, &mux.Message{\n\t\t\tMessage:        muxr,\n\t\t\tSequenceNumber: r.Sequence(),\n\t\t})\n\t}\n\treturn WithHandlerFunc(h)\n}"}
{"input": "package client\n\nimport (\n\t\"errors\"\n\t\"io\"\n\n\tCli \"github.com/docker/docker/cli\"\n\tflag \"github.com/docker/docker/pkg/mflag\"\n)\n\n\n\n\n\n\n\n\nfunc (cli *DockerCli) CmdExport(args ...string) error ", "output": "{\n\tcmd := Cli.Subcmd(\"export\", []string{\"CONTAINER\"}, Cli.DockerCommands[\"export\"].Description, true)\n\toutfile := cmd.String([]string{\"o\", \"-output\"}, \"\", \"Write to a file, instead of STDOUT\")\n\tcmd.Require(flag.Exact, 1)\n\n\tcmd.ParseFlags(args, true)\n\n\tif *outfile == \"\" && cli.isTerminalOut {\n\t\treturn errors.New(\"Cowardly refusing to save to a terminal. Use the -o flag or redirect.\")\n\t}\n\n\tresponseBody, err := cli.client.ContainerExport(cmd.Arg(0))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer responseBody.Close()\n\n\tif *outfile == \"\" {\n\t\t_, err := io.Copy(cli.out, responseBody)\n\t\treturn err\n\t}\n\n\treturn copyToFile(*outfile, responseBody)\n\n}"}
{"input": "package bytealg\n\n\n\nfunc CountString(s string, c byte) int {\n\tn := 0\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == c {\n\t\t\tn++\n\t\t}\n\t}\n\treturn n\n}\n\nfunc Count(b []byte, c byte) int ", "output": "{\n\tn := 0\n\tfor _, x := range b {\n\t\tif x == c {\n\t\t\tn++\n\t\t}\n\t}\n\treturn n\n}"}
{"input": "package proto\n\nimport ()\n\ntype getdata struct {\n\tCount     uint64\n\tInventory []byte\n}\n\nfunc NewGetdata() (*getdata, error) {\n\treturn nil, nil\n}\n\nfunc (v *getdata) Serialize() ([]byte, error) {\n\treturn nil, nil\n}\n\n\n\nfunc (v *getdata) Deserialize(packet []byte) error ", "output": "{\n\treturn nil\n}"}
{"input": "package notifications\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nvar url string\nvar serverKey string\nvar topic string\n\n\nfunc Init() {\n\turl = \"https://fcm.googleapis.com/fcm/send\"\n\tserverKey = os.Getenv(\"JFBKEY\")\n\tif serverKey == \"\" {\n\t\tlog.Fatal(\"Missing JFBKEY for Firebase Authentication\")\n\t}\n\ttopic = os.Getenv(\"JFBTOPIC\")\n\tif topic == \"\" {\n\t\tlog.Fatal(\"Missing JFBTOPIC for Firebase Topic\")\n\t}\n}\n\n\n\n\nfunc PushFirebase(title string, body string) ", "output": "{\n\tvar jsonStr = []byte(fmt.Sprintf(`{\"to\": \"/topics/%s\", \"priority\" : \"high\", \"notification\": {\"body\": \"%s\", \"icon\" : \"ic_notify\", \"tag\":\"JIMMY\", \"title\": \"%s\"}}`, topic, body, title))\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonStr))\n\treq.Header.Set(\"Authorization\", \"key=\"+serverKey)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\t_, err = client.Do(req)\n\tif err != nil {\n\t\tlog.Println(\"Push failed\")\n\t}\n}"}
{"input": "package controller\n\nimport (\n\t\"fmt\"\n\t\"github.com/gorilla/mux\"\n\t\"html\"\n\t\"log\"\n\t\"net/http\"\n)\n\n\ntype BasicExampleController struct {\n\tbase string\n}\n\nfunc (t *BasicExampleController) SetBase(base string) HTTPController {\n\tt.base = base\n\treturn t\n}\n\nfunc (t *BasicExampleController) Base() string {\n\treturn t.base\n}\n\n\nfunc (t *BasicExampleController) Routes() (http.Handler, error) {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(t.Base(), t.index)\n\trouter.HandleFunc(t.Base()+\"magic\", t.index)\n\treturn router, nil\n}\n\n\n\n\n\nfunc ExampleBasicExample() {\n\tcontrollers := HTTPControllers{\n\t\t(&BasicExampleController{}).SetBase(\"/\"),\n\t\t(&BasicExampleController{}).SetBase(\"/testing/\"),\n\t}\n\n\tlog.Fatal(http.ListenAndServe(\":80\", controllers.Routes()))\n}\n\nfunc (t *BasicExampleController) index(response http.ResponseWriter, request *http.Request) ", "output": "{\n\tfmt.Fprintf(response, \"Hello, %q\", html.EscapeString(request.URL.Path))\n}"}
{"input": "package credentials\n\nimport (\n\t\"strings\"\n\n\t\"github.com/docker/docker/cliconfig/configfile\"\n\t\"github.com/docker/engine-api/types\"\n)\n\n\n\ntype fileStore struct {\n\tfile *configfile.ConfigFile\n}\n\n\n\n\n\nfunc (c *fileStore) Erase(serverAddress string) error {\n\tdelete(c.file.AuthConfigs, serverAddress)\n\treturn c.file.Save()\n}\n\n\nfunc (c *fileStore) Get(serverAddress string) (types.AuthConfig, error) {\n\tauthConfig, ok := c.file.AuthConfigs[serverAddress]\n\tif !ok {\n\t\tfor registry, ac := range c.file.AuthConfigs {\n\t\t\tif serverAddress == convertToHostname(registry) {\n\t\t\t\treturn ac, nil\n\t\t\t}\n\t\t}\n\n\t\tauthConfig = types.AuthConfig{}\n\t}\n\treturn authConfig, nil\n}\n\nfunc (c *fileStore) GetAll() (map[string]types.AuthConfig, error) {\n\treturn c.file.AuthConfigs, nil\n}\n\n\nfunc (c *fileStore) Store(authConfig types.AuthConfig) error {\n\tc.file.AuthConfigs[authConfig.ServerAddress] = authConfig\n\treturn c.file.Save()\n}\n\nfunc convertToHostname(url string) string {\n\tstripped := url\n\tif strings.HasPrefix(url, \"http://\") {\n\t\tstripped = strings.Replace(url, \"http://\", \"\", 1)\n\t} else if strings.HasPrefix(url, \"https://\") {\n\t\tstripped = strings.Replace(url, \"https://\", \"\", 1)\n\t}\n\n\tnameParts := strings.SplitN(stripped, \"/\", 2)\n\n\treturn nameParts[0]\n}\n\nfunc NewFileStore(file *configfile.ConfigFile) Store ", "output": "{\n\treturn &fileStore{\n\t\tfile: file,\n\t}\n}"}
{"input": "package solid\n\nimport \"github.com/cpmech/gosl/chk\"\n\n\ntype OnedState struct {\n\n\tSig float64 \n\n\tAlp     []float64 \n\tDgam    float64   \n\tLoading bool      \n\n\tPhi []float64 \n\n\tF float64 \n}\n\n\n\nfunc NewOnedState(nalp, nphi int) *OnedState {\n\tvar state OnedState\n\tif nalp > 0 {\n\t\tstate.Alp = make([]float64, nalp)\n\t}\n\tif nphi > 0 {\n\t\tstate.Phi = make([]float64, nphi)\n\t}\n\treturn &state\n}\n\n\n\n\nfunc (o *OnedState) Set(other *OnedState) {\n\to.Sig = other.Sig\n\to.Dgam = other.Dgam\n\to.Loading = other.Loading\n\tchk.IntAssert(len(o.Alp), len(other.Alp))\n\tchk.IntAssert(len(o.Phi), len(other.Phi))\n\tcopy(o.Alp, other.Alp)\n\tcopy(o.Phi, other.Phi)\n\to.F = other.F\n}\n\n\n\n\nfunc (o *OnedState) GetCopy() *OnedState ", "output": "{\n\tother := NewOnedState(len(o.Alp), len(o.Phi))\n\tother.Set(o)\n\treturn other\n}"}
{"input": "package domain\n\nimport \"github.com/ecsteam/cloudfoundry-top-plugin/metadata/common\"\n\ntype DomainMetadata struct {\n\t*common.Metadata\n\t*Domain\n}\n\nfunc NewDomainMetadata(Domain Domain) *DomainMetadata {\n\treturn &DomainMetadata{Metadata: &common.Metadata{}, Domain: &Domain}\n}\n\n\n\nfunc (metadataItem *DomainMetadata) GetName() string {\n\treturn metadataItem.Name\n}\n\nfunc NewDomainMetadataById(id string) *DomainMetadata ", "output": "{\n\treturn NewDomainMetadata(Domain{EntityCommon: common.EntityCommon{Guid: id}, Name: id})\n}"}
{"input": "package main\n\nimport (\n\t\"testing\"\n\n\t. \"github.com/atlassian/git-lob/Godeps/_workspace/src/github.com/onsi/ginkgo\"\n\t. \"github.com/atlassian/git-lob/Godeps/_workspace/src/github.com/onsi/gomega\"\n\t. \"github.com/atlassian/git-lob/util\"\n)\n\n\n\nfunc TestAll(t *testing.T) ", "output": "{\n\tRegisterFailHandler(Fail)\n\n\tloggingOff := true\n\tif loggingOff {\n\t\tLogSuppressAllConsoleOutput()\n\t}\n\n\tRunSpecs(t, \"Git Lob Root Test Suite\")\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/mycaosf/gui\"\n\t\"github.com/mycaosf/winapi\"\n)\n\ntype aboutDialog struct {\n\tgui.BaseDialog\n}\n\n\n\nfunc (p *aboutDialog) OnOk(cmd *winapi.CMD) {\n\tp.End(winapi.IDOK)\n}\n\nfunc runAboutDialog(res *gui.Resource, parent winapi.HWND) {\n\tvar dlg aboutDialog\n\tdlg.Reg()\n\tdlg.DlgBox(res.Get(), \"AboutDlg\", parent)\n}\n\nfunc (p *aboutDialog) Reg() ", "output": "{\n\tp.BaseDialog.Reg()\n\tp.RegCmd(winapi.IDOK, p.OnOk)\n}"}
{"input": "package config_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/gengo/goship/lib/config\"\n)\n\nfunc TestSetComment(t *testing.T) {\n\tconst key = \"/goship/projects/test_project/environments/test_environment/comment\"\n\tecl := mockEtcdClient{\n\t\tsetExpectation: map[string]string{key: \"A comment\"},\n\t}\n\terr := config.SetComment(ecl, \"test_project\", \"test_environment\", \"A comment\")\n\tif err != nil {\n\t\tt.Fatalf(\"Can't set Comment %s\", err)\n\t}\n}\n\n\n\nfunc TestUnlockingEnvironment(t *testing.T) {\n\tconst key = \"/goship/projects/test_project/environments/test_environment/locked\"\n\tecl := mockEtcdClient{\n\t\tsetExpectation: map[string]string{key: \"false\"},\n\t}\n\terr := config.LockEnvironment(ecl, \"test_project\", \"test_environment\", \"false\")\n\tif err != nil {\n\t\tt.Fatalf(\"Can't unlock %s\", err)\n\t}\n}\n\nfunc TestLockingEnvironment(t *testing.T) ", "output": "{\n\tconst key = \"/goship/projects/test_project/environments/test_environment/locked\"\n\tecl := mockEtcdClient{\n\t\tsetExpectation: map[string]string{key: \"true\"},\n\t}\n\terr := config.LockEnvironment(ecl, \"test_project\", \"test_environment\", \"true\")\n\tif err != nil {\n\t\tt.Fatalf(\"Can't lock %s\", err)\n\t}\n}"}
{"input": "package memconn\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype memconn struct {\n\tsync.Once\n\taddr addr\n\tbsiz uint64\n\tchcn chan net.Conn\n\tdone func()\n\tpool *sync.Pool\n}\n\n\n\nfunc (m *memconn) Accept() (net.Conn, error) {\n\tfor c := range m.chcn {\n\t\treturn c, nil\n\t}\n\treturn nil, http.ErrServerClosed\n}\n\nfunc (m *memconn) Close() error {\n\tm.Do(func() {\n\t\tclose(m.chcn)\n\t\tm.done()\n\t})\n\treturn http.ErrServerClosed\n}\n\nfunc (m *memconn) Addr() net.Addr {\n\treturn m.addr\n}\n\nfunc (m *memconn) Dial() (net.Conn, error) ", "output": "{\n\tr, w := pipe(&m.addr, m.pool)\n\tgo func() {\n\t\tm.chcn <- r\n\t}()\n\treturn w, nil\n}"}
{"input": "package main\n\nimport (\n\t\"strings\"\n\t\"unsafe\"\n)\n\ntype T chan int\n\nconst ptrSize = unsafe.Sizeof((*byte)(nil))\n\nfunc main() {\n\tc := make(T, 10)\n\tif len(c) != 0 || cap(c) != 10 {\n\t\tprintln(\"chan len/cap \", len(c), cap(c), \" want 0 10\")\n\t\tpanic(\"fail\")\n\t}\n\n\tfor i := 0; i < 3; i++ {\n\t\tc <- i\n\t}\n\tif len(c) != 3 || cap(c) != 10 {\n\t\tprintln(\"chan len/cap \", len(c), cap(c), \" want 3 10\")\n\t\tpanic(\"fail\")\n\t}\n\n\tc = make(T)\n\tif len(c) != 0 || cap(c) != 0 {\n\t\tprintln(\"chan len/cap \", len(c), cap(c), \" want 0 0\")\n\t\tpanic(\"fail\")\n\t}\n\n\tn := -1\n\tshouldPanic(\"makechan: size out of range\", func() { _ = make(T, n) })\n\tshouldPanic(\"makechan: size out of range\", func() { _ = make(T, int64(n)) })\n\tif ptrSize == 8 {\n\t\tvar n2 int64 = 1 << 59\n\t\tshouldPanic(\"makechan: size out of range\", func() { _ = make(T, int(n2)) })\n\t\tn2 = 1<<63 - 1\n\t\tshouldPanic(\"makechan: size out of range\", func() { _ = make(T, int(n2)) })\n\t} else {\n\t\tn = 1<<31 - 1\n\t\tshouldPanic(\"makechan: size out of range\", func() { _ = make(T, n) })\n\t\tshouldPanic(\"makechan: size out of range\", func() { _ = make(T, int64(n)) })\n\t}\n}\n\n\n\nfunc shouldPanic(str string, f func()) ", "output": "{\n\tdefer func() {\n\t\terr := recover()\n\t\tif err == nil {\n\t\t\tpanic(\"did not panic\")\n\t\t}\n\t\ts := err.(error).Error()\n\t\tif !strings.Contains(s, str) {\n\t\t\tpanic(\"got panic \" + s + \", want \" + str)\n\t\t}\n\t}()\n\n\tf()\n}"}
{"input": "package iso20022\n\n\ntype ATMEnvironment3 struct {\n\n\tAcquirer *Acquirer7 `xml:\"Acqrr,omitempty\"`\n\n\tATMManagerIdentification *Max35Text `xml:\"ATMMgrId,omitempty\"`\n\n\tHostingEntity *TerminalHosting1 `xml:\"HstgNtty,omitempty\"`\n\n\tATM *AutomatedTellerMachine1 `xml:\"ATM\"`\n\n\tCustomer *ATMCustomer3 `xml:\"Cstmr\"`\n\n\tCard *PaymentCard17 `xml:\"Card,omitempty\"`\n}\n\nfunc (a *ATMEnvironment3) AddAcquirer() *Acquirer7 {\n\ta.Acquirer = new(Acquirer7)\n\treturn a.Acquirer\n}\n\nfunc (a *ATMEnvironment3) SetATMManagerIdentification(value string) {\n\ta.ATMManagerIdentification = (*Max35Text)(&value)\n}\n\nfunc (a *ATMEnvironment3) AddHostingEntity() *TerminalHosting1 {\n\ta.HostingEntity = new(TerminalHosting1)\n\treturn a.HostingEntity\n}\n\nfunc (a *ATMEnvironment3) AddATM() *AutomatedTellerMachine1 {\n\ta.ATM = new(AutomatedTellerMachine1)\n\treturn a.ATM\n}\n\nfunc (a *ATMEnvironment3) AddCustomer() *ATMCustomer3 {\n\ta.Customer = new(ATMCustomer3)\n\treturn a.Customer\n}\n\n\n\nfunc (a *ATMEnvironment3) AddCard() *PaymentCard17 ", "output": "{\n\ta.Card = new(PaymentCard17)\n\treturn a.Card\n}"}
{"input": "package extension\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/jinzhu/gorm\"\n)\n\nvar initializerList = []Initializer{}\n\n\n\n\n\n\ntype Initializer interface {\n\tDoBeforeDBMigration(db *gorm.DB) error\n\tDoAfterDBMigration(tx *gorm.DB) error\n\tDoBeforeRouterSetup(r *gin.Engine) error\n\tDoAfterRouterSetup(r *gin.Engine) error\n}\n\n\n\n\n\nfunc GetRegisteredInitializerList() []Initializer {\n\tresult := []Initializer{}\n\tresult = append(result, initializerList...)\n\treturn result\n}\n\nfunc RegisterInitializer(initializer Initializer) ", "output": "{\n\tinitializerList = append(initializerList, initializer)\n}"}
{"input": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\n\t\"gopkg.in/yaml.v2\"\n)\n\nvar proxies map[string]string\n\n\n\nfunc main() {\n\n\tfor path, port := range proxies {\n\t\tvhost, err := url.Parse(\"http://127.0.0.1:\" + port)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tproxy := httputil.NewSingleHostReverseProxy(vhost)\n\t\thttp.HandleFunc(path+\"/\", handler(proxy))\n\t}\n\n\terr := http.ListenAndServe(\":8888\", nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc handler(p *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tp.ServeHTTP(w, r)\n\t}\n}\n\nfunc init() ", "output": "{\n\tdata, err := ioutil.ReadFile(\"config.yaml\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif err := yaml.Unmarshal(data, &proxies); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nconst (\n\tapi = \"http://readability.com/api/content/v1/parser?token=%s&url=%s\"\n)\n\n\ntype Article struct {\n\tURL     string\n\tContent string `json: \"content\"`\n\tExcerpt string `json: \"excerpt\"`\n\tTitle   string `json: \"title\"`\n}\n\n\n\n\nfunc (article *Article) parse() ", "output": "{\n\tresponse, _ := http.Get(fmt.Sprintf(api, config.Hackernews.ReadabilityKey, article.URL))\n\tbody, _ := ioutil.ReadAll(response.Body)\n\tjson.Unmarshal(body, article)\n}"}
{"input": "package MR_test\n\nimport (\n\t\"github.com/SailorKGame/MessageRoute/MR\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype MsgTest struct {\n\tm_msgType MR.MsgType\n\tm_body    interface{}\n}\n\nfunc createMsgTest(msgType MR.MsgType, body interface{}) MR.Msg {\n\tmsg := new(MsgTest)\n\tmsg.m_msgType = msgType\n\tmsg.m_body = body\n\treturn msg\n}\nfunc (self *MsgTest) GetType() MR.MsgType {\n\treturn self.m_msgType\n}\n\n\nfunc TestMsg(t *testing.T) {\n\tmsgList := MR.CreateMsgList()\n\tmsg := createMsgTest(1, \"test\")\n\tgo func() {\n\t\ttime.Sleep(time.Second)\n\t\tmsgList.Push(msg)\n\t}()\n\tpoped := msgList.Pop()\n\tif \"test\" != poped.GetBody().(string) {\n\t\tt.Error(poped.GetBody())\n\t}\n}\nfunc TestMsg_Signal(t *testing.T) {\n\tmsgList := MR.CreateMsgList()\n\tmsg := createMsgTest(1, \"test\")\n\tmsgList.Push(msg)\n\tpoped := msgList.Pop()\n\tif \"test\" != poped.GetBody().(string) {\n\t\tt.Error(poped.GetBody())\n\t}\n}\n\nfunc (self *MsgTest) GetBody() interface{} ", "output": "{\n\treturn self.m_body\n}"}
{"input": "package quantile\n\nimport (\n    \"testing\"\n)\n\nfunc BenchmarkInsertTargeted(b *testing.B) {\n    b.ReportAllocs()\n\n    s := NewTargeted(Targets)\n    b.ResetTimer()\n    for i := float64(0); i < float64(b.N); i++ {\n        s.Insert(i)\n    }\n}\n\nfunc BenchmarkInsertTargetedSmallEpsilon(b *testing.B) {\n    s := NewTargeted(TargetsSmallEpsilon)\n    b.ResetTimer()\n    for i := float64(0); i < float64(b.N); i++ {\n        s.Insert(i)\n    }\n}\n\nfunc BenchmarkInsertBiased(b *testing.B) {\n    s := NewLowBiased(0.01)\n    b.ResetTimer()\n    for i := float64(0); i < float64(b.N); i++ {\n        s.Insert(i)\n    }\n}\n\n\n\nfunc BenchmarkQuery(b *testing.B) {\n    s := NewTargeted(Targets)\n    for i := float64(0); i < 1e6; i++ {\n        s.Insert(i)\n    }\n    b.ResetTimer()\n    n := float64(b.N)\n    for i := float64(0); i < n; i++ {\n        s.Query(i / n)\n    }\n}\n\nfunc BenchmarkQuerySmallEpsilon(b *testing.B) {\n    s := NewTargeted(TargetsSmallEpsilon)\n    for i := float64(0); i < 1e6; i++ {\n        s.Insert(i)\n    }\n    b.ResetTimer()\n    n := float64(b.N)\n    for i := float64(0); i < n; i++ {\n        s.Query(i / n)\n    }\n}\n\nfunc BenchmarkInsertBiasedSmallEpsilon(b *testing.B) ", "output": "{\n    s := NewLowBiased(0.0001)\n    b.ResetTimer()\n    for i := float64(0); i < float64(b.N); i++ {\n        s.Insert(i)\n    }\n}"}
{"input": "package commands\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/pflag\"\n\n\t\"github.com/golangci/golangci-lint/pkg/config\"\n)\n\ntype jsonVersion struct {\n\tVersion string `json:\"version\"`\n\tCommit  string `json:\"commit\"`\n\tDate    string `json:\"date\"`\n}\n\n\n\nfunc initVersionFlagSet(fs *pflag.FlagSet, cfg *config.Config) {\n\tvc := &cfg.Version\n\tfs.StringVar(&vc.Format, \"format\", \"\", wh(\"The version's format can be: 'short', 'json'\"))\n}\n\nfunc (e *Executor) initVersion() {\n\tversionCmd := &cobra.Command{\n\t\tUse:   \"version\",\n\t\tShort: \"Version\",\n\t\tRunE: func(cmd *cobra.Command, _ []string) error {\n\t\t\tswitch strings.ToLower(e.cfg.Version.Format) {\n\t\t\tcase \"short\":\n\t\t\t\tcmd.Println(e.version)\n\t\t\tcase \"json\":\n\t\t\t\tver := jsonVersion{\n\t\t\t\t\tVersion: e.version,\n\t\t\t\t\tCommit:  e.commit,\n\t\t\t\t\tDate:    e.date,\n\t\t\t\t}\n\t\t\t\tdata, err := json.Marshal(&ver)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcmd.Println(string(data))\n\t\t\tdefault:\n\t\t\t\tcmd.Printf(\"golangci-lint has version %s built from %s on %s\\n\", e.version, e.commit, e.date)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\n\te.rootCmd.AddCommand(versionCmd)\n\te.initVersionConfiguration(versionCmd)\n}\n\nfunc (e *Executor) initVersionConfiguration(cmd *cobra.Command) ", "output": "{\n\tfs := cmd.Flags()\n\tfs.SortFlags = false \n\tinitVersionFlagSet(fs, e.cfg)\n}"}
{"input": "package slice\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n\nfunc InSlice(v interface{}, vs []interface{}) bool {\n\tfor _, _v := range vs {\n\t\tif reflect.DeepEqual(v, _v) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc InStrings(s string, ss []string) bool {\n\tfor _, _s := range ss {\n\t\tif _s == s {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc InInts(v int, vs []int) bool {\n\tfor _, i := range vs {\n\t\tif i == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc InUints(v uint, vs []uint) bool {\n\tfor _, i := range vs {\n\t\tif i == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\n\n\n\nfunc ReverseStrings(ss []string) {\n\tslen := len(ss)\n\tfor i, j := 0, slen/2; i < j; i++ {\n\t\tk := slen - i - 1\n\t\tss[i], ss[k] = ss[k], ss[i]\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc BinarySearch(num int, search func(N int) int) int {\n\tfor low, high := 0, num-1; low <= high; {\n\t\tmid := (low + high)\n\t\tswitch n := search(mid); n {\n\t\tcase -1:\n\t\t\thigh = mid - 1\n\t\tcase 0:\n\t\t\treturn mid\n\t\tcase 1:\n\t\t\tlow = mid + 1\n\t\tdefault:\n\t\t\tpanic(fmt.Errorf(\"BinarySearch: unknown search result '%d'\", n))\n\t\t}\n\t}\n\n\treturn -1\n}\n\nfunc StringsEqual(s1, s2 []string) bool ", "output": "{\n\tlen1, len2 := len(s1), len(s2)\n\tif len1 != len2 {\n\t\treturn false\n\t}\n\n\tfor i := 0; i < len1; i++ {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}"}
{"input": "package hello\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net/http\"\n\n\t\"appengine\"\n\t\"appengine/channel\"\n)\n\nconst (\n\tchannelKey = \"tno_chat\"\n\tindexFile  = \"index_react\"\n)\n\n\n\nfunc chatHandler(w http.ResponseWriter, r *http.Request) {\n\tcontext := appengine.NewContext(r)\n\n\tusername := r.FormValue(\"username\")\n\tmessage := r.FormValue(\"message\")\n\n\tif err := channel.SendJSON(context, channelKey, []string{username, message}); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\nfunc mainHandler(w http.ResponseWriter, r *http.Request) {\n\tcontext := appengine.NewContext(r)\n\n\ttmpl, err := template.ParseFiles(fmt.Sprintf(\"static/templates/%s.html\", indexFile))\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\ttoken, err := channel.Create(context, channelKey)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"text/html\")\n\ttmpl.Execute(w, map[string]string{\"token\": token})\n}\n\nfunc init() ", "output": "{\n\thttp.HandleFunc(\"/send\", chatHandler)\n\thttp.HandleFunc(\"/\", mainHandler)\n}"}
{"input": "package routers\n\nimport (\n\t\"github.com/TeamFat/go-way/code/beeapi/controllers\"\n\n\t\"github.com/astaxie/beego\"\n)\n\n\n\nfunc init() ", "output": "{\n\tns := beego.NewNamespace(\"/v1\",\n\t\tbeego.NSNamespace(\"/object\",\n\t\t\tbeego.NSInclude(\n\t\t\t\t&controllers.ObjectController{},\n\t\t\t),\n\t\t),\n\t\tbeego.NSNamespace(\"/user\",\n\t\t\tbeego.NSInclude(\n\t\t\t\t&controllers.UserController{},\n\t\t\t),\n\t\t),\n\t)\n\tbeego.AddNamespace(ns)\n}"}
{"input": "package terraform\n\n\ntype EvalSequence struct {\n\tNodes []EvalNode\n}\n\nfunc (n *EvalSequence) Eval(ctx EvalContext) (interface{}, error) {\n\tfor _, n := range n.Nodes {\n\t\tif n == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif _, err := EvalRaw(n, ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn nil, nil\n}\n\n\n\n\nfunc (n *EvalSequence) Filter(fn EvalNodeFilterFunc) ", "output": "{\n\tfor i, node := range n.Nodes {\n\t\tn.Nodes[i] = fn(node)\n\t}\n}"}
{"input": "package main\n\nimport . \"g2d\"\n\nvar screen = Point{480, 360}\nvar size = Point{20, 20}\n\ntype Ball struct {\n    x, y   int\n    dx, dy int\n}\n\nfunc NewBall(pos Point) *Ball {\n    return &Ball{pos.X, pos.Y, 5, 5}\n}\n\nfunc (b *Ball) Move() {\n    if !(0 <= b.x+b.dx && b.x+b.dx <= screen.X-size.X) {\n        b.dx = -b.dx\n    }\n    if !(0 <= b.y+b.dy && b.y+b.dy <= screen.Y-size.Y) {\n        b.dy = -b.dy\n    }\n    b.x += b.dx\n    b.y += b.dy\n}\n\n\n\n\nvar b1 = NewBall(Point{40, 80})\nvar b2 = NewBall(Point{80, 40})\n\nfunc mainConsole() {\n    for i := 0; i < 25; i++ {\n        Println(\"Ball 1 @\", b1.Position())\n        Println(\"Ball 2 @\", b2.Position())\n        b1.Move()\n        b2.Move()\n    }\n}\n\nfunc tick() {\n    ClearCanvas()  \n    b1.Move()\n    b2.Move()\n    DrawImage(\"ball.png\", b1.Position())  \n    DrawImage(\"ball.png\", b2.Position())  \n}\n\nfunc main() {\n    \n    InitCanvas(screen)\n    MainLoop(tick)\n}\n\nfunc (b *Ball) Position() Point ", "output": "{\n    return Point{b.x, b.y}\n}"}
{"input": "package testing\n\nimport (\n\t\"github.com/astaxie/beego\"\n\t\"github.com/astaxie/beego/httplib\"\n)\n\nvar port = \"\"\nvar baseUrl = \"http://localhost:\"\n\ntype TestHttpRequest struct{\n\thttplib.BeegoHttpRequest\n}\n\nfunc getPort() string{\n\tif port==\"\"{\n\t\tconfig,err:= beego.LoadConfig(\"../conf/app.conf\")\n\t\tif err!=nil{\n\t\t\treturn \"8080\"\n\t\t}\n\t\tport=config.String(\"httpport\")\n\t\treturn port\n\t}\n\treturn port\n}\n\nfunc Get(path string) *TestHttpRequest {\n\treturn &TestHttpRequest{*httplib.Get(baseUrl+getPort()+path)}\n}\n\n\n\nfunc Put(path string) *TestHttpRequest {\n\treturn &TestHttpRequest{*httplib.Put(baseUrl+getPort()+path)}\n}\n\nfunc Delete(path string) *TestHttpRequest {\n\treturn &TestHttpRequest{*httplib.Delete(baseUrl+getPort()+path)}\n}\n\nfunc Head(path string) *TestHttpRequest {\n\treturn &TestHttpRequest{*httplib.Head(baseUrl+getPort()+path)}\n}\n\nfunc Post(path string) *TestHttpRequest ", "output": "{\n\treturn &TestHttpRequest{*httplib.Post(baseUrl+getPort()+path)}\n}"}
{"input": "package v2\n\nimport (\n\t\"code.cloudfoundry.org/cli/command\"\n\t\"code.cloudfoundry.org/cli/command/translatableerror\"\n)\n\ntype RouterGroupsCommand struct {\n\tusage           interface{} `usage:\"CF_NAME router-groups\"`\n\trelatedCommands interface{} `related_commands:\"create-domain, domains\"`\n}\n\nfunc (RouterGroupsCommand) Setup(config command.Config, ui command.UI) error {\n\treturn nil\n}\n\n\n\nfunc (RouterGroupsCommand) Execute(args []string) error ", "output": "{\n\treturn translatableerror.UnrefactoredCommandError{}\n}"}
{"input": "package gtreap\n\nimport (\n\t\"github.com/akhenakh/oureadb/store\"\n\n\t\"github.com/steveyen/gtreap\"\n)\n\ntype Reader struct {\n\tt *gtreap.Treap\n}\n\nfunc (w *Reader) Get(k []byte) (v []byte, err error) {\n\tvar rv []byte\n\titm := w.t.Get(&Item{k: k})\n\tif itm != nil {\n\t\trv = make([]byte, len(itm.(*Item).v))\n\t\tcopy(rv, itm.(*Item).v)\n\t\treturn rv, nil\n\t}\n\treturn nil, nil\n}\n\nfunc (r *Reader) MultiGet(keys [][]byte) ([][]byte, error) {\n\treturn store.MultiGet(r, keys)\n}\n\n\n\nfunc (w *Reader) RangeIterator(start, end []byte) store.KVIterator {\n\trv := Iterator{\n\t\tt:     w.t,\n\t\tstart: start,\n\t\tend:   end,\n\t}\n\trv.restart(&Item{k: start})\n\treturn &rv\n}\n\nfunc (w *Reader) Close() error {\n\treturn nil\n}\n\nfunc (w *Reader) PrefixIterator(k []byte) store.KVIterator ", "output": "{\n\trv := Iterator{\n\t\tt:      w.t,\n\t\tprefix: k,\n\t}\n\trv.restart(&Item{k: k})\n\treturn &rv\n}"}
{"input": "package syscall\n\nimport \"unsafe\"\n\n\n\n\nfunc StringByteSlice(s string) []byte {\n\ta, err := ByteSliceFromString(s)\n\tif err != nil {\n\t\tpanic(\"syscall: string with NUL passed to StringByteSlice\")\n\t}\n\treturn a\n}\n\n\n\n\nfunc ByteSliceFromString(s string) ([]byte, error) {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == 0 {\n\t\t\treturn nil, EINVAL\n\t\t}\n\t}\n\ta := make([]byte, len(s)+1)\n\tcopy(a, s)\n\treturn a, nil\n}\n\n\n\n\nfunc StringBytePtr(s string) *byte { return &StringByteSlice(s)[0] }\n\n\n\n\nfunc BytePtrFromString(s string) (*byte, error) {\n\ta, err := ByteSliceFromString(s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &a[0], nil\n}\n\n\n\nvar _zero uintptr\n\nvar dummy *byte\n\nconst sizeofPtr uintptr = uintptr(unsafe.Sizeof(dummy))\n\nfunc (ts *Timespec) Unix() (sec int64, nsec int64) {\n\treturn int64(ts.Sec), int64(ts.Nsec)\n}\n\n\n\nfunc (ts *Timespec) Nano() int64 {\n\treturn int64(ts.Sec)*1e9 + int64(ts.Nsec)\n}\n\nfunc (tv *Timeval) Nano() int64 {\n\treturn int64(tv.Sec)*1e9 + int64(tv.Usec)*1000\n}\n\nfunc (tv *Timeval) Unix() (sec int64, nsec int64) ", "output": "{\n\treturn int64(tv.Sec), int64(tv.Usec) * 1000\n}"}
{"input": "package iso\n\nimport (\n\t\"fmt\"\n\t\"github.com/mitchellh/multistep\"\n\tparallelscommon \"github.com/mitchellh/packer/builder/parallels/common\"\n\t\"github.com/mitchellh/packer/packer\"\n\t\"strconv\"\n)\n\n\n\ntype stepCreateDisk struct{}\n\n\n\nfunc (s *stepCreateDisk) Cleanup(state multistep.StateBag) {}\n\nfunc (s *stepCreateDisk) Run(state multistep.StateBag) multistep.StepAction ", "output": "{\n\tconfig := state.Get(\"config\").(*config)\n\tdriver := state.Get(\"driver\").(parallelscommon.Driver)\n\tui := state.Get(\"ui\").(packer.Ui)\n\tvmName := state.Get(\"vmName\").(string)\n\n\tcommand := []string{\n\t\t\"set\", vmName,\n\t\t\"--device-set\", \"hdd0\",\n\t\t\"--size\", strconv.FormatUint(uint64(config.DiskSize), 10),\n\t\t\"--iface\", config.HardDriveInterface,\n\t}\n\n\tui.Say(\"Creating hard drive...\")\n\terr := driver.Prlctl(command...)\n\tif err != nil {\n\t\terr := fmt.Errorf(\"Error creating hard drive: %s\", err)\n\t\tstate.Put(\"error\", err)\n\t\tui.Error(err.Error())\n\t\treturn multistep.ActionHalt\n\t}\n\n\treturn multistep.ActionContinue\n}"}
{"input": "package extension\n\nimport (\n\t\"context\"\n\t\"flag\"\n\n\t\"github.com/vmware/govmomi/govc/cli\"\n\t\"github.com/vmware/govmomi/govc/flags\"\n\t\"github.com/vmware/govmomi/object\"\n)\n\ntype unregister struct {\n\t*flags.ClientFlag\n}\n\nfunc init() {\n\tcli.Register(\"extension.unregister\", &unregister{})\n}\n\nfunc (cmd *unregister) Register(ctx context.Context, f *flag.FlagSet) {\n\tcmd.ClientFlag, ctx = flags.NewClientFlag(ctx)\n\tcmd.ClientFlag.Register(ctx, f)\n}\n\n\n\nfunc (cmd *unregister) Run(ctx context.Context, f *flag.FlagSet) error {\n\tc, err := cmd.Client()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tm, err := object.GetExtensionManager(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, key := range f.Args() {\n\t\tif err = m.Unregister(ctx, key); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (cmd *unregister) Process(ctx context.Context) error ", "output": "{\n\tif err := cmd.ClientFlag.Process(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package enmime\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/cention-sany/mime\"\n)\n\nfunc debug(format string, args ...interface{}) {\n\tif false {\n\t\tfmt.Printf(format, args...)\n\t\tfmt.Println()\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc DecodeToUTF8Base64Header(input string) string {\n\tif !strings.Contains(input, \"=?\") {\n\t\treturn input\n\t}\n\n\tdebug(\"input = %q\", input)\n\ttokens := strings.FieldsFunc(input, isWhiteSpaceRune)\n\toutput := make([]string, len(tokens), len(tokens))\n\tfor i, token := range tokens {\n\t\tif len(token) > 4 && strings.Contains(token, \"=?\") {\n\t\t\tprefix := \"\"\n\t\t\tsuffix := \"\"\n\t\t\tif token[0] == '(' {\n\t\t\t\tprefix = \"(\"\n\t\t\t\ttoken = token[1:]\n\t\t\t}\n\t\t\tif token[len(token)-1] == ')' {\n\t\t\t\tsuffix = \")\"\n\t\t\t\ttoken = token[:len(token)-1]\n\t\t\t}\n\t\t\toutput[i] = prefix + mime.BEncoding.Encode(\"UTF-8\", DecodeHeader(token)) + suffix\n\t\t} else {\n\t\t\toutput[i] = token\n\t\t}\n\t\tdebug(\"%v %q %q\", i, token, output[i])\n\t}\n\n\treturn strings.Join(output, \" \")\n}\n\n\nfunc isWhiteSpaceRune(r rune) bool {\n\tswitch r {\n\tcase ' ':\n\t\treturn true\n\tcase '\\t':\n\t\treturn true\n\tcase '\\r':\n\t\treturn true\n\tcase '\\n':\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc DecodeHeader(input string) string ", "output": "{\n\tif !strings.Contains(input, \"=?\") {\n\t\treturn input\n\t}\n\n\tdec := new(mime.WordDecoder)\n\tdec.CharsetReader = NewCharsetReader\n\theader, err := dec.DecodeHeader(input)\n\tif err != nil {\n\t\treturn input\n\t}\n\treturn header\n}"}
{"input": "package s3_test\n\nimport (\n\t\"github.com/rwcarlsen/goamz/aws\"\n\t\"github.com/rwcarlsen/goamz/s3\"\n\t\"github.com/rwcarlsen/goamz/s3/s3test\"\n\t. \"launchpad.net/gocheck\"\n)\n\ntype LocalServer struct {\n\tauth   aws.Auth\n\tregion aws.Region\n\tsrv    *s3test.Server\n}\n\nfunc (s *LocalServer) SetUp(c *C) {\n\tsrv, err := s3test.NewServer()\n\tc.Assert(err, IsNil)\n\tc.Assert(srv, NotNil)\n\n\ts.srv = srv\n\ts.region = aws.Region{\n\t\tName:                 \"faux-region-1\",\n\t\tS3Endpoint:           srv.URL(),\n\t\tS3LocationConstraint: true, \n\t}\n}\n\n\n\n\n\n\ntype LocalServerSuite struct {\n\tsrv         LocalServer\n\tclientTests ClientTests\n}\n\nvar _ = Suite(&LocalServerSuite{})\n\nfunc (s *LocalServerSuite) SetUpSuite(c *C) {\n\ts.srv.SetUp(c)\n\ts.clientTests.s3 = s3.New(s.srv.auth, s.srv.region)\n\n\ts.clientTests.authIsBroken = true\n}\n\nfunc (s *LocalServerSuite) TestBasicFunctionality(c *C) {\n\ts.clientTests.TestBasicFunctionality(c)\n}\n\nfunc (s *LocalServerSuite) TestGetNotFound(c *C) {\n\ts.clientTests.TestGetNotFound(c)\n}\n\n\n\nfunc (s *LocalServerSuite) TestBucketList(c *C) ", "output": "{\n\ts.clientTests.TestBucketList(c)\n}"}
{"input": "package database\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype CreateDbHomeRequest struct {\n\n\tCreateDbHomeWithDbSystemIdDetails CreateDbHomeBase `contributesTo:\"body\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request CreateDbHomeRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request CreateDbHomeRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\n\n\n\nfunc (request CreateDbHomeRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype CreateDbHomeResponse struct {\n\n\tRawResponse *http.Response\n\n\tDbHome `presentIn:\"body\"`\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response CreateDbHomeResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response CreateDbHomeResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request CreateDbHomeRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) ", "output": "{\n\n\treturn nil, false\n\n}"}
{"input": "package daemon\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n)\n\n\nconst (\n\trootPrivileges = \"You must have root user privileges. Possibly using 'sudo' command should help\"\n\tsuccess        = \"\\t\\t\\t\\t\\t[  \\033[32mOK\\033[0m  ]\" \n\tfailed         = \"\\t\\t\\t\\t\\t[\\033[31mFAILED\\033[0m]\" \n)\n\nfunc IsExecutable(path string) (bool, error) {\n\tin, err := os.Open(path)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer in.Close()\n\n\tstat, err := in.Stat()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif stat.Mode()&0111 != 0 {\n\t\treturn true, nil\n\t} else {\n\t\treturn false, nil\n\t}\n}\n\n\n\n\n\nfunc checkPrivileges() bool {\n\n\tif user, err := user.Current(); err == nil && user.Gid == \"0\" {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc executablePath(name string) (string, error) ", "output": "{\n\tif path, err := exec.LookPath(name); err == nil {\n\t\t_, err := os.Stat(path)\n\t\tif os.IsNotExist(err) {\n\t\t\treturn execPath()\n\t\t}\n\t\treturn path, nil\n\t}\n\treturn execPath()\n}"}
{"input": "package booklit\n\n\n\n\ntype String string\n\n\nvar Empty String\n\n\nfunc (str String) IsFlow() bool {\n\treturn true\n}\n\n\n\n\n\nfunc (str String) Visit(visitor Visitor) error {\n\treturn visitor.VisitString(str)\n}\n\nfunc (str String) String() string ", "output": "{\n\treturn string(str)\n}"}
{"input": "package gb\n\nimport (\n\t\"path/filepath\"\n)\n\n\n\n\n\n\n\n\ntype Project struct {\n\trootdir string\n\tsrcdirs []Srcdir\n}\n\nfunc SourceDir(root string) func(*Project) {\n\treturn func(p *Project) {\n\t\tp.srcdirs = append(p.srcdirs, Srcdir{Root: root})\n\t}\n}\n\nfunc NewProject(root string, options ...func(*Project)) *Project {\n\tproj := Project{\n\t\trootdir: root,\n\t}\n\n\tfor _, opt := range options {\n\t\topt(&proj)\n\t}\n\n\treturn &proj\n}\n\n\nfunc (p *Project) Pkgdir() string {\n\treturn filepath.Join(p.rootdir, \"pkg\")\n}\n\n\n\n\n\n\n\n\nfunc (p *Project) Srcdirs() []string {\n\tvar dirs []string\n\tfor _, s := range p.srcdirs {\n\t\tdirs = append(dirs, s.Root)\n\t}\n\treturn dirs\n}\n\n\nfunc (p *Project) Bindir() string {\n\treturn filepath.Join(p.rootdir, \"bin\")\n}\n\nfunc (p *Project) Projectdir() string ", "output": "{\n\treturn p.rootdir\n}"}
{"input": "package tfinstall\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/hashicorp/go-checkpoint\"\n)\n\ntype LatestVersionOption struct {\n\tforceCheckpoint bool\n\tinstallDir      string\n\n\tUserAgent string\n}\n\nvar _ ExecPathFinder = &LatestVersionOption{}\n\nfunc LatestVersion(installDir string, forceCheckpoint bool) *LatestVersionOption {\n\topt := &LatestVersionOption{\n\t\tforceCheckpoint: forceCheckpoint,\n\t\tinstallDir:      installDir,\n\t}\n\n\treturn opt\n}\n\n\n\nfunc latestVersion(forceCheckpoint bool) (string, error) {\n\tresp, err := checkpoint.Check(&checkpoint.CheckParams{\n\t\tProduct: \"terraform\",\n\t\tForce:   forceCheckpoint,\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif resp.CurrentVersion == \"\" {\n\t\treturn \"\", fmt.Errorf(\"could not determine latest version of terraform using checkpoint: CHECKPOINT_DISABLE may be set\")\n\t}\n\n\treturn resp.CurrentVersion, nil\n}\n\nfunc (opt *LatestVersionOption) ExecPath(ctx context.Context) (string, error) ", "output": "{\n\tv, err := latestVersion(opt.forceCheckpoint)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn downloadWithVerification(ctx, v, opt.installDir, opt.UserAgent)\n}"}
{"input": "package toolchain\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\n\n\nfunc TestGetVersion(t *testing.T) ", "output": "{\n\ttc := &Toolchain{GoTool: filepath.Join(os.Getenv(\"DATA\"), \"bin/go\")}\n\n\tver, err := tc.GoMinorVersion()\n\trequire.NoError(t, err)\n\trequire.Equal(t, 17, ver)\n}"}
{"input": "package transporttest\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\n\n\n\ntype ContextMatcher struct {\n\tt   *testing.T\n\tttl time.Duration\n\n\tTTLDelta time.Duration\n}\n\n\ntype ContextMatcherOption interface {\n\trun(*ContextMatcher)\n}\n\n\n\ntype ContextTTL time.Duration\n\nfunc (ttl ContextTTL) run(c *ContextMatcher) {\n\tc.ttl = time.Duration(ttl)\n}\n\n\n\n\n\n\n\n\nfunc (c *ContextMatcher) Matches(got interface{}) bool {\n\tctx, ok := got.(context.Context)\n\tif !ok {\n\t\tc.t.Logf(\"expected a Context but got a %T: %v\", got, got)\n\t\treturn false\n\t}\n\n\tif c.ttl != 0 {\n\t\td, ok := ctx.Deadline()\n\t\tif !ok {\n\t\t\tc.t.Logf(\n\t\t\t\t\"expected Context to have a TTL of %v but it has no deadline\", c.ttl)\n\t\t\treturn false\n\t\t}\n\n\t\tttl := time.Until(d)\n\t\tmaxTTL := c.ttl + c.TTLDelta\n\t\tminTTL := c.ttl - c.TTLDelta\n\t\tif ttl > maxTTL || ttl < minTTL {\n\t\t\tc.t.Logf(\"TTL out of expected bounds: %v < %v < %v\", minTTL, ttl, maxTTL)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (c *ContextMatcher) String() string {\n\treturn fmt.Sprintf(\"ContextMatcher(TTL:%v±%v)\", c.ttl, c.TTLDelta)\n}\n\nfunc NewContextMatcher(t *testing.T, options ...ContextMatcherOption) *ContextMatcher ", "output": "{\n\tmatcher := &ContextMatcher{t: t, TTLDelta: DefaultTTLDelta}\n\tfor _, opt := range options {\n\t\topt.run(matcher)\n\t}\n\treturn matcher\n}"}
{"input": "package remote\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/golang/glog\"\n\t\"google.golang.org/grpc\"\n\n\truntimeapi \"k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1\"\n\t\"k8s.io/kubernetes/pkg/kubelet/dockershim\"\n\t\"k8s.io/kubernetes/pkg/kubelet/util\"\n\t\"k8s.io/kubernetes/pkg/util/interrupt\"\n)\n\n\ntype DockerServer struct {\n\tendpoint string\n\tservice DockerService\n\tserver *grpc.Server\n}\n\n\n\n\n\nfunc (s *DockerServer) Start() error {\n\tglog.V(2).Infof(\"Start dockershim grpc server\")\n\tl, err := util.CreateListener(s.endpoint)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to listen on %q: %v\", s.endpoint, err)\n\t}\n\ts.server = grpc.NewServer()\n\truntimeapi.RegisterRuntimeServiceServer(s.server, s.service)\n\truntimeapi.RegisterImageServiceServer(s.server, s.service)\n\tgo func() {\n\t\th := interrupt.New(nil, s.Stop)\n\t\terr := h.Run(func() error { return s.server.Serve(l) })\n\t\tif err != nil {\n\t\t\tglog.Errorf(\"Failed to serve connections: %v\", err)\n\t\t}\n\t}()\n\treturn nil\n}\n\n\nfunc (s *DockerServer) Stop() {\n\tglog.V(2).Infof(\"Stop docker server\")\n\ts.server.Stop()\n}\n\nfunc NewDockerServer(endpoint string, s dockershim.DockerService) *DockerServer ", "output": "{\n\treturn &DockerServer{\n\t\tendpoint: endpoint,\n\t\tservice:  NewDockerService(s),\n\t}\n}"}
{"input": "package sqlwire\n\nimport \"strconv\"\n\n\n\nfunc (d Datum) String() string ", "output": "{\n\tif d.BoolVal != nil {\n\t\tif *d.BoolVal {\n\t\t\treturn \"true\"\n\t\t}\n\t\treturn \"false\"\n\t}\n\tif d.IntVal != nil {\n\t\treturn strconv.FormatInt(*d.IntVal, 10)\n\t}\n\tif d.FloatVal != nil {\n\t\treturn strconv.FormatFloat(*d.FloatVal, 'g', -1, 64)\n\t}\n\tif d.BytesVal != nil {\n\t\treturn string(d.BytesVal)\n\t}\n\tif d.StringVal != nil {\n\t\treturn *d.StringVal\n\t}\n\treturn \"NULL\"\n}"}
{"input": "package core\n\nimport (\n\t\"bytes\"\n\t\"math/big\"\n\n\t\"github.com/ethereum/go-ethereum/core/state\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/params\"\n)\n\n\n\n\n\n\n\n\n\nfunc ValidateDAOHeaderExtraData(config *params.ChainConfig, header *types.Header) error {\n\tif config.DAOForkBlock == nil {\n\t\treturn nil\n\t}\n\tlimit := new(big.Int).Add(config.DAOForkBlock, params.DAOForkExtraRange)\n\tif header.Number.Cmp(config.DAOForkBlock) < 0 || header.Number.Cmp(limit) >= 0 {\n\t\treturn nil\n\t}\n\tif config.DAOForkSupport {\n\t\tif bytes.Compare(header.Extra, params.DAOForkBlockExtra) != 0 {\n\t\t\treturn ValidationError(\"DAO pro-fork bad block extra-data: 0x%x\", header.Extra)\n\t\t}\n\t} else {\n\t\tif bytes.Compare(header.Extra, params.DAOForkBlockExtra) == 0 {\n\t\t\treturn ValidationError(\"DAO no-fork bad block extra-data: 0x%x\", header.Extra)\n\t\t}\n\t}\n\treturn nil\n}\n\n\n\n\n\n\nfunc ApplyDAOHardFork(statedb *state.StateDB) ", "output": "{\n\trefund := statedb.GetOrNewStateObject(params.DAORefundContract)\n\n\tfor _, addr := range params.DAODrainList {\n\t\tif account := statedb.GetStateObject(addr); account != nil {\n\t\t\trefund.AddBalance(account.Balance())\n\t\t\taccount.SetBalance(new(big.Int))\n\t\t}\n\t}\n}"}
{"input": "package wire\n\n\ntype ProviderSet struct{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Build(...interface{}) string {\n\treturn \"implementation not generated, run wire\"\n}\n\n\ntype Binding struct{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Bind(iface, to interface{}) Binding {\n\treturn Binding{}\n}\n\n\n\nconst bindToUsePointer = true\n\n\ntype ProvidedValue struct{}\n\n\n\n\n\n\n\nfunc Value(interface{}) ProvidedValue {\n\treturn ProvidedValue{}\n}\n\n\n\n\n\n\n\n\n\nfunc InterfaceValue(typ interface{}, x interface{}) ProvidedValue {\n\treturn ProvidedValue{}\n}\n\n\ntype StructProvider struct{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Struct(structType interface{}, fieldNames ...string) StructProvider {\n\treturn StructProvider{}\n}\n\n\ntype StructFields struct{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc FieldsOf(structType interface{}, fieldNames ...string) StructFields {\n\treturn StructFields{}\n}\n\nfunc NewSet(...interface{}) ProviderSet ", "output": "{\n\treturn ProviderSet{}\n}"}
{"input": "package channel\n\nimport (\n\t\"math\"\n\n\tcb \"github.com/hyperledger/fabric/protos/common\"\n\t\"github.com/hyperledger/fabric/protos/utils\"\n)\n\nconst defaultHashingAlgorithm = SHA3Shake256\n\nfunc configGroup(key string, value []byte) *cb.ConfigGroup {\n\tresult := cb.NewConfigGroup()\n\tresult.Values[key] = &cb.ConfigValue{\n\t\tValue: value,\n\t}\n\treturn result\n}\n\n\nfunc TemplateHashingAlgorithm(name string) *cb.ConfigGroup {\n\treturn configGroup(HashingAlgorithmKey, utils.MarshalOrPanic(&cb.HashingAlgorithm{Name: name}))\n\n}\n\n\nfunc DefaultHashingAlgorithm() *cb.ConfigGroup {\n\treturn TemplateHashingAlgorithm(defaultHashingAlgorithm)\n}\n\nconst defaultBlockDataHashingStructureWidth = math.MaxUint32\n\n\n\n\n\nfunc DefaultBlockDataHashingStructure() *cb.ConfigGroup {\n\treturn TemplateBlockDataHashingStructure(defaultBlockDataHashingStructureWidth)\n}\n\nvar defaultOrdererAddresses = []string{\"127.0.0.1:7050\"}\n\n\nfunc TemplateOrdererAddresses(addresses []string) *cb.ConfigGroup {\n\treturn configGroup(OrdererAddressesKey, utils.MarshalOrPanic(&cb.OrdererAddresses{Addresses: addresses}))\n}\n\n\nfunc DefaultOrdererAddresses() *cb.ConfigGroup {\n\treturn TemplateOrdererAddresses(defaultOrdererAddresses)\n}\n\nfunc TemplateBlockDataHashingStructure(width uint32) *cb.ConfigGroup ", "output": "{\n\treturn configGroup(BlockDataHashingStructureKey, utils.MarshalOrPanic(&cb.BlockDataHashingStructure{Width: width}))\n}"}
{"input": "package dao\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc TestDaoDelStatCache(t *testing.T) {\n\tvar (\n\t\tmid = int64(0)\n\t)\n\tconvey.Convey(\"DelStatCache\", t, func(ctx convey.C) {\n\t\terr := d.DelStatCache(mid)\n\t\tctx.Convey(\"Then err should be nil.\", func(ctx convey.C) {\n\t\t\tctx.So(err, convey.ShouldBeNil)\n\t\t})\n\t})\n}\n\nfunc TestDaoFollowerAchieve(t *testing.T) {\n\tvar (\n\t\tc        = context.Background()\n\t\tmid      = int64(0)\n\t\tfollower = int64(0)\n\t)\n\tconvey.Convey(\"FollowerAchieve\", t, func(ctx convey.C) {\n\t\td.FollowerAchieve(c, mid, follower)\n\t\tctx.Convey(\"No return values\", func(ctx convey.C) {\n\t\t})\n\t})\n}\n\nfunc TestDaoensureAllFollowerAchieve(t *testing.T) {\n\tvar (\n\t\tc        = context.Background()\n\t\tmid      = int64(0)\n\t\tfollower = int64(0)\n\t)\n\tconvey.Convey(\"ensureAllFollowerAchieve\", t, func(ctx convey.C) {\n\t\td.ensureAllFollowerAchieve(c, mid, follower)\n\t\tctx.Convey(\"No return values\", func(ctx convey.C) {\n\t\t})\n\t})\n}\n\n\n\nfunc TestDaoSendMsg(t *testing.T) ", "output": "{\n\tvar (\n\t\tc       = context.Background()\n\t\tmid     = int64(0)\n\t\ttitle   = \"\"\n\t\tcontext = \"\"\n\t)\n\tconvey.Convey(\"SendMsg\", t, func(ctx convey.C) {\n\t\terr := d.SendMsg(c, mid, title, context)\n\t\tctx.Convey(\"Then err should be nil.\", func(ctx convey.C) {\n\t\t\tctx.So(err, convey.ShouldBeNil)\n\t\t})\n\t})\n}"}
{"input": "package store\n\nimport (\n\t\"strings\"\n\n\t\"github.com/namely/broadway/env\"\n\n\tetcdclient \"github.com/coreos/etcd/client\"\n\t\"github.com/golang/glog\"\n\t\"golang.org/x/net/context\"\n)\n\nvar api etcdclient.KeysAPI\n\nfunc init() {\n\tvar err error\n\tcfg := etcdclient.Config{\n\t\tEndpoints: []string{env.EtcdHost},\n\t}\n\tclient, err := etcdclient.New(cfg)\n\tif err != nil {\n\t\tglog.Fatal(\"wrong etcd client\")\n\t}\n\tapi = etcdclient.NewKeysAPI(client)\n}\n\ntype etcdStore struct{}\n\n\nfunc New() Store {\n\treturn &etcdStore{}\n}\n\n\n\nfunc (*etcdStore) SetValue(path, value string) error {\n\t_, err := api.Set(context.Background(), path, value, nil)\n\treturn err\n}\n\n\nfunc (*etcdStore) Value(path string) string {\n\tresp, err := api.Get(context.Background(), path, nil)\n\tif err == nil && resp.Node != nil {\n\t\treturn resp.Node.Value\n\t}\n\treturn \"\"\n}\n\n\n\n\n\n\n\n\nfunc (*etcdStore) Delete(path string) error {\n\t_, err := api.Delete(context.Background(), path, &etcdclient.DeleteOptions{Recursive: true})\n\treturn err\n}\n\n\nfunc lastKeyItem(key string) string {\n\tkeyItems := strings.Split(key, \"/\")\n\treturn keyItems[len(keyItems)-1]\n}\n\nfunc (*etcdStore) Values(path string) (values map[string]string) ", "output": "{\n\tvalues = map[string]string{}\n\tresp, err := api.Get(context.Background(), path, &etcdclient.GetOptions{Recursive: true})\n\tif err != nil {\n\t\tglog.Warningf(\"Ignoring error getting values: %s. Error: %s\", path, err.Error())\n\t\treturn values\n\t}\n\tif resp.Node != nil && len(resp.Node.Nodes) > 0 {\n\t\tfor _, node := range resp.Node.Nodes {\n\t\t\tvalues[lastKeyItem(node.Key)] = node.Value\n\t\t}\n\t} else {\n\t\tglog.Error(\"No values found here: \" + path)\n\t}\n\treturn values\n}"}
{"input": "package retry\n\nimport (\n\t\"time\"\n)\n\ntype strategyFunc func(now time.Time) Timer\n\n\nfunc (f strategyFunc) NewTimer(now time.Time) Timer {\n\treturn f(now)\n}\n\n\n\n\nfunc LimitCount(n int, strategy Strategy) Strategy {\n\treturn strategyFunc(func(now time.Time) Timer {\n\t\treturn &countLimitTimer{\n\t\t\ttimer:  strategy.NewTimer(now),\n\t\t\tremain: n,\n\t\t}\n\t})\n}\n\ntype countLimitTimer struct {\n\ttimer  Timer\n\tremain int\n}\n\nfunc (t *countLimitTimer) NextSleep(now time.Time) (time.Duration, bool) {\n\tif t.remain--; t.remain <= 0 {\n\t\treturn 0, false\n\t}\n\treturn t.timer.NextSleep(now)\n}\n\n\n\n\n\ntype timeLimitTimer struct {\n\ttimer Timer\n\tend   time.Time\n}\n\nfunc (t *timeLimitTimer) NextSleep(now time.Time) (time.Duration, bool) {\n\tsleep, ok := t.timer.NextSleep(now)\n\tif ok && now.Add(sleep).After(t.end) {\n\t\treturn 0, false\n\t}\n\treturn sleep, ok\n}\n\nfunc LimitTime(limit time.Duration, strategy Strategy) Strategy ", "output": "{\n\treturn strategyFunc(func(now time.Time) Timer {\n\t\treturn &timeLimitTimer{\n\t\t\ttimer: strategy.NewTimer(now),\n\t\t\tend:   now.Add(limit),\n\t\t}\n\t})\n}"}
{"input": "package alibabacloudlogserviceexporter \n\nimport (\n\t\"context\"\n\n\t\"go.opentelemetry.io/collector/component\"\n\t\"go.opentelemetry.io/collector/config\"\n\t\"go.opentelemetry.io/collector/exporter/exporterhelper\"\n\t\"go.opentelemetry.io/collector/model/pdata\"\n\t\"go.uber.org/zap\"\n)\n\n\n\n\ntype logServiceMetricsSender struct {\n\tlogger *zap.Logger\n\tclient LogServiceClient\n}\n\nfunc (s *logServiceMetricsSender) pushMetricsData(\n\t_ context.Context,\n\tmd pdata.Metrics,\n) error {\n\tvar err error\n\tlogs := metricsDataToLogServiceData(s.logger, md)\n\tif len(logs) > 0 {\n\t\terr = s.client.SendLogs(logs)\n\t}\n\treturn err\n}\n\nfunc newMetricsExporter(set component.ExporterCreateSettings, cfg config.Exporter) (component.MetricsExporter, error) ", "output": "{\n\n\tl := &logServiceMetricsSender{\n\t\tlogger: set.Logger,\n\t}\n\n\tvar err error\n\tif l.client, err = NewLogServiceClient(cfg.(*Config), set.Logger); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn exporterhelper.NewMetricsExporter(\n\t\tcfg,\n\t\tset,\n\t\tl.pushMetricsData)\n}"}
{"input": "package core\n\nimport \"github.com/sacloud/libsacloud/v2/pkg/mapconv\"\n\nvar mapconvDecoder = mapconv.Decoder{Config: &mapconv.DecoderConfig{TagName: \"temp\"}}\n\n\n\nfunc cloneParameter(src, dest interface{}) error ", "output": "{\n\treturn mapconvDecoder.ConvertTo(src, dest)\n}"}
{"input": "package marketplaceordering\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient {\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}\n\nfunc New(subscriptionID string) BaseClient ", "output": "{\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}"}
{"input": "package sse_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/rndz/sse\"\n)\n\nfunc Example() {\n\ts := &Server{}\n\tgo runClient()\n\tlog.Fatal(\"HTTP server error: \", http.ListenAndServe(\"localhost:3000\", s))\n}\n\ntype Server struct {\n}\n\nfunc (s *Server) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tflusher, ok := rw.(http.Flusher)\n\tif !ok {\n\t\thttp.Error(rw, \"Streaming unsupported!\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\trw.Header().Set(\"Content-Type\", \"text/event-stream\")\n\trw.Header().Set(\"Cache-Control\", \"no-cache\")\n\trw.Header().Set(\"Connection\", \"keep-alive\")\n\trw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tfor {\n\t\tfmt.Fprintf(rw, \"event: ts\\ndata: %s\\n\\n\", time.Now())\n\t\tfmt.Fprintf(rw, \"event: new\\ndata: %s\\n\\n\", time.Now())\n\t\tflusher.Flush()\n\t\ttime.Sleep(time.Second * 2)\n\t\treturn\n\t}\n}\n\n\n\nfunc runClient() ", "output": "{\n\ttime.Sleep(1 * time.Second)\n\tcfg := &sse.Config{\n\t\tURL: \"http://localhost:3000\",\n\t}\n\tclient, err := sse.New(cfg)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tclient.AddListener(\"ts\", func(e sse.Event) {\n\t\tfmt.Printf(\"%+v\\n\", e)\n\t})\n\tclient.AddListener(\"error\", func(e sse.Event) {\n\t\tfmt.Println(\"error \", e)\n\t})\n\tclient.AddListener(\"open\", func(e sse.Event) {\n\t\tfmt.Println(\"open \", e)\n\t})\n\tclient.Connect()\n}"}
{"input": "package internal\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc Test_providerAuthHeaderWorks(t *testing.T) {\n\tfor _, p := range brokenAuthHeaderProviders {\n\t\tif providerAuthHeaderWorks(p) {\n\t\t\tt.Errorf(\"got %q as unbroken; want broken\", p)\n\t\t}\n\t\tp := fmt.Sprintf(\"%ssomesuffix\", p)\n\t\tif providerAuthHeaderWorks(p) {\n\t\t\tt.Errorf(\"got %q as unbroken; want broken\", p)\n\t\t}\n\t}\n\tp := \"https://api.not-in-the-list-example.com/\"\n\tif !providerAuthHeaderWorks(p) {\n\t\tt.Errorf(\"got %q as unbroken; want broken\", p)\n\t}\n}\n\nfunc TestRegisterBrokenAuthHeaderProvider(t *testing.T) ", "output": "{\n\tRegisterBrokenAuthHeaderProvider(\"https://aaa.com/\")\n\ttokenURL := \"https://aaa.com/token\"\n\tif providerAuthHeaderWorks(tokenURL) {\n\t\tt.Errorf(\"got %q as unbroken; want broken\", tokenURL)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"testing\"\n)\n\ntype testValue struct {\n\tresult bool\n\tvalue  string\n}\n\nfunc TestSupportsTLS(t *testing.T) {\n\ttests := []testValue{\n\t\t{true, \"abba\"},\n\t\t{true, \"abba[mnop]qrst\"},\n\t\t{false, \"abcd[bddb]xyyx\"},\n\t\t{false, \"aaaa[qwer]tyui\"},\n\t\t{true, \"ioxxoj[asdfgh]zxcvbn\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tip := ParseIP(test.value)\n\t\tresult := ip.SupportsTLS()\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Test %d failed.  Expected %v got %v\", i, test.result, result)\n\t\t}\n\t}\n}\n\n\n\nfunc TestSupportSSL(t *testing.T) ", "output": "{\n\ttests := []testValue{\n\t\t{true, \"aba[bab]xyz\"},\n\t\t{false, \"xyx[xyx]xyx\"},\n\t\t{true, \"aaa[kek]eke\"},\n\t\t{true, \"aaa[kek]ekek\"},\n\t\t{true, \"zazbz[bzb]cdb\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tip := ParseIP(test.value)\n\t\tresult := ip.SupportsSSL()\n\t\tif result != test.result {\n\t\t\tt.Errorf(\"Test %d failed.  Expected %v got %v\", i, test.result, result)\n\t\t}\n\t}\n}"}
{"input": "package triton\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/hashicorp/errwrap\"\n)\n\ntype ConfigClient struct {\n\t*Client\n}\n\n\n\nfunc (c *Client) Config() *ConfigClient {\n\treturn &ConfigClient{c}\n}\n\n\ntype Config struct {\n\tDefaultNetwork string `json:\"default_network\"`\n}\n\ntype GetConfigInput struct{}\n\n\nfunc (client *ConfigClient) GetConfig(ctx context.Context, input *GetConfigInput) (*Config, error) {\n\tpath := fmt.Sprintf(\"/%s/config\", client.accountName)\n\trespReader, err := client.executeRequest(ctx, http.MethodGet, path, nil)\n\tif respReader != nil {\n\t\tdefer respReader.Close()\n\t}\n\tif err != nil {\n\t\treturn nil, errwrap.Wrapf(\"Error executing GetConfig request: {{err}}\", err)\n\t}\n\n\tvar result *Config\n\tdecoder := json.NewDecoder(respReader)\n\tif err = decoder.Decode(&result); err != nil {\n\t\treturn nil, errwrap.Wrapf(\"Error decoding GetConfig response: {{err}}\", err)\n\t}\n\n\treturn result, nil\n}\n\ntype UpdateConfigInput struct {\n\tDefaultNetwork string `json:\"default_network\"`\n}\n\n\n\n\nfunc (client *ConfigClient) UpdateConfig(ctx context.Context, input *UpdateConfigInput) (*Config, error) ", "output": "{\n\tpath := fmt.Sprintf(\"/%s/config\", client.accountName)\n\trespReader, err := client.executeRequest(ctx, http.MethodPut, path, input)\n\tif respReader != nil {\n\t\tdefer respReader.Close()\n\t}\n\tif err != nil {\n\t\treturn nil, errwrap.Wrapf(\"Error executing UpdateConfig request: {{err}}\", err)\n\t}\n\n\tvar result *Config\n\tdecoder := json.NewDecoder(respReader)\n\tif err = decoder.Decode(&result); err != nil {\n\t\treturn nil, errwrap.Wrapf(\"Error decoding UpdateConfig response: {{err}}\", err)\n\t}\n\n\treturn result, nil\n}"}
{"input": "package command\n\nimport (\n\t\"github.com/spf13/cobra\"\n)\n\nvar (\n\trootCmd = &cobra.Command{Use: \"app\"}\n)\n\n\n\nfunc Execute() error ", "output": "{\n\treturn rootCmd.Execute()\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\ntype SendPhotoLinkBody struct {\n\n\tCaption string `json:\"caption,omitempty\"`\n\n\tChatID interface{} `json:\"chat_id\"`\n\n\tDisableNotification bool `json:\"disable_notification,omitempty\"`\n\n\tPhoto *string `json:\"photo\"`\n\n\tReplyMarkup interface{} `json:\"reply_markup,omitempty\"`\n\n\tReplyToMessageID int64 `json:\"reply_to_message_id,omitempty\"`\n}\n\n\nfunc (m *SendPhotoLinkBody) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateChatID(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validatePhoto(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *SendPhotoLinkBody) validateChatID(formats strfmt.Registry) error {\n\n\treturn nil\n}\n\nfunc (m *SendPhotoLinkBody) validatePhoto(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"photo\", \"body\", m.Photo); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\n\n\nfunc (m *SendPhotoLinkBody) UnmarshalBinary(b []byte) error {\n\tvar res SendPhotoLinkBody\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *SendPhotoLinkBody) MarshalBinary() ([]byte, error) ", "output": "{\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}"}
{"input": "package handlers\n\nimport (\n\t\"net/http\"\n\t\"strconv\"\n\n\tlog \"github.com/sirupsen/logrus\"\n\n\t\"github.com/codedellemc/rexray/libstorage/api/types\"\n)\n\n\n\ntype queryParamsHandler struct {\n\thandler types.APIFunc\n}\n\nfunc (h *queryParamsHandler) Name() string {\n\treturn \"query-params-handler\"\n}\n\n\n\nfunc NewQueryParamsHandler() types.Middleware {\n\treturn &queryParamsHandler{}\n}\n\n\n\n\nfunc (h *queryParamsHandler) Handle(\n\tctx types.Context,\n\tw http.ResponseWriter,\n\treq *http.Request,\n\tstore types.Store) error {\n\n\tfor k, v := range req.URL.Query() {\n\t\tctx.WithFields(log.Fields{\n\t\t\t\"key\":        k,\n\t\t\t\"value\":      v,\n\t\t\t\"len(value)\": len(v),\n\t\t}).Debug(\"query param\")\n\t\tswitch len(v) {\n\t\tcase 0:\n\t\t\tstore.Set(k, true)\n\t\tcase 1:\n\t\t\tif len(v[0]) == 0 {\n\t\t\t\tstore.Set(k, true)\n\t\t\t} else {\n\t\t\t\tif i, err := strconv.ParseInt(v[0], 10, 64); err == nil {\n\t\t\t\t\tstore.Set(k, i)\n\t\t\t\t} else if b, err := strconv.ParseBool(v[0]); err == nil {\n\t\t\t\t\tstore.Set(k, b)\n\t\t\t\t} else {\n\t\t\t\t\tstore.Set(k, v[0])\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tstore.Set(k, v)\n\t\t}\n\t}\n\treturn h.handler(ctx, w, req, store)\n}\n\nfunc (h *queryParamsHandler) Handler(m types.APIFunc) types.APIFunc ", "output": "{\n\treturn (&queryParamsHandler{m}).Handle\n}"}
{"input": "package ipv6\n\ntype sysICMPFilter struct {\n\tFilt [8]uint32\n}\n\nfunc (f *sysICMPFilter) set(typ ICMPType, block bool) {\n\tif block {\n\t\tf.Filt[typ>>5] &^= 1 << (uint32(typ) & 31)\n\t} else {\n\t\tf.Filt[typ>>5] |= 1 << (uint32(typ) & 31)\n\t}\n}\n\nfunc (f *sysICMPFilter) setAll(block bool) {\n\tfor i := range f.Filt {\n\t\tif block {\n\t\t\tf.Filt[i] = 0\n\t\t} else {\n\t\t\tf.Filt[i] = 1<<32 - 1\n\t\t}\n\t}\n}\n\n\n\nfunc (f *sysICMPFilter) willBlock(typ ICMPType) bool ", "output": "{\n\treturn f.Filt[typ>>5]&(1<<(uint32(typ)&31)) == 0\n}"}
{"input": "package resque\n\nimport (\n\t\"errors\"\n\n\tredis \"gopkg.in/redis.v5\"\n)\n\n\ntype Batch struct {\n\tqueue       string\n\tjobs        []Job\n\tredisClient *redis.Client\n\tnamespace   string\n}\n\n\n\n\nfunc (r *Client) NewBatch(queue string) (*Batch, error) ", "output": "{\n\tif queue == \"\" {\n\t\treturn nil, errors.New(\"invalid queue name\")\n\t}\n\n\treturn &Batch{\n\t\tqueue:       queue,\n\t\tredisClient: r.redisClient,\n\t\tnamespace:   r.namespace,\n\t}, nil\n}"}
{"input": "package configdrive\n\nimport (\n\t\"encoding/json\"\n)\n\ntype Openstack struct {\n\tMetadata OpenstackMetadata\n\tUserdata []byte\n}\n\n\n\nfunc (data *Openstack) PublicKeys() []string {\n\tkeys := []string{}\n\tfor _, value := range data.Metadata.PublicKeys {\n\t\tkeys = append(keys, value)\n\t}\n\treturn keys\n}\n\ntype OpenstackMetadata struct {\n\tAz          string            `json:\"availability_zone\"`\n\tFiles       []struct{}        `json:\"files\"`\n\tHostname    string            `json:\"hostname\"`\n\tLaunchIndex uint              `json:\"launch_index\"`\n\tName        string            `json:\"name\"`\n\tMeta        map[string]string `json:\"meta\"`\n\tPublicKeys  map[string]string `json:\"public_keys\"`\n\tUUID        string            `json:\"uuid\"`\n}\n\nfunc (md *OpenstackMetadata) Unmarshal(in []byte) error {\n\treturn json.Unmarshal(in, md)\n}\n\nfunc (md *OpenstackMetadata) Marshal() ([]byte, error) {\n\treturn json.Marshal(md)\n}\n\nfunc (data *Openstack) Hostname() string ", "output": "{\n\treturn data.Metadata.Hostname\n}"}
{"input": "package oracle\n\n\n\nimport (\n\t\"context\"\n)\n\n\n\n\nfunc AFunc2In(ctx context.Context, db DB, paramOne, paramTwo int64) (int64, error) ", "output": "{\n\tconst sqlstr = `SELECT a_bit_of_everything.a_func_2_in(:1, :2) FROM dual`\n\tvar r0 int64\n\tlogf(sqlstr, paramOne, paramTwo)\n\tif err := db.QueryRowContext(ctx, sqlstr, paramOne, paramTwo).Scan(&r0); err != nil {\n\t\treturn 0, logerror(err)\n\t}\n\treturn r0, nil\n}"}
{"input": "package uaa\n\ntype ClientTokenSession struct {\n\tuaa   UAA\n\ttoken AccessToken\n}\n\n\n\nfunc (c *ClientTokenSession) TokenFunc(retried bool) (string, error) {\n\tif c.token == nil || retried {\n\t\ttoken, err := c.uaa.ClientCredentialsGrant()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tc.token = token\n\t}\n\n\treturn c.token.Type() + \" \" + c.token.Value(), nil\n}\n\nfunc NewClientTokenSession(uaa UAA) *ClientTokenSession ", "output": "{\n\treturn &ClientTokenSession{uaa: uaa}\n}"}
{"input": "package test_helpers\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\tdatatypes \"github.com/maximilien/softlayer-go/data_types\"\n)\n\ntype MockProductPackageService struct{}\n\nfunc (mock *MockProductPackageService) GetName() string {\n\treturn \"Mock_Product_Package_Service\"\n}\n\nfunc (mock *MockProductPackageService) GetItemsByType(packageType string) ([]datatypes.SoftLayer_Product_Item, error) {\n\tresponse, _ := ReadJsonTestFixtures(\"services\", \"SoftLayer_Product_Package_getItemsByType_virtual_server.json\")\n\n\tproductItems := []datatypes.SoftLayer_Product_Item{}\n\tjson.Unmarshal(response, &productItems)\n\n\treturn productItems, nil\n}\n\n\n\nfunc (mock *MockProductPackageService) GetItemPricesBySize(packageId int, size int) ([]datatypes.SoftLayer_Product_Item_Price, error) {\n\treturn []datatypes.SoftLayer_Product_Item_Price{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetItems(packageId int) ([]datatypes.SoftLayer_Product_Item, error) {\n\treturn []datatypes.SoftLayer_Product_Item{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetPackagesByType(packageType string) ([]datatypes.Softlayer_Product_Package, error) {\n\treturn []datatypes.Softlayer_Product_Package{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetOnePackageByType(packageType string) (datatypes.Softlayer_Product_Package, error) {\n\treturn datatypes.Softlayer_Product_Package{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetItemPrices(packageId int) ([]datatypes.SoftLayer_Product_Item_Price, error) ", "output": "{\n\treturn []datatypes.SoftLayer_Product_Item_Price{}, errors.New(\"Not supported\")\n}"}
{"input": "package apigen\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n)\n\ntype c struct{}\n\nfunc (x *c) filename() string {\n\treturn \"mumax2.h\"\n}\n\nfunc (x *c) comment() string {\n\treturn \"\"\n}\n\nfunc (x *c) writeHeader(out io.Writer) {\n\tfmt.Fprintln(out, `\n#ifndef MUMAX2_H\n#define MUMAX2_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n`)\n}\n\nfunc (x *c) writeFooter(out io.Writer) {\n\tfmt.Fprint(out, `\n#ifdef __cplusplus\n}\n#endif\n#endif\n`)\n}\n\n\n\nvar (\n\tc_parse map[string]string = map[string]string{\"int\": \"Integer.parseInt\",\n\t\t\"float32\": \"Float.parseFloat\",\n\t\t\"float64\": \"Double.parseDouble\",\n\t\t\"bool\":    \"Boolean.parseBoolean\"}\n\tc_type map[string]string = map[string]string{\"int\": \"int\",\n\t\t\"float32\": \"float\",\n\t\t\"float64\": \"double\",\n\t\t\"string\":  \"char*\",\n\t\t\"bool\":    \"bool\",\n\t\t\"\":        \"void\"}\n)\n\nfunc (x *c) writeFunc(out io.Writer, funcName string, argTypes []reflect.Type, returnType reflect.Type) ", "output": "{\n\n\tret := \"\"\n\tif returnType != nil {\n\t\tret = returnType.String()\n\t}\n\tret = c_type[ret]\n\n\targs := \"\"\n\tfor i := range argTypes {\n\t\tif i != 0 {\n\t\t\targs += \", \"\n\t\t}\n\t\targs += c_type[argTypes[i].String()] + \" \"\n\t\targs += \"arg\" + fmt.Sprint(i+1)\n\t}\n\n\tcode := fmt.Sprintf(`\n%s %s(%s){\n}\n`,\n\t\tret, funcName, args)\n\n\tfmt.Fprintln(out, code)\n\n}"}
{"input": "package vox\n\ntype Block uint8\n\nconst (\n\tBlockNil        = 0x00\n\tblockActiveMask = 0x80 \n\tblockTypeMask   = 0x7F \n)\n\nfunc (b Block) Active() bool {\n\treturn (blockActiveMask & b) == blockActiveMask\n}\n\nfunc (b Block) Activate(active bool) Block {\n\tif active {\n\t\treturn b | blockActiveMask\n\t}\n\treturn b & blockTypeMask\n}\n\nfunc (b Block) TypeID() uint8 {\n\treturn uint8(b & blockTypeMask)\n}\n\n\n\ntype BlockType struct {\n\tID     uint8\n\tTop    *TextureRegion\n\tBottom *TextureRegion\n\tSide   *TextureRegion\n}\n\ntype BlockBank struct {\n\tTypes   []*BlockType\n\ttypeMap map[uint8]*BlockType\n}\n\nfunc NewBlockBank() *BlockBank {\n\treturn &BlockBank{\n\t\ttypeMap: make(map[uint8]*BlockType),\n\t}\n}\n\nfunc (b *BlockBank) AddType(blockType *BlockType) {\n\tb.typeMap[blockType.ID] = blockType\n\tb.Types = append(b.Types, blockType)\n}\n\nfunc (b *BlockBank) TypeOf(block Block) *BlockType {\n\treturn b.typeMap[block.TypeID()]\n}\n\nfunc (b Block) ChangeType(t *BlockType) Block ", "output": "{\n\treturn Block((uint8(b) & blockActiveMask) | t.ID)\n}"}
{"input": "package sarama\n\nimport (\n\t\"net\"\n\t\"strconv\"\n)\n\n\ntype ConsumerMetadataResponse struct {\n\tErr             KError\n\tCoordinator     *Broker\n\tCoordinatorID   int32  \n\tCoordinatorHost string \n\tCoordinatorPort int32  \n}\n\n\n\nfunc (r *ConsumerMetadataResponse) encode(pe packetEncoder) error {\n\tif r.Coordinator == nil {\n\t\tr.Coordinator = new(Broker)\n\t\tr.Coordinator.id = r.CoordinatorID\n\t\tr.Coordinator.addr = net.JoinHostPort(r.CoordinatorHost, strconv.Itoa(int(r.CoordinatorPort)))\n\t}\n\n\ttmp := &FindCoordinatorResponse{\n\t\tVersion:     0,\n\t\tErr:         r.Err,\n\t\tCoordinator: r.Coordinator,\n\t}\n\n\tif err := tmp.encode(pe); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (r *ConsumerMetadataResponse) key() int16 {\n\treturn 10\n}\n\nfunc (r *ConsumerMetadataResponse) version() int16 {\n\treturn 0\n}\n\nfunc (r *ConsumerMetadataResponse) headerVersion() int16 {\n\treturn 0\n}\n\nfunc (r *ConsumerMetadataResponse) requiredVersion() KafkaVersion {\n\treturn V0_8_2_0\n}\n\nfunc (r *ConsumerMetadataResponse) decode(pd packetDecoder, version int16) (err error) ", "output": "{\n\ttmp := new(FindCoordinatorResponse)\n\n\tif err := tmp.decode(pd, version); err != nil {\n\t\treturn err\n\t}\n\n\tr.Err = tmp.Err\n\n\tr.Coordinator = tmp.Coordinator\n\tif tmp.Coordinator == nil {\n\t\treturn nil\n\t}\n\n\thost, portstr, err := net.SplitHostPort(r.Coordinator.Addr())\n\tif err != nil {\n\t\treturn err\n\t}\n\tport, err := strconv.ParseInt(portstr, 10, 32)\n\tif err != nil {\n\t\treturn err\n\t}\n\tr.CoordinatorID = r.Coordinator.ID()\n\tr.CoordinatorHost = host\n\tr.CoordinatorPort = int32(port)\n\n\treturn nil\n}"}
{"input": "package servicebus\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype ManagementClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\nfunc New(subscriptionID string) ManagementClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) ManagementClient ", "output": "{\n\treturn ManagementClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}"}
{"input": "package ylog\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestLog(t *testing.T) ", "output": "{\n\tInit(\".\")\n\tSetDebug(true)\n\tDebug(\"debug\")\n\tError(\"error\")\n\tWarning(\"warning\")\n\tInfo(\"info\")\n\tClose()\n}"}
{"input": "package mailgun\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/hashicorp/terraform/config\"\n\t\"github.com/hashicorp/terraform/helper/schema\"\n\t\"github.com/hashicorp/terraform/terraform\"\n\t\"github.com/pearkes/mailgun\"\n)\n\nvar testAccProviders map[string]terraform.ResourceProvider\nvar testAccProvider *schema.Provider\n\nfunc init() {\n\ttestAccProvider = Provider().(*schema.Provider)\n\ttestAccProviders = map[string]terraform.ResourceProvider{\n\t\t\"mailgun\": testAccProvider,\n\t}\n}\n\nfunc TestProvider(t *testing.T) {\n\tif err := Provider().(*schema.Provider).InternalValidate(); err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n}\n\nfunc TestProvider_impl(t *testing.T) {\n\tvar _ terraform.ResourceProvider = Provider()\n}\n\n\n\nfunc testAccPreCheck(t *testing.T) {\n\tif v := os.Getenv(\"MAILGUN_API_KEY\"); v == \"\" {\n\t\tt.Fatal(\"MAILGUN_API_KEY must be set for acceptance tests\")\n\t}\n}\n\nfunc TestProviderConfigure(t *testing.T) ", "output": "{\n\tvar expectedKey string\n\n\tif v := os.Getenv(\"MAILGUN_API_KEY\"); v != \"\" {\n\t\texpectedKey = v\n\t} else {\n\t\texpectedKey = \"foo\"\n\t}\n\n\traw := map[string]interface{}{\n\t\t\"api_key\": expectedKey,\n\t}\n\n\trawConfig, err := config.NewRawConfig(raw)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\trp := Provider().(*schema.Provider)\n\terr = rp.Configure(terraform.NewResourceConfig(rawConfig))\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tconfig := rp.Meta().(*mailgun.Client)\n\tif config.ApiKey != expectedKey {\n\t\tt.Fatalf(\"bad: %#v\", config)\n\t}\n}"}
{"input": "\n\nfunc stress1(verbose bool) ", "output": "{\n\tfor i:=0; i<20; i++ {\n\t\tif verbose {\n\t\t\tputs(\"Setting scale to 1\\n\")\n\t\t}\n\t\tscale(1)\n\t\twait(10)\n\n\t\tif verbose {\n\t\t\tputs(\"Setting scale to 2\\n\")\n\t\t}\n\t\tscale(2)\n\t\twait(10)\n\t}\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/ulricqin/beego-blog/g\"\n\t\"github.com/ulricqin/beego-blog/models/blog\"\n\t\"github.com/ulricqin/beego-blog/models/catalog\"\n)\n\ntype MainController struct {\n\tBaseController\n}\n\nfunc (this *MainController) Get() {\n\tthis.Data[\"Catalogs\"] = catalog.All()\n\tthis.Data[\"PageTitle\"] = \"首页\"\n\tthis.Layout = \"layout/default.html\"\n\tthis.TplName = \"index.html\"\n}\n\n\n\nfunc (this *MainController) ListByCatalog() {\n\tcata := this.Ctx.Input.Param(\":ident\")\n\tif cata == \"\" {\n\t\tthis.Ctx.WriteString(\"catalog ident is blank\")\n\t\treturn\n\t}\n\n\tlimit := this.GetIntWithDefault(\"limit\", 10)\n\n\tc := catalog.OneByIdent(cata)\n\tif c == nil {\n\t\tthis.Ctx.WriteString(\"catalog:\" + cata + \" not found\")\n\t\treturn\n\t}\n\n\tids := blog.Ids(c.Id)\n\tpager := this.SetPaginator(limit, int64(len(ids)))\n\tblogs := blog.ByCatalog(c.Id, pager.Offset(), limit)\n\n\tthis.Data[\"Catalog\"] = c\n\tthis.Data[\"Blogs\"] = blogs\n\tthis.Data[\"PageTitle\"] = c.Name\n\n\tthis.Layout = \"layout/default.html\"\n\tthis.TplName = \"article/by_catalog.html\"\n}\n\nfunc (this *MainController) Read() ", "output": "{\n\tident := this.GetString(\":ident\")\n\tb := blog.OneByIdent(ident)\n\tif b == nil {\n\t\tthis.Ctx.WriteString(\"no such article\")\n\t\treturn\n\t}\n\n\tb.Views = b.Views + 1\n\tblog.Update(b, \"\")\n\n\tthis.Data[\"Blog\"] = b\n\tthis.Data[\"Content\"] = g.RenderMarkdown(blog.ReadBlogContent(b).Content)\n\tthis.Data[\"PageTitle\"] = b.Title\n\tthis.Data[\"Catalog\"] = catalog.OneById(b.CatalogId)\n\tthis.Layout = \"layout/default.html\"\n\tthis.TplName = \"article/read.html\"\n}"}
{"input": "package spark\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nvar httpClient *http.Client\n\nfunc init() {\n\thttpClient = &http.Client{}\n}\n\nfunc (s *Spark) request(req *http.Request) ([]byte, error) {\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", s.token))\n\treq.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\n\tres, err := httpClient.Do(req)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\tbs, err := ioutil.ReadAll(res.Body)\n\n\tif res.StatusCode != http.StatusOK {\n\t\tif res.StatusCode != 204 {\n\t\t\te := fmt.Sprintf(\"HTTP Status Code: %d\\n%s\", res.StatusCode, string(bs))\n\t\t\treturn nil, errors.New(e)\n\t\t}\n\t}\n\n\treturn bs, err\n}\n\nfunc (s *Spark) GetRequest(url string, uv *url.Values) ([]byte, error) {\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif uv != nil {\n\t\treq.URL.RawQuery = (*uv).Encode()\n\t}\n\treturn s.request(req)\n}\n\nfunc (s *Spark) PostRequest(url string, body *bytes.Buffer) ([]byte, error) {\n\treq, err := http.NewRequest(\"POST\", url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.request(req)\n}\n\n\n\nfunc (s *Spark) DeleteRequest(url string) ([]byte, error) ", "output": "{\n\tfmt.Println(\"Delete url: \", url)\n\treq, err := http.NewRequest(\"DELETE\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.request(req)\n}"}
{"input": "package markdown\n\nimport (\n\t\"bufio\"\n\t\"io\"\n)\n\ntype writer interface {\n\tWrite([]byte) (int, error)\n\tWriteByte(byte) error\n\tWriteString(string) (int, error)\n\tFlush() error\n}\n\ntype monadicWriter struct {\n\twriter\n\terr error\n}\n\nfunc newMonadicWriter(w io.Writer) *monadicWriter {\n\tif w, ok := w.(writer); ok {\n\t\treturn &monadicWriter{writer: w}\n\t}\n\treturn &monadicWriter{writer: bufio.NewWriter(w)}\n}\n\nfunc (w *monadicWriter) Write(p []byte) (n int, err error) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\n\tn, err = w.writer.Write(p)\n\tw.err = err\n\treturn\n}\n\nfunc (w *monadicWriter) WriteByte(b byte) (err error) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\n\terr = w.writer.WriteByte(b)\n\tw.err = err\n\treturn\n}\n\nfunc (w *monadicWriter) WriteString(s string) (n int, err error) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\n\tn, err = w.writer.WriteString(s)\n\tw.err = err\n\treturn\n}\n\n\n\nfunc (w *monadicWriter) Flush() (err error) ", "output": "{\n\tif w.err != nil {\n\t\treturn\n\t}\n\n\terr = w.writer.Flush()\n\tw.err = err\n\treturn\n}"}
{"input": "package persist\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"os\"\n)\n\n\nfunc Load(meta Metadata, data interface{}, r io.Reader) error {\n\tvar header, version string\n\tdec := json.NewDecoder(r)\n\tif err := dec.Decode(&header); err != nil {\n\t\treturn err\n\t}\n\tif header != meta.Header {\n\t\treturn ErrBadHeader\n\t}\n\tif err := dec.Decode(&version); err != nil {\n\t\treturn err\n\t}\n\tif version != meta.Version {\n\t\treturn ErrBadVersion\n\t}\n\tif err := dec.Decode(data); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc LoadFile(meta Metadata, data interface{}, filename string) error {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\terr = Load(meta, data, file)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc SaveFile(meta Metadata, data interface{}, filename string) error {\n\tfile, err := NewSafeFile(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\terr = Save(meta, data, file)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn file.Commit()\n}\n\n\nfunc SaveFileSync(meta Metadata, data interface{}, filename string) error {\n\tfile, err := NewSafeFile(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\terr = Save(meta, data, file)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn file.CommitSync()\n}\n\nfunc Save(meta Metadata, data interface{}, w io.Writer) error ", "output": "{\n\tb, err := json.MarshalIndent(data, \"\", \"\\t\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tenc := json.NewEncoder(w)\n\tif err := enc.Encode(meta.Header); err != nil {\n\t\treturn err\n\t}\n\tif err := enc.Encode(meta.Version); err != nil {\n\t\treturn err\n\t}\n\tif _, err = w.Write(b); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package builtin\n\nconst systemTraceSummary = `allows using kernel tracing facilities`\n\nconst systemTraceConnectedPlugAppArmor = `\n# Description: Can use kernel tracing facilities. This is restricted because it\n# gives privileged access to all processes on the system and should only be\n# used with trusted apps.\n\n  # For the bpf() syscall and manipulating bpf map types\n  capability sys_admin,\n  capability sys_resource,\n\n  # For kernel probes, etc\n  /sys/kernel/debug/kprobes/ r,\n  /sys/kernel/debug/kprobes/** r,\n\n  /sys/kernel/debug/tracing/ r,\n  /sys/kernel/debug/tracing/** rw,\n\n  # Access to kernel headers required for iovisor/bcc. This is typically\n  # detected with 'ls -l /lib/modules/$(uname -r)/build/' which is a symlink\n  # to /usr/src on Ubuntu and so only /usr/src is needed.\n  /usr/src/ r,\n  /usr/src/** r,\n`\n\nconst systemTraceConnectedPlugSecComp = `\n# Description: Can use kernel tracing facilities. This is restricted because it\n# gives privileged access to all processes on the system and should only be\n# used with trusted apps.\n\nbpf\nperf_event_open\n`\n\n\n\nfunc init() ", "output": "{\n\tregisterIface(&commonInterface{\n\t\tname:                  \"system-trace\",\n\t\tsummary:               systemTraceSummary,\n\t\timplicitOnCore:        true,\n\t\timplicitOnClassic:     true,\n\t\tconnectedPlugAppArmor: systemTraceConnectedPlugAppArmor,\n\t\tconnectedPlugSecComp:  systemTraceConnectedPlugSecComp,\n\t\treservedForOS:         true,\n\t})\n}"}
{"input": "package buffer\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\n\ntype Buffer interface {\n\tLen() int64 \n\tCap() int64 \n\tio.Reader   \n\tio.Writer   \n\tReset()     \n}\n\n\ntype BufferAt interface {\n\tBuffer\n\tio.ReaderAt\n\tio.WriterAt\n}\n\nfunc len64(p []byte) int64 {\n\treturn int64(len(p))\n}\n\n\nfunc Gap(buf Buffer) int64 {\n\treturn buf.Cap() - buf.Len()\n}\n\n\n\n\n\nfunc Empty(buf Buffer) bool {\n\treturn buf.Len() == 0\n}\n\n\n\nfunc NewUnboundedBuffer(mem, file int64) Buffer {\n\treturn NewMulti(New(mem), NewPartition(NewFilePool(file, os.TempDir())))\n}\n\nfunc Full(buf Buffer) bool ", "output": "{\n\treturn buf.Len() == buf.Cap()\n}"}
{"input": "package time\n\nimport (\n\t\"errors\"\n\t\"syscall\"\n)\n\n\nfunc interrupt() {\n}\n\n\n\n\nfunc readFile(name string) ([]byte, error) {\n\tf, err := syscall.Open(name, syscall.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer syscall.Close(f)\n\tvar (\n\t\tbuf [4096]byte\n\t\tret []byte\n\t\tn   int\n\t)\n\tfor {\n\t\tn, err = syscall.Read(f, buf[:])\n\t\tif n > 0 {\n\t\t\tret = append(ret, buf[:n]...)\n\t\t}\n\t\tif n == 0 || err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn ret, err\n}\n\nfunc open(name string) (uintptr, error) {\n\tfd, err := syscall.Open(name, syscall.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn uintptr(fd), nil\n}\n\n\n\nfunc preadn(fd uintptr, buf []byte, off int) error {\n\twhence := seekStart\n\tif off < 0 {\n\t\twhence = seekEnd\n\t}\n\tif _, err := syscall.Seek(syscall.Handle(fd), int64(off), whence); err != nil {\n\t\treturn err\n\t}\n\tfor len(buf) > 0 {\n\t\tm, err := syscall.Read(syscall.Handle(fd), buf)\n\t\tif m <= 0 {\n\t\t\tif err == nil {\n\t\t\t\treturn errors.New(\"short read\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tbuf = buf[m:]\n\t}\n\treturn nil\n}\n\nfunc closefd(fd uintptr) ", "output": "{\n\tsyscall.Close(syscall.Handle(fd))\n}"}
{"input": "package decorator\n\nimport (\n\t\"fmt\"\n)\n\ntype DefaultDecorator struct {\n}\n\nfunc (i *DefaultDecorator) ToString(field interface{}) (string, error) {\n\treturn fmt.Sprintf(\"%v\", field), nil\n}\n\n\n\nfunc (i *DefaultDecorator) FromString(field string) (interface{}, error) ", "output": "{\n\treturn field, nil\n}"}
{"input": "package gpgconf\n\nimport (\n\t\"os\"\n\t\"syscall\"\n)\n\nvar (\n\tfd0 = \"/proc/self/fd/0\"\n)\n\n\n\n\n\n\nfunc Umask(mask int) int {\n\treturn syscall.Umask(mask)\n}\n\nfunc TTY() string ", "output": "{\n\tdest, err := os.Readlink(fd0)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn dest\n}"}
{"input": "package astutils\n\nimport (\n\t\"go/ast\"\n\t\"go/types\"\n)\n\n\n\n\n\nfunc FieldListNames(fieldList *ast.FieldList, position int) []*ast.Ident {\n\tif fieldList == nil {\n\t\treturn nil\n\t}\n\n\tif len(fieldList.List) <= position {\n\t\treturn nil\n\t}\n\n\tfield := fieldList.List[position]\n\n\tif field == nil {\n\t\treturn nil\n\t}\n\n\treturn field.Names\n}\n\n\nfunc FieldListType(fieldList *ast.FieldList, position int) *ast.Expr {\n\tif fieldList == nil {\n\t\treturn nil\n\t}\n\n\tif len(fieldList.List) <= position {\n\t\treturn nil\n\t}\n\n\tfield := fieldList.List[position]\n\n\tif field == nil {\n\t\treturn nil\n\t}\n\n\treturn &field.Type\n}\n\n\n\nfunc HasFieldListLength(fieldList *ast.FieldList, expectedLength int) bool {\n\tif fieldList == nil {\n\t\treturn expectedLength == 0\n\t}\n\n\treturn len(fieldList.List) == expectedLength\n}\n\n\nfunc IsFieldListType(fieldList *ast.FieldList, position int, exprFunc func(ast.Expr) bool) bool {\n\tt := FieldListType(fieldList, position)\n\n\treturn t != nil && exprFunc(*t)\n}\n\n\nfunc IsFieldListTypePackageType(fieldList *ast.FieldList, position int, info *types.Info, packageSuffix string, typeName string) bool {\n\tt := FieldListType(fieldList, position)\n\n\treturn t != nil && IsPackageFunctionFieldListType(*t, info, packageSuffix, typeName)\n}\n\nfunc FieldListName(fieldList *ast.FieldList, fieldPosition int, namePosition int) *string ", "output": "{\n\tnames := FieldListNames(fieldList, fieldPosition)\n\n\tif names == nil || len(names) <= namePosition {\n\t\treturn nil\n\t}\n\n\tname := names[namePosition]\n\n\tif name == nil {\n\t\treturn nil\n\t}\n\n\treturn &name.Name\n}"}
{"input": "package store\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc interestingGoroutines() (gs []string) {\n\tbuf := make([]byte, 2<<20)\n\tbuf = buf[:runtime.Stack(buf, true)]\n\tfor _, g := range strings.Split(string(buf), \"\\n\\n\") {\n\t\tsl := strings.SplitN(g, \"\\n\", 2)\n\t\tif len(sl) != 2 {\n\t\t\tcontinue\n\t\t}\n\t\tstack := strings.TrimSpace(sl[1])\n\t\tif stack == \"\" ||\n\t\t\tstrings.Contains(stack, \"created by testing.RunTests\") ||\n\t\t\tstrings.Contains(stack, \"testing.Main(\") ||\n\t\t\tstrings.Contains(stack, \"runtime.goexit\") ||\n\t\t\tstrings.Contains(stack, \"github.com/coreos/rkt/store.interestingGoroutines\") ||\n\t\t\tstrings.Contains(stack, \"created by runtime.gc\") ||\n\t\t\tstrings.Contains(stack, \"runtime.MHeap_Scavenger\") {\n\t\t\tcontinue\n\t\t}\n\t\tgs = append(gs, stack)\n\t}\n\tsort.Strings(gs)\n\treturn\n}\n\n\n\n\nfunc goroutineLeaked() bool {\n\tif testing.Short() {\n\t\treturn false\n\t}\n\tgs := interestingGoroutines()\n\n\tn := 0\n\tstackCount := make(map[string]int)\n\tfor _, g := range gs {\n\t\tstackCount[g]++\n\t\tn++\n\t}\n\n\tif n == 0 {\n\t\treturn false\n\t}\n\tfmt.Fprintf(os.Stderr, \"Too many goroutines running after integration test(s).\\n\")\n\tfor stack, count := range stackCount {\n\t\tfmt.Fprintf(os.Stderr, \"%d instances of:\\n%s\\n\", count, stack)\n\t}\n\treturn true\n}\n\nfunc TestMain(m *testing.M) ", "output": "{\n\tv := m.Run()\n\tif v == 0 && goroutineLeaked() {\n\t\tos.Exit(1)\n\t}\n\tos.Exit(v)\n}"}
{"input": "package db\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang/glog\"\n\t\"github.com/hobeone/tv2go/naming\"\n)\n\n\ntype NameException struct {\n\tID        int64\n\tSource    string\n\tIndexer   string\n\tIndexerID int64\n\tName      string\n\tSeason    int64\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}\n\n\nfunc (e *NameException) BeforeSave() error {\n\tif e.Indexer == \"\" {\n\t\treturn fmt.Errorf(\"NameException Indexer can't be blank\")\n\t}\n\tif e.Source == \"\" {\n\t\treturn fmt.Errorf(\"NameException Source can't be blank\")\n\t}\n\tif e.IndexerID == 0 {\n\t\treturn fmt.Errorf(\"NameException IndexerID can't be blank\")\n\t}\n\tif e.Name == \"\" {\n\t\treturn fmt.Errorf(\"NameException Name can't be blank\")\n\t}\n\treturn nil\n}\n\n\n\n\n\n\n\n\nfunc (h *Handle) SaveNameExceptions(source string, excepts []*NameException) error {\n\tif h.writeUpdates {\n\t\ttx := h.db.Begin()\n\t\terr := tx.Where(\"source = ?\", source).Delete(NameException{}).Error\n\t\tif err != nil {\n\t\t\tglog.Errorf(\"Couldn't delete old name exceptions for %s: %s\", source, err)\n\t\t\ttx.Rollback()\n\t\t\treturn err\n\t\t}\n\t\tfor _, e := range excepts {\n\t\t\terr := tx.Save(e).Error\n\t\t\tif err != nil {\n\t\t\t\tglog.Errorf(\"Error saving exceptions to the database: %s\", err.Error())\n\t\t\t\ttx.Rollback()\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\ttx.Commit()\n\t}\n\treturn nil\n}\n\nfunc (h *Handle) GetShowFromNameException(name string) (*Show, int64, error) ", "output": "{\n\tne := &[]NameException{}\n\terr := h.db.Where(\"name = ? COLLATE NOCASE\", name).Find(ne).Error\n\tif err != nil {\n\t\tne = &[]NameException{}\n\t\tsceneName := naming.FullSanitizeSceneName(name)\n\t\tglog.Infof(\"searching for name '%s' with scene name '%s'\", name, sceneName)\n\n\t\terr = h.db.Where(\"name = ? COLLATE NOCASE\", name).Find(ne).Error\n\t\tif err != nil {\n\t\t\treturn nil, -1, err\n\t\t}\n\t}\n\tfor _, exp := range *ne {\n\t\tshow, err := h.GetShowByIndexerAndID(exp.Indexer, exp.IndexerID)\n\t\tif err == nil {\n\t\t\treturn show, exp.Season, nil\n\t\t}\n\t}\n\treturn nil, -1, fmt.Errorf(\"Couldn't find matching show for %s\", name)\n}"}
{"input": "package events\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\n\n\ntype SecondsEpochTime struct {\n\ttime.Time\n}\n\n\ntype MilliSecondsEpochTime struct {\n\ttime.Time\n}\n\nconst secondsToNanoSecondsFactor = 1000000000\nconst milliSecondsToNanoSecondsFactor = 1000000\n\nfunc (e SecondsEpochTime) MarshalJSON() ([]byte, error) {\n\tunixTime := float64(e.UnixNano()) / float64(secondsToNanoSecondsFactor)\n\treturn json.Marshal(unixTime)\n}\n\nfunc (e *SecondsEpochTime) UnmarshalJSON(b []byte) error {\n\tvar epoch float64\n\terr := json.Unmarshal(b, &epoch)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tepochSec := int64(epoch)\n\tepochNano := int64((epoch - float64(epochSec)) * float64(secondsToNanoSecondsFactor))\n\n\t*e = SecondsEpochTime{time.Unix(epochSec, epochNano)}\n\treturn nil\n}\n\n\n\nfunc (e *MilliSecondsEpochTime) UnmarshalJSON(b []byte) error {\n\tvar epoch int64\n\terr := json.Unmarshal(b, &epoch)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*e = MilliSecondsEpochTime{time.Unix(epoch/1000, (epoch%1000)*1000000)}\n\treturn nil\n}\n\nfunc (e MilliSecondsEpochTime) MarshalJSON() ([]byte, error) ", "output": "{\n\tunixTimeMs := e.UnixNano() / milliSecondsToNanoSecondsFactor\n\treturn json.Marshal(unixTimeMs)\n}"}
{"input": "package source\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc f(from string) {\n\tfor i := 0; i<3; i++ {\n\t\tfmt.Println(from, \":\", i)\n\t\ttime.Sleep(time.Second)\n\t}\n}\n\n\n\nfunc Goroutines() ", "output": "{\n\n\tf(\"direct\")\n\n\tgo f(\"goroutine\")\n\n\tgo func(msg string) {\n\t\tfmt.Println(msg)\n\t}(\"going\")\n\n\ttime.Sleep(time.Second*5)\n\n}"}
{"input": "package commands\n\nimport (\n\t\"github.com/jawher/mow.cli\"\n\t\"github.com/mesanine/mesos-cli/config\"\n\t\"github.com/mesanine/mesos-cli/mesosfile\"\n\t\"github.com/mesanine/mesos-cli/runner\"\n)\n\ntype Run struct{}\n\nfunc (_ Run) Name() string { return \"run\" }\nfunc (_ Run) Desc() string { return \"Run tasks on Mesos\" }\n\n\n\nfunc (_ Run) Init(profile config.ProfileFn) func(*cli.Cmd) ", "output": "{\n\treturn func(cmd *cli.Cmd) {\n\t\tcmd.Spec = \"[OPTIONS] [FILE]\"\n\n\t\tvar (\n\t\t\tfile     = cmd.StringArg(\"FILE\", \"Mesosfile\", \"File containing Mesos Task information, - for stdin\")\n\t\t\thostname = cmd.StringOpt(\"m master\", \"\", \"Mesos Master\")\n\t\t\trestart  = cmd.BoolOpt(\"restart\", false, \"Restart containers on failure\")\n\t\t\tsync     = cmd.BoolOpt(\"s sync\", false, \"Run containers synchronously\")\n\t\t)\n\n\t\tcmd.Action = func() {\n\t\t\tprofile().With(\n\t\t\t\tconfig.Master(*hostname),\n\t\t\t\tconfig.Restart(*restart),\n\t\t\t\tconfig.Sync(*sync),\n\t\t\t)\n\n\t\t\tmf, err := mesosfile.Load(*file)\n\t\t\tfailOnErr(err)\n\n\t\t\tfailOnErr(runner.Run(profile(), mf))\n\t\t}\n\t}\n}"}
{"input": "package stores\n\nimport \"jvmgo/ch08/instructions/base\"\nimport \"jvmgo/ch08/rtda\"\n\n\ntype ASTORE struct{ base.Index8Instruction }\n\nfunc (self *ASTORE) Execute(frame *rtda.Frame) {\n\t_astore(frame, uint(self.Index))\n}\n\ntype ASTORE_0 struct{ base.NoOperandsInstruction }\n\nfunc (self *ASTORE_0) Execute(frame *rtda.Frame) {\n\t_astore(frame, 0)\n}\n\ntype ASTORE_1 struct{ base.NoOperandsInstruction }\n\nfunc (self *ASTORE_1) Execute(frame *rtda.Frame) {\n\t_astore(frame, 1)\n}\n\ntype ASTORE_2 struct{ base.NoOperandsInstruction }\n\nfunc (self *ASTORE_2) Execute(frame *rtda.Frame) {\n\t_astore(frame, 2)\n}\n\ntype ASTORE_3 struct{ base.NoOperandsInstruction }\n\nfunc (self *ASTORE_3) Execute(frame *rtda.Frame) {\n\t_astore(frame, 3)\n}\n\n\n\nfunc _astore(frame *rtda.Frame, index uint) ", "output": "{\n\tref := frame.OperandStack().PopRef()\n\tframe.LocalVars().SetRef(index, ref)\n}"}
{"input": "package clientv3\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/coreos/etcd/etcdserver\"\n\t\"github.com/coreos/etcd/pkg/testutil\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc\"\n)\n\nfunc TestDialTimeout(t *testing.T) {\n\tdefer testutil.AfterTest(t)\n\n\tdonec := make(chan error)\n\tgo func() {\n\t\tcfg := Config{\n\t\t\tEndpoints:   []string{\"localhost:12345\"},\n\t\t\tDialTimeout: 2 * time.Second}\n\t\tc, err := New(cfg)\n\t\tif c != nil || err == nil {\n\t\t\tt.Errorf(\"new client should fail\")\n\t\t}\n\t\tdonec <- err\n\t}()\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tselect {\n\tcase err := <-donec:\n\t\tt.Errorf(\"dial didn't wait (%v)\", err)\n\tdefault:\n\t}\n\n\tselect {\n\tcase <-time.After(5 * time.Second):\n\t\tt.Errorf(\"failed to timeout dial on time\")\n\tcase err := <-donec:\n\t\tif err != grpc.ErrClientConnTimeout {\n\t\t\tt.Errorf(\"unexpected error %v, want %v\", err, grpc.ErrClientConnTimeout)\n\t\t}\n\t}\n}\n\nfunc TestDialNoTimeout(t *testing.T) {\n\tcfg := Config{Endpoints: []string{\"127.0.0.1:12345\"}}\n\tc, err := New(cfg)\n\tif c == nil || err != nil {\n\t\tt.Fatalf(\"new client with DialNoWait should succeed, got %v\", err)\n\t}\n\tc.Close()\n}\n\n\n\nfunc TestIsHaltErr(t *testing.T) ", "output": "{\n\tif !isHaltErr(nil, fmt.Errorf(\"etcdserver: some etcdserver error\")) {\n\t\tt.Errorf(`error prefixed with \"etcdserver: \" should be Halted by default`)\n\t}\n\tif isHaltErr(nil, etcdserver.ErrStopped) {\n\t\tt.Errorf(\"error %v should not halt\", etcdserver.ErrStopped)\n\t}\n\tif isHaltErr(nil, etcdserver.ErrNoLeader) {\n\t\tt.Errorf(\"error %v should not halt\", etcdserver.ErrNoLeader)\n\t}\n\tctx, cancel := context.WithCancel(context.TODO())\n\tif isHaltErr(ctx, nil) {\n\t\tt.Errorf(\"no error and active context should not be Halted\")\n\t}\n\tcancel()\n\tif !isHaltErr(ctx, nil) {\n\t\tt.Errorf(\"cancel on context should be Halted\")\n\t}\n}"}
{"input": "package cmd\n\nimport (\n\t\"testing\"\n\t\"bytes\"\n\t\"os\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\t. \"github.com/spf13/cobra\"\n\t\"github.com/spf13/pflag\"\n\t\"net/http\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"io/ioutil\"\n)\n\nfunc TestCmd(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Cmd Suite\")\n}\n\n\n\n\nfunc executeCommand(root *Command, args ...string) (stdout string, output string, err error) {\n\tstdout, output, err = executeCommandC(root, args...)\n\treturn strings.TrimRight(stdout, \"\\n\"), output, err\n}\n\n\n\n\nfunc resetCommandLineFlagSet() {\n\tpflag.CommandLine = pflag.NewFlagSet(os.Args[0], pflag.ExitOnError)\n}\n\nfunc testMethod(r *http.Request, want string) {\n\tif got := r.Method; got != want {\n\t\tFail(fmt.Sprintf(\"Request method: %s, want %s\", got, want))\n\t}\n}\n\nfunc readFixture(fixture string) string {\n\tpath := fmt.Sprintf(\"fixtures/%s.json\", fixture)\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\tFail(fmt.Sprintf(\"Fixture %s could not be found in %s\", fixture, path))\n\t}\n\tcontent, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tFail(err.Error())\n\t}\n\treturn string(content)\n}\n\nfunc executeCommandC(root *Command, args ...string) (stdout string, output string, err error) ", "output": "{\n\tbuf := new(bytes.Buffer)\n\troot.SetOutput(buf) \n\troot.SetArgs(args)\n\n\told := os.Stdout \n\tr, w, _ := os.Pipe()\n\tos.Stdout = w\n\n\t_, err = root.ExecuteC()\n\n\toutC := make(chan string)\n\tgo func() {\n\t\tvar buf bytes.Buffer\n\t\tio.Copy(&buf, r)\n\t\toutC <- buf.String()\n\t}()\n\n\tw.Close()\n\tos.Stdout = old \n\tstdout = <-outC\n\n\treturn stdout, buf.String(), err\n}"}
{"input": "package update\n\nimport (\n\t\"github.com/spf13/cobra\"\n\n\t\"github.com/emicklei/go-restful/log\"\n\t\"github.com/kubernetes-incubator/apiserver-builder/cmd/apiserver-boot/boot/init_repo\"\n)\n\nvar vendorCmd = &cobra.Command{\n\tUse:   \"vendor\",\n\tShort: \"Update the vendor packages managed by apiserver-builder.\",\n\tLong:  `Update the vendor packages managed by apiserver-builder.`,\n\tExample: `# Replace the vendor packages managed by apiserver-builder with versions for the current install.\napiserver-boot update vendor\n`,\n\tRun: RunUpdateVendor,\n}\n\nfunc AddUpdateVendorCmd(cmd *cobra.Command) {\n\tcmd.AddCommand(vendorCmd)\n}\n\n\n\nfunc RunUpdateVendor(cmd *cobra.Command, args []string) ", "output": "{\n\tinit_repo.Update = true\n\tlog.Printf(\"Replacing vendored libraries managed by apiserver-builder with the current version.\")\n\tinit_repo.CopyGlide()\n}"}
{"input": "package engine\n\nimport (\n\t\"testing\"\n\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\nfunc TestUnitsCounterAddBalance(t *testing.T) {\n\tuc := &UnitsCounter{\n\t\tDirection:   OUTBOUND,\n\t\tBalanceType: utils.SMS,\n\t\tBalances:    BalanceChain{&Balance{Value: 1}, &Balance{Weight: 20, DestinationIds: \"NAT\"}, &Balance{Weight: 10, DestinationIds: \"RET\"}},\n\t}\n\tuc.addUnits(20, \"test\")\n\tif len(uc.Balances) != 3 {\n\t\tt.Error(\"Error adding minute bucket: \", uc.Balances)\n\t}\n}\n\n\n\nfunc TestUnitsCounterAddBalanceExists(t *testing.T) ", "output": "{\n\tuc := &UnitsCounter{\n\t\tDirection:   OUTBOUND,\n\t\tBalanceType: utils.SMS,\n\t\tBalances:    BalanceChain{&Balance{Value: 1}, &Balance{Value: 10, Weight: 20, DestinationIds: \"NAT\"}, &Balance{Weight: 10, DestinationIds: \"RET\"}},\n\t}\n\tuc.addUnits(5, \"0723\")\n\tif len(uc.Balances) != 3 || uc.Balances[1].Value != 15 {\n\t\tt.Error(\"Error adding minute bucket!\")\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/cobra/doc\"\n)\n\nvar (\n\tmangenCmd = &cobra.Command{\n\t\tUse:   \"man-generation [path]\",\n\t\tShort: \"Creates unix style manpages.\",\n\t\tLong:  \"Creates unix style man pages at the specified directory.\",\n\t\tRun:   wrap(mangencmd),\n\t}\n)\n\n\n\nfunc mangencmd(path string) ", "output": "{\n\theader := &doc.GenManHeader{\n\t\tSection: \"1\",\n\t\tManual:  \"siac Manual\",\n\t\tSource:  \"\",\n\t}\n\n\tdoc.GenManTree(rootCmd, header, path)\n}"}
{"input": "package main ;\nvar m int = 10 ;\nfunc main() { println(fibonacci(m)) ;\n\t} ;\n ;\n\nfunc fibonacci(n int) int ", "output": "{ if n < 2 { return n ;\n\t} ;\n\treturn fibonacci(n - 1) + fibonacci(n - 2) ;\n}"}
{"input": "package remotecontext \n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc createTestTempSubdir(t *testing.T, dir, prefix string) string {\n\tpath, err := os.MkdirTemp(dir, prefix)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Error when creating directory %s with prefix %s: %s\", dir, prefix, err)\n\t}\n\n\treturn path\n}\n\n\n\nfunc createTestTempFile(t *testing.T, dir, filename, contents string, perm os.FileMode) string {\n\tfilePath := filepath.Join(dir, filename)\n\terr := os.WriteFile(filePath, []byte(contents), perm)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Error when creating %s file: %s\", filename, err)\n\t}\n\n\treturn filePath\n}\n\nfunc createTestTempDir(t *testing.T, dir, prefix string) (string, func()) ", "output": "{\n\tpath, err := os.MkdirTemp(dir, prefix)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Error when creating directory %s with prefix %s: %s\", dir, prefix, err)\n\t}\n\n\treturn path, func() {\n\t\terr = os.RemoveAll(path)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error when removing directory %s: %s\", path, err)\n\t\t}\n\t}\n}"}
{"input": "package strings\n\nimport (\n\t\"io\"\n)\n\ntype Reader struct {\n\ts string\n}\n\n\n\nfunc (r *Reader) Read(buf []byte) (n int, err error) {\n\tn = copy(buf, r.s)\n\tr.s = r.s[n:]\n\tif len(r.s) == 0 {\n\t\terr = io.EOF\n\t}\n\treturn\n}\n\nfunc MakeReader(s string) Reader ", "output": "{\n\treturn Reader{s}\n}"}
{"input": "package communicator\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/hashicorp/packer/helper/multistep\"\n)\n\n\n\n\nfunc CommHost(host string, statebagKey string) func(multistep.StateBag) (string, error) ", "output": "{\n\treturn func(state multistep.StateBag) (string, error) {\n\t\tif host != \"\" {\n\t\t\tlog.Printf(\"Using ssh_host value: %s\", host)\n\t\t\treturn host, nil\n\t\t}\n\t\tipAddress, hasIP := state.Get(statebagKey).(string)\n\t\tif !hasIP {\n\t\t\treturn \"\", fmt.Errorf(\"Failed to retrieve IP address.\")\n\t\t}\n\t\treturn ipAddress, nil\n\t}\n}"}
{"input": "package protolog \n\nimport (\n\t\"os\"\n\n\t\"go.pedge.io/dlog\"\n\t\"go.pedge.io/protolog\"\n)\n\nfunc init() {\n\tdlog.SetLogger(NewLogger(protolog.NewStandardLogger(protolog.NewFileFlusher(os.Stderr))))\n}\n\ntype logger struct {\n\tprotolog.Logger\n}\n\n\nfunc NewLogger(l protolog.Logger) dlog.Logger {\n\treturn &logger{l}\n}\n\nfunc (l *logger) Debug(args ...interface{}) {\n\tl.Debugln(args...)\n}\n\nfunc (l *logger) Info(args ...interface{}) {\n\tl.Infoln(args...)\n}\n\nfunc (l *logger) Warn(args ...interface{}) {\n\tl.Warnln(args...)\n}\n\nfunc (l *logger) Error(args ...interface{}) {\n\tl.Errorln(args...)\n}\n\nfunc (l *logger) Fatal(args ...interface{}) {\n\tl.Fatalln(args...)\n}\n\n\n\nfunc (l *logger) Print(args ...interface{}) {\n\tl.Println(args...)\n}\n\nfunc (l *logger) Panic(args ...interface{}) ", "output": "{\n\tl.Panicln(args...)\n}"}
{"input": "package state\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/juju/errors\"\n\t\"gopkg.in/juju/names.v2\"\n\n\t\"github.com/juju/juju/state/storage\"\n)\n\n\n\ntype rawState struct {\n\tbase    *State\n\tpersist Persistence\n}\n\n\n\nfunc NewResourceState(persist Persistence, base *State) Resources {\n\treturn &resourceState{\n\t\tpersist: NewResourcePersistence(persist),\n\t\traw: rawState{\n\t\t\tbase:    base,\n\t\t\tpersist: persist,\n\t\t},\n\t\tstorage: persist.NewStorage(),\n\t\tclock:   base.clock,\n\t}\n}\n\n\nfunc (st rawState) Persistence() Persistence {\n\treturn st.persist\n}\n\n\nfunc (st rawState) Storage() storage.Storage {\n\treturn st.persist.NewStorage()\n}\n\n\n\n\n\nfunc (st rawState) VerifyService(id string) error {\n\tapp, err := st.base.Application(id)\n\tif err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\tif app.Life() != Alive {\n\t\treturn errors.NewNotFound(nil, fmt.Sprintf(\"application %q dying or dead\", id))\n\t}\n\treturn nil\n}\n\nfunc (st rawState) Units(applicationID string) (tags []names.UnitTag, err error) ", "output": "{\n\tapp, err := st.base.Application(applicationID)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tunits, err := app.AllUnits()\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tfor _, u := range units {\n\t\ttags = append(tags, u.UnitTag())\n\t}\n\treturn tags, nil\n}"}
{"input": "package cache\n\nimport (\n\t\"fmt\"\n\n\t\"code.gitea.io/gitea/modules/git\"\n\t\"code.gitea.io/gitea/modules/log\"\n\n\tmc \"gitea.com/macaron/cache\"\n\t\"github.com/go-git/go-git/v5/plumbing/object\"\n)\n\n\ntype LastCommitCache struct {\n\trepoPath    string\n\tttl         int64\n\trepo        *git.Repository\n\tcommitCache map[string]*object.Commit\n\tmc.Cache\n}\n\n\nfunc NewLastCommitCache(repoPath string, gitRepo *git.Repository, ttl int64) *LastCommitCache {\n\treturn &LastCommitCache{\n\t\trepoPath:    repoPath,\n\t\trepo:        gitRepo,\n\t\tcommitCache: make(map[string]*object.Commit),\n\t\tttl:         ttl,\n\t\tCache:       conn,\n\t}\n}\n\n\n\n\n\nfunc (c LastCommitCache) Put(ref, entryPath, commitID string) error {\n\tlog.Trace(\"LastCommitCache save: [%s:%s:%s]\", ref, entryPath, commitID)\n\treturn c.Cache.Put(fmt.Sprintf(\"last_commit:%s:%s:%s\", c.repoPath, ref, entryPath), commitID, c.ttl)\n}\n\nfunc (c LastCommitCache) Get(ref, entryPath string) (*object.Commit, error) ", "output": "{\n\tv := c.Cache.Get(fmt.Sprintf(\"last_commit:%s:%s:%s\", c.repoPath, ref, entryPath))\n\tif vs, ok := v.(string); ok {\n\t\tlog.Trace(\"LastCommitCache hit level 1: [%s:%s:%s]\", ref, entryPath, vs)\n\t\tif commit, ok := c.commitCache[vs]; ok {\n\t\t\tlog.Trace(\"LastCommitCache hit level 2: [%s:%s:%s]\", ref, entryPath, vs)\n\t\t\treturn commit, nil\n\t\t}\n\t\tid, err := c.repo.ConvertToSHA1(vs)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcommit, err := c.repo.GoGitRepo().CommitObject(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tc.commitCache[vs] = commit\n\t\treturn commit, nil\n\t}\n\treturn nil, nil\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"runtime\"\n\t\"runtime/pprof\"\n)\n\nconst (\n\tusage = `Usage: %s [OPTION...]\ncontrol program for coffee roasting\n\nOptions:\n`\n)\n\nvar (\n\tmemProfile string\n\tcpuProfile string\n)\n\nfunc init() {\n\tflag.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, usage, os.Args[0])\n\t\tflag.PrintDefaults()\n\t}\n\n\tflag.StringVar(&memProfile, \"memprofile\", \"\",\n\t\t\"write memory profile to this file\")\n\tflag.StringVar(&cpuProfile, \"cpuprofile\", \"\",\n\t\t\"write cpu profile to this file\")\n\n\tflag.Parse()\n}\n\n\n\nfunc startProfiling() {\n\tvar err error\n\tif memProfile != \"\" {\n\t\truntime.MemProfileRate = 1\n\t}\n\tif cpuProfile != \"\" {\n\t\tvar f *os.File\n\t\tif f, err = os.Create(cpuProfile); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tpprof.StartCPUProfile(f)\n\t}\n}\n\n\n\nfunc main() {\n\tstartProfiling()\n\tdefer stopProfiling()\n\n}\n\nfunc stopProfiling() ", "output": "{\n\tif memProfile != \"\" {\n\t\truntime.GC()\n\t\tf, err := os.Create(memProfile)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t\tpprof.WriteHeapProfile(f)\n\t\tf.Close()\n\t}\n\tif cpuProfile != \"\" {\n\t\tpprof.StopCPUProfile()\n\t\tcpuProfile = \"\"\n\t}\n}"}
{"input": "package runewidth\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar escRegex *regexp.Regexp\n\nfunc init() {\n\tescRegex = regexp.MustCompile(\"\\u001b\\\\[(?:[0-9]{1,3}(?:;[0-9]{1,3})*)?[m|K]\")\n}\n\n\n\n\n\n\n\n\nfunc RuneWdith(r rune) int {\n\tif 0x0021 <= r && r <= 0x007e {\n\t\treturn 1\n\t}\n\n\tif 0x4e00 <= r && r <= 0x9fff {\n\t\treturn 2\n\t}\n\n\tif 0xac00 <= r && r <= 0xd7af {\n\t\treturn 2\n\t}\n\n\tif 0x3040 <= r && r <= 0x309f {\n\t\treturn 2\n\t}\n\tif 0x30a0 <= r && r <= 0x30ff {\n\t\treturn 2\n\t}\n\n\tif 0xff01 <= r && r <= 0xff60 {\n\t\treturn 2\n\t}\n\n\tif 0x3000 <= r && r <= 0x303e {\n\t\treturn 2\n\t}\n\n\tif 0x0008 == r || 0x007f == r {\n\t\treturn -1\n\t}\n\n\tif 0x0000 <= r && r <= 0x001f {\n\t\treturn 0\n\t}\n\n\treturn 1\n}\n\nfunc Width(s string) int ", "output": "{\n\tvar rv int\n\ts = escRegex.ReplaceAllString(s, \"\")\n\trstr := strings.NewReader(s)\n\tfor {\n\t\tr, _, err := rstr.ReadRune()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\trv += RuneWdith(r)\n\t}\n\n\treturn rv\n}"}
{"input": "package glog\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\tgolog \"github.com/golang/glog\"\n)\n\nconst logDepth = 4\n\n\n\ntype logBridge severity\n\n\n\n\n\nfunc (lb logBridge) Write(b []byte) (n int, err error) ", "output": "{\n\tvar text string\n\tif parts := bytes.SplitN(b, []byte{':'}, 3); len(parts) != 3 || len(parts[0]) < 1 || len(parts[2]) < 1 {\n\t\ttext = fmt.Sprintf(\"bad log format: %s\", b)\n\t} else {\n\t\ttext = string(parts[2][1:]) \n\t}\n\n\tswitch severity(lb) {\n\tcase infoLog:\n\t\tgolog.InfoDepth(logDepth, text)\n\tcase warningLog:\n\t\tgolog.WarningDepth(logDepth, text)\n\tcase errorLog:\n\t\tgolog.ErrorDepth(logDepth, text)\n\tcase fatalLog:\n\t\tgolog.FatalDepth(logDepth, text)\n\t}\n\tnotifyAirbrake(logDepth+1, severity(lb), text)\n\n\treturn len(b), nil\n}"}
{"input": "package translators_test\n\nimport (\n\t\"github.com/gobuffalo/pop/fizz\"\n\t\"github.com/gobuffalo/pop/fizz/translators\"\n)\n\nfunc (s *SchemaSuite) buildSchema() translators.Schema {\n\tschema := map[string]*fizz.Table{}\n\tta := &fizz.Table{Name: \"testTable\"}\n\tta.Column(\"testColumn\", \"type\", nil)\n\tta.Indexes = append(ta.Indexes, fizz.Index{Name: \"testIndex\"})\n\tschema[\"testTable\"] = ta\n\treturn translators.CreateSchema(\"name\", \"url\", schema)\n}\n\nfunc (s *SchemaSuite) Test_Schema_TableInfo() {\n\tr := s.Require()\n\tts := s.buildSchema()\n\tt, err := ts.TableInfo(\"testTable\")\n\tr.NoError(err)\n\tr.Equal(\"testTable\", t.Name)\n}\n\nfunc (s *SchemaSuite) Test_Schema_ColumnInfo() {\n\tr := s.Require()\n\tts := s.buildSchema()\n\tc, err := ts.ColumnInfo(\"testTable\", \"testCOLUMN\")\n\tr.NoError(err)\n\tr.Equal(\"testColumn\", c.Name)\n}\n\n\n\nfunc (s *SchemaSuite) Test_Schema_IndexInfo() ", "output": "{\n\tr := s.Require()\n\tts := s.buildSchema()\n\tc, err := ts.IndexInfo(\"testTable\", \"testindEX\")\n\tr.NoError(err)\n\tr.Equal(\"testIndex\", c.Name)\n}"}
{"input": "package tun\n\nimport (\n\t\"encoding/binary\"\n\n\t\"gvisor.dev/gvisor/pkg/tcpip\"\n)\n\nconst (\n\tPacketInfoHeaderSize = 4\n\n\toffsetFlags    = 0\n\toffsetProtocol = 2\n)\n\n\n\ntype PacketInfoFields struct {\n\tFlags    uint16\n\tProtocol tcpip.NetworkProtocolNumber\n}\n\n\n\ntype PacketInfoHeader []byte\n\n\n\n\n\nfunc (h PacketInfoHeader) Flags() uint16 {\n\treturn binary.BigEndian.Uint16(h[offsetFlags:])\n}\n\n\nfunc (h PacketInfoHeader) Protocol() tcpip.NetworkProtocolNumber {\n\treturn tcpip.NetworkProtocolNumber(binary.BigEndian.Uint16(h[offsetProtocol:]))\n}\n\nfunc (h PacketInfoHeader) Encode(f *PacketInfoFields) ", "output": "{\n\tbinary.BigEndian.PutUint16(h[offsetFlags:][:2], f.Flags)\n\tbinary.BigEndian.PutUint16(h[offsetProtocol:][:2], uint16(f.Protocol))\n}"}
{"input": "package wire\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n\n\n\n\n\n\ntype MsgMemPool struct{}\n\n\n\nfunc (msg *MsgMemPool) BtcDecode(r io.Reader, pver uint32) error {\n\tif pver < BIP0035Version {\n\t\tstr := fmt.Sprintf(\"mempool message invalid for protocol \"+\n\t\t\t\"version %d\", pver)\n\t\treturn messageError(\"MsgMemPool.BtcDecode\", str)\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (msg *MsgMemPool) BtcEncode(w io.Writer, pver uint32) error {\n\tif pver < BIP0035Version {\n\t\tstr := fmt.Sprintf(\"mempool message invalid for protocol \"+\n\t\t\t\"version %d\", pver)\n\t\treturn messageError(\"MsgMemPool.BtcEncode\", str)\n\t}\n\n\treturn nil\n}\n\n\n\n\n\n\n\nfunc (msg *MsgMemPool) MaxPayloadLength(pver uint32) uint32 {\n\treturn 0\n}\n\n\n\nfunc NewMsgMemPool() *MsgMemPool {\n\treturn &MsgMemPool{}\n}\n\nfunc (msg *MsgMemPool) Command() string ", "output": "{\n\treturn CmdMemPool\n}"}
{"input": "package prometheus\n\nimport (\n\t\"github.com/hyperhq/client-go/util/workqueue\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n)\n\n\n\n\nfunc init() {\n\tworkqueue.SetProvider(prometheusMetricsProvider{})\n}\n\ntype prometheusMetricsProvider struct{}\n\nfunc (_ prometheusMetricsProvider) NewDepthMetric(name string) workqueue.GaugeMetric {\n\tdepth := prometheus.NewGauge(prometheus.GaugeOpts{\n\t\tSubsystem: name,\n\t\tName:      \"depth\",\n\t\tHelp:      \"Current depth of workqueue: \" + name,\n\t})\n\tprometheus.Register(depth)\n\treturn depth\n}\n\nfunc (_ prometheusMetricsProvider) NewAddsMetric(name string) workqueue.CounterMetric {\n\tadds := prometheus.NewCounter(prometheus.CounterOpts{\n\t\tSubsystem: name,\n\t\tName:      \"adds\",\n\t\tHelp:      \"Total number of adds handled by workqueue: \" + name,\n\t})\n\tprometheus.Register(adds)\n\treturn adds\n}\n\nfunc (_ prometheusMetricsProvider) NewLatencyMetric(name string) workqueue.SummaryMetric {\n\tlatency := prometheus.NewSummary(prometheus.SummaryOpts{\n\t\tSubsystem: name,\n\t\tName:      \"queue_latency\",\n\t\tHelp:      \"How long an item stays in workqueue\" + name + \" before being requested.\",\n\t})\n\tprometheus.Register(latency)\n\treturn latency\n}\n\nfunc (_ prometheusMetricsProvider) NewWorkDurationMetric(name string) workqueue.SummaryMetric {\n\tworkDuration := prometheus.NewSummary(prometheus.SummaryOpts{\n\t\tSubsystem: name,\n\t\tName:      \"work_duration\",\n\t\tHelp:      \"How long processing an item from workqueue\" + name + \" takes.\",\n\t})\n\tprometheus.Register(workDuration)\n\treturn workDuration\n}\n\n\n\nfunc (_ prometheusMetricsProvider) NewRetriesMetric(name string) workqueue.CounterMetric ", "output": "{\n\tretries := prometheus.NewCounter(prometheus.CounterOpts{\n\t\tSubsystem: name,\n\t\tName:      \"retries\",\n\t\tHelp:      \"Total number of retries handled by workqueue: \" + name,\n\t})\n\tprometheus.Register(retries)\n\treturn retries\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/unrolled/render\"\n)\n\n\nvar Render *render.Render\n\n\nfunc init() {\n\tRender = render.New(render.Options{\n\t\tIndentJSON: true,\n\t})\n}\n\nfunc index(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Welcome to the home page!\")\n}\n\nfunc apiHandler(w http.ResponseWriter, r *http.Request) {\n\tRender.JSON(w, http.StatusOK, \"Welcome to the api hander page!\")\n}\n\n\n\nfunc apiKeyDetailsHandler(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\tfmt.Fprintf(w, \"Welcome to the api Key Details hander page! %s\", id)\n}\n\nfunc webKeyHandler(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\tfmt.Fprintf(w, \"Welcome to the web Key hander page! %s\", id)\n}\n\nfunc notFound(w http.ResponseWriter, r *http.Request) {\n\thttp.Redirect(w, r, \"/\", http.StatusTemporaryRedirect)\n}\n\nfunc apiKeyHandler(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tid := mux.Vars(r)[\"id\"]\n\tfmt.Fprintf(w, \"Welcome to the api Key hander page! %s\", id)\n}"}
{"input": "package tracking\n\nimport (\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/go-kit/kit/endpoint\"\n)\n\ntype trackCargoRequest struct {\n\tID string\n}\n\ntype trackCargoResponse struct {\n\tCargo *Cargo `json:\"cargo,omitempty\"`\n\tErr   error  `json:\"error,omitempty\"`\n}\n\n\n\nfunc makeTrackCargoEndpoint(ts Service) endpoint.Endpoint {\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treq := request.(trackCargoRequest)\n\t\tc, err := ts.Track(req.ID)\n\t\treturn trackCargoResponse{Cargo: &c, Err: err}, nil\n\t}\n}\n\nfunc (r trackCargoResponse) error() error ", "output": "{ return r.Err }"}
{"input": "package problem0646\n\nimport \"sort\"\n\ntype Seg struct {\n\tl int\n\tr int\n}\n\ntype segList []Seg\n\nfunc (s segList) Less(i, j int) bool { return s[i].r < s[j].r }\nfunc (s segList) Len() int           { return len(s) }\nfunc (s segList) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\n\n\nfunc findLongestChain(pairs [][]int) int ", "output": "{\n\tvar p segList\n\tn := len(pairs)\n\tfor i := 0; i < n; i++ {\n\t\tp = append(p, Seg{pairs[i][0], pairs[i][1]})\n\t}\n\tsort.Sort(p)\n\tr := p[0].r\n\tans := 1\n\tfor i := 1; i < n; i++ {\n\t\tif p[i].l > r {\n\t\t\tr = p[i].r\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}"}
{"input": "package daemon\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/swarm\"\n\t\"gotest.tools/assert\"\n)\n\n\ntype ConfigConstructor func(*swarm.Config)\n\n\nfunc (d *Daemon) CreateConfig(t testing.TB, configSpec swarm.ConfigSpec) string {\n\tt.Helper()\n\tcli := d.NewClientT(t)\n\tdefer cli.Close()\n\n\tscr, err := cli.ConfigCreate(context.Background(), configSpec)\n\tassert.NilError(t, err)\n\treturn scr.ID\n}\n\n\n\n\n\nfunc (d *Daemon) GetConfig(t testing.TB, id string) *swarm.Config {\n\tt.Helper()\n\tcli := d.NewClientT(t)\n\tdefer cli.Close()\n\n\tconfig, _, err := cli.ConfigInspectWithRaw(context.Background(), id)\n\tassert.NilError(t, err)\n\treturn &config\n}\n\n\nfunc (d *Daemon) DeleteConfig(t testing.TB, id string) {\n\tt.Helper()\n\tcli := d.NewClientT(t)\n\tdefer cli.Close()\n\n\terr := cli.ConfigRemove(context.Background(), id)\n\tassert.NilError(t, err)\n}\n\n\n\nfunc (d *Daemon) UpdateConfig(t testing.TB, id string, f ...ConfigConstructor) {\n\tt.Helper()\n\tcli := d.NewClientT(t)\n\tdefer cli.Close()\n\n\tconfig := d.GetConfig(t, id)\n\tfor _, fn := range f {\n\t\tfn(config)\n\t}\n\n\terr := cli.ConfigUpdate(context.Background(), config.ID, config.Version, config.Spec)\n\tassert.NilError(t, err)\n}\n\nfunc (d *Daemon) ListConfigs(t testing.TB) []swarm.Config ", "output": "{\n\tt.Helper()\n\tcli := d.NewClientT(t)\n\tdefer cli.Close()\n\n\tconfigs, err := cli.ConfigList(context.Background(), types.ConfigListOptions{})\n\tassert.NilError(t, err)\n\treturn configs\n}"}
{"input": "package iso20022\n\n\ntype FinancialInstrumentDetails24 struct {\n\n\tFinancialInstrumentIdentification *SecurityIdentification19 `xml:\"FinInstrmId\"`\n\n\tFinancialInstrumentAttributes *FinancialInstrumentAttributes63 `xml:\"FinInstrmAttrbts,omitempty\"`\n\n\tSubBalance []*IntraPositionDetails40 `xml:\"SubBal\"`\n}\n\nfunc (f *FinancialInstrumentDetails24) AddFinancialInstrumentIdentification() *SecurityIdentification19 {\n\tf.FinancialInstrumentIdentification = new(SecurityIdentification19)\n\treturn f.FinancialInstrumentIdentification\n}\n\n\n\nfunc (f *FinancialInstrumentDetails24) AddSubBalance() *IntraPositionDetails40 {\n\tnewValue := new(IntraPositionDetails40)\n\tf.SubBalance = append(f.SubBalance, newValue)\n\treturn newValue\n}\n\nfunc (f *FinancialInstrumentDetails24) AddFinancialInstrumentAttributes() *FinancialInstrumentAttributes63 ", "output": "{\n\tf.FinancialInstrumentAttributes = new(FinancialInstrumentAttributes63)\n\treturn f.FinancialInstrumentAttributes\n}"}
{"input": "package dilma\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/go-chat-bot/bot\"\n)\n\n\n\nfunc TestDilmaWhenTtheTextMatchDilma(t *testing.T) {\n\tcmd := &bot.PassiveCmd{}\n\tcmd.Raw = \"eu não votei na dilma!\"\n\tgot, err := dilma(cmd)\n\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil => %s\", err)\n\t}\n\tif !strings.HasPrefix(got, \":dilma: \") {\n\t\tt.Errorf(\"Test failed. Should return a clever Dilma quote\")\n\t}\n}\n\nfunc TestDilmaWhenTheTextDoesNotMatchDilma(t *testing.T) ", "output": "{\n\tcmd := &bot.PassiveCmd{}\n\tcmd.Raw = \"My name is go-bot, I am awesome.\"\n\tgot, err := dilma(cmd)\n\n\tif err != nil {\n\t\tt.Errorf(\"Error should be nil => %s\", err)\n\t}\n\tif got != \"\" {\n\t\tt.Errorf(\"Test failed. Expected a empty return, got:  '%s'\", got)\n\t}\n}"}
{"input": "package validate\n\nimport (\n\t\"log\"\n\t\"reflect\"\n\n\t\"github.com/go-openapi/spec\"\n\t\"github.com/go-openapi/strfmt\"\n)\n\ntype formatValidator struct {\n\tFormat       string\n\tPath         string\n\tIn           string\n\tKnownFormats strfmt.Registry\n}\n\nfunc (f *formatValidator) SetPath(path string) {\n\tf.Path = path\n}\n\nfunc (f *formatValidator) Applies(source interface{}, kind reflect.Kind) bool {\n\tdoit := func() bool {\n\t\tif source == nil {\n\t\t\treturn false\n\t\t}\n\t\tswitch source.(type) {\n\t\tcase *spec.Items:\n\t\t\tit := source.(*spec.Items)\n\t\t\treturn kind == reflect.String && f.KnownFormats.ContainsName(it.Format)\n\t\tcase *spec.Parameter:\n\t\t\tpar := source.(*spec.Parameter)\n\t\t\treturn kind == reflect.String && f.KnownFormats.ContainsName(par.Format)\n\t\tcase *spec.Schema:\n\t\t\tsch := source.(*spec.Schema)\n\t\t\treturn kind == reflect.String && f.KnownFormats.ContainsName(sch.Format)\n\t\t}\n\t\treturn false\n\t}\n\tr := doit()\n\tif Debug {\n\t\tlog.Printf(\"format validator for %q applies %t for %T (kind: %v)\\n\", f.Path, r, source, kind)\n\t}\n\treturn r\n}\n\n\n\nfunc (f *formatValidator) Validate(val interface{}) *Result ", "output": "{\n\tresult := new(Result)\n\n\tif err := FormatOf(f.Path, f.In, f.Format, val.(string), f.KnownFormats); err != nil {\n\t\tresult.AddErrors(err)\n\t}\n\n\tif result.HasErrors() {\n\t\treturn result\n\t}\n\treturn nil\n}"}
{"input": "package api\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAPI_StatusLeader(t *testing.T) {\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tleader, err := status.Leader()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif leader == \"\" {\n\t\tt.Fatalf(\"Expected leader\")\n\t}\n}\n\n\n\nfunc TestAPI_StatusPeers(t *testing.T) ", "output": "{\n\tt.Parallel()\n\tc, s := makeClient(t)\n\tdefer s.Stop()\n\n\tstatus := c.Status()\n\n\tpeers, err := status.Peers()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif len(peers) == 0 {\n\t\tt.Fatalf(\"Expected peers \")\n\t}\n}"}
{"input": "package testing\n\nimport (\n\t\"fmt\"\n\n\truntimeapi \"k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1\"\n)\n\nfunc BuildContainerName(metadata *runtimeapi.ContainerMetadata, sandboxID string) string {\n\treturn fmt.Sprintf(\"%s_%s_%d\", sandboxID, metadata.Name, metadata.Attempt)\n}\n\n\n\nfunc filterInLabels(filter, labels map[string]string) bool {\n\tfor k, v := range filter {\n\t\tif value, ok := labels[k]; ok {\n\t\t\tif value != v {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc BuildSandboxName(metadata *runtimeapi.PodSandboxMetadata) string ", "output": "{\n\treturn fmt.Sprintf(\"%s_%s_%s_%d\", metadata.Name, metadata.Namespace, metadata.Uid, metadata.Attempt)\n}"}
{"input": "package robustio\n\n\n\n\n\n\n\n\n\n\n\nfunc ReadFile(filename string) ([]byte, error) {\n\treturn readFile(filename)\n}\n\n\n\n\n\nfunc RemoveAll(path string) error {\n\treturn removeAll(path)\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc IsEphemeralError(err error) bool {\n\treturn isEphemeralError(err)\n}\n\nfunc Rename(oldpath, newpath string) error ", "output": "{\n\treturn rename(oldpath, newpath)\n}"}
{"input": "package tenant_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/influxdata/influxdb/v2\"\n\t\"github.com/influxdata/influxdb/v2/tenant\"\n\tinfluxdbtesting \"github.com/influxdata/influxdb/v2/testing\"\n\t\"go.uber.org/zap/zaptest\"\n)\n\nfunc TestUserLoggingService(t *testing.T) {\n\tinfluxdbtesting.UserService(initBoltUserLoggingService, t)\n}\n\n\n\nfunc initBoltUserLoggingService(f influxdbtesting.UserFields, t *testing.T) (influxdb.UserService, string, func()) ", "output": "{\n\tsvc, s, closer := initBoltUserService(f, t)\n\treturn tenant.NewUserLogger(zaptest.NewLogger(t), svc), s, closer\n}"}
{"input": "package env\n\nimport (\n\t\"net/http\"\n)\n\nvar envInstance = env{\n\thandlers: []Handler{},\n}\n\ntype env struct {\n\thandlers []Handler\n}\n\nfunc RegisterHandler(handler Handler) {\n\tenvInstance.handlers = append(envInstance.handlers, handler)\n}\n\n\n\ntype Handler struct {\n\tURLPrefix string\n\tHandler   http.Handler\n}\n\nfunc GetHandlers() []Handler ", "output": "{\n\treturn envInstance.handlers\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/flynn/go-docopt\"\n)\n\n\n\nfunc runInstaller(args *docopt.Args) error {\n\tfmt.Printf(\"DEPRECATED: `flynn install` has been deprecated.\\nRefer to https://flynn.io/docs/installation for current installation instructions.\\nAn unsupported and unmaintained snapshot of the installer binaries at the time of deprecation is available at https://dl.flynn.io/flynn-install-deprecated.tar.gz\\n\")\n\treturn nil\n}\n\nfunc init() ", "output": "{\n\tregister(\"install\", runInstaller, `usage: flynn install`)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\n\t\"mvdan.cc/fdroidcl/fdroid\"\n)\n\nvar cmdDownload = &Command{\n\tUsageLine: \"download <appid...>\",\n\tShort:     \"Download an app\",\n}\n\nfunc init() {\n\tcmdDownload.Run = runDownload\n}\n\nfunc runDownload(args []string) error {\n\tif len(args) < 1 {\n\t\treturn fmt.Errorf(\"no package names given\")\n\t}\n\tapps, err := findApps(args)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdevice, _ := maybeOneDevice()\n\tfor _, app := range apps {\n\t\tapk := app.SuggestedApk(device)\n\t\tif apk == nil {\n\t\t\treturn fmt.Errorf(\"no suggested APK found for %s\", app.PackageName)\n\t\t}\n\t\tpath, err := downloadApk(apk)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Printf(\"APK available in %s\\n\", path)\n\t}\n\treturn nil\n}\n\nfunc downloadApk(apk *fdroid.Apk) (string, error) {\n\turl := apk.URL()\n\tpath := apkPath(apk.ApkName)\n\tif err := downloadEtag(url, path, apk.Hash); err == errNotModified {\n\t} else if err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not download %s: %v\", apk.AppID, err)\n\t}\n\treturn path, nil\n}\n\n\n\nfunc apkPath(apkname string) string ", "output": "{\n\tapksDir := subdir(mustCache(), \"apks\")\n\treturn filepath.Join(apksDir, apkname)\n}"}
{"input": "package rpcmux\n\nimport (\n\t\"time\"\n\n\t\"github.com/jj-io/jj/rpc\"\n)\n\nvar (\n\tRouterDebugPing  = \"debug.ping\"\n\tRouterDebugSleep = \"debug.sleep\"\n\tRouterHelp       = \"help\"\n)\n\nfunc InitDebugHandler(handler rpc.Handler) {\n\thandler.HandleFunc(RouterDebugPing, PingHandler)\n\thandler.HandleFunc(RouterDebugSleep, SleepHandler)\n\thandler.HandleFunc(RouterHelp, HelpHandler)\n}\n\n\n\nfunc PingHandler(w rpc.ResponseWriter, data *rpc.Request) {\n\tw.Response(\"pong\")\n}\n\nfunc SleepHandler(w rpc.ResponseWriter, data *rpc.Request) {\n\tvar params string\n\tif err := data.Params(&params); err != nil {\n\t\tw.Error(err)\n\t\treturn\n\t}\n\n\tduration, err := time.ParseDuration(params)\n\tif err != nil {\n\t\tw.Errorf(\"%v: %v\", err, params)\n\t\treturn\n\t}\n\n\ttime.Sleep(duration)\n\tw.Responsef(\"sleep %v\", duration)\n}\n\nfunc HelpHandler(w rpc.ResponseWriter, req *rpc.Request) ", "output": "{\n\tlist := w.(*responseWriter).routerList()\n\tw.Response(list)\n}"}
{"input": "package log\n\nimport \"fmt\"\n\nconst _Field_name = \"NodeIDStoreIDRangeIDKeymaxField\"\n\nvar _Field_index = [...]uint8{0, 6, 13, 20, 23, 31}\n\n\n\nfunc (i Field) String() string ", "output": "{\n\tif i < 0 || i >= Field(len(_Field_index)-1) {\n\t\treturn fmt.Sprintf(\"Field(%d)\", i)\n\t}\n\treturn _Field_name[_Field_index[i]:_Field_index[i+1]]\n}"}
{"input": "package modelview\n\nimport \"github.com/gopns/gopns/model\"\n\ntype PaginatedListView struct {\n\tcursor string `json:\",omitempty\"`\n\titems  []interface{}\n}\n\nfunc NewPaginatedDeviceListView(devices []model.Device, cursor string) *PaginatedListView {\n\titems := make([]interface{}, len(devices))\n\tfor i := range devices {\n\t\titems[i] = devices[i]\n\t}\n\treturn &PaginatedListView{items: items, cursor: cursor}\n}\n\nfunc (lv PaginatedListView) Cursor() string {\n\treturn lv.cursor\n}\n\n\n\nfunc (lv *PaginatedListView) SetCursor(cursor string) {\n\tlv.cursor = cursor\n}\n\nfunc (lv *PaginatedListView) SetItems(items []interface{}) {\n\tlv.items = items\n}\n\nfunc (lv PaginatedListView) Items() []interface{} ", "output": "{\n\treturn lv.items\n}"}
{"input": "package pusher\n\nimport (\n\t\"sync\"\n)\n\n\ntype ChannelManager struct {\n\tchannels    map[string]*Channel\n\tchannelsMtx *sync.Mutex\n}\n\n\nfunc NewChannelManager() *ChannelManager {\n\treturn &ChannelManager{\n\t\tchannels:    make(map[string]*Channel),\n\t\tchannelsMtx: &sync.Mutex{},\n\t}\n}\n\n\nfunc (c *ChannelManager) Add(channel *Channel) {\n\tc.channelsMtx.Lock()\n\tdefer c.channelsMtx.Unlock()\n\n\tc.channels[channel.ID] = channel\n}\n\n\nfunc (c *ChannelManager) Get(ID string) (*Channel, bool) {\n\tc.channelsMtx.Lock()\n\tdefer c.channelsMtx.Unlock()\n\n\tchannel, ok := c.channels[ID]\n\n\treturn channel, ok\n}\n\n\n\n\nfunc (c *ChannelManager) Remove(channel *Channel) ", "output": "{\n\tc.channelsMtx.Lock()\n\tdefer c.channelsMtx.Unlock()\n\n\tdelete(c.channels, channel.ID)\n}"}
{"input": "package pg\n\ntype Factory interface {\n\tNew() interface{}\n}\n\ntype singleFactory struct {\n\tv interface{}\n}\n\nfunc (f *singleFactory) New() interface{} {\n\treturn f.v\n}\n\ntype Appender interface {\n\tAppend([]byte) []byte\n}\n\ntype RawAppender interface {\n\tAppendRaw([]byte) []byte\n}\n\n\ntype Q string\n\nfunc (q Q) Append(dst []byte) []byte {\n\treturn append(dst, string(q)...)\n}\n\n\n\n\ntype F string\n\nfunc (f F) Append(dst []byte) []byte {\n\tdst = append(dst, '\"')\n\tfor _, c := range []byte(f) {\n\t\tif c == '\"' {\n\t\t\tdst = append(dst, '\"', '\"')\n\t\t} else {\n\t\t\tdst = append(dst, c)\n\t\t}\n\t}\n\tdst = append(dst, '\"')\n\treturn dst\n}\n\ntype RecordReader interface {\n\tRead() ([]string, error)\n}\n\nfunc (q Q) AppendRaw(dst []byte) []byte ", "output": "{\n\treturn q.Append(dst)\n}"}
{"input": "package column\n\nimport (\n\t\"github.com/ClickHouse/clickhouse-go/lib/binary\"\n)\n\ntype Int32 struct{ base }\n\n\n\nfunc (i *Int32) Write(encoder *binary.Encoder, v interface{}) error {\n\tswitch v := v.(type) {\n\tcase int32:\n\t\treturn encoder.Int32(v)\n\tcase int64:\n\t\treturn encoder.Int32(int32(v))\n\tcase int:\n\t\treturn encoder.Int32(int32(v))\n\n\tcase *int32:\n\t\treturn encoder.Int32(*v)\n\tcase *int64:\n\t\treturn encoder.Int32(int32(*v))\n\tcase *int:\n\t\treturn encoder.Int32(int32(*v))\n\t}\n\n\treturn &ErrUnexpectedType{\n\t\tT:      v,\n\t\tColumn: i,\n\t}\n}\n\nfunc (Int32) Read(decoder *binary.Decoder, isNull bool) (interface{}, error) ", "output": "{\n\tv, err := decoder.Int32()\n\tif err != nil {\n\t\treturn int32(0), err\n\t}\n\treturn v, nil\n}"}
{"input": "package testing\n\n\n\n\nimport (\n\t\"k8s.io/kubernetes/pkg/api/v1\"\n\tclientset \"k8s.io/kubernetes/pkg/client/clientset_generated/clientset\"\n\tkubecontainer \"k8s.io/kubernetes/pkg/kubelet/container\"\n\tcontainertest \"k8s.io/kubernetes/pkg/kubelet/container/testing\"\n)\n\ntype fakeNetworkHost struct {\n\tfakeNamespaceGetter\n\tkubeClient clientset.Interface\n\tLegacy     bool\n\tRuntime    *containertest.FakeRuntime\n}\n\nfunc NewFakeHost(kubeClient clientset.Interface) *fakeNetworkHost {\n\thost := &fakeNetworkHost{kubeClient: kubeClient, Legacy: true, Runtime: &containertest.FakeRuntime{}}\n\treturn host\n}\n\n\n\nfunc (fnh *fakeNetworkHost) GetKubeClient() clientset.Interface {\n\treturn nil\n}\n\nfunc (nh *fakeNetworkHost) GetRuntime() kubecontainer.Runtime {\n\treturn nh.Runtime\n}\n\nfunc (nh *fakeNetworkHost) SupportsLegacyFeatures() bool {\n\treturn nh.Legacy\n}\n\ntype fakeNamespaceGetter struct {\n\tns string\n}\n\nfunc (nh *fakeNamespaceGetter) GetNetNS(containerID string) (string, error) {\n\treturn nh.ns, nil\n}\n\nfunc (fnh *fakeNetworkHost) GetPodByName(name, namespace string) (*v1.Pod, bool) ", "output": "{\n\treturn nil, false\n}"}
{"input": "package markdownutils\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n)\n\n\nfunc CreateGitHubAnchor(text string) string {\n\tvar anchorName []rune\n\n\tfor _, r := range []rune(strings.TrimSpace(text)) {\n\t\tswitch {\n\t\tcase r == ' ' || r == '-':\n\t\t\tanchorName = append(anchorName, '-')\n\t\tcase unicode.IsLetter(r) || unicode.IsNumber(r):\n\t\t\tanchorName = append(anchorName, unicode.ToLower(r))\n\t\tdefault:\n\t\t}\n\t}\n\n\treturn string(anchorName)\n}\n\n\n\n\nfunc CreateGitLabAnchor(text string) string ", "output": "{\n\tvar anchorName []rune\n\tvar lastWasDash = false\n\n\tfor _, r := range []rune(strings.TrimSpace(text)) {\n\t\tswitch {\n\t\tcase r == ' ' || r == '-':\n\t\t\tif !lastWasDash {\n\t\t\t\tanchorName = append(anchorName, '-')\n\t\t\t\tlastWasDash = true\n\t\t\t}\n\t\tcase unicode.IsLetter(r) || unicode.IsNumber(r):\n\t\t\tanchorName = append(anchorName, unicode.ToLower(r))\n\t\t\tlastWasDash = false\n\t\tdefault:\n\t\t}\n\t}\n\n\treturn string(anchorName)\n}"}
{"input": "package router\n\n\n\n\nimport (\n\t\"github.com/weaveworks/mesh\"\n)\n\n\n\ntype AWSVPCConnection struct {\n\testablishedChan chan struct{}\n\terrorChan       chan error\n}\n\nfunc (conn *AWSVPCConnection) Confirm() {\n\tclose(conn.establishedChan)\n}\n\nfunc (conn *AWSVPCConnection) EstablishedChannel() <-chan struct{} {\n\treturn conn.establishedChan\n}\n\nfunc (conn *AWSVPCConnection) ErrorChannel() <-chan error {\n\treturn conn.errorChan\n}\n\nfunc (conn *AWSVPCConnection) Stop() {}\n\nfunc (conn *AWSVPCConnection) ControlMessage(tag byte, msg []byte) {\n}\n\nfunc (conn *AWSVPCConnection) DisplayName() string {\n\treturn \"awsvpc\"\n}\n\n\n\n\n\ntype AWSVPC struct{}\n\nfunc NewAWSVPC() AWSVPC {\n\treturn AWSVPC{}\n}\n\n\n\nfunc (vpc AWSVPC) AddFeaturesTo(features map[string]string) {}\n\nfunc (vpc AWSVPC) PrepareConnection(params mesh.OverlayConnectionParams) (mesh.OverlayConnection, error) {\n\tconn := &AWSVPCConnection{\n\t\testablishedChan: make(chan struct{}),\n\t\terrorChan:       make(chan error, 1),\n\t}\n\treturn conn, nil\n}\n\nfunc (vpc AWSVPC) Diagnostics() interface{} {\n\treturn nil\n}\n\n\n\nfunc (vpc AWSVPC) InvalidateRoutes() {}\n\nfunc (vpc AWSVPC) InvalidateShortIDs() {}\n\nfunc (vpc AWSVPC) StartConsumingPackets(localPeer *mesh.Peer, peers *mesh.Peers, consumer OverlayConsumer) error {\n\treturn nil\n}\n\nfunc (conn *AWSVPCConnection) Forward(key ForwardPacketKey) FlowOp ", "output": "{\n\treturn DiscardingFlowOp{}\n}"}
{"input": "package operators\n\nimport (\n\t\"gopkg.in/check.v1\"\n\t\"gopkg.in/mgo.v2/bson\"\n)\n\n\n\nfunc (s *OperatorsSuite) TestComment(c *check.C) ", "output": "{\n\tcomment := Comment(\"foo\")\n\tc.Assert(comment, check.DeepEquals, bson.M{\"$comment\": \"foo\"})\n}"}
{"input": "package api\n\nimport . \"go-ws/api/types\"\n\n\n\nfunc NewSDK(apiKey string) (sdk SDK) ", "output": "{\n\tvalidateApiKey(apiKey)\n\tconfig := getSDKConfig(apiKey)\n\tsdk = getSDK(config)\n\treturn sdk\n}"}
{"input": "package handlers\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/thecodeteam/rexray/libstorage/api/context\"\n\t\"github.com/thecodeteam/rexray/libstorage/api/server/auth\"\n\t\"github.com/thecodeteam/rexray/libstorage/api/types\"\n)\n\n\ntype authGlobalHandler struct {\n\thandler types.APIFunc\n\tconfig  *types.AuthConfig\n}\n\n\nfunc NewAuthGlobalHandler(\n\tconfig *types.AuthConfig) types.Middleware {\n\treturn &authGlobalHandler{config: config}\n}\n\nfunc (h *authGlobalHandler) Name() string {\n\treturn \"auth-global-handler\"\n}\n\nfunc (h *authGlobalHandler) Handler(m types.APIFunc) types.APIFunc {\n\treturn (&authGlobalHandler{m, h.config}).Handle\n}\n\n\n\n\nfunc (h *authGlobalHandler) Handle(\n\tctx types.Context,\n\tw http.ResponseWriter,\n\treq *http.Request,\n\tstore types.Store) error ", "output": "{\n\n\tif h.config == nil {\n\t\tctx.Debug(\"skipping global auth handler; empty auth config\")\n\t\treturn h.handler(ctx, w, req, store)\n\t}\n\n\tif len(h.config.Allow) == 0 && len(h.config.Deny) == 0 {\n\t\tctx.Debug(\"skipping global auth handler; empty allow & deny lists\")\n\t\treturn h.handler(ctx, w, req, store)\n\t}\n\n\ttok, err := auth.ValidateAuthTokenWithReq(ctx, h.config, req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif tok == nil {\n\t\tpanic(\"token should never be nil here\")\n\t}\n\n\tctx.Debug(\"validated global security token\")\n\n\treturn h.handler(\n\t\tctx.WithValue(context.AuthTokenKey, tok), w, req, store)\n}"}
{"input": "package event\n\nimport (\n\t\"io/ioutil\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/alvalor/alvalor-go/network\"\n\t\"github.com/alvalor/alvalor-go/node/handlers/message\"\n\t\"github.com/alvalor/alvalor-go/types\"\n\t\"github.com/rs/zerolog\"\n\t\"github.com/stretchr/testify/mock\"\n)\n\n\n\nfunc TestProcessReceivedSuccess(t *testing.T) ", "output": "{\n\n\thash := types.Hash{0x1}\n\taddress := \"192.0.2.1\"\n\n\twg := &sync.WaitGroup{}\n\tmsg := &message.GetTx{Hash: hash}\n\tevent := network.Received{Address: address, Message: msg}\n\n\tnet := &NetworkMock{}\n\theaders := &HeadersMock{}\n\tpeers := &PeersMock{}\n\tmessage := &MessageMock{}\n\n\thandler := &Handler{\n\t\tlog:     zerolog.New(ioutil.Discard),\n\t\tnet:     net,\n\t\theaders: headers,\n\t\tpeers:   peers,\n\t\tmessage: message,\n\t}\n\n\tmessage.On(\"Process\", mock.Anything, mock.Anything, mock.Anything)\n\n\thandler.Process(wg, event)\n\twg.Wait()\n\n\tif message.AssertNumberOfCalls(t, \"Process\", 1) {\n\t\tmessage.AssertCalled(t, \"Process\", wg, address, msg)\n\t}\n}"}
{"input": "package commands\n\nimport (\n\t\"fmt\"\n\t\"github.com/brooklyncentral/brooklyn-cli/api/entity_policies\"\n\t\"github.com/brooklyncentral/brooklyn-cli/command_metadata\"\n\t\"github.com/brooklyncentral/brooklyn-cli/error_handler\"\n\t\"github.com/brooklyncentral/brooklyn-cli/net\"\n\t\"github.com/brooklyncentral/brooklyn-cli/scope\"\n\t\"github.com/codegangsta/cli\"\n)\n\ntype StopPolicy struct {\n\tnetwork *net.Network\n}\n\nfunc NewStopPolicy(network *net.Network) (cmd *StopPolicy) {\n\tcmd = new(StopPolicy)\n\tcmd.network = network\n\treturn\n}\n\nfunc (cmd *StopPolicy) Metadata() command_metadata.CommandMetadata {\n\treturn command_metadata.CommandMetadata{\n\t\tName:        \"stop-policy\",\n\t\tDescription: \"Suspends a policy\",\n\t\tUsage:       \"BROOKLYN_NAME SCOPE stop-policy POLICY\",\n\t\tFlags:       []cli.Flag{},\n\t}\n}\n\n\n\nfunc (cmd *StopPolicy) Run(scope scope.Scope, c *cli.Context) ", "output": "{\n\tif err := net.VerifyLoginURL(cmd.network); err != nil {\n\t\terror_handler.ErrorExit(err)\n\t}\n\tspec, err := entity_policies.StopPolicy(cmd.network, scope.Application, scope.Entity, c.Args().First())\n\tif nil != err {\n\t\terror_handler.ErrorExit(err)\n\t}\n\tfmt.Println(spec)\n}"}
{"input": "package wordpress\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Status struct {\n\tName       string `json:\"name,omitempty\"`\n\tPrivate    bool   `json:\"private,omitempty\"`\n\tPublic     bool   `json:\"public,omitempty\"`\n\tQueryable  bool   `json:\"queryable,omitempty\"`\n\tShowInList bool   `json:\"show_in_list,omitempty\"`\n\tSlug       string `json:\"slug,omitempty\"`\n}\n\ntype Statuses struct {\n\tPublish Status `json:\"publish,omitempty\"`\n\tFuture  Status `json:\"future,omitempty\"`\n\tDraft   Status `json:\"draft,omitempty\"`\n\tPending Status `json:\"pending,omitempty\"`\n\tPrivate Status `json:\"private,omitempty\"`\n}\ntype StatusesCollection struct {\n\tclient *Client\n\turl    string\n}\n\nfunc (col *StatusesCollection) List(params interface{}) (*Statuses, *http.Response, []byte, error) {\n\tvar statuses Statuses\n\tresp, body, err := col.client.List(col.url, params, &statuses)\n\treturn &statuses, resp, body, err\n}\n\n\n\nfunc (col *StatusesCollection) Get(slug string, params interface{}) (*Status, *http.Response, []byte, error) ", "output": "{\n\tvar entity Status\n\tentityURL := fmt.Sprintf(\"%v/%v\", col.url, slug)\n\tresp, body, err := col.client.Get(entityURL, params, &entity)\n\treturn &entity, resp, body, err\n}"}
{"input": "package runtime\n\nimport \"unsafe\"\n\n\n\n\n\n\nfunc atomicload(ptr *uint32) uint32 {\n\tnop()\n\treturn *ptr\n}\n\n\nfunc atomicloadp(ptr unsafe.Pointer) unsafe.Pointer {\n\tnop()\n\treturn *(*unsafe.Pointer)(ptr)\n}\n\n\nfunc xadd64(ptr *uint64, delta int64) uint64 {\n\tfor {\n\t\told := *ptr\n\t\tif cas64(ptr, old, old+uint64(delta)) {\n\t\t\treturn old + uint64(delta)\n\t\t}\n\t}\n}\n\n\n\n\n\nfunc xadd(ptr *uint32, delta int32) uint32\n\n\nfunc xchg(ptr *uint32, new uint32) uint32\n\n\nfunc xchgp1(ptr unsafe.Pointer, new unsafe.Pointer) unsafe.Pointer\n\n\nfunc xchguintptr(ptr *uintptr, new uintptr) uintptr\n\n\nfunc atomicload64(ptr *uint64) uint64\n\n\nfunc atomicor8(ptr *uint8, val uint8)\n\n\nfunc cas64(ptr *uint64, old, new uint64) bool\n\n\nfunc atomicstore(ptr *uint32, val uint32)\n\n\nfunc atomicstore64(ptr *uint64, val uint64)\n\n\nfunc atomicstorep1(ptr unsafe.Pointer, val unsafe.Pointer)\n\nfunc xchg64(ptr *uint64, new uint64) uint64 ", "output": "{\n\tfor {\n\t\told := *ptr\n\t\tif cas64(ptr, old, new) {\n\t\t\treturn old\n\t\t}\n\t}\n}"}
{"input": "package irc\n\nimport (\n\t\"io\"\n)\n\ntype Client struct {\n\tio.ReadWriteCloser\n}\n\n\nfunc (c Client) Command(command string, params ...string) error {\n\treturn c.SendMessage(Message{Command: command, Params: params})\n}\n\nfunc (c Client) Nick(name string) error        { return c.Command(\"NICK\", name) }\nfunc (c Client) Pass(password string) error    { return c.Command(\"PASS\", password) }\nfunc (c Client) Join(channels ...string) error { return c.Command(\"JOIN\", channels...) }\nfunc (c Client) JoinLockedChannel(channel, password string) error {\n\treturn c.Command(\"JOIN\", channel, password)\n}\n\nfunc NewClient(r io.ReadWriteCloser) (c Client) {\n\tc.ReadWriteCloser = r\n\n\treturn\n}\n\nfunc (c Client) SendMessage(m Message) (err error) ", "output": "{ return m.Encode(c) }"}
{"input": "package ivona_test\n\nimport (\n\t\"log\"\n\n\tivona \"github.com/jpadilla/ivona-go\"\n)\n\nfunc ExampleIvona_CreateSpeech() {\n\tclient := ivona.New(\"IVONA_ACCESS_KEY\", \"IVONA_SECRET_KEY\")\n\toptions := ivona.NewSpeechOptions(\"Hello World\")\n\tr, err := client.CreateSpeech(options)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Printf(\"%v\\n\", len(r.Audio))\n\tlog.Printf(\"%v\\n\", r.ContentType)\n\tlog.Printf(\"%v\\n\", r.RequestID)\n}\n\n\n\nfunc ExampleIvona_ListVoices() ", "output": "{\n\tclient := ivona.New(\"IVONA_ACCESS_KEY\", \"IVONA_SECRET_KEY\")\n\n\tr, err := client.ListVoices(ivona.Voice{})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Printf(\"%v\\n\", len(r.Voices))\n}"}
{"input": "package osutil\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n\nfunc CreateSharedMemFile(size int) (f *os.File, err error) {\n\tfd, err := unix.MemfdCreate(\"syz-shared-mem\", 0)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to do memfd_create: %v\", err)\n\t\treturn\n\t}\n\tf = os.NewFile(uintptr(fd), fmt.Sprintf(\"/proc/self/fd/%d\", fd))\n\treturn\n}\n\n\n\nfunc CloseSharedMemFile(f *os.File) error ", "output": "{\n\treturn f.Close()\n}"}
{"input": "package clean\n\nimport (\n\t\"flag\"\n\t\"os\"\n\n\t\"github.com/tueftler/doget/command\"\n\t\"github.com/tueftler/doget/config\"\n\t\"github.com/tueftler/doget/dockerfile\"\n)\n\n\ntype CleanCommand struct {\n\tcommand.Command\n\tflags *flag.FlagSet\n}\n\n\n\n\n\nfunc (c *CleanCommand) Run(parser *dockerfile.Parser, args []string) error {\n\ttarget := config.Vendordir\n\tif _, err := os.Stat(target); nil == err {\n\t\treturn os.RemoveAll(target)\n\t}\n\n\treturn nil\n}\n\nfunc NewCommand(name string) *CleanCommand ", "output": "{\n\treturn &CleanCommand{flags: flag.NewFlagSet(name, flag.ExitOnError)}\n}"}
{"input": "package car\n\nimport (\n\t\"archive/tar\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\tcutil \"github.com/hyperledger/fabric/core/container/util\"\n\tpb \"github.com/hyperledger/fabric/protos\"\n\t\"github.com/spf13/viper\"\n)\n\n\n\n\n\nfunc (carPlatform *Platform) WritePackage(spec *pb.ChaincodeSpec, tw *tar.Writer) error {\n\n\tpath, err := download(spec.ChaincodeID.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tspec.ChaincodeID.Name, err = generateHashcode(spec, path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error generating hashcode: %s\", err)\n\t}\n\n\tvar buf []string\n\n\tbuf = append(buf, viper.GetString(\"chaincode.car.Dockerfile\"))\n\tbuf = append(buf, \"COPY package.car /tmp/package.car\")\n\tbuf = append(buf, fmt.Sprintf(\"RUN chaintool buildcar /tmp/package.car -o $GOPATH/bin/%s && rm /tmp/package.car\", spec.ChaincodeID.Name))\n\n\tdockerFileContents := strings.Join(buf, \"\\n\")\n\tdockerFileSize := int64(len([]byte(dockerFileContents)))\n\n\tvar zeroTime time.Time\n\ttw.WriteHeader(&tar.Header{Name: \"Dockerfile\", Size: dockerFileSize, ModTime: zeroTime, AccessTime: zeroTime, ChangeTime: zeroTime})\n\ttw.Write([]byte(dockerFileContents))\n\n\terr = cutil.WriteFileToPackage(path, \"package.car\", tw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc download(path string) (string, error) ", "output": "{\n\tif strings.HasPrefix(path, \"http://\") {\n\n\t\tvar tmp *os.File\n\t\tvar err error\n\t\ttmp, err = ioutil.TempFile(\"\", \"car\")\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"Error creating temporary file: %s\", err)\n\t\t}\n\t\tdefer os.Remove(tmp.Name())\n\t\tdefer tmp.Close()\n\n\t\tresp, err := http.Get(path)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"Error with HTTP GET: %s\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t_, err = io.Copy(tmp, resp.Body)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"Error downloading bytes: %s\", err)\n\t\t}\n\n\t\treturn tmp.Name(), nil\n\t}\n\n\treturn path, nil\n}"}
{"input": "package util\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/big\"\n\t\"time\"\n\n\tgp \"google/protobuf\"\n\n\t\"golang.org/x/crypto/sha3\"\n)\n\n\nfunc ComputeCryptoHash(data []byte) (hash []byte) {\n\thash = make([]byte, 64)\n\tsha3.ShakeSum256(hash, data)\n\treturn\n}\n\n\nfunc GenerateBytesUUID() []byte {\n\tuuid := make([]byte, 16)\n\t_, err := io.ReadFull(rand.Reader, uuid)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Error generating UUID: %s\", err))\n\t}\n\n\tuuid[8] = uuid[8]&^0xc0 | 0x80\n\n\tuuid[6] = uuid[6]&^0xf0 | 0x40\n\n\treturn uuid\n}\n\n\nfunc GenerateIntUUID() *big.Int {\n\tuuid := GenerateBytesUUID()\n\tz := big.NewInt(0)\n\treturn z.SetBytes(uuid)\n}\n\n\n\n\n\nfunc CreateUtcTimestamp() *gp.Timestamp {\n\tnow := time.Now().UTC()\n\tsecs := now.Unix()\n\tnanos := int32(now.UnixNano() - (secs * 1000000000))\n\treturn &(gp.Timestamp{Seconds: secs, Nanos: nanos})\n}\n\n\nfunc GenerateHashFromSignature(path string, ctor string, args []string) []byte {\n\tfargs := ctor\n\tif args != nil {\n\t\tfor _, str := range args {\n\t\t\tfargs = fargs + str\n\t\t}\n\t}\n\tcbytes := []byte(path + fargs)\n\n\tb := make([]byte, len(cbytes))\n\tcopy(b, cbytes)\n\thash := ComputeCryptoHash(b)\n\treturn hash\n}\n\nfunc GenerateUUID() string ", "output": "{\n\tuuid := GenerateBytesUUID()\n\treturn fmt.Sprintf(\"%x-%x-%x-%x-%x\", uuid[0:4], uuid[4:6], uuid[6:8], uuid[8:10], uuid[10:])\n}"}
{"input": "package core\n\nimport (\n\t\"fmt\"\n)\n\ntype BuiltInClass struct {\n\tname   Instance\n\tsupers []Class\n\tslots  []Instance\n}\n\nfunc NewBuiltInClass(name string, super Class, slots ...string) Class {\n\tslotNames := []Instance{}\n\tfor _, slot := range slots {\n\t\tslotNames = append(slotNames, NewSymbol(slot))\n\t}\n\treturn BuiltInClass{NewSymbol(name), []Class{super}, slotNames}\n}\n\nfunc (p BuiltInClass) Supers() []Class {\n\treturn p.supers\n}\n\nfunc (p BuiltInClass) Slots() []Instance {\n\treturn p.slots\n}\n\nfunc (p BuiltInClass) Initform(arg Instance) (v Instance, ok bool) {\n\treturn nil, false\n}\n\nfunc (p BuiltInClass) Initarg(arg Instance) (v Instance, ok bool) {\n\treturn arg, true\n}\n\nfunc (BuiltInClass) Class() Class {\n\treturn BuiltInClassClass\n}\n\n\n\nfunc (p BuiltInClass) String() string ", "output": "{\n\treturn fmt.Sprint(p.name)\n}"}
{"input": "package engine\n\nimport (\n\tvtrpcpb \"vitess.io/vitess/go/vt/proto/vtrpc\"\n\t\"vitess.io/vitess/go/vt/vterrors\"\n\n\t\"vitess.io/vitess/go/sqltypes\"\n\t\"vitess.io/vitess/go/vt/proto/query\"\n)\n\nvar _ Primitive = (*UpdateTarget)(nil)\n\n\ntype UpdateTarget struct {\n\tTarget string\n\n\tnoInputs\n\n\tnoTxNeeded\n}\n\nfunc (updTarget *UpdateTarget) description() PrimitiveDescription {\n\treturn PrimitiveDescription{\n\t\tOperatorType: \"UpdateTarget\",\n\t\tOther:        map[string]interface{}{\"target\": updTarget.Target},\n\t}\n}\n\n\nfunc (updTarget *UpdateTarget) RouteType() string {\n\treturn \"UpdateTarget\"\n}\n\n\n\n\n\nfunc (updTarget *UpdateTarget) GetTableName() string {\n\treturn \"\"\n}\n\n\nfunc (updTarget *UpdateTarget) TryExecute(vcursor VCursor, bindVars map[string]*query.BindVariable, wantfields bool) (*sqltypes.Result, error) {\n\terr := vcursor.Session().SetTarget(updTarget.Target)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &sqltypes.Result{}, nil\n}\n\n\nfunc (updTarget *UpdateTarget) TryStreamExecute(vcursor VCursor, bindVars map[string]*query.BindVariable, wantfields bool, callback func(*sqltypes.Result) error) error {\n\tresult, err := updTarget.TryExecute(vcursor, bindVars, wantfields)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn callback(result)\n}\n\n\nfunc (updTarget *UpdateTarget) GetFields(vcursor VCursor, bindVars map[string]*query.BindVariable) (*sqltypes.Result, error) {\n\treturn nil, vterrors.Errorf(vtrpcpb.Code_INTERNAL, \"[BUG] GetFields not reachable for use statement\")\n}\n\nfunc (updTarget *UpdateTarget) GetKeyspaceName() string ", "output": "{\n\treturn updTarget.Target\n}"}
{"input": "package models\n\nimport (\n\t\"github.com/jinzhu/gorm\"\n)\n\n\ntype UserContributionSoundLength struct {\n\tBaseModel\n\tUserContributionID int `json:\"user_contribution_id\"`\n\tSecond             int `json:\"second\"`\n\tLength             int `json:\"length\"`\n}\n\n\n\n\n\nfunc (u *UserContributionSoundLength) Save() error {\n\treturn Save(u)\n}\n\n\nfunc (u *UserContributionSoundLength) GetByUserContributionID(uID int) (userContributionSoundLength UserContributionSoundLength, db *gorm.DB, err error) {\n\twhereList := []map[string]interface{}{\n\t\t{\"UserContributionID\": uID},\n\t}\n\toption := make(map[string]interface{})\n\n\tdb, err = GetWhere(&userContributionSoundLength, \"User_contribution_ID = :UserContributionID\", whereList, option)\n\n\treturn\n}\n\n\nfunc (u *UserContributionSoundLength) GetByTop(o int, s int) (userContributionSoundLength []UserContributionSoundLength, db *gorm.DB, err error) {\n\twhereList := []map[string]interface{}{}\n\n\toptionMap := map[string]interface{}{\n\t\t\"order\":  \"ID desc\",\n\t\t\"limit\":  s,\n\t\t\"offset\": o,\n\t}\n\n\tdb, err = GetListWhere(&userContributionSoundLength, \"\", whereList, optionMap)\n\treturn\n}\n\nfunc (u *UserContributionSoundLength) Add() error ", "output": "{\n\treturn Create(u)\n}"}
{"input": "package command\n\nimport (\n\t\"fmt\"\n\t\"gcredstash\"\n\t\"os\"\n\t\"sort\"\n\t\"strings\"\n)\n\ntype ListCommand struct {\n\tMeta\n}\n\nfunc (c *ListCommand) getLines(items map[*string]*string) []string {\n\tmaxNameLen := gcredstash.MaxKeyLen(items)\n\tlines := []string{}\n\n\tfor name, version := range items {\n\t\tversionNum := gcredstash.Atoi(*version)\n\t\tlines = append(lines, fmt.Sprintf(\"%-*s -- version: %d\", maxNameLen, *name, versionNum))\n\t}\n\n\treturn lines\n}\n\nfunc (c *ListCommand) RunImpl(args []string) (string, error) {\n\tif len(args) > 0 {\n\t\treturn \"\", fmt.Errorf(\"too many arguments\")\n\t}\n\n\titems, err := c.Driver.ListSecrets(c.Table)\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tlines := c.getLines(items)\n\tsort.Strings(lines)\n\n\treturn strings.Join(lines, \"\\n\"), nil\n}\n\n\n\nfunc (c *ListCommand) Synopsis() string {\n\treturn \"list credentials and their version\"\n}\n\nfunc (c *ListCommand) Help() string {\n\thelpText := `\nusage: gcredstash list\n`\n\n\treturn strings.TrimSpace(helpText)\n}\n\nfunc (c *ListCommand) Run(args []string) int ", "output": "{\n\tout, err := c.RunImpl(args)\n\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error: %s\\n\", err.Error())\n\t\treturn 1\n\t}\n\n\tfmt.Println(out)\n\n\treturn 0\n}"}
{"input": "package tabular\n\nimport (\n\t\"bytes\"\n\t\"github.com/omakoto/mlib\"\n\t\"strings\"\n)\n\n\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc doTabular(r <-chan []string, out chan<- string) {\n\tall := make([][]string, 0, 1024)\n\twidths := make([]int, 0)\n\n\tmlib.Debug(\"Reading input...\\n\")\n\n\tfor fields := range r {\n\t\tall = append(all, fields)\n\t\tfor i := 0; i < len(fields); i++ {\n\t\t\tif len(widths) < len(fields) {\n\t\t\t\told := widths\n\t\t\t\twidths = make([]int, len(fields))\n\t\t\t\tcopy(widths, old)\n\t\t\t}\n\t\t\tmlib.Debug(\"  index=%d, cur=%d\\n\", i, widths[i])\n\t\t\twidths[i] = max(widths[i], stringWidth(fields[i]))\n\t\t}\n\t}\n\n\tmlib.Debug(\"Read all lines\\n\")\n\n\tmlib.DebugDump(all)\n\tmlib.DebugDump(widths)\n\n\toutBuffer := bytes.Buffer{}\n\n\tfor _, fields := range all {\n\t\toutBuffer.Reset()\n\t\tfor i := 0; i < len(fields); i++ {\n\t\t\tif i > 0 {\n\t\t\t\toutBuffer.WriteString(\" \")\n\t\t\t}\n\t\t\tw := stringWidth(fields[i])\n\t\t\toutBuffer.WriteString(fields[i])\n\t\t\toutBuffer.WriteString(strings.Repeat(\" \", widths[i]-w))\n\t\t}\n\t\tout <- outBuffer.String()\n\t}\n}\n\nfunc Tabular(r <-chan []string) <-chan string ", "output": "{\n\tout := make(chan string)\n\n\tgo func() {\n\t\tdefer close(out)\n\t\tdoTabular(r, out)\n\t}()\n\n\treturn out\n}"}
{"input": "package blobserver\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\n\t\"perkeep.org/pkg/blob\"\n)\n\n\n\ntype NoImplStorage struct{}\n\nvar _ Storage = NoImplStorage{}\n\nfunc (NoImplStorage) Fetch(context.Context, blob.Ref) (file io.ReadCloser, size uint32, err error) {\n\treturn nil, 0, os.ErrNotExist\n}\n\nfunc (NoImplStorage) ReceiveBlob(context.Context, blob.Ref, io.Reader) (sb blob.SizedRef, err error) {\n\terr = errors.New(\"ReceiveBlob not implemented\")\n\treturn\n}\n\n\n\nfunc (NoImplStorage) EnumerateBlobs(ctx context.Context, dest chan<- blob.SizedRef, after string, limit int) error {\n\tclose(dest)\n\treturn errors.New(\"EnumerateBlobs not implemented\")\n}\n\nfunc (NoImplStorage) RemoveBlobs(ctx context.Context, blobs []blob.Ref) error {\n\treturn errors.New(\"Remove not implemented\")\n}\n\nfunc (NoImplStorage) StatBlobs(ctx context.Context, blobs []blob.Ref, fn func(blob.SizedRef) error) error ", "output": "{\n\treturn errors.New(\"Stat not implemented\")\n}"}
{"input": "package json\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"k8s.io/client-go/pkg/api/unversioned\"\n)\n\n\n\ntype MetaFactory interface {\n\tInterpret(data []byte) (*unversioned.GroupVersionKind, error)\n}\n\n\n\n\nvar DefaultMetaFactory = SimpleMetaFactory{}\n\n\n\n\n\ntype SimpleMetaFactory struct {\n}\n\n\n\n\n\nfunc (SimpleMetaFactory) Interpret(data []byte) (*unversioned.GroupVersionKind, error) ", "output": "{\n\tfindKind := struct {\n\t\tAPIVersion string `json:\"apiVersion,omitempty\"`\n\t\tKind string `json:\"kind,omitempty\"`\n\t}{}\n\tif err := json.Unmarshal(data, &findKind); err != nil {\n\t\treturn nil, fmt.Errorf(\"couldn't get version/kind; json parse error: %v\", err)\n\t}\n\tgv, err := unversioned.ParseGroupVersion(findKind.APIVersion)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &unversioned.GroupVersionKind{Group: gv.Group, Version: gv.Version, Kind: findKind.Kind}, nil\n}"}
{"input": "package kubernetes\n\nimport (\n\t\"github.com/weaveworks/scope/report\"\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/labels\"\n)\n\n\nconst (\n\tPublicIP = \"kubernetes_public_ip\"\n)\n\n\ntype Service interface {\n\tMeta\n\tGetNode() report.Node\n\tSelector() labels.Selector\n\tClusterIP() string\n}\n\ntype service struct {\n\t*api.Service\n\tMeta\n}\n\n\nfunc NewService(s *api.Service) Service {\n\treturn &service{Service: s, Meta: meta{s.ObjectMeta}}\n}\n\nfunc (s *service) Selector() labels.Selector {\n\tif s.Spec.Selector == nil {\n\t\treturn labels.Nothing()\n\t}\n\treturn labels.SelectorFromSet(labels.Set(s.Spec.Selector))\n}\n\nfunc (s *service) GetNode() report.Node {\n\tlatest := map[string]string{IP: s.Spec.ClusterIP}\n\tif s.Spec.LoadBalancerIP != \"\" {\n\t\tlatest[PublicIP] = s.Spec.LoadBalancerIP\n\t}\n\treturn s.MetaNode(report.MakeServiceNodeID(s.UID())).WithLatests(latest)\n}\n\n\n\nfunc (s *service) ClusterIP() string ", "output": "{\n\treturn s.Spec.ClusterIP\n}"}
{"input": "package ssb\n\nimport (\n\t\"encoding/json\"\n)\n\ntype MessageBody struct {\n\tType    string   `json:\"type\"`\n\tMessage *Message `json:\"-\"`\n}\n\nvar MessageTypes = map[string]func(mb MessageBody) interface{}{}\n\nfunc (m *Message) DecodeMessage() (t string, mb interface{}) {\n\tType := &MessageBody{}\n\tjson.Unmarshal(m.Content, &Type)\n\tType.Message = m\n\tif mf, ok := MessageTypes[Type.Type]; ok {\n\t\tmb = mf(*Type)\n\t}\n\tt = Type.Type\n\tjson.Unmarshal(m.Content, &mb)\n\treturn\n}\n\n\n\nfunc (m *Message) Type() string ", "output": "{\n\tType := &MessageBody{}\n\tjson.Unmarshal(m.Content, &Type)\n\treturn Type.Type\n}"}
{"input": "package goxml_test\n\nimport (\n\t. \"launchpad.net/gocheck\"\n)\n\n\n\nfunc (s *S) testXmlwriterFilename(c *C) ", "output": "{\n\tc.Check(42, Equals, 42)\n}"}
{"input": "package servicebuilder_test\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n)\n\n\n\nfunc TestServiceBuilder(t *testing.T) ", "output": "{\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"ServiceBuilder Suite\")\n}"}
{"input": "package clipboard\n\n\nfunc Clear() error {\n\treturn NoDataError{notImplemented: true}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Write(formats []Format) (err error) {\n\treturn NoDataError{notImplemented: true}\n}\n\nfunc Read(formats ...string) (f int, b []byte, err error) ", "output": "{\n\treturn 0, nil, NoDataError{notImplemented: true}\n}"}
{"input": "package cubbyhole\n\nimport \"testing\"\n\nfunc TestCubbyholePut(t *testing.T) {\n\tc := Cubbyhole{}\n\n\tif c.Message != \"\" {\n\t\tt.Error(`Cubbyhole must be \"\" before the first put`)\n\t}\n\n\tc.Put(\"test!\")\n\tif c.Message != \"test!\" {\n\t\tt.Errorf(`Cubbyhole should be \"test!\" but is: %s`, c.Message)\n\t}\n}\n\nfunc TestCubbyholeDrop(t *testing.T) {\n\tc := Cubbyhole{}\n\n\tc.Drop()\n\tif c.Message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Drop didn't drop the message: %s`, c.Message)\n\t}\n\n\tc.Message = \"foobar\"\n\n\tc.Drop()\n\tif c.Message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Drop didn't drop the message: %s`, c.Message)\n\t}\n}\n\nfunc TestCubbyholeLook(t *testing.T) {\n\tc := Cubbyhole{}\n\n\tif message := c.Look(); message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Look didn't return an empty message: %s`, message)\n\t}\n\n\tc.Message = \"NPA\"\n\tif message := c.Look(); message != \"NPA\" {\n\t\tt.Errorf(`Cubbyhole.Look didn't return the correct message \"NPA\" != %s`, message)\n\t}\n}\n\n\n\nfunc TestCubbyholeGet(t *testing.T) ", "output": "{\n\tc := Cubbyhole{}\n\n\tif message := c.Get(); message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Get didn't return an empty message: %s`, message)\n\t}\n\n\tc.Message = \"NPA\"\n\tif message := c.Get(); message != \"NPA\" {\n\t\tt.Errorf(`Cubbyhole.Look didn't return the correct message \"NPA\" != %s`, message)\n\t}\n\n\tif message := c.Get(); message != \"\" {\n\t\tt.Errorf(`Cubbyhole.Get didn't return an empty message: %s`, message)\n\t}\n}"}
{"input": "package actions\n\n\n\n\nimport (\n\t\"net/http\"\n\n\tmiddleware \"github.com/go-openapi/runtime/middleware\"\n\n\tmodels \"github.com/semi-technologies/weaviate/entities/models\"\n)\n\n\ntype ActionsDeleteHandlerFunc func(ActionsDeleteParams, *models.Principal) middleware.Responder\n\n\nfunc (fn ActionsDeleteHandlerFunc) Handle(params ActionsDeleteParams, principal *models.Principal) middleware.Responder {\n\treturn fn(params, principal)\n}\n\n\ntype ActionsDeleteHandler interface {\n\tHandle(ActionsDeleteParams, *models.Principal) middleware.Responder\n}\n\n\n\n\n\ntype ActionsDelete struct {\n\tContext *middleware.Context\n\tHandler ActionsDeleteHandler\n}\n\nfunc (o *ActionsDelete) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n\troute, rCtx, _ := o.Context.RouteInfo(r)\n\tif rCtx != nil {\n\t\tr = rCtx\n\t}\n\tvar Params = NewActionsDeleteParams()\n\n\tuprinc, aCtx, err := o.Context.Authorize(r, route)\n\tif err != nil {\n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\tif aCtx != nil {\n\t\tr = aCtx\n\t}\n\tvar principal *models.Principal\n\tif uprinc != nil {\n\t\tprincipal = uprinc.(*models.Principal) \n\t}\n\n\tif err := o.Context.BindValidRequest(r, route, &Params); err != nil { \n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\n\tres := o.Handler.Handle(Params, principal) \n\n\to.Context.Respond(rw, r, route.Produces, route, res)\n\n}\n\nfunc NewActionsDelete(ctx *middleware.Context, handler ActionsDeleteHandler) *ActionsDelete ", "output": "{\n\treturn &ActionsDelete{Context: ctx, Handler: handler}\n}"}
{"input": "package response\n\nimport \"encoding/json\"\nimport \"net/http\"\n\n\ntype Response struct {\n\tStatusCode int         `json:\"status_code\"`\n\tMessage    string      `json:\"message\"`\n\tData       interface{} `json:\"data\"`\n}\n\n\n\n\n\nfunc Success(result interface{}) []byte {\n\treturn createResponse(Response{\n\t\tStatusCode: 200,\n\t\tMessage:    \"ok\",\n\t\tData:       result,\n\t})\n}\n\n\nfunc Failed(message string) []byte {\n\treturn createResponse(Response{\n\t\tStatusCode: 500,\n\t\tMessage:    message,\n\t})\n}\n\nfunc SendJSONResponseHeader(w http.ResponseWriter) {\n\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc createResponse(result Response) []byte ", "output": "{\n\tres, _ := json.Marshal(result)\n\treturn res\n}"}
{"input": "package activekit\n\nimport \"io\"\n\ntype Recounter struct {\n\tRe  io.Reader\n\tsum int64\n}\n\n\nfunc (re *Recounter) Sum() int64 {\n\treturn re.sum\n}\n\nfunc (re *Recounter) Read(p []byte) (int, error) ", "output": "{\n\tn, err := re.Re.Read(p)\n\tre.sum += int64(n)\n\treturn n, err\n}"}
{"input": "package vulnerabilityscanning\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ChangeContainerScanRecipeCompartmentRequest struct {\n\n\tContainerScanRecipeId *string `mandatory:\"true\" contributesTo:\"path\" name:\"containerScanRecipeId\"`\n\n\tChangeContainerScanRecipeCompartmentDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request ChangeContainerScanRecipeCompartmentRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request ChangeContainerScanRecipeCompartmentRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\n\n\n\nfunc (request ChangeContainerScanRecipeCompartmentRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ChangeContainerScanRecipeCompartmentResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response ChangeContainerScanRecipeCompartmentResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response ChangeContainerScanRecipeCompartmentResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request ChangeContainerScanRecipeCompartmentRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) ", "output": "{\n\n\treturn nil, false\n\n}"}
{"input": "package ginkgoext\n\nimport (\n\t\"github.com/onsi/gomega/types\"\n)\n\ntype anythingMatcher struct{}\n\nfunc (matcher *anythingMatcher) Match(actual interface{}) (success bool, err error) {\n\treturn true, nil\n}\n\nfunc (matcher *anythingMatcher) FailureMessage(actual interface{}) (message string) {\n\treturn \"\"\n}\n\n\n\n\nfunc BeAnything() types.GomegaMatcher {\n\treturn &anythingMatcher{}\n}\n\nfunc (matcher *anythingMatcher) NegatedFailureMessage(actual interface{}) (message string) ", "output": "{\n\treturn \"\"\n}"}
{"input": "package msgraph\n\nimport \"context\"\n\n\ntype WorkbookFunctionsAcoshRequestBuilder struct{ BaseRequestBuilder }\n\n\nfunc (b *WorkbookFunctionsRequestBuilder) Acosh(reqObj *WorkbookFunctionsAcoshRequestParameter) *WorkbookFunctionsAcoshRequestBuilder {\n\tbb := &WorkbookFunctionsAcoshRequestBuilder{BaseRequestBuilder: b.BaseRequestBuilder}\n\tbb.BaseRequestBuilder.baseURL += \"/acosh\"\n\tbb.BaseRequestBuilder.requestObject = reqObj\n\treturn bb\n}\n\n\ntype WorkbookFunctionsAcoshRequest struct{ BaseRequest }\n\n\n\n\n\nfunc (r *WorkbookFunctionsAcoshRequest) Post(ctx context.Context) (resObj *WorkbookFunctionResult, err error) {\n\terr = r.JSONRequest(ctx, \"POST\", \"\", r.requestObject, &resObj)\n\treturn\n}\n\nfunc (b *WorkbookFunctionsAcoshRequestBuilder) Request() *WorkbookFunctionsAcoshRequest ", "output": "{\n\treturn &WorkbookFunctionsAcoshRequest{\n\t\tBaseRequest: BaseRequest{baseURL: b.baseURL, client: b.client, requestObject: b.requestObject},\n\t}\n}"}
{"input": "package sch\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype UpdateServiceConnectorRequest struct {\n\n\tServiceConnectorId *string `mandatory:\"true\" contributesTo:\"path\" name:\"serviceConnectorId\"`\n\n\tUpdateServiceConnectorDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request UpdateServiceConnectorRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request UpdateServiceConnectorRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request UpdateServiceConnectorRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request UpdateServiceConnectorRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype UpdateServiceConnectorResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response UpdateServiceConnectorResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\n\n\nfunc (response UpdateServiceConnectorResponse) HTTPResponse() *http.Response ", "output": "{\n\treturn response.RawResponse\n}"}
{"input": "package data\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/spf13/viper\"\n)\n\n\ntype SSHKey struct {\n\tID          int    `json:\"id\"`\n\tFingerprint string `json:\"fingerprint\"`\n\tPublicKey   string `json:\"public_key\"`\n\tName        string `json:\"name\"`\n}\n\n\ntype SingleSSHKey struct {\n\tSSHKey *SSHKey `json:\"ssh_key\"`\n}\n\n\ntype ArraySSHKey struct {\n\tSSHKey []SSHKey `json:\"ssh_keys\"`\n}\n\n\n\n\n\nfunc (k *SSHKey) PrintInfo() {\n\tif viper.GetString(\"output\") == \"json\" {\n\t\tk.JSONPrint()\n\t} else {\n\t\tk.TextPrint()\n\t}\n}\n\n\nfunc (k *SSHKey) TextPrint() {\n\tfmt.Println(\"==============================\")\n\tfmt.Println(\"ID:           \", k.ID)\n\tfmt.Println(\"Fingerprint:  \", k.Fingerprint)\n\tfmt.Println(\"Name:         \", k.Name)\n}\n\n\nfunc (k *SSHKey) JSONPrint() {\n\toutput, err := json.MarshalIndent(k, \"\", \"    \")\n\tif err != nil {\n\t\tfmt.Println(\"Error parsing to JSON\")\n\t}\n\tos.Stdout.Write(output)\n}\n\nfunc (arr *ArraySSHKey) PrintInfo() ", "output": "{\n\tfor _, v := range arr.SSHKey {\n\t\tv.PrintInfo()\n\t}\n}"}
{"input": "package gfile\n\nimport (\n\t\"bytes\"\n\t\"github.com/gogf/gf/v2/errors/gcode\"\n\t\"github.com/gogf/gf/v2/errors/gerror\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"runtime\"\n\t\"strings\"\n)\n\n\n\n\nfunc Home(names ...string) (string, error) {\n\tpath, err := getHomePath()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, name := range names {\n\t\tpath += Separator + name\n\t}\n\treturn path, nil\n}\n\n\nfunc getHomePath() (string, error) {\n\tu, err := user.Current()\n\tif nil == err {\n\t\treturn u.HomeDir, nil\n\t}\n\tif \"windows\" == runtime.GOOS {\n\t\treturn homeWindows()\n\t}\n\treturn homeUnix()\n}\n\n\nfunc homeUnix() (string, error) {\n\tif home := os.Getenv(\"HOME\"); home != \"\" {\n\t\treturn home, nil\n\t}\n\tvar stdout bytes.Buffer\n\tcmd := exec.Command(\"sh\", \"-c\", \"eval echo ~$USER\")\n\tcmd.Stdout = &stdout\n\tif err := cmd.Run(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tresult := strings.TrimSpace(stdout.String())\n\tif result == \"\" {\n\t\treturn \"\", gerror.NewCode(gcode.CodeInternalError, \"blank output when reading home directory\")\n\t}\n\n\treturn result, nil\n}\n\n\n\n\nfunc homeWindows() (string, error) ", "output": "{\n\tvar (\n\t\tdrive = os.Getenv(\"HOMEDRIVE\")\n\t\tpath  = os.Getenv(\"HOMEPATH\")\n\t\thome  = drive + path\n\t)\n\tif drive == \"\" || path == \"\" {\n\t\thome = os.Getenv(\"USERPROFILE\")\n\t}\n\tif home == \"\" {\n\t\treturn \"\", gerror.NewCode(gcode.CodeOperationFailed, \"HOMEDRIVE, HOMEPATH, and USERPROFILE are blank\")\n\t}\n\n\treturn home, nil\n}"}
{"input": "package vip\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\n\t\"go-common/app/interface/main/account/model\"\n\t\"go-common/library/ecode\"\n\n\tpkgerr \"github.com/pkg/errors\"\n)\n\nconst (\n\t_oauth2UserInfoPath = \"/oauth2/user_info\"\n)\n\n\n\n\nfunc (d *Dao) OAuth2ByCode(c context.Context, a *model.ArgAuthCode) (data *model.OAuth2InfoResp, err error) ", "output": "{\n\tparams := url.Values{}\n\tparams.Add(\"code\", a.Code)\n\tparams.Add(\"grant_type\", \"authorization_code\")\n\tvar res struct {\n\t\tCode int                   `json:\"code\"`\n\t\tData *model.OAuth2InfoResp `json:\"data\"`\n\t}\n\tif err = d.cl.get(c, d.c.Host.PassportCom, _oauth2UserInfoPath, a.IP, params, &res); err != nil {\n\t\treturn\n\t}\n\tif res.Code != 0 {\n\t\terr = ecode.Int(res.Code)\n\t\terr = pkgerr.Wrap(err, \"dao oauth2 userinfo\")\n\t\treturn\n\t}\n\tdata = res.Data\n\treturn\n}"}
{"input": "package common\n\nimport (\n\t\"github.com/spf13/viper\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\ntype Wskprops struct {\n\tAPIHost string\n\tAuthKey string\n}\n\n\n\nfunc GetWskprops() *Wskprops ", "output": "{\n\tvar dep Wskprops\n\tdep.APIHost = \"\"\n\tdep.AuthKey = \"\"\n\n\tviper.SetConfigName(\"whisk\")\n\tviper.AddConfigPath(os.Getenv(\"OPENWHISK_HOME\"))\n\n\terr := viper.ReadInConfig()\n\tif err == nil {\n\t\tauthPath := viper.GetString(\"testing.auth\")\n\n\t\tb, err := ioutil.ReadFile(authPath)\n\t\tif err == nil {\n\t\t\tdep.AuthKey = string(b)\n\t\t}\n\t\tdep.APIHost = viper.GetString(\"router.host\")\n\t}\n\treturn &dep\n}"}
{"input": "package stats\n\nimport (\n\t\"time\"\n\n\t\"github.com/syncthing/syncthing/lib/db\"\n\t\"github.com/syndtr/goleveldb/leveldb\"\n)\n\ntype FolderStatistics struct {\n\tLastFile LastFile `json:\"lastFile\"`\n}\n\ntype FolderStatisticsReference struct {\n\tns     *db.NamespacedKV\n\tfolder string\n}\n\ntype LastFile struct {\n\tAt       time.Time `json:\"at\"`\n\tFilename string    `json:\"filename\"`\n\tDeleted  bool      `json:\"deleted\"`\n}\n\nfunc NewFolderStatisticsReference(ldb *leveldb.DB, folder string) *FolderStatisticsReference {\n\tprefix := string(db.KeyTypeFolderStatistic) + folder\n\treturn &FolderStatisticsReference{\n\t\tns:     db.NewNamespacedKV(ldb, prefix),\n\t\tfolder: folder,\n\t}\n}\n\nfunc (s *FolderStatisticsReference) GetLastFile() LastFile {\n\tat, ok := s.ns.Time(\"lastFileAt\")\n\tif !ok {\n\t\treturn LastFile{}\n\t}\n\tfile, ok := s.ns.String(\"lastFileName\")\n\tif !ok {\n\t\treturn LastFile{}\n\t}\n\tdeleted, ok := s.ns.Bool(\"lastFileDeleted\")\n\treturn LastFile{\n\t\tAt:       at,\n\t\tFilename: file,\n\t\tDeleted:  deleted,\n\t}\n}\n\nfunc (s *FolderStatisticsReference) ReceivedFile(file string, deleted bool) {\n\tif debug {\n\t\tl.Debugln(\"stats.FolderStatisticsReference.ReceivedFile:\", s.folder, file)\n\t}\n\ts.ns.PutTime(\"lastFileAt\", time.Now())\n\ts.ns.PutString(\"lastFileName\", file)\n\ts.ns.PutBool(\"lastFileDeleted\", deleted)\n}\n\n\n\nfunc (s *FolderStatisticsReference) GetStatistics() FolderStatistics ", "output": "{\n\treturn FolderStatistics{\n\t\tLastFile: s.GetLastFile(),\n\t}\n}"}
{"input": "package gexp\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\n\n\ntype Context struct {\n\tcontext context.Context\n\tcancel  context.CancelFunc\n}\n\n\n\n\nfunc NewContext() *Context {\n\treturn &Context{\n\t\tcontext: context.Background(),\n\t}\n}\n\n\n\n\n\n\nfunc (c *Context) WithCancel() *Context {\n\tchild, cancel := context.WithCancel(c.context)\n\treturn &Context{\n\t\tcontext: child,\n\t\tcancel:  cancel,\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (c *Context) WithTimeout(nsec int64) *Context {\n\tchild, cancel := context.WithTimeout(c.context, time.Duration(nsec))\n\treturn &Context{\n\t\tcontext: child,\n\t\tcancel:  cancel,\n\t}\n}\n\nfunc (c *Context) WithDeadline(sec int64, nsec int64) *Context ", "output": "{\n\tchild, cancel := context.WithDeadline(c.context, time.Unix(sec, nsec))\n\treturn &Context{\n\t\tcontext: child,\n\t\tcancel:  cancel,\n\t}\n}"}
{"input": "package start\n\nimport (\n\t\"github.com/spf13/pflag\"\n)\n\n\ntype NetworkArgs struct {\n\tNetworkPluginName string\n\tClusterNetworkCIDR string\n\tHostSubnetLength uint32\n\tServiceNetworkCIDR string\n}\n\n\nfunc BindNetworkArgs(args *NetworkArgs, flags *pflag.FlagSet, prefix string) {\n\tflags.StringVar(&args.NetworkPluginName, prefix+\"network-plugin\", args.NetworkPluginName, \"The name of the networking plugin to be used for networking.\")\n\tflags.StringVar(&args.ClusterNetworkCIDR, prefix+\"network-cidr\", args.ClusterNetworkCIDR, \"The CIDR string representing the network that all containers should belong to.\")\n\tflags.Uint32Var(&args.HostSubnetLength, prefix+\"host-subnet-length\", args.HostSubnetLength, \"The length of subnet each host is given from the network-cidr.\")\n\tflags.StringVar(&args.ServiceNetworkCIDR, prefix+\"portal-net\", args.ServiceNetworkCIDR, \"The CIDR string representing the network that portal/service IPs will be assigned from. This must not overlap with any IP ranges assigned to nodes for pods.\")\n}\n\n\n\n\nfunc NewDefaultNetworkArgs() *NetworkArgs ", "output": "{\n\tconfig := &NetworkArgs{\n\t\tNetworkPluginName:  \"\",\n\t\tClusterNetworkCIDR: \"10.128.0.0/14\",\n\t\tHostSubnetLength:   9,\n\t\tServiceNetworkCIDR: \"172.30.0.0/16\",\n\t}\n\n\treturn config\n}"}
{"input": "package main\n\nimport (\n\t\"math\"\n\t\"sort\"\n)\n\ntype NaiveSieve struct {\n\tsieve map[int]bool\n}\n\nfunc NewNaiveSieve(limit int) NaiveSieve {\n\n\tprimes := make(map[int]bool)\n\n\tprimes[2] = true\n\n\tfor n := 3; n < limit; n += 2 {\n\t\tif IsNaivePrime(n) {\n\t\t\tprimes[n] = true\n\t\t}\n\t}\n\n\treturn NaiveSieve{primes}\n}\n\n\n\nfunc (self *NaiveSieve) Primes() []int {\n\tprimes := make([]int, 0, len(self.sieve))\n\tfor n, _ := range self.sieve {\n\t\tprimes = append(primes, n)\n\t}\n\tsort.Ints(primes)\n\treturn primes\n}\n\nfunc IsNaivePrime(n int) bool {\n\tswitch {\n\tcase n == 1:\n\t\treturn false\n\tcase n == 2:\n\t\treturn true\n\tcase n%2 == 0:\n\t\treturn false\n\t}\n\n\tlimit := int(math.Sqrt(float64(n)))\n\n\tfor i := 3; i <= limit; i += 2 {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (self *NaiveSieve) Contains(n int) bool ", "output": "{\n\t_, ok := self.sieve[n]\n\treturn ok\n}"}
{"input": "package models\n\nimport (\n\n)\n\ntype FirstModel struct {\n\tBaseModel\n}\n\ntype second struct {\n\tTitle string \n\tUrl   string \n\tId    int    \n\tCount int    \n}\n\ntype Fream struct {\n\tId         int\n\tTitle      string\n\tDesc       string\n\tBigPic     string\n\tSecondList []second\n\tCount      int \n}\n\n\n\nfunc (self *FirstModel) LoadData() (d []Good) {\n\tfor i := 0; i < 48; i++ {\n\t\td = append(d, Good{\n\t\t\tGoodId:       string(i),\n\t\t\tFirst:        \"搞笑 & 奇葩\",\n\t\t\tSecond:       \"搞笑\",\n\t\t\tGoodPrice:    \"5\",\n\t\t\tGoodUrl:      \"/\",\n\t\t\tTitle:        \"I will fuck fuck fuck fuck you!\",\n\t\t\tAuthor:       \"fuck fuck\",\n\t\t\tAuthorUrl:    \"/\",\n\t\t\tPic:          \"http://i11.tietuku.com/a6512ad4adb04b7d.jpg\",\n\t\t\tSupport:      \"/join\",\n\t\t\tSupportCount: \"800\",\n\t\t\tSupportLevel: \"10\",\n\t\t})\n\t}\n\treturn\n}\n\nfunc (self *FirstModel) LoadFrame() (c Fream) ", "output": "{\n\tc.Id = 1\n\tc.Title = \"搞笑&奇葩\"\n\tc.Desc = \"各种搞笑，各种奇葩\"\n\tc.BigPic = \"http://i13.tietuku.com/0d2a7be856ebf374.jpg\"\n\tc.Count = 9999999\n\tc.SecondList = []second{\n\t\t{\n\t\t\tTitle: \"搞笑\",\n\t\t\tUrl:   \"/categorys/fun/\",\n\t\t\tId:    1,\n\t\t\tCount: 10000,\n\t\t},\n\t\t{\n\t\t\tTitle: \"奇葩\",\n\t\t\tUrl:   \"/categorys/miracle/\",\n\t\t\tId:    2,\n\t\t\tCount: 8000,\n\t\t},\n\t}\n\treturn\n}"}
{"input": "package yaml\n\nimport (\n\t\"errors\"\n\n\t\"github.com/guzzlerio/corcel/core\"\n\t\"github.com/guzzlerio/corcel/extractors\"\n)\n\n\ntype JSONPathExtractorParser struct{}\n\n\nfunc (instance JSONPathExtractorParser) Parse(input map[string]interface{}) (core.Extractor, error) {\n\n\tif _, ok := input[\"name\"]; !ok {\n\t\treturn extractors.JSONPathExtractor{}, errors.New(\"name not set\")\n\t}\n\n\tif _, ok := input[\"key\"]; !ok {\n\t\treturn extractors.JSONPathExtractor{}, errors.New(\"key not set\")\n\t}\n\n\tif _, ok := input[\"jsonpath\"]; !ok {\n\t\treturn extractors.JSONPathExtractor{}, errors.New(\"jsonpath not set\")\n\t}\n\n\textractor := extractors.JSONPathExtractor{\n\t\tName:     input[\"name\"].(string),\n\t\tKey:      input[\"key\"].(string),\n\t\tJSONPath: input[\"jsonpath\"].(string),\n\t\tScope:    core.StepScope,\n\t}\n\n\tif input[\"scope\"] != nil {\n\t\textractor.Scope = input[\"scope\"].(string)\n\t}\n\n\treturn extractor, nil\n}\n\n\n\n\nfunc (instance JSONPathExtractorParser) Key() string ", "output": "{\n\treturn \"JSONPathExtractor\"\n}"}
{"input": "package fake\n\nimport (\n\tv1alpha1 \"github.com/appscode/searchlight/client/clientset/versioned/typed/incidents/v1alpha1\"\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n)\n\ntype FakeIncidentsV1alpha1 struct {\n\t*testing.Fake\n}\n\n\n\n\n\nfunc (c *FakeIncidentsV1alpha1) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakeIncidentsV1alpha1) Acknowledgements(namespace string) v1alpha1.AcknowledgementInterface ", "output": "{\n\treturn &FakeAcknowledgements{c, namespace}\n}"}
{"input": "package gzip\n\nimport (\n\t\"net/http\"\n\t\"path\"\n\n\t\"github.com/mholt/caddy/middleware\"\n)\n\n\ntype Filter interface {\n\tShouldCompress(*http.Request) bool\n}\n\n\nvar defaultExtensions = []string{\"\", \".txt\", \".htm\", \".html\", \".css\", \".php\", \".js\", \".json\", \".md\", \".xml\"}\n\n\nfunc DefaultExtFilter() ExtFilter {\n\tm := ExtFilter{Exts: make(Set)}\n\tfor _, extension := range defaultExtensions {\n\t\tm.Exts.Add(extension)\n\t}\n\treturn m\n}\n\n\ntype ExtFilter struct {\n\tExts Set\n}\n\n\nconst ExtWildCard = \"*\"\n\n\n\n\nfunc (e ExtFilter) ShouldCompress(r *http.Request) bool {\n\text := path.Ext(r.URL.Path)\n\treturn e.Exts.Contains(ExtWildCard) || e.Exts.Contains(ext)\n}\n\n\ntype PathFilter struct {\n\tIgnoredPaths Set\n}\n\n\n\n\nfunc (p PathFilter) ShouldCompress(r *http.Request) bool {\n\treturn !p.IgnoredPaths.ContainsFunc(func(value string) bool {\n\t\treturn middleware.Path(r.URL.Path).Matches(value)\n\t})\n}\n\n\ntype Set map[string]struct{}\n\n\nfunc (s Set) Add(value string) {\n\ts[value] = struct{}{}\n}\n\n\n\n\n\nfunc (s Set) Contains(value string) bool {\n\t_, ok := s[value]\n\treturn ok\n}\n\n\n\n\nfunc (s Set) ContainsFunc(f func(string) bool) bool {\n\tfor k, _ := range s {\n\t\tif f(k) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s Set) Remove(value string) ", "output": "{\n\tdelete(s, value)\n}"}
{"input": "package validator\n\nimport (\n\t\"errors\"\n\t\"regexp\"\n\t\"time\"\n)\n\ntype Validator struct {\n\tValidatorHandler ValidatorHandler\n\tErrorMessage     string\n}\n\ntype ValidatorHandler func(value string) bool\n\nfunc New(validatorHandler ValidatorHandler, errorMessage string) *Validator {\n\n\tthis := new(Validator)\n\tthis.ValidatorHandler = validatorHandler\n\tthis.ErrorMessage = errorMessage\n\n\treturn this\n}\n\nfunc (this *Validator) IsValid(data string) error {\n\n\tif this.ValidatorHandler(data) {\n\n\t\treturn nil\n\t}\n\treturn errors.New(this.ErrorMessage)\n}\n\nfunc IsEqual(references ...string) ValidatorHandler {\n\n\treturn func(value string) bool {\n\n\t\tfor _, reference := range references {\n\n\t\t\tif reference == value {\n\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}\n\nfunc IsNotEmpty() ValidatorHandler {\n\n\treturn func(value string) bool {\n\n\t\tif len(value) > 0 {\n\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n}\n\n\n\nfunc IsEmail() ValidatorHandler {\n\n\treturn Regexp(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]+$`)\n}\n\nfunc IsNumber() ValidatorHandler {\n\n\treturn Regexp(`^(-|)[0-9]+$`)\n}\n\nfunc IsDate() ValidatorHandler {\n\n\treturn func(value string) bool {\n\n\t\t_, err := time.Parse(\"2006-01-02\", value)\n\t\tif err != nil {\n\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n}\n\nfunc Regexp(pattern string) ValidatorHandler ", "output": "{\n\n\treturn func(value string) bool {\n\n\t\tr, _ := regexp.Compile(pattern)\n\n\t\treturn r.MatchString(value)\n\t}\n}"}
{"input": "package iso20022\n\n\ntype CorporateActionEventReference4 struct {\n\n\tEventIdentification *CorporateActionEventReference4Choice `xml:\"EvtId\"`\n\n\tLinkageType *ProcessingPosition10Choice `xml:\"LkgTp,omitempty\"`\n}\n\nfunc (c *CorporateActionEventReference4) AddEventIdentification() *CorporateActionEventReference4Choice {\n\tc.EventIdentification = new(CorporateActionEventReference4Choice)\n\treturn c.EventIdentification\n}\n\n\n\nfunc (c *CorporateActionEventReference4) AddLinkageType() *ProcessingPosition10Choice ", "output": "{\n\tc.LinkageType = new(ProcessingPosition10Choice)\n\treturn c.LinkageType\n}"}
{"input": "package grpcservice\n\nimport \"google.golang.org/grpc\"\n\n\n\n\n\nfunc GetInstanceFromClient(grpcclient *GRPCClient) *grpc.ClientConn {\n\treturn grpcclient.connection\n}\n\nfunc GetInstanceFromServer(grpcserver *GRPCServer) *grpc.Server ", "output": "{\n\treturn grpcserver.server\n}"}
{"input": "package state\n\nimport (\n\t\"time\"\n\n\t\"github.com/juju/errors\"\n\t\"gopkg.in/juju/names.v2\"\n\n\t\"github.com/juju/juju/core/lease\"\n)\n\n\n\n\n\n\n\n\n\ntype singularSecretary struct {\n\tuuid string\n}\n\n\n\n\n\nfunc (s singularSecretary) CheckHolder(name string) error {\n\tif _, err := names.ParseMachineTag(name); err != nil {\n\t\treturn errors.New(\"expected machine tag\")\n\t}\n\treturn nil\n}\n\n\nfunc (s singularSecretary) CheckDuration(duration time.Duration) error {\n\tif duration <= 0 {\n\t\treturn errors.NewNotValid(nil, \"non-positive\")\n\t}\n\treturn nil\n}\n\n\n\nfunc (st *State) SingularClaimer() lease.Claimer {\n\treturn st.workers.singularManager()\n}\n\nfunc (s singularSecretary) CheckLease(name string) error ", "output": "{\n\tif name != s.uuid {\n\t\treturn errors.New(\"expected environ UUID\")\n\t}\n\treturn nil\n}"}
{"input": "package util\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"maunium.net/go/mauirc-server/interfaces\"\n)\n\nvar config interfaces.Configuration\n\n\nfunc Init(cfg interfaces.Configuration) {\n\tconfig = cfg\n}\n\n\n\n\nfunc GetIP(r *http.Request) string ", "output": "{\n\tif config.TrustHeaders() {\n\t\treturn r.Header.Get(\"X-Forwarded-For\")\n\t}\n\treturn strings.Split(r.RemoteAddr, \":\")[0]\n}"}
{"input": "package all\n\nimport (\n\t\"github.com/juju/collections/set\"\n\t\"github.com/juju/errors\"\n)\n\ntype component interface {\n\tregisterForServer() error\n\tregisterForClient() error\n}\n\nvar components = []component{\n\t&payloads{},\n\t&resources{},\n}\n\n\n\n\n\n\n\nfunc RegisterForClient() error {\n\tfor _, c := range components {\n\t\tif err := c.registerForClient(); err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t}\n\treturn nil\n}\n\n\nvar registered = map[string]set.Strings{}\n\n\n\n\n\nfunc markRegistered(component, part string) bool {\n\tparts, ok := registered[component]\n\tif !ok {\n\t\tparts = set.NewStrings()\n\t\tregistered[component] = parts\n\t}\n\tif parts.Contains(part) {\n\t\treturn false\n\t}\n\tparts.Add(part)\n\treturn true\n}\n\nfunc RegisterForServer() error ", "output": "{\n\tfor _, c := range components {\n\t\tif err := c.registerForServer(); err != nil {\n\t\t\treturn errors.Trace(err)\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package parser\n\nimport (\n\t\"testing\"\n\t\"fareastdominions.com/evepaste/eve/test\"\n\t\"fareastdominions.com/evepaste/eve/entity\"\n)\n\n\n\nfunc TestCargoScanParse(t *testing.T) ", "output": "{\n\ttestCases := []test.ParserTestCase{{\n\t\t`5000 Caldari Navy Mjolnir Rocket\n47720 Azure Plagioclase\n5 Navy Cap Booster 400`,\n\t\t[]entity.Item{\n\t\t\tentity.Item{\n\t\t\t\tTypeName: `Caldari Navy Mjolnir Rocket`,\n\t\t\t\tQuantity: 5000,\n\t\t\t},\n\t\t\tentity.Item{\n\t\t\t\tTypeName: `Azure Plagioclase`,\n\t\t\t\tQuantity: 47720,\n\t\t\t},\n\t\t\tentity.Item{\n\t\t\t\tTypeName: `Navy Cap Booster 400`,\n\t\t\t\tQuantity: 5,\n\t\t\t},\n\t\t},\n\t}}\n\n\tp := &CargoScanParser{}\n\tfor _, c := range testCases {\n\t\titems, err := p.Parse(c.GetLines())\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tc.Assert(t, items)\n\t}\n}"}
{"input": "package libgogo\n\n\n\n\n\nvar Argv [255]string;\nvar Argc uint64 = 0;\n\n\n\n\n\n\n\n\n\n\n\nfunc CopyMem(source uint64, dest uint64, size uint64);\n\n\n\n\n\nfunc Exit(code uint64);\n\n\n\n\nfunc ExitError(msg string, code uint64) {\n    PrintString(msg);\n    PrintChar(10); \n    Exit(code);\n}\n\nfunc GetArgv() ", "output": "{\n    var fd uint64;\n    var errno uint64;    \n    var singleChar byte;\n    var lastChar byte = 1; \n\n    fd = FileOpen(\"/proc/self/cmdline\", 0); \n    if fd == 0 { \n        ExitError(\"Error opening /proc/self/cmdline. Currently GoGo is only supported on systems with /proc enabled.\", 1);\n    }    \n\n    for singleChar = GetChar(fd);(singleChar != 0) || (lastChar != 0); singleChar = GetChar(fd) {\n        if (singleChar == 0) {\n            Argc = Argc +1;\n        } else {\n            CharAppend(&Argv[Argc], singleChar);\n        }\n        lastChar = singleChar;\n    }\n\n    errno = FileClose(fd);\n    if errno != 0 {\n        ExitError(\"Error closing file /proc/self/cmdline\",1);\n    }\n}"}
{"input": "package apimgr\n\nimport \"reflect\"\n\nfunc newSorter(manager *Manager) *sorter {\n\tapis := []Definition{}\n\tfor _, api := range manager.apiMethodPatternMap {\n\t\tapis = append(apis, api)\n\t}\n\treturn &sorter{\n\t\tManager: manager,\n\t\tapis:    apis,\n\t}\n}\n\ntype sorter struct {\n\t*Manager\n\n\tapis []Definition\n}\n\n\n\nfunc (t sorter) Swap(i int, j int) {\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\n}\n\nfunc (t sorter) Less(i int, j int) bool {\n\tki := t.getSortKey(t.apis[i])\n\tkj := t.getSortKey(t.apis[j])\n\treturn ki < kj\n}\n\nfunc (t sorter) getSortKey(api Definition) string {\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\n\treturn key\n}\n\nfunc (t sorter) Len() int ", "output": "{\n\treturn len(t.apis)\n}"}
{"input": "package main\n\nimport(\n\t\"fmt\"\n\t\"flag\"\n\t\"os\"\n)\n\nconst EMPTY = \"\"\n\ntype flagConfig struct {\n\tType, Handler, CertificateFile, KeyFile string\n\tMaxProcs, Threads, Port int\n\tNoSSL bool\n}\n\nfunc NewFlagConfig() *flagConfig {\n\treturn &flagConfig{}\n}\n\nfunc (flags *flagConfig) parse() {\n\tflag.StringVar(&flags.Type, \"type\", \"tcp\", \"Server type (tcp, xmppandroidpn, [dbus not implemented])\")\n\tflag.BoolVar(&flags.NoSSL, \"no-ssl\", false, \"disable SSL encryption\")\n\tflag.StringVar(&flags.Handler, \"handler\", \"notify\", \"Message Handler (notify, stdout)\")\n\tflag.IntVar(&flags.MaxProcs, \"maxprocs\", 5, \"set runtime.GOMAXPROCS\")\n\tflag.IntVar(&flags.Threads, \"threads\", 5, \"number of threads to run\")\n\tflag.StringVar(&flags.CertificateFile, \"cert\", \"cert.pem\", \"ssl certificate file\")\n\tflag.StringVar(&flags.KeyFile, \"key\", \"key.pem\", \"ssl key file\")\n\tflag.IntVar(&flags.Port, \"port\", 65222, \"port to use\")\n\n\n\tflag.Parse()\n\n\tif flags.MaxProcs < 1 {\n\t\tfmt.Println(\"maxprocs may not be smaller then 1!\")\n\t\tos.Exit(22)\n\t}\n\n\tif flags.Threads < 1 {\n\t\tfmt.Println(\"threads may not be smaller then 1!\")\n\t\tos.Exit(23)\n\t}\n}\n\n\n\nfunc (flags *flagConfig) usage() ", "output": "{\n\tflag.Usage()\n}"}
{"input": "package hash\n\nimport \"unsafe\"\n\nconst DJBInit uint32 = 5381\n\n\n\nfunc DJB(hs ...uint32) uint32 {\n\tacc := DJBInit\n\tfor _, h := range hs {\n\t\tacc = DJBCombine(acc, h)\n\t}\n\treturn acc\n}\n\nfunc UInt32(u uint32) uint32 {\n\treturn u\n}\n\nfunc UInt64(u uint64) uint32 {\n\treturn mul33(uint32(u>>32)) + uint32(u&0xffffffff)\n}\n\nfunc Pointer(p unsafe.Pointer) uint32 {\n\tswitch unsafe.Sizeof(p) {\n\tcase 4:\n\t\treturn UInt32(uint32(uintptr(p)))\n\tcase 8:\n\t\treturn UInt64(uint64(uintptr(p)))\n\tdefault:\n\t\tpanic(\"unhandled pointer size\")\n\t}\n}\n\nfunc UIntPtr(p uintptr) uint32 {\n\tswitch unsafe.Sizeof(p) {\n\tcase 4:\n\t\treturn UInt32(uint32(p))\n\tcase 8:\n\t\treturn UInt64(uint64(p))\n\tdefault:\n\t\tpanic(\"unhandled pointer size\")\n\t}\n}\n\nfunc String(s string) uint32 {\n\th := DJBInit\n\tfor i := 0; i < len(s); i++ {\n\t\th = DJBCombine(h, uint32(s[i]))\n\t}\n\treturn h\n}\n\nfunc mul33(u uint32) uint32 {\n\treturn u<<5 + u\n}\n\nfunc DJBCombine(acc, h uint32) uint32 ", "output": "{\n\treturn mul33(acc) + h\n}"}
{"input": "package ldapserver\n\ntype CompareRequest struct {\n\tentry LDAPDN\n\tava   AttributeValueAssertion\n}\n\nfunc (r *CompareRequest) GetEntry() LDAPDN {\n\treturn r.entry\n}\n\n\n\ntype CompareResponse struct {\n\tldapResult\n}\n\nfunc NewCompareResponse(resultCode int) *CompareResponse {\n\tr := &CompareResponse{}\n\tr.ResultCode = resultCode\n\treturn r\n}\n\nfunc (r *CompareRequest) GetAttributeValueAssertion() *AttributeValueAssertion ", "output": "{\n\treturn &r.ava\n}"}
{"input": "package ast\n\nimport \"github.com/orktes/orlang/scanner\"\n\ntype UnaryExpression struct {\n\tExpression\n\tOperator scanner.Token\n\tPostfix  bool\n}\n\n\n\nfunc (u *UnaryExpression) EndPos() Position {\n\tif u.Postfix {\n\t\treturn EndPositionFromToken(u.Operator)\n\t}\n\treturn u.Expression.EndPos()\n}\n\nfunc (_ *UnaryExpression) exprNode() {}\n\nfunc (u *UnaryExpression) StartPos() Position ", "output": "{\n\tif u.Postfix {\n\t\treturn u.Expression.StartPos()\n\t}\n\treturn StartPositionFromToken(u.Operator)\n}"}
{"input": "package google\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/hashicorp/terraform/helper/acctest\"\n\t\"github.com/hashicorp/terraform/helper/resource\"\n)\n\n\n\nfunc testAccResourceUsageExportBucket(baseProject, org, billingId string) string {\n\treturn fmt.Sprintf(`\nresource \"google_project\" \"base\" {\n\tproject_id      = \"%s\"\n\tname            = \"Export Bucket Base\"\n\torg_id          = \"%s\"\n\tbilling_account = \"%s\"\n}\n\nresource \"google_project_service\" \"service\" {\n\tproject = \"${google_project.base.project_id}\"\n\tservice = \"compute.googleapis.com\"\n}\n\nresource \"google_storage_bucket\" \"bucket\" {\n  name = \"b-${google_project.base.project_id}\"\n\tproject = \"${google_project_service.service.project}\"\n}\n\nresource \"google_project_usage_export_bucket\" \"ueb\" {\n  project = \"${google_project.base.project_id}\"\n  bucket_name = \"${google_storage_bucket.bucket.name}\"\n\tprefix = \"foobar\"\n}\n`, baseProject, org, billingId)\n}\n\nfunc TestAccComputeResourceUsageExportBucket(t *testing.T) ", "output": "{\n\torg := getTestOrgFromEnv(t)\n\tbillingId := getTestBillingAccountFromEnv(t)\n\n\tbaseProject := \"ub-\" + acctest.RandString(10)\n\n\tresource.Test(t, resource.TestCase{\n\t\tPreCheck:  func() { testAccPreCheck(t) },\n\t\tProviders: testAccProviders,\n\t\tSteps: []resource.TestStep{\n\t\t\tresource.TestStep{\n\t\t\t\tConfig: testAccResourceUsageExportBucket(baseProject, org, billingId),\n\t\t\t},\n\t\t\tresource.TestStep{\n\t\t\t\tResourceName:      \"google_project_usage_export_bucket.ueb\",\n\t\t\t\tImportState:       true,\n\t\t\t\tImportStateVerify: true,\n\t\t\t},\n\t\t},\n\t})\n}"}
{"input": "package wml\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"strconv\"\n)\n\ntype CT_Markup struct {\n\tIdAttr int64\n}\n\n\n\nfunc (m *CT_Markup) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tstart.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: \"w:id\"},\n\t\tValue: fmt.Sprintf(\"%v\", m.IdAttr)})\n\te.EncodeToken(start)\n\te.EncodeToken(xml.EndElement{Name: start.Name})\n\treturn nil\n}\n\nfunc (m *CT_Markup) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n\tfor _, attr := range start.Attr {\n\t\tif attr.Name.Local == \"id\" {\n\t\t\tparsed, err := strconv.ParseInt(attr.Value, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tm.IdAttr = parsed\n\t\t}\n\t}\n\tfor {\n\t\ttok, err := d.Token()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing CT_Markup: %s\", err)\n\t\t}\n\t\tif el, ok := tok.(xml.EndElement); ok && el.Name == start.Name {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (m *CT_Markup) Validate() error {\n\treturn m.ValidateWithPath(\"CT_Markup\")\n}\n\n\nfunc (m *CT_Markup) ValidateWithPath(path string) error {\n\treturn nil\n}\n\nfunc NewCT_Markup() *CT_Markup ", "output": "{\n\tret := &CT_Markup{}\n\treturn ret\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/takama/daemon\"\n)\n\n\ntype Service struct {\n\tdaemon.Daemon\n}\n\nfunc (service *Service) Start() (string, error) {\n\n\n\tgo URLScanner(results, control, urls)\n\treturn \"\", nil\n}\n\nfunc (service *Service) Stop() (string, error) {\n\n\tcontrol <- FULLSTOP\n\treturn \"\", nil\n}\n\nfunc (service *Service) Status() (string, error) {\n\treturn \"\", nil\n}\n\n\n\nfunc (service *Service) Update() (string, error) ", "output": "{\n\treturn \"\", nil\n}"}
{"input": "package libvmi\n\nimport (\n\tkvirtv1 \"kubevirt.io/client-go/api/v1\"\n)\n\n\nfunc WithInterface(iface kvirtv1.Interface) Option {\n\treturn func(vmi *kvirtv1.VirtualMachineInstance) {\n\t\tvmi.Spec.Domain.Devices.Interfaces = append(\n\t\t\tvmi.Spec.Domain.Devices.Interfaces, iface,\n\t\t)\n\t}\n}\n\n\nfunc WithNetwork(network *kvirtv1.Network) Option {\n\treturn func(vmi *kvirtv1.VirtualMachineInstance) {\n\t\tvmi.Spec.Networks = append(vmi.Spec.Networks, *network)\n\t}\n}\n\n\n\n\n\nfunc InterfaceDeviceWithBridgeBinding() kvirtv1.Interface {\n\treturn kvirtv1.Interface{\n\t\tName: \"default\",\n\t\tInterfaceBindingMethod: kvirtv1.InterfaceBindingMethod{\n\t\t\tBridge: &kvirtv1.InterfaceBridge{},\n\t\t},\n\t}\n}\n\n\nfunc InterfaceDeviceWithSRIOVBinding(name string) kvirtv1.Interface {\n\treturn kvirtv1.Interface{\n\t\tName: name,\n\t\tInterfaceBindingMethod: kvirtv1.InterfaceBindingMethod{\n\t\t\tSRIOV: &kvirtv1.InterfaceSRIOV{},\n\t\t},\n\t}\n}\n\n\nfunc InterfaceWithMac(iface *kvirtv1.Interface, macAddress string) *kvirtv1.Interface {\n\tiface.MacAddress = macAddress\n\treturn iface\n}\n\n\nfunc MultusNetwork(networkName string) *kvirtv1.Network {\n\treturn &kvirtv1.Network{\n\t\tName: networkName,\n\t\tNetworkSource: kvirtv1.NetworkSource{\n\t\t\tMultus: &kvirtv1.MultusNetwork{\n\t\t\t\tNetworkName: networkName,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc InterfaceDeviceWithMasqueradeBinding(ports ...kvirtv1.Port) kvirtv1.Interface ", "output": "{\n\treturn kvirtv1.Interface{\n\t\tName: \"default\",\n\t\tInterfaceBindingMethod: kvirtv1.InterfaceBindingMethod{\n\t\t\tMasquerade: &kvirtv1.InterfaceMasquerade{},\n\t\t},\n\t\tPorts: ports,\n\t}\n}"}
{"input": "package v1alpha1\n\nimport (\n\t\"fmt\"\n\n\t\"kubedb.dev/apimachinery/apis\"\n\t\"kubedb.dev/apimachinery/apis/catalog\"\n\t\"kubedb.dev/apimachinery/crds\"\n\n\t\"kmodules.xyz/client-go/apiextensions\"\n)\n\nfunc (_ RedisAutoscaler) CustomResourceDefinition() *apiextensions.CustomResourceDefinition {\n\treturn crds.MustCustomResourceDefinition(SchemeGroupVersion.WithResource(ResourcePluralRedisAutoscaler))\n}\n\nvar _ apis.ResourceInfo = &RedisAutoscaler{}\n\n\n\nfunc (r RedisAutoscaler) ResourceShortCode() string {\n\treturn ResourceCodeRedisAutoscaler\n}\n\nfunc (r RedisAutoscaler) ResourceKind() string {\n\treturn ResourceKindRedisAutoscaler\n}\n\nfunc (r RedisAutoscaler) ResourceSingular() string {\n\treturn ResourceSingularRedisAutoscaler\n}\n\nfunc (r RedisAutoscaler) ResourcePlural() string {\n\treturn ResourcePluralRedisAutoscaler\n}\n\nfunc (r RedisAutoscaler) ValidateSpecs() error {\n\treturn nil\n}\n\nfunc (r RedisAutoscaler) ResourceFQN() string ", "output": "{\n\treturn fmt.Sprintf(\"%s.%s\", ResourcePluralRedisAutoscaler, catalog.GroupName)\n}"}
{"input": "package logs\n\nconst (\n\tErrorLevel = iota\n\tWarnLevel\n\tInfoLevel\n\tDebugLevel\n)\n\ntype Level uint32\n\nfunc (l Level) EQ(lv Level) bool {\n\tif l == lv {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (l Level) LTE(lv Level) bool {\n\tif l <= lv {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (l Level) LT(lv Level) bool {\n\tif l < lv {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (l Level) GTE(lv Level) bool {\n\tif l >= lv {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (l Level) GT(lv Level) bool {\n\tif l > lv {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n\nfunc (l Level) String() string {\n\tswitch l {\n\tcase DebugLevel:\n\t\treturn \"DEBU\"\n\tcase InfoLevel:\n\t\treturn \"INFO\"\n\tcase WarnLevel:\n\t\treturn \"WARN\"\n\tcase ErrorLevel:\n\t\treturn \"ERRO\"\n\t}\n\treturn \"    \"\n}\n\nfunc (l Level) Color() int ", "output": "{\n\tvar levelColor int\n\tswitch l {\n\tcase DebugLevel:\n\t\tlevelColor = 32\n\tcase InfoLevel:\n\t\tlevelColor = 36\n\tcase WarnLevel:\n\t\tlevelColor = 33\n\tcase ErrorLevel:\n\t\tlevelColor = 31\n\tdefault:\n\t\tlevelColor = 0\n\t}\n\treturn levelColor\n}"}
{"input": "package call\n\nimport (\n\t\"crypto/md5\"\n\t\"encoding/json\"\n\t\"fmt\"\n\tM \"github.com/ionous/sashimi/compiler/model\"\n\tG \"github.com/ionous/sashimi/game\"\n\t\"github.com/ionous/sashimi/util/ident\"\n\t\"io\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n)\n\ntype Marker struct {\n\tM.CallbackModel\n}\n\nfunc MarkFileLine(file string, line int) Marker {\n\treturn Marker{M.CallbackModel{file, line, 0}}\n}\n\nfunc MakeMarker(cb G.Callback) Marker {\n\tv := reflect.ValueOf(cb)\n\tpc := v.Pointer()\n\tf := runtime.FuncForPC(pc)\n\treturn MarkFileLine(f.FileLine(pc - 1))\n}\n\nfunc (cfg Config) MakeMarker(cb G.Callback) Marker {\n\tm := MakeMarker(cb)\n\tif strings.HasPrefix(m.File, cfg.BasePath+\"/\") {\n\t\tm.File = m.File[len(cfg.BasePath)+1:]\n\t}\n\treturn m\n}\n\nfunc (cfg Config) MarkFileLine(file string, line int) Marker {\n\tm := MarkFileLine(file, line)\n\tif strings.HasPrefix(m.File, cfg.BasePath+\"/\") {\n\t\tm.File = m.File[len(cfg.BasePath)+1:]\n\t}\n\treturn m\n}\n\n\n\nfunc (m Marker) Encode() (ret ident.Id, err error) ", "output": "{\n\tif text, e := json.Marshal(m); e != nil {\n\t\terr = e\n\t} else {\n\t\thash := md5.New()\n\t\tio.WriteString(hash, string(text))\n\t\tb := hash.Sum(nil)\n\t\ts := fmt.Sprintf(\"~%x\", b)\n\t\tif len(s) > len(\"~e2c569be17396eca2a2e3c11578123ed\") {\n\t\t\tpanic(s)\n\t\t}\n\t\tret = ident.MakeId(s)\n\t}\n\treturn\n}"}
{"input": "package pipelineserver\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/concourse/atc/db\"\n)\n\n\n\nfunc (s *Server) PausePipeline(pipelineDB db.PipelineDB) http.Handler ", "output": "{\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\terr := pipelineDB.Pause()\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n}"}
{"input": "package agent\n\nimport (\n\t\"github.com/jteso/xchronos/task\"\n)\n\n\n\ntype handleStateFn func(*Agent) handleStateFn\n\nfunc startStateFn(agent *Agent) handleStateFn {\n\tagent.changeState(\"STARTING_STATE\")\n\tagent.connectEtcdCluster()\n\n\treturn candidateStateFn\n}\n\nfunc candidateStateFn(agent *Agent) handleStateFn {\n\tagent.changeState(\"CANDIDATE_STATE\")\n\tleader, err := agent.runForLeader()\n\n\tif err != nil {\n\t\tagent.lastError = err\n\t\treturn errorStateFn\n\t}\n\tif leader {\n\t\treturn leaderStateFn\n\t}\n\n\treturn supporterStateFn\n\n}\n\n\n\nfunc supporterStateFn(agent *Agent) handleStateFn {\n\tagent.changeState(\"SUPPORTER_STATE\")\n\n\texecutorTask := agent.advertiseAndRenewExecutorRoleT()\n\tjobExecutorTask := agent.watchForJobOffersT()\n\twatchNewLeaderTask := agent.watchForNewLeaderElectionT()\n\n\tfor {\n\t\tselect {\n\t\tcase err := <-task.FirstError(\n\t\t\tagent.listenUICancelTask(), \n\t\t\texecutorTask,\n\t\t\tjobExecutorTask):\n\n\t\t\tagent.lastError = err\n\t\t\treturn errorStateFn\n\t\tcase <-watchNewLeaderTask.ErrorChan():\n\t\t\treturn candidateStateFn\n\n\t\t}\n\t}\n}\n\nfunc errorStateFn(agent *Agent) handleStateFn {\n\tagent.changeState(\"RECOVERY_MODE_STATE\")\n\tagent.logf(\"Error: %s\", agent.lastError.Error())\n\tagent.stopTasks()\n\treturn nil\n}\n\nfunc leaderStateFn(agent *Agent) handleStateFn ", "output": "{\n\tagent.changeState(\"LEADER_STATE\")\n\n\tleaderTask := agent.advertiseAndRenewLeaderRoleT()\n\tjobPublisherTask := agent.publishJobOffersT()\n\n\texecutorTask := agent.advertiseAndRenewExecutorRoleT()\n\tjobExecutorTask := agent.watchForJobOffersT()\n\twatchNewLeaderTask := agent.watchForNewLeaderElectionT()\n\n\tfor {\n\t\tselect {\n\t\tcase err := <-task.FirstError(\n\t\t\tagent.listenUICancelTask(), \n\t\t\tleaderTask,\n\t\t\tjobPublisherTask,\n\t\t\texecutorTask,\n\t\t\tjobExecutorTask):\n\n\t\t\tagent.lastError = err\n\t\t\treturn errorStateFn\n\t\tcase <-watchNewLeaderTask.ErrorChan():\n\t\t\treturn candidateStateFn\n\t\t}\n\t}\n}"}
{"input": "package files\n\nimport (\n\tu \"github.com/araddon/gou\"\n\t\"github.com/lytics/cloudstorage\"\n\n\t\"github.com/araddon/qlbridge/datasource\"\n\t\"github.com/araddon/qlbridge/schema\"\n)\n\nvar (\n\t_ FileHandler = (*csvFiles)(nil)\n)\n\nfunc init() {\n\tRegisterFileHandler(\"csv\", &csvFiles{})\n}\n\n\ntype csvFiles struct {\n\tappendcols []string\n}\n\nfunc (m *csvFiles) Init(store FileStore, ss *schema.Schema) error { return nil }\nfunc (m *csvFiles) FileAppendColumns() []string                   { return m.appendcols }\n\nfunc (m *csvFiles) Scanner(store cloudstorage.StoreReader, fr *FileReader) (schema.ConnScanner, error) {\n\tcsv, err := datasource.NewCsvSource(fr.Table, 0, fr.F, fr.Exit)\n\tif err != nil {\n\t\tu.Errorf(\"Could not open file for csv reading %v\", err)\n\t\treturn nil, err\n\t}\n\treturn csv, nil\n}\n\nfunc (m *csvFiles) File(path string, obj cloudstorage.Object) *FileInfo ", "output": "{\n\treturn FileInfoFromCloudObject(path, obj)\n}"}
{"input": "package wwwweb\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n\n\nfunc Handler(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tfmt.Fprintf(w, \"Hi there, I love %s!\", r.URL.Path[1:])\n}"}
{"input": "package cabf_ev\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/zmap/zcrypto/x509\"\n\t\"github.com/zmap/zlint/v3/lint\"\n\t\"github.com/zmap/zlint/v3/util\"\n)\n\nconst (\n\tmaxOnionValidityMonths = 15\n)\n\ntype torValidityTooLarge struct{}\n\nfunc init() {\n\tlint.RegisterLint(&lint.Lint{\n\t\tName: \"e_onion_subject_validity_time_too_large\",\n\t\tDescription: fmt.Sprintf(\n\t\t\t\"certificates with .onion names can not be valid for more than %d months\",\n\t\t\tmaxOnionValidityMonths),\n\t\tCitation:      \"EVGs: Appendix F\",\n\t\tSource:        lint.CABFEVGuidelines,\n\t\tEffectiveDate: util.OnionOnlyEVDate,\n\t\tLint:          &torValidityTooLarge{},\n\t})\n}\n\n\nfunc (l *torValidityTooLarge) Initialize() error {\n\treturn nil\n}\n\n\n\nfunc (l *torValidityTooLarge) CheckApplies(c *x509.Certificate) bool {\n\treturn util.IsSubscriberCert(c) && util.CertificateSubjInTLD(c, util.OnionTLD)\n}\n\n\n\n\n\n\nfunc (l *torValidityTooLarge) Execute(c *x509.Certificate) *lint.LintResult ", "output": "{\n\tif c.NotBefore.AddDate(0, maxOnionValidityMonths, 0).Before(c.NotAfter) {\n\t\treturn &lint.LintResult{\n\t\t\tStatus: lint.Error,\n\t\t}\n\t}\n\treturn &lint.LintResult{Status: lint.Pass}\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/white-pony/go-fann\"\n\t\"os\"\n)\n\nvar data string\nvar output string\n\n\n\nfunc main() {\n\tconst numLayers = 32\n\tconst desiredError = 0.001\n\tconst maxEpochs = 3000\n\tconst epochsBetweenReports = 10\n\n\tfmt.Println(\"Creating network.\")\n\n\tneurons := []uint32{32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n\t\t32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32}\n\tfmt.Println(len(neurons))\n\tann := fann.CreateStandart(numLayers, neurons)\n\n\tfmt.Println(\"Training network.\")\n\tann.SetActivationFunctionHidden(fann.SIGMOID_SYMMETRIC)\n\tann.SetActivationFunctionOutput(fann.SIGMOID_SYMMETRIC)\n\n\tif _, err := os.Stat(data); os.IsNotExist(err) {\n\t\tprint(\"Training datafile does not exist.\")\n\t\tos.Exit(1)\n\t}\n\tann.TrainOnFile(data, maxEpochs, epochsBetweenReports, desiredError)\n\tann.Save(output)\n\tann.Destroy()\n\n\tfmt.Println(\"finished\")\n}\n\nfunc init() ", "output": "{\n\tflag.StringVar(&data, \"input\", \"data.train\",\n\t\t\"Filename of the training data\")\n\tflag.StringVar(&output, \"output\", \"sha256.net\",\n\t\t\"Filename of output file where the network is saved\")\n\tflag.Parse()\n}"}
{"input": "package config\n\nimport \"github.com/corestoreio/csfw/utils\"\n\n\n\ntype ScopePerm uint64\n\n\nvar ScopePermAll = ScopePerm(1<<ScopeDefaultID | 1<<ScopeWebsiteID | 1<<ScopeStoreID)\n\n\nfunc NewScopePerm(scopes ...ScopeGroup) ScopePerm {\n\tp := ScopePerm(0)\n\tp.Set(scopes...)\n\treturn p\n}\n\n\nfunc (bits *ScopePerm) All() ScopePerm {\n\tbits.Set(ScopeDefaultID, ScopeWebsiteID, ScopeStoreID)\n\treturn *bits\n}\n\n\nfunc (bits *ScopePerm) Set(scopes ...ScopeGroup) ScopePerm {\n\tfor _, i := range scopes {\n\t\t*bits = *bits | (1 << i) \n\t}\n\treturn *bits\n}\n\n\n\n\n\nfunc (bits ScopePerm) Human() utils.StringSlice {\n\tvar ret utils.StringSlice\n\tvar i uint\n\tfor i = 0; i < 64; i++ {\n\t\tbit := ((bits & (1 << i)) != 0)\n\t\tif bit {\n\t\t\tret.Append(ScopeGroup(i).String())\n\t\t}\n\t}\n\treturn ret\n}\n\n\nfunc (bits ScopePerm) MarshalJSON() ([]byte, error) {\n\tif bits == 0 {\n\t\treturn []byte(\"null\"), nil\n\t}\n\treturn []byte(`[\"` + bits.Human().Join(`\",\"`) + `\"]`), nil\n}\n\nfunc (bits ScopePerm) Has(s ScopeGroup) bool ", "output": "{\n\tvar one ScopeGroup = 1 \n\treturn (bits & ScopePerm(one<<s)) != 0\n}"}
{"input": "package id\n\n\ntype Generator struct {\n\tout chan ID\n}\n\n\n\n\n\nfunc (g *Generator) GetID() ID {\n\treturn <-g.out\n}\n\nfunc NewGenerator() *Generator ", "output": "{\n\tgen := &Generator{\n\t\tout: make(chan ID),\n\t}\n\n\tgo func() {\n\t\tcurrentID := ID(0)\n\n\t\tfor {\n\t\t\tgen.out <- currentID\n\t\t\tcurrentID++\n\t\t}\n\t}()\n\n\treturn gen\n}"}
{"input": "package matchers_test\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/blevesearch/bleve\"\n\t\"github.com/blevesearch/bleve/search/query\"\n\t\"github.com/nrwiersma/isenzo/matchers\"\n)\n\n\n\ntype waitMatcherFactory struct {}\n\nfunc newWaitMatcherFactory() matchers.Factory {\n\treturn &waitMatcherFactory{}\n}\n\nfunc (f waitMatcherFactory) New(doc interface{}) (matchers.Matcher, error) {\n\treturn &waitMatcher{\n\t\tids: make([]string, 0),\n\t}, nil\n}\n\nfunc (f waitMatcherFactory) Map(doc interface{}) (interface{}, error) {\n\treturn doc, nil\n}\n\ntype waitMatcher struct {\n\tids []string\n}\n\n\nfunc (m *waitMatcher) Match(id string, q query.Query) {\n\ttime.Sleep(10 * time.Millisecond)\n\n\tm.ids = append(m.ids, id)\n}\n\n\nfunc (m *waitMatcher) Finish() (ids []string, errs []error) {\n\treturn m.ids, []error{}\n}\n\nfunc TestParallelMatcher(t *testing.T) ", "output": "{\n\tf :=  matchers.NewParallelMatcherFactory(newWaitMatcherFactory(), 10)\n\tm, err := f.New(map[string]interface{}{})\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err; got %v\", err)\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\tm.Match(\"\", bleve.NewMatchAllQuery())\n\t}\n\n\tids, errs := m.Finish()\n\tif len(errs) != 0 {\n\t\tt.Fatalf(\"expected no errors; got %v\", errs)\n\t}\n\n\tif len(ids) != 10 {\n\t\tt.Fatalf(\"expected %d results; got %v\", 10, len(ids))\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/aodin/aspect\"\n\t_ \"github.com/aodin/aspect/postgres\"\n\t\"github.com/aodin/denver/grocery\"\n\t\"github.com/aodin/volta/config\"\n)\n\n\n\n\nfunc LoadFile(db *aspect.DB, path string) error {\n\tstores, err := grocery.ParseConvertedStoresCSV(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tstmt := grocery.Stores.Insert(stores)\n\t_, err = db.Execute(stmt)\n\treturn err\n}\n\nfunc main() {\n\tvar init bool\n\tvar load string\n\tflag.BoolVar(&init, \"init\", false, \"print SQL for CREATE TABLE\")\n\tflag.StringVar(&load, \"load\", \"\", \"load the given file\")\n\tflag.Parse()\n\n\tc, err := config.ParseFile(\"../../settings.json\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif init {\n\t\tInitSQL()\n\t}\n\n\tif load != \"\" {\n\t\tdb, err := aspect.Connect(\n\t\t\tc.Database.Driver,\n\t\t\tc.Database.Credentials(),\n\t\t)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif err = LoadFile(db, load); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc InitSQL() ", "output": "{\n\tfmt.Println(grocery.Stores.Create())\n}"}
{"input": "package iso20022\n\n\ntype AmountAndDirection48 struct {\n\n\tAmount *ActiveCurrencyAndAmount `xml:\"Amt\"`\n\n\tCreditDebitIndicator *CreditDebitCode `xml:\"CdtDbtInd\"`\n\n\tOriginalCurrencyAndOrderedAmount *ActiveOrHistoricCurrencyAndAmount `xml:\"OrgnlCcyAndOrdrdAmt,omitempty\"`\n\n\tForeignExchangeDetails *ForeignExchangeTerms23 `xml:\"FXDtls,omitempty\"`\n\n\tValueDate *DateAndDateTimeChoice `xml:\"ValDt,omitempty\"`\n}\n\nfunc (a *AmountAndDirection48) SetAmount(value, currency string) {\n\ta.Amount = NewActiveCurrencyAndAmount(value, currency)\n}\n\nfunc (a *AmountAndDirection48) SetCreditDebitIndicator(value string) {\n\ta.CreditDebitIndicator = (*CreditDebitCode)(&value)\n}\n\nfunc (a *AmountAndDirection48) SetOriginalCurrencyAndOrderedAmount(value, currency string) {\n\ta.OriginalCurrencyAndOrderedAmount = NewActiveOrHistoricCurrencyAndAmount(value, currency)\n}\n\nfunc (a *AmountAndDirection48) AddForeignExchangeDetails() *ForeignExchangeTerms23 {\n\ta.ForeignExchangeDetails = new(ForeignExchangeTerms23)\n\treturn a.ForeignExchangeDetails\n}\n\n\n\nfunc (a *AmountAndDirection48) AddValueDate() *DateAndDateTimeChoice ", "output": "{\n\ta.ValueDate = new(DateAndDateTimeChoice)\n\treturn a.ValueDate\n}"}
{"input": "package isolation\n\n\ntype Decorator interface {\n\tDecorate(string) string\n}\n\n\ntype Decorators []Decorator\n\n\n\n\n\nfunc (d Decorators) Decorate(command string) string ", "output": "{\n\tfor _, decorator := range d {\n\t\tcommand = decorator.Decorate(command)\n\t}\n\treturn command\n}"}
{"input": "package util\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n)\n\n\n\nfunc LogAsJson(object interface{}) ", "output": "{\n\ttest, _ := json.Marshal(object)\n\tlog.Printf(string(test))\n}"}
{"input": "package message\n\nimport \"fmt\"\n\n\n\n\n\n\nfunc (l LDAPOID) String() string {\n\treturn string(l)\n}\n\nfunc (l LDAPOID) Bytes() []byte {\n\treturn []byte(l)\n}\n\nfunc (l LDAPOID) Pointer() *LDAPOID { return &l }\n\nfunc readTaggedLDAPOID(bytes *Bytes, class int, tag int) (ret LDAPOID, err error) {\n\tvar octetstring OCTETSTRING\n\toctetstring, err = readTaggedOCTETSTRING(bytes, class, tag)\n\tif err != nil {\n\t\terr = LdapError{fmt.Sprintf(\"readTaggedLDAPOID:\\n%s\", err.Error())}\n\t\treturn\n\t}\n\tret = LDAPOID(octetstring)\n\treturn\n}\n\nfunc readLDAPOID(bytes *Bytes) (ret LDAPOID, err error) {\n\treturn readTaggedLDAPOID(bytes, classUniversal, tagOctetString)\n}\n\n\n\nfunc (l LDAPOID) writeTagged(bytes *Bytes, class int, tag int) int {\n\treturn OCTETSTRING(l).writeTagged(bytes, class, tag)\n}\n\nfunc (l LDAPOID) size() int {\n\treturn OCTETSTRING(l).size()\n}\n\nfunc (l LDAPOID) sizeTagged(tag int) int {\n\treturn OCTETSTRING(l).sizeTagged(tag)\n}\n\nfunc (l LDAPOID) write(bytes *Bytes) int ", "output": "{\n\treturn OCTETSTRING(l).write(bytes)\n}"}
{"input": "package actions\n\n\n\n\nimport (\n\t\"net/http\"\n\n\tmiddleware \"github.com/go-openapi/runtime/middleware\"\n\n\tmodels \"github.com/semi-technologies/weaviate/entities/models\"\n)\n\n\ntype ActionsDeleteHandlerFunc func(ActionsDeleteParams, *models.Principal) middleware.Responder\n\n\nfunc (fn ActionsDeleteHandlerFunc) Handle(params ActionsDeleteParams, principal *models.Principal) middleware.Responder {\n\treturn fn(params, principal)\n}\n\n\ntype ActionsDeleteHandler interface {\n\tHandle(ActionsDeleteParams, *models.Principal) middleware.Responder\n}\n\n\nfunc NewActionsDelete(ctx *middleware.Context, handler ActionsDeleteHandler) *ActionsDelete {\n\treturn &ActionsDelete{Context: ctx, Handler: handler}\n}\n\n\ntype ActionsDelete struct {\n\tContext *middleware.Context\n\tHandler ActionsDeleteHandler\n}\n\n\n\nfunc (o *ActionsDelete) ServeHTTP(rw http.ResponseWriter, r *http.Request) ", "output": "{\n\troute, rCtx, _ := o.Context.RouteInfo(r)\n\tif rCtx != nil {\n\t\tr = rCtx\n\t}\n\tvar Params = NewActionsDeleteParams()\n\n\tuprinc, aCtx, err := o.Context.Authorize(r, route)\n\tif err != nil {\n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\tif aCtx != nil {\n\t\tr = aCtx\n\t}\n\tvar principal *models.Principal\n\tif uprinc != nil {\n\t\tprincipal = uprinc.(*models.Principal) \n\t}\n\n\tif err := o.Context.BindValidRequest(r, route, &Params); err != nil { \n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\n\tres := o.Handler.Handle(Params, principal) \n\n\to.Context.Respond(rw, r, route.Produces, route, res)\n\n}"}
{"input": "package file\n\nimport (\n\t\"encoding/gob\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/landjur/golibrary/caching\"\n)\n\ntype dependency struct {\n\tpath             string\n\tlastModifiedTime time.Time\n}\n\nfunc (d *dependency) HasChanged() bool {\n\tfi, err := os.Stat(d.path)\n\tif err != nil {\n\t\treturn true\n\t}\n\n\treturn fi.ModTime().After(d.lastModifiedTime)\n}\n\n\nfunc NewDependency(path string) caching.Dependency {\n\tvar lastModifiedTime time.Time\n\tfi, err := os.Stat(path)\n\tif err != nil {\n\t\tlastModifiedTime = time.Now()\n\t} else {\n\t\tlastModifiedTime = fi.ModTime()\n\t}\n\n\treturn &dependency{\n\t\tpath:             path,\n\t\tlastModifiedTime: lastModifiedTime,\n\t}\n}\n\n\n\n\nfunc init() ", "output": "{\n\tgob.Register(dependency{})\n}"}
{"input": "package api\n\nimport (\n\t\"github.com/golang/glog\"\n\t\"github.com/nais/naisd/api/app\"\n\t\"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\tk8smeta \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/client-go/kubernetes\"\n)\n\ntype ServiceAccountInterface interface {\n\tCreateServiceAccountIfNotExist(spec app.Spec) (*v1.ServiceAccount, error)\n\tDeleteServiceAccount(spec app.Spec) error\n}\n\n\n\nfunc (c clientHolder) DeleteServiceAccount(spec app.Spec) error {\n\tserviceAccountInterface := c.client.CoreV1().ServiceAccounts(spec.Namespace)\n\n\tif e := serviceAccountInterface.Delete(spec.ResourceName(), &k8smeta.DeleteOptions{}); e != nil && !errors.IsNotFound(e) {\n\t\treturn e\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc (c clientHolder) CreateServiceAccountIfNotExist(spec app.Spec) (*v1.ServiceAccount, error) {\n\tserviceAccountInterface := c.client.CoreV1().ServiceAccounts(spec.Namespace)\n\n\tif account, err := serviceAccountInterface.Get(spec.ResourceName(), k8smeta.GetOptions{}); err == nil {\n\t\tglog.Infof(\"Skipping service account creation. All ready exist for application: %s in namespace: %s\", spec.ResourceName(), spec.Namespace)\n\t\treturn account, nil\n\t}\n\n\treturn serviceAccountInterface.Create(createServiceAccountDef(spec))\n}\n\nfunc createServiceAccountDef(spec app.Spec) *v1.ServiceAccount {\n\treturn &v1.ServiceAccount{\n\t\tTypeMeta: k8smeta.TypeMeta{\n\t\t\tKind:       \"ServiceAccount\",\n\t\t\tAPIVersion: \"v1\",\n\t\t},\n\t\tObjectMeta: generateObjectMeta(spec),\n\t}\n}\n\nfunc NewServiceAccountInterface(client kubernetes.Interface) ServiceAccountInterface ", "output": "{\n\treturn clientHolder{\n\t\tclient: client,\n\t}\n}"}
{"input": "package aggregator\n\nimport . \"gopkg.in/check.v1\"\n\n\n\nfunc (s *TimeAggregatorSuite) TestPeriodToMap(c *C) {\n\tp := Period(1201511003)\n\tm, err := p.Map()\n\tc.Assert(err, IsNil)\n\n\tc.Assert(m, DeepEquals, map[string]uint64{\"year\": 2015, \"month\": 11})\n\n\tp = Period(12015316017)\n\tm, err = p.Map()\n\tc.Assert(err, IsNil)\n\tc.Assert(m, DeepEquals, map[string]uint64{\"year\": 2015, \"yearday\": 316})\n}\n\nfunc (s *TimeAggregatorSuite) TestPeriodString(c *C) {\n\tp := Period(1201511003)\n\tc.Assert(p.String(), Equals, \"Year: 2015 / Month: 11\")\n}\n\nfunc (s *TimeAggregatorSuite) TestNewPeriod(c *C) ", "output": "{\n\tp := newPeriod(Year|Month, date2015November)\n\tc.Assert(p, Equals, Period(1201511003))\n\n\tp = newPeriod(Year|YearDay, date2015November)\n\tc.Assert(p, Equals, Period(12015316017))\n}"}
{"input": "package distsql\n\nimport (\n\t\"errors\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/pingcap/check\"\n\t\"github.com/pingcap/tidb/model\"\n\t\"github.com/pingcap/tidb/mysql\"\n\t\"github.com/pingcap/tidb/util/testleak\"\n\t\"github.com/pingcap/tidb/util/types\"\n\t\"github.com/pingcap/tipb/go-tipb\"\n\tgoctx \"golang.org/x/net/context\"\n)\n\nfunc TestT(t *testing.T) {\n\tCustomVerboseFlag = true\n\tTestingT(t)\n}\n\nvar _ = Suite(&testTableCodecSuite{})\n\ntype testTableCodecSuite struct{}\n\n\nfunc (s *testTableCodecSuite) TestColumnToProto(c *C) {\n\tdefer testleak.AfterTest(c)()\n\ttp := types.NewFieldType(mysql.TypeLong)\n\ttp.Flag = 10\n\tcol := &model.ColumnInfo{\n\t\tFieldType: *tp,\n\t}\n\tpc := columnToProto(col)\n\tc.Assert(pc.GetFlag(), Equals, int32(10))\n}\n\n\n\n\ntype mockResponse struct {\n\tcount int\n}\n\nfunc (resp *mockResponse) Next() ([]byte, error) {\n\tresp.count++\n\tif resp.count == 100 {\n\t\treturn nil, errors.New(\"error happend\")\n\t}\n\treturn mockSubresult(), nil\n}\n\nfunc (resp *mockResponse) Close() error {\n\treturn nil\n}\n\nfunc mockSubresult() []byte {\n\tresp := new(tipb.SelectResponse)\n\tb, err := resp.Marshal()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn b\n}\n\nfunc (s *testTableCodecSuite) TestGoroutineLeak(c *C) ", "output": "{\n\tvar sr SelectResult\n\tcountBefore := runtime.NumGoroutine()\n\n\tsr = &selectResult{\n\t\tresp:    &mockResponse{},\n\t\tresults: make(chan resultWithErr, 5),\n\t\tclosed:  make(chan struct{}),\n\t}\n\tgo sr.Fetch(goctx.TODO())\n\tfor {\n\t\t_, err := sr.Next()\n\t\tif err != nil {\n\t\t\tsr.Close()\n\t\t\tbreak\n\t\t}\n\t}\n\n\ttick := 10 * time.Millisecond\n\ttotalSleep := time.Duration(0)\n\tfor totalSleep < 3*time.Second {\n\t\ttime.Sleep(tick)\n\t\ttotalSleep += tick\n\t\tcountAfter := runtime.NumGoroutine()\n\n\t\tif countAfter-countBefore < 5 {\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.Error(\"distsql goroutine leak!\")\n}"}
{"input": "package main\n\n\n\n\n\ntype I interface {\n\tone() int\n\ttwo() string\n}\n\ntype S struct {\n\tI\n}\n\ntype impl struct{}\n\nfunc (impl) one() int {\n\treturn 1\n}\n\n\n\nfunc main() {\n\tvar s S\n\ts.I = impl{}\n\tif one := s.I.one(); one != 1 {\n\t\tpanic(one)\n\t}\n\tif one := s.one(); one != 1 {\n\t\tpanic(one)\n\t}\n\tclosOne := s.I.one\n\tif one := closOne(); one != 1 {\n\t\tpanic(one)\n\t}\n\tclosOne = s.one\n\tif one := closOne(); one != 1 {\n\t\tpanic(one)\n\t}\n\n\tif two := s.I.two(); two != \"two\" {\n\t\tpanic(two)\n\t}\n\tif two := s.two(); two != \"two\" {\n\t\tpanic(two)\n\t}\n\tclosTwo := s.I.two\n\tif two := closTwo(); two != \"two\" {\n\t\tpanic(two)\n\t}\n\tclosTwo = s.two\n\tif two := closTwo(); two != \"two\" {\n\t\tpanic(two)\n\t}\n}\n\nfunc (impl) two() string ", "output": "{\n\treturn \"two\"\n}"}
{"input": "package main\n\nimport \"fmt\"\n\ntype Player interface {\n  MyName()\n  TheirName()\n}\ntype FirstPerson interface {\n  MyName()\n}\ntype ThirdPerson interface {\n  TheirName()\n}\n\ntype Man struct {}\n\nfunc (man Man) TheirName() {\n  fmt.Println(\"What's his name?\")\n}\n\ntype Woman struct {}\nfunc (woman Woman) MyName() {\n  fmt.Println(\"What's your name Lady?\")\n}\nfunc (woman Woman) TheirName() {\n  fmt.Println(\"What's her name?\")\n}\n\ntype Human struct {\n  HumanPlayer Player\n  Name string\n}\nfunc (human *Human) ConfigPlayer(mode Player) {\n  human.HumanPlayer = mode\n}\n\nfunc main(){\n  player00 := Human{HumanPlayer: new(Man)}\n  player01 := Human{HumanPlayer: new(Woman)}\n\n  player00.HumanPlayer.MyName()\n  fmt.Scanf(\"%s\", &player00.Name)\n\n  player01.HumanPlayer.TheirName()\n  fmt.Scanf(\"%s\", &player01.Name)\n\n  fmt.Printf(\"MortalKombat: %s vs. %s\\n\", player00.Name, player01.Name)\n}\n\nfunc (man Man) MyName() ", "output": "{\n  fmt.Println(\"What's your name dude?\")\n}"}
{"input": "package openshift\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"syscall\"\n\n\t\"github.com/golang/glog\"\n\n\t\"github.com/openshift/origin/pkg/bootstrap/docker/errors\"\n)\n\nfunc CheckSocat() error {\n\t_, err := exec.LookPath(\"socat\")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc KillExistingSocat() error {\n\t_, err := os.Stat(SocatPidFile)\n\tif os.IsNotExist(err) {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tpidStr, err := ioutil.ReadFile(SocatPidFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer os.Remove(SocatPidFile)\n\tpid, err := strconv.Atoi(string(pidStr))\n\tif err != nil {\n\t\treturn err\n\t}\n\tprocess, err := os.FindProcess(pid)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn process.Kill()\n}\n\nfunc SaveSocatPid(pid int) error {\n\tparentDir := filepath.Dir(SocatPidFile)\n\terr := os.MkdirAll(parentDir, 0755)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ioutil.WriteFile(SocatPidFile, []byte(strconv.Itoa(pid)), 0644)\n}\n\n\n\nfunc (h *Helper) startSocatTunnel() error ", "output": "{\n\terr := KillExistingSocat()\n\tif err != nil {\n\t\tglog.V(1).Infof(\"error: cannot kill socat: %v\", err)\n\t}\n\tcmd := exec.Command(\"socat\", \"TCP-L:8443,reuseaddr,fork,backlog=20\", \"SYSTEM:\\\"docker exec -i origin socat - TCP\\\\:localhost\\\\:8443,nodelay\\\"\")\n\tcmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}\n\terr = cmd.Start()\n\tif err != nil {\n\t\treturn errors.NewError(\"cannot start socat tunnel\").WithCause(err)\n\t}\n\tglog.V(1).Infof(\"Started socat with pid: %d\", cmd.Process.Pid)\n\treturn SaveSocatPid(cmd.Process.Pid)\n}"}
{"input": "package scs\n\nimport (\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tsetStored        = \"STORED\"\n\tStatCmdSet       = \"cmd_set\"\n\tStatCmdSetHits   = \"set_hits\"\n\tStatCmdSetMisses = \"set_misses\"\n\tkeyLimit         = 249\n\tvalueLimit       = 8*1024 - 1 \n)\n\n\nfunc Set(s *Store, r io.Reader, w io.Writer, args string) {\n\terr := ValidateBytes(args, validArgBytes)\n\tif err != nil {\n\t\tWriteError(w, InvalidChars{err, \"in set arguments\"})\n\t\treturn\n\t}\n\tif len(args) > keyLimit {\n\t\tWriteError(w, ExceededKeyLengthLimit(len(args)))\n\t\treturn\n\t}\n\tdata, err := ReadToDelim(r, []byte(commandDelim))\n\tif err != nil {\n\t\ts.logFunc(err)\n\t\tWriteError(w, err)\n\t}\n\tdata = strings.TrimSuffix(data, commandDelim)\n\tif len(data) > valueLimit {\n\t\tWriteError(w, ExceededValueLengthLimit(len(data)))\n\t\treturn\n\t}\n\terr = s.Set(args, data)\n\tif err != nil {\n\t\tWriteError(w, err)\n\t\ts.SetStat(StatCmdSetMisses, Increment)\n\t} else {\n\t\tw.Write([]byte(setStored + commandDelim))\n\t\ts.SetStat(StatCmdSetHits, Increment)\n\t}\n\ts.SetStat(StatCmdSet, Increment)\n}\n\n\n\ntype ExceededKeyLengthLimit int\n\n\n\ntype ExceededValueLengthLimit int\n\nfunc (e ExceededValueLengthLimit) Error() string {\n\treturn \"value length (\" + strconv.Itoa(int(e)) + \") exceeded maxiumum allowed (\" + strconv.Itoa(valueLimit) + \")\"\n}\n\nfunc (e ExceededKeyLengthLimit) Error() string ", "output": "{\n\treturn \"key length (\" + strconv.Itoa(int(e)) + \") exceeded maxiumum allowed (\" + strconv.Itoa(keyLimit) + \")\"\n}"}
{"input": "package command\n\nimport (\n\t\"fmt\"\n\t\"koding/kites/kloud/stack\"\n\n\t\"github.com/mitchellh/cli\"\n)\n\ntype Build struct {\n\tid         *string\n\tsnapshotId *string\n\tprovider   *string\n}\n\n\n\nfunc (b *Build) Action(args []string) error {\n\tk, err := kloudClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tDefaultUi.Info(fmt.Sprintf(\"Build called for machine '%s'\\n\", *b.id))\n\n\tresp, err := k.Tell(\"build\", &KloudArgs{\n\t\tMachineId:  *b.id,\n\t\tSnapshotId: *b.snapshotId,\n\t\tProvider:   *b.provider,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar result stack.ControlResult\n\terr = resp.Unmarshal(&result)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tDefaultUi.Info(fmt.Sprintf(\"%+v\", result))\n\n\tif flagWatchEvents {\n\t\treturn watch(k, \"build\", *b.id, defaultPollInterval)\n\t}\n\n\treturn nil\n}\n\nfunc NewBuild() cli.CommandFactory ", "output": "{\n\treturn func() (cli.Command, error) {\n\t\tf := NewFlag(\"build\", \"Build a machine\")\n\t\tf.action = &Build{\n\t\t\tid:         f.String(\"id\", \"\", \"Machine Id belonging to the Build\"),\n\t\t\tsnapshotId: f.String(\"snapshot\", \"\", \"Build the machine from this snapshot\"),\n\t\t\tprovider:   f.String(\"provider\", \"koding\", \"Kloud provider.\"),\n\t\t}\n\t\treturn f, nil\n\t}\n}"}
{"input": "package tfexec\n\nimport (\n\t\"context\"\n\t\"os/exec\"\n\n\ttfjson \"github.com/hashicorp/terraform-json\"\n)\n\n\n\n\nfunc (tf *Terraform) providersSchemaCmd(ctx context.Context, args ...string) *exec.Cmd {\n\tallArgs := []string{\"providers\", \"schema\", \"-json\", \"-no-color\"}\n\tallArgs = append(allArgs, args...)\n\n\treturn tf.buildTerraformCmd(ctx, nil, allArgs...)\n}\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) ", "output": "{\n\tschemaCmd := tf.providersSchemaCmd(ctx)\n\n\tvar ret tfjson.ProviderSchemas\n\terr := tf.runTerraformCmdJSON(schemaCmd, &ret)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = ret.Validate()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ret, nil\n}"}
{"input": "package cmd\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/spf13/cobra\"\n\n\t\"k8s.io/kubernetes/pkg/kubectl\"\n\tcmdutil \"k8s.io/kubernetes/pkg/kubectl/cmd/util\"\n)\n\nconst (\n\tserviceAccountLong = `\nCreate a service account with the specified name.`\n\n\tserviceAccountExample = `  # Create a new service account named my-service-account\n  $ kubectl create serviceaccount my-service-account`\n)\n\n\n\n\n\nfunc CreateServiceAccount(f *cmdutil.Factory, cmdOut io.Writer, cmd *cobra.Command, args []string) error {\n\tname, err := NameFromCommandArgs(cmd, args)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar generator kubectl.StructuredGenerator\n\tswitch generatorName := cmdutil.GetFlagString(cmd, \"generator\"); generatorName {\n\tcase cmdutil.ServiceAccountV1GeneratorName:\n\t\tgenerator = &kubectl.ServiceAccountGeneratorV1{Name: name}\n\tdefault:\n\t\treturn cmdutil.UsageError(cmd, fmt.Sprintf(\"Generator: %s not supported.\", generatorName))\n\t}\n\treturn RunCreateSubcommand(f, cmd, cmdOut, &CreateSubcommandOptions{\n\t\tName:                name,\n\t\tStructuredGenerator: generator,\n\t\tDryRun:              cmdutil.GetFlagBool(cmd, \"dry-run\"),\n\t\tOutputFormat:        cmdutil.GetFlagString(cmd, \"output\"),\n\t})\n}\n\nfunc NewCmdCreateServiceAccount(f *cmdutil.Factory, cmdOut io.Writer) *cobra.Command ", "output": "{\n\tcmd := &cobra.Command{\n\t\tUse:     \"serviceaccount NAME [--dry-run]\",\n\t\tAliases: []string{\"sa\"},\n\t\tShort:   \"Create a service account with the specified name.\",\n\t\tLong:    serviceAccountLong,\n\t\tExample: serviceAccountExample,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\terr := CreateServiceAccount(f, cmdOut, cmd, args)\n\t\t\tcmdutil.CheckErr(err)\n\t\t},\n\t}\n\tcmdutil.AddApplyAnnotationFlags(cmd)\n\tcmdutil.AddValidateFlags(cmd)\n\tcmdutil.AddGeneratorFlags(cmd, cmdutil.ServiceAccountV1GeneratorName)\n\treturn cmd\n}"}
{"input": "package tris\n\nimport (\n\t\"fmt\"\n)\n\ntype ClientConnection struct {\n\tId           []byte\n\tMsg          []byte\n\tActiveDb     *Database\n\tShowExecTime bool\n}\n\n\n\nfunc NewClientConnection(s *Server, id []byte) *ClientConnection {\n\treturn &ClientConnection{\n\t\tId:           id,\n\t\tActiveDb:     s.Databases[DEFAULT_DB],\n\t\tShowExecTime: false,\n\t}\n}\n\nfunc (c *ClientConnection) String() string ", "output": "{\n\treturn fmt.Sprintf(\"Client ID: %v\\nActive Db: %v\\n\", c.Id, c.ActiveDb.Name)\n}"}
{"input": "package core\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/oci/oci-go-sdk/v43/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype RemoveNetworkSecurityGroupSecurityRulesRequest struct {\n\n\tNetworkSecurityGroupId *string `mandatory:\"true\" contributesTo:\"path\" name:\"networkSecurityGroupId\"`\n\n\tRemoveNetworkSecurityGroupSecurityRulesDetails `contributesTo:\"body\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request RemoveNetworkSecurityGroupSecurityRulesRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request RemoveNetworkSecurityGroupSecurityRulesRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request RemoveNetworkSecurityGroupSecurityRulesRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request RemoveNetworkSecurityGroupSecurityRulesRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype RemoveNetworkSecurityGroupSecurityRulesResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\n\n\n\nfunc (response RemoveNetworkSecurityGroupSecurityRulesResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response RemoveNetworkSecurityGroupSecurityRulesResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package expression\n\nimport (\n\t\"strings\"\n\n\t\"github.com/juju/errors\"\n\t\"github.com/pingcap/tidb/context\"\n\n\t\"github.com/pingcap/tidb/sessionctx/variable\"\n)\n\nvar (\n\t_ Expression = (*Variable)(nil)\n)\n\n\ntype Variable struct {\n\tName string\n\tIsGlobal bool\n\tIsSystem bool\n}\n\n\n\n\n\nfunc (v *Variable) IsStatic() bool {\n\treturn false\n}\n\n\nfunc (v *Variable) String() string {\n\tif !v.IsSystem {\n\t\treturn \"@\" + v.Name\n\t}\n\tif v.IsGlobal {\n\t\treturn \"@@GLOBAL.\" + v.Name\n\t}\n\treturn \"@@\" + v.Name\n}\n\n\nfunc (v *Variable) Eval(ctx context.Context, args map[interface{}]interface{}) (interface{}, error) {\n\tname := strings.ToLower(v.Name)\n\tsessionVars := variable.GetSessionVars(ctx)\n\tglobalVars := variable.GetGlobalVarAccessor(ctx)\n\tif !v.IsSystem {\n\t\tif value, ok := sessionVars.Users[name]; ok {\n\t\t\treturn value, nil\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\t_, ok := variable.SysVars[name]\n\tif !ok {\n\t\treturn nil, errors.Errorf(\"Unknown system variable '%s'\", name)\n\t}\n\n\tif !v.IsGlobal {\n\t\tif value, ok := sessionVars.Systems[name]; ok {\n\t\t\treturn value, nil\n\t\t}\n\t}\n\tvalue, err := globalVars.GetGlobalSysVar(ctx, name)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\treturn value, nil\n}\n\n\nfunc (v *Variable) Accept(visitor Visitor) (Expression, error) {\n\treturn visitor.VisitVariable(v)\n}\n\nfunc (v *Variable) Clone() Expression ", "output": "{\n\tnewVar := *v\n\treturn &newVar\n}"}
{"input": "package activedir\n\n\n\nfunc (c *activedirProvider) powerShellDoCommand(command string, shouldLog bool) error {\n\tif !c.fake {\n\t\tpanic(\"Can not happen: PowerShell on non-windows\")\n\t}\n\treturn c.powerShellRecord(command)\n}\n\nfunc (c *activedirProvider) getRecords(domainname string) ([]byte, error) ", "output": "{\n\tif !c.fake {\n\t\tpanic(\"Can not happen: PowerShell on non-windows\")\n\t}\n\treturn c.readZoneDump(domainname)\n}"}
{"input": "package quantile\n\nimport (\n    \"testing\"\n)\n\n\n\nfunc BenchmarkInsertTargetedSmallEpsilon(b *testing.B) {\n    s := NewTargeted(TargetsSmallEpsilon)\n    b.ResetTimer()\n    for i := float64(0); i < float64(b.N); i++ {\n        s.Insert(i)\n    }\n}\n\nfunc BenchmarkInsertBiased(b *testing.B) {\n    s := NewLowBiased(0.01)\n    b.ResetTimer()\n    for i := float64(0); i < float64(b.N); i++ {\n        s.Insert(i)\n    }\n}\n\nfunc BenchmarkInsertBiasedSmallEpsilon(b *testing.B) {\n    s := NewLowBiased(0.0001)\n    b.ResetTimer()\n    for i := float64(0); i < float64(b.N); i++ {\n        s.Insert(i)\n    }\n}\n\nfunc BenchmarkQuery(b *testing.B) {\n    s := NewTargeted(Targets)\n    for i := float64(0); i < 1e6; i++ {\n        s.Insert(i)\n    }\n    b.ResetTimer()\n    n := float64(b.N)\n    for i := float64(0); i < n; i++ {\n        s.Query(i / n)\n    }\n}\n\nfunc BenchmarkQuerySmallEpsilon(b *testing.B) {\n    s := NewTargeted(TargetsSmallEpsilon)\n    for i := float64(0); i < 1e6; i++ {\n        s.Insert(i)\n    }\n    b.ResetTimer()\n    n := float64(b.N)\n    for i := float64(0); i < n; i++ {\n        s.Query(i / n)\n    }\n}\n\nfunc BenchmarkInsertTargeted(b *testing.B) ", "output": "{\n    b.ReportAllocs()\n\n    s := NewTargeted(Targets)\n    b.ResetTimer()\n    for i := float64(0); i < float64(b.N); i++ {\n        s.Insert(i)\n    }\n}"}
{"input": "package console\n\nimport (\n\t\"github.com/cgrates/cgrates/config\"\n\t\"github.com/cgrates/cgrates/engine\"\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\nfunc init() {\n\tc := &CmdGetResourceForEvent{\n\t\tname:      \"resources_for_event\",\n\t\trpcMethod: \"ResourceSv1.GetResourcesForEvent\",\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}\n\n\ntype CmdGetResourceForEvent struct {\n\tname      string\n\trpcMethod string\n\trpcParams interface{}\n\t*CommandExecuter\n}\n\nfunc (self *CmdGetResourceForEvent) Name() string {\n\treturn self.name\n}\n\nfunc (self *CmdGetResourceForEvent) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\n\n\nfunc (self *CmdGetResourceForEvent) PostprocessRpcParams() error { \n\tvar tenant string\n\tparam := self.rpcParams.(*map[string]interface{})\n\tif (*param)[utils.Tenant] != nil && (*param)[utils.Tenant].(string) != \"\" {\n\t\ttenant = (*param)[utils.Tenant].(string)\n\t\tdelete((*param), utils.Tenant)\n\t} else {\n\t\ttenant = config.CgrConfig().DefaultTenant\n\t}\n\targres := utils.ArgRSv1ResourceUsage{\n\t\tCGREvent: utils.CGREvent{\n\t\t\tTenant: tenant,\n\t\t\tID:     utils.UUIDSha1Prefix(),\n\t\t\tEvent:  *param,\n\t\t},\n\t}\n\tself.rpcParams = argres\n\treturn nil\n}\n\nfunc (self *CmdGetResourceForEvent) RpcResult() interface{} {\n\tatr := engine.Resources{}\n\treturn &atr\n}\n\nfunc (self *CmdGetResourceForEvent) RpcParams(reset bool) interface{} ", "output": "{\n\tif reset || self.rpcParams == nil {\n\t\tmp := make(map[string]interface{})\n\t\tself.rpcParams = &mp\n\t}\n\treturn self.rpcParams\n}"}
{"input": "package user\n\nimport (\n\t\"errors\"\n\n\t\"github.com/appcelerator/amp/api/rpc/account\"\n\t\"github.com/appcelerator/amp/api/rpc/version\"\n\t\"github.com/appcelerator/amp/cli\"\n\t\"github.com/appcelerator/amp/cmd/amplifier/server/configuration\"\n\t\"github.com/spf13/cobra\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc/status\"\n)\n\n\n\n\nfunc resendVerify(c cli.Interface, args []string) error {\n\tconn := c.ClientConn()\n\tclientVer := version.NewVersionClient(conn)\n\trequestVer := &version.GetRequest{}\n\treply, err := clientVer.VersionGet(context.Background(), requestVer)\n\tif err != nil {\n\t\tif s, ok := status.FromError(err); ok {\n\t\t\treturn errors.New(s.Message())\n\t\t}\n\t}\n\tif reply.Info.Registration == configuration.RegistrationNone {\n\t\treturn errors.New(\"`amp user resend-verify` disabled. This cluster has no registration policy\")\n\t}\n\n\tclient := account.NewAccountClient(conn)\n\trequest := &account.ResendVerifyRequest{\n\t\tName: args[0],\n\t\tUrl:  c.Server(),\n\t}\n\tif _, err := client.ResendVerify(context.Background(), request); err != nil {\n\t\tif s, ok := status.FromError(err); ok {\n\t\t\treturn errors.New(s.Message())\n\t\t}\n\t}\n\tc.Console().Printf(\"A new verification email has been sent to %s\\n\", args[0])\n\treturn nil\n}\n\nfunc NewResendVerifyCommand(c cli.Interface) *cobra.Command ", "output": "{\n\treturn &cobra.Command{\n\t\tUse:     \"resend-verification-token USERNAME\",\n\t\tShort:   \"Resend verification email to registered address\",\n\t\tPreRunE: cli.ExactArgs(1),\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn resendVerify(c, args)\n\t\t},\n\t}\n}"}
{"input": "package mysql\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"camlistore.org/pkg/osutil\"\n\t\"camlistore.org/pkg/sorted\"\n\t\"camlistore.org/pkg/sorted/kvtest\"\n\t\"camlistore.org/pkg/test/dockertest\"\n\t\"go4.org/jsonconfig\"\n)\n\n\n\n\nfunc TestRollback(t *testing.T) {\n\tdbname := \"camlitest_\" + osutil.Username()\n\tcontainerID, ip := dockertest.SetupMySQLContainer(t, dbname)\n\tdefer containerID.KillRemove(t)\n\n\tkv, err := sorted.NewKeyValue(jsonconfig.Obj{\n\t\t\"type\":     \"mysql\",\n\t\t\"host\":     ip + \":3306\",\n\t\t\"database\": dbname,\n\t\t\"user\":     dockertest.MySQLUsername,\n\t\t\"password\": dockertest.MySQLPassword,\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"mysql.NewKeyValue = %v\", err)\n\t}\n\n\tkv.(*keyValue).KeyValue.BatchSetFunc = func(*sql.Tx, string, string) error {\n\t\treturn errors.New(\"Forced failure to trigger a rollback\")\n\t}\n\n\tnbConnections := 2\n\ttick := time.AfterFunc(5*time.Second, func() {\n\t\tkv.(*keyValue).DB.Close()\n\t\tt.Fatal(\"Test failed because SQL connections blocked by unrolled transactions\")\n\t})\n\tkv.(*keyValue).DB.SetMaxOpenConns(nbConnections)\n\tfor i := 0; i < nbConnections+1; i++ {\n\t\tb := kv.BeginBatch()\n\t\tb.Set(\"foo\", \"bar\")\n\t\tif err := kv.CommitBatch(b); err == nil {\n\t\t\tt.Fatal(\"wanted failed commit because too large a key\")\n\t\t}\n\t}\n\ttick.Stop()\n}\n\nfunc TestMySQLKV(t *testing.T) ", "output": "{\n\tdbname := \"camlitest_\" + osutil.Username()\n\tcontainerID, ip := dockertest.SetupMySQLContainer(t, dbname)\n\tdefer containerID.KillRemove(t)\n\n\n\tkv, err := sorted.NewKeyValue(jsonconfig.Obj{\n\t\t\"type\":     \"mysql\",\n\t\t\"host\":     ip + \":3306\",\n\t\t\"database\": dbname,\n\t\t\"user\":     dockertest.MySQLUsername,\n\t\t\"password\": dockertest.MySQLPassword,\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"mysql.NewKeyValue = %v\", err)\n\t}\n\tkvtest.TestSorted(t, kv)\n}"}
{"input": "package icinga\n\nimport \"strconv\"\n\n\n\nconst _State_name = \"OKWarningCriticalUnknown\"\n\nvar _State_index = [...]uint8{0, 2, 9, 17, 24}\n\nfunc (i State) String() string {\n\tif i < 0 || i >= State(len(_State_index)-1) {\n\t\treturn \"State(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n\treturn _State_name[_State_index[i]:_State_index[i+1]]\n}\n\nfunc _() ", "output": "{\n\tvar x [1]struct{}\n\t_ = x[OK-0]\n\t_ = x[Warning-1]\n\t_ = x[Critical-2]\n\t_ = x[Unknown-3]\n}"}
{"input": "package odbc\n\nimport (\n\t\"strings\"\n\n\t\"github.com/alexbrainman/odbc\" \n\t\"github.com/xo/usql/drivers\"\n)\n\n\n\nfunc init() ", "output": "{\n\tdrivers.Register(\"odbc\", drivers.Driver{\n\t\tLexerName: \"tsql\",\n\t\tIsPasswordErr: func(err error) bool {\n\t\t\tif e, ok := err.(*odbc.Error); ok {\n\t\t\t\tmsg := strings.ToLower(e.Error())\n\t\t\t\treturn strings.Contains(msg, \"failed\") &&\n\t\t\t\t\t(strings.Contains(msg, \"login\") ||\n\t\t\t\t\t\tstrings.Contains(msg, \"authentication\") ||\n\t\t\t\t\t\tstrings.Contains(msg, \"password\"))\n\t\t\t}\n\t\t\treturn false\n\t\t},\n\t})\n}"}
{"input": "package testutil\n\nimport (\n\t\"fmt\"\n\n\t\"gopkg.in/check.v1\"\n)\n\ntype intChecker struct {\n\t*check.CheckerInfo\n\trel string\n}\n\n\n\n\n\n\n\nvar IntLessThan = &intChecker{CheckerInfo: &check.CheckerInfo{Name: \"IntLessThan\", Params: []string{\"a\", \"b\"}}, rel: \"<\"}\n\n\n\n\n\nvar IntLessEqual = &intChecker{CheckerInfo: &check.CheckerInfo{Name: \"IntLessEqual\", Params: []string{\"a\", \"b\"}}, rel: \"<=\"}\n\n\n\n\n\nvar IntEqual = &intChecker{CheckerInfo: &check.CheckerInfo{Name: \"IntEqual\", Params: []string{\"a\", \"b\"}}, rel: \"==\"}\n\n\n\n\n\nvar IntNotEqual = &intChecker{CheckerInfo: &check.CheckerInfo{Name: \"IntNotEqual\", Params: []string{\"a\", \"b\"}}, rel: \"!=\"}\n\n\n\n\n\nvar IntGreaterThan = &intChecker{CheckerInfo: &check.CheckerInfo{Name: \"IntGreaterThan\", Params: []string{\"a\", \"b\"}}, rel: \">\"}\n\n\n\n\n\nvar IntGreaterEqual = &intChecker{CheckerInfo: &check.CheckerInfo{Name: \"IntGreaterEqual\", Params: []string{\"a\", \"b\"}}, rel: \">=\"}\n\nfunc (checker *intChecker) Check(params []interface{}, names []string) (result bool, error string) ", "output": "{\n\ta, ok := params[0].(int)\n\tif !ok {\n\t\treturn false, \"left-hand-side argument must be an int\"\n\t}\n\tb, ok := params[1].(int)\n\tif !ok {\n\t\treturn false, \"right-hand-side argument must be an int\"\n\t}\n\tswitch checker.rel {\n\tcase \"<\":\n\t\tresult = a < b\n\tcase \"<=\":\n\t\tresult = a <= b\n\tcase \"==\":\n\t\tresult = a == b\n\tcase \"!=\":\n\t\tresult = a != b\n\tcase \">\":\n\t\tresult = a > b\n\tcase \">=\":\n\t\tresult = a >= b\n\tdefault:\n\t\treturn false, fmt.Sprintf(\"unexpected relation %q\", checker.rel)\n\t}\n\tif !result {\n\t\terror = fmt.Sprintf(\"relation %d %s %d is not true\", a, checker.rel, b)\n\t}\n\treturn result, error\n}"}
{"input": "package excel\n\n\n\nfunc ConvertToTitle(n int) string ", "output": "{\n\tvar ret string\n\tfor n != 0 {\n\t\tret = string('A'+(n-1)%26) + ret\n\t\tn = (n - 1) / 26\n\t}\n\treturn ret\n}"}
{"input": "package mdr\n\n\n\n\n\nfunc InRangeF64(a, b, c float64) bool {\n\tif a > c { \n\t\ta, c = c, a\n\t}\n\tif b < a {\n\t\treturn false\n\t}\n\tif b > c {\n\t\treturn false\n\t}\n\treturn true\n}\n\n\nfunc RangeLoHiF64Slice(v []float64) (lo, hi float64) {\n\tvlen := len(v)\n\tif vlen <= 0 {\n\t\treturn\n\t}\n\tlo, hi = v[0], v[0]\n\tfor i := 1; i < vlen; i++ {\n\t\tif v[i] < lo {\n\t\t\tlo = v[i]\n\t\t}\n\t\tif v[i] > hi {\n\t\t\thi = v[i]\n\t\t}\n\t}\n\treturn lo, hi\n}\n\n\nfunc ForceRangeF64(a, b, c float64) float64 {\n\tif a > c { \n\t\ta, c = c, a\n\t}\n\tif b < a {\n\t\treturn a\n\t}\n\tif b > c {\n\t\treturn c\n\t}\n\treturn b\n}\n\nfunc AbsF64(a float64) float64 ", "output": "{\n\tif a < 0.0 {\n\t\treturn -a\n\t}\n\treturn a\n}"}
{"input": "package source\n\nimport (\n\t\"fmt\"\n\n\tplatform \"github.com/influxdata/influxdb/v2\"\n\t\"github.com/influxdata/influxdb/v2/http\"\n\t\"github.com/influxdata/influxdb/v2/http/influxdb\"\n\t\"github.com/influxdata/influxdb/v2/query\"\n)\n\n\n\n\nfunc NewQueryService(s *platform.Source) (query.ProxyQueryService, error) ", "output": "{\n\tswitch s.Type {\n\tcase platform.SelfSourceType:\n\t\treturn nil, fmt.Errorf(\"self source type not implemented\")\n\tcase platform.V2SourceType:\n\t\treturn &http.SourceProxyQueryService{\n\t\t\tInsecureSkipVerify: s.InsecureSkipVerify,\n\t\t\tAddr:               s.URL,\n\t\t\tSourceFields:       s.SourceFields,\n\t\t}, nil\n\tcase platform.V1SourceType:\n\t\treturn &influxdb.SourceProxyQueryService{\n\t\t\tInsecureSkipVerify: s.InsecureSkipVerify,\n\t\t\tURL:                s.URL,\n\t\t\tSourceFields:       s.SourceFields,\n\t\t\tV1SourceFields:     s.V1SourceFields,\n\t\t\tOrganizationID:     s.OrganizationID,\n\t\t}, nil\n\t}\n\treturn nil, fmt.Errorf(\"unsupported source type %s\", s.Type)\n}"}
{"input": "package vect \n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n)\n\nfunc (v Vect) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(&[2]Float{v.X, v.Y})\n}\n\n\n\nfunc (v *Vect) UnmarshalJSON(data []byte) error ", "output": "{\n\tvectData := [2]Float{}\n\n\terr := json.Unmarshal(data, &vectData)\n\tif err != nil {\n\t\tvectData := struct {\n\t\t\tX, Y Float\n\t\t}{}\n\n\t\terr := json.Unmarshal(data, &vectData)\n\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error decoding Vect\")\n\t\t\treturn err\n\t\t}\n\t\tv.X = vectData.X\n\t\tv.Y = vectData.Y\n\t\treturn nil\n\t}\n\n\tv.X = vectData[0]\n\tv.Y = vectData[1]\n\n\treturn nil\n}"}
{"input": "package lb\n\nimport (\n\t\"github.com/valyala/fasthttp\"\n\t\"testing\"\n)\n\n\n\nfunc Benchmark_RandBalance(b *testing.B) {\n\tlb := NewRandBalance()\n\treqCtx := &fasthttp.RequestCtx{}\n\tfor i := 0; i < b.N; i++ {\n\t\tid := lb.Select(reqCtx, Servers)\n\t\tif id < 1 {\n\t\t\tb.Errorf(\"Test_HashIPBalance is error=%d\", id)\n\t\t}\n\t}\n}\n\nfunc Test_RandBalance(t *testing.T) ", "output": "{\n\tlb := NewRandBalance()\n\treqCtx := &fasthttp.RequestCtx{}\n\tfor i := 0; i < 66; i++ {\n\t\tid := lb.Select(reqCtx, Servers)\n\t\tif id < 1 {\n\t\t\tt.Errorf(\"Test_HashIPBalance is error=%d\", id)\n\t\t}\n\t\tt.Logf(\"id=%d\", id)\n\t}\n}"}
{"input": "package glw\n\nimport \"golang.org/x/mobile/gl\"\n\ntype A2fv gl.Attrib\n\nfunc (a A2fv) Enable()  { ctx.EnableVertexAttribArray(gl.Attrib(a)) }\nfunc (a A2fv) Disable() { ctx.DisableVertexAttribArray(gl.Attrib(a)) }\nfunc (a A2fv) Pointer() {\n\ta.Enable()\n\tctx.VertexAttribPointer(gl.Attrib(a), 2, gl.FLOAT, false, 0, 0)\n}\n\ntype A3fv gl.Attrib\n\nfunc (a A3fv) Enable()  { ctx.EnableVertexAttribArray(gl.Attrib(a)) }\nfunc (a A3fv) Disable() { ctx.DisableVertexAttribArray(gl.Attrib(a)) }\nfunc (a A3fv) Pointer() {\n\ta.Enable()\n\tctx.VertexAttribPointer(gl.Attrib(a), 3, gl.FLOAT, false, 0, 0)\n}\n\ntype A4fv gl.Attrib\n\n\nfunc (a A4fv) Disable() { ctx.DisableVertexAttribArray(gl.Attrib(a)) }\nfunc (a A4fv) Pointer() {\n\ta.Enable()\n\tctx.VertexAttribPointer(gl.Attrib(a), 4, gl.FLOAT, false, 0, 0)\n}\n\nfunc (a A4fv) Enable()  ", "output": "{ ctx.EnableVertexAttribArray(gl.Attrib(a)) }"}
{"input": "package bufpool_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/corestoreio/caddy-esi/bufpool\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestBufferPoolSize(t *testing.T) ", "output": "{\n\tp := bufpool.New(4096)\n\tassert.Exactly(t, 4096, p.Get().Cap())\n\tassert.Exactly(t, 0, p.Get().Len())\n}"}
{"input": "package xmlquery\n\nimport (\n\txml \"encoding/xml\"\n)\n\nfunc Find(_ *Node, _ string) []*Node {\n\treturn nil\n}\n\nfunc FindEach(_ *Node, _ string, _ func(int, *Node)) {}\n\nfunc FindEachWithBreak(_ *Node, _ string, _ func(int, *Node) bool) {}\n\n\n\ntype Node struct {\n\tParent       *Node\n\tFirstChild   *Node\n\tLastChild    *Node\n\tPrevSibling  *Node\n\tNextSibling  *Node\n\tType         NodeType\n\tData         string\n\tPrefix       string\n\tNamespaceURI string\n\tAttr         []xml.Attr\n}\n\nfunc (_ *Node) InnerText() string {\n\treturn \"\"\n}\n\nfunc (_ *Node) OutputXML(_ bool) string {\n\treturn \"\"\n}\n\nfunc (_ *Node) SelectAttr(_ string) string {\n\treturn \"\"\n}\n\nfunc (_ *Node) SelectElement(_ string) *Node {\n\treturn nil\n}\n\nfunc (_ *Node) SelectElements(_ string) []*Node {\n\treturn nil\n}\n\ntype NodeType uint\n\nfunc Query(_ *Node, _ string) (*Node, error) {\n\treturn nil, nil\n}\n\nfunc QueryAll(_ *Node, _ string) ([]*Node, error) {\n\treturn nil, nil\n}\n\nfunc FindOne(_ *Node, _ string) *Node ", "output": "{\n\treturn nil\n}"}
{"input": "package ports\n\n\n\n\nfunc Contains(ports []Port, location Location) bool ", "output": "{\n\tfor _, p := range ports {\n\t\tif p.Location == location {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}"}
{"input": "package storage\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\tmgo \"github.com/ilius/mgo\"\n\t\"github.com/ilius/starcal-server/pkg/scal/settings\"\n)\n\nvar db *MongoDatabase\n\n\n\nfunc InitDB() {\n\tmongoDBDialInfo := &mgo.DialInfo{\n\t\tAddrs:    []string{settings.MONGO_HOST},\n\t\tTimeout:  2 * time.Second,\n\t\tDatabase: settings.MONGO_DB_NAME,\n\t\tUsername: settings.MONGO_USERNAME,\n\t\tPassword: settings.MONGO_PASSWORD,\n\t}\n\n\tmongoSession, err := mgo.DialWithInfo(mongoDBDialInfo)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmongoSession.SetMode(mgo.Monotonic, true)\n\n\tdb = &MongoDatabase{\n\t\t*mongoSession.DB(settings.MONGO_DB_NAME),\n\t}\n}\n\nfunc GetDB() (Database, error) ", "output": "{\n\tif db == nil {\n\t\treturn nil, fmt.Errorf(\"database is not initialized\")\n\t}\n\treturn db, nil\n}"}
{"input": "package chug_test\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"../..lager/chug\"\n\t\"github.com/onsi/gomega/format\"\n\t\"github.com/onsi/gomega/types\"\n)\n\nfunc MatchLogEntry(entry chug.LogEntry) types.GomegaMatcher {\n\treturn &logEntryMatcher{entry}\n}\n\ntype logEntryMatcher struct {\n\tentry chug.LogEntry\n}\n\n\n\nfunc (m *logEntryMatcher) FailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, \"to equal\", m.entry)\n}\n\nfunc (m *logEntryMatcher) NegatedFailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, \"not to equal\", m.entry)\n}\n\nfunc (m *logEntryMatcher) Match(actual interface{}) (success bool, err error) ", "output": "{\n\tactualEntry, ok := actual.(chug.LogEntry)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"MatchLogEntry must be passed a chug.LogEntry.  Got:\\n%s\", format.Object(actual, 1))\n\t}\n\n\treturn m.entry.LogLevel == actualEntry.LogLevel &&\n\t\tm.entry.Source == actualEntry.Source &&\n\t\tm.entry.Message == actualEntry.Message &&\n\t\tm.entry.Session == actualEntry.Session &&\n\t\treflect.DeepEqual(m.entry.Error, actualEntry.Error) &&\n\t\tm.entry.Trace == actualEntry.Trace &&\n\t\treflect.DeepEqual(m.entry.Data, actualEntry.Data), nil\n}"}
{"input": "package jsons\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\n\ntype FileReader struct {\n\tfilename string\n\tf        io.WriteCloser\n\tr        *Reader\n}\n\n\n\nfunc NewFileReader(filename string) *FileReader {\n\treturn &FileReader{filename: filename}\n}\n\n\n\nfunc (fr *FileReader) Open() error {\n\tf, err := os.Open(fr.filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfr.f = f\n\tfr.r = NewReader(f)\n\treturn nil\n}\n\n\n\n\n\n\nfunc (fr *FileReader) Next(v interface{}) error {\n\treturn fr.r.Next(v)\n}\n\nfunc (fr *FileReader) Close() error ", "output": "{\n\treturn fr.f.Close()\n}"}
{"input": "package halfshell\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\ntype Logger struct {\n\t*log.Logger\n\tName string\n}\n\nfunc NewLogger(nameFormat string, v ...interface{}) *Logger {\n\treturn &Logger{\n\t\tlog.New(os.Stdout, \"\", log.Ldate|log.Lmicroseconds),\n\t\tfmt.Sprintf(nameFormat, v...),\n\t}\n}\n\n\n\nfunc (l *Logger) Debug(format string, v ...interface{}) {\n\tl.Log(\"DEBUG\", format, v...)\n}\n\nfunc (l *Logger) Info(format string, v ...interface{}) {\n\tl.Log(\"INFO\", format, v...)\n}\n\nfunc (l *Logger) Warn(format string, v ...interface{}) {\n\tl.Log(\"WARNING\", format, v...)\n}\n\nfunc (l *Logger) Error(format string, v ...interface{}) {\n\tl.Log(\"ERROR\", format, v...)\n}\n\nfunc (l *Logger) Log(level, format string, v ...interface{}) ", "output": "{\n\tl.Printf(\"[%s] [%s] %s\", level, l.Name, fmt.Sprintf(format, v...))\n}"}
{"input": "package oauth\n\nimport (\n\t\"github.com/RichardKnop/go-oauth2-server/config\"\n\t\"github.com/RichardKnop/go-oauth2-server/oauth/roles\"\n\t\"github.com/jinzhu/gorm\"\n)\n\n\ntype Service struct {\n\tcnf          *config.Config\n\tdb           *gorm.DB\n\tallowedRoles []string\n}\n\n\nfunc NewService(cnf *config.Config, db *gorm.DB) *Service {\n\treturn &Service{\n\t\tcnf:          cnf,\n\t\tdb:           db,\n\t\tallowedRoles: []string{roles.Superuser, roles.User},\n\t}\n}\n\n\n\n\n\nfunc (s *Service) RestrictToRoles(allowedRoles ...string) {\n\ts.allowedRoles = allowedRoles\n}\n\n\nfunc (s *Service) IsRoleAllowed(role string) bool {\n\tfor _, allowedRole := range s.allowedRoles {\n\t\tif role == allowedRole {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc (s *Service) Close() {}\n\nfunc (s *Service) GetConfig() *config.Config ", "output": "{\n\treturn s.cnf\n}"}
{"input": "package main\n\nimport \"fmt\"\n\n\n\nfunc main() {\n\tx := 1.5\n\tsquare(&x)\n\tfmt.Println(x)\n}\n\nfunc square(x *float64) ", "output": "{\n\t*x = *x * *x\n}"}
{"input": "package database\n\nimport (\n\t\"context\"\n\n\t\"github.com/sacloud/libsacloud/v2/sacloud\"\n)\n\n\n\nfunc (s *Service) ReadWithContext(ctx context.Context, req *ReadRequest) (*sacloud.Database, error) {\n\tif err := req.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\tclient := sacloud.NewDatabaseOp(s.caller)\n\treturn client.Read(ctx, req.Zone, req.ID)\n}\n\nfunc (s *Service) Read(req *ReadRequest) (*sacloud.Database, error) ", "output": "{\n\treturn s.ReadWithContext(context.Background(), req)\n}"}
{"input": "package redis_client\n\nimport (\n\t\"fmt\"\n\t\"github.com/golang/glog\"\n)\n\ntype redisClientManager struct {\n\tredisClients map[string]*RedisPool\n}\n\nvar redisClients = &redisClientManager{make(map[string]*RedisPool)}\n\n\n\nfunc GetRedisClient(redisName string) (client *RedisPool) {\n\tclient, ok := redisClients.redisClients[redisName]\n\tif !ok {\n\t\tglog.Errorf(\"getRedisClient - Not found client: %s\", redisName)\n\t}\n\treturn\n}\n\nfunc GetRedisClientManager() map[string]*RedisPool {\n\treturn redisClients.redisClients\n}\n\nfunc InstallRedisClientManager(configs []RedisConfig) ", "output": "{\n\tfor _, config := range configs {\n\t\tclient := NewRedisPool(&config)\n\t\tif client == nil {\n\t\t\terr := fmt.Errorf(\"InstallRedisClient - NewRedisPool {%v} error!\", config)\n\t\t\tpanic(err)\n\t\t}\n\n\t\tredisClients.redisClients[config.Name] = client\n\t}\n}"}
{"input": "package dt\n\nimport \"github.com/gin-gonic/gin\"\n\nfunc init() {\n\tDtRegister(\"dns.delDomain\", NewDnsDelDomain)\n}\n\ntype DnsDelDomain struct {\n\tparam Param\n}\n\n\n\nfunc (d *DnsDelDomain) Response() (data gin.H, err error) {\n\tdomain := d.param.Get.Get(\"domain\")\n\n\tsqlstr := \"delete from dns.record where domain=:domain\"\n\t_, err = d.param.Db.NamedExec(sqlstr,\n\t\tmap[string]interface{}{\n\t\t\t\"domain\": domain,\n\t\t})\n\treturn\n}\n\nfunc NewDnsDelDomain(param Param) (Action, error) ", "output": "{\n\treturn &DnsDelDomain{\n\t\tparam: param,\n\t}, nil\n}"}
{"input": "package opts\n\n\ntype CreateOption func(*CreateConfig)\n\n\n\ntype CreateConfig struct {\n\tOptions   map[string]string\n\tLabels    map[string]string\n\tReference string\n}\n\n\n\nfunc WithCreateLabels(labels map[string]string) CreateOption {\n\treturn func(cfg *CreateConfig) {\n\t\tcfg.Labels = labels\n\t}\n}\n\n\n\nfunc WithCreateOptions(opts map[string]string) CreateOption {\n\treturn func(cfg *CreateConfig) {\n\t\tcfg.Options = opts\n\t}\n}\n\n\n\n\nfunc WithCreateReference(ref string) CreateOption {\n\treturn func(cfg *CreateConfig) {\n\t\tcfg.Reference = ref\n\t}\n}\n\n\n\ntype GetConfig struct {\n\tDriver        string\n\tReference     string\n\tResolveStatus bool\n}\n\n\ntype GetOption func(*GetConfig)\n\n\n\n\n\nfunc WithGetDriver(name string) GetOption {\n\treturn func(o *GetConfig) {\n\t\to.Driver = name\n\t}\n}\n\n\n\nfunc WithGetReference(ref string) GetOption {\n\treturn func(o *GetConfig) {\n\t\to.Reference = ref\n\t}\n}\n\n\n\nfunc WithGetResolveStatus(cfg *GetConfig) {\n\tcfg.ResolveStatus = true\n}\n\n\ntype RemoveConfig struct {\n\tPurgeOnError bool\n}\n\n\ntype RemoveOption func(*RemoveConfig)\n\n\n\n\n\n\nfunc WithPurgeOnError(b bool) RemoveOption ", "output": "{\n\treturn func(o *RemoveConfig) {\n\t\to.PurgeOnError = b\n\t}\n}"}
{"input": "package logging\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/ConSol/go-neb-wrapper/neb\"\n\t\"github.com/griesbacher/Iapetos/config\"\n)\n\nconst (\n\tcore   = \"core\"\n\tstdout = \"stdout\"\n)\n\nvar destination string\n\n\nfunc InitLogDestination() error {\n\tdest := strings.ToLower(config.GetConfig().Logging.Destination)\n\tif dest != core && dest != stdout {\n\t\treturn fmt.Errorf(\"This log destination is not supported. Supported are: %s %s\", core, stdout)\n\t}\n\n\tneb.CoreFLog(\"Logging from now on to: %s\", dest)\n\tdestination = dest\n\treturn nil\n}\n\n\n\n\nfunc Flog(format string, a ...interface{}) ", "output": "{\n\tif destination == core {\n\t\tneb.CoreFLog(format, a)\n\t} else if destination == stdout {\n\t\tif a == nil {\n\t\t\tfmt.Print(format)\n\t\t} else {\n\t\t\tfmt.Printf(format, a)\n\t\t}\n\t}\n}"}
{"input": "package dfs_test\n\nimport (\n\tvolumemocks \"github.com/control-center/serviced/volume/mocks\"\n\t. \"gopkg.in/check.v1\"\n)\n\n\n\nfunc (s *DFSTestSuite) TestList_NoSnapshots(c *C) {\n\tvol := &volumemocks.Volume{}\n\ts.disk.On(\"Get\", \"tenant\").Return(vol, nil)\n\tvol.On(\"Snapshots\").Return(nil, ErrTestNoSnapshots)\n\tsnapshots, err := s.dfs.List(\"tenant\")\n\tc.Assert(snapshots, IsNil)\n\tc.Assert(err, Equals, ErrTestNoSnapshots)\n}\n\nfunc (s *DFSTestSuite) TestList_Success(c *C) {\n\tvol := &volumemocks.Volume{}\n\ts.disk.On(\"Get\", \"tenant\").Return(vol, nil)\n\tsnaps := []string{\"tenant_label1\", \"tenant_label2\"}\n\tvol.On(\"Snapshots\").Return(snaps, nil)\n\tsnapshots, err := s.dfs.List(\"tenant\")\n\tc.Assert(snapshots, DeepEquals, snaps)\n\tc.Assert(err, IsNil)\n}\n\nfunc (s *DFSTestSuite) TestList_NoVolume(c *C) ", "output": "{\n\ts.disk.On(\"Get\", \"tenant\").Return(&volumemocks.Volume{}, ErrTestVolumeNotFound)\n\tsnapshots, err := s.dfs.List(\"tenant\")\n\tc.Assert(snapshots, IsNil)\n\tc.Assert(err, Equals, ErrTestVolumeNotFound)\n}"}
{"input": "package benchmarks\n\nimport (\n\t\"testing\"\n)\n\nfunc BenchmarkChannelBlockingOneGoroutine(b *testing.B) {\n\tbenchmarkBlocking(b, 1)\n}\nfunc BenchmarkChannelBlockingTwoGoroutines(b *testing.B) {\n\tbenchmarkBlocking(b, 1)\n}\nfunc BenchmarkChannelBlockingThreeGoroutinesWithContendedWrite(b *testing.B) {\n\tbenchmarkBlocking(b, 2)\n}\nfunc benchmarkBlocking(b *testing.B, writers int64) {\n\tchannel := make(chan int64, 1024*16)\n\titerations := int64(b.N)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor x := int64(0); x < writers; x++ {\n\t\tgo func() {\n\t\t\tfor i := int64(0); i < iterations; i++ {\n\t\t\t\tchannel <- i\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor i := int64(0); i < iterations*writers; i++ {\n\t\tmsg := <-channel\n\t\tif writers == 1 && msg != i {\n\t\t\tpanic(\"out of sequence\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkChannelNonBlockingOneGoroutine(b *testing.B) {\n\tbenchmarkNonBlocking(b, 1)\n}\nfunc BenchmarkChannelNonBlockingTwoGoroutines(b *testing.B) {\n\tbenchmarkNonBlocking(b, 1)\n}\nfunc BenchmarkChannelNonBlockingThreeGoroutinesWithContendedWrite(b *testing.B) {\n\tbenchmarkNonBlocking(b, 2)\n}\n\n\nfunc benchmarkNonBlocking(b *testing.B, writers int64) ", "output": "{\n\titerations := int64(b.N)\n\tmaxReads := iterations * writers\n\tchannel := make(chan int64, 1024*16)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor x := int64(0); x < writers; x++ {\n\t\tgo func() {\n\t\t\tfor i := int64(0); i < iterations; {\n\t\t\t\tselect {\n\t\t\t\tcase channel <- i:\n\t\t\t\t\ti++\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor i := int64(0); i < maxReads; i++ {\n\t\tselect {\n\t\tcase msg := <-channel:\n\t\t\tif writers == 1 && msg != i {\n\t\t\t}\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t}\n}"}
{"input": "package bencode\n\nimport (\n\t\"bytes\"\n\t\"strconv\"\n)\n\n\n\nfunc SerializeStr(str string) []byte {\n\treturn []byte(strconv.Itoa(len(str)) + \":\" + str)\n}\n\n\n\nfunc SerializeList(list []string) []byte {\n\tvar buffer bytes.Buffer\n\tbuffer.WriteString(\"l\")\n\tfor _, elt := range list {\n\t\tbuffer.Write(SerializeStr(elt))\n\t}\n\tbuffer.WriteString(\"e\")\n\treturn buffer.Bytes()\n}\n\n\n\n\n\n\n\nfunc DeserializeList(bencode []byte) ([]string, int) {\n\tlist := make([]string, 0)\n\tind := 1\n\tfor ind < len(bencode)-1 {\n\t\tstrLength := bytes.SplitN(bencode[ind:], []byte(\":\"), 2)[0]\n        length, _ := strconv.Atoi(string(strLength))\n\t\telt, _ := DeserializeStr(bencode[ind : ind+length+1])\n\t\tlist = append(list, elt)\n\t\tind += length + 1 + len(strLength)\n\t}\n\treturn list, len(list)\n}\n\nfunc DeserializeStr(bencode []byte) (string, int) ", "output": "{\n    strLength := bytes.SplitN(bencode, []byte(\":\"), 2)[0]\n    length, _ := strconv.Atoi(string(strLength))\n    return string(bencode[len(strLength)+1:]), length\n}"}
{"input": "package keyseq\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestTrie(t *testing.T) {\n\ttrie := NewTrie()\n\tfor i := 1; i <= 5; i++ {\n\t\ttrie.Put(KeyList{Key{0, 0, rune(i)}}, 111*i)\n\t}\n\n\tnodes := Children(trie.Root())\n\tfor i := 0; i < 5; i++ {\n\t\tcheckTrieNode(t, nodes[i], Key{0, 0, rune(i + 1)}, 111*(i+1))\n\t}\n\n\tif s := trie.Size(); s != 5 {\n\t\tt.Errorf(\"trie.Size() returns not 5: %d\", s)\n\t}\n}\n\nfunc TestNotFound(t *testing.T) {\n\ttrie := NewTrie()\n\tif trie.Get(Key{999, 999, 'a'}) != nil {\n\t\tt.Errorf(\"found 'not_exist' in empty trie\")\n\t}\n}\n\nfunc checkTrieNode(t *testing.T, n Node, k Key, value int) ", "output": "{\n\tif n == nil {\n\t\tt.Fatal(\"TrieNode is null\")\n\t}\n\tif l := n.Label(); l != k {\n\t\tt.Errorf(\"TrieNode.Label() expected:'%c' actual:'%c'\", k, l)\n\t}\n\tif v := n.Value().(int); v != value {\n\t\tt.Errorf(\"TrieNode.Value() expected:%d actual:%d\", value, v)\n\t}\n}"}
{"input": "package builtinutil\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n\nfunc CastInterfaceToInterfaceSlice(slice interface{}) ([]interface{}, error) {\n\ts := reflect.ValueOf(slice)\n\tif s.Kind() != reflect.Slice {\n\t\treturn []interface{}{}, fmt.Errorf(\"Input is not a slice: %#v\", slice)\n\t}\n\n\tret := make([]interface{}, s.Len())\n\n\tfor i := 0; i < s.Len(); i++ {\n\t\tret[i] = s.Index(i).Interface()\n\t}\n\n\treturn ret, nil\n}\n\n\n\n\nfunc DeepEqualSlices(expected, actual []interface{}) bool ", "output": "{\n\texpectedMap := map[string]bool{}\n\tfor _, itm := range expected {\n\t\titmAsStr := fmt.Sprintf(\"%#v\", itm)\n\t\texpectedMap[itmAsStr] = true\n\t}\n\tactualMap := map[string]bool{}\n\tfor _, itm := range actual {\n\t\titmAsStr := fmt.Sprintf(\"%#v\", itm)\n\t\tactualMap[itmAsStr] = true\n\t}\n\treturn reflect.DeepEqual(expectedMap, actualMap)\n}"}
{"input": "package waas\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype IpHashLoadBalancingMethod struct {\n}\n\nfunc (m IpHashLoadBalancingMethod) String() string {\n\treturn common.PointerString(m)\n}\n\n\n\n\nfunc (m IpHashLoadBalancingMethod) MarshalJSON() (buff []byte, e error) ", "output": "{\n\ttype MarshalTypeIpHashLoadBalancingMethod IpHashLoadBalancingMethod\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"method\"`\n\t\tMarshalTypeIpHashLoadBalancingMethod\n\t}{\n\t\t\"IP_HASH\",\n\t\t(MarshalTypeIpHashLoadBalancingMethod)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n\t\"net/http\"\n)\n\n\ntype CreateBootVolumeRequest struct {\n\n\tCreateBootVolumeDetails `contributesTo:\"body\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request CreateBootVolumeRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request CreateBootVolumeRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype CreateBootVolumeResponse struct {\n\n\tRawResponse *http.Response\n\n\tBootVolume `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response CreateBootVolumeResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response CreateBootVolumeResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request CreateBootVolumeRequest) HTTPRequest(method, path string) (http.Request, error) ", "output": "{\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}"}
{"input": "package sparkle\n\nimport (\n\t\"net/http\"\n)\n\ntype Context struct {\n\tresponseWriter http.ResponseWriter\n\trequest        *http.Request\n\tdata           map[string]interface{}\n}\n\nfunc newContext(w http.ResponseWriter, r *http.Request) *Context {\n\treturn &Context{\n\t\tw,\n\t\tr,\n\t\tmake(map[string]interface{}),\n\t}\n}\n\n\nfunc (c *Context) ResponseWriter() http.ResponseWriter {\n\treturn c.responseWriter\n}\n\n\nfunc (c *Context) Request() *http.Request {\n\treturn c.request\n}\n\n\n\n\n\n\n\n\n\n\nfunc (c *Context) Get(key string) interface{} {\n\tresult, ok := c.data[key]\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn result\n}\n\nfunc (c *Context) Set(key string, value interface{}) ", "output": "{\n\tc.data[key] = value\n}"}
{"input": "package jd\n\nimport (\n\t\"fmt\"\n)\n\nfunc patchAll(n JsonNode, d Diff) (JsonNode, error) {\n\tvar err error\n\tfor _, de := range d {\n\t\tn, err = n.patch(Path{}, de.Path, de.OldValues, de.NewValues)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn n, nil\n}\n\n\n\nfunc patchErrExpectColl(n JsonNode, pe interface{}) (JsonNode, error) {\n\tswitch pe := pe.(type) {\n\tcase string:\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"Found %v at %v. Expected JSON object.\",\n\t\t\tn.Json(), pe)\n\tcase float64:\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"Found %v at %v. Expected JSON array.\",\n\t\t\tn.Json(), pe)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Invalid path element %v.\", pe))\n\t}\n\n}\n\nfunc patchErrNonSetDiff(oldValues, newValues []JsonNode, path Path) (JsonNode, error) {\n\tif len(oldValues) > 1 {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"Invalid diff: Multiple removals from non-set at %v.\",\n\t\t\tpath)\n\t} else {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"Invalid diff: Multiple additions to a non-set at %v.\",\n\t\t\tpath)\n\t}\n}\n\nfunc patchErrExpectValue(want, found JsonNode, path Path) (JsonNode, error) {\n\treturn nil, fmt.Errorf(\n\t\t\"Found %v at %v. Expected %v.\",\n\t\tfound.Json(), path, want.Json())\n}\n\nfunc singleValue(nodes []JsonNode) JsonNode ", "output": "{\n\tif len(nodes) == 0 {\n\t\treturn voidNode{}\n\t}\n\tif len(nodes) > 1 {\n\t\tpanic(fmt.Sprintf(\"Expected single value. Got %v.\", nodes))\n\t}\n\treturn nodes[0]\n}"}
{"input": "package view\n\nimport (\n\t\"github.com/jmesyan/layerui\"\n\t\"github.com/andlabs/ui\"\n)\n\nfunc tab1()*layerui.LayContainer{\n\tbox:=new(layerui.LayContainer)\n\tbox.LcType=layerui.LcBox\n\tbox.Title=\"box1_title\"\n\tbox.Stretchy=true\n\tbox.Box=ui.NewVerticalBox()\n\tbox.AddWidget(\"box1\",layerui.LayWidget{box1(),true})\n\tbox.Compose()\n\treturn box\n}\n\n\n\n\nfunc MainTab()*layerui.LayContainer{\n\ttab:=new(layerui.LayContainer)\n\ttab.LcType=layerui.LcTab\n\ttab.Tab=ui.NewTab()\n\ttab.AddWidget(\"tab1\",layerui.LayWidget{tab1(),true})\n\ttab.AddWidget(\"tab2\",layerui.LayWidget{tab2(),true})\n\ttab.Compose()\n\treturn tab\n}\n\nfunc tab2()*layerui.LayContainer", "output": "{\n\tbox:=new(layerui.LayContainer)\n\tbox.LcType=layerui.LcBox\n\tbox.Title=\"box2_title\"\n\tbox.Stretchy=true\n\tbox.Box=ui.NewVerticalBox()\n\tbox.AddWidget(\"box2\",layerui.LayWidget{box2(),true})\n\tbox.Compose()\n\treturn box\n}"}
{"input": "package proxy\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/fsouza/go-dockerclient\"\n\t. \"github.com/weaveworks/weave/common\"\n)\n\ntype createExecInterceptor struct {\n\tclient   *docker.Client\n\twithIPAM bool\n}\n\n\n\nfunc (i *createExecInterceptor) InterceptResponse(r *http.Response) error {\n\treturn nil\n}\n\nfunc (i *createExecInterceptor) InterceptRequest(r *http.Request) error ", "output": "{\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tr.Body.Close()\n\n\toptions := docker.CreateExecOptions{}\n\tif err := json.Unmarshal(body, &options); err != nil {\n\t\treturn err\n\t}\n\n\tcontainer, err := inspectContainerInPath(i.client, r.URL.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif cidrs, ok := weaveCIDRsFromConfig(container.Config); ok || i.withIPAM {\n\t\tInfo.Printf(\"Exec in container %s with WEAVE_CIDR \\\"%s\\\"\", container.ID, strings.Join(cidrs, \" \"))\n\t\tcmd := append(weaveWaitEntrypoint, \"-s\")\n\t\toptions.Cmd = append(cmd, options.Cmd...)\n\t}\n\n\tif err := marshalRequestBody(r, options); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package archive\n\nimport (\n\t\"archive/tar\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/docker/docker/pkg/longpath\"\n)\n\n\n\nfunc fixVolumePathPrefix(srcPath string) string {\n\treturn longpath.AddPrefix(srcPath)\n}\n\n\n\nfunc getWalkRoot(srcPath string, include string) string {\n\treturn filepath.Join(srcPath, include)\n}\n\n\n\n\nfunc CanonicalTarNameForPath(p string) (string, error) {\n\tif strings.Contains(p, \"/\") {\n\t\treturn \"\", fmt.Errorf(\"Windows path contains forward slash: %s\", p)\n\t}\n\treturn strings.Replace(p, string(os.PathSeparator), \"/\", -1), nil\n\n}\n\n\n\nfunc chmodTarEntry(perm os.FileMode) os.FileMode {\n\tperm &= 0755\n\tperm |= 0111\n\n\treturn perm\n}\n\nfunc setHeaderForSpecialDevice(hdr *tar.Header, ta *tarAppender, name string, stat interface{}) (nlink uint32, inode uint64, err error) {\n\treturn\n}\n\n\n\nfunc handleTarTypeBlockCharFifo(hdr *tar.Header, path string) error {\n\treturn nil\n}\n\n\n\nfunc getFileUIDGID(stat interface{}) (int, int, error) {\n\treturn 0, 0, nil\n}\n\nfunc handleLChmod(hdr *tar.Header, path string, hdrInfo os.FileInfo) error ", "output": "{\n\treturn nil\n}"}
{"input": "package v1\n\nimport (\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/client-go/tools/cache\"\n\tapi \"k8s.io/kubernetes/pkg/api\"\n\tv1 \"k8s.io/kubernetes/pkg/api/v1\"\n)\n\n\ntype PodLister interface {\n\tList(selector labels.Selector) (ret []*v1.Pod, err error)\n\tPods(namespace string) PodNamespaceLister\n\tPodListerExpansion\n}\n\n\ntype podLister struct {\n\tindexer cache.Indexer\n}\n\n\nfunc NewPodLister(indexer cache.Indexer) PodLister {\n\treturn &podLister{indexer: indexer}\n}\n\n\nfunc (s *podLister) List(selector labels.Selector) (ret []*v1.Pod, err error) {\n\terr = cache.ListAll(s.indexer, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*v1.Pod))\n\t})\n\treturn ret, err\n}\n\n\nfunc (s *podLister) Pods(namespace string) PodNamespaceLister {\n\treturn podNamespaceLister{indexer: s.indexer, namespace: namespace}\n}\n\n\ntype PodNamespaceLister interface {\n\tList(selector labels.Selector) (ret []*v1.Pod, err error)\n\tGet(name string) (*v1.Pod, error)\n\tPodNamespaceListerExpansion\n}\n\n\n\ntype podNamespaceLister struct {\n\tindexer   cache.Indexer\n\tnamespace string\n}\n\n\nfunc (s podNamespaceLister) List(selector labels.Selector) (ret []*v1.Pod, err error) {\n\terr = cache.ListAllByNamespace(s.indexer, s.namespace, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*v1.Pod))\n\t})\n\treturn ret, err\n}\n\n\n\n\nfunc (s podNamespaceLister) Get(name string) (*v1.Pod, error) ", "output": "{\n\tobj, exists, err := s.indexer.GetByKey(s.namespace + \"/\" + name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn nil, errors.NewNotFound(api.Resource(\"pod\"), name)\n\t}\n\treturn obj.(*v1.Pod), nil\n}"}
{"input": "package netchan\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\ntype Error struct {\n\tId   []byte\n\tAddr net.Addr\n\tErr  error\n}\n\n\n\n\n\n\ntype LocalSender chan<- interface{}\n\nfunc (ls LocalSender) Send(block bool, val interface{}) (st ChannelStatus) {\n\tdefer func() {\n\t\tif recover() != nil {\n\t\t\tst = StatusClosed\n\t\t}\n\t}()\n\tif block {\n\t\tls <- val\n\t\treturn StatusOK\n\t}\n\tselect {\n\tcase ls <- val:\n\t\treturn StatusOK\n\tdefault:\n\t\treturn StatusNotReady\n\t}\n}\n\nfunc (ls LocalSender) SendTo(id []byte, val interface{}) (st ChannelStatus) {\n\treturn StatusNotFound\n}\n\n\n\ntype LocalReceiver <-chan interface{}\n\nfunc (lr LocalReceiver) Recv(block bool) (id []byte, val interface{}, st ChannelStatus) {\n\tdefer func() {\n\t\tif recover() != nil {\n\t\t\tst = StatusClosed\n\t\t}\n\t}()\n\tif block {\n\t\tval = <-lr\n\t\tst = StatusOK\n\t\treturn\n\t}\n\tselect {\n\tcase val = <-lr:\n\t\tst = StatusOK\n\tdefault:\n\t\tst = StatusNotReady\n\t}\n\treturn\n}\n\nfunc (err Error) Error() string ", "output": "{\n\treturn fmt.Sprintln(\"Channel [id=%x, remote=%s] error = %v\", err.Id, err.Addr, err.Err)\n}"}
{"input": "package adt\n\ntype Stack struct {\n\ttop *Element\n\tsize int\n}\n \ntype Element struct {\n\tvalue interface{} \n\tnext *Element\n}\n\n\nfunc NewStack() *Stack {\n\treturn new(Stack)\n\n}\n\n\n\n\n\nfunc (s *Stack) IsEmpty() bool {\n\treturn s.Len()==0\n}\n\n\nfunc (s *Stack) Push(value interface{}) {\n\ts.top = &Element{value, s.top}\n\ts.size++\n}\n \n\n\nfunc (s *Stack) Pop() (value interface{}) {\n\tif s.size > 0 {\n\t\tvalue, s.top = s.top.value, s.top.next\n\t\ts.size--\n\t\treturn\n\t}\n\treturn nil\n}\n\nfunc (s *Stack) Len() int ", "output": "{\n\treturn s.size\n}"}
{"input": "package simplemonitor\n\nimport (\n\t\"context\"\n\n\t\"github.com/sacloud/libsacloud/v2/helper/service\"\n\t\"github.com/sacloud/libsacloud/v2/sacloud\"\n)\n\nfunc (s *Service) Delete(req *DeleteRequest) error {\n\treturn s.DeleteWithContext(context.Background(), req)\n}\n\n\n\nfunc (s *Service) DeleteWithContext(ctx context.Context, req *DeleteRequest) error ", "output": "{\n\tif err := req.Validate(); err != nil {\n\t\treturn err\n\t}\n\n\tclient := sacloud.NewSimpleMonitorOp(s.caller)\n\tif err := client.Delete(ctx, req.ID); err != nil {\n\t\treturn service.HandleNotFoundError(err, !req.FailIfNotFound)\n\t}\n\treturn nil\n}"}
{"input": "package datasource \n\nimport \"fmt\"\n\ntype DatabaseID struct {\n\tprojectID    string\n\tinstanceID   string\n\tdatabaseName string\n\tid           string\n}\n\nfunc NewDatabaseID(projectID string, instanceID string, databaseName string) *DatabaseID {\n\treturn &DatabaseID{\n\t\tprojectID:    projectID,\n\t\tinstanceID:   instanceID,\n\t\tdatabaseName: databaseName,\n\t\tid:           fmt.Sprintf(\"projects/%v/instances/%v/databases/%v\", projectID, instanceID, databaseName),\n\t}\n}\n\n\n\nfunc (databaseID *DatabaseID) InstanceID() string {\n\treturn databaseID.instanceID\n}\n\nfunc (databaseID *DatabaseID) DatabaseName() string {\n\treturn databaseID.databaseName\n}\nfunc (databaseID *DatabaseID) ID() string {\n\treturn databaseID.id\n}\n\nfunc (databaseID *DatabaseID) ProjectID() string ", "output": "{\n\treturn databaseID.projectID\n}"}
{"input": "package podsecuritypolicy\n\nimport (\n\t\"context\"\n\n\tv3 \"github.com/rancher/types/apis/management.cattle.io/v3\"\n\tv1beta12 \"github.com/rancher/types/apis/policy/v1beta1\"\n\t\"github.com/rancher/types/config\"\n\t\"k8s.io/api/policy/v1beta1\"\n\tk8serrors \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n)\n\nfunc RegisterPodSecurityPolicy(ctx context.Context, context *config.UserContext) {\n\tp := pspHandler{\n\t\tpsptLister:          context.Management.Management.PodSecurityPolicyTemplates(\"\").Controller().Lister(),\n\t\tpodSecurityPolicies: context.Policy.PodSecurityPolicies(\"\"),\n\t}\n\n\tcontext.Policy.PodSecurityPolicies(\"\").AddHandler(ctx, \"psp-sync\", p.sync)\n}\n\ntype pspHandler struct {\n\tpsptLister          v3.PodSecurityPolicyTemplateLister\n\tpodSecurityPolicies v1beta12.PodSecurityPolicyInterface\n}\n\n\n\n\n\nfunc (p *pspHandler) sync(key string, obj *v1beta1.PodSecurityPolicy) (runtime.Object, error) ", "output": "{\n\tif obj == nil || obj.DeletionTimestamp != nil {\n\t\treturn obj, nil\n\t}\n\tif templateID, ok := obj.Annotations[podSecurityPolicyTemplateParentAnnotation]; ok {\n\t\t_, err := p.psptLister.Get(\"\", templateID)\n\t\tif err != nil {\n\t\t\tif k8serrors.IsNotFound(err) {\n\t\t\t\treturn obj, p.podSecurityPolicies.Delete(obj.Name, &metav1.DeleteOptions{})\n\n\t\t\t}\n\t\t\treturn obj, err\n\t\t}\n\n\t}\n\treturn obj, nil\n}"}
{"input": "package parsex\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n)\n\ntype ParsexError struct {\n\tPos     int\n\tMessage string\n}\n\nfunc (err ParsexError) Error() string {\n\treturn fmt.Sprintf(\"pos %d :\\n%s\",\n\t\terr.Pos, err.Message)\n}\n\ntype ParsexState interface {\n\tNext(pred func(int, interface{}) (interface{}, error)) (x interface{}, err error)\n\tPos() int\n\tSeekTo(int)\n\tTrap(message string, args ...interface{}) error\n}\n\ntype StateInMemory struct {\n\tbuffer []interface{}\n\tpos    int\n}\n\n\n\nfunc (this *StateInMemory) Next(pred func(int, interface{}) (interface{}, error)) (x interface{}, err error) {\n\tbuffer := (*this).buffer\n\tif (*this).pos < len(buffer) {\n\t\tx := buffer[(*this).pos]\n\t\toutput, err := pred((*this).pos, x)\n\t\tif err == nil {\n\t\t\t(*this).pos++\n\t\t\treturn output, nil\n\t\t} else {\n\t\t\treturn x, err\n\t\t}\n\t} else {\n\t\treturn nil, io.EOF\n\t}\n}\n\nfunc (this *StateInMemory) Pos() int {\n\treturn (*this).pos\n}\n\nfunc (this *StateInMemory) SeekTo(pos int) {\n\tend := len((*this).buffer)\n\tif pos < 0 || pos > end {\n\t\tmessage := fmt.Sprintf(\"%d out range [0, %d]\", pos, end)\n\t\tpanic(errors.New(message))\n\t}\n\t(*this).pos = pos\n}\n\nfunc (this *StateInMemory) Trap(message string, args ...interface{}) error {\n\treturn ParsexError{(*this).pos,\n\t\tfmt.Sprintf(message, args...)}\n}\n\nfunc NewStateInMemory(buffer []interface{}) *StateInMemory ", "output": "{\n\treturn &StateInMemory{buffer, 0}\n}"}
{"input": "package selinux\n\n\n\n\n\ntype realSELinuxRunner struct{}\n\nvar _ SELinuxRunner = &realSELinuxRunner{}\n\nfunc (_ *realSELinuxRunner) Getfilecon(path string) (string, error) {\n\treturn \"\", nil\n}\n\n\nfunc SetFileLabel(path string, label string) error {\n\treturn nil\n}\n\nfunc SELinuxEnabled() bool ", "output": "{\n\treturn false\n}"}
{"input": "package mysqlctl\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/youtube/vitess/go/mysql\"\n\t\"github.com/youtube/vitess/go/netutil\"\n)\n\n\ntype Status struct {\n\tPosition            mysql.Position\n\tSlaveIORunning      bool\n\tSlaveSQLRunning     bool\n\tSecondsBehindMaster uint\n\tMasterHost          string\n\tMasterPort          int\n\tMasterConnectRetry  int\n}\n\n\n\nfunc (rs *Status) SlaveRunning() bool {\n\treturn rs.SlaveIORunning && rs.SlaveSQLRunning\n}\n\n\nfunc (rs *Status) MasterAddr() string {\n\treturn netutil.JoinHostPort(rs.MasterHost, int32(rs.MasterPort))\n}\n\n\n\n\nfunc NewStatus(masterAddr string) (*Status, error) ", "output": "{\n\thost, port, err := netutil.SplitHostPort(masterAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid masterAddr: %q, %v\", masterAddr, err)\n\t}\n\treturn &Status{\n\t\tMasterConnectRetry: 10,\n\t\tMasterHost:         host,\n\t\tMasterPort:         port,\n\t}, nil\n}"}
{"input": "package sql\n\nimport (\n\t\"github.com/cockroachdb/cockroach/client\"\n\t\"github.com/cockroachdb/cockroach/keys\"\n\t\"github.com/cockroachdb/cockroach/proto\"\n\t\"github.com/cockroachdb/cockroach/sql/parser\"\n\t\"github.com/cockroachdb/cockroach/sql/privilege\"\n\t\"github.com/cockroachdb/cockroach/util/log\"\n)\n\n\n\n\n\n\n\nfunc (p *planner) Truncate(n *parser.Truncate) (planNode, error) ", "output": "{\n\tb := client.Batch{}\n\n\tfor _, tableQualifiedName := range n.Tables {\n\t\ttableDesc, err := p.getTableDesc(tableQualifiedName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err := p.checkPrivilege(tableDesc, privilege.DROP); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttablePrefix := keys.MakeTablePrefix(uint32(tableDesc.ID))\n\n\t\ttableStartKey := proto.Key(tablePrefix)\n\t\ttableEndKey := tableStartKey.PrefixEnd()\n\t\tif log.V(2) {\n\t\t\tlog.Infof(\"DelRange %q - %q\", tableStartKey, tableEndKey)\n\t\t}\n\t\tb.DelRange(tableStartKey, tableEndKey)\n\t}\n\n\tif err := p.txn.Run(&b).GoError(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &valuesNode{}, nil\n}"}
{"input": "package murmur\n\nimport (\n\t\"unsafe\"\n)\n\n\n\nfunc getBlock(data []byte, n int) (int64, int64) ", "output": "{\n\tblock := (*[2]int64)(unsafe.Pointer(&data[n*16]))\n\n\tk1 := block[0]\n\tk2 := block[1]\n\treturn k1, k2\n}"}
{"input": "package websocket\n\nimport (\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"github.com/b00lduck/raspberry_soundboard/persistence\"\n)\n\ntype Hub struct {\n\tclients map[*Client]bool\n\tbroadcast chan bool\n\tregister chan *Client\n\tunregister chan *Client\n\tpersistence *persistence.Persistence\n}\n\nfunc NewHub(persistence *persistence.Persistence) *Hub {\n\treturn &Hub{\n\t\tbroadcast:  make(chan bool),\n\t\tregister:   make(chan *Client),\n\t\tunregister: make(chan *Client),\n\t\tclients:    make(map[*Client]bool),\n\t\tpersistence: persistence,\n\t}\n}\n\nfunc (h *Hub) Broadcast() {\n\th.broadcast <- true\n}\n\n\n\nfunc (h *Hub) Run() ", "output": "{\n\tfor {\n\t\tselect {\n\t\tcase client := <-h.register:\n\t\t\tlog.Info(\"register client\")\n\t\t\th.clients[client] = true\n\t\t\tclient.send <- h.persistence.JsonState()\n\t\tcase client := <-h.unregister:\n\t\t\tif _, ok := h.clients[client]; ok {\n\t\t\t\tlog.Info(\"unregister client\")\n\t\t\t\tdelete(h.clients, client)\n\t\t\t\tclose(client.send)\n\t\t\t}\n\t\tcase <-h.broadcast:\n\t\t\tfor client := range h.clients {\n\t\t\t\tselect {\n\t\t\t\tcase client.send <- h.persistence.JsonState():\n\t\t\t\tdefault:\n\t\t\t\t\tclose(client.send)\n\t\t\t\t\tdelete(h.clients, client)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"}
{"input": "package integration\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/m3db/m3cluster/kv\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype conditionFn func() bool\n\nfunc waitUntil(fn conditionFn, timeout time.Duration) bool {\n\tdeadline := time.Now().Add(timeout)\n\tfor time.Now().Before(deadline) {\n\t\tif fn() {\n\t\t\treturn true\n\t\t}\n\t\ttime.Sleep(time.Second)\n\t}\n\treturn false\n}\n\n\n\nfunc updateStore(t *testing.T, store kv.Store, key string, proto proto.Message) ", "output": "{\n\t_, err := store.Set(key, proto)\n\trequire.NoError(t, err)\n}"}
{"input": "package event\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\n\n\n\ntype AppPopulateMenuBar struct {\n\ttarget   Target\n\tid       uint64\n\tfinished bool\n}\n\n\nfunc SendAppPopulateMenuBar(id uint64) {\n\tDispatch(&AppPopulateMenuBar{target: GlobalTarget(), id: id})\n}\n\n\n\n\n\nfunc (e *AppPopulateMenuBar) Target() Target {\n\treturn e.target\n}\n\n\nfunc (e *AppPopulateMenuBar) Cascade() bool {\n\treturn false\n}\n\n\nfunc (e *AppPopulateMenuBar) Finished() bool {\n\treturn e.finished\n}\n\n\nfunc (e *AppPopulateMenuBar) Finish() {\n\te.finished = true\n}\n\n\n\nfunc (e *AppPopulateMenuBar) ID() uint64 {\n\treturn e.id\n}\n\n\nfunc (e *AppPopulateMenuBar) String() string {\n\tvar buffer bytes.Buffer\n\tbuffer.WriteString(\"AppPopulateMenuBar[\")\n\tbuffer.WriteString(\"window id: \")\n\tbuffer.WriteString(fmt.Sprint(e.id))\n\tif e.finished {\n\t\tbuffer.WriteString(\", Finished\")\n\t}\n\tbuffer.WriteString(\"]\")\n\treturn buffer.String()\n}\n\nfunc (e *AppPopulateMenuBar) Type() Type ", "output": "{\n\treturn AppPopulateMenuBarType\n}"}
{"input": "package tfs\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/richardwilkes/toolbox/errs\"\n)\n\ntype vfs struct {\n\tstorage  string\n\tname     string\n\toffset   int64\n\tlength   int64\n\tmode     os.FileMode\n\tmodTime  time.Time\n\tchildren []*vfs\n}\n\nfunc (v *vfs) Name() string {\n\treturn v.name\n}\n\nfunc (v *vfs) Size() int64 {\n\treturn v.length\n}\n\nfunc (v *vfs) Mode() os.FileMode {\n\treturn v.mode\n}\n\nfunc (v *vfs) ModTime() time.Time {\n\treturn v.modTime\n}\n\nfunc (v *vfs) IsDir() bool {\n\treturn (v.mode & os.ModeDir) == os.ModeDir\n}\n\n\n\nfunc (v *vfs) open() (http.File, error) {\n\tif v.IsDir() {\n\t\treturn &vdir{owner: v}, nil\n\t}\n\tf, err := os.Open(v.storage)\n\tif err != nil {\n\t\treturn nil, errs.NewWithCausef(err, \"Unable to open %s\", v.name)\n\t}\n\treturn &vfile{\n\t\towner: v,\n\t\tfile:  f,\n\t\tsr:    io.NewSectionReader(f, v.offset, v.length),\n\t}, nil\n}\n\nfunc (v *vfs) Sys() interface{} ", "output": "{\n\treturn nil\n}"}
{"input": "package seq\n\nimport \"fmt\"\n\ntype Result struct {\n\tIssues []Issue\n}\n\ntype Issue struct {\n\tPath          string\n\tExpectedValue string\n\tActualValue   string\n}\n\nfunc (r *Result) Ok() bool {\n\treturn len(r.Issues) == 0\n}\n\nfunc (d *Issue) String() string {\n\treturn fmt.Sprintf(\"Expected '%s' to be '%v' but got '%s'\",\n\t\td.Path,\n\t\td.ExpectedValue,\n\t\td.ActualValue,\n\t)\n}\n\nfunc NewResult() *Result {\n\treturn &Result{}\n}\n\n\n\nfunc (r *Result) AddIssue(key, expected, actual string) ", "output": "{\n\tr.Issues = append(r.Issues, Issue{key, expected, actual})\n}"}
{"input": "package orm\n\nimport (\n\t\"time\"\n)\n\nfunc String(s string) *string {\n\treturn &s\n}\n\nfunc Int(i int) *int {\n\treturn &i\n}\n\nfunc Int8(i int8) *int8 {\n\treturn &i\n}\n\nfunc Int16(i int16) *int16 {\n\treturn &i\n}\n\nfunc Int32(i int32) *int32 {\n\treturn &i\n}\n\nfunc Int64(i int64) *int64 {\n\treturn &i\n}\n\nfunc Bool(b bool) *bool {\n\treturn &b\n}\n\nfunc Byte(b byte) *byte {\n\treturn &b\n}\n\nfunc Float32(f float32) *float32 {\n\treturn &f\n}\n\nfunc Float64(f float64) *float64 {\n\treturn &f\n}\n\nfunc Rune(r rune) *rune {\n\treturn &r\n}\n\nfunc Uint(u uint) *uint {\n\treturn &u\n}\n\nfunc Uint8(u uint8) *uint8 {\n\treturn &u\n}\n\nfunc Uint16(u uint16) *uint16 {\n\treturn &u\n}\n\nfunc Uint32(u uint32) *uint32 {\n\treturn &u\n}\n\n\n\nfunc Is(b *bool) bool {\n\treturn b != nil && *b\n}\n\nfunc Time(t time.Time) *time.Time {\n\treturn &t\n}\n\nfunc Duration(d time.Duration) *time.Duration {\n\treturn &d\n}\n\nfunc Uint64(u uint64) *uint64 ", "output": "{\n\treturn &u\n}"}
{"input": "package testers\n\nimport (\n\t\"testing\"\n\n\t\"github.com/keratin/authn-server/app/data\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar BlobStoreTesters = []func(*testing.T, data.BlobStore){\n\ttestRead,\n\ttestWriteNX,\n}\n\n\n\nfunc testWriteNX(t *testing.T, bs data.BlobStore) {\n\tset, err := bs.WriteNX(\"key\", []byte(\"first\"))\n\tassert.NoError(t, err)\n\tassert.True(t, set)\n\n\tset, err = bs.WriteNX(\"key\", []byte(\"second\"))\n\tassert.NoError(t, err)\n\tassert.False(t, set)\n}\n\nfunc testRead(t *testing.T, bs data.BlobStore) ", "output": "{\n\tblob, err := bs.Read(\"unknown\")\n\tassert.NoError(t, err)\n\tassert.Empty(t, blob)\n\n\tok, err := bs.WriteNX(\"blob\", []byte(\"val\"))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\n\tblob, err = bs.Read(\"blob\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"val\", string(blob))\n}"}
{"input": "package introspection\n\nimport (\n\t\"io/ioutil\"\n\t\"path\"\n\t\"runtime\"\n\n\t\"github.com/juju/errors\"\n)\n\nvar (\n\tprofileDir        = \"/etc/profile.d\"\n\tbashFuncsFilename = \"juju-introspection.sh\"\n)\n\n\n\n\n\n\nfunc profileFilename() string {\n\treturn path.Join(profileDir, bashFuncsFilename)\n}\n\nconst bashFuncs = `\njujuAgentCall () {\n  local agent=$1\n  shift\n  local path=\n  for i in \"$@\"; do\n    path=\"$path/$i\"\n  done\n  echo -e \"GET $path HTTP/1.0\\r\\n\" | socat abstract-connect:jujud-$agent STDIO\n}\n\njujuMachineAgentName () {\n  local machine=` + \"`ls -d /var/lib/juju/agents/machine*`\" + `\n  machine=` + \"`basename $machine`\" + `\n  echo $machine\n}\n\njujuMachineOrUnit () {\n  # First arg is the path, second is optional agent name.\n  if [ \"$#\" -gt 2 ]; then\n    echo \"expected no args (for machine agent) or one (unit agent)\"\n    return 1\n  fi\n  local agent=$(jujuMachineAgentName)\n  if [ \"$#\" -eq 2 ]; then\n    agent=$2\n  fi\n  jujuAgentCall $agent $1\n}\n\njuju-goroutines () {\n  jujuMachineOrUnit debug/pprof/goroutine?debug=1 $@\n}\n\njuju-heap-profile () {\n  jujuMachineOrUnit debug/pprof/heap?debug=1 $@\n}\n\njuju-engine-report () {\n  jujuMachineOrUnit depengine/ $@\n}\n\nexport -f jujuAgentCall\nexport -f jujuMachineAgentName\nexport -f jujuMachineOrUnit\nexport -f juju-goroutines\nexport -f juju-heap-profile\nexport -f juju-engine-report\n`\n\nfunc WriteProfileFunctions() error ", "output": "{\n\tif runtime.GOOS != \"linux\" {\n\t\tlogger.Debugf(\"skipping profile funcs install\")\n\t\treturn nil\n\t}\n\tfilename := profileFilename()\n\tif err := ioutil.WriteFile(filename, []byte(bashFuncs), 0644); err != nil {\n\t\treturn errors.Annotate(err, \"writing introspection bash funcs\")\n\t}\n\treturn nil\n}"}
{"input": "package filesystem\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/windows\"\n)\n\n\n\nfunc addReadMode(mode os.FileMode) os.FileMode {\n\treturn mode | syscall.S_IRUSR\n}\n\nfunc getFreeSpace(path string) (uint64, error) {\n\twpath, err := windows.UTF16PtrFromString(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvar freeBytes uint64\n\tif err := windows.GetDiskFreeSpaceEx(wpath, nil, nil, &freeBytes); err != nil {\n\t\treturn 0, err\n\t}\n\treturn freeBytes, nil\n}\n\nfunc umask(mask int) int ", "output": "{\n\treturn 0\n}"}
{"input": "package governor\n\nimport (\n\t\"sync\"\n)\n\n\n\n\n\ntype Governor struct {\n\twg          *sync.WaitGroup\n\tconcurrency int\n\tsemaphore   chan bool\n\terrs        chan error\n}\n\n\n\n\nfunc New(size int, concurrency int) Governor {\n\n\tif concurrency > size {\n\t\tconcurrency = size\n\t}\n\n\tvar wg sync.WaitGroup\n\tsemaphore := make(chan bool, concurrency)\n\terrs := make(chan error, size)\n\n\tg := Governor{\n\t\twg:          &wg,\n\t\tconcurrency: concurrency,\n\t\tsemaphore:   semaphore,\n\t\terrs:        errs,\n\t}\n\n\treturn g\n}\n\n\nfunc (g *Governor) Accelerate() {\n\n\tg.wg.Add(1)\n\tg.semaphore <- true\n}\n\n\nfunc (g *Governor) Decelerate(err error) {\n\n\tg.errs <- err\n\t<-g.semaphore\n\tg.wg.Done()\n}\n\n\n\n\nfunc (g *Governor) Regulate() error {\n\n\tg.spin()\n\tg.coast()\n\tg.stop()\n\n\treturn g.condition()\n}\n\nfunc (g *Governor) spin() {\n\n\tfor govolution := 0; govolution < g.concurrency; govolution++ {\n\t\tg.semaphore <- true\n\t}\n}\n\n\n\nfunc (g *Governor) stop() {\n\n\tclose(g.errs)\n}\n\nfunc (g *Governor) condition() error {\n\n\tfor err := range g.errs {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (g *Governor) coast() ", "output": "{\n\n\tg.wg.Wait()\n}"}
{"input": "package awsauth\n\nimport (\n\t\"bytes\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\n\nfunc SignatureV2(req *http.Request, Auth interface{}) (err error) {\n\tauth, _ := Auth.(map[string]string)\n\tqueryVals := req.URL.Query()\n\tqueryVals.Set(\"AWSAccessKeyId\", auth[\"AccessKey\"])\n\tqueryVals.Set(\"SignatureVersion\", \"2\")\n\tqueryVals.Set(\"SignatureMethod\", \"HmacSHA256\")\n\n\tqueryStr, err := canonicalQueryString(queryVals)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpath := req.URL.Path\n\tif path == \"\" {\n\t\tpath = \"/\"\n\t}\n\n\tpayload := new(bytes.Buffer)\n\tpayloadstring := checkrequestMethod(req.Method) + \"\\n\" + req.Host + \"\\n\" + path + \"\\n\" + queryStr\n\tfmt.Fprintf(payload, \"%s\", payloadstring)\n\thash := hmac.New(sha256.New, []byte(auth[\"SecretKey\"]))\n\thash.Write(payload.Bytes())\n\tsignature := make([]byte, base64.StdEncoding.EncodedLen(hash.Size()))\n\tbase64.StdEncoding.Encode(signature, hash.Sum(nil))\n\n\tqueryVals.Set(\"Signature\", string(signature))\n\treq.URL.RawQuery = queryVals.Encode()\n\treturn nil\n}\n\n\n\nfunc checkrequestMethod(rawMethod string) (verb string) {\n\trawMethodverb := strings.SplitN(rawMethod, \" \", 2)\n\tswitch {\n\tcase len(rawMethodverb) == 0:\n\t\tverb = \"GET\"\n\tdefault:\n\t\tverb = rawMethodverb[0]\n\t}\n\treturn verb\n}\n\nfunc canonicalQueryString(queryString url.Values) (string, error) ", "output": "{\n\treturn strings.Replace(queryString.Encode(), \"+\", \"%20\", -1), nil\n}"}
{"input": "package loaders\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/volatiletech/sqlboiler/boil\"\n)\n\ntype config struct {\n\texec boil.ContextExecutor\n}\n\n\n\nfunc AddToContext(ctx context.Context, exec boil.ContextExecutor, wait time.Duration) context.Context {\n\tctx = context.WithValue(ctx, TopicLoaderKey, newTopicLoader(ctx, exec, wait))\n\tctx = context.WithValue(ctx, OrganizationLoaderKey, newOrganizationLoader(ctx, exec, wait))\n\tctx = context.WithValue(ctx, RepositoryLoaderKey, newRepositoryLoader(ctx, exec, wait))\n\treturn ctx\n}\n\nfunc convertIds(ids []string) []interface{} ", "output": "{\n\tvar translatedIds []interface{}\n\tfor _, id := range ids {\n\t\ttranslatedIds = append(translatedIds, id)\n\t}\n\treturn translatedIds\n}"}
{"input": "package limits\n\nimport \"github.com/harrowio/harrow/domain\"\n\ntype DummyProjectStore struct {\n\tbyId map[string]*domain.Project\n}\n\nfunc NewDummyProjectStore() *DummyProjectStore {\n\treturn &DummyProjectStore{\n\t\tbyId: map[string]*domain.Project{},\n\t}\n}\n\nfunc (self *DummyProjectStore) Add(project *domain.Project) *DummyProjectStore {\n\tself.byId[project.Uuid] = project\n\treturn self\n}\n\n\n\nfunc (self *DummyProjectStore) FindByMemberUuid(uuid string) (*domain.Project, error) {\n\tpanic(\"not implemented\")\n}\n\nfunc (self *DummyProjectStore) FindByOrganizationUuid(uuid string) (*domain.Project, error) {\n\tpanic(\"not implemented\")\n}\n\nfunc (self *DummyProjectStore) FindByNotifierUuid(uuid string, notifierType string) (*domain.Project, error) {\n\tpanic(\"not implemented\")\n}\n\nfunc (self *DummyProjectStore) FindByJobUuid(uuid string) (*domain.Project, error) {\n\tpanic(\"not implemented\")\n}\n\nfunc (self *DummyProjectStore) FindByTaskUuid(uuid string) (*domain.Project, error) {\n\tpanic(\"not implemented\")\n}\n\nfunc (self *DummyProjectStore) FindByRepositoryUuid(uuid string) (*domain.Project, error) {\n\tpanic(\"not implemented\")\n}\n\nfunc (self *DummyProjectStore) FindByEnvironmentUuid(uuid string) (*domain.Project, error) {\n\tpanic(\"not implemented\")\n}\n\nfunc (self *DummyProjectStore) FindByWebhookUuid(uuid string) (*domain.Project, error) {\n\tpanic(\"not implemented\")\n}\n\nfunc (self *DummyProjectStore) FindByNotificationRule(notifierType string, notifierUuid string) (*domain.Project, error) {\n\tpanic(\"not implemented\")\n}\n\nfunc (self *DummyProjectStore) FindByUuid(uuid string) (*domain.Project, error) ", "output": "{\n\tproject, found := self.byId[uuid]\n\tif !found {\n\t\treturn nil, new(domain.NotFoundError)\n\t}\n\n\treturn project, nil\n}"}
{"input": "package system\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\n\t\"github.com/syndtr/gocapability/capability\"\n)\n\n\n\ntype ProcessCapabilities struct {\n\tPid int\n}\n\nfunc (c ProcessCapabilities) Limit(extendedWhitelist bool) error {\n\tcaps, err := capability.NewPid(c.Pid)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"system: getting capabilities: %s\", err)\n\t}\n\n\tsets := capability.BOUNDING | capability.CAPS\n\tcaps.Clear(sets)\n\tcaps.Set(sets,\n\t\tcapability.CAP_CHOWN,\n\t\tcapability.CAP_DAC_OVERRIDE,\n\t\tcapability.CAP_FSETID,\n\t\tcapability.CAP_FOWNER,\n\t\tcapability.CAP_MKNOD,\n\t\tcapability.CAP_NET_RAW,\n\t\tcapability.CAP_SETGID,\n\t\tcapability.CAP_SETUID,\n\t\tcapability.CAP_SETFCAP,\n\t\tcapability.CAP_SETPCAP,\n\t\tcapability.CAP_NET_BIND_SERVICE,\n\t\tcapability.CAP_SYS_CHROOT,\n\t\tcapability.CAP_KILL,\n\t\tcapability.CAP_AUDIT_WRITE,\n\t)\n\n\tif extendedWhitelist {\n\t\tcaps.Set(sets, capability.CAP_SYS_ADMIN)\n\t}\n\n\terr = caps.Apply(sets)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"system: applying capabilities: %s\", err)\n\t}\n\n\treturn nil\n}\n\nfunc init() ", "output": "{\n\truntime.LockOSThread()\n}"}
{"input": "package systemd\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"strconv\"\n\n\t\"github.com/coreos/go-systemd/activation\"\n)\n\n\n\n\n\nfunc ListenFD(addr string) ([]net.Listener, error) ", "output": "{\n\tlisteners, err := activation.Listeners(false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif listeners == nil || len(listeners) == 0 {\n\t\treturn nil, errors.New(\"No sockets found\")\n\t}\n\n\tif addr == \"\" {\n\t\taddr = \"*\"\n\t}\n\n\tfdNum, _ := strconv.Atoi(addr)\n\tfdOffset := fdNum - 3\n\tif (addr != \"*\") && (len(listeners) < int(fdOffset)+1) {\n\t\treturn nil, errors.New(\"Too few socket activated files passed in\")\n\t}\n\n\tif addr == \"*\" {\n\t\treturn listeners, nil\n\t}\n\n\treturn []net.Listener{listeners[fdOffset]}, nil\n}"}
{"input": "package amcl\n\n\nfunc (F *FP) ToString() string {\n\treturn F.toString()\n}\n\nfunc (F *FP) Zero() {\n\tF.zero()\n}\n\nfunc (F *FP) One() {\n\tF.one()\n}\n\n\n\nfunc (F *FP) Neg() {\n\tF.neg()\n}\n\nfunc (F *FP) Add(b *FP) {\n\tF.add(b)\n}\n\nfunc (F *FP) Sub(b *FP) {\n\tF.sub(b)\n}\n\nfunc (F *FP) Inverse() {\n\tF.inverse()\n}\n\nfunc (F *FP) Equals(a *FP) bool {\n\treturn F.equals(a)\n}\n\nfunc (F *FP) Pow(e *BIG) *FP {\n\treturn F.pow(e)\n}\n\nfunc (F *FP) Mul(b *FP) ", "output": "{\n\tF.mul(b)\n}"}
{"input": "package plugins\n\nimport (\n\t\"../answers\"\n\t\"../ircclient\"\n\t\"strings\"\n)\n\ntype DongPlugin struct {\n\tic *ircclient.IRCClient\n}\n\n\n\nfunc (q *DongPlugin) Info() string {\n\treturn `sends back a dong sound for every \\a`\n}\n\nfunc (q *DongPlugin) Usage(cmd string) string {\n\treturn \"\"\n}\n\nfunc (q *DongPlugin) Register(cl *ircclient.IRCClient) {\n\tq.ic = cl\n}\n\nfunc (q *DongPlugin) Unregister() {\n\treturn\n}\n\nfunc (q *DongPlugin) ProcessLine(msg *ircclient.IRCMessage) {\n\tif msg.Command != \"PRIVMSG\" {\n\t\treturn\n\t}\n\n\tcount := strings.Count(msg.Args[0], `\\a`)\n\tcount -= strings.Count(msg.Args[0], `\\\\a`)\n\tif count < 1 {\n\t\treturn\n\t}\n\n\tstr := answers.RandStr(\"dong\")\n\tmessage := \"\"\n\n\tfor i := 0; i < count; i++ {\n\t\tmessage += str + \" \"\n\t}\n\n\tq.ic.ReplyMsg(msg, message)\n}\n\nfunc (q *DongPlugin) ProcessCommand(cmd *ircclient.IRCCommand) {\n\treturn\n}\n\nfunc (q *DongPlugin) String() string ", "output": "{\n\treturn \"dong\"\n}"}
{"input": "package decision\n\nimport (\n\t\"time\"\n\n\twl \"github.com/jbenet/go-ipfs/exchange/bitswap/wantlist\"\n\tpeer \"github.com/jbenet/go-ipfs/p2p/peer\"\n\tu \"github.com/jbenet/go-ipfs/util\"\n)\n\n\n\ntype keySet map[u.Key]struct{}\n\n\n\n\n\ntype ledger struct {\n\tPartner peer.ID\n\n\tAccounting debtRatio\n\n\tfirstExchange time.Time\n\n\tlastExchange time.Time\n\n\texchangeCount uint64\n\n\twantList *wl.Wantlist\n\n\tsentToPeer map[u.Key]time.Time\n}\n\ntype debtRatio struct {\n\tBytesSent uint64\n\tBytesRecv uint64\n}\n\nfunc (dr *debtRatio) Value() float64 {\n\treturn float64(dr.BytesSent) / float64(dr.BytesRecv+1)\n}\n\nfunc (l *ledger) SentBytes(n int) {\n\tl.exchangeCount++\n\tl.lastExchange = time.Now()\n\tl.Accounting.BytesSent += uint64(n)\n}\n\nfunc (l *ledger) ReceivedBytes(n int) {\n\tl.exchangeCount++\n\tl.lastExchange = time.Now()\n\tl.Accounting.BytesRecv += uint64(n)\n}\n\n\nfunc (l *ledger) Wants(k u.Key, priority int) {\n\tlog.Debugf(\"peer %s wants %s\", l.Partner, k)\n\tl.wantList.Add(k, priority)\n}\n\nfunc (l *ledger) CancelWant(k u.Key) {\n\tl.wantList.Remove(k)\n}\n\nfunc (l *ledger) WantListContains(k u.Key) (wl.Entry, bool) {\n\treturn l.wantList.Contains(k)\n}\n\nfunc (l *ledger) ExchangeCount() uint64 {\n\treturn l.exchangeCount\n}\n\nfunc newLedger(p peer.ID) *ledger ", "output": "{\n\treturn &ledger{\n\t\twantList:   wl.New(),\n\t\tPartner:    p,\n\t\tsentToPeer: make(map[u.Key]time.Time),\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\n\n\nfunc saveSecretTo(fname string, s *[]byte) error {\n\terr := ioutil.WriteFile(fname, *s, 0600)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = os.Chmod(fname, 0600)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc readSecretFrom(fname string) (*[]byte, error) {\n\tbytes, err := ioutil.ReadFile(fname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &bytes, nil\n}\n\nfunc newSecret(size int) *[]byte ", "output": "{\n\tbytes := make([]byte, size)\n\n\t_, err := io.ReadFull(rand.Reader, bytes)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn &bytes\n}"}
{"input": "package config\n\nimport (\n\tcb \"github.com/hyperledger/fabric/protos/common\"\n\tab \"github.com/hyperledger/fabric/protos/orderer\"\n\t\"github.com/hyperledger/fabric/protos/utils\"\n)\n\nfunc ordererConfigGroup(key string, value []byte) *cb.ConfigGroup {\n\tresult := cb.NewConfigGroup()\n\tresult.Groups[OrdererGroupKey] = cb.NewConfigGroup()\n\tresult.Groups[OrdererGroupKey].Values[key] = &cb.ConfigValue{\n\t\tValue: value,\n\t}\n\treturn result\n}\n\n\nfunc TemplateConsensusType(typeValue string) *cb.ConfigGroup {\n\treturn ordererConfigGroup(ConsensusTypeKey, utils.MarshalOrPanic(&ab.ConsensusType{Type: typeValue}))\n}\n\n\nfunc TemplateBatchSize(batchSize *ab.BatchSize) *cb.ConfigGroup {\n\treturn ordererConfigGroup(BatchSizeKey, utils.MarshalOrPanic(batchSize))\n}\n\n\n\n\n\nfunc TemplateChannelRestrictions(maxChannels uint64) *cb.ConfigGroup {\n\treturn ordererConfigGroup(ChannelRestrictionsKey, utils.MarshalOrPanic(&ab.ChannelRestrictions{MaxCount: maxChannels}))\n}\n\n\nfunc TemplateKafkaBrokers(brokers []string) *cb.ConfigGroup {\n\treturn ordererConfigGroup(KafkaBrokersKey, utils.MarshalOrPanic(&ab.KafkaBrokers{Brokers: brokers}))\n}\n\nfunc TemplateBatchTimeout(batchTimeout string) *cb.ConfigGroup ", "output": "{\n\treturn ordererConfigGroup(BatchTimeoutKey, utils.MarshalOrPanic(&ab.BatchTimeout{Timeout: batchTimeout}))\n}"}
{"input": "package vulnerabilityscanning\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ChangeContainerScanRecipeCompartmentRequest struct {\n\n\tContainerScanRecipeId *string `mandatory:\"true\" contributesTo:\"path\" name:\"containerScanRecipeId\"`\n\n\tChangeContainerScanRecipeCompartmentDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request ChangeContainerScanRecipeCompartmentRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request ChangeContainerScanRecipeCompartmentRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request ChangeContainerScanRecipeCompartmentRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\n\n\n\ntype ChangeContainerScanRecipeCompartmentResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response ChangeContainerScanRecipeCompartmentResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response ChangeContainerScanRecipeCompartmentResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request ChangeContainerScanRecipeCompartmentRequest) RetryPolicy() *common.RetryPolicy ", "output": "{\n\treturn request.RequestMetadata.RetryPolicy\n}"}
{"input": "package stores\n\nimport (\n\t\"HTVM/instructions/base\"\n\t\"HTVM/runtime\"\n)\n\n\ntype ASTORE struct {\n\tbase.Index8Instruction\n}\n\nfunc (self *ASTORE) Execute(frame *runtime.Frame) {\n\t_executeRef(frame, self.Index)\n}\n\ntype ASTORE_0 struct {\n\tbase.NoOperandsInstruction\n}\n\n\n\ntype ASTORE_1 struct {\n\tbase.NoOperandsInstruction\n}\n\nfunc (self *ASTORE_1) Execute(frame *runtime.Frame) {\n\t_executeRef(frame, 1)\n}\n\ntype ASTORE_2 struct {\n\tbase.NoOperandsInstruction\n}\n\nfunc (self *ASTORE_2) Execute(frame *runtime.Frame) {\n\t_executeRef(frame, 2)\n}\n\ntype ASTORE_3 struct {\n\tbase.NoOperandsInstruction\n}\n\nfunc (self *ASTORE_3) Execute(frame *runtime.Frame) {\n\t_executeRef(frame, 3)\n}\n\ntype ASTORE_4 struct {\n\tbase.NoOperandsInstruction\n}\n\nfunc (self *ASTORE_4) Execute(frame *runtime.Frame) {\n\t_executeRef(frame, 4)\n}\n\nfunc _executeRef(frame *runtime.Frame, index uint) {\n\tval := frame.OperateStack().PopRef()\n\tframe.LocalVars().SetRef(index, val)\n}\n\nfunc (self *ASTORE_0) Execute(frame *runtime.Frame) ", "output": "{\n\t_executeRef(frame, 0)\n}"}
{"input": "package http\n\nimport (\n\tbm \"go-common/library/net/http/blademaster\"\n)\n\nfunc appNameList(c *bm.Context) {\n\tc.JSON(apmSvc.AppNameList(c), nil)\n}\n\nfunc prometheusList(c *bm.Context) {\n\tv := new(struct {\n\t\tAppName string `form:\"app_name\" validate:\"required\"`\n\t\tMethod  string `form:\"method\" validate:\"required\"`\n\t\tMType   string `form:\"mtype\" default:\"count\"`\n\t})\n\tif err := c.Bind(v); err != nil {\n\t\treturn\n\t}\n\tpts, err := apmSvc.PrometheusList(c, v.AppName, v.Method, v.MType)\n\tif err != nil {\n\t\tc.JSON(nil, err)\n\t\treturn\n\t}\n\tc.JSON(pts, nil)\n}\n\nfunc onlineList(c *bm.Context) {\n\tols, err := apmSvc.OnlineList(c)\n\tif err != nil {\n\t\tc.JSON(nil, err)\n\t\treturn\n\t}\n\tc.JSON(ols, nil)\n}\n\n\n\nfunc databusList(c *bm.Context) {\n\tdbs, err := apmSvc.DataBusList(c)\n\tif err != nil {\n\t\tc.JSON(nil, err)\n\t\treturn\n\t}\n\tc.JSON(dbs, nil)\n}\n\nfunc broadcastList(c *bm.Context) ", "output": "{\n\tbcs, err := apmSvc.BroadCastList(c)\n\tif err != nil {\n\t\tc.JSON(nil, err)\n\t\treturn\n\t}\n\tc.JSON(bcs, nil)\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/lxc/lxd/lxd/cluster\"\n\t\"github.com/lxc/lxd/lxd/instance/instancetype\"\n\t\"github.com/lxc/lxd/lxd/response\"\n)\n\nfunc forwardedResponseToNode(d *Daemon, r *http.Request, node string) response.Response {\n\taddress, err := cluster.ResolveTarget(d.cluster, node)\n\tif err != nil {\n\t\treturn response.SmartError(err)\n\t}\n\n\tif address != \"\" {\n\t\tclient, err := cluster.Connect(address, d.endpoints.NetworkCert(), d.serverCert(), r, false)\n\t\tif err != nil {\n\t\t\treturn response.SmartError(err)\n\t\t}\n\t\treturn response.ForwardedResponse(client, r)\n\t}\n\n\treturn nil\n}\n\n\n\nfunc forwardedResponseIfTargetIsRemote(d *Daemon, r *http.Request) response.Response {\n\ttargetNode := queryParam(r, \"target\")\n\tif targetNode == \"\" {\n\t\treturn nil\n\t}\n\n\treturn forwardedResponseToNode(d, r, targetNode)\n}\n\n\n\n\nfunc forwardedResponseIfInstanceIsRemote(d *Daemon, r *http.Request, project, name string, instanceType instancetype.Type) (response.Response, error) {\n\tclient, err := cluster.ConnectIfInstanceIsRemote(d.cluster, project, name, d.endpoints.NetworkCert(), d.serverCert(), r, instanceType)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif client == nil {\n\t\treturn nil, nil\n\t}\n\treturn response.ForwardedResponse(client, r), nil\n}\n\n\n\n\n\n\n\n\n\n\nfunc forwardedResponseIfVolumeIsRemote(d *Daemon, r *http.Request, poolName string, projectName string, volumeName string, volumeType int) response.Response ", "output": "{\n\tif queryParam(r, \"target\") != \"\" {\n\t\treturn nil\n\t}\n\n\tclient, err := cluster.ConnectIfVolumeIsRemote(d.State(), poolName, projectName, volumeName, volumeType, d.endpoints.NetworkCert(), d.serverCert(), r)\n\tif err != nil {\n\t\treturn response.SmartError(err)\n\t}\n\n\tif client == nil {\n\t\treturn nil\n\t}\n\n\treturn response.ForwardedResponse(client, r)\n}"}
{"input": "package logs\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"os\"\n\t\"runtime\"\n)\n\ntype Brush func(string) string\n\nfunc NewBrush(color string) Brush {\n\tpre := \"\\033[\"\n\treset := \"\\033[0m\"\n\treturn func(text string) string {\n\t\treturn pre + color + \"m\" + text + reset\n\t}\n}\n\nvar colors = []Brush{\n\tNewBrush(\"1;37\"), \n\tNewBrush(\"1;36\"), \n\tNewBrush(\"1;35\"), \n\tNewBrush(\"1;31\"), \n\tNewBrush(\"1;33\"), \n\tNewBrush(\"1;32\"), \n\tNewBrush(\"1;34\"), \n\tNewBrush(\"1;34\"), \n}\n\n\ntype ConsoleWriter struct {\n\tlg    *log.Logger\n\tLevel int `json:\"level\"`\n}\n\n\nfunc NewConsole() LoggerInterface {\n\tcw := new(ConsoleWriter)\n\tcw.lg = log.New(os.Stdout, \"\", log.Ldate|log.Ltime)\n\tcw.Level = LevelDebug\n\treturn cw\n}\n\n\n\nfunc (c *ConsoleWriter) Init(jsonconfig string) error {\n\tif len(jsonconfig) == 0 {\n\t\treturn nil\n\t}\n\terr := json.Unmarshal([]byte(jsonconfig), c)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc (c *ConsoleWriter) Destroy() {\n\n}\n\n\nfunc (c *ConsoleWriter) Flush() {\n\n}\n\nfunc init() {\n\tRegister(\"console\", NewConsole)\n}\n\nfunc (c *ConsoleWriter) WriteMsg(msg string, level int) error ", "output": "{\n\tif level > c.Level {\n\t\treturn nil\n\t}\n\tif goos := runtime.GOOS; goos == \"windows\" {\n\t\tc.lg.Println(msg)\n\t} else {\n\t\tc.lg.Println(colors[level](msg))\n\t}\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n)\n\n\n\nfunc main() {\n\tfor i := 0; i < 10; i++ {\n\t\tgo f(i)\n\t}\n\tvar input string\n\tfmt.Scanln(&input)\n}\n\nfunc f(n int) ", "output": "{\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(n, \":\", i)\n\t}\n}"}
{"input": "package example\n\nimport (\n\t\"github.com/hyperledger/fabric/core/ledger\"\n\t\"github.com/hyperledger/fabric/protos\"\n)\n\n\ntype Committer struct {\n\tledger ledger.ValidatedLedger\n}\n\n\n\n\n\nfunc (c *Committer) CommitBlock(rawBlock *protos.Block2) (*protos.Block2, []*protos.InvalidTransaction, error) {\n\tvar validBlock *protos.Block2\n\tvar invalidTxs []*protos.InvalidTransaction\n\tvar err error\n\tlogger.Debugf(\"Committer validating the block...\")\n\tif validBlock, invalidTxs, err = c.ledger.RemoveInvalidTransactionsAndPrepare(rawBlock); err != nil {\n\t\treturn nil, nil, err\n\t}\n\tlogger.Debugf(\"Committer committing the block...\")\n\tif err = c.ledger.Commit(); err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn validBlock, invalidTxs, err\n}\n\nfunc ConstructCommitter(ledger ledger.ValidatedLedger) *Committer ", "output": "{\n\treturn &Committer{ledger}\n}"}
{"input": "package reexec\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\n\t\"github.com/docker/containerd/subreaper/exec\"\n)\n\nvar registeredInitializers = make(map[string]func())\n\n\nfunc Register(name string, initializer func()) {\n\tif _, exists := registeredInitializers[name]; exists {\n\t\tpanic(fmt.Sprintf(\"reexec func already registred under name %q\", name))\n\t}\n\n\tregisteredInitializers[name] = initializer\n}\n\n\n\n\n\nfunc naiveSelf() string {\n\tname := os.Args[0]\n\tif filepath.Base(name) == name {\n\t\tif lp, err := exec.LookPath(name); err == nil {\n\t\t\treturn lp\n\t\t}\n\t}\n\tif absName, err := filepath.Abs(name); err == nil {\n\t\treturn absName\n\t}\n\treturn name\n}\n\nfunc Init() bool ", "output": "{\n\tinitializer, exists := registeredInitializers[os.Args[0]]\n\tif !exists {\n\t\tinitializer, exists = registeredInitializers[path.Base(os.Args[0])]\n\t}\n\tif exists {\n\t\tinitializer()\n\n\t\treturn true\n\t}\n\treturn false\n}"}
{"input": "package spvwallet\n\n\n\n\n\n\n\nimport (\n\t\"github.com/btcsuite/btcd/wire\"\n)\n\n\nconst (\n\tRedeemP2PKHSigScriptSize = 1 + 73 + 1 + 33\n\n\tP2PKHPkScriptSize = 1 + 1 + 1 + 20 + 1 + 1\n\n\tRedeemP2PKHInputSize = 32 + 4 + 1 + RedeemP2PKHSigScriptSize + 4\n\n\tP2PKHOutputSize = 8 + 1 + P2PKHPkScriptSize\n)\n\n\n\n\n\n\n\nfunc sumOutputSerializeSizes(outputs []*wire.TxOut) (serializeSize int) {\n\tfor _, txOut := range outputs {\n\t\tserializeSize += txOut.SerializeSize()\n\t}\n\treturn serializeSize\n}\n\nfunc EstimateSerializeSize(inputCount int, txOuts []*wire.TxOut, addChangeOutput bool) int ", "output": "{\n\tchangeSize := 0\n\toutputCount := len(txOuts)\n\tif addChangeOutput {\n\t\tchangeSize = P2PKHOutputSize\n\t\toutputCount++\n\t}\n\n\treturn 8 + wire.VarIntSerializeSize(uint64(inputCount)) +\n\t\twire.VarIntSerializeSize(uint64(outputCount)) +\n\t\tinputCount*RedeemP2PKHInputSize +\n\t\tsumOutputSerializeSizes(txOuts) +\n\t\tchangeSize\n}"}
{"input": "package pool\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nconst (\n\t_net = \"udp4\" \n)\n\nfunc createUDPConnection(address string) (*net.UDPConn, error) {\n\taddr, err := net.ResolveUDPAddr(_net, address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn, err := net.DialUDP(_net, nil, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}\n\nfunc worker(id int, address string, done chan bool, buffers <-chan []byte) {\n\n\tconn, err := createUDPConnection(address)\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\terr := conn.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t}\n\t}()\n\n\tfor buffer := range buffers {\n\t\t_, err := conn.Write(buffer)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tdone <- true\n}\n\ntype UDPPool struct {\n\tbuffers chan []byte\n\tdone    chan bool\n}\n\n\nfunc NewUDPPool(address string, workerNumber int) *UDPPool {\n\tbuffers := make(chan []byte, workerNumber)\n\tdone := make(chan bool)\n\n\tfor wid := 1; wid < workerNumber; wid++ {\n\t\tgo worker(wid, address, done, buffers)\n\t}\n\treturn &UDPPool{buffers, done}\n}\n\nfunc (p *UDPPool) Fire(buffer []byte) {\n\tp.buffers <- buffer\n}\n\n\n\nfunc (p *UDPPool) Close() ", "output": "{\n\tclose(p.buffers)\n}"}
{"input": "package replay\n\nimport (\n\t\"context\"\n\n\t\"github.com/google/gapid/core/data/search\"\n\t\"github.com/google/gapid/test/robot/job/worker\"\n\t\"google.golang.org/grpc\"\n\n\txctx \"golang.org/x/net/context\"\n)\n\ntype server struct {\n\tmanager Manager\n}\n\n\n\n\n\n\nfunc (s *server) Search(query *search.Query, stream Service_SearchServer) error {\n\tctx := stream.Context()\n\treturn s.manager.Search(ctx, query, func(ctx context.Context, e *Action) error { return stream.Send(e) })\n}\n\n\n\nfunc (s *server) Register(request *worker.RegisterRequest, stream Service_RegisterServer) error {\n\tctx := stream.Context()\n\treturn s.manager.Register(ctx, request.Host, request.Target, func(ctx context.Context, t *Task) error { return stream.Send(t) })\n}\n\n\n\nfunc (s *server) Do(ctx xctx.Context, request *DoRequest) (*worker.DoResponse, error) {\n\tid, err := s.manager.Do(ctx, request.Device, request.Input)\n\treturn &worker.DoResponse{Id: id}, err\n}\n\n\n\nfunc (s *server) Update(ctx xctx.Context, request *UpdateRequest) (*worker.UpdateResponse, error) {\n\tif err := s.manager.Update(ctx, request.Action, request.Status, request.Output); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &worker.UpdateResponse{}, nil\n}\n\nfunc Serve(ctx context.Context, grpcServer *grpc.Server, manager Manager) error ", "output": "{\n\tRegisterServiceServer(grpcServer, &server{manager: manager})\n\treturn nil\n}"}
{"input": "package filters\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"context\"\n\n\t\"github.com/otiai10/chant/server/middleware\"\n\t\"github.com/otiai10/chant/server/models\"\n\t\"github.com/otiai10/marmoset\"\n)\n\n\ntype AuthFilter struct {\n\tmarmoset.Filter\n\tPolicy *Policy\n}\n\n\ntype AuthCtxKey string\n\n\nconst AuthKey AuthCtxKey = \"user\"\n\n\nvar policy *Policy\n\n\nfunc SharedPolicy() Policy {\n\treturn *policy\n}\n\n\n\nfunc InitializeAuthFilter(policyfile io.Reader) *AuthFilter {\n\tpolicy = NewPolicy(policyfile)\n\treturn &AuthFilter{\n\t\tPolicy: policy,\n\t}\n}\n\n\n\n\n\nfunc RequestUser(r *http.Request) *models.User {\n\tuser, ok := marmoset.Context().Get(r).Value(AuthKey).(*models.User)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn user\n}\n\nfunc (f *AuthFilter) ServeHTTP(w http.ResponseWriter, r *http.Request) ", "output": "{\n\n\tc, err := r.Cookie(\"chant_identity_token\")\n\tif err != nil {\n\t\thttp.Redirect(w, r, \"/login\", http.StatusTemporaryRedirect)\n\t\treturn\n\t}\n\tuser, err := models.DecodeUser(c.Value, os.Getenv(\"JWT_SALT\"))\n\tif err != nil {\n\t\thttp.Redirect(w, r, \"/login\", http.StatusTemporaryRedirect)\n\t\treturn\n\t}\n\tif user == nil {\n\t\thttp.Redirect(w, r, \"/login\", http.StatusTemporaryRedirect)\n\t\treturn\n\t}\n\tif !f.Policy.Allow(user) {\n\t\thttp.Redirect(w, r, \"/403\", http.StatusTemporaryRedirect)\n\t\treturn\n\t}\n\tctx := middleware.Context(r)\n\tmarmoset.Context().Set(r, context.WithValue(ctx, AuthKey, user))\n\tf.Next.ServeHTTP(w, r)\n\treturn\n\n}"}
{"input": "package create_topic\n\nimport (\n\t\"encoding/xml\"\n\t\"net/http\"\n\n\t\"github.com/vburenin/firempq/server/snsproto/sns_query\"\n\t\"github.com/vburenin/firempq/server/snsproto/sns_response\"\n\t\"github.com/vburenin/firempq/server/snsproto/snsdefs\"\n\t\"github.com/vburenin/firempq/server/snsproto/snserr\"\n\t\"github.com/vburenin/firempq/server/snsproto/tmgr\"\n\t\"github.com/vburenin/firempq/server/snsproto/validation\"\n)\n\ntype CreateTopicResponse struct {\n\tXMLName   xml.Name `xml:\"http://sns.amazonaws.com/doc/2010-03-31/ CreateTopicResponse\"`\n\tTopicArn  string   `xml:\"CreateTopicResult>TopicArn\"`\n\tRequestId string   `xml:\"ResponseMetadata>RequestId\"`\n}\n\nfunc (s *CreateTopicResponse) XmlDocument() string { return sns_response.EncodeXml(s) }\nfunc (s *CreateTopicResponse) HttpCode() int       { return http.StatusOK }\n\n\n\nfunc CreateTopic(tm *tmgr.TopicManager, snsQuery *sns_query.SNSQuery) sns_response.SNSResponse ", "output": "{\n\ttopicName := \"\"\n\tsns_query.ParseParams(snsQuery, func(k, v string) {\n\t\tif k == \"Name\" {\n\t\t\ttopicName = v\n\t\t}\n\t})\n\n\tif !validation.ValidateTopicName(topicName) {\n\t\treturn snserr.InvalidParameterError(\"Invalid parameter: Topic Name\")\n\t}\n\n\tarn := tm.CreateTopic(topicName)\n\n\treturn &CreateTopicResponse{\n\t\tXMLName: xml.Name{\n\t\t\tSpace: snsdefs.XMLSpace,\n\t\t\tLocal: \"CreateTopicResponse\",\n\t\t},\n\t\tTopicArn:  arn,\n\t\tRequestId: \"reqId\",\n\t}\n}"}
{"input": "package main\n\nimport \"fmt\"\n\nfunc merge(a, b, d []int) {\n    i, j, k := 0, 0, 0\n    na, nb := len(a), len(b)\n    for i < na && j < nb {\n        if a[i] < b[j] {\n            d[k] = a[i]\n            i++\n        } else {\n            d[k] = b[j]\n            j++;\n        }\n        k++;\n    }\n    for i < na {\n        d[k] = a[i]\n        k++\n        i++\n    }\n    for j < nb {\n        d[k] = b[j]\n        k++\n        j++\n    }\n}\n\nfunc merge_sort1(a, b []int) {\n    n := len(a)\n    if n == 1 {\n        b[0] = a[0]\n        return\n    }\n    merge_sort1(a[:n/2], b[:n/2])\n    merge_sort1(a[n/2:], b[n/2:])\n    merge(b[:n/2], b[n/2:], a)\n    copy(b,a)\n}\n\n\n\nfunc main() {\n    a := []int{3,4,178,642,85,3,45,78,5,976,34,51,65,761,414,1,87,612,53,14,550}\n    merge_sort(a)\n    fmt.Println(a)\n}\n\nfunc merge_sort(a []int) ", "output": "{\n    n := len(a)\n    if n <= 1 {\n        return\n    }\n    b := make([]int, n)\n    merge_sort1(a[:n/2], b[:n/2])\n    merge_sort1(a[n/2:], b[n/2:])\n    merge(b[:n/2], b[n/2:], a)\n}"}
{"input": "package install\n\nimport (\n\t\"k8s.io/apimachinery/pkg/apimachinery/announced\"\n\t\"k8s.io/apimachinery/pkg/apimachinery/registered\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/client-go/pkg/api\"\n\t\"k8s.io/client-go/pkg/apis/autoscaling\"\n\t\"k8s.io/client-go/pkg/apis/autoscaling/v1\"\n)\n\n\n\n\nfunc Install(groupFactoryRegistry announced.APIGroupFactoryRegistry, registry *registered.APIRegistrationManager, scheme *runtime.Scheme) {\n\tif err := announced.NewGroupMetaFactory(\n\t\t&announced.GroupMetaFactoryArgs{\n\t\t\tGroupName:                  autoscaling.GroupName,\n\t\t\tVersionPreferenceOrder:     []string{v1.SchemeGroupVersion.Version},\n\t\t\tImportPrefix:               \"k8s.io/client-go/pkg/apis/autoscaling\",\n\t\t\tAddInternalObjectsToScheme: autoscaling.AddToScheme,\n\t\t},\n\t\tannounced.VersionToSchemeFunc{\n\t\t\tv1.SchemeGroupVersion.Version: v1.AddToScheme,\n\t\t},\n\t).Announce(groupFactoryRegistry).RegisterAndEnable(registry, scheme); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc init() ", "output": "{\n\tInstall(api.GroupFactoryRegistry, api.Registry, api.Scheme)\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/go-gl/gl/v3.3-core/gl\"\n)\n\ntype Buffer interface {\n}\n\ntype GLBuffer struct {\n\tid          uint32\n\tbufferBytes int\n\ttarget      uint32\n}\n\nfunc NewGLBuffer(target uint32) (b *GLBuffer) {\n\tb = &GLBuffer{\n\t\ttarget: target,\n\t}\n\tgl.GenBuffers(1, &b.id)\n\tb.Bind()\n\treturn\n}\n\n\n\nfunc (b *GLBuffer) Bind() {\n\tgl.BindBuffer(b.target, b.id)\n}\n\nfunc (b *GLBuffer) Delete() {\n\tgl.DeleteBuffers(1, &b.id)\n}\n\nfunc (b *GLBuffer) Upload(data interface{}, size int) {\n\tb.Bind()\n\tif size > b.bufferBytes {\n\t\tb.bufferBytes = size\n\t\tgl.BufferData(b.target, size, gl.Ptr(data), gl.STREAM_DRAW)\n\t} else {\n\t\tgl.BufferSubData(b.target, 0, size, gl.Ptr(data))\n\t}\n}\n\nfunc (b *GLBuffer) Size() int {\n\treturn b.bufferBytes\n}\n\ntype UniformBuffer struct {\n\t*GLBuffer\n}\n\nfunc NewUniformBuffer() (b *UniformBuffer) {\n\tb = &UniformBuffer{\n\t\tGLBuffer: NewGLBuffer(gl.UNIFORM_BUFFER),\n\t}\n\treturn\n}\n\ntype ArrayBuffer struct {\n\t*GLBuffer\n}\n\nfunc NewArrayBuffer() (b *ArrayBuffer) {\n\tb = &ArrayBuffer{\n\t\tGLBuffer: NewGLBuffer(gl.ARRAY_BUFFER),\n\t}\n\treturn\n}\n\nfunc (b *GLBuffer) BufferID() uint32 ", "output": "{\n\treturn b.id\n}"}
{"input": "package operations\n\n\n\n\nimport (\n\t\"github.com/go-swagger/go-swagger/client\"\n\thttptransport \"github.com/go-swagger/go-swagger/httpkit/client\"\n\t\"github.com/go-swagger/go-swagger/spec\"\n\t\"github.com/go-swagger/go-swagger/strfmt\"\n\n\t\"github.com/jawspeak/go-jira-restclient/client/operations\"\n)\n\n\nvar Default = NewHTTPClient(nil)\n\n\n\n\n\nfunc New(transport client.Transport, formats strfmt.Registry) *JiraRestAPI {\n\tcli := new(JiraRestAPI)\n\tcli.Transport = transport\n\n\tcli.Operations = operations.New(transport, formats)\n\n\treturn cli\n}\n\n\ntype JiraRestAPI struct {\n\tOperations *operations.Client\n\n\tTransport client.Transport\n}\n\n\nfunc (c *JiraRestAPI) SetTransport(transport client.Transport) {\n\tc.Transport = transport\n\n\tc.Operations.SetTransport(transport)\n\n}\n\nfunc NewHTTPClient(formats strfmt.Registry) *JiraRestAPI ", "output": "{\n\tswaggerSpec, err := spec.New(SwaggerJSON, \"\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif formats == nil {\n\t\tformats = strfmt.Default\n\t}\n\treturn New(httptransport.New(swaggerSpec), formats)\n}"}
{"input": "package mcore\n\nimport (\n)\n\n\n\nfunc ExampleNewRandom() ", "output": "{\n\tfor i := 0; i < 100; i++ {\n\t\tprintln(i, \":\", NewRandom())\n\t}\n\n\tprintln(\"======================================\")\n\n\tfor i := 0; i < 100; i++ {\n\t\tprintln(i, \":\", NewRangeRandom(1000000))\n\t}\n\n}"}
{"input": "package operations\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/runtime/middleware\"\n\t\"github.com/go-openapi/validate\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n)\n\n\n\nfunc NewGetPoolSitesParams() GetPoolSitesParams {\n\n\treturn GetPoolSitesParams{}\n}\n\n\n\n\n\ntype GetPoolSitesParams struct {\n\n\tHTTPRequest *http.Request `json:\"-\"`\n\n\tAuthorization string\n\tID string\n}\n\n\n\n\n\n\n\n\nfunc (o *GetPoolSitesParams) bindAuthorization(rawData []string, hasKey bool, formats strfmt.Registry) error {\n\tif !hasKey {\n\t\treturn errors.Required(\"authorization\", \"header\")\n\t}\n\tvar raw string\n\tif len(rawData) > 0 {\n\t\traw = rawData[len(rawData)-1]\n\t}\n\n\n\tif err := validate.RequiredString(\"authorization\", \"header\", raw); err != nil {\n\t\treturn err\n\t}\n\n\to.Authorization = raw\n\n\treturn nil\n}\n\n\nfunc (o *GetPoolSitesParams) bindID(rawData []string, hasKey bool, formats strfmt.Registry) error {\n\tvar raw string\n\tif len(rawData) > 0 {\n\t\traw = rawData[len(rawData)-1]\n\t}\n\n\n\to.ID = raw\n\n\treturn nil\n}\n\nfunc (o *GetPoolSitesParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error ", "output": "{\n\tvar res []error\n\n\to.HTTPRequest = r\n\n\tif err := o.bindAuthorization(r.Header[http.CanonicalHeaderKey(\"authorization\")], true, route.Formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\trID, rhkID, _ := route.Params.GetOK(\"id\")\n\tif err := o.bindID(rID, rhkID, route.Formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package console\n\nimport (\n\t\"reflect\"\n\n\tv1 \"github.com/cgrates/cgrates/apier/v1\"\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\n\n\n\ntype CmdRemRatingProfile struct {\n\tname      string\n\trpcMethod string\n\trpcParams *v1.AttrRemoveRatingProfile\n\trpcResult string\n\t*CommandExecuter\n}\n\nfunc (self *CmdRemRatingProfile) Name() string {\n\treturn self.name\n}\n\nfunc (self *CmdRemRatingProfile) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\nfunc (self *CmdRemRatingProfile) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &v1.AttrRemoveRatingProfile{}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *CmdRemRatingProfile) PostprocessRpcParams() error {\n\tif reflect.DeepEqual(self.rpcParams, &v1.AttrRemoveRatingProfile{}) {\n\t\treturn utils.ErrMandatoryIeMissing\n\t}\n\treturn nil\n}\n\nfunc (self *CmdRemRatingProfile) RpcResult() interface{} {\n\tvar s string\n\treturn &s\n}\n\nfunc init() ", "output": "{\n\tc := &CmdRemRatingProfile{\n\t\tname:      \"ratingprofile_remove\",\n\t\trpcMethod: utils.APIerSv1RemoveRatingProfile,\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}"}
{"input": "package querying\n\nimport (\n\t. \"github.com/herald-it/goncord/models\"\n\t\"gopkg.in/mgo.v2\"\n)\n\n\n\n\n\n\n\nfunc IsExistUser(obj *User, c *mgo.Collection) bool {\n\treturn IsExistUserByLoginOrEmail(obj.Login, obj.Email, c)\n}\n\nfunc IsExistDumpToken(obj *DumpToken, c *mgo.Collection) (bool, error) ", "output": "{\n\tdumpToken, err := FindDumpToken(obj, c)\n\treturn dumpToken != nil && err == nil, err\n}"}
{"input": "package tokencontext\n\nimport (\n\t\"context\"\n)\n\ntype contextTMKey int\n\nconst (\n\t_ = iota\n\tcontextTokenManagerKey contextTMKey = iota\n\tautzSpaceServiceKey int = iota\n)\n\n\n\n\nfunc ReadTokenManagerFromContext(ctx context.Context) interface{} {\n\treturn ctx.Value(contextTokenManagerKey)\n}\n\n\n\n\n\n\n\n\n\nfunc ContextWithTokenManager(ctx context.Context, tm interface{}) context.Context {\n\treturn context.WithValue(ctx, contextTokenManagerKey, tm)\n}\n\n\n\n\nfunc ContextWithSpaceAuthzService(ctx context.Context, s interface{}) context.Context {\n\treturn context.WithValue(ctx, autzSpaceServiceKey, s)\n}\n\nfunc ReadSpaceAuthzServiceFromContext(ctx context.Context) interface{} ", "output": "{\n\treturn ctx.Value(autzSpaceServiceKey)\n}"}
{"input": "package operationalinsights\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc UserAgent() string {\n\treturn \"Azure-SDK-For-Go/\" + version.Number + \" operationalinsights/2015-11-01-preview\"\n}\n\n\n\n\n\nfunc Version() string ", "output": "{\n\treturn version.Number\n}"}
{"input": "package gcetasks\n\nimport (\n\t\"encoding/json\"\n\n\t\"k8s.io/kops/upup/pkg/fi\"\n)\n\n\n\n\ntype realAddress Address\n\n\nfunc (o *Address) UnmarshalJSON(data []byte) error {\n\tvar jsonName string\n\tif err := json.Unmarshal(data, &jsonName); err == nil {\n\t\to.Name = &jsonName\n\t\treturn nil\n\t}\n\n\tvar r realAddress\n\tif err := json.Unmarshal(data, &r); err != nil {\n\t\treturn err\n\t}\n\t*o = Address(r)\n\treturn nil\n}\n\nvar _ fi.HasLifecycle = &Address{}\n\n\n\n\n\nfunc (o *Address) SetLifecycle(lifecycle fi.Lifecycle) {\n\to.Lifecycle = &lifecycle\n}\n\nvar _ fi.HasName = &Address{}\n\n\nfunc (o *Address) GetName() *string {\n\treturn o.Name\n}\n\n\nfunc (o *Address) SetName(name string) {\n\to.Name = &name\n}\n\n\nfunc (o *Address) String() string {\n\treturn fi.TaskAsString(o)\n}\n\nfunc (o *Address) GetLifecycle() *fi.Lifecycle ", "output": "{\n\treturn o.Lifecycle\n}"}
{"input": "package mount\n\nimport \"errors\"\n\n\ntype Mounts []*Mount\n\n\nfunc (ms Mounts) ContainsMount(containsMount *Mount) bool {\n\tfor _, sliceMount := range ms {\n\t\tif containsMount == sliceMount {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n\n\n\n\nfunc (ms Mounts) FindByName(name string) (*Mount, bool) {\n\tfor _, m := range ms {\n\t\tif m.MountName == name {\n\t\t\treturn m, true\n\t\t}\n\t}\n\n\treturn nil, false\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (ms Mounts) IsDuplicate(ip, remote, local string) bool {\n\tfor _, m := range ms {\n\t\tif m.LocalPath == local {\n\t\t\treturn true\n\t\t}\n\n\t\tif m.IP == ip && m.RemotePath == remote {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\n\n\n\nfunc (ms Mounts) GetByLocalPath(local string) *Mount {\n\tfor _, m := range ms {\n\t\tif m.LocalPath == local {\n\t\t\treturn m\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (ms Mounts) RemoveByName(name string) (Mounts, error) ", "output": "{\n\tfor i, m := range ms {\n\t\tif m.MountName == name {\n\t\t\treturn append(ms[:i], ms[i+1:]...), nil\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"Name not found\")\n}"}
{"input": "package meta\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n\n\n\ntype Cuepoint string\n\n\nfunc (m Cuepoint) Text() string {\n\treturn string(m)\n}\n\n\nfunc (m Cuepoint) Raw() []byte {\n\treturn (&metaMessage{\n\t\tTyp:  byte(byteCuepoint),\n\t\tData: []byte(m),\n\t}).Bytes()\n}\n\n\nfunc (m Cuepoint) String() string {\n\treturn fmt.Sprintf(\"%T: %#v\", m, m.Text())\n}\n\n\n\nfunc (m Cuepoint) meta() {}\n\nfunc (m Cuepoint) readFrom(rd io.Reader) (Message, error) ", "output": "{\n\ttext, err := readText(rd)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn Cuepoint(text), nil\n}"}
{"input": "package matchers\n\nimport (\n\t\"fmt\"\n\t\"github.com/bfontaine/go-tchoutchou/Godeps/_workspace/src/github.com/onsi/gomega/format\"\n\t\"reflect\"\n)\n\ntype BeEquivalentToMatcher struct {\n\tExpected interface{}\n}\n\nfunc (matcher *BeEquivalentToMatcher) Match(actual interface{}) (success bool, err error) {\n\tif actual == nil && matcher.Expected == nil {\n\t\treturn false, fmt.Errorf(\"Both actual and expected must not be nil.\")\n\t}\n\n\tconvertedActual := actual\n\n\tif actual != nil && matcher.Expected != nil && reflect.TypeOf(actual).ConvertibleTo(reflect.TypeOf(matcher.Expected)) {\n\t\tconvertedActual = reflect.ValueOf(actual).Convert(reflect.TypeOf(matcher.Expected)).Interface()\n\t}\n\n\treturn reflect.DeepEqual(convertedActual, matcher.Expected), nil\n}\n\nfunc (matcher *BeEquivalentToMatcher) FailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, \"to be equivalent to\", matcher.Expected)\n}\n\n\n\nfunc (matcher *BeEquivalentToMatcher) NegatedFailureMessage(actual interface{}) (message string) ", "output": "{\n\treturn format.Message(actual, \"not to be equivalent to\", matcher.Expected)\n}"}
{"input": "package bunyan\n\nimport \"fmt\"\n\n\ntype Logger struct {\n\tsink   Sink\n\trecord Record\n}\n\n\nfunc NewLogger(target Sink) *Logger {\n\treturn &Logger{target, NewRecord()}\n}\n\n\n\nfunc (l *Logger) Write(record Record) error {\n\trecord.TemplateMerge(l.record)\n\treturn l.sink.Write(record)\n}\n\n\n\nfunc (l *Logger) Include(info Info) Log {\n\treturn NewLogger(InfoSink(l, info))\n}\n\n\n\n\n\n\n\nfunc (l *Logger) Recordf(key, value string, args ...interface{}) Log {\n\treturn l.Record(key, fmt.Sprintf(value, args...))\n}\n\n\n\nfunc (l *Logger) Child() Log {\n\treturn NewLogger(l)\n}\n\nfunc (l *Logger) Tracef(msg string, args ...interface{}) { l.send(TRACE, msg, args...) }\nfunc (l *Logger) Debugf(msg string, args ...interface{}) { l.send(DEBUG, msg, args...) }\nfunc (l *Logger) Infof(msg string, args ...interface{})  { l.send(INFO, msg, args...) }\nfunc (l *Logger) Warnf(msg string, args ...interface{})  { l.send(WARN, msg, args...) }\nfunc (l *Logger) Errorf(msg string, args ...interface{}) { l.send(ERROR, msg, args...) }\nfunc (l *Logger) Fatalf(msg string, args ...interface{}) { l.send(FATAL, msg, args...) }\n\nfunc (l *Logger) send(level Level, msg string, args ...interface{}) {\n\trecord := NewRecord()\n\trecord.SetMessagef(level, msg, args...)\n\te := l.Write(record)\n\n\tif e != nil {\n\t\tpanic(e)\n\t}\n}\n\nfunc (l *Logger) Record(key string, value interface{}) Log ", "output": "{\n\tbuilder := NewLogger(l)\n\tbuilder.record[key] = value\n\treturn builder\n}"}
{"input": "package errors\n\nimport \"fmt\"\n\ntype Error struct {\n\terr string\n}\n\nfunc New(message string, args ...interface{}) error {\n\treturn Error{err: \"goqu: \" + fmt.Sprintf(message, args...)}\n}\n\nfunc NewEncodeError(t interface{}) error {\n\treturn Error{err: \"goqu_encode_error: \" + fmt.Sprintf(\"Unable to encode value %+v\", t)}\n}\n\n\n\nfunc (e Error) Error() string ", "output": "{\n\treturn e.err\n}"}
{"input": "package core\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/oci/oci-go-sdk/v43/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ListLocalPeeringGatewaysRequest struct {\n\n\tCompartmentId *string `mandatory:\"true\" contributesTo:\"query\" name:\"compartmentId\"`\n\n\tLimit *int `mandatory:\"false\" contributesTo:\"query\" name:\"limit\"`\n\n\tPage *string `mandatory:\"false\" contributesTo:\"query\" name:\"page\"`\n\n\tVcnId *string `mandatory:\"false\" contributesTo:\"query\" name:\"vcnId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request ListLocalPeeringGatewaysRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request ListLocalPeeringGatewaysRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request ListLocalPeeringGatewaysRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request ListLocalPeeringGatewaysRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ListLocalPeeringGatewaysResponse struct {\n\n\tRawResponse *http.Response\n\n\tItems []LocalPeeringGateway `presentIn:\"body\"`\n\n\tOpcNextPage *string `presentIn:\"header\" name:\"opc-next-page\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\n\n\n\nfunc (response ListLocalPeeringGatewaysResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response ListLocalPeeringGatewaysResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package common\n\nimport (\n\t\"bytes\"\n\n\t\"k8s.io/kubernetes/pkg/api\"\n)\n\n\ntype Endpoint struct {\n\tHost string `json:\"host\"`\n\n\tPorts []ServicePort `json:\"ports\"`\n}\n\n\n\n\n\n\nfunc GetInternalEndpoint(serviceName, namespace string, ports []api.ServicePort) Endpoint {\n\tname := serviceName\n\n\tif namespace != api.NamespaceDefault && len(namespace) > 0 && len(serviceName) > 0 {\n\t\tbufferName := bytes.NewBufferString(name)\n\t\tbufferName.WriteString(\".\")\n\t\tbufferName.WriteString(namespace)\n\t\tname = bufferName.String()\n\t}\n\n\treturn Endpoint{\n\t\tHost:  name,\n\t\tPorts: GetServicePorts(ports),\n\t}\n}\n\n\nfunc getExternalEndpoint(ingress api.LoadBalancerIngress, ports []api.ServicePort) Endpoint {\n\tvar host string\n\tif ingress.Hostname != \"\" {\n\t\thost = ingress.Hostname\n\t} else {\n\t\thost = ingress.IP\n\t}\n\treturn Endpoint{\n\t\tHost:  host,\n\t\tPorts: GetServicePorts(ports),\n\t}\n}\n\n\nfunc GetNodeByName(nodes []api.Node, nodeName string) *api.Node {\n\tfor _, node := range nodes {\n\t\tif node.ObjectMeta.Name == nodeName {\n\t\t\treturn &node\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc GetExternalEndpoints(service *api.Service) []Endpoint ", "output": "{\n\tvar externalEndpoints []Endpoint\n\tif service.Spec.Type == api.ServiceTypeLoadBalancer {\n\t\tfor _, ingress := range service.Status.LoadBalancer.Ingress {\n\t\t\texternalEndpoints = append(externalEndpoints, getExternalEndpoint(ingress, service.Spec.Ports))\n\t\t}\n\t}\n\n\tfor _, ip := range service.Spec.ExternalIPs {\n\t\texternalEndpoints = append(externalEndpoints, Endpoint{\n\t\t\tHost:  ip,\n\t\t\tPorts: GetServicePorts(service.Spec.Ports),\n\t\t})\n\t}\n\n\treturn externalEndpoints\n}"}
{"input": "package sync\n\nimport (\n\t\"sync/atomic\"\n)\n\nconst supportsWakeSuppression = true\n\n\nfunc addrOfSpinning() *int32\n\n\nvar nmspinning = addrOfSpinning()\n\n\n\nfunc postGoReadyWakeSuppression() {\n\tatomic.AddInt32(nmspinning, -1)\n}\n\nfunc preGoReadyWakeSuppression() ", "output": "{\n\tatomic.AddInt32(nmspinning, 1)\n}"}
{"input": "package cs\n\nimport (\n\t\"github.com/scionproto/scion/go/cs/beacon\"\n\t\"github.com/scionproto/scion/go/cs/config\"\n\t\"github.com/scionproto/scion/go/lib/serrors\"\n)\n\n\n\n\n\nfunc LoadNonCorePolicies(cfg config.Policies) (beacon.Policies, error) {\n\tvar err error\n\tvar policies beacon.Policies\n\tif policies.Prop, err = loadPolicy(cfg.Propagation, beacon.PropPolicy); err != nil {\n\t\treturn policies, err\n\t}\n\tif policies.UpReg, err = loadPolicy(cfg.UpRegistration, beacon.UpRegPolicy); err != nil {\n\t\treturn policies, err\n\t}\n\tif policies.DownReg, err = loadPolicy(cfg.DownRegistration, beacon.DownRegPolicy); err != nil {\n\t\treturn policies, err\n\t}\n\treturn policies, nil\n}\n\nfunc loadPolicy(fn string, t beacon.PolicyType) (beacon.Policy, error) {\n\tvar policy beacon.Policy\n\tif fn != \"\" {\n\t\tp, err := beacon.LoadPolicyFromYaml(fn, t)\n\t\tif err != nil {\n\t\t\treturn policy, serrors.WrapStr(\"loading beaconing policy\", err, \"file\", fn, \"type\", t)\n\t\t}\n\t\tpolicy = *p\n\t}\n\tpolicy.InitDefaults()\n\treturn policy, nil\n}\n\nfunc LoadCorePolicies(cfg config.Policies) (beacon.CorePolicies, error) ", "output": "{\n\tvar err error\n\tvar policies beacon.CorePolicies\n\tif policies.Prop, err = loadPolicy(cfg.Propagation, beacon.PropPolicy); err != nil {\n\t\treturn policies, err\n\t}\n\tif policies.CoreReg, err = loadPolicy(cfg.CoreRegistration, beacon.CoreRegPolicy); err != nil {\n\t\treturn policies, err\n\t}\n\treturn policies, nil\n}"}
{"input": "package geetplaban\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc TestUtil(t *testing.T) ", "output": "{\n\tx := NewRandomUUID()\n\tif x == nil {\n\t\tt.Fatalf(\"Invalid value returned\")\n\t} else {\n\t\tfmt.Printf(\"UUID %v\\n\", x)\n\t}\n\tx = NewRandomUUID()\n\tif x == nil {\n\t\tt.Fatalf(\"Invalid value returned\")\n\t} else {\n\t\tfmt.Printf(\"UUID %v\\n\", x)\n\t}\n}"}
{"input": "package packer\n\nimport (\n\t\"sync\"\n)\n\n\n\ntype Provisioner interface {\n\tPrepare(...interface{}) error\n\n\tProvision(Ui, Communicator) error\n\n\tCancel()\n}\n\n\ntype ProvisionHook struct {\n\tProvisioners []Provisioner\n\n\tlock               sync.Mutex\n\trunningProvisioner Provisioner\n}\n\n\nfunc (h *ProvisionHook) Run(name string, ui Ui, comm Communicator, data interface{}) error {\n\tdefer func() {\n\t\th.lock.Lock()\n\t\tdefer h.lock.Unlock()\n\n\t\th.runningProvisioner = nil\n\t}()\n\n\tfor _, p := range h.Provisioners {\n\t\th.lock.Lock()\n\t\th.runningProvisioner = p\n\t\th.lock.Unlock()\n\n\t\tif err := p.Provision(ui, comm); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n\n\n\nfunc (h *ProvisionHook) Cancel() ", "output": "{\n\th.lock.Lock()\n\tdefer h.lock.Unlock()\n\n\tif h.runningProvisioner != nil {\n\t\th.runningProvisioner.Cancel()\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/go-svc/svc/examples/grpc-fixed-lb/pb\"\n\t\"github.com/jinzhu/gorm\"\n\t_ \"github.com/jinzhu/gorm/dialects/sqlite\"\n\t\"google.golang.org/grpc\"\n)\n\n\nvar port string\n\n\ntype server struct {\n\tdb *gorm.DB\n}\n\n\nfunc (s *server) Add(ctx context.Context, in *pb.Task) (*pb.Task, error) {\n\ts.db.Create(in)\n\treturn in, nil\n}\n\n\nfunc (s *server) List(ctx context.Context, in *pb.Void) (*pb.Tasks, error) {\n\tvar tasks []*pb.Task\n\ts.db.Find(&tasks)\n\n\treturn &pb.Tasks{Tasks: tasks}, nil\n}\n\n\n\n\nfunc main() {\n\tport = os.Args[0]\n\tif len(os.Args) == 2 {\n\t\tport = os.Args[1]\n\t}\n\n\tlis, err := net.Listen(\"tcp\", \":\"+port)\n\tif err != nil {\n\t\tlog.Fatalf(\"無法監聽該埠口：%v\", err)\n\t}\n\n\ts := grpc.NewServer()\n\tpb.RegisterTodoServer(s, &server{\n\t\tdb: newConnection(),\n\t})\n\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"無法提供服務：%v\", err)\n\t}\n}\n\nfunc newConnection() *gorm.DB ", "output": "{\n\tdb, _ := gorm.Open(\"sqlite3\", \"/tmp/gorm.db\")\n\tdb.DropTableIfExists(&pb.Task{})\n\tdb.CreateTable(&pb.Task{})\n\treturn db\n}"}
{"input": "package system\n\nimport (\n\t\"github.com/golang/glog\"\n\t\"k8s.io/kubernetes/pkg/util/errors\"\n)\n\n\ntype Validator interface {\n\tName() string\n\tValidate(SysSpec) error\n}\n\n\nvar validators = []Validator{\n\t&OSValidator{},\n\t&KernelValidator{},\n\t&CgroupsValidator{},\n\t&DockerValidator{},\n}\n\n\n\n\nfunc Validate() error ", "output": "{\n\tvar errs []error\n\tspec := DefaultSysSpec\n\tfor _, v := range validators {\n\t\tglog.Infof(\"Validating %s...\", v.Name())\n\t\terrs = append(errs, v.Validate(spec))\n\t}\n\treturn errors.NewAggregate(errs)\n}"}
{"input": "package syscall\n\nimport \"unsafe\"\n\n\n\nfunc naclClose(fd int) (err error) {\n\t_, _, e1 := Syscall(sys_close, uintptr(fd), 0, 0)\n\tif e1 != 0 {\n\t\terr = errnoErr(e1)\n\t}\n\treturn\n}\n\n\n\nfunc Exit(code int) (err error) {\n\t_, _, e1 := Syscall(sys_exit, uintptr(code), 0, 0)\n\tif e1 != 0 {\n\t\terr = errnoErr(e1)\n\t}\n\treturn\n}\n\n\n\nfunc naclFstat(fd int, stat *Stat_t) (err error) {\n\t_, _, e1 := Syscall(sys_fstat, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)\n\tif e1 != 0 {\n\t\terr = errnoErr(e1)\n\t}\n\treturn\n}\n\n\n\n\n\n\n\nfunc naclSeek(fd int, off *int64, whence int) (err error) {\n\t_, _, e1 := Syscall(sys_lseek, uintptr(fd), uintptr(unsafe.Pointer(off)), uintptr(whence))\n\tif e1 != 0 {\n\t\terr = errnoErr(e1)\n\t}\n\treturn\n}\n\n\n\nfunc naclGetRandomBytes(b []byte) (err error) {\n\tvar _p0 unsafe.Pointer\n\tif len(b) > 0 {\n\t\t_p0 = unsafe.Pointer(&b[0])\n\t} else {\n\t\t_p0 = unsafe.Pointer(&_zero)\n\t}\n\t_, _, e1 := Syscall(sys_get_random_bytes, uintptr(_p0), uintptr(len(b)), 0)\n\tif e1 != 0 {\n\t\terr = errnoErr(e1)\n\t}\n\treturn\n}\n\nfunc naclRead(fd int, b []byte) (n int, err error) ", "output": "{\n\tvar _p0 unsafe.Pointer\n\tif len(b) > 0 {\n\t\t_p0 = unsafe.Pointer(&b[0])\n\t} else {\n\t\t_p0 = unsafe.Pointer(&_zero)\n\t}\n\tr0, _, e1 := Syscall(sys_read, uintptr(fd), uintptr(_p0), uintptr(len(b)))\n\tn = int(r0)\n\tif e1 != 0 {\n\t\terr = errnoErr(e1)\n\t}\n\treturn\n}"}
{"input": "package testutil\n\nimport (\n\t\"testing\"\n\n\t\"github.com/tendermint/abci/server\"\n\twire \"github.com/tendermint/go-wire\"\n\t\"github.com/tendermint/merkleeyes/app\"\n\teyes \"github.com/tendermint/merkleeyes/client\"\n\t. \"github.com/tendermint/tmlibs/common\"\n)\n\n\nfunc CreateEyes(t *testing.T) (svr Service, cli *eyes.Client) {\n\taddr := \"unix://eyes.sock\"\n\n\tmApp := app.NewMerkleEyesApp(\"\", 0)\n\tsvr, err := server.NewServer(addr, \"socket\", mApp)\n\tif err != nil {\n\t\t(err.Error())\n\t\treturn\n\t}\n\n\tcli, err = eyes.NewClient(addr)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t\treturn\n\t}\n\n\treturn svr, cli\n}\n\n\nfunc MakeTxKV() ([]byte, []byte, []byte) {\n\tk := []byte(RandStr(8))\n\tv := []byte(RandStr(8))\n\treturn k, v, makeSet(k, v)\n}\n\n\n\n\n\nfunc makeSet(key, value []byte) []byte ", "output": "{\n\ttx := make([]byte, 1+wire.ByteSliceSize(key)+wire.ByteSliceSize(value))\n\tbuf := tx\n\tbuf[0] = app.TxTypeSet \n\tbuf = buf[1:]\n\tn, err := wire.PutByteSlice(buf, key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tbuf = buf[n:]\n\tn, err = wire.PutByteSlice(buf, value)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn tx\n}"}
{"input": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"golang.org/x/tools/go/packages\"\n)\n\n\n\nfunc Test_copyrightRenderer_sort(t *testing.T) {\n\tr := copyrightRenderer{}\n\tps := []licPkg{somePackage(\"x/y\", false, &apache2Short), somePackage(\"b/c\", true, &mit), somePackage(\"a/b\", false, &bsd2)}\n\tr.sort(ps)\n\tassert.Equal(t, \"b/c\", ps[0].PkgPath)\n\tassert.Equal(t, \"a/b\", ps[1].PkgPath)\n\tassert.Equal(t, \"x/y\", ps[2].PkgPath)\n}\n\nfunc somePackage(path string, root bool, l *license) licPkg {\n\treturn licPkg{\n\t\tlicense: l,\n\t\tpkgWithLicenseFile: &pkgWithLicenseFile{\n\t\t\tpkg: &pkg{\n\t\t\t\troot: root,\n\t\t\t\tPackage: &packages.Package{\n\t\t\t\t\tPkgPath: path,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc Test_copyrightRenderer_render_no_pkgs(t *testing.T) {\n\tc := copyrightRenderer{}\n\terr := c.render(ioutil.Discard)\n\tassert.Error(t, err)\n}\n\nfunc Test_copyrightRenderer_hasLicense(t *testing.T) {\n\tc := copyrightRenderer{}\n\tassert.False(t, c.hasLicense(somePackage(\"x\", false, nil)))\n\tassert.True(t, c.hasLicense(somePackage(\"y\", false, &mit)))\n}\n\nfunc TestRender(t *testing.T) ", "output": "{\n\tpkgs, _ := xPackagesScanner{}.scan(depScannerOptions{\n\t\tenvPermutations: [][]string{nil},\n\t\ttests:           false,\n\t}, \"github.com/bpicode/fritzctl\")\n\twithLicenseFiles, _ := licenceFileResolver{}.resolve(pkgs...)\n\n\tlicPkgs, _ := licenseFileAnalizer{}.analyze(withLicenseFiles...)\n\tcopyrightRenderer{}.render(os.Stdout, licPkgs...)\n}"}
{"input": "package event\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"sync\"\n)\n\nvar (\n\tlistenersMutex sync.RWMutex \n\tlisteners      = make(map[reflect.Type][]interface{})\n\tinterfaces     = make([]reflect.Type, 0)\n)\n\n\n\ntype BadListenerError string\n\nfunc (why BadListenerError) Error() string {\n\treturn fmt.Sprintf(\"bad listener func: %s\", string(why))\n}\n\n\n\n\nfunc AddListener(fn interface{}) {\n\tlistenersMutex.Lock()\n\tdefer listenersMutex.Unlock()\n\n\tfnType := reflect.TypeOf(fn)\n\n\tswitch {\n\tcase fnType.Kind() != reflect.Func:\n\t\tpanic(BadListenerError(\"listener must be a function\"))\n\tcase fnType.NumIn() != 1:\n\t\tpanic(BadListenerError(\"listener must take exactly one input argument\"))\n\t}\n\n\tevType := fnType.In(0)\n\n\tlisteners[evType] = append(listeners[evType], fn)\n\n\tif evType.Kind() == reflect.Interface {\n\t\tinterfaces = append(interfaces, evType)\n\t}\n}\n\n\n\nfunc Dispatch(ev interface{}) {\n\tlistenersMutex.RLock()\n\tdefer listenersMutex.RUnlock()\n\n\tevType := reflect.TypeOf(ev)\n\tvals := []reflect.Value{reflect.ValueOf(ev)}\n\n\tcallListeners(evType, vals)\n\n\tfor _, in := range interfaces {\n\t\tif evType.Implements(in) {\n\t\t\tcallListeners(in, vals)\n\t\t}\n\t}\n}\n\n\n\nfunc callListeners(t reflect.Type, vals []reflect.Value) ", "output": "{\n\tfor _, fn := range listeners[t] {\n\t\treflect.ValueOf(fn).Call(vals)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"io\"\n\n\t\"github.com/juju/ratelimit\"\n)\n\ntype limitedWriter struct {\n\tw      io.Writer\n\tbucket *ratelimit.Bucket\n}\n\n\n\nfunc (w *limitedWriter) Write(buf []byte) (int, error) ", "output": "{\n\tif w.bucket != nil {\n\t\tw.bucket.Wait(int64(len(buf)))\n\t}\n\treturn w.w.Write(buf)\n}"}
{"input": "package loadbalancer\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n)\n\n\ntype IpAddress struct {\n\n\tIpAddress *string `mandatory:\"true\" json:\"ipAddress\"`\n\n\tIsPublic *bool `mandatory:\"false\" json:\"isPublic\"`\n}\n\n\n\nfunc (m IpAddress) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package logging\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype terribadLogMessage struct{}\n\nfunc (msg terribadLogMessage) Message() string {\n\tpanic(\"never panic while logging; it's not worth crashing the app!\")\n}\n\nfunc (msg terribadLogMessage) EachField(fn FieldReportFn) {\n\tpanic(\"never panic while logging; it's not worth crashing the app!\")\n}\n\nfunc TestLogMessagePanicking(t *testing.T) {\n\tlog, ctrl := NewLogSinkSpy(true)\n\n\tassert.NotPanics(t, func() {\n\t\tDeliver(log, terribadLogMessage{})\n\t})\n\n\tcalls := ctrl.CallsTo(\"Fields\")\n\tif assert.Len(t, calls, 2) {\n\t\tfields := calls[1].PassedArgs().Get(0).([]EachFielder)\n\t\tassert.IsType(t, &silentMessageError{}, fields[2])\n\t}\n}\n\nfunc (msg terribadLogMessage) DefaultLevel() Level ", "output": "{\n\tpanic(\"never panic while logging; it's not worth crashing the app!\")\n}"}
{"input": "package event\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFGaugeDeltaUpdate(t *testing.T) {\n\te1 := &FGaugeDelta{Name: \"test\", Value: float64(15.1)}\n\te2 := &FGaugeDelta{Name: \"test\", Value: float64(-10.0)}\n\te3 := &FGaugeDelta{Name: \"test\", Value: float64(15.1)}\n\terr := e1.Update(e2)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\terr = e1.Update(e3)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\n\texpected := []string{\"test:+20.2|g\"}\n\tactual := e1.Stats()\n\tif !reflect.DeepEqual(expected, actual) {\n\t\tt.Errorf(\"did not receive all metrics: Expected: %T %v, Actual: %T %v \", expected, expected, actual, actual)\n\t}\n}\n\n\n\nfunc TestFGaugeDeltaUpdateNegative(t *testing.T) ", "output": "{\n\te1 := &FGaugeDelta{Name: \"test\", Value: float64(-15.1)}\n\te2 := &FGaugeDelta{Name: \"test\", Value: float64(10.0)}\n\te3 := &FGaugeDelta{Name: \"test\", Value: float64(-15.1)}\n\terr := e1.Update(e2)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\terr = e1.Update(e3)\n\tif nil != err {\n\t\tt.Error(err)\n\t}\n\n\texpected := []string{\"test:-20.2|g\"}\n\tactual := e1.Stats()\n\tif !reflect.DeepEqual(expected, actual) {\n\t\tt.Errorf(\"did not receive all metrics: Expected: %T %v, Actual: %T %v \", expected, expected, actual, actual)\n\t}\n}"}
{"input": "package pubsub_test\n\nimport (\n\t\"testing\"\n\n\t. \"v2ray.com/core/common/signal/pubsub\"\n)\n\n\n\nfunc TestPubsub(t *testing.T) ", "output": "{\n\tservice := NewService()\n\n\tsub := service.Subscribe(\"a\")\n\tservice.Publish(\"a\", 1)\n\n\tselect {\n\tcase v := <-sub.Wait():\n\t\tif v != 1 {\n\t\t\tt.Error(\"expected subscribed value 1, but got \", v)\n\t\t}\n\tdefault:\n\t\tt.Fail()\n\t}\n\n\tsub.Close()\n\tservice.Publish(\"a\", 2)\n\n\tselect {\n\tcase <-sub.Wait():\n\t\tt.Fail()\n\tdefault:\n\t}\n\n\tservice.Cleanup()\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSEMRInstanceFleetConfig_SpotProvisioningSpecification struct {\n\n\tBlockDurationMinutes int `json:\"BlockDurationMinutes,omitempty\"`\n\n\tTimeoutAction string `json:\"TimeoutAction,omitempty\"`\n\n\tTimeoutDurationMinutes int `json:\"TimeoutDurationMinutes\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) AWSCloudFormationType() string {\n\treturn \"AWS::EMR::InstanceFleetConfig.SpotProvisioningSpecification\"\n}\n\n\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\n\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) SetDeletionPolicy(policy policies.DeletionPolicy) ", "output": "{\n\tr._deletionPolicy = policy\n}"}
{"input": "package query\n\nfunc Parse(query string) (Expression, error) {\n\tscanner := NewScanner(query)\n\tparser := NewParser(scanner)\n\n\treturn parser.Parse()\n}\n\n\nfunc HasAll(tagNames []string) Expression {\n\tif len(tagNames) == 0 {\n\t\treturn EmptyExpression{}\n\t}\n\n\tvar expression Expression = TagExpression{tagNames[0]}\n\n\tfor _, tagName := range tagNames[1:] {\n\t\texpression = AndExpression{expression, TagExpression{tagName}}\n\t}\n\n\treturn expression\n}\n\n\nfunc TagNames(expression Expression) []string {\n\tnames := make([]string, 0, 10)\n\tnames = tagNames(expression, names)\n\n\treturn names\n}\n\n\nfunc ValueNames(expression Expression) []string {\n\tnames := make([]string, 0, 10)\n\tnames = valueNames(expression, names)\n\n\treturn names\n}\n\n\n\nfunc tagNames(expression Expression, names []string) []string {\n\tswitch exp := expression.(type) {\n\tcase TagExpression:\n\t\tnames = append(names, exp.Name)\n\tcase NotExpression:\n\t\tnames = tagNames(exp.Operand, names)\n\tcase AndExpression:\n\t\tnames = tagNames(exp.LeftOperand, names)\n\t\tnames = tagNames(exp.RightOperand, names)\n\tcase OrExpression:\n\t\tnames = tagNames(exp.LeftOperand, names)\n\t\tnames = tagNames(exp.RightOperand, names)\n\tcase ComparisonExpression:\n\t\tnames = append(names, exp.Tag.Name)\n\tdefault:\n\t\tpanic(\"unsupported token type\")\n\t}\n\n\treturn names\n}\n\n\n\nfunc valueNames(expression Expression, names []string) []string ", "output": "{\n\tswitch exp := expression.(type) {\n\tcase TagExpression:\n\tcase NotExpression:\n\t\tnames = valueNames(exp.Operand, names)\n\tcase AndExpression:\n\t\tnames = valueNames(exp.LeftOperand, names)\n\t\tnames = valueNames(exp.RightOperand, names)\n\tcase OrExpression:\n\t\tnames = valueNames(exp.LeftOperand, names)\n\t\tnames = valueNames(exp.RightOperand, names)\n\tcase ComparisonExpression:\n\t\tnames = append(names, exp.Value.Name)\n\tdefault:\n\t\tpanic(\"unsupported token type\")\n\t}\n\n\treturn names\n}"}
{"input": "package readline\n\nfunc (rl *Instance) insert(r []rune) {\n\tfor {\n\t\tif len(r) > 1 && (r[len(r)-1] == 0 || r[len(r)-1] == '\\r') {\n\t\t\tr = r[:len(r)-1]\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\tswitch {\n\tcase len(rl.line) == 0:\n\t\trl.line = r\n\tcase rl.pos == 0:\n\t\trl.line = append(r, rl.line...)\n\tcase rl.pos < len(rl.line):\n\t\tr := append(r, rl.line[rl.pos:]...)\n\t\trl.line = append(rl.line[:rl.pos], r...)\n\tdefault:\n\t\trl.line = append(rl.line, r...)\n\t}\n\n\trl.moveCursorByAdjust(len(r))\n\trl.echo()\n\n\tif rl.modeViMode == vimInsert {\n\t\trl.updateHelpers()\n\t}\n}\n\nfunc (rl *Instance) backspace() {\n\tif len(rl.line) == 0 || rl.pos == 0 {\n\t\treturn\n\t}\n\n\tmoveCursorBackwards(1)\n\trl.pos--\n\trl.delete()\n}\n\n\n\nfunc (rl *Instance) delete() ", "output": "{\n\tswitch {\n\tcase len(rl.line) == 0:\n\t\treturn\n\tcase rl.pos == 0:\n\t\trl.line = rl.line[1:]\n\t\trl.echo()\n\tcase rl.pos > len(rl.line):\n\t\trl.backspace()\n\tcase rl.pos == len(rl.line):\n\t\trl.line = rl.line[:rl.pos]\n\t\trl.echo()\n\tdefault:\n\t\trl.line = append(rl.line[:rl.pos], rl.line[rl.pos+1:]...)\n\t\trl.echo()\n\t}\n\n\trl.updateHelpers()\n}"}
{"input": "package store\n\nimport (\n\t\"time\"\n\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"github.com/russross/meddler\"\n\tsq \"github.com/Masterminds/squirrel\"\n)\n\ntype Feature struct {\n\tId        int64      `json:\"id\"                         meddler:\"id,pk\"`\n\tCreatedAt *time.Time `json:\"created_at,omitempty\"       meddler:\"created_at\"`\n\tName      *string    `json:\"name,omitempty\"             meddler:\"name\"`\n}\n\nfunc (s *store) GetFeatureByName(name string) (*Feature, error) {\n\tfeature := new(Feature)\n\n\tquery := sq.Select(\"*\").From(\"feature\")\n\tquery = query.Where(sq.Eq{\"name\": name})\n\n\tsql, args, err := query.ToSql()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlog.Debug(sql)\n\n\terr = meddler.QueryRow(s.db, feature, sql, args...)\n\n\treturn feature, err\n}\n\n\n\nfunc (s *store) CreateFeature(feature *Feature) error {\n\tfeature.CreatedAt = Time(time.Now())\n\treturn meddler.Insert(s.db, \"feature\", feature)\n}\n\nfunc (s *store) UpdateFeature(feature *Feature) error {\n\treturn meddler.Update(s.db, \"feature\", feature)\n}\n\nfunc (s *store) ListFeatures() ([]*Feature, error) ", "output": "{\n\tquery := sq.Select(\"*\").From(\"feature\")\n\n\tsql, args, err := query.ToSql()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlog.Debug(sql)\n\n\tfeatures := []*Feature{}\n\terr = meddler.QueryAll(s.db, &features, sql, args...)\n\n\treturn features, err\n}"}
{"input": "package rivet\n\nimport (\n\t\"net/http\"\n)\n\n\ntype Response struct {\n\tw      http.ResponseWriter\n\tstatus int\n\tsize   int\n}\n\n\nfunc NewResponse(rw http.ResponseWriter) *Response {\n\treturn &Response{rw, 0, 0}\n}\n\n\n\nfunc (r *Response) Flush() {\n\tif flusher, ok := r.w.(http.Flusher); ok {\n\t\tflusher.Flush()\n\t}\n}\n\n\nfunc (r *Response) WriteHeader(s int) {\n\tr.status = s\n\tr.w.WriteHeader(s)\n}\n\n\n\n\n\nfunc (r *Response) Status() int {\n\treturn r.status\n}\n\n\nfunc (r *Response) Size() int {\n\treturn r.size\n}\n\n\nfunc (r *Response) Written() bool {\n\treturn r.status != 0 || r.size != 0\n}\n\nfunc (r *Response) Write(b []byte) (int, error) ", "output": "{\n\tif !r.Written() {\n\t\tr.WriteHeader(http.StatusOK)\n\t}\n\tsize, err := r.w.Write(b)\n\tr.size += size\n\treturn size, err\n}"}
{"input": "package main\n\nimport (\n\t\"Algorithms-in-Golang/stack\"\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(\"程序开始\")\n\n\ts := \"( ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) )\"\n\tfmt.Println(s)\n\tr := infixToPostfix(s)\n\tfmt.Println(r)\n\n}\n\n\n\nfunc infixToPostfix(s string) string ", "output": "{\n\tstrs := stack.New()\n\tops := stack.New()\n\n\tss := strings.Split(s, \" \")\n\tfor _, v := range ss {\n\t\tswitch v {\n\t\tcase \"(\":\n\t\t\tcontinue\n\t\tcase \"+\", \"-\", \"*\", \"/\":\n\t\t\tops.Push(v)\n\t\tcase \")\":\n\t\t\tb := strs.Pop().(string)\n\t\t\ta := strs.Pop().(string)\n\t\t\top := ops.Pop().(string)\n\t\t\tstrs.Push(fmt.Sprintf(\"( %s %s %s )\", a, b, op))\n\t\tdefault:\n\t\t\tstrs.Push(v)\n\t\t}\n\t}\n\tresult := strs.Pop().(string)\n\treturn result\n}"}
{"input": "package smbios\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSMBIOSEFISMBIOS2(t *testing.T) {\n\tsystabPath = \"testdata/smbios2_systab\"\n\tbase, size, err := SMBIOSBaseEFI()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar want int64 = 0x12345678\n\n\tif base != want {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): 0x%x, want 0x%x\", base, want)\n\t}\n\tif size != smbios2HeaderSize {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): 0x%x, want 0x%x \", size, smbios2HeaderSize)\n\t}\n}\n\nfunc TestSMBIOSEFISMBIOS3(t *testing.T) {\n\tsystabPath = \"testdata/smbios3_systab\"\n\tbase, size, err := SMBIOSBaseEFI()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar want int64 = 0x12345678\n\n\tif base != want {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): 0x%x, want 0x%x\", base, want)\n\t}\n\tif size != smbios3HeaderSize {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): 0x%x, want 0x%x \", size, smbios3HeaderSize)\n\t}\n}\n\n\n\nfunc TestSMBIOSEFIInvalid(t *testing.T) {\n\tsystabPath = \"testdata/invalid_systab\"\n\t_, _, err := SMBIOSBaseEFI()\n\tif err == nil {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): nil , want error\")\n\t}\n}\n\nfunc TestSMBIOSEFINotFound(t *testing.T) ", "output": "{\n\tsystabPath = \"testdata/systab_NOT_FOUND\"\n\t_, _, err := SMBIOSBaseEFI()\n\tif err == nil {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): nil , want error\")\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n)\n\ntype Node struct {\n\tdata interface{}\n\tnext *Node\n}\n\nvar lengthOfStack = 0\nvar top *Node\n\nfunc main() {\n\tscanner := bufio.NewScanner(os.Stdin)\n\n\tfor true {\n\t\tfmt.Println(\"Select one of the following options:\")\n\t\tfmt.Println(\"1. Push\")\n\t\tfmt.Println(\"2. Pop\")\n\t\tfmt.Println(\"3. Length of stack\")\n\t\tfmt.Println(\"4. Exit\")\n\n\t\tscanner.Scan()\n\t\tfmt.Println(\"\")\n\t\tswitch scanner.Text() {\n\t\t\tcase \"1\":\n\t\t\t\tpush(scanner)\n\t\t\tcase \"2\":\n\t\t\t\tpop()\n\n\t\t\tcase \"3\":\n\t\t\t\tfmt.Println(\"The length of the stack is:\", lengthOfStack)\n\t\t\t\tfmt.Println(\"\")\t\n\t\t\tcase \"4\":\n\t\t\t\tos.Exit(0)\n\n\t\t\tdefault:\n\t\t\t\tfmt.Println(\"Please, select a valid option.\")\n\t\t}\n\t}\n}\n\n\n\nfunc pop() {\n\tif(top == nil) {\n\t\tfmt.Println(\"Empty stack\")\n\t\tfmt.Println(\"\")\t\t\n\t\treturn\n\t}\n\n\tfmt.Println(\"Element to pop:\", top.data)\n\tfmt.Println(\"\")\t\n\n\ttop = top.next\n\n\tlengthOfStack -= 1\n}\n\nfunc push(scanner *bufio.Scanner) ", "output": "{\n\tfmt.Println(\"Type the number you want to push into the stack\")\n\tscanner.Scan()\n\tfmt.Println(\"\")\t\n\n\tlengthOfStack += 1\n\tif(top == nil) {\n\t\ttop = &Node{scanner.Text(), nil}\n\t\treturn\n\t}\n\n\tnewNode := &Node{scanner.Text(), top}\n\ttop = newNode\n}"}
{"input": "package iso\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/mitchellh/multistep\"\n\tparallelscommon \"github.com/orivej/packer/builder/parallels/common\"\n\t\"github.com/orivej/packer/packer\"\n)\n\n\n\n\n\ntype stepCreateVM struct {\n\tvmName string\n}\n\nfunc (s *stepCreateVM) Run(state multistep.StateBag) multistep.StepAction {\n\n\tconfig := state.Get(\"config\").(*Config)\n\tdriver := state.Get(\"driver\").(parallelscommon.Driver)\n\tui := state.Get(\"ui\").(packer.Ui)\n\tname := config.VMName\n\n\tcommand := []string{\n\t\t\"create\", name,\n\t\t\"--distribution\", config.GuestOSType,\n\t\t\"--dst\", config.OutputDir,\n\t\t\"--vmtype\", \"vm\",\n\t\t\"--no-hdd\",\n\t}\n\n\tui.Say(\"Creating virtual machine...\")\n\tif err := driver.Prlctl(command...); err != nil {\n\t\terr := fmt.Errorf(\"Error creating VM: %s\", err)\n\t\tstate.Put(\"error\", err)\n\t\tui.Error(err.Error())\n\t\treturn multistep.ActionHalt\n\t}\n\n\tui.Say(\"Applying default settings...\")\n\tif err := driver.SetDefaultConfiguration(name); err != nil {\n\t\terr := fmt.Errorf(\"Error VM configuration: %s\", err)\n\t\tstate.Put(\"error\", err)\n\t\tui.Error(err.Error())\n\t\treturn multistep.ActionHalt\n\t}\n\n\tif s.vmName == \"\" {\n\t\ts.vmName = name\n\t}\n\n\tstate.Put(\"vmName\", s.vmName)\n\treturn multistep.ActionContinue\n}\n\n\n\nfunc (s *stepCreateVM) Cleanup(state multistep.StateBag) ", "output": "{\n\tif s.vmName == \"\" {\n\t\treturn\n\t}\n\n\tdriver := state.Get(\"driver\").(parallelscommon.Driver)\n\tui := state.Get(\"ui\").(packer.Ui)\n\n\tui.Say(\"Unregistering virtual machine...\")\n\tif err := driver.Prlctl(\"unregister\", s.vmName); err != nil {\n\t\tui.Error(fmt.Sprintf(\"Error unregistering virtual machine: %s\", err))\n\t}\n}"}
{"input": "package random\n\nimport (\n\t\"math/rand\"\n\n\t\"github.com/micro/go-micro/v3/selector\"\n)\n\ntype random struct{}\n\nfunc (r *random) Select(routes []string, opts ...selector.SelectOption) (selector.Next, error) {\n\tif len(routes) == 0 {\n\t\treturn nil, selector.ErrNoneAvailable\n\t}\n\n\treturn func() string {\n\t\tif len(routes) == 1 {\n\t\t\treturn routes[0]\n\t\t}\n\n\t\treturn routes[rand.Intn(len(routes)-1)]\n\t}, nil\n}\n\nfunc (r *random) Record(addr string, err error) error {\n\treturn nil\n}\n\nfunc (r *random) Reset() error {\n\treturn nil\n}\n\n\n\n\nfunc NewSelector(opts ...selector.Option) selector.Selector {\n\treturn new(random)\n}\n\nfunc (r *random) String() string ", "output": "{\n\treturn \"random\"\n}"}
{"input": "package filesystem\n\nimport (\n\tkeystore2 \"github.com/cossacklabs/acra/keystore\"\n)\n\nfunc getSymmetricKeyName(id string) string {\n\treturn id + `_sym`\n}\n\nfunc getTokenSymmetricKeyName(id []byte, ownerType keystore2.KeyOwnerType) string {\n\tvar name string\n\tswitch ownerType {\n\tcase keystore2.KeyOwnerTypeClient:\n\t\tname = getClientIDSymmetricKeyName(id)\n\tcase keystore2.KeyOwnerTypeZone:\n\t\tname = getZoneIDSymmetricKeyName(id)\n\tdefault:\n\t\tname = string(id)\n\t}\n\treturn name + \".token\"\n}\n\n\n\nfunc getZoneIDSymmetricKeyName(id []byte) string {\n\treturn getSymmetricKeyName(GetZoneKeyFilename(id))\n}\n\nfunc getClientIDSymmetricKeyName(id []byte) string ", "output": "{\n\treturn getSymmetricKeyName(GetServerDecryptionKeyFilename(id))\n}"}
{"input": "package persistence\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\tbolt \"github.com/coreos/bbolt\"\n)\n\ntype txMock struct {\n\tbucketToReject string\n}\n\nfunc (tx *txMock) CreateBucketIfNotExists(name []byte) (b *bolt.Bucket, err error) {\n\tif string(name) == tx.bucketToReject {\n\t\terr = errors.New(\"some error\")\n\t}\n\treturn\n}\n\nvar dbName string = \"inMemoryWb\"\n\n\n\n\n\nfunc TestCreateBucketsIfNeededJObsBucketError(t *testing.T) {\n\ttx := new(txMock)\n\ttx.bucketToReject = \"jobs\"\n\texpectedErrorMsg := \"ERROR >> job bucket creation failed : some error\"\n\n\terr := createBucketsIfNeeded(tx)\n\n\tif err == nil {\n\t\tt.Error(\"expect to have an error, but got nil\")\n\t}\n\n\tif err.Error() != expectedErrorMsg {\n\t\tt.Errorf(\"expect to have an error with text %s, but got %s\", expectedErrorMsg, err.Error())\n\t}\n\n}\n\nfunc TestCreateBucketsIfNeededUsersBucketError(t *testing.T) ", "output": "{\n\ttx := new(txMock)\n\ttx.bucketToReject = \"users\"\n\texpectedErrorMsg := \"ERROR >> user bucket creation failed : some error\"\n\n\terr := createBucketsIfNeeded(tx)\n\n\tif err == nil {\n\t\tt.Error(\"expect to have an error, but got nil\")\n\t}\n\n\tif err.Error() != expectedErrorMsg {\n\t\tt.Errorf(\"expect to have an error with text %s, but got %s\", expectedErrorMsg, err.Error())\n\t}\n}"}
{"input": "package helper\n\nimport (\n\t\"bufio\"\n\t\"net\"\n)\n\ntype BufConn struct {\n\tnet.Conn\n\tBR *bufio.Reader\n}\n\nfunc (c *BufConn) Peek(n int) ([]byte, error) {\n\treturn c.BR.Peek(n)\n}\n\nfunc (c *BufConn) Read(b []byte) (n int, err error) {\n\treturn c.BR.Read(b)\n}\n\nfunc (c *BufConn) Write(b []byte) (n int, err error) {\n\treturn c.Conn.Write(b)\n}\n\nfunc (c *BufConn) Reset(conn net.Conn) {\n\tc.Conn = conn\n}\n\n\n\nfunc NewBufConn(c net.Conn, r *bufio.Reader) *BufConn ", "output": "{\n\tconn := &BufConn{Conn: c}\n\tconn.BR = r\n\tif nil == r {\n\t\tconn.BR = bufio.NewReader(c)\n\t}\n\treturn conn\n}"}
{"input": "package alg\n\nimport (\n\t\"math\"\n)\n\n\n\n\ntype Node struct {\n\tadj            []*Node\n\tadjMap         map[*Node]bool\n\tX              float64\n\tY              float64\n\tPrev           *Node\n\tPathCost       float64\n\tHieuristicCost float64\n}\n\nfunc NewNode() (n Node) {\n\tn.adj = make([]*Node, 0)\n\tn.adjMap = make(map[*Node]bool)\n\tn.PathCost = math.MaxFloat64\n\treturn n\n}\n\n\n\nfunc (node *Node) Adj() (nodes []*Node) {\n\treturn node.adj\n}\n\nfunc (node *Node) AdjTo(adj Node) (adjTo bool) {\n\tif node.adjMap[&adj] == true {\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}\n\nfunc (node *Node) AddAdjNode(adjNode *Node) {\n\tnode.adj = append(node.adj, adjNode)\n\tnode.adjMap[adjNode] = true\n}\n\nfunc (n *Node) TraversalCost(node *Node) float64 {\n\treturn math.Sqrt(math.Pow(node.X-n.X, 2) + math.Pow(node.Y-n.Y, 2))\n}\n\nfunc (n *Node) Path() (path []*Node) {\n\tif n.Prev == nil {\n\t\treturn []*Node{n}\n\t} else {\n\t\treturn append(n.Prev.Path(), n)\n\t}\n}\n\nfunc (node *Node) CalcHieuristic(goal *Node) ", "output": "{\n\tnode.HieuristicCost = math.Sqrt(math.Pow(node.X-goal.X, 2) + math.Pow(node.Y-goal.Y, 2))\n}"}
{"input": "package data\n\nimport (\n  \"github.com/twitchyliquid64/CNC/registry/syscomponents\"\n)\n\nvar trackerObj DatabaseComponent\n\ntype DatabaseComponent struct{\n  err error\n}\n\nfunc (d *DatabaseComponent)Name() string{\n  return \"Database\"\n}\nfunc (d *DatabaseComponent)IconStr() string{\n  return \"list\"\n}\nfunc (d *DatabaseComponent)IsNominal()bool{\n  return d.err == nil\n}\nfunc (d *DatabaseComponent)IsDisabled()bool{\n  return false\n}\nfunc (d *DatabaseComponent)IsFault()bool{\n  return d.err != nil\n}\nfunc (d *DatabaseComponent)Error()string{\n  if d.err == nil{\n    return \"\"\n  }\n  return d.err.Error()\n}\n\n\nfunc trackingSetup(){\n  trackerObj = DatabaseComponent{}\n  syscomponents.Register(&trackerObj)\n}\n\nfunc tracking_notifyFault(err error){\n  syscomponents.SetError(trackerObj.Name(), err)\n}\n\nfunc (d *DatabaseComponent)SetError(e error)", "output": "{\n  d.err = e\n}"}
{"input": "package delete\n\nimport (\n\t\"os\"\n\n\t\"github.com/golang/glog\"\n\t\"github.com/spf13/cobra\"\n\n\t\"k8s.io/test-infra/kind/pkg/cluster\"\n)\n\ntype flags struct {\n\tName string\n}\n\n\n\n\nfunc run(flags *flags, cmd *cobra.Command, args []string) {\n\tconfig := cluster.NewConfig(flags.Name)\n\tctx := cluster.NewContext(config)\n\terr := ctx.Delete()\n\tif err != nil {\n\t\tglog.Errorf(\"Failed to delete cluster: %v\", err)\n\t\tos.Exit(-1)\n\t}\n}\n\nfunc NewCommand() *cobra.Command ", "output": "{\n\tflags := &flags{}\n\tcmd := &cobra.Command{\n\t\tUse:   \"delete\",\n\t\tShort: \"Deletes a cluster\",\n\t\tLong:  \"Deletes a Kubernetes cluster\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\trun(flags, cmd, args)\n\t\t},\n\t}\n\tcmd.Flags().StringVar(&flags.Name, \"name\", \"\", \"the cluster name\")\n\treturn cmd\n}"}
{"input": "package iso20022\n\n\ntype SettlementStatus10Choice struct {\n\n\tPending *PendingStatus15Choice `xml:\"Pdg\"`\n\n\tFailing *FailingStatus3Choice `xml:\"Flng\"`\n\n\tProprietary *ProprietaryStatusAndReason1 `xml:\"Prtry\"`\n}\n\nfunc (s *SettlementStatus10Choice) AddPending() *PendingStatus15Choice {\n\ts.Pending = new(PendingStatus15Choice)\n\treturn s.Pending\n}\n\nfunc (s *SettlementStatus10Choice) AddFailing() *FailingStatus3Choice {\n\ts.Failing = new(FailingStatus3Choice)\n\treturn s.Failing\n}\n\n\n\nfunc (s *SettlementStatus10Choice) AddProprietary() *ProprietaryStatusAndReason1 ", "output": "{\n\ts.Proprietary = new(ProprietaryStatusAndReason1)\n\treturn s.Proprietary\n}"}
{"input": "package command\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/codegangsta/cli\"\n\t\"github.com/coreos/etcd/client\"\n)\n\n\nfunc NewGetCommand() cli.Command {\n\treturn cli.Command{\n\t\tName:      \"get\",\n\t\tUsage:     \"retrieve the value of a key\",\n\t\tArgsUsage: \"<key>\",\n\t\tFlags: []cli.Flag{\n\t\t\tcli.BoolFlag{Name: \"sort\", Usage: \"returns result in sorted order\"},\n\t\t\tcli.BoolFlag{Name: \"quorum, q\", Usage: \"require quorum for get request\"},\n\t\t},\n\t\tAction: func(c *cli.Context) {\n\t\t\tgetCommandFunc(c, mustNewKeyAPI(c))\n\t\t},\n\t}\n}\n\n\n\n\nfunc getCommandFunc(c *cli.Context, ki client.KeysAPI) ", "output": "{\n\tif len(c.Args()) == 0 {\n\t\thandleError(ExitBadArgs, errors.New(\"key required\"))\n\t}\n\n\tkey := c.Args()[0]\n\tsorted := c.Bool(\"sort\")\n\tquorum := c.Bool(\"quorum\")\n\n\tctx, cancel := contextWithTotalTimeout(c)\n\tresp, err := ki.Get(ctx, key, &client.GetOptions{Sort: sorted, Quorum: quorum})\n\tcancel()\n\tif err != nil {\n\t\thandleError(ExitServerError, err)\n\t}\n\n\tif resp.Node.Dir {\n\t\tfmt.Fprintln(os.Stderr, fmt.Sprintf(\"%s: is a directory\", resp.Node.Key))\n\t\tos.Exit(1)\n\t}\n\n\tprintResponseKey(resp, c.GlobalString(\"output\"))\n}"}
{"input": "package stats\n\nimport (\n\t\"fmt\"\n\n\t\"k8s.io/kubernetes/pkg/volume\"\n)\n\ntype fakeLogMetrics struct {\n\tfakeStats map[string]*volume.Metrics\n}\n\nfunc NewFakeLogMetricsService(stats map[string]*volume.Metrics) LogMetricsService {\n\treturn &fakeLogMetrics{fakeStats: stats}\n}\n\n\n\ntype fakeMetricsDu struct {\n\tfakeStats *volume.Metrics\n}\n\nfunc NewFakeMetricsDu(path string, stats *volume.Metrics) volume.MetricsProvider {\n\treturn &fakeMetricsDu{fakeStats: stats}\n}\n\nfunc (f *fakeMetricsDu) GetMetrics() (*volume.Metrics, error) {\n\tif f.fakeStats == nil {\n\t\treturn nil, fmt.Errorf(\"no stats provided\")\n\t}\n\treturn f.fakeStats, nil\n}\n\nfunc (l *fakeLogMetrics) createLogMetricsProvider(path string) volume.MetricsProvider ", "output": "{\n\treturn NewFakeMetricsDu(path, l.fakeStats[path])\n}"}
{"input": "package overview\n\nimport (\n\t\"appengine\"\n\n\th \"github.com/czertbytes/pocket/pkg/http\"\n\tt \"github.com/czertbytes/pocket/pkg/types\"\n)\n\ntype Notificator struct {\n\tAppEngineContext appengine.Context\n\tRequestContext   *h.RequestContext\n}\n\nfunc NewNotificator(RequestContext *h.RequestContext) *Notificator {\n\treturn &Notificator{\n\t\tAppEngineContext: RequestContext.AppEngineContext,\n\t\tRequestContext:   RequestContext,\n\t}\n}\n\nfunc (self *Notificator) Create(overview *t.Overview) error {\n\treturn nil\n}\n\nfunc (self *Notificator) Update(overview *t.Overview) error {\n\treturn nil\n}\n\n\n\nfunc (self *Notificator) CreateParticipant(participant *t.User) error {\n\treturn nil\n}\n\nfunc (self *Notificator) CreatePayment(payment *t.Payment) error ", "output": "{\n\treturn nil\n}"}
{"input": "package tc\n\n\n\nimport (\n\t\"encoding/json\"\n)\n\n\ntype CRStates struct {\n\tCaches          map[CacheName]IsAvailable                       `json:\"caches\"`\n\tDeliveryService map[DeliveryServiceName]CRStatesDeliveryService `json:\"deliveryServices\"`\n}\n\n\ntype CRStatesDeliveryService struct {\n\tDisabledLocations []CacheGroupName `json:\"disabledLocations\"`\n\tIsAvailable       bool             `json:\"isAvailable\"`\n}\n\n\ntype IsAvailable struct {\n\tIsAvailable bool `json:\"isAvailable\"`\n}\n\n\nfunc NewCRStates() CRStates {\n\treturn CRStates{\n\t\tCaches:          map[CacheName]IsAvailable{},\n\t\tDeliveryService: map[DeliveryServiceName]CRStatesDeliveryService{},\n\t}\n}\n\n\nfunc (a CRStates) Copy() CRStates {\n\tb := NewCRStates()\n\tfor k, v := range a.Caches {\n\t\tb.Caches[k] = v\n\t}\n\tfor k, v := range a.DeliveryService {\n\t\tb.DeliveryService[k] = v\n\t}\n\treturn b\n}\n\n\nfunc (a CRStates) CopyDeliveryServices() map[DeliveryServiceName]CRStatesDeliveryService {\n\tb := map[DeliveryServiceName]CRStatesDeliveryService{}\n\tfor k, v := range a.DeliveryService {\n\t\tb[k] = v\n\t}\n\treturn b\n}\n\n\n\n\n\nfunc CRStatesMarshall(states CRStates) ([]byte, error) {\n\treturn json.Marshal(states)\n}\n\n\nfunc CRStatesUnMarshall(body []byte) (CRStates, error) {\n\tvar crStates CRStates\n\terr := json.Unmarshal(body, &crStates)\n\treturn crStates, err\n}\n\nfunc (a CRStates) CopyCaches() map[CacheName]IsAvailable ", "output": "{\n\tb := map[CacheName]IsAvailable{}\n\tfor k, v := range a.Caches {\n\t\tb[k] = v\n\t}\n\treturn b\n}"}
{"input": "package server\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n)\n\ntype getFluxLinksResponse struct {\n\tAST         string `json:\"ast\"`\n\tSelf        string `json:\"self\"`\n\tSuggestions string `json:\"suggestions\"`\n}\n\ntype getConfigLinksResponse struct {\n\tSelf string `json:\"self\"` \n\tAuth string `json:\"auth\"` \n}\n\ntype getOrganizationConfigLinksResponse struct {\n\tSelf      string `json:\"self\"`      \n\tLogViewer string `json:\"logViewer\"` \n}\n\ntype getExternalLinksResponse struct {\n\tStatusFeed  *string      `json:\"statusFeed,omitempty\"` \n\tCustomLinks []CustomLink `json:\"custom,omitempty\"`     \n}\n\n\ntype CustomLink struct {\n\tName string `json:\"name\"`\n\tURL  string `json:\"url\"`\n}\n\n\n\n\n\nfunc NewCustomLinks(links map[string]string) ([]CustomLink, error) ", "output": "{\n\tcustomLinks := make([]CustomLink, 0, len(links))\n\tfor name, link := range links {\n\t\tif name == \"\" {\n\t\t\treturn nil, errors.New(\"customLink missing key for Name\")\n\t\t}\n\t\tif link == \"\" {\n\t\t\treturn nil, errors.New(\"customLink missing value for URL\")\n\t\t}\n\t\t_, err := url.Parse(link)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcustomLink := CustomLink{\n\t\t\tName: name,\n\t\t\tURL:  link,\n\t\t}\n\t\tcustomLinks = append(customLinks, customLink)\n\t}\n\n\treturn customLinks, nil\n}"}
{"input": "package scheduling\n\nimport \"k8s.io/api/core/v1\"\n\n\ntype FakeVolumeBinderConfig struct {\n\tAllBound    bool\n\tFindReasons ConflictReasons\n\tFindErr     error\n\tAssumeErr   error\n\tBindErr     error\n}\n\n\n\nfunc NewFakeVolumeBinder(config *FakeVolumeBinderConfig) *FakeVolumeBinder {\n\treturn &FakeVolumeBinder{\n\t\tconfig: config,\n\t}\n}\n\n\ntype FakeVolumeBinder struct {\n\tconfig       *FakeVolumeBinderConfig\n\tAssumeCalled bool\n\tBindCalled   bool\n}\n\n\n\n\n\nfunc (b *FakeVolumeBinder) AssumePodVolumes(assumedPod *v1.Pod, nodeName string) (bool, error) {\n\tb.AssumeCalled = true\n\treturn b.config.AllBound, b.config.AssumeErr\n}\n\n\nfunc (b *FakeVolumeBinder) BindPodVolumes(assumedPod *v1.Pod) error {\n\tb.BindCalled = true\n\treturn b.config.BindErr\n}\n\n\nfunc (b *FakeVolumeBinder) GetBindingsCache() PodBindingCache {\n\treturn nil\n}\n\n\nfunc (b *FakeVolumeBinder) DeletePodBindings(pod *v1.Pod) {}\n\nfunc (b *FakeVolumeBinder) FindPodVolumes(pod *v1.Pod, node *v1.Node) (reasons ConflictReasons, err error) ", "output": "{\n\treturn b.config.FindReasons, b.config.FindErr\n}"}
{"input": "package echo\n\ntype (\n\tGroup struct {\n\t\techo Echo\n\t}\n)\n\nfunc (g *Group) Use(m ...Middleware) {\n\tfor _, h := range m {\n\t\tg.echo.middleware = append(g.echo.middleware, wrapMiddleware(h))\n\t}\n}\n\nfunc (g *Group) Connect(path string, h Handler) {\n\tg.echo.Connect(path, h)\n}\n\n\n\nfunc (g *Group) Get(path string, h Handler) {\n\tg.echo.Get(path, h)\n}\n\nfunc (g *Group) Head(path string, h Handler) {\n\tg.echo.Head(path, h)\n}\n\nfunc (g *Group) Options(path string, h Handler) {\n\tg.echo.Options(path, h)\n}\n\nfunc (g *Group) Patch(path string, h Handler) {\n\tg.echo.Patch(path, h)\n}\n\nfunc (g *Group) Post(path string, h Handler) {\n\tg.echo.Post(path, h)\n}\n\nfunc (g *Group) Put(path string, h Handler) {\n\tg.echo.Put(path, h)\n}\n\nfunc (g *Group) Trace(path string, h Handler) {\n\tg.echo.Trace(path, h)\n}\n\nfunc (g *Group) WebSocket(path string, h HandlerFunc) {\n\tg.echo.WebSocket(path, h)\n}\n\nfunc (g *Group) Static(path, root string) {\n\tg.echo.Static(path, root)\n}\n\nfunc (g *Group) ServeDir(path, root string) {\n\tg.echo.ServeDir(path, root)\n}\n\nfunc (g *Group) ServeFile(path, file string) {\n\tg.echo.ServeFile(path, file)\n}\n\nfunc (g *Group) Group(prefix string, m ...Middleware) *Group {\n\treturn g.echo.Group(prefix, m...)\n}\n\nfunc (g *Group) Delete(path string, h Handler) ", "output": "{\n\tg.echo.Delete(path, h)\n}"}
{"input": "package downloader\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/Lopastvertoleta/go-ethereum/core/types\"\n)\n\n\ntype peerDropFn func(id string)\n\n\ntype dataPack interface {\n\tPeerId() string\n\tItems() int\n\tStats() string\n}\n\n\ntype headerPack struct {\n\tpeerId  string\n\theaders []*types.Header\n}\n\n\nfunc (p *headerPack) Items() int     { return len(p.headers) }\nfunc (p *headerPack) Stats() string  { return fmt.Sprintf(\"%d\", len(p.headers)) }\n\n\ntype bodyPack struct {\n\tpeerId       string\n\ttransactions [][]*types.Transaction\n\tuncles       [][]*types.Header\n}\n\nfunc (p *bodyPack) PeerId() string { return p.peerId }\nfunc (p *bodyPack) Items() int {\n\tif len(p.transactions) <= len(p.uncles) {\n\t\treturn len(p.transactions)\n\t}\n\treturn len(p.uncles)\n}\nfunc (p *bodyPack) Stats() string { return fmt.Sprintf(\"%d:%d\", len(p.transactions), len(p.uncles)) }\n\n\ntype receiptPack struct {\n\tpeerId   string\n\treceipts [][]*types.Receipt\n}\n\nfunc (p *receiptPack) PeerId() string { return p.peerId }\nfunc (p *receiptPack) Items() int     { return len(p.receipts) }\nfunc (p *receiptPack) Stats() string  { return fmt.Sprintf(\"%d\", len(p.receipts)) }\n\n\ntype statePack struct {\n\tpeerId string\n\tstates [][]byte\n}\n\nfunc (p *statePack) PeerId() string { return p.peerId }\nfunc (p *statePack) Items() int     { return len(p.states) }\nfunc (p *statePack) Stats() string  { return fmt.Sprintf(\"%d\", len(p.states)) }\n\nfunc (p *headerPack) PeerId() string ", "output": "{ return p.peerId }"}
{"input": "package streaming\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype DeleteStreamPoolRequest struct {\n\n\tStreamPoolId *string `mandatory:\"true\" contributesTo:\"path\" name:\"streamPoolId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request DeleteStreamPoolRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request DeleteStreamPoolRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\n\n\n\nfunc (request DeleteStreamPoolRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype DeleteStreamPoolResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response DeleteStreamPoolResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response DeleteStreamPoolResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request DeleteStreamPoolRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) ", "output": "{\n\n\treturn nil, false\n\n}"}
{"input": "package govaluate\n\ntype lexerStream struct {\n\tsource   []rune\n\tposition int\n\tlength   int\n}\n\nfunc newLexerStream(source string) *lexerStream {\n\n\tvar ret *lexerStream\n\tvar runes []rune\n\n\tfor _, character := range source {\n\t\trunes = append(runes, character)\n\t}\n\n\tret = new(lexerStream)\n\tret.source = runes\n\tret.length = len(runes)\n\treturn ret\n}\n\nfunc (l *lexerStream) readCharacter() rune {\n\n\tvar character rune\n\n\tcharacter = l.source[l.position]\n\tl.position++\n\treturn character\n}\n\nfunc (l *lexerStream) rewind(amount int) {\n\tl.position -= amount\n}\n\n\n\nfunc (l lexerStream) canRead() bool ", "output": "{\n\treturn l.position < l.length\n}"}
{"input": "package gfile\n\nimport (\n\t\"bytes\"\n\t\"github.com/gogf/gf/v2/errors/gcode\"\n\t\"github.com/gogf/gf/v2/errors/gerror\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"runtime\"\n\t\"strings\"\n)\n\n\n\n\nfunc Home(names ...string) (string, error) {\n\tpath, err := getHomePath()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, name := range names {\n\t\tpath += Separator + name\n\t}\n\treturn path, nil\n}\n\n\n\n\n\nfunc homeUnix() (string, error) {\n\tif home := os.Getenv(\"HOME\"); home != \"\" {\n\t\treturn home, nil\n\t}\n\tvar stdout bytes.Buffer\n\tcmd := exec.Command(\"sh\", \"-c\", \"eval echo ~$USER\")\n\tcmd.Stdout = &stdout\n\tif err := cmd.Run(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tresult := strings.TrimSpace(stdout.String())\n\tif result == \"\" {\n\t\treturn \"\", gerror.NewCode(gcode.CodeInternalError, \"blank output when reading home directory\")\n\t}\n\n\treturn result, nil\n}\n\n\nfunc homeWindows() (string, error) {\n\tvar (\n\t\tdrive = os.Getenv(\"HOMEDRIVE\")\n\t\tpath  = os.Getenv(\"HOMEPATH\")\n\t\thome  = drive + path\n\t)\n\tif drive == \"\" || path == \"\" {\n\t\thome = os.Getenv(\"USERPROFILE\")\n\t}\n\tif home == \"\" {\n\t\treturn \"\", gerror.NewCode(gcode.CodeOperationFailed, \"HOMEDRIVE, HOMEPATH, and USERPROFILE are blank\")\n\t}\n\n\treturn home, nil\n}\n\nfunc getHomePath() (string, error) ", "output": "{\n\tu, err := user.Current()\n\tif nil == err {\n\t\treturn u.HomeDir, nil\n\t}\n\tif \"windows\" == runtime.GOOS {\n\t\treturn homeWindows()\n\t}\n\treturn homeUnix()\n}"}
{"input": "package security\n\nimport \"github.com/e-XpertSolutions/f5-rest-client/f5\"\n\n\ntype DOSProfileDOSNetworkConfigList struct {\n\tItems    []DOSProfileDOSNetworkConfig `json:\"items\"`\n\tKind     string                       `json:\"kind\"`\n\tSelfLink string                       `json:\"selflink\"`\n}\n\n\ntype DOSProfileDOSNetworkConfig struct {\n}\n\n\nconst DOSProfileDOSNetworkEndpoint = \"/dos/profile_dos-network\"\n\n\ntype DOSProfileDOSNetworkResource struct {\n\tc *f5.Client\n}\n\n\n\n\n\nfunc (r *DOSProfileDOSNetworkResource) Get(id string) (*DOSProfileDOSNetworkConfig, error) {\n\tvar item DOSProfileDOSNetworkConfig\n\tif err := r.c.ReadQuery(BasePath+DOSProfileDOSNetworkEndpoint, &item); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &item, nil\n}\n\n\nfunc (r *DOSProfileDOSNetworkResource) Create(item DOSProfileDOSNetworkConfig) error {\n\tif err := r.c.ModQuery(\"POST\", BasePath+DOSProfileDOSNetworkEndpoint, item); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\nfunc (r *DOSProfileDOSNetworkResource) Edit(id string, item DOSProfileDOSNetworkConfig) error {\n\tif err := r.c.ModQuery(\"PUT\", BasePath+DOSProfileDOSNetworkEndpoint+\"/\"+id, item); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\nfunc (r *DOSProfileDOSNetworkResource) Delete(id string) error {\n\tif err := r.c.ModQuery(\"DELETE\", BasePath+DOSProfileDOSNetworkEndpoint+\"/\"+id, nil); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (r *DOSProfileDOSNetworkResource) ListAll() (*DOSProfileDOSNetworkConfigList, error) ", "output": "{\n\tvar list DOSProfileDOSNetworkConfigList\n\tif err := r.c.ReadQuery(BasePath+DOSProfileDOSNetworkEndpoint, &list); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &list, nil\n}"}
{"input": "package runtime\n\n\ntype Thread struct {\n\tpc    int\n\tstack *Stack\n}\n\n\nfunc NewThread() *Thread {\n\treturn &Thread{\n\t\tstack:newStack(1024),\n\t}\n}\n\nfunc (self *Thread) PC() int {\n\treturn self.pc\n}\n\nfunc (self *Thread) SetPC(pc int) {\n\tself.pc = pc\n}\n\n\nfunc (self *Thread) PushFrame(frame *Frame) {\n\tself.stack.push(frame)\n}\n\n\nfunc (self *Thread) PopFrame() *Frame {\n\treturn self.stack.pop()\n}\n\n\nfunc (self *Thread) CurrentFrame() *Frame {\n\treturn self.stack.top()\n}\n\n\n\nfunc (self *Thread) NewFrame(maxLocals, maxStack uint) *Frame ", "output": "{\n\treturn newFrame(self, maxLocals, maxStack)\n}"}
{"input": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"time\"\n)\n\ntype TLSConnection struct {\n\thost     string\n\tcertPool *x509.CertPool\n\tconn     *tls.Conn\n}\n\nfunc NewTLSConnection(host string) (*TLSConnection, error) {\n\tc := &TLSConnection{}\n\tc.host = host\n\tc.getCerts()\n\terr := c.Connect()\n\treturn c, err\n}\n\nfunc (c *TLSConnection) Connect() (err error) {\n\tc.conn, err = tls.Dial(\"tcp\", c.host, &tls.Config{\n\t\tRootCAs: c.certPool,\n\t})\n\tif err != nil {\n\t\treturn\n\t}\n\tc.conn.SetWriteDeadline(time.Time{})\n\treturn\n}\n\n\n\nfunc (c *TLSConnection) Write(p []byte) (n int, err error) {\n\treturn c.conn.Write(p)\n}\n\nfunc (c *TLSConnection) Close() error {\n\treturn c.conn.Close()\n}\n\nfunc (c *TLSConnection) getCerts() {\n\tc.certPool = x509.NewCertPool()\n\tcert, err := ioutil.ReadFile(certsPemFile)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tif !c.certPool.AppendCertsFromPEM(cert) {\n\t\tlog.Fatal(\"Failed parsing root certificate\")\n\t}\n}\n\nfunc (c *TLSConnection) WriteString(s string) (n int, err error) ", "output": "{\n\treturn io.WriteString(c.conn, s)\n}"}
{"input": "package common_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"github.com/jacobsa/crypto/common\"\n\t. \"github.com/jacobsa/oglematchers\"\n\t. \"github.com/jacobsa/ogletest\"\n\t\"testing\"\n)\n\n\n\n\n\n\n\ntype PadBlockTest struct{}\n\nfunc init() { RegisterTestSuite(&PadBlockTest{}) }\n\n\n\n\n\nfunc (t *PadBlockTest) FullBlock() {\n\tb := make([]byte, 16)\n\tf := func() { common.PadBlock(b) }\n\tExpectThat(f, Panics(HasSubstr(\"16 bytes\")))\n}\n\nfunc (t *PadBlockTest) LongBlock() {\n\tb := make([]byte, 17)\n\tf := func() { common.PadBlock(b) }\n\tExpectThat(f, Panics(HasSubstr(\"16 bytes\")))\n}\n\nfunc (t *PadBlockTest) OneByteMissing() {\n\tb, err := hex.DecodeString(\"deadbeeffeedfaceba5eba11cafeba\")\n\tAssertEq(nil, err)\n\tAssertEq(15, len(b))\n\n\texpected := append(b, 0x80)\n\tExpectThat(common.PadBlock(b), DeepEquals(expected))\n}\n\nfunc (t *PadBlockTest) MultipleBytesMissing() {\n\tb, err := hex.DecodeString(\"deadbeeffeedfaceba5eba11ca\")\n\tAssertEq(nil, err)\n\tAssertEq(13, len(b))\n\n\texpected := append(b, 0x80, 0x00, 0x00)\n\tExpectThat(common.PadBlock(b), DeepEquals(expected))\n}\n\nfunc (t *PadBlockTest) AllBytesMissing() {\n\tb := []byte{}\n\texpected := append([]byte{0x80}, bytes.Repeat([]byte{0x00}, 15)...)\n\tExpectThat(common.PadBlock(b), DeepEquals(expected))\n}\n\nfunc TestPadBlock(t *testing.T) ", "output": "{ RunTests(t) }"}
{"input": "package model\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/huaweicloud/huaweicloud-sdk-go-v3/core/utils\"\n\n\t\"strings\"\n)\n\n\ntype DeleteServerMetadataResponse struct {\n\tHttpStatusCode int `json:\"-\"`\n}\n\n\n\nfunc (o DeleteServerMetadataResponse) String() string ", "output": "{\n\tdata, err := utils.Marshal(o)\n\tif err != nil {\n\t\treturn \"DeleteServerMetadataResponse struct{}\"\n\t}\n\n\treturn strings.Join([]string{\"DeleteServerMetadataResponse\", string(data)}, \" \")\n}"}
{"input": "package v1\n\nimport (\n\tfmt \"fmt\"\n\tapi \"k8s.io/kubernetes/pkg/api\"\n\tunversioned \"k8s.io/kubernetes/pkg/api/unversioned\"\n\tregistered \"k8s.io/kubernetes/pkg/apimachinery/registered\"\n\trestclient \"k8s.io/kubernetes/pkg/client/restclient\"\n\tserializer \"k8s.io/kubernetes/pkg/runtime/serializer\"\n)\n\ntype BuildV1Interface interface {\n\tRESTClient() restclient.Interface\n\tBuildsGetter\n}\n\n\ntype BuildV1Client struct {\n\trestClient restclient.Interface\n}\n\nfunc (c *BuildV1Client) Builds(namespace string) BuildResourceInterface {\n\treturn newBuilds(c, namespace)\n}\n\n\nfunc NewForConfig(c *restclient.Config) (*BuildV1Client, error) {\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := restclient.RESTClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &BuildV1Client{client}, nil\n}\n\n\n\nfunc NewForConfigOrDie(c *restclient.Config) *BuildV1Client {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n\n\nfunc New(c restclient.Interface) *BuildV1Client {\n\treturn &BuildV1Client{c}\n}\n\n\n\n\n\nfunc (c *BuildV1Client) RESTClient() restclient.Interface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.restClient\n}\n\nfunc setConfigDefaults(config *restclient.Config) error ", "output": "{\n\tgv, err := unversioned.ParseGroupVersion(\"build.openshift.io/v1\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !registered.IsEnabledVersion(gv) {\n\t\treturn fmt.Errorf(\"build.openshift.io/v1 is not enabled\")\n\t}\n\tconfig.APIPath = \"/apis\"\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = restclient.DefaultKubernetesUserAgent()\n\t}\n\tcopyGroupVersion := gv\n\tconfig.GroupVersion = &copyGroupVersion\n\n\tconfig.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: api.Codecs}\n\n\treturn nil\n}"}
{"input": "package test\n\nimport (\n\t\"debug/macho\"\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/bazelbuild/rules_go/go/tools/bazel\"\n)\n\n\n\nfunc TestPIE(t *testing.T) {\n\tm, err := openMachO(\"tests/core/go_binary\", \"hello_pie_bin\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif m.Flags&macho.FlagPIE == 0 {\n\t\tt.Error(\"ELF binary is not position-independent.\")\n\t}\n}\n\nfunc openMachO(dir, bin string) (*macho.File, error) ", "output": "{\n\tbin, ok := bazel.FindBinary(dir, bin)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"could not find binary: %s\", bin)\n\t}\n\n\tf, err := os.Open(bin)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn macho.NewFile(f)\n}"}
{"input": "package controller\n\nimport (\n\t\"fmt\"\n)\n\ntype AdminParams struct {\n\tName          *string\n\tInviteId      *string\n\tInviteKey     *string\n\tConfirmDelete *string\n}\n\nfunc NewAdminParams() *AdminParams {\n\treturn new(AdminParams)\n}\n\n\n\nfunc (params *AdminParams) ValidateInviteId(required bool) error  { return nil }\nfunc (params *AdminParams) ValidateInviteKey(required bool) error { return nil }\n\nfunc (params *AdminParams) ValidateName(required bool) error ", "output": "{\n\tif required && *params.Name == \"\" {\n\t\treturn fmt.Errorf(\"name cannot be empty\")\n\t}\n\treturn nil\n}"}
{"input": "package server\n\nimport \"context\"\n\n\n\nfunc apply(_ context.Context, _ *Config) error ", "output": "{\n\treturn nil\n}"}
{"input": "package util\n\nimport (\n\tauthorizationapi \"k8s.io/kubernetes/pkg/apis/authorization\"\n\t\"k8s.io/kubernetes/pkg/auth/authorizer\"\n\t\"k8s.io/kubernetes/pkg/auth/user\"\n)\n\n\n\n\n\nfunc NonResourceAttributesFrom(user user.Info, in authorizationapi.NonResourceAttributes) authorizer.AttributesRecord {\n\treturn authorizer.AttributesRecord{\n\t\tUser:            user,\n\t\tResourceRequest: false,\n\t\tPath:            in.Path,\n\t}\n}\n\nfunc ResourceAttributesFrom(user user.Info, in authorizationapi.ResourceAttributes) authorizer.AttributesRecord ", "output": "{\n\treturn authorizer.AttributesRecord{\n\t\tUser:            user,\n\t\tVerb:            in.Verb,\n\t\tNamespace:       in.Namespace,\n\t\tAPIGroup:        in.Group,\n\t\tResource:        in.Resource,\n\t\tResourceRequest: true,\n\t}\n}"}
{"input": "package action\n\nimport (\n\t\"flag\"\n)\n\ntype catalogNodes struct {\n\t*config\n}\n\n\n\nfunc (c *catalogNodes) CommandFlags() *flag.FlagSet {\n\treturn c.newFlagSet(FLAG_DATACENTER, FLAG_CONSISTENCY, FLAG_OUTPUT, FLAG_NODEMETA, FLAG_NEAR)\n}\n\nfunc (c *catalogNodes) Run(args []string) error {\n\tclient, err := c.newCatalog()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tqueryOpts := c.queryOptions()\n\tconfig, _, err := client.Nodes(queryOpts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn c.Output(config)\n}\n\nfunc CatalogNodesAction() Action ", "output": "{\n\treturn &catalogNodes{\n\t\tconfig: &gConfig,\n\t}\n}"}
{"input": "package version\n\nimport (\n\t\"github.com/hashicorp/packer-plugin-sdk/version\"\n\tpackerVersion \"github.com/hashicorp/packer/version\"\n)\n\nvar AzureDTLPluginVersion *version.PluginVersion\n\n\n\nfunc init() ", "output": "{\n\tAzureDTLPluginVersion = version.InitializePluginVersion(\n\t\tpackerVersion.Version, packerVersion.VersionPrerelease)\n}"}
{"input": "package etcd\n\nimport (\n\t\"testing\"\n\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/registry/generic\"\n\t\"k8s.io/kubernetes/pkg/registry/registrytest\"\n\t\"k8s.io/kubernetes/pkg/runtime\"\n\tetcdtesting \"k8s.io/kubernetes/pkg/storage/etcd/testing\"\n)\n\nvar testTTL uint64 = 60\n\nfunc newStorage(t *testing.T) (*REST, *etcdtesting.EtcdTestServer) {\n\tetcdStorage, server := registrytest.NewEtcdStorage(t, \"\")\n\trestOptions := generic.RESTOptions{StorageConfig: etcdStorage, Decorator: generic.UndecoratedStorage, DeleteCollectionWorkers: 1}\n\treturn NewREST(restOptions, testTTL), server\n}\n\nfunc validNewEvent(namespace string) *api.Event {\n\treturn &api.Event{\n\t\tObjectMeta: api.ObjectMeta{\n\t\t\tName:      \"foo\",\n\t\t\tNamespace: namespace,\n\t\t},\n\t\tReason: \"forTesting\",\n\t\tInvolvedObject: api.ObjectReference{\n\t\t\tName:      \"bar\",\n\t\t\tNamespace: namespace,\n\t\t},\n\t}\n}\n\nfunc TestCreate(t *testing.T) {\n\tstorage, server := newStorage(t)\n\tdefer server.Terminate(t)\n\ttest := registrytest.New(t, storage.Store)\n\tevent := validNewEvent(test.TestNamespace())\n\tevent.ObjectMeta = api.ObjectMeta{}\n\ttest.TestCreate(\n\t\tevent,\n\t\t&api.Event{},\n\t)\n}\n\n\n\nfunc TestDelete(t *testing.T) {\n\tstorage, server := newStorage(t)\n\tdefer server.Terminate(t)\n\ttest := registrytest.New(t, storage.Store)\n\ttest.TestDelete(validNewEvent(test.TestNamespace()))\n}\n\nfunc TestUpdate(t *testing.T) ", "output": "{\n\tstorage, server := newStorage(t)\n\tdefer server.Terminate(t)\n\ttest := registrytest.New(t, storage.Store).AllowCreateOnUpdate()\n\ttest.TestUpdate(\n\t\tvalidNewEvent(test.TestNamespace()),\n\t\tfunc(obj runtime.Object) runtime.Object {\n\t\t\tobject := obj.(*api.Event)\n\t\t\tobject.Reason = \"forDifferentTesting\"\n\t\t\treturn object\n\t\t},\n\t\tfunc(obj runtime.Object) runtime.Object {\n\t\t\tobject := obj.(*api.Event)\n\t\t\tobject.InvolvedObject.Namespace = \"different-namespace\"\n\t\t\treturn object\n\t\t},\n\t)\n}"}
{"input": "package jwt\n\nfunc verifyPrincipals(pcpls, auds []string) bool {\n\n\tfound := -1\n\tfor i, p := range pcpls {\n\t\tfor _, v := range auds {\n\t\t\tif p == v {\n\t\t\t\tfound++\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif found != i {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\n\n\n\n\n\n\nfunc ValidAudience(a, b interface{}) bool ", "output": "{\n\ts1, ok := a.(string)\n\tif ok {\n\t\tif s2, ok := b.(string); ok {\n\t\t\treturn s1 == s2\n\t\t}\n\t\ta2, ok := b.([]string)\n\t\treturn ok && verifyPrincipals([]string{s1}, a2)\n\t}\n\n\ta1, ok := a.([]string)\n\tif !ok {\n\t\treturn false\n\t}\n\tif a2, ok := b.([]string); ok {\n\t\treturn verifyPrincipals(a1, a2)\n\t}\n\ts2, ok := b.(string)\n\treturn ok && len(a1) == 1 && a1[0] == s2\n}"}
{"input": "package base\n\nimport (\n\t\"errors\"\n\t\"html/template\"\n)\n\n\n\nfunc Str2html(raw string) template.HTML {\n\treturn template.HTML(raw)\n}\n\nfunc Dict(values ...interface{}) (map[string]interface{}, error) ", "output": "{\n\tif len(values)%2 != 0 {\n\t\treturn nil, errors.New(\"invalid dict call\")\n\t}\n\tdict := make(map[string]interface{}, len(values)/2)\n\tfor i := 0; i < len(values); i += 2 {\n\t\tkey, ok := values[i].(string)\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"dict keys must be strings\")\n\t\t}\n\t\tdict[key] = values[i+1]\n\t}\n\treturn dict, nil\n}"}
{"input": "package appui\n\nimport (\n\t\"github.com/docker/docker/api/types\"\n\tgtermui \"github.com/gizak/termui\"\n\t\"github.com/moncho/dry/ui\"\n\t\"github.com/moncho/dry/ui/termui\"\n)\n\n\ntype ImageRunWidget struct {\n\timage types.ImageSummary\n\ttermui.TextInput\n}\n\n\nfunc NewImageRunWidget(image types.ImageSummary) *ImageRunWidget {\n\tw := &ImageRunWidget{\n\t\timage:     image,\n\t\tTextInput: *termui.NewTextInput(ui.ActiveScreen, \"\"),\n\t}\n\tw.Height = 3\n\tw.Width = ui.ActiveScreen.Dimensions().Width / 2\n\tw.X = (ui.ActiveScreen.Dimensions().Width - w.Width) / 2\n\tw.Y = ui.ActiveScreen.Dimensions().Height / 2\n\tw.Bg = gtermui.Attribute(DryTheme.Bg)\n\tw.TextBgColor = gtermui.Attribute(DryTheme.Bg)\n\tw.TextFgColor = gtermui.ColorWhite\n\tw.BorderLabel = widgetTitle(&image)\n\tw.BorderLabelFg = gtermui.ColorWhite\n\n\treturn w\n}\n\n\nfunc (w *ImageRunWidget) Mount() error {\n\treturn nil\n}\n\n\n\n\n\nfunc (w *ImageRunWidget) Name() string {\n\treturn \"ImageRunWidget.\" + w.image.ID\n}\n\nfunc widgetTitle(image *types.ImageSummary) string {\n\tif len(image.RepoTags) > 0 {\n\t\treturn \" docker run \" + image.RepoTags[0]\n\t} else if len(image.RepoDigests) > 0 {\n\t\treturn \" docker run \" + image.RepoDigests[0]\n\t}\n\treturn \" docker run <none>\"\n}\n\nfunc (w *ImageRunWidget) Unmount() error ", "output": "{\n\treturn nil\n}"}
{"input": "package main\n\nimport \"fmt\"\n\ntype QU struct {\n\tid []int\n}\n\n\n\nfunc (q *QU) Root(i int) int {\n\tfor i != q.id[i] {\n\t\ti = q.id[i]\n\t}\n\treturn i\n}\n\nfunc (q *QU) Union(a int, b int) {\n\ti := q.Root(a)\n\tj := q.Root(b)\n\tq.id[i] = j\n}\n\nfunc (q *QU) Connected(a int, b int) bool {\n\treturn q.Root(a) == q.Root(b)\n}\n\nfunc main() {\n\tqu := QU{}\n\tqu.Init(10)\n\tfmt.Printf(\"Array initialized. %v\", qu.id)\n\tqu.Union(3, 4)\n\tqu.Union(4, 8)\n\tfmt.Printf(\"\\n\\n%v is Connected to %v %v\", 3, 8, qu.Connected(3, 8))\n}\n\nfunc (q *QU) Init(size int) ", "output": "{\n\tfor i := 0; i < size; i++ {\n\t\tq.id = append(q.id, i)\n\t}\n}"}
{"input": "package checksums\n\nimport (\n\t\"crypto/md5\"\n\t\"hash\"\n\t\"hash/crc32\"\n\t\"io\"\n\t\"sync\"\n)\n\nvar crc32cTable *crc32.Table\nvar tableInitOnce = new(sync.Once)\n\n\n\ntype Digest struct {\n\tmd5    hash.Hash\n\tcrc32c hash.Hash32\n}\n\n\nvar _ io.Writer = new(Digest)\n\n\nfunc NewDigest() *Digest {\n\ttableInitOnce.Do(func() { crc32cTable = crc32.MakeTable(crc32.Castagnoli) })\n\treturn &Digest{\n\t\tmd5:    md5.New(),\n\t\tcrc32c: crc32.New(crc32cTable),\n\t}\n}\n\n\n\nfunc (d *Digest) Write(p []byte) (int, error) {\n\td.crc32c.Write(p)\n\td.md5.Write(p)\n\treturn len(p), nil\n}\n\n\nfunc (d *Digest) Reset() {\n\td.md5.Reset()\n\td.crc32c.Reset()\n}\n\n\n\n\nfunc (d *Digest) Checksums() Checksums ", "output": "{\n\treturn Checksums{\n\t\tMD5:       d.md5.Sum(nil),\n\t\tCRC32C:    int32(d.crc32c.Sum32()),\n\t\tHasCRC32C: true,\n\t}\n}"}
{"input": "package api2go\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\n\ntype APIContextAllocatorFunc func(*API) APIContexter\n\n\ntype APIContexter interface {\n\tcontext.Context\n\tSet(key string, value interface{})\n\tGet(key string) (interface{}, bool)\n\tReset()\n}\n\n\ntype APIContext struct {\n\tkeys map[string]interface{}\n}\n\n\nfunc (c *APIContext) Set(key string, value interface{}) {\n\tif c.keys == nil {\n\t\tc.keys = make(map[string]interface{})\n\t}\n\tc.keys[key] = value\n}\n\n\nfunc (c *APIContext) Get(key string) (value interface{}, exists bool) {\n\tif c.keys != nil {\n\t\tvalue, exists = c.keys[key]\n\t}\n\treturn\n}\n\n\nfunc (c *APIContext) Reset() {\n\tc.keys = nil\n}\n\n\nfunc (c *APIContext) Deadline() (deadline time.Time, ok bool) {\n\treturn\n}\n\n\nfunc (c *APIContext) Done() <-chan struct{} {\n\treturn nil\n}\n\n\nfunc (c *APIContext) Err() error {\n\treturn nil\n}\n\n\nfunc (c *APIContext) Value(key interface{}) interface{} {\n\tif keyAsString, ok := key.(string); ok {\n\t\tval, _ := c.Get(keyAsString)\n\t\treturn val\n\t}\n\treturn nil\n}\n\n\nvar _ APIContexter = &APIContext{}\n\n\n\n\nfunc ContextQueryParams(c *APIContext) map[string][]string ", "output": "{\n\tqp, ok := c.Get(\"QueryParams\")\n\tif ok == false {\n\t\tqp = make(map[string][]string)\n\t\tc.Set(\"QueryParams\", qp)\n\t}\n\treturn qp.(map[string][]string)\n}"}
{"input": "package uber\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\tistioconfig \"istio.io/api/istio/config/v1\"\n\n\t\"istio.io/mixer/pkg/aspectsupport\"\n\t\"istio.io/mixer/pkg/attribute\"\n\t\"istio.io/mixer/pkg/expr\"\n)\n\ntype (\n\tfakereg struct {\n\t\tRegistryQuerier\n\t}\n\n\tfakemgr struct {\n\t\tkind string\n\t\taspectsupport.Manager\n\t}\n\n\tfakebag struct {\n\t\tattribute.Bag\n\t}\n\n\tfakeevaluator struct {\n\t\texpr.Evaluator\n\t}\n)\n\nfunc (m *fakemgr) Kind() string {\n\treturn m.kind\n}\n\n\n\nfunc TestManager(t *testing.T) ", "output": "{\n\tr := &fakereg{}\n\tmgrs := []aspectsupport.Manager{&fakemgr{kind: \"k1\"}, &fakemgr{kind: \"k2\"}}\n\tm := NewManager(r, mgrs)\n\tcfg := &aspectsupport.CombinedConfig{\n\t\tAspect:  &istioconfig.Aspect{},\n\t\tAdapter: &istioconfig.Adapter{},\n\t}\n\tattrs := &fakebag{}\n\tmapper := &fakeevaluator{}\n\tif _, err := m.Execute(cfg, attrs, mapper); err != nil {\n\t\tif !strings.Contains(err.Error(), \"could not find aspect manager\") {\n\t\t\tt.Error(\"excute errored out: \", err)\n\t\t}\n\n\t}\n}"}
{"input": "package errors\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/GoogleContainerTools/skaffold/proto/v1\"\n)\n\ntype Error interface {\n\tError() string\n\tStatusCode() proto.StatusCode\n\tSuggestions() []*proto.Suggestion\n\tUnwrap() error\n}\n\ntype ErrDef struct {\n\terr error\n\tae  *proto.ActionableErr\n}\n\nvar _ error = (*ErrDef)(nil)\n\nfunc (e *ErrDef) Error() string {\n\tif s := concatSuggestions(e.Suggestions()); s != \"\" {\n\t\treturn fmt.Sprintf(\"%s. %s\", e.ae.Message, concatSuggestions(e.Suggestions()))\n\t}\n\treturn e.ae.Message\n}\n\nfunc (e *ErrDef) Unwrap() error {\n\treturn e.err\n}\n\nfunc (e *ErrDef) StatusCode() proto.StatusCode {\n\treturn e.ae.ErrCode\n}\n\nfunc (e *ErrDef) Suggestions() []*proto.Suggestion {\n\treturn e.ae.Suggestions\n}\n\n\nfunc NewError(err error, ae *proto.ActionableErr) *ErrDef {\n\treturn &ErrDef{\n\t\terr: err,\n\t\tae:  ae,\n\t}\n}\n\n\nfunc NewErrorWithStatusCode(ae *proto.ActionableErr) *ErrDef {\n\treturn &ErrDef{\n\t\tae: ae,\n\t}\n}\n\n\n\nfunc IsSkaffoldErr(err error) bool ", "output": "{\n\tif _, ok := err.(Error); ok {\n\t\treturn true\n\t}\n\treturn false\n}"}
{"input": "package parser\n\ntype sField struct {\n\tName        string\n\tType        string\n\tTag         string\n\tStruct      sStruct\n\tInitialName string\n\n\tattr     bool\n\tpointer  bool\n\tarray    bool\n\trequired bool\n\tnillable bool\n}\n\ntype mapofFields map[string]sField\n\nfunc (m mapofFields) add(i string, s sField) bool {\n\tif i == \"\" || s.Type == \"\" {\n\t\treturn false\n\t}\n\n\ts.resolveType()\n\ts.resolveTag()\n\ts.resolveName(i)\n\tm[s.Name] = s\n\n\treturn true\n}\n\nfunc (s *sField) resolveName(i string) {\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\ts.InitialName = makeExported(normalize(removeNS(i)))\n\ts.Name = makeExported(lintName(normalize(removeNS(i))))\n}\n\nfunc (s *sField) resolveType() {\n\tif s.nillable && s.required {\n\t\ts.Type = toGoType(makeUnexported(lintName(removeNS(s.Type + \"ReqNil\"))))\n\t\treturn\n\t}\n\n\ttn := makeUnexported(lintName(removeNS(s.Type)))\n\tif s.array {\n\t\ts.Type = \"[]\" + toGoType(tn)\n\t\treturn\n\t}\n\tif s.pointer {\n\t\ts.Type = toGoPointerType(tn)\n\t\treturn\n\t}\n\ts.Type = toGoPointerType(tn)\n}\n\n\n\nfunc (s *sField) resolveTag() ", "output": "{\n\tif s.Name == \"\" {\n\t\treturn\n\t}\n\n\tif s.attr {\n\t\ts.Tag = \"`\" + `xml:\"` + s.Name + `,attr\"` + \"`\"\n\t\treturn\n\t}\n\n\ts.Tag = \"`\" + `xml:\"` + s.Name + `\"` + \"`\"\n}"}
{"input": "package mgutil\n\nimport (\n\t\"unicode/utf8\"\n)\n\n\nfunc RepositionLeft(src []byte, pos int, cond func(rune) bool) int {\n\tfor 0 <= pos && pos < len(src) {\n\t\tr, n := utf8.DecodeLastRune(src[:pos])\n\t\tif n < 1 || !cond(r) {\n\t\t\tbreak\n\t\t}\n\t\tpos -= n\n\t}\n\treturn pos\n}\n\n\n\n\nfunc RepositionRight(src []byte, pos int, cond func(rune) bool) int ", "output": "{\n\tfor 0 <= pos && pos < len(src) {\n\t\tr, n := utf8.DecodeRune(src[pos:])\n\t\tif n < 1 || !cond(r) {\n\t\t\tbreak\n\t\t}\n\t\tpos += n\n\t}\n\treturn pos\n}"}
{"input": "package misc\n\nimport (\n\t\"crypto/md5\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n)\n\n\n\nfunc MD5(text string) string {\n\th := md5.New()\n\tio.WriteString(h, text)\n\treturn fmt.Sprintf(\"%x\", h.Sum(nil))\n}\n\n\nfunc Base64(src string) string {\n\treturn base64.URLEncoding.EncodeToString([]byte(src))\n}\n\n\n\n\n\nfunc Unused(...interface{}) {}\n\nfunc UnBase64(src string) string ", "output": "{\n\tdata, err := base64.URLEncoding.DecodeString(src)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn string(data)\n}"}
{"input": "package geocoder\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"strings\"\n)\n\nconst (\n\tGOOGLE_ENDPOINT = \"%s://maps.googleapis.com/maps/api/geocode/json?address=%v&sensor=false\"\n)\n\n\ntype Google struct {\n\tUseSsl bool\n\tLocale string\n\tRegion string\n}\n\ntype results struct {\n\tResults []result `json:\"results\"`\n}\n\ntype result struct {\n\tFormattedAddress string   `json:\"formatted_address\"`\n\tGeometry         geometry `json:\"geometry\"`\n}\n\ntype geometry struct {\n\tLocation Coordinate `json:\"location\"`\n}\n\nfunc (g *Google) buildEndpoint() string {\n\tvar endpoint, scheme string\n\tif g.UseSsl {\n\t\tscheme = \"https\"\n\t} else {\n\t\tscheme = \"http\"\n\t}\n\n\tendpoint = fmt.Sprintf(GOOGLE_ENDPOINT, scheme, \"%v\")\n\n\tif g.Locale != \"\" {\n\t\tendpoint = fmt.Sprintf(\"%s&language=%s\", endpoint, g.Locale)\n\t}\n\n\tif g.Region != \"\" {\n\t\tendpoint = fmt.Sprintf(\"%s&region=%s\", endpoint, g.Region)\n\t}\n\n\treturn endpoint\n}\n\n\nfunc (g *Google) Geocode(a Address) (*Coordinate, error) {\n\turl := fmt.Sprintf(g.buildEndpoint(), url.QueryEscape(strings.TrimSpace(a.Street)))\n\n\tresp, err := request(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res results\n\tif err := json.NewDecoder(resp.Body).Decode(&res); err != nil {\n\t\treturn nil, err\n\t}\n\n\tlocation := res.Results[0].Geometry.Location\n\n\treturn &Coordinate{location.Lat, location.Lng}, nil\n}\n\n\n\n\nfunc (g *Google) Reverse(c Coordinate) (*Address, error) ", "output": "{\n\turl := fmt.Sprintf(g.buildEndpoint(), fmt.Sprintf(\"%f,%f\", c.Lat, c.Lng))\n\n\tresp, err := request(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res results\n\tif err := json.NewDecoder(resp.Body).Decode(&res); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Address{res.Results[0].FormattedAddress}, nil\n}"}
{"input": "package hooks\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\n\t\"github.com/cloudfoundry/libbuildpack\"\n)\n\ntype AppHook struct {\n\tlibbuildpack.DefaultHook\n}\n\nfunc init() {\n\tlibbuildpack.AddHook(AppHook{})\n}\n\nfunc (h AppHook) BeforeCompile(compiler *libbuildpack.Stager) error {\n\treturn runHook(\"pre_compile\", compiler)\n}\n\n\n\nfunc runHook(scriptName string, compiler *libbuildpack.Stager) error {\n\tpath := filepath.Join(compiler.BuildDir(), \"bin\", scriptName)\n\tif exists, err := libbuildpack.FileExists(path); err != nil {\n\t\treturn err\n\t} else if exists {\n\t\tcompiler.Logger().BeginStep(\"Running \" + scriptName + \" hook\")\n\t\tif err := os.Chmod(path, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfileContents, err := ioutil.ReadFile(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tshebangRegex := regexp.MustCompile(\"^\\\\s*#!\")\n\t\thasShebang := shebangRegex.Match(fileContents)\n\n\t\tvar cmd *exec.Cmd\n\t\tif hasShebang {\n\t\t\tcmd = exec.Command(path)\n\t\t} else {\n\t\t\tcmd = exec.Command(\"/bin/sh\", path)\n\t\t}\n\n\t\tcmd.Dir = compiler.BuildDir()\n\t\toutput, err := cmd.CombinedOutput()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcompiler.Logger().Info(\"%s\", output)\n\t}\n\treturn nil\n\n}\n\nfunc (h AppHook) AfterCompile(compiler *libbuildpack.Stager) error ", "output": "{\n\treturn runHook(\"post_compile\", compiler)\n}"}
{"input": "package exchange\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n\ntype ValidPeriod struct {\n\tdate    time.Time\n\texpires time.Time\n}\n\n\n\nfunc NewValidPeriod(date, expires time.Time) ValidPeriod {\n\treturn ValidPeriod{date, expires}\n}\n\n\n\nfunc NewValidPeriodWithLifetime(date time.Time, lifetime time.Duration) ValidPeriod {\n\treturn ValidPeriod{date, date.Add(lifetime)}\n}\n\n\nfunc (vp ValidPeriod) Date() time.Time {\n\treturn vp.date\n}\n\n\nfunc (vp ValidPeriod) Expires() time.Time {\n\treturn vp.expires\n}\n\n\nfunc (vp ValidPeriod) Lifetime() time.Duration {\n\treturn vp.expires.Sub(vp.date)\n}\n\n\n\n\n\n\n\nfunc (vp ValidPeriod) String() string {\n\treturn fmt.Sprintf(\"[%s] to [%s]\", vp.date, vp.expires)\n}\n\nfunc (vp ValidPeriod) Contains(t time.Time) bool ", "output": "{\n\treturn !t.Before(vp.date) && !t.After(vp.expires)\n}"}
{"input": "package httputil\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc accessLogger(l chan string) {\n\tfor {\n\t\tlog.Print(<-l)\n\t}\n}\n\ntype statusWrapper struct {\n\tstatus int\n\thttp.ResponseWriter\n}\n\nfunc (s *statusWrapper) WriteHeader(status int) {\n\ts.status = status\n\ts.ResponseWriter.WriteHeader(status)\n}\n\n\n\nfunc NewLogWrapper(handler http.Handler) http.Handler {\n\tlchan := make(chan string, 64)\n\tgo accessLogger(lchan)\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tsw := statusWrapper{-1, w}\n\t\tw.Header().Set(\"Server\", \"Go HTTP handler\")\n\t\thandler.ServeHTTP(&sw, r)\n\t\thttpLog(lchan, &sw, r)\n\t})\n}\n\nfunc httpLog(l chan string, sw *statusWrapper, r *http.Request) ", "output": "{\n\n\tvar remote string\n\tif len(r.Header[\"X-Forwarded-For\"]) > 0 {\n\t\tremote = r.Header[\"X-Forwarded-For\"][0]\n\t} else {\n\t\tremote = r.RemoteAddr\n\t}\n\tl <- fmt.Sprintf(\"%s %s %s %d\", remote, r.Method, r.URL, sw.status)\n}"}
{"input": "package summary\n\nimport (\n\t\"encoding/xml\"\n\t\"log\"\n\t\"os\"\n\t\"testing\"\n\n\t\"golang.org/x/net/html/charset\"\n)\n\nfunc TestSectionsSize(t *testing.T) {\n\tboe := readXML()\n\texpected := 7\n\tactual := boe.SectionsSize()\n\tif actual != expected {\n\t\tt.Error(\"Expected\", expected, \"but found\", actual)\n\t}\n}\n\n\n\nfunc readXML() BoeSummary {\n\txmlFile, err := os.Open(\"example.xml\")\n\tif err != nil {\n\t\tlog.Fatalln(\"Error opening file:\", err)\n\t}\n\tdefer xmlFile.Close()\n\n\tvar summary BoeSummary\n\tdecoder := xml.NewDecoder(xmlFile)\n\tdecoder.CharsetReader = charset.NewReaderLabel\n\terr = decoder.Decode(&summary)\n\n\treturn summary\n}\n\nfunc TestMetadata(t *testing.T) ", "output": "{\n\tsummary := readXML()\n\tbulletinType := summary.Meta.BulletinType\n\tlastDate := summary.Meta.LastPublicationDate\n\tnextDate := summary.Meta.NextPublicationDate\n\tpubDate := summary.Meta.PublicationDate\n\tif bulletinType != \"BOE\" {\n\t\tt.Error(\"Expected bulletin type BOE, got\", bulletinType)\n\t}\n\tif lastDate != \"17/10/2014\" {\n\t\tt.Error(\"Expected last data 18/10/2014, got\", lastDate)\n\t}\n\tif nextDate != \"20/10/2014\" {\n\t\tt.Error(\"Expected last data 20/10/2014, got\", nextDate)\n\t}\n\tif pubDate != \"18/10/2014\" {\n\t\tt.Error(\"Expected last data 18/10/2014, got\", pubDate)\n\t}\n}"}
{"input": "package around\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"log\"\n\t\"bytes\"\n\t\"strings\"\n\t\"encoding/json\"\n)\n\nfunc Connect(quit chan int) {\n\tres, err := http.Get(\"https://\"+getApiKey()+\"@streaming.campfirenow.com/room/\"+getRoomId()+\"/live.json\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tvar buffer bytes.Buffer\n\n\tln := []byte{13}\n\n\tstringLn := string(ln)\n\n\tfor {\n\t\tb := []byte{10}\n\t\t_, err := res.Body.Read(b)\n\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\ts := string(b)\n\n\t\tif s == stringLn {\n\t\t\tline := buffer.String()\n\n\t\t\tif line != \" \" {\n\t\t\t\tdec := json.NewDecoder(strings.NewReader(line))\n\n\t\t\t\tvar message Message\n\n\t\t\t\terr = dec.Decode(&message)\n\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tfmt.Println(message.Body)\n\t\t\t}\n\t\t\tbuffer.Reset()\n\t\t} else {\n\t\t\tbuffer.WriteString(s)\n\t\t}\n\n\t}\n\tquit <- 1\n}\n\n\n\n\n\n\ntype Message struct {\n\tStarred bool\n\tUserId int\n\tRoomId int\n\tId int\n\tBody string\n\tTime string\n}\n\nfunc Speak(words string) ", "output": "{\n\txmlMessage := \"<message><type>TextMessage</type><body>\" + words +  \"</body></message>\"\n\txmlReader := strings.NewReader(xmlMessage)\n\n\n\t_, err := http.Post(\"https://\"+getApiKey()+\"@\"+getCampfireDomain()+\"/room/\"+getRoomId()+\"/speak.xml\", \"text/xml\", xmlReader)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"input": "package configuration\n\nimport (\n\t\"github.com/cloudfoundry/cli/cf/configuration/core_config\"\n\t\"github.com/cloudfoundry/cli/cf/models\"\n)\n\nfunc NewRepository() core_config.Repository {\n\treturn core_config.NewRepositoryFromPersistor(NewFakePersistor(), func(err error) {\n\t\tpanic(err)\n\t})\n}\n\nfunc NewRepositoryWithAccessToken(tokenInfo core_config.TokenInfo) core_config.Repository {\n\taccessToken, err := EncodeAccessToken(tokenInfo)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tconfig := NewRepository()\n\tconfig.SetAccessToken(accessToken)\n\treturn config\n}\n\n\n\nfunc NewRepositoryWithDefaults() core_config.Repository ", "output": "{\n\tconfigRepo := NewRepositoryWithAccessToken(core_config.TokenInfo{\n\t\tUserGuid: \"my-user-guid\",\n\t\tUsername: \"my-user\",\n\t\tEmail:    \"my-user-email\",\n\t})\n\n\tconfigRepo.SetSpaceFields(models.SpaceFields{\n\t\tName: \"my-space\",\n\t\tGuid: \"my-space-guid\",\n\t})\n\tconfigRepo.SetOrganizationFields(models.OrganizationFields{\n\t\tName: \"my-org\",\n\t\tGuid: \"my-org-guid\",\n\t})\n\n\treturn configRepo\n}"}
{"input": "package discordgo\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n\ntype User struct {\n\tID            string `json:\"id\"`\n\tEmail         string `json:\"email\"`\n\tUsername      string `json:\"username\"`\n\tAvatar        string `json:\"avatar\"`\n\tDiscriminator string `json:\"discriminator\"`\n\tToken         string `json:\"token\"`\n\tVerified      bool   `json:\"verified\"`\n\tMFAEnabled    bool   `json:\"mfa_enabled\"`\n\tBot           bool   `json:\"bot\"`\n}\n\n\n\n\n\nfunc (u *User) Mention() string {\n\treturn fmt.Sprintf(\"<@%s>\", u.ID)\n}\n\n\n\n\n\nfunc (u *User) AvatarURL(size string) string {\n\tvar URL string\n\tif strings.HasPrefix(u.Avatar, \"a_\") {\n\t\tURL = EndpointUserAvatarAnimated(u.ID, u.Avatar)\n\t} else {\n\t\tURL = EndpointUserAvatar(u.ID, u.Avatar)\n\t}\n\n\tif size != \"\" {\n\t\treturn URL + \"?size=\" + size\n\t}\n\treturn URL\n}\n\nfunc (u *User) String() string ", "output": "{\n\treturn fmt.Sprintf(\"%s#%s\", u.Username, u.Discriminator)\n}"}
{"input": "package heap\n\nimport \"jvmgo/ch07/classfile\"\n\ntype Field struct {\n\tClassMember\n\tconstValueIndex uint\n\tslotId          uint\n}\n\nfunc newFields(class *Class, cfFields []*classfile.MemberInfo) []*Field {\n\tfields := make([]*Field, len(cfFields))\n\tfor i, cfField := range cfFields {\n\t\tfields[i] = &Field{}\n\t\tfields[i].class = class\n\t\tfields[i].copyMemberInfo(cfField)\n\t\tfields[i].copyAttributes(cfField)\n\t}\n\treturn fields\n}\nfunc (self *Field) copyAttributes(cfField *classfile.MemberInfo) {\n\tif valAttr := cfField.ConstantValueAttribute(); valAttr != nil {\n\t\tself.constValueIndex = uint(valAttr.ConstantValueIndex())\n\t}\n}\n\nfunc (self *Field) IsVolatile() bool {\n\treturn 0 != self.accessFlags&ACC_VOLATILE\n}\nfunc (self *Field) IsTransient() bool {\n\treturn 0 != self.accessFlags&ACC_TRANSIENT\n}\nfunc (self *Field) IsEnum() bool {\n\treturn 0 != self.accessFlags&ACC_ENUM\n}\n\nfunc (self *Field) ConstValueIndex() uint {\n\treturn self.constValueIndex\n}\n\nfunc (self *Field) isLongOrDouble() bool {\n\treturn self.descriptor == \"J\" || self.descriptor == \"D\"\n}\n\nfunc (self *Field) SlotId() uint ", "output": "{\n\treturn self.slotId\n}"}
{"input": "package cache\n\nimport (\n\tkapi \"k8s.io/kubernetes/pkg/api\"\n\tkapierrors \"k8s.io/kubernetes/pkg/api/errors\"\n\t\"k8s.io/kubernetes/pkg/controller/framework\"\n\n\toapi \"github.com/openshift/origin/pkg/api\"\n\tauthorizationapi \"github.com/openshift/origin/pkg/authorization/api\"\n\tclusterpolicyregistry \"github.com/openshift/origin/pkg/authorization/registry/clusterpolicy\"\n\t\"github.com/openshift/origin/pkg/client\"\n)\n\ntype InformerToClusterPolicyLister struct {\n\tframework.SharedIndexInformer\n}\n\n\nfunc (i *InformerToClusterPolicyLister) LastSyncResourceVersion() string {\n\treturn i.SharedIndexInformer.LastSyncResourceVersion()\n}\n\nfunc (i *InformerToClusterPolicyLister) ClusterPolicies() client.ClusterPolicyLister {\n\treturn i\n}\n\nfunc (i *InformerToClusterPolicyLister) List(options kapi.ListOptions) (*authorizationapi.ClusterPolicyList, error) {\n\tclusterPolicyList := &authorizationapi.ClusterPolicyList{}\n\treturnedList := i.GetIndexer().List()\n\tmatcher := clusterpolicyregistry.Matcher(oapi.ListOptionsToSelectors(&options))\n\tfor i := range returnedList {\n\t\tclusterPolicy := returnedList[i].(*authorizationapi.ClusterPolicy)\n\t\tif matches, err := matcher.Matches(clusterPolicy); err == nil && matches {\n\t\t\tclusterPolicyList.Items = append(clusterPolicyList.Items, *clusterPolicy)\n\t\t}\n\t}\n\treturn clusterPolicyList, nil\n}\n\n\n\nfunc (i *InformerToClusterPolicyLister) Get(name string) (*authorizationapi.ClusterPolicy, error) ", "output": "{\n\tkeyObj := &authorizationapi.ClusterPolicy{ObjectMeta: kapi.ObjectMeta{Name: name}}\n\tkey, _ := framework.DeletionHandlingMetaNamespaceKeyFunc(keyObj)\n\n\titem, exists, getErr := i.GetIndexer().GetByKey(key)\n\tif getErr != nil {\n\t\treturn nil, getErr\n\t}\n\tif !exists {\n\t\texistsErr := kapierrors.NewNotFound(authorizationapi.Resource(\"clusterpolicy\"), name)\n\t\treturn nil, existsErr\n\t}\n\treturn item.(*authorizationapi.ClusterPolicy), nil\n}"}
{"input": "package datastore\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path\"\n)\n\n\ntype Posix struct {\n\tMountPoint string\n}\n\n\n\n\n\nfunc (p *Posix) Delete(ID string) error {\n\timageName := path.Join(p.MountPoint, ID)\n\n\t_, err := os.Stat(imageName)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\terr = nil\n\t\t}\n\t\treturn err\n\t}\n\n\terr = os.Remove(imageName)\n\n\treturn err\n}\n\n\nfunc (p *Posix) GetImageSize(ID string) (uint64, error) {\n\timageName := path.Join(p.MountPoint, ID)\n\n\tfi, err := os.Stat(imageName)\n\timageSize := uint64(fi.Size())\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"Error getting image size: %v\", err)\n\t}\n\treturn imageSize, nil\n}\n\nfunc (p *Posix) Write(ID string, body io.Reader) (err error) ", "output": "{\n\timageName := path.Join(p.MountPoint, ID)\n\tif _, err := os.Stat(imageName); !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"image already uploaded with that ID\")\n\t}\n\n\timage, err := os.Create(imageName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbuf := make([]byte, 1<<16)\n\n\t_, err = io.CopyBuffer(image, body, buf)\n\tdefer func() {\n\t\terr1 := image.Close()\n\t\tif err == nil {\n\t\t\terr = err1\n\t\t}\n\t}()\n\n\treturn err\n}"}
{"input": "package command\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/hashicorp/nomad/nomad/mock\"\n\t\"github.com/mitchellh/cli\"\n\t\"github.com/posener/complete\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestJobHistoryCommand_Implements(t *testing.T) {\n\tt.Parallel()\n\tvar _ cli.Command = &JobDispatchCommand{}\n}\n\nfunc TestJobHistoryCommand_Fails(t *testing.T) {\n\tt.Parallel()\n\tui := new(cli.MockUi)\n\tcmd := &JobHistoryCommand{Meta: Meta{Ui: ui}}\n\n\tif code := cmd.Run([]string{\"some\", \"bad\", \"args\"}); code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got: %d\", code)\n\t}\n\tif out := ui.ErrorWriter.String(); !strings.Contains(out, cmd.Help()) {\n\t\tt.Fatalf(\"expected help output, got: %s\", out)\n\t}\n\tui.ErrorWriter.Reset()\n\n\tif code := cmd.Run([]string{\"-address=nope\", \"foo\"}); code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got: %d\", code)\n\t}\n\tif out := ui.ErrorWriter.String(); !strings.Contains(out, \"Error listing jobs\") {\n\t\tt.Fatalf(\"expected failed query error, got: %s\", out)\n\t}\n\tui.ErrorWriter.Reset()\n}\n\n\n\nfunc TestJobHistoryCommand_AutocompleteArgs(t *testing.T) ", "output": "{\n\tassert := assert.New(t)\n\tt.Parallel()\n\n\tsrv, _, url := testServer(t, true, nil)\n\tdefer srv.Shutdown()\n\n\tui := new(cli.MockUi)\n\tcmd := &JobHistoryCommand{Meta: Meta{Ui: ui, flagAddress: url}}\n\n\tstate := srv.Agent.Server().State()\n\tj := mock.Job()\n\tassert.Nil(state.UpsertJob(1000, j))\n\n\tprefix := j.ID[:len(j.ID)-5]\n\targs := complete.Args{Last: prefix}\n\tpredictor := cmd.AutocompleteArgs()\n\n\tres := predictor.Predict(args)\n\tassert.Equal(1, len(res))\n\tassert.Equal(j.ID, res[0])\n}"}
{"input": "package hash\n\nimport \"unsafe\"\n\nconst DJBInit uint32 = 5381\n\nfunc DJBCombine(acc, h uint32) uint32 {\n\treturn mul33(acc) + h\n}\n\n\n\nfunc UInt32(u uint32) uint32 {\n\treturn u\n}\n\nfunc UInt64(u uint64) uint32 {\n\treturn mul33(uint32(u>>32)) + uint32(u&0xffffffff)\n}\n\nfunc Pointer(p unsafe.Pointer) uint32 {\n\tswitch unsafe.Sizeof(p) {\n\tcase 4:\n\t\treturn UInt32(uint32(uintptr(p)))\n\tcase 8:\n\t\treturn UInt64(uint64(uintptr(p)))\n\tdefault:\n\t\tpanic(\"unhandled pointer size\")\n\t}\n}\n\nfunc UIntPtr(p uintptr) uint32 {\n\tswitch unsafe.Sizeof(p) {\n\tcase 4:\n\t\treturn UInt32(uint32(p))\n\tcase 8:\n\t\treturn UInt64(uint64(p))\n\tdefault:\n\t\tpanic(\"unhandled pointer size\")\n\t}\n}\n\nfunc String(s string) uint32 {\n\th := DJBInit\n\tfor i := 0; i < len(s); i++ {\n\t\th = DJBCombine(h, uint32(s[i]))\n\t}\n\treturn h\n}\n\nfunc mul33(u uint32) uint32 {\n\treturn u<<5 + u\n}\n\nfunc DJB(hs ...uint32) uint32 ", "output": "{\n\tacc := DJBInit\n\tfor _, h := range hs {\n\t\tacc = DJBCombine(acc, h)\n\t}\n\treturn acc\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/go-gl/gl/v3.3-core/gl\"\n)\n\ntype Buffer interface {\n}\n\ntype GLBuffer struct {\n\tid          uint32\n\tbufferBytes int\n\ttarget      uint32\n}\n\n\n\nfunc (b *GLBuffer) BufferID() uint32 {\n\treturn b.id\n}\n\nfunc (b *GLBuffer) Bind() {\n\tgl.BindBuffer(b.target, b.id)\n}\n\nfunc (b *GLBuffer) Delete() {\n\tgl.DeleteBuffers(1, &b.id)\n}\n\nfunc (b *GLBuffer) Upload(data interface{}, size int) {\n\tb.Bind()\n\tif size > b.bufferBytes {\n\t\tb.bufferBytes = size\n\t\tgl.BufferData(b.target, size, gl.Ptr(data), gl.STREAM_DRAW)\n\t} else {\n\t\tgl.BufferSubData(b.target, 0, size, gl.Ptr(data))\n\t}\n}\n\nfunc (b *GLBuffer) Size() int {\n\treturn b.bufferBytes\n}\n\ntype UniformBuffer struct {\n\t*GLBuffer\n}\n\nfunc NewUniformBuffer() (b *UniformBuffer) {\n\tb = &UniformBuffer{\n\t\tGLBuffer: NewGLBuffer(gl.UNIFORM_BUFFER),\n\t}\n\treturn\n}\n\ntype ArrayBuffer struct {\n\t*GLBuffer\n}\n\nfunc NewArrayBuffer() (b *ArrayBuffer) {\n\tb = &ArrayBuffer{\n\t\tGLBuffer: NewGLBuffer(gl.ARRAY_BUFFER),\n\t}\n\treturn\n}\n\nfunc NewGLBuffer(target uint32) (b *GLBuffer) ", "output": "{\n\tb = &GLBuffer{\n\t\ttarget: target,\n\t}\n\tgl.GenBuffers(1, &b.id)\n\tb.Bind()\n\treturn\n}"}
{"input": "package conui\n\n\ntype ColorScheme struct {\n\tBodyBg            Attribute\n\tBlockBg           Attribute\n\tHasBorder         bool\n\tBorderFg          Attribute\n\tBorderBg          Attribute\n\tBorderLabelTextFg Attribute\n\tBorderLabelTextBg Attribute\n\tParTextFg         Attribute\n\tParTextBg         Attribute\n\tSparklineLine     Attribute\n\tSparklineTitle    Attribute\n\tGaugeBar          Attribute\n\tGaugePercent      Attribute\n\tLineChartLine     Attribute\n\tLineChartAxes     Attribute\n\tListItemFg        Attribute\n\tListItemBg        Attribute\n\tBarChartBar       Attribute\n\tBarChartText      Attribute\n\tBarChartNum       Attribute\n\tMBarChartBar      Attribute\n\tMBarChartText     Attribute\n\tMBarChartNum      Attribute\n}\n\n\nvar themeDefault = ColorScheme{HasBorder: true}\n\nvar themeHelloWorld = ColorScheme{\n\tBodyBg:            ColorBlack,\n\tBlockBg:           ColorBlack,\n\tHasBorder:         true,\n\tBorderFg:          ColorWhite,\n\tBorderBg:          ColorBlack,\n\tBorderLabelTextBg: ColorBlack,\n\tBorderLabelTextFg: ColorGreen,\n\tParTextBg:         ColorBlack,\n\tParTextFg:         ColorWhite,\n\tSparklineLine:     ColorMagenta,\n\tSparklineTitle:    ColorWhite,\n\tGaugeBar:          ColorRed,\n\tGaugePercent:      ColorWhite,\n\tLineChartLine:     ColorYellow | AttrBold,\n\tLineChartAxes:     ColorWhite,\n\tListItemBg:        ColorBlack,\n\tListItemFg:        ColorYellow,\n\tBarChartBar:       ColorRed,\n\tBarChartNum:       ColorWhite,\n\tBarChartText:      ColorCyan,\n\tMBarChartBar:      ColorRed,\n\tMBarChartNum:      ColorWhite,\n\tMBarChartText:     ColorCyan,\n}\n\nvar theme = themeDefault \n\n\nfunc Theme() ColorScheme {\n\treturn theme\n}\n\n\nfunc SetTheme(newTheme ColorScheme) {\n\ttheme = newTheme\n}\n\n\n\n\n\nfunc UseTheme(th string) ", "output": "{\n\tswitch th {\n\tcase \"helloworld\":\n\t\ttheme = themeHelloWorld\n\tdefault:\n\t\ttheme = themeDefault\n\t}\n}"}
{"input": "package time\n\nimport (\n\t\"errors\"\n\t\"syscall\"\n)\n\n\nfunc interrupt() {\n}\n\n\n\n\nfunc readFile(name string) ([]byte, error) {\n\tf, err := syscall.Open(name, syscall.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer syscall.Close(f)\n\tvar (\n\t\tbuf [4096]byte\n\t\tret []byte\n\t\tn   int\n\t)\n\tfor {\n\t\tn, err = syscall.Read(f, buf[:])\n\t\tif n > 0 {\n\t\t\tret = append(ret, buf[:n]...)\n\t\t}\n\t\tif n == 0 || err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn ret, err\n}\n\nfunc open(name string) (uintptr, error) {\n\tfd, err := syscall.Open(name, syscall.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn uintptr(fd), nil\n}\n\nfunc closefd(fd uintptr) {\n\tsyscall.Close(syscall.Handle(fd))\n}\n\n\n\nfunc preadn(fd uintptr, buf []byte, off int) error ", "output": "{\n\twhence := seekStart\n\tif off < 0 {\n\t\twhence = seekEnd\n\t}\n\tif _, err := syscall.Seek(syscall.Handle(fd), int64(off), whence); err != nil {\n\t\treturn err\n\t}\n\tfor len(buf) > 0 {\n\t\tm, err := syscall.Read(syscall.Handle(fd), buf)\n\t\tif m <= 0 {\n\t\t\tif err == nil {\n\t\t\t\treturn errors.New(\"short read\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tbuf = buf[m:]\n\t}\n\treturn nil\n}"}
{"input": "package router\n\nimport (\n\t\"github.com/henrylee2cn/faygo\"\n\t\"github.com/henrylee2cn/faygo/ext/db/directsqlx\"\n\t\"github.com/henrylee2cn/faygo/samples/directsql/handler\"\n)\n\n\n\n\nfunc Route(frame *faygo.Framework) ", "output": "{\n\tfaygo.SetUpload(\"./upload\", false, false)\n\tfaygo.SetStatic(\"./static\", false, false)\n\tframe.NamedAPI(\"Home\", \"GET\", \"/\", handler.Index())\n\tframe.NamedAPI(\"DirectSQLX\", \"POST\", \"/bosx/*path\", directsql.DirectSQL())\n\tframe.NamedGET(\"DirectSQLX ModelSql Reload\", \"/bomx/reloadall\", directsql.DirectSQLReloadAll())\n\tframe.NamedGET(\"DirectSQLX ModelSql Reload\", \"/bomx/reload/*path\", directsql.DirectSQLReloadModel())\n\tframe.NamedAPI(\"Pongo2\", \"GET\", \"/pongo2\", handler.Pongo2())\n\tframe.NamedStaticFS(\"render\", \"/tpl\", faygo.RenderFS(\n\t\t\"./view\",\n\t\t\".tpl\", \n\t\tfaygo.Map{\"title\": \"tpl page\"},\n\t))\n}"}
{"input": "package nunc\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype State int32\n\nconst (\n\tClosed State = iota - 1\n\tResolved\n\tOpen\n\tInProgress\n\tFeedback\n)\n\ntype Task struct {\n\tEID          int64 `ql:\"index xEID\"`\n\tContext      int64\n\tText         string\n\tState        State\n\tCreation     time.Time\n\tModification time.Time\n\tParent       int64\n}\n\nfunc (t *Task) StateString() (state string) {\n\tswitch t.State {\n\tcase Closed:\n\t\tstate = \"x\"\n\tcase Resolved:\n\t\tstate = \".\"\n\tcase Open:\n\t\tstate = \"o\"\n\tcase InProgress:\n\t\tstate = \">\"\n\tcase Feedback:\n\t\tstate = \"?\"\n\tdefault:\n\t\tstate = \"!\"\n\t}\n\treturn\n}\n\n\n\nfunc TaskPath(context Context, task Task) string {\n\treturn filepath.Join(context.ShortName, strconv.FormatInt(task.EID, 10))\n}\n\nfunc TaskBody(context Context, task Task) (string, error) {\n\tdata, err := ioutil.ReadFile(ResolvePath(TaskPath(context, task)))\n\treturn string(data), err\n}\n\nfunc TaskID(context Context, task Task) string ", "output": "{\n\treturn fmt.Sprintf(\"@%s-%d\", context.ShortName, task.EID)\n}"}
{"input": "package goesl\n\nimport \"fmt\"\n\n\nfunc (sc *SocketConnection) ExecuteSet(key string, value string, sync bool) (m *Message, err error) {\n\treturn sc.Execute(\"set\", fmt.Sprintf(\"%s=%s\", key, value), sync)\n}\n\n\n\n\n\nfunc (sc *SocketConnection) ExecuteHangup(uuid string, args string, sync bool) (m *Message, err error) {\n\tif uuid != \"\" {\n\t\treturn sc.ExecuteUUID(uuid, \"hangup\", args, sync)\n\t}\n\n\treturn sc.Execute(\"hangup\", args, sync)\n}\n\n\nfunc (sc *SocketConnection) Api(command string) error {\n\treturn sc.Send(fmt.Sprintf(\"api %s\", command))\n}\n\n\nfunc (sc *SocketConnection) BgApi(command string) error {\n\treturn sc.Send(fmt.Sprintf(\"bgapi %s\", command))\n}\n\n\n\nfunc (sc *SocketConnection) Connect() error {\n\treturn sc.Send(\"connect\")\n}\n\n\nfunc (sc *SocketConnection) Exit() error {\n\treturn sc.Send(\"exit\")\n}\n\nfunc (sc *SocketConnection) ExecuteAnswer(args string, sync bool) (m *Message, err error) ", "output": "{\n\treturn sc.Execute(\"answer\", args, sync)\n}"}
{"input": "package wml_test\n\nimport (\n\t\"encoding/xml\"\n\t\"testing\"\n\n\t\"baliance.com/gooxml/schema/soo/wml\"\n)\n\n\n\nfunc TestWdWgpMarshalUnmarshal(t *testing.T) {\n\tv := wml.NewWdWgp()\n\tbuf, _ := xml.Marshal(v)\n\tv2 := wml.NewWdWgp()\n\txml.Unmarshal(buf, v2)\n}\n\nfunc TestWdWgpConstructor(t *testing.T) ", "output": "{\n\tv := wml.NewWdWgp()\n\tif v == nil {\n\t\tt.Errorf(\"wml.NewWdWgp must return a non-nil value\")\n\t}\n\tif err := v.Validate(); err != nil {\n\t\tt.Errorf(\"newly constructed wml.WdWgp should validate: %s\", err)\n\t}\n}"}
{"input": "package guest\n\nimport (\n\t\"flag\"\n\n\t\"os\"\n\n\t\"github.com/RotatingFans/govmomi/govc/cli\"\n\t\"golang.org/x/net/context\"\n)\n\ntype download struct {\n\t*GuestFlag\n\n\toverwrite bool\n}\n\nfunc init() {\n\tcli.Register(\"guest.download\", &download{})\n}\n\n\n\nfunc (cmd *download) Process(ctx context.Context) error {\n\tif err := cmd.GuestFlag.Process(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (cmd *download) Run(ctx context.Context, f *flag.FlagSet) error {\n\tm, err := cmd.FileManager()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsrc := f.Arg(0)\n\tdst := f.Arg(1)\n\n\t_, err = os.Stat(dst)\n\tif err == nil && !cmd.overwrite {\n\t\treturn os.ErrExist\n\t}\n\n\tinfo, err := m.InitiateFileTransferFromGuest(context.TODO(), cmd.Auth(), src)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tu, err := cmd.ParseURL(info.Url)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc, err := cmd.Client()\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\treturn c.Client.DownloadFile(dst, u, nil)\n}\n\nfunc (cmd *download) Register(ctx context.Context, f *flag.FlagSet) ", "output": "{\n\tcmd.GuestFlag, ctx = newGuestFlag(ctx)\n\tcmd.GuestFlag.Register(ctx, f)\n\n\tf.BoolVar(&cmd.overwrite, \"f\", false, \"If set, the local destination file is clobbered\")\n}"}
{"input": "package main\nimport (\n\t\"time\"\n\t\"log\"\n\t\"os\"\n\t\"fmt\"\n\t\"runtime\"\n)\n\n\n\nfunc main() {\n\tcpu := runtime.NumCPU()\n\tlog.Printf(\"Num cpu: %v\\n\", cpu)\n\truntime.GOMAXPROCS(1)\n\n\tstart := time.Now()\n\tlog.Printf(\"Started: %v\", start)\n\n\tconcurrentTotal := 4\n\tlog.Printf(\"Number of concurrent calls: %v\", concurrentTotal)\n\n\tfor i := 0; i < concurrentTotal; i++ {\n\t\tfunc (concurrentCount int) {\n\t\t\tfor j:= 0; j < 10000000000; j++ {\n\t\t\t\tif j % 100000000 == 0 {\n\t\t\t\t\tlog.Printf(\"[%v] %v\", concurrentCount, j)\n\t\t\t\t}\n\t\t\t}\n\t\t\tlog.Printf(\"-- DONE Concurrent routine #%v\", concurrentCount)\n\t\t}(i)\n\t}\n\tlog.Println(\"------------------------------\")\n\tfmt.Printf(\"Elapsed time: %v\\n\", time.Since(start))\n}\n\nfunc init() ", "output": "{\n\tlog.SetOutput(os.Stdout)\n}"}
{"input": "package rest\n\nimport (\n\t\"fmt\"\n)\n\ntype imagecache struct {\n\tca cache\n}\n\ntype pic struct {\n\tpng    []byte\n\tpkthsh hashcode\n}\n\nfunc (p pic) hash() hashcode {\n\treturn p.pkthsh\n}\n\n\n\nfunc (ic imagecache) put(hsh hashcode, png []byte) {\n\tsz := 0\n\tif __DEBUG {\n\t\tsz = len(png)\n\t}\n\tdebugf(\"Storing image for %v (length %v)\", hsh, sz)\n\tp := pic{}\n\tp.png = png\n\tp.pkthsh = hsh\n\tic.ca.put(p)\n}\n\nfunc (ic imagecache) get(hsh hashcode) ([]byte, bool) {\n\tdebugf(\"Fetching image for %v\", hsh)\n\tany, present := ic.ca.get(hsh)\n\tif !present {\n\t\treturn nil, false\n\t}\n\tp, ok := any.(pic)\n\tif !ok {\n\t\tpanic(fmt.Sprintf(\"Expected type pic received: %v\", any))\n\t}\n\treturn p.png, true\n}\n\nfunc makeImageCache() imagecache ", "output": "{\n\tic := imagecache{}\n\tic.ca = makeCache(pic{})\n\treturn ic\n}"}
{"input": "package pubsub\n\nimport (\n\t\"time\"\n\n\t\"github.com/golang/protobuf/ptypes\"\n\tpb \"google.golang.org/genproto/googleapis/pubsub/v1\"\n)\n\n\ntype Message struct {\n\tID string\n\n\tData []byte\n\n\tAttributes map[string]string\n\n\tackID string\n\n\tPublishTime time.Time\n\n\tcalledDone bool\n\n\tdoneFunc func(string, bool)\n}\n\nfunc toMessage(resp *pb.ReceivedMessage) (*Message, error) {\n\tif resp.Message == nil {\n\t\treturn &Message{ackID: resp.AckId}, nil\n\t}\n\n\tpubTime, err := ptypes.Timestamp(resp.Message.PublishTime)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Message{\n\t\tackID:       resp.AckId,\n\t\tData:        resp.Message.Data,\n\t\tAttributes:  resp.Message.Attributes,\n\t\tID:          resp.Message.MessageId,\n\t\tPublishTime: pubTime,\n\t}, nil\n}\n\n\n\n\n\n\nfunc (m *Message) Ack() {\n\tm.done(true)\n}\n\n\n\n\n\n\nfunc (m *Message) Nack() {\n\tm.done(false)\n}\n\n\n\nfunc (m *Message) done(ack bool) ", "output": "{\n\tif m.calledDone {\n\t\treturn\n\t}\n\tm.calledDone = true\n\tm.doneFunc(m.ackID, ack)\n}"}
{"input": "package runtime\n\nfunc checkgoarm() {\n\treturn \n}\n\n\n\n\nfunc cputicks() int64 ", "output": "{\n\treturn nanotime()\n}"}
{"input": "package goutil\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype WorkSubmitter interface {\n\tSubmit(f func())\n}\n\ntype WorkQueue interface {\n\tWorkSubmitter\n\tWait()\n}\n\n\n\ntype iWorkQueue struct {\n\twg *sync.WaitGroup\n\tch chan func()\n}\n\nfunc (w iWorkQueue) Submit(f func()) {\n\tw.ch <- f\n}\n\nfunc (w iWorkQueue) Wait() {\n\tclose(w.ch)\n\tw.wg.Wait()\n}\n\ntype Tool struct {\n}\n\nfunc (Tool) Name() string {\n\treturn \"testq,test the work queue\"\n}\n\nfunc (t Tool) Run(args []string) {\n\tq := NewWorkQueue(100)\n\n\tvar started, ended int64\n\n\twork := func() {\n\t\tatomic.AddInt64(&started, 1)\n\t\tfmt.Printf(\"%d\\n\", started)\n\t\ttime.Sleep(time.Duration(30+rand.Intn(70)) * time.Millisecond)\n\t\tatomic.AddInt64(&ended, 1)\n\t}\n\n\tfor i := 0; i < 3000; i++ {\n\t\tq.Submit(work)\n\t}\n\n\tq.Wait()\n\n\tfmt.Println(started, ended)\n\n}\n\nfunc NewWorkQueue(n int) WorkQueue ", "output": "{\n\tvar wg sync.WaitGroup\n\tch := make(chan func())\n\tfor i := 0; i < n; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor f := range ch {\n\t\t\t\tf()\n\t\t\t}\n\t\t}()\n\t}\n\treturn iWorkQueue{wg: &wg, ch: ch}\n}"}
{"input": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/get-ion/ion/httptest\"\n)\n\ntype resource string\n\nfunc (r resource) String() string {\n\treturn string(r)\n}\n\n\n\nfunc (r resource) loadFromBase(dir string) string {\n\tfilename := r.String()\n\n\tfilename = r.strip(\"/static\")\n\n\tfullpath := filepath.Join(dir, filename)\n\n\tb, err := ioutil.ReadFile(fullpath)\n\tif err != nil {\n\t\tpanic(fullpath + \" failed with error: \" + err.Error())\n\t}\n\n\tresult := string(b)\n\tif runtime.GOOS != \"windows\" {\n\t\tresult = strings.Replace(result, \"\\n\", \"\\r\\n\", -1)\n\t}\n\treturn result\n}\n\nvar urls = []resource{\n\t\"/static/css/bootstrap.min.css\",\n\t\"/static/js/jquery-2.1.1.js\",\n\t\"/static/favicon.ico\",\n}\n\n\n\n\nfunc TestEmbeddingFilesIntoApp(t *testing.T) {\n\tapp := newApp()\n\te := httptest.New(t, app)\n\n\tif runtime.GOOS != \"windows\" {\n\t\turls = urls[0 : len(urls)-1]\n\t}\n\n\tfor _, u := range urls {\n\t\turl := u.String()\n\t\tcontents := u.loadFromBase(\"./assets\")\n\n\t\te.GET(url).Expect().\n\t\t\tStatus(httptest.StatusOK).\n\t\t\tBody().Equal(contents)\n\t}\n}\n\nfunc (r resource) strip(strip string) string ", "output": "{\n\ts := r.String()\n\treturn strings.TrimPrefix(s, strip)\n}"}
{"input": "package category\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n)\n\n\n\n\n\n\n\nfunc HashtagFromTitle(title string) string {\n\tvar t strings.Builder\n\tvar prev rune\n\tfor _, c := range title {\n\t\tif !unicode.IsLetter(c) && !unicode.IsNumber(c) {\n\t\t\tprev = c\n\t\t\tcontinue\n\t\t}\n\t\tif unicode.IsSpace(prev) {\n\t\t\tt.WriteRune(unicode.ToUpper(c))\n\t\t} else {\n\t\t\tt.WriteRune(c)\n\t\t}\n\t\tprev = c\n\t}\n\treturn t.String()\n}\n\nfunc titleFromHashtag(hashtag string) string ", "output": "{\n\tvar t strings.Builder\n\tvar prev rune\n\tfor i, c := range hashtag {\n\t\tif unicode.IsUpper(c) {\n\t\t\tif i > 0 && !unicode.IsUpper(prev) {\n\t\t\t\tt.WriteRune(' ')\n\t\t\t}\n\t\t\tt.WriteRune(unicode.ToLower(c))\n\t\t} else {\n\t\t\tt.WriteRune(c)\n\t\t}\n\t\tprev = c\n\t}\n\treturn t.String()\n}"}
{"input": "package raft\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\tpb \"github.com/coreos/etcd/raft/raftpb\"\n)\n\ntype Status struct {\n\tID uint64\n\n\tpb.HardState\n\tSoftState\n\n\tApplied  uint64\n\tProgress map[uint64]Progress\n}\n\n\nfunc getStatus(r *raft) Status {\n\ts := Status{ID: r.id}\n\ts.HardState = r.HardState\n\ts.SoftState = *r.softState()\n\n\ts.Applied = r.raftLog.applied\n\n\tif s.RaftState == StateLeader {\n\t\ts.Progress = make(map[uint64]Progress)\n\t\tfor id, p := range r.prs {\n\t\t\ts.Progress[id] = *p\n\t\t}\n\t}\n\n\treturn s\n}\n\n\nfunc (s Status) MarshalJSON() ([]byte, error) {\n\tj := fmt.Sprintf(`{\"id\":\"%x\",\"term\":%d,\"vote\":\"%x\",\"commit\":%d,\"lead\":\"%x\",\"raftState\":\"%s\",\"progress\":{`,\n\t\ts.ID, s.Term, s.Vote, s.Commit, s.Lead, s.RaftState)\n\n\tif len(s.Progress) == 0 {\n\t\tj += \"}}\"\n\t} else {\n\t\tfor k, v := range s.Progress {\n\t\t\tsubj := fmt.Sprintf(`\"%x\":{\"match\":%d,\"next\":%d,\"unreachable\":%t},`, k, v.Match, v.Next, v.Unreachable)\n\t\t\tj += subj\n\t\t}\n\t\tj = j[:len(j)-1] + \"}}\"\n\t}\n\treturn []byte(j), nil\n}\n\n\n\nfunc (s Status) String() string ", "output": "{\n\tb, err := s.MarshalJSON()\n\tif err != nil {\n\t\tlog.Panicf(\"unexpected error: %v\", err)\n\t}\n\treturn string(b)\n}"}
{"input": "package atc\n\nimport (\n\t\"fmt\"\n)\n\ntype MalformedConfigError struct {\n\tUnmarshalError error\n}\n\nfunc (err MalformedConfigError) Error() string {\n\treturn fmt.Sprintf(\"malformed config: %s\", err.UnmarshalError.Error())\n}\n\ntype MalformedStepError struct {\n\tStepType string\n\tErr      error\n}\n\n\n\nfunc (err MalformedStepError) Unwrap() error {\n\treturn err.Err\n}\n\nfunc (err MalformedStepError) Error() string ", "output": "{\n\treturn fmt.Sprintf(\"malformed %s step: %s\", err.StepType, err.Err)\n}"}
{"input": "package netest\n\nimport \"net\"\n\n\nfunc Listen() net.Listener {\n\tlistener, err := net.Listen(\"tcp\", \"[::1]:\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn listener\n}\n\n\nfunc BrokenListener(err error) net.Listener {\n\treturn broken{err}\n}\n\nfunc (b broken) Accept() (net.Conn, error) {\n\treturn nil, b.error\n}\n\n\n\nfunc (broken) Close() error {\n\treturn nil\n}\n\ntype broken struct {\n\terror\n}\n\nfunc (broken) Addr() net.Addr ", "output": "{\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/mozilla/mig\"\n\t\"os\"\n\t\"os/exec\"\n)\n\n\n\n\nfunc daemonize(orig_ctx Context, upgrading bool) (ctx Context, err error) {\n\tctx = orig_ctx\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = fmt.Errorf(\"daemonize() -> %v\", e)\n\t\t}\n\t\tctx.Channels.Log <- mig.Log{Desc: \"leaving daemonize()\"}.Debug()\n\t}()\n\n\tif os.Getppid() == 1 {\n\t\tctx.Channels.Log <- mig.Log{Desc: \"Parent process is PID 1\"}.Debug()\n\t\tctx.Channels.Log <- mig.Log{Desc: \"Running as a service.\"}.Debug()\n\t\tctx.Agent.Respawn = false\n\t} else {\n\t\tif MUSTINSTALLSERVICE {\n\t\t\tctx, err = serviceDeploy(ctx)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tctx.Channels.Log <- mig.Log{Desc: \"Service deployed. Exit.\"}.Debug()\n\t\t} else {\n\t\t\tcmd := exec.Command(ctx.Agent.BinPath, \"-f\")\n\t\t\terr = cmd.Start()\n\t\t\tif err != nil {\n\t\t\t\tctx.Channels.Log <- mig.Log{Desc: fmt.Sprintf(\"Failed to spawn new agent from '%s': '%v'\", ctx.Agent.BinPath, err)}.Err()\n\t\t\t\treturn ctx, err\n\t\t\t}\n\t\t\tctx.Channels.Log <- mig.Log{Desc: \"Started new foreground agent. Exit.\"}.Debug()\n\t\t}\n\t\tos.Exit(0)\n\t}\n\treturn\n}\n\n\n\nfunc installCron(ctx Context) (err error) ", "output": "{\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = fmt.Errorf(\"installCron() -> %v\", e)\n\t\t}\n\t\tctx.Channels.Log <- mig.Log{Desc: \"leaving installCron()\"}.Debug()\n\t}()\n\tpanic(\"mig-agent doesn't have a cronjob for darwin.\")\n\treturn\n}"}
{"input": "package container\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/docker/cli/cli\"\n\t\"github.com/docker/cli/cli/command\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype pauseOptions struct {\n\tcontainers []string\n}\n\n\n\n\nfunc runPause(dockerCli command.Cli, opts *pauseOptions) error {\n\tctx := context.Background()\n\n\tvar errs []string\n\terrChan := parallelOperation(ctx, opts.containers, dockerCli.Client().ContainerPause)\n\tfor _, container := range opts.containers {\n\t\tif err := <-errChan; err != nil {\n\t\t\terrs = append(errs, err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Fprintln(dockerCli.Out(), container)\n\t}\n\tif len(errs) > 0 {\n\t\treturn errors.New(strings.Join(errs, \"\\n\"))\n\t}\n\treturn nil\n}\n\nfunc NewPauseCommand(dockerCli command.Cli) *cobra.Command ", "output": "{\n\tvar opts pauseOptions\n\n\treturn &cobra.Command{\n\t\tUse:   \"pause CONTAINER [CONTAINER...]\",\n\t\tShort: \"Pause all processes within one or more containers\",\n\t\tArgs:  cli.RequiresMinArgs(1),\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\topts.containers = args\n\t\t\treturn runPause(dockerCli, &opts)\n\t\t},\n\t}\n}"}
{"input": "package funk\n\n\n\nfunc ShortIf(condition bool, a interface{}, b interface{}) interface{} ", "output": "{\n\tif condition {\n\t\treturn a\n\t}\n\treturn b\n}"}
{"input": "package media\n\ntype FileContent struct {\n}\n\n\n\nfunc (self *FileContent) IsDirectory() bool {\n\treturn false\n}\n\nfunc NewFileContent() *FileContent ", "output": "{\n\tfile := &FileContent{}\n\treturn file\n}"}
{"input": "package tick\n\nimport (\n\t\"appengine/datastore\"\n\t\"appengine/taskqueue\"\n\t\"net/http\"\n\t\"techtraits.com/klaxon/rest/project\"\n\t\"techtraits.com/klaxon/router\"\n\t\"techtraits.com/log\"\n)\n\n\n\nfunc getTick(request router.Request) (int, []byte) {\n\n\tquery := datastore.NewQuery(project.PROJECT_KEY)\n\tprojects := make([]project.ProjectDTO, 0)\n\t_, err := query.GetAll(request.GetContext(), &projects)\n\n\tif err != nil {\n\t\tlog.Errorf(request.GetContext(), \"Error retriving projects: %v\", err)\n\t\treturn http.StatusInternalServerError, []byte(err.Error())\n\t} else {\n\n\t\tfor _, project := range projects {\n\t\t\ttask := taskqueue.NewPOSTTask(\"/rest/internal/check/\"+project.Name, nil)\n\t\t\tif _, err := taskqueue.Add(request.GetContext(), task, \"alertCheckQueue\"); err != nil {\n\t\t\t\tlog.Errorf(request.GetContext(), \"Error posting to task queue: %v\", err)\n\t\t\t}\n\n\t\t}\n\n\t\treturn http.StatusOK, nil\n\t}\n}\n\nfunc init() ", "output": "{\n\trouter.Register(\"/rest/internal/tick/\", router.GET, nil, nil, getTick)\n}"}
{"input": "package engine\n\ntype ReverseStringSlice []string\n\nfunc (self ReverseStringSlice) Less(i, j int) bool {\n\treturn j < i\n}\n\nfunc (self ReverseStringSlice) Swap(i, j int) {\n\tself[i], self[j] = self[j], self[i]\n}\n\n\n\nfunc (self ReverseStringSlice) Len() int ", "output": "{\n\treturn len(self)\n}"}
{"input": "package evoli\n\nimport \"math/rand\"\n\ntype crosserMock struct {\n}\n\n\n\ntype evaluaterMock struct {\n}\n\nfunc (e evaluaterMock) Evaluate(individual Individual) (Fitness float64, err error) {\n\treturn individual.Fitness(), nil\n}\n\ntype mutaterMock struct {\n}\n\nfunc (m mutaterMock) Mutate(individual Individual, p float64) (Individual, error) {\n\treturn individual, nil\n}\n\ntype positionerMock struct {\n}\n\nfunc (p positionerMock) Position(indiv, pBest, gBest Individual, c1, c2 float64) (Individual, error) {\n\treturn NewIndividual((indiv.Fitness() + pBest.Fitness() + gBest.Fitness()) / 3), nil\n}\n\nfunc (c crosserMock) Cross(parent1, parent2 Individual) (child1, child2 Individual, err error) ", "output": "{\n\tw := 0.1 + 0.8*rand.Float64()\n\treturn NewIndividual(w*parent1.Fitness() + (1-w)*parent2.Fitness()),\n\t\tNewIndividual((1-w)*parent1.Fitness() + w*parent2.Fitness()),\n\t\tnil\n}"}
{"input": "package tracker\n\nimport (\n\t\"sync\"\n\n\t\"github.com/GoogleContainerTools/skaffold/pkg/skaffold/graph\"\n)\n\ntype Container struct {\n\tName string\n\tID   string\n}\n\ntype ContainerTracker struct {\n\tsync.RWMutex\n\tdeployedContainers  map[string]Container      \n\tcontainerToArtifact map[string]graph.Artifact \n\tcontainers          map[string]bool           \n\tnotifier            chan string\n}\n\n\nfunc NewContainerTracker() *ContainerTracker {\n\treturn &ContainerTracker{\n\t\tcontainerToArtifact: make(map[string]graph.Artifact),\n\t\tdeployedContainers:  make(map[string]Container),\n\t\tnotifier:            make(chan string, 1),\n\t}\n}\n\n\n\n\nfunc (t *ContainerTracker) Notifier() chan string {\n\treturn t.notifier\n}\n\nfunc (t *ContainerTracker) ArtifactForContainer(id string) graph.Artifact {\n\tt.Lock()\n\tdefer t.Unlock()\n\treturn t.containerToArtifact[id]\n}\n\n\n\nfunc (t *ContainerTracker) ContainerForImage(image string) (Container, bool) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tc, found := t.deployedContainers[image]\n\treturn c, found\n}\n\n\n\nfunc (t *ContainerTracker) DeployedContainers() map[string]Container {\n\treturn t.deployedContainers\n}\n\n\nfunc (t *ContainerTracker) Reset() {\n\tfor c := range t.containers {\n\t\tdelete(t.containers, c)\n\t}\n}\n\n\n\n\nfunc (t *ContainerTracker) Add(artifact graph.Artifact, c Container) ", "output": "{\n\tt.Lock()\n\tdefer t.Unlock()\n\tt.deployedContainers[artifact.ImageName] = c\n\tt.containerToArtifact[c.ID] = artifact\n\tgo func() {\n\t\tt.notifier <- c.ID\n\t}()\n}"}
{"input": "package json\n\nimport \"encoding/json\"\nimport \"net/http\"\n\n\nfunc String(writer http.ResponseWriter, request *http.Request, data string) {\n\n    \n    writer.Header().Set(\"Content-Type\", \"application/json\")\n\n    \n    type SimpleResponse struct {\n        Data      string\n    }\n\n    res := SimpleResponse {\n        Data: data,\n    }\n\n    result, error := json.Marshal(res)\n\n    if error == nil {\n        \n        writer.Write([]byte(result))\n    } else {\n        writer.Write([]byte(\"Error\"))\n    }\n}\n\n\n\n\nfunc Struct(writer http.ResponseWriter, request *http.Request, data interface{}, indent bool) ", "output": "{\n\n    \n    writer.Header().Set(\"Content-Type\", \"application/json\")\n\n    \n    type SimpleResponse struct {\n        Data      interface {}\n    }\n\n    res := SimpleResponse {\n        Data: data,\n    }\n\n    var result []byte\n    var error error\n\n    if indent {\n        result, error = json.MarshalIndent(res, \"\", \"\")\n    } else {\n        result, error = json.Marshal(res)\n    }\n\n    if error == nil {\n        \n        writer.Write([]byte(result))\n    } else {\n        writer.Write([]byte(\"Error\"))\n    }\n}"}
{"input": "package derive\n\nimport (\n\t\"go/types\"\n\t\"strings\"\n)\n\n\ntype Named struct {\n\tFields  []*Field\n\tReflect bool\n}\n\n\ntype Field struct {\n\tname     string\n\texternal bool\n\tType     types.Type\n\ttypeStr  func() string\n}\n\n\nfunc (f *Field) Name(recv string, unsafePkg Import) string {\n\tif !f.Private() || !f.external {\n\t\treturn recv + \".\" + f.name\n\t}\n\treturn `*(*` + f.typeStr() + `)(` + unsafePkg() + `.Pointer(` + recv + `.FieldByName(\"` + f.name + `\").UnsafeAddr()))`\n}\n\n\nfunc (f *Field) DebugName() string {\n\treturn f.name\n}\n\n\nfunc (f *Field) Private() bool {\n\treturn strings.ToLower(f.name[0:1]) == f.name[0:1]\n}\n\n\n\n\nfunc GetStructFields(s *types.Struct) []*types.Var {\n\tfields := make([]*types.Var, s.NumFields())\n\tfor i := 0; i < s.NumFields(); i++ {\n\t\tfields[i] = s.Field(i)\n\t}\n\treturn fields\n}\n\nfunc Fields(typesMap TypesMap, typ *types.Struct, external bool) *Named ", "output": "{\n\tnumFields := typ.NumFields()\n\tn := &Named{\n\t\tFields: make([]*Field, numFields),\n\t}\n\tfor i := 0; i < numFields; i++ {\n\t\tfield := typ.Field(i)\n\t\tfieldType := field.Type()\n\t\tfieldName := field.Name()\n\t\tn.Fields[i] = &Field{\n\t\t\tname:     fieldName,\n\t\t\texternal: external,\n\t\t\tType:     fieldType,\n\t\t\ttypeStr: func() string {\n\t\t\t\treturn typesMap.TypeString(fieldType)\n\t\t\t},\n\t\t}\n\t\tif n.Fields[i].Private() {\n\t\t\tif external {\n\t\t\t\tn.Reflect = true\n\t\t\t}\n\t\t}\n\t}\n\treturn n\n}"}
{"input": "package libfuse\n\nimport (\n\t\"os\"\n\n\t\"bazil.org/fuse\"\n\t\"bazil.org/fuse/fs\"\n\t\"golang.org/x/net/context\"\n)\n\n\n\ntype Alias struct {\n\trealPath string\n\tinode    uint64\n}\n\nvar _ fs.Node = (*Alias)(nil)\n\n\n\n\nvar _ fs.NodeReadlinker = (*Alias)(nil)\n\n\nfunc (a *Alias) Readlink(ctx context.Context, req *fuse.ReadlinkRequest) (string, error) {\n\treturn a.realPath, nil\n}\n\nfunc (*Alias) Attr(ctx context.Context, a *fuse.Attr) error ", "output": "{\n\ta.Mode = os.ModeSymlink | 0777\n\treturn nil\n}"}
{"input": "package chipmunk\n\nimport (\n\t\"github.com/Dethrail/chipmunk/transform\"\n\t\"github.com/Dethrail/chipmunk/vect\"\n\t\"math\"\n)\n\nconst (\n\tRadianConst = math.Pi / 180\n\tDegreeConst = 180 / math.Pi\n)\n\ntype Group int\ntype Layer int\n\ntype Shape struct {\n\tDefaultHash\n\tShapeClass\n\n\tBody *Body\n\n\tBB AABB\n\n\tIsSensor bool\n\n\te vect.Float\n\tu vect.Float\n\tSurface_v vect.Vect\n\n\tUserData interface{}\n\n\tGroup Group\n\tLayer Layer\n\n\tspace *Space\n\n\tvelocityIndexed bool\n}\n\nfunc newShape() *Shape {\n\treturn &Shape{velocityIndexed: true, e: 0.5, u: 0.5, Layer: -1}\n\n}\n\nfunc (shape *Shape) Velocity() (vect.Vect, bool) {\n\treturn shape.Body.v, shape.velocityIndexed\n}\n\nfunc (shape *Shape) SetFriction(friction vect.Float) {\n\tshape.u = friction\n}\n\nfunc (shape *Shape) SetElasticity(e vect.Float) {\n\tshape.e = e\n}\n\nfunc (shape *Shape) Shape() *Shape {\n\treturn shape\n}\n\n\n\nfunc (shape *Shape) Clone() *Shape {\n\tclone := *shape\n\tcc := &clone\n\tcc.space = nil\n\tcc.DefaultHash.Reset()\n\tcc.Body = nil\n\tcc.ShapeClass = cc.ShapeClass.Clone(cc)\n\treturn cc\n}\n\nfunc (shape *Shape) Update() {\n\tshape.BB = shape.ShapeClass.update(transform.NewTransform(shape.Body.p, shape.Body.a))\n}\n\nfunc (shape *Shape) AABB() AABB ", "output": "{\n\treturn shape.BB\n}"}
{"input": "package main\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aws/aws-sdk-go/service/ssm\"\n\t\"github.com/aws/aws-sdk-go/service/ssm/ssmiface\"\n)\n\n\ntype mockSSMClient struct {\n\tssmiface.SSMAPI\n}\n\n\n\nfunc TestDeleteParameter(t *testing.T) {\n\tthisTime := time.Now()\n\tnowString := thisTime.Format(\"2006-01-02 15:04:05 Monday\")\n\tt.Log(\"Starting unit test at \" + nowString)\n\n\tname := \"test-param\"\n\n\tmockSvc := &mockSSMClient{}\n\n\terr := DeleteParameter(mockSvc, &name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc (m *mockSSMClient) DeleteParameter(input *ssm.DeleteParameterInput) (*ssm.DeleteParameterOutput, error) ", "output": "{\n\tif input.Name == nil || *input.Name == \"\" {\n\t\treturn nil, errors.New(\"GetParameterInput.Name is nil or an empty string\")\n\t}\n\treturn nil, nil\n}"}
{"input": "package systemd\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/google/cadvisor/container\"\n\t\"github.com/google/cadvisor/fs\"\n\tinfo \"github.com/google/cadvisor/info/v1\"\n\t\"github.com/google/cadvisor/watcher\"\n\n\t\"k8s.io/klog/v2\"\n)\n\ntype systemdFactory struct{}\n\nfunc (f *systemdFactory) String() string {\n\treturn \"systemd\"\n}\n\nfunc (f *systemdFactory) NewContainerHandler(name string, inHostNamespace bool) (container.ContainerHandler, error) {\n\treturn nil, fmt.Errorf(\"Not yet supported\")\n}\n\nfunc (f *systemdFactory) CanHandleAndAccept(name string) (bool, bool, error) {\n\tif strings.HasSuffix(name, \".mount\") {\n\t\treturn true, false, nil\n\t}\n\tklog.V(5).Infof(\"%s not handled by systemd handler\", name)\n\treturn false, false, nil\n}\n\n\n\n\nfunc Register(machineInfoFactory info.MachineInfoFactory, fsInfo fs.FsInfo, includedMetrics container.MetricSet) error {\n\tklog.V(1).Infof(\"Registering systemd factory\")\n\tfactory := &systemdFactory{}\n\tcontainer.RegisterContainerHandlerFactory(factory, []watcher.ContainerWatchSource{watcher.Raw})\n\treturn nil\n}\n\nfunc (f *systemdFactory) DebugInfo() map[string][]string ", "output": "{\n\treturn map[string][]string{}\n}"}
{"input": "package vagrant\n\nimport (\n\t\"github.com/mitchellh/packer/packer\"\n\t\"testing\"\n)\n\nfunc testConfig() map[string]interface{} {\n\treturn map[string]interface{}{}\n}\n\nfunc TestPostProcessor_ImplementsPostProcessor(t *testing.T) {\n\tvar raw interface{}\n\traw = &PostProcessor{}\n\tif _, ok := raw.(packer.PostProcessor); !ok {\n\t\tt.Fatalf(\"AWS PostProcessor should be a PostProcessor\")\n\t}\n}\n\nfunc TestBuilderPrepare_OutputPath(t *testing.T) {\n\tvar p PostProcessor\n\n\tc := testConfig()\n\tdelete(c, \"output\")\n\terr := p.Configure(c)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n\n\tc[\"output\"] = \"bad {{{{.Template}}}}\"\n\terr = p.Configure(c)\n\tif err == nil {\n\t\tt.Fatal(\"should have error\")\n\t}\n}\n\n\n\nfunc TestBuilderPrepare_PPConfig(t *testing.T) ", "output": "{\n\tvar p PostProcessor\n\n\tc := testConfig()\n\tc[\"aws\"] = map[string]interface{}{}\n\terr := p.Configure(c)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %s\", err)\n\t}\n}"}
{"input": "package honeywell\n\nimport (\n\t\"github.com/markdaws/gohome/pkg/cmd\"\n\t\"github.com/markdaws/gohome/pkg/gohome\"\n)\n\ntype extension struct {\n\tgohome.NullExtension\n}\n\n\n\nfunc (e *extension) BuilderForDevice(sys *gohome.System, d *gohome.Device) cmd.Builder {\n\n\tswitch d.ModelNumber {\n\tcase \"honeywell.redlink.thermostat\":\n\t\treturn &cmdBuilder{Device: d, System: sys}\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc (e *extension) NetworkForDevice(sys *gohome.System, d *gohome.Device) gohome.Network {\n\treturn nil\n}\n\nfunc (e *extension) EventsForDevice(sys *gohome.System, d *gohome.Device) *gohome.ExtEvents {\n\tswitch d.ModelNumber {\n\tcase \"honeywell.redlink.thermostat\":\n\t\tevts := &gohome.ExtEvents{}\n\t\tevts.Producer = &producer{\n\t\t\tDevice: d,\n\t\t\tSystem: sys,\n\t\t}\n\t\tevts.Consumer = &consumer{\n\t\t\tDevice: d,\n\t\t\tSystem: sys,\n\t\t}\n\t\treturn evts\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc (e *extension) Discovery(sys *gohome.System) gohome.Discovery {\n\treturn &discovery{}\n}\n\nfunc NewExtension() *extension {\n\treturn &extension{}\n}\n\nfunc (e *extension) Name() string ", "output": "{\n\treturn \"honeywell\"\n}"}
{"input": "package libcontainerd \n\nimport (\n\t\"sync\"\n\n\t\"github.com/sirupsen/logrus\"\n)\n\ntype remote struct {\n\tsync.RWMutex\n\n\tlogger  *logrus.Entry\n\tclients []*client\n\n\trootDir  string\n\tstateDir string\n}\n\n\n\n\ntype client struct {\n\tsync.Mutex\n\n\trootDir    string\n\tstateDir   string\n\tbackend    Backend\n\tlogger     *logrus.Entry\n\teventQ     queue\n\tcontainers map[string]*container\n}\n\nfunc (r *remote) NewClient(ns string, b Backend) (Client, error) {\n\tc := &client{\n\t\trootDir:    r.rootDir,\n\t\tstateDir:   r.stateDir,\n\t\tbackend:    b,\n\t\tlogger:     r.logger.WithField(\"namespace\", ns),\n\t\tcontainers: make(map[string]*container),\n\t}\n\tr.Lock()\n\tr.clients = append(r.clients, c)\n\tr.Unlock()\n\n\treturn c, nil\n}\n\nfunc (r *remote) Cleanup() {\n}\n\nfunc New(rootDir, stateDir string, options ...RemoteOption) (Remote, error) ", "output": "{\n\treturn &remote{\n\t\tlogger:   logrus.WithField(\"module\", \"libcontainerd\"),\n\t\trootDir:  rootDir,\n\t\tstateDir: stateDir,\n\t}, nil\n}"}
{"input": "package state\n\nimport (\n\t\"fmt\"\n\n\t\"labix.org/v2/mgo\"\n\t\"labix.org/v2/mgo/bson\"\n\t\"labix.org/v2/mgo/txn\"\n\n\t\"github.com/wallyworld/core/errors\"\n\t\"github.com/wallyworld/core/state/api/params\"\n)\n\n\n\n\n\ntype statusDoc struct {\n\tStatus     params.Status\n\tStatusInfo string\n\tStatusData params.StatusData\n}\n\n\n\n\n\n\n\n\nfunc getStatus(st *State, globalKey string) (statusDoc, error) {\n\tvar doc statusDoc\n\terr := st.statuses.FindId(globalKey).One(&doc)\n\tif err == mgo.ErrNotFound {\n\t\treturn statusDoc{}, errors.NotFoundf(\"status\")\n\t}\n\tif err != nil {\n\t\treturn statusDoc{}, fmt.Errorf(\"cannot get status %q: %v\", globalKey, err)\n\t}\n\treturn doc, nil\n}\n\n\n\nfunc createStatusOp(st *State, globalKey string, doc statusDoc) txn.Op {\n\treturn txn.Op{\n\t\tC:      st.statuses.Name,\n\t\tId:     globalKey,\n\t\tAssert: txn.DocMissing,\n\t\tInsert: doc,\n\t}\n}\n\n\n\nfunc updateStatusOp(st *State, globalKey string, doc statusDoc) txn.Op {\n\treturn txn.Op{\n\t\tC:      st.statuses.Name,\n\t\tId:     globalKey,\n\t\tAssert: txn.DocExists,\n\t\tUpdate: bson.D{{\"$set\", doc}},\n\t}\n}\n\n\n\nfunc removeStatusOp(st *State, globalKey string) txn.Op {\n\treturn txn.Op{\n\t\tC:      st.statuses.Name,\n\t\tId:     globalKey,\n\t\tRemove: true,\n\t}\n}\n\nfunc (doc statusDoc) validateSet(allowPending bool) error ", "output": "{\n\tif !doc.Status.Valid() {\n\t\treturn fmt.Errorf(\"cannot set invalid status %q\", doc.Status)\n\t}\n\tswitch doc.Status {\n\tcase params.StatusPending:\n\t\tif !allowPending {\n\t\t\treturn fmt.Errorf(\"cannot set status %q\", doc.Status)\n\t\t}\n\tcase params.StatusDown:\n\t\treturn fmt.Errorf(\"cannot set status %q\", doc.Status)\n\tcase params.StatusError:\n\t\tif doc.StatusInfo == \"\" {\n\t\t\treturn fmt.Errorf(\"cannot set status %q without info\", doc.Status)\n\t\t}\n\t}\n\tif doc.StatusData != nil && doc.Status != params.StatusError {\n\t\treturn fmt.Errorf(\"cannot set status data when status is %q\", doc.Status)\n\t}\n\treturn nil\n}"}
{"input": "package unittest\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/apcera/logray\"\n)\n\n\n\nfunc ExamplePass() {\n\tbuffer := SetupBuffer()\n\tdefer buffer.DumpToStdout()\n\n\tlogger := logray.New()\n\tfmt.Println(\"Expected output.\")\n\tlogger.Info(\"log line 1\")\n\tlogger.Info(\"log line 2\")\n\tlogger.Info(\"log line 3\")\n\n\tbuffer.Clear()\n\n}\n\nfunc TestLogBufferFields(t *testing.T) {\n\n\tlogBuffer := SetupBuffer()\n\n\tlogger := logray.New()\n\tlogger.SetField(\"TestField1\", \"Test1\")\n\tlogger.SetField(\"TestField2\", \"Test2\")\n\tlogger.Info(\"Test Log\")\n\n\ttime.Sleep(1 * time.Second)\n\n\tif len(logBuffer.buffer) != 1 {\n\t\tt.Fatalf(\"Expected: %d, Got: %d LineData items in the log buffer.\", 1, len(logBuffer.buffer))\n\t}\n\n\tif len(logBuffer.fields) != 2 {\n\t\tt.Fatalf(\"Expected: %d, Got: %d fields in the log buffer.\", 2, len(logBuffer.fields))\n\t}\n\n\tif fv, ok := logBuffer.fields[\"TestField1\"]; !ok || !strings.EqualFold(fv.(string), \"Test1\") {\n\t\tt.Fatal(\"Unexpected field found in the log buffer\")\n\t}\n\n\tif fv, ok := logBuffer.fields[\"TestField2\"]; !ok || !strings.EqualFold(fv.(string), \"Test2\") {\n\t\tt.Fatal(\"Unexpected field found in the log buffer\")\n\t}\n}\n\nfunc Example() ", "output": "{\n\tbuffer := SetupBuffer()\n\tdefer buffer.DumpToStdout()\n\n\n\tbuffer.Clear()\n}"}
{"input": "package client\n\nimport (\n\tuserapi \"github.com/projectatomic/atomic-enterprise/pkg/user/api\"\n)\n\n\ntype UserIdentityMappingsInterface interface {\n\tUserIdentityMappings() UserIdentityMappingInterface\n}\n\n\ntype UserIdentityMappingInterface interface {\n\tGet(string) (*userapi.UserIdentityMapping, error)\n\tCreate(*userapi.UserIdentityMapping) (*userapi.UserIdentityMapping, error)\n\tUpdate(*userapi.UserIdentityMapping) (*userapi.UserIdentityMapping, error)\n\tDelete(string) error\n}\n\n\ntype userIdentityMappings struct {\n\tr *Client\n}\n\n\nfunc newUserIdentityMappings(c *Client) *userIdentityMappings {\n\treturn &userIdentityMappings{\n\t\tr: c,\n\t}\n}\n\n\nfunc (c *userIdentityMappings) Get(name string) (result *userapi.UserIdentityMapping, err error) {\n\tresult = &userapi.UserIdentityMapping{}\n\terr = c.r.Get().Resource(\"userIdentityMappings\").Name(name).Do().Into(result)\n\treturn\n}\n\n\nfunc (c *userIdentityMappings) Create(mapping *userapi.UserIdentityMapping) (result *userapi.UserIdentityMapping, err error) {\n\tresult = &userapi.UserIdentityMapping{}\n\terr = c.r.Post().Resource(\"userIdentityMappings\").Body(mapping).Do().Into(result)\n\treturn\n}\n\n\n\n\n\nfunc (c *userIdentityMappings) Delete(name string) (err error) {\n\terr = c.r.Delete().Resource(\"userIdentityMappings\").Name(name).Do().Error()\n\treturn\n}\n\nfunc (c *userIdentityMappings) Update(mapping *userapi.UserIdentityMapping) (result *userapi.UserIdentityMapping, err error) ", "output": "{\n\tresult = &userapi.UserIdentityMapping{}\n\terr = c.r.Put().Resource(\"userIdentityMappings\").Name(mapping.Name).Body(mapping).Do().Into(result)\n\treturn\n}"}
{"input": "package modules\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n)\n\n\n\nfunc Decode(data []byte, to interface{}) error {\n\tbuf := bytes.NewBuffer(data)\n\tdec := gob.NewDecoder(buf)\n\treturn dec.Decode(to)\n}\n\nfunc Encode(data interface{}) ([]byte, error) ", "output": "{\n\tbuf := bytes.NewBuffer(nil)\n\tenc := gob.NewEncoder(buf)\n\terr := enc.Encode(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}"}
{"input": "package main\n\nimport \"sync/atomic\"\n\n\n\n\n\n\n\ntype BlackHole struct {\n\texitChan chan int\n\tStatus   int64\n}\n\n\n\n\n\nfunc (blackHole *BlackHole) Stop() {\n\tclose(blackHole.exitChan)\n}\n\n\nfunc (blackHole *BlackHole) Start(dataChan chan map[string]interface{}) error {\n\tatomic.StoreInt64(&blackHole.Status, 1)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-dataChan:\n\t\t\tcase <-blackHole.exitChan:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}\n\n\nfunc (blackHole *BlackHole) IsRunning() bool {\n\treturn atomic.LoadInt64(&blackHole.Status) > 0\n}\n\nfunc NewBlackHole(config map[string]string) (*BlackHole, error) ", "output": "{\n\tblackHole := &BlackHole{}\n\tblackHole.exitChan = make(chan int)\n\tatomic.StoreInt64(&blackHole.Status, 1)\n\treturn blackHole, nil\n}"}
{"input": "package cache\n\nimport \"github.com/bitrise-tools/go-steputils/tools\"\nimport \"os\"\nimport \"strings\"\n\n\nconst GlobalCachePathsEnvironmentKey = \"BITRISE_CACHE_INCLUDE_PATHS\"\n\n\nconst GlobalCacheIgnorePathsEnvironmentKey = \"BITRISE_CACHE_EXCLUDE_PATHS\"\n\n\ntype Cache struct {\n\tinclude []string\n\texclude []string\n}\n\n\nfunc New() Cache {\n\treturn Cache{}\n}\n\n\nfunc (cache *Cache) IncludePath(item string) {\n\tcache.include = append(cache.include, item)\n}\n\n\nfunc (cache *Cache) ExcludePath(item string) {\n\tcache.exclude = append(cache.exclude, item)\n}\n\n\nfunc (cache *Cache) Commit() error {\n\terr := appendCacheItem(cache.include)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = appendCacheIgnoreItem(cache.exclude)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc appendCacheItem(values []string) error {\n\treturn combineEnvContent(GlobalCachePathsEnvironmentKey, values)\n}\n\n\n\nfunc combineEnvContent(envVar string, values []string) error {\n\tcontent := os.Getenv(envVar)\n\n\tcontent += \"\\n\" + strings.Join(values, \"\\n\") + \"\\n\"\n\n\tif err := tools.ExportEnvironmentWithEnvman(envVar, content); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc appendCacheIgnoreItem(values []string) error ", "output": "{\n\treturn combineEnvContent(GlobalCacheIgnorePathsEnvironmentKey, values)\n}"}
{"input": "package spotify_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/javiermanzano/goth\"\n\t\"github.com/javiermanzano/goth/providers/spotify\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_ImplementsSession(t *testing.T) {\n\tt.Parallel()\n\ta := assert.New(t)\n\ts := &spotify.Session{}\n\ta.Implements((*goth.Session)(nil), s)\n}\n\n\n\nfunc Test_ToJSON(t *testing.T) {\n\tt.Parallel()\n\ta := assert.New(t)\n\ts := &spotify.Session{}\n\n\tdata := s.Marshal()\n\ta.Equal(data, `{\"AuthURL\":\"\",\"AccessToken\":\"\",\"RefreshToken\":\"\",\"ExpiresAt\":\"0001-01-01T00:00:00Z\"}`)\n}\n\nfunc Test_GetAuthURL(t *testing.T) ", "output": "{\n\tt.Parallel()\n\ta := assert.New(t)\n\ts := &spotify.Session{}\n\n\t_, err := s.GetAuthURL()\n\ta.Error(err)\n\n\ts.AuthURL = \"/foo\"\n\turl, _ := s.GetAuthURL()\n\ta.Equal(url, \"/foo\")\n}"}
{"input": "package functions\n\n\n\n\n\n\n\n\n\n\n\nvar _ = func(b bool) {}\n\n\n\n\n\nvar _ = func(z int) {}\n\n\n\n\n\n\n\n\n\n\nfunc F(input int) (output int) { return 17 }\n\ntype T struct{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc outer() {\n\t_ = func(q bool) {}\n}\n\n\n\n\n\nfunc ignore(_ int) bool { return false }\n\nfunc (recv *T) M(input int) (output int) ", "output": "{ return 34 }"}
{"input": "package log\n\nimport (\n\t\"github.com/sirupsen/logrus\"\n)\n\ntype LogLevel uint32\n\nconst (\n\tPanicLevel LogLevel = iota\n\tFatalLevel\n\tErrorLevel\n\tWarnLevel\n\tInfoLevel\n\tDebugLevel\n\tTraceLevel\n)\n\ntype Fields map[string]interface{}\n\ntype Logger interface {\n\tPanic(msg string, fields Fields)\n\tFatal(msg string, fields Fields)\n\tError(msg string, fields Fields)\n\tWarn(msg string, fields Fields)\n\tInfo(msg string, fields Fields)\n\tDebug(msg string, fields Fields)\n\tSetLevel(level LogLevel)\n\tGetLevel() LogLevel\n}\n\ntype DefaultLogger struct {\n\tlogger *logrus.Logger\n}\n\nfunc (l *DefaultLogger) Panic(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Panic(msg)\n}\n\nfunc (l *DefaultLogger) Fatal(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Fatal(msg)\n}\n\nfunc (l *DefaultLogger) Error(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Error(msg)\n}\n\nfunc (l *DefaultLogger) Warn(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Warn(msg)\n}\n\nfunc (l *DefaultLogger) Info(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Info(msg)\n}\n\n\n\nfunc (l *DefaultLogger) SetLevel(level LogLevel) {\n\tl.logger.SetLevel(logrus.Level(level))\n}\n\nfunc (l *DefaultLogger) GetLevel() LogLevel {\n\treturn LogLevel(l.logger.GetLevel())\n}\n\nfunc NewDefaultLogger() *DefaultLogger {\n\treturn &DefaultLogger{\n\t\tlogger: logrus.New(),\n\t}\n}\n\nfunc (l *DefaultLogger) Debug(msg string, fields Fields) ", "output": "{\n\tl.logger.WithFields(logrus.Fields(fields)).Debug(msg)\n}"}
{"input": "package servo_test\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n\t\"github.com/fgrosse/servo\"\n\t\"fmt\"\n)\n\nfunc TestServo(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Servo Test Suite\")\n}\n\ntype TestBundle struct {}\n\n\n\ntype SomeService struct {}\n\nfunc NewRecursiveService(*SomeService) *SomeService {\n\treturn &SomeService{}\n}\n\nfunc NewService() *SomeService {\n\treturn &SomeService{}\n}\n\nfunc NewServiceWithParam(param interface{}) *SomeService {\n\tpanic(param)\n\treturn &SomeService{}\n}\n\n\ntype ServerMock struct {\n\tRunHasBeenCalled bool\n\tReturnError      bool\n\n\tParameter1, Parameter2 string\n}\n\nfunc NewServerMockWithParams(param1, param2 string) *ServerMock {\n\tExpect(param1).To(Equal(\"foo\"), `NewServerMockWithParams should always be called with the values \"foo\" and \"bar\"`)\n\tExpect(param2).To(Equal(\"bar\"), `NewServerMockWithParams should always be called with the values \"foo\" and \"bar\"`)\n\n\treturn &ServerMock{\n\t\tParameter1: param1,\n\t\tParameter2: param2,\n\t}\n}\n\nfunc (s *ServerMock) Run() error {\n\ts.RunHasBeenCalled = true\n\tif s.ReturnError {\n\t\treturn fmt.Errorf(\"ServerMock was told to return an error!\")\n\t}\n\n\treturn nil\n}\n\nfunc (b *TestBundle) Boot(kernel *servo.Kernel) ", "output": "{\n\tkernel.RegisterType(\"test_bundle.my_type\", NewService)\n}"}
{"input": "package multiraft\n\nimport (\n\t\"github.com/cockroachdb/cockroach/roachpb\"\n\t\"github.com/cockroachdb/cockroach/util/log\"\n\t\"github.com/coreos/etcd/raft/raftpb\"\n)\n\n\n\ntype EventLeaderElection struct {\n\tGroupID   roachpb.RangeID\n\tReplicaID roachpb.ReplicaID\n\tTerm      uint64\n}\n\n\ntype EventCommandCommitted struct {\n\tGroupID roachpb.RangeID\n\tCommandID string\n\tIndex   uint64\n\tCommand []byte\n}\n\n\n\ntype EventMembershipChangeCommitted struct {\n\tGroupID    roachpb.RangeID\n\tCommandID  string\n\tIndex      uint64\n\tReplica    roachpb.ReplicaDescriptor\n\tChangeType raftpb.ConfChangeType\n\tPayload    []byte\n\n\tCallback func(error)\n}\n\n\n\n\nconst (\n\tCommandIDLen                = 8\n\tcommandEncodingVersion byte = 0\n)\n\nfunc encodeCommand(commandID string, command []byte) []byte {\n\tif len(commandID) != CommandIDLen {\n\t\tlog.Fatalf(\"invalid command ID length; %d != %d\", len(commandID), CommandIDLen)\n\t}\n\tx := make([]byte, 1, 1+CommandIDLen+len(command))\n\tx[0] = commandEncodingVersion\n\tx = append(x, []byte(commandID)...)\n\tx = append(x, command...)\n\treturn x\n}\n\n\n\nfunc decodeCommand(data []byte) (commandID string, command []byte) ", "output": "{\n\tif data[0] != commandEncodingVersion {\n\t\tlog.Fatalf(\"unknown command encoding version %v\", data[0])\n\t}\n\treturn string(data[1 : 1+CommandIDLen]), data[1+CommandIDLen:]\n}"}
{"input": "package graceful\n\nimport (\n\t\"crypto/tls\"\n\t\"net/http\"\n)\n\n\n\n\n\nfunc HTTPListenAndServe(network, address string, handler http.Handler) error {\n\tserver, lHandler := newHTTPServer(network, address, handler)\n\treturn server.ListenAndServe(lHandler)\n}\n\n\n\nfunc HTTPListenAndServeTLS(network, address, certFile, keyFile string, handler http.Handler) error {\n\tserver, lHandler := newHTTPServer(network, address, handler)\n\treturn server.ListenAndServeTLS(certFile, keyFile, lHandler)\n}\n\n\n\nfunc HTTPListenAndServeTLSConfig(network, address string, tlsConfig *tls.Config, handler http.Handler) error {\n\tserver, lHandler := newHTTPServer(network, address, handler)\n\treturn server.ListenAndServeTLSConfig(tlsConfig, lHandler)\n}\n\nfunc newHTTPServer(network, address string, handler http.Handler) (*Server, ServeFunction) ", "output": "{\n\tserver := NewServer(network, address)\n\thttpServer := http.Server{\n\t\tReadTimeout:    DefaultReadTimeOut,\n\t\tWriteTimeout:   DefaultWriteTimeOut,\n\t\tMaxHeaderBytes: DefaultMaxHeaderBytes,\n\t\tHandler:        handler,\n\t}\n\tserver.OnShutdown = func() {\n\t\thttpServer.SetKeepAlivesEnabled(false)\n\t}\n\treturn server, httpServer.Serve\n}"}
{"input": "package bodylmt\n\nimport (\n\t\"github.com/hellofresh/janus/pkg/plugin\"\n\t\"github.com/hellofresh/janus/pkg/proxy\"\n)\n\n\ntype Config struct {\n\tLimit string `json:\"limit\"`\n}\n\nfunc init() {\n\tplugin.RegisterPlugin(\"body_limit\", plugin.Plugin{\n\t\tAction: setupBodyLimit,\n\t})\n}\n\n\n\nfunc setupBodyLimit(route *proxy.Route, rawConfig plugin.Config) error ", "output": "{\n\tvar config Config\n\terr := plugin.Decode(rawConfig, &config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\troute.AddInbound(NewBodyLimitMiddleware(config.Limit))\n\treturn nil\n}"}
{"input": "package server\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/cri-o/cri-o/oci\"\n\t\"golang.org/x/net/context\"\n\tpb \"k8s.io/kubernetes/pkg/kubelet/apis/cri/runtime/v1alpha2\"\n)\n\nfunc buildContainerStats(stats *oci.ContainerStats, container *oci.Container) *pb.ContainerStats {\n\treturn &pb.ContainerStats{\n\t\tAttributes: &pb.ContainerAttributes{\n\t\t\tId:          container.ID(),\n\t\t\tMetadata:    container.Metadata(),\n\t\t\tLabels:      container.Labels(),\n\t\t\tAnnotations: container.Annotations(),\n\t\t},\n\t\tCpu: &pb.CpuUsage{\n\t\t\tTimestamp:            stats.SystemNano,\n\t\t\tUsageCoreNanoSeconds: &pb.UInt64Value{Value: stats.CPUNano},\n\t\t},\n\t\tMemory: &pb.MemoryUsage{\n\t\t\tTimestamp:       stats.SystemNano,\n\t\t\tWorkingSetBytes: &pb.UInt64Value{Value: stats.MemUsage},\n\t\t},\n\t\tWritableLayer: nil,\n\t}\n}\n\n\n\n\n\nfunc (s *Server) ContainerStats(ctx context.Context, req *pb.ContainerStatsRequest) (resp *pb.ContainerStatsResponse, err error) ", "output": "{\n\tconst operation = \"container_stats\"\n\tdefer func() {\n\t\trecordOperation(operation, time.Now())\n\t\trecordError(operation, err)\n\t}()\n\n\tcontainer := s.GetContainer(req.ContainerId)\n\tif container == nil {\n\t\treturn nil, fmt.Errorf(\"invalid container\")\n\t}\n\n\tstats, err := s.Runtime().ContainerStats(container)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pb.ContainerStatsResponse{Stats: buildContainerStats(stats, container)}, nil\n}"}
{"input": "package bebber\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"gopkg.in/mgo.v2\"\n)\n\n\ntype Globals struct {\n\tConfig  Config\n\tMongoDB MongoDBConn\n}\n\ntype Config map[string]string\n\ntype MongoDBConn struct {\n\tSession  *mgo.Session\n\tDialInfo *mgo.DialInfo\n\tDBName   string\n}\n\n\n\nfunc MakeGlobalsHandler(fn func(*gin.Context, Globals), globals Globals) func(*gin.Context) ", "output": "{\n\treturn func(c *gin.Context) {\n\t\tfn(c, globals)\n\t}\n}"}
{"input": "package main\n\nimport (\n  \"testing\"\n)\n\n\n\nfunc TestRootHandler(t *testing.T) ", "output": "{\n  recorder := newTestRequest(\"GET\", \"/\")\n  expectedStatusCode := 200\n  if recorder.Code != expectedStatusCode {\n    t.Errorf(\"Expected response status code `%d`, got `%d`\", expectedStatusCode, recorder.Code)\n  }\n}"}
{"input": "package gospec\n\nimport (\n\t\"fmt\"\n\tfilepath \"path\"\n\t\"runtime\"\n)\n\ntype Location struct {\n\tname string\n\tfile string\n\tline int\n}\n\nfunc currentLocation() *Location {\n\treturn newLocation(1)\n}\n\nfunc callerLocation() *Location {\n\treturn newLocation(2)\n}\n\nfunc newLocation(n int) *Location {\n\tif pc, _, _, ok := runtime.Caller(n + 1); ok {\n\t\treturn locationForPC(pc)\n\t}\n\treturn nil\n}\n\nfunc locationForPC(pc uintptr) *Location {\n\tpc = pcOfWhereCallWasMade(pc)\n\tf := runtime.FuncForPC(pc)\n\tname := f.Name()\n\tfile, line := f.FileLine(pc)\n\treturn &Location{name, file, line}\n}\n\n\n\n\n\n\n\n\n\n\nfunc (this *Location) Name() string     { return this.name }\nfunc (this *Location) File() string     { return this.file }\nfunc (this *Location) FileName() string { return filename(this.file) }\nfunc (this *Location) Line() int        { return this.line }\n\nfunc filename(path string) string {\n\t_, file := filepath.Split(path)\n\treturn file\n}\n\nfunc (this *Location) equals(that *Location) bool {\n\treturn this.name == that.name &&\n\t\tthis.file == that.file &&\n\t\tthis.line == that.line\n}\n\nfunc (this *Location) String() string {\n\treturn fmt.Sprintf(\"%v:%v\", this.FileName(), this.Line())\n}\n\nfunc pcOfWhereCallWasMade(pcOfWhereCallReturnsTo uintptr) uintptr ", "output": "{\n\treturn pcOfWhereCallReturnsTo - 1\n}"}
{"input": "package web\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/hellofresh/janus/pkg/render\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n\n\n\n\nfunc RedirectHTTPS(port int) http.HandlerFunc {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\thost, _, _ := net.SplitHostPort(req.Host)\n\n\t\ttarget := url.URL{\n\t\t\tScheme: \"https\",\n\t\t\tHost:   fmt.Sprintf(\"%s:%v\", host, port),\n\t\t\tPath:   req.URL.Path,\n\t\t}\n\t\tif len(req.URL.RawQuery) > 0 {\n\t\t\ttarget.RawQuery += \"?\" + req.URL.RawQuery\n\t\t}\n\t\tlog.Printf(\"redirect to: %s\", target.String())\n\t\thttp.Redirect(w, req, target.String(), http.StatusTemporaryRedirect)\n\t})\n}\n\nfunc Home() http.HandlerFunc ", "output": "{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\trender.JSON(w, http.StatusOK, \"Welcome to Janus\")\n\t}\n}"}
{"input": "package v1beta1\n\nimport (\n\tv1beta1 \"k8s.io/api/policy/v1beta1\"\n)\n\n\n\ntype FSGroupStrategyOptionsApplyConfiguration struct {\n\tRule   *v1beta1.FSGroupStrategyType `json:\"rule,omitempty\"`\n\tRanges []IDRangeApplyConfiguration  `json:\"ranges,omitempty\"`\n}\n\n\n\nfunc FSGroupStrategyOptions() *FSGroupStrategyOptionsApplyConfiguration {\n\treturn &FSGroupStrategyOptionsApplyConfiguration{}\n}\n\n\n\n\nfunc (b *FSGroupStrategyOptionsApplyConfiguration) WithRule(value v1beta1.FSGroupStrategyType) *FSGroupStrategyOptionsApplyConfiguration {\n\tb.Rule = &value\n\treturn b\n}\n\n\n\n\n\n\nfunc (b *FSGroupStrategyOptionsApplyConfiguration) WithRanges(values ...*IDRangeApplyConfiguration) *FSGroupStrategyOptionsApplyConfiguration ", "output": "{\n\tfor i := range values {\n\t\tif values[i] == nil {\n\t\t\tpanic(\"nil value passed to WithRanges\")\n\t\t}\n\t\tb.Ranges = append(b.Ranges, *values[i])\n\t}\n\treturn b\n}"}
{"input": "package collectors\n\nimport (\n\t\"container/list\"\n\n\t\"github.com/blevesearch/bleve/search\"\n)\n\ntype collectStoreList struct {\n\tresults *list.List\n\tcompare collectorCompare\n}\n\n\n\nfunc (c *collectStoreList) Add(doc *search.DocumentMatch) {\n\tfor e := c.results.Front(); e != nil; e = e.Next() {\n\t\tcurr := e.Value.(*search.DocumentMatch)\n\t\tif c.compare(doc, curr) >= 0 {\n\t\t\tc.results.InsertBefore(doc, e)\n\t\t\treturn\n\t\t}\n\t}\n\tc.results.PushBack(doc)\n}\n\nfunc (c *collectStoreList) RemoveLast() *search.DocumentMatch {\n\treturn c.results.Remove(c.results.Front()).(*search.DocumentMatch)\n}\n\nfunc (c *collectStoreList) Final(skip int, fixup collectorFixup) (search.DocumentMatchCollection, error) {\n\tif c.results.Len()-skip > 0 {\n\t\trv := make(search.DocumentMatchCollection, c.results.Len()-skip)\n\t\ti := 0\n\t\tskipped := 0\n\t\tfor e := c.results.Back(); e != nil; e = e.Prev() {\n\t\t\tif skipped < skip {\n\t\t\t\tskipped++\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\trv[i] = e.Value.(*search.DocumentMatch)\n\t\t\terr := fixup(rv[i])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t\treturn rv, nil\n\t}\n\treturn search.DocumentMatchCollection{}, nil\n}\n\nfunc (c *collectStoreList) Len() int {\n\treturn c.results.Len()\n}\n\nfunc newStoreList(cap int, compare collectorCompare) *collectStoreList ", "output": "{\n\trv := &collectStoreList{\n\t\tresults: list.New(),\n\t\tcompare: compare,\n\t}\n\n\treturn rv\n}"}
{"input": "package matrix\n\nimport \"github.com/hebl/gosl/errors\"\n\n\n\n\nfunc Product(A, B *Matrix) (*Matrix, error) ", "output": "{\n\tif A.size2 != B.size1 {\n\t\treturn nil, errors.ErrBADLEN\n\t}\n\n\tC := Zeros(A.size1, B.size2)\n\n\tfor i := 0; i < A.size1; i++ {\n\t\tfor j := 0; j < B.size2; j++ {\n\t\t\tv := 0.0\n\t\t\tfor k := 0; k < A.size2; k++ {\n\t\t\t\tv += A.At(i, k) * B.At(k, j)\n\t\t\t}\n\t\t\tC.Set(i, j, v)\n\t\t}\n\t}\n\n\treturn C, nil\n}"}
{"input": "package matchers\n\nimport (\n\t\"fmt\"\n\n\t\"gx/ipfs/QmUWtNQd8JdEiYiDqNYTUcaqyteJZ2rTNQLiw3dauLPccy/gomega/format\"\n)\n\ntype BeEmptyMatcher struct {\n}\n\nfunc (matcher *BeEmptyMatcher) Match(actual interface{}) (success bool, err error) {\n\tlength, ok := lengthOf(actual)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"BeEmpty matcher expects a string/array/map/channel/slice.  Got:\\n%s\", format.Object(actual, 1))\n\t}\n\n\treturn length == 0, nil\n}\n\n\n\nfunc (matcher *BeEmptyMatcher) NegatedFailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, \"not to be empty\")\n}\n\nfunc (matcher *BeEmptyMatcher) FailureMessage(actual interface{}) (message string) ", "output": "{\n\treturn format.Message(actual, \"to be empty\")\n}"}
{"input": "package gin\n\nimport (\n\t\"github.com/gin-gonic/gin/binding\"\n\t\"log\"\n)\n\nfunc (c *Context) GetCookie(name string) (string, error) {\n\tlog.Println(\"GetCookie() method is deprecated. Use Cookie() instead.\")\n\treturn c.Cookie(name)\n}\n\n\n\n\n\nfunc (c *Context) BindWith(obj interface{}, b binding.Binding) error ", "output": "{\n\tlog.Println(`BindWith(\\\"interface{}, binding.Binding\\\") error is going to\n\tbe deprecated, please check issue #662 and either use MustBindWith() if you\n\twant HTTP 400 to be automatically returned if any error occur, of use\n\tShouldBindWith() if you need to manage the error.`)\n\treturn c.MustBindWith(obj, b)\n}"}
{"input": "package kiwotigo\n\ntype Position struct {\n\tX, Y uint\n}\n\nfunc (pos *Position) Row() uint {\n\treturn pos.Y\n}\n\nfunc (pos *Position) SetRow(row uint) uint {\n\tpos.Y = row\n\treturn pos.Y\n}\n\nfunc (pos *Position) Col() uint {\n\treturn pos.X\n}\n\n\n\nfunc (pos *Position) SetCol(col uint) uint ", "output": "{\n\tpos.X = col\n\treturn pos.X\n}"}
{"input": "package gofaker\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"unicode\"\n)\n\n\ntype Bank struct {\n\tfaker *Faker\n}\n\n\n\n\n\nfunc (b *Bank) BIC() string {\n\treturn b.faker.MustFetch(\"bank.swift_bic\")\n}\n\nfunc (b *Bank) IBAN() string {\n\tiban, err := b.NationalIBAN(\"DE\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn iban\n}\n\nfunc getIBANInfo(ibanDetails []map[string]string, countryCode string) map[string]string {\n\tfor _, m := range ibanDetails {\n\t\tif m[\"bank_country_code\"] == countryCode {\n\t\t\treturn m\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (b *Bank) NationalIBAN(countryCode string) (string, error) {\n\tdetails := b.faker.data.GetStringMapList(\"bank.iban_details\")\n\tm := getIBANInfo(details, countryCode)\n\tif m == nil {\n\t\treturn \"\", fmt.Errorf(\"invalid country code for iban '%s'\", countryCode)\n\t}\n\ts := bytes.NewBufferString(countryCode)\n\tnumLetters, err := strconv.Atoi(m[\"iban_letter_code\"])\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor i := 0; i < numLetters; i++ {\n\t\ts.WriteRune(unicode.ToUpper(b.faker.RandomLetter()))\n\t}\n\tnumDigits, err := strconv.Atoi(m[\"iban_digits\"])\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor i := 0; i < numDigits; i++ {\n\t\ts.WriteRune(b.faker.RandomDigit())\n\t}\n\treturn s.String(), nil\n}\n\nfunc (b *Bank) Name() string ", "output": "{\n\treturn b.faker.MustFetch(\"bank.name\")\n}"}
{"input": "package tracker\n\nimport (\n\t\"sync\"\n\n\t\"github.com/GoogleContainerTools/skaffold/pkg/skaffold/graph\"\n)\n\ntype Container struct {\n\tName string\n\tID   string\n}\n\ntype ContainerTracker struct {\n\tsync.RWMutex\n\tdeployedContainers  map[string]Container      \n\tcontainerToArtifact map[string]graph.Artifact \n\tcontainers          map[string]bool           \n\tnotifier            chan string\n}\n\n\nfunc NewContainerTracker() *ContainerTracker {\n\treturn &ContainerTracker{\n\t\tcontainerToArtifact: make(map[string]graph.Artifact),\n\t\tdeployedContainers:  make(map[string]Container),\n\t\tnotifier:            make(chan string, 1),\n\t}\n}\n\n\n\n\n\n\nfunc (t *ContainerTracker) ArtifactForContainer(id string) graph.Artifact {\n\tt.Lock()\n\tdefer t.Unlock()\n\treturn t.containerToArtifact[id]\n}\n\n\n\nfunc (t *ContainerTracker) ContainerForImage(image string) (Container, bool) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tc, found := t.deployedContainers[image]\n\treturn c, found\n}\n\n\n\nfunc (t *ContainerTracker) DeployedContainers() map[string]Container {\n\treturn t.deployedContainers\n}\n\n\nfunc (t *ContainerTracker) Reset() {\n\tfor c := range t.containers {\n\t\tdelete(t.containers, c)\n\t}\n}\n\n\nfunc (t *ContainerTracker) Add(artifact graph.Artifact, c Container) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tt.deployedContainers[artifact.ImageName] = c\n\tt.containerToArtifact[c.ID] = artifact\n\tgo func() {\n\t\tt.notifier <- c.ID\n\t}()\n}\n\nfunc (t *ContainerTracker) Notifier() chan string ", "output": "{\n\treturn t.notifier\n}"}
{"input": "package objects\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"time\"\n)\n\n\ntype Logger interface {\n\tWriteLog(log string, writer io.Writer, output bool) error\n}\n\n\n\n\nfunc WriteLog(log string, writer io.Writer, timestamp bool, objects ...Logger) error ", "output": "{\n\tif timestamp == true {\n\t\tlog = fmt.Sprintf(\"[%d] %s\", time.Now().Unix(), log)\n\t}\n\n\tfor i, obj := range objects {\n\t\tif i == 0 {\n\t\t\tif err := obj.WriteLog(log, writer, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif err := obj.WriteLog(log, writer, false); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}"}
{"input": "package generators\n\nimport (\n\t\"go-sysgen/src/definitions\"\n)\n\ntype (\n\tPrimaryStarGenerator struct{}\n)\n\n\nfunc (Generator PrimaryStarGenerator) GetName() string {\n\treturn \"PrimaryStarGenerator\"\n}\n\n\n\n\nfunc (Generator PrimaryStarGenerator) getStarClassProbability() definitions.Probability {\n\tvar result definitions.Probability\n\n\tresult.Dice = append(result.Dice, definitions.Dice{\n\t\tSides: 10,\n\t}, definitions.Dice{\n\t\tSides: 10,\n\t})\n\n\tresult.Lookup = map[int]interface{}{\n\t\t3:  \"A\",\n\t\t7:  \"F\",\n\t\t12: \"G\",\n\t\t17: \"K\",\n\t\t20: \"M\",\n\t}\n\n\treturn result\n}\n\nfunc (Generator PrimaryStarGenerator) getStarSizeProbability() definitions.Probability {\n\tvar result definitions.Probability\n\n\tresult.Dice = append(result.Dice, definitions.Dice{\n\t\tSides: 10,\n\t}, definitions.Dice{\n\t\tSides: 10,\n\t})\n\n\tresult.Lookup = map[int]interface{}{\n\t\t2:  \"II\",\n\t\t4:  \"III\",\n\t\t8:  \"IV\",\n\t\t18: \"V\",\n\t\t20: \"VI\",\n\t}\n\n\treturn result\n}\n\nfunc (Generator PrimaryStarGenerator) Run(system *definitions.System) ", "output": "{\n\tvar resultStar definitions.Star\n\tvar result interface{}\n\n\tresultStar.Primary = true\n\tresultStar.Dwarf = false\n\n\tclassProb := Generator.getStarClassProbability()\n\tresult = definitions.GetProbabilityResult(\n\t\tclassProb.RollAll(),\n\t\tclassProb.Lookup,\n\t)\n\tresultStar.Class = result.(string)\n\n\tsizeProb := Generator.getStarSizeProbability()\n\tresult = definitions.GetProbabilityResult(\n\t\tsizeProb.RollAll(),\n\t\tsizeProb.Lookup,\n\t)\n\tresultStar.Size = result.(string)\n\n\tresultStar.DecimalClassification = resultStar.GetDecimalClassification()\n\n\tresultStar.DwarfType = \"-\"\n\n\tsystem.Bodies = append(system.Bodies, resultStar)\n}"}
{"input": "package ambition\n\nimport (\n\tcrand \"crypto/rand\"\n\t\"encoding/base64\"\n\t\"golang.org/x/crypto/bcrypt\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"time\"\n)\n\n\n\n\nfunc CreateSaltAndHashedPassword(password []byte) ([]byte, []byte, error) {\n\tnano := time.Now().UnixNano()\n\trand.Seed(nano)\n\trandom := rand.Int31()\n\tsalt := strconv.Itoa(int(nano)) + strconv.Itoa(int(random))\n\n\thash, err := bcrypt.GenerateFromPassword([]byte(string(password)+salt), 10)\n\n\treturn []byte(salt), hash, err\n}\n\n\n\n\n\n\n\n\n\nfunc GenerateRandomBytes(n int) ([]byte, error) {\n\tb := make([]byte, n)\n\t_, err := crand.Read(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b, nil\n}\n\n\n\n\n\n\nfunc GenerateRandomString(s int) (string, error) {\n\tb, err := GenerateRandomBytes(s)\n\treturn base64.URLEncoding.EncodeToString(b), err\n}\n\nfunc HashToken(token string) string {\n\thash, _ := bcrypt.GenerateFromPassword([]byte(token), 10)\n\treturn string(hash)\n}\n\nfunc CompareHashAndToken(hash string, token string) bool {\n\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(token))\n\treturn err == nil\n}\n\nfunc LoginUser(username string, password string) {}\n\nfunc CompareSaltAndPasswordToHash(salt, hashedPassword, password []byte) bool ", "output": "{\n\tsaltedPassword := []byte(string(password) + string(salt))\n\n\terr := bcrypt.CompareHashAndPassword(hashedPassword, saltedPassword)\n\treturn err == nil\n}"}
{"input": "package storagesync\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Version() string {\n\treturn version.Number\n}\n\nfunc UserAgent() string ", "output": "{\n\treturn \"Azure-SDK-For-Go/\" + version.Number + \" storagesync/2018-07-01\"\n}"}
{"input": "package main\n\nimport (\n\t\"euler/tools\"\n\t\"fmt\"\n)\n\n\n\nfunc main() {\n\tfmt.Println(problem73())\n}\n\nfunc problem73() int ", "output": "{\n\tsum := 0\n\tfor d := 1; d <= 12000; d++ {\n\t\tfor n := 1; n < d; n++ {\n\t\t\tif tools.GCD(n, d) == 1 {\n\t\t\t\tfn, fd := float64(n), float64(d)\n\t\t\t\trat := fn / fd\n\t\t\t\tif 1.0/3.0 < rat && rat < 0.5 {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn sum\n}"}
{"input": "package max_slice\n\nimport (\n\t. \"gopkg.in/check.v1\"\n)\n\ntype MySuite struct{}\n\nvar _ = Suite(&MySuite{})\n\n\n\nfunc (s *MySuite) BenchmarkMaxSliceSum(c *C) {\n\tfor i := 0; i < c.N; i++ {\n\t\tMaxSliceSum([]int{-10})\n\t}\n}\n\nfunc (s *MySuite) TestMaxSliceSum(c *C) ", "output": "{\n\tc.Assert(MaxSliceSum([]int{-10}), Equals, -10)\n}"}
{"input": "package policy\n\nimport original \"github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2015-10-01-preview/policy\"\n\ntype AssignmentsClient = original.AssignmentsClient\n\nconst (\n\tDefaultBaseURI = original.DefaultBaseURI\n)\n\ntype BaseClient = original.BaseClient\ntype DefinitionsClient = original.DefinitionsClient\ntype Type = original.Type\n\nconst (\n\tBuiltIn      Type = original.BuiltIn\n\tCustom       Type = original.Custom\n\tNotSpecified Type = original.NotSpecified\n)\n\ntype Assignment = original.Assignment\ntype AssignmentListResult = original.AssignmentListResult\ntype AssignmentListResultIterator = original.AssignmentListResultIterator\ntype AssignmentListResultPage = original.AssignmentListResultPage\ntype AssignmentProperties = original.AssignmentProperties\ntype Definition = original.Definition\ntype DefinitionListResult = original.DefinitionListResult\ntype DefinitionListResultIterator = original.DefinitionListResultIterator\ntype DefinitionListResultPage = original.DefinitionListResultPage\ntype DefinitionProperties = original.DefinitionProperties\n\nfunc NewAssignmentsClient(subscriptionID string) AssignmentsClient {\n\treturn original.NewAssignmentsClient(subscriptionID)\n}\nfunc NewAssignmentsClientWithBaseURI(baseURI string, subscriptionID string) AssignmentsClient {\n\treturn original.NewAssignmentsClientWithBaseURI(baseURI, subscriptionID)\n}\nfunc New(subscriptionID string) BaseClient {\n\treturn original.New(subscriptionID)\n}\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient {\n\treturn original.NewWithBaseURI(baseURI, subscriptionID)\n}\nfunc NewDefinitionsClient(subscriptionID string) DefinitionsClient {\n\treturn original.NewDefinitionsClient(subscriptionID)\n}\nfunc NewDefinitionsClientWithBaseURI(baseURI string, subscriptionID string) DefinitionsClient {\n\treturn original.NewDefinitionsClientWithBaseURI(baseURI, subscriptionID)\n}\nfunc PossibleTypeValues() []Type {\n\treturn original.PossibleTypeValues()\n}\nfunc UserAgent() string {\n\treturn original.UserAgent() + \" profiles/2017-03-09\"\n}\n\n\nfunc Version() string ", "output": "{\n\treturn original.Version()\n}"}
{"input": "package page\n\nimport (\n\t\"testing\"\n\n\t\"github.com/issue9/assert\"\n)\n\nfunc TestPage_Next(t *testing.T) {\n\ta := assert.New(t)\n\tp := &Page{}\n\n\tp.Next(\"url\", \"\")\n\ta.Equal(p.NextPage.URL, \"url\")\n\ta.Equal(p.NextPage.Rel, \"next\")\n\n\tp.Next(\"url\", \"text\")\n\ta.Equal(p.NextPage.URL, \"url\")\n\ta.Equal(p.NextPage.Rel, \"next\")\n\ta.Equal(p.NextPage.Text, \"text\")\n}\n\n\n\nfunc TestPage_Prev(t *testing.T) ", "output": "{\n\ta := assert.New(t)\n\tp := &Page{}\n\n\tp.Prev(\"url\", \"\")\n\ta.Equal(p.PrevPage.URL, \"url\")\n\ta.Equal(p.PrevPage.Rel, \"prev\")\n\n\tp.Prev(\"url\", \"text\")\n\ta.Equal(p.PrevPage.URL, \"url\")\n\ta.Equal(p.PrevPage.Rel, \"prev\")\n\ta.Equal(p.PrevPage.Text, \"text\")\n}"}
{"input": "package backingstore\n\nimport (\n\t\"github.com/gostor/gotgt/pkg/api\"\n\t\"github.com/gostor/gotgt/pkg/scsi\"\n)\n\nfunc init() {\n\tscsi.RegisterBackingStore(\"null\", newNull)\n}\n\ntype NullBackingStore struct {\n\tscsi.BaseBackingStore\n}\n\nfunc newNull() (api.BackingStore, error) {\n\treturn &NullBackingStore{\n\t\tBaseBackingStore: scsi.BaseBackingStore{\n\t\t\tName:            \"null\",\n\t\t\tDataSize:        0,\n\t\t\tOflagsSupported: 0,\n\t\t},\n\t}, nil\n}\n\n\n\nfunc (bs *NullBackingStore) Close(dev *api.SCSILu) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Init(dev *api.SCSILu, Opts string) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Exit(dev *api.SCSILu) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Size(dev *api.SCSILu) uint64 {\n\treturn 0\n}\n\nfunc (bs *NullBackingStore) Read(offset, tl int64) ([]byte, error) {\n\treturn nil, nil\n}\n\nfunc (bs *NullBackingStore) Write(wbuf []byte, offset int64) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) DataSync(offset, tl int64) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) DataAdvise(offset, length int64, advise uint32) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Unmap([]api.UnmapBlockDescriptor) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Open(dev *api.SCSILu, path string) error ", "output": "{\n\treturn nil\n}"}
{"input": "package go_koans\n\nfunc isPrimeNumber(possiblePrime int) bool {\n\tfor underPrime := 2; underPrime < possiblePrime; underPrime++ {\n\t\tif possiblePrime%underPrime == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\n\nfunc aboutConcurrency() {\n\tch := make(chan int)\n\n\tassert(__delete_me__) \n\n\tassert(<-ch == 2)\n\tassert(<-ch == 3)\n\tassert(<-ch == 5)\n\tassert(<-ch == 7)\n\tassert(<-ch == 11)\n}\n\nfunc findPrimeNumbers(channel chan int) ", "output": "{\n\tfor i := 2; ;  i++ {\n\n\t\tassert(i < 100) \n\t}\n}"}
{"input": "package install\n\nimport (\n\t\"k8s.io/apimachinery/pkg/apimachinery/announced\"\n\t\"k8s.io/apimachinery/pkg/apimachinery/registered\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/apis/batch\"\n\t\"k8s.io/kubernetes/pkg/apis/batch/v1\"\n\t\"k8s.io/kubernetes/pkg/apis/batch/v2alpha1\"\n)\n\nfunc init() {\n\tInstall(api.GroupFactoryRegistry, api.Registry, api.Scheme)\n}\n\n\n\n\nfunc Install(groupFactoryRegistry announced.APIGroupFactoryRegistry, registry *registered.APIRegistrationManager, scheme *runtime.Scheme) ", "output": "{\n\tif err := announced.NewGroupMetaFactory(\n\t\t&announced.GroupMetaFactoryArgs{\n\t\t\tGroupName:                  batch.GroupName,\n\t\t\tVersionPreferenceOrder:     []string{v1.SchemeGroupVersion.Version, v2alpha1.SchemeGroupVersion.Version},\n\t\t\tImportPrefix:               \"k8s.io/kubernetes/pkg/apis/batch\",\n\t\t\tAddInternalObjectsToScheme: batch.AddToScheme,\n\t\t},\n\t\tannounced.VersionToSchemeFunc{\n\t\t\tv1.SchemeGroupVersion.Version:       v1.AddToScheme,\n\t\t\tv2alpha1.SchemeGroupVersion.Version: v2alpha1.AddToScheme,\n\t\t},\n\t).Announce(groupFactoryRegistry).RegisterAndEnable(registry, scheme); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\t\"time\"\n\t\"os\"\n\t\"fmt\"\n\t\"fence-executor/providers\"\n\t\"fence-executor/utils\"\n)\n\n\n\n\nfunc main() {\n\tvar args = os.Args[1:]\n\tvar parameters map[string]string\n\tparameters = make(map[string]string)\n\tfmt.Println(args)\n\n\tparameters[\"address\"] = args[0]\n\tparameters[\"username\"] = args[1]\n\tparameters[\"password\"] = args[2]\n\tparameters[\"agent\"] = args[3]\n\tparameters[\"provider\"] = args[4]\n\tparameters[\"port\"] = args[5]\n\n\tfmt.Println(parameters)\n\texecuteFence(parameters)\n\n\tfmt.Println(\"Done\")\n}\n\nfunc executeFence(parameters map[string]string) error ", "output": "{\n\tf := utils.CreateNewFence()\n\tprovider := providers.CreateRHProvider(nil)\n\tf.RegisterProvider(\"redhat\", provider)\n\terr := f.LoadAgents(10 * time.Second)\n\tif err != nil {\n\t\tlog.Print(\"error loading agents:\", err)\n\t\treturn err\n\t}\n\n\tac := utils.NewAgentConfig(parameters[\"provider\"], parameters[\"agent\"])\n\n\tac.SetParameter(\"--ip\", parameters[\"address\"])\n\tac.SetParameter(\"--username\", parameters[\"username\"])\n\tac.SetParameter(\"--password\", parameters[\"password\"])\n\tac.SetParameter(\"--plug\", parameters[\"port\"])\n\n\terr = f.Run(ac, utils.Status, 10*time.Second)\n\tif err != nil {\n\t\tlog.Print(\"error: \", err)\n\t\treturn err\n\t}\n\tlog.Print(\"Fenced was executed!\")\n\treturn nil\n}"}
{"input": "package timeseries\n\nimport (\n\t\"sort\"\n\t\"strconv\"\n)\n\n\nfunc SortBy(series []*TimeSeriesData, order string, aggFunc AggFunc) []*TimeSeriesData {\n\tfor _, s := range series {\n\t\ts.Meta.AggValue = aggFunc(s.TS)\n\t}\n\n\tsort.Slice(series, func(i, j int) bool {\n\t\tif series[i].Meta.AggValue != nil && series[j].Meta.AggValue != nil {\n\t\t\treturn *series[i].Meta.AggValue < *series[j].Meta.AggValue\n\t\t} else if series[j].Meta.AggValue != nil {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\n\tif order == \"desc\" {\n\t\treverseSeries := make([]*TimeSeriesData, len(series))\n\t\tfor i := 0; i < len(series); i++ {\n\t\t\treverseSeries[i] = series[len(series)-1-i]\n\t\t}\n\t\tseries = reverseSeries\n\t}\n\n\treturn series\n}\n\nfunc SortByItem(series []*TimeSeriesData) []*TimeSeriesData {\n\tsort.Slice(series, func(i, j int) bool {\n\t\titemIDi, err := strconv.Atoi(series[i].Meta.Item.ID)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\titemIDj, err := strconv.Atoi(series[j].Meta.Item.ID)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\treturn itemIDi < itemIDj\n\t})\n\n\treturn series\n}\n\n\n\nfunc SortByName(series []*TimeSeriesData, order string) []*TimeSeriesData ", "output": "{\n\tsort.Slice(series, func(i, j int) bool {\n\t\tif order == \"desc\" {\n\t\t\treturn series[i].Meta.Name > series[j].Meta.Name\n\t\t} else {\n\t\t\treturn series[i].Meta.Name < series[j].Meta.Name\n\t\t}\n\t})\n\n\treturn series\n}"}
{"input": "package actionerror\n\ntype NoRelationshipError struct {\n}\n\n\n\nfunc (e NoRelationshipError) Error() string ", "output": "{\n\treturn \"No relationship found.\"\n}"}
{"input": "package model\n\n\nimport \"soy/db/link\"\nimport \"soy/vat\"\nimport \"math/rand\"\n\ntype PlayerModel struct {\n\tBaseModel\n}\n\nfunc _init_player() {\n\tplayer := new(PlayerModel)\n\tvar str string = \"未命名\" + vat.IntToString(rand.Int()%1000)\n\tprintln(\"设置名字:\", str)\n\tplayer.ChangeName(str, 1008)\n\tret := player.GetPlayerInfo(1008)\n\tprintln(\"获取用户:\", ret.String(\"name\"))\n}\n\n\nfunc (this *PlayerModel) GetPlayerInfo(uid int32) link.IRowItem {\n\ttx := this.Sql().Begin()\n\tdefer tx.Commit()\n\tret := tx.ReadQuery(\"SELECT * FROM player WHERE uid=?\", uid)\n\tif ret == nil || ret.Empty() {\n\t\treturn nil\n\t}\n\treturn ret.Row(0)\n}\n\n\n\n\n\nfunc (this *PlayerModel) RemovePlayerInfo(uid int32) {\n\ttx := this.Sql().Begin()\n\tdefer tx.Commit()\n\ttx.WriteQuery(\"DELETE FROM player WHERE uid=?\", uid)\n}\n\nfunc (this *PlayerModel) ChangeName(name string, uid int32) ", "output": "{\n\ttx := this.Sql().Begin()\n\tdefer tx.Commit()\n\ttx.WriteQuery(\"UPDATE player SET name=? WHERE uid=?\", name, uid)\n}"}
{"input": "package server\n\nimport \"testing\"\n\nfunc Test_Routes_routeNames(t *testing.T) {\n\tcounter := make(map[string]int)\n\n\tfor _, route := range Routes() {\n\t\tname := route.Name\n\n\t\tcounter[name]++\n\t\tif counter[name] > 1 {\n\t\t\tt.Fatalf(\"duplicate route name: %q\", name)\n\t\t}\n\t}\n}\n\n\n\nfunc Test_Routes_routeSignaures(t *testing.T) ", "output": "{\n\tcounter := make(map[string]int)\n\n\tfor _, route := range Routes() {\n\t\tsignature := route.Path\n\n\t\tcounter[signature]++\n\t\tif counter[signature] > 1 {\n\t\t\tt.Fatalf(\"duplicate route signature: %q\", signature)\n\t\t}\n\t}\n}"}
{"input": "package converter\n\nimport (\n\t\"github.com/nono/gofpdf\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\n\ntype PdfGenerator struct {\n\tpdfObj *gofpdf.Fpdf\n}\n\n\n\nfunc NewPdf() *PdfGenerator {\n\treturn &PdfGenerator{gofpdf.New(\"L\", \"mm\", \"A4\", \"\")}\n}\n\n\n\n\n\n\n\nfunc (pdfGen *PdfGenerator) AddJPEGImage(imageName string) {\n\tpdfGen.pdfObj.Image(imageName, 0, 0, 0, 0, true, \"JPEG\", 0, \"\")\n}\n\n\n\nfunc (pdfGen *PdfGenerator) ClosePdf(pdfName string) error {\n\treturn pdfGen.pdfObj.OutputFileAndClose(pdfName)\n\n}\n\n\n\n\nfunc SaveSWFPage(swfUrl, swfDir string) (string, error) {\n\tpageReq, errRequest := http.Get(swfUrl)\n\n\tif errRequest != nil {\n\t\treturn \"\", errRequest\n\t}\n\n\tdefer pageReq.Body.Close()\n\n\tswfImage, errImage := ioutil.ReadAll(pageReq.Body)\n\n\tif errImage != nil {\n\t\treturn \"\", errImage\n\t}\n\n\tslideIndex := strings.Index(swfUrl, \"-slide\")\n\n\tslideFileName := swfDir + string(os.PathSeparator) + swfUrl[slideIndex+1:]\n\n\tioutil.WriteFile(slideFileName, swfImage, os.ModePerm)\n\n\treturn slideFileName, nil\n\n}\n\n\n\nfunc ExecuteConversion(slideFileName string) (string, error) {\n\treplacer := strings.NewReplacer(\".swf\", \".png\")\n\timageName := replacer.Replace(slideFileName)\n\n\tswfCommand := exec.Command(\"swfrender\", slideFileName, \"-o\", imageName)\n\n\treturn imageName, swfCommand.Run()\n}\n\nfunc (pdfGen *PdfGenerator) AddPngImage(imageName string) ", "output": "{\n\tpdfGen.pdfObj.Image(imageName, 0, 0, 0, 0, true, \"PNG\", 0, \"\")\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\n\nfunc (r *oauthProxy) dropCookie(cx *gin.Context, name, value string, duration time.Duration) {\n\tdomain := strings.Split(cx.Request.Host, \":\")[0]\n\tif r.config.CookieDomain != \"\" {\n\t\tdomain = r.config.CookieDomain\n\t}\n\tcookie := &http.Cookie{\n\t\tName:     name,\n\t\tDomain:   domain,\n\t\tHttpOnly: r.config.HTTPOnlyCookie,\n\t\tPath:     \"/\",\n\t\tSecure:   r.config.SecureCookie,\n\t\tValue:    value,\n\t}\n\tif duration != 0 {\n\t\tcookie.Expires = time.Now().Add(duration)\n\t}\n\n\thttp.SetCookie(cx.Writer, cookie)\n}\n\n\nfunc (r *oauthProxy) dropAccessTokenCookie(cx *gin.Context, value string, duration time.Duration) {\n\tr.dropCookie(cx, r.config.CookieAccessName, value, duration)\n}\n\n\nfunc (r *oauthProxy) dropRefreshTokenCookie(cx *gin.Context, value string, duration time.Duration) {\n\tr.dropCookie(cx, r.config.CookieRefreshName, value, duration)\n}\n\n\nfunc (r *oauthProxy) clearAllCookies(cx *gin.Context) {\n\tr.clearAccessTokenCookie(cx)\n\tr.clearRefreshTokenCookie(cx)\n}\n\n\nfunc (r *oauthProxy) clearRefreshTokenCookie(cx *gin.Context) {\n\tr.dropCookie(cx, r.config.CookieRefreshName, \"\", time.Duration(-10*time.Hour))\n}\n\n\n\n\nfunc (r *oauthProxy) clearAccessTokenCookie(cx *gin.Context) ", "output": "{\n\tr.dropCookie(cx, r.config.CookieAccessName, \"\", time.Duration(-10*time.Hour))\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Rectangle struct {\n\twidth, height float64\n}\n\ntype Circle struct {\n\tradius float64\n}\n\nfunc (r Rectangle) area() float64 {\n\treturn r.width * r.height\n}\n\n\n\nfunc main() {\n\tr1 := Rectangle{12, 2}\n\tr2 := Rectangle{9, 4}\n\tc1 := Circle{10}\n\tc2 := Circle{25}\n\n\tfmt.Println(\"Area of r1 is: \", r1.area())\n\tfmt.Println(\"Area of r2 is: \", r2.area())\n\tfmt.Println(\"Area of c1 is: \", c1.area())\n\tfmt.Println(\"Area of c2 is: \", c2.area())\n}\n\nfunc (c Circle) area() float64 ", "output": "{\n\treturn c.radius * c.radius * math.Pi\n}"}
{"input": "package test\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"testing\"\n)\n\n\n\nfunc TestCodeAuth(t *testing.T) ", "output": "{\n\tgo startTestServer()\n\n\tcfg := OConfig\n\n\tcfg.ClientID = CLIENT_ID\n\tcfg.ClientSecret = CLIENT_SECRET\n\n\taurl := cfg.AuthCodeURL(\"state\")\n\tlq, _ := url.ParseQuery(fastHttpGet(nil, aurl, t))\n\tcq := fastHttpPost(nil, LOGIN_URL, lq, t)\n\tif cq != NICKNAME {\n\t\tfmt.Println(\"failed\")\n\t}\n}"}
{"input": "package wml\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n)\n\ntype CT_MailMergeDocType struct {\n\tValAttr ST_MailMergeDocType\n}\n\nfunc NewCT_MailMergeDocType() *CT_MailMergeDocType {\n\tret := &CT_MailMergeDocType{}\n\tret.ValAttr = ST_MailMergeDocType(1)\n\treturn ret\n}\n\nfunc (m *CT_MailMergeDocType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tattr, err := m.ValAttr.MarshalXMLAttr(xml.Name{Local: \"w:val\"})\n\tif err != nil {\n\t\treturn err\n\t}\n\tstart.Attr = append(start.Attr, attr)\n\te.EncodeToken(start)\n\te.EncodeToken(xml.EndElement{Name: start.Name})\n\treturn nil\n}\n\nfunc (m *CT_MailMergeDocType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n\tm.ValAttr = ST_MailMergeDocType(1)\n\tfor _, attr := range start.Attr {\n\t\tif attr.Name.Local == \"val\" {\n\t\t\tm.ValAttr.UnmarshalXMLAttr(attr)\n\t\t}\n\t}\n\tfor {\n\t\ttok, err := d.Token()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing CT_MailMergeDocType: %s\", err)\n\t\t}\n\t\tif el, ok := tok.(xml.EndElement); ok && el.Name == start.Name {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (m *CT_MailMergeDocType) Validate() error {\n\treturn m.ValidateWithPath(\"CT_MailMergeDocType\")\n}\n\n\n\n\nfunc (m *CT_MailMergeDocType) ValidateWithPath(path string) error ", "output": "{\n\tif m.ValAttr == ST_MailMergeDocTypeUnset {\n\t\treturn fmt.Errorf(\"%s/ValAttr is a mandatory field\", path)\n\t}\n\tif err := m.ValAttr.ValidateWithPath(path + \"/ValAttr\"); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package stringcmap\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"testing\"\n)\n\n\n\nfunc TestJSONType(t *testing.T) {\n\tcm := New()\n\tcm.Set(\"1\", uint64(1))\n\n\tj, err := json.Marshal(cm)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar mwj MapWithJSON\n\tmwj.UnmarshalValueFn = func(j json.RawMessage) (interface{}, error) {\n\t\tvar u uint64\n\t\terr = json.Unmarshal(j, &u)\n\t\treturn u, err\n\t}\n\n\tif err = json.Unmarshal(j, &mwj); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor kv := range cm.Iter(context.Background(), 0) {\n\t\tif v, ok := kv.Value.(uint64); !ok || kv.Key != \"1\" || v != 1 {\n\t\t\tt.Fatalf(\"bad kv: %#+v\", kv)\n\t\t}\n\t}\n}\n\nfunc TestJSON(t *testing.T) ", "output": "{\n\tcm := New()\n\tfor i := 0; i < 100; i++ {\n\t\tsi := strconv.Itoa(i)\n\t\tcm.Set(si, si)\n\t}\n\n\tj, err := json.Marshal(cm)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar mwj MapWithJSON\n\n\tif err = json.Unmarshal(j, &mwj); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tokeys, nkeys := cm.Keys(), mwj.Keys()\n\n\tsort.Strings(okeys)\n\tsort.Strings(nkeys)\n\n\tif !reflect.DeepEqual(okeys, nkeys) {\n\t\tt.Fatal(\"!reflect.DeepEqual(okeys, nkeys)\")\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t_ \"expvar\"\n\t_ \"net/http/pprof\"\n\n\t\"github.com/rcrowley/go-metrics\"\n)\n\nvar timer metrics.Timer\n\n\n\nfunc simpleGetValuesSingle(w http.ResponseWriter, r *http.Request) {\n\tstart := time.Now()\n\ts1 := \"800100020000000f67657456616c75657353696e676c65\"\n\tb, _ := ioutil.ReadAll(r.Body)\n\tn := hex.EncodeToString(b[23:27])\n\ts2 := \"0c00000d0001080b00000000080002000000000000\"\n\n\ts := s1 + n + s2\n\tdata := make([]byte, len(s)/2)\n\thex.Decode(data, []byte(s))\n\tw.Write(data)\n\ttimer.UpdateSince(start)\n}\n\nfunc main() {\n\tr := metrics.NewRegistry()\n\ttimer = metrics.GetOrRegisterTimer(\"rtt\", r)\n\tgo metrics.LogScaled(r, time.Second*5, time.Millisecond, log.New(os.Stderr, \"\\t\", 0))\n\n\thttp.HandleFunc(\"/rpc/HFileService\", simpleGetValuesSingle)\n\thttp.HandleFunc(\"/\", helloworld)\n\thttp.ListenAndServe(\":9999\", nil)\n}\n\nfunc helloworld(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tfmt.Fprintf(w, \"ok\")\n}"}
{"input": "package idna\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype info uint16\n\nconst (\n\tcatSmallMask = 0x3\n\tcatBigMask   = 0xF8\n\tindexShift   = 3\n\txorBit       = 0x4    \n\tinlineXOR    = 0xE000 \n\n\tjoinShift = 8\n\tjoinMask  = 0x07\n\n\tviramaModifier = 0x0800\n\tmodifier       = 0x1000\n)\n\n\ntype category uint16\n\nconst (\n\tunknown              category = 0 \n\tmapped               category = 1\n\tdisallowedSTD3Mapped category = 2\n\tdeviation            category = 3\n)\n\nconst (\n\tvalid               category = 0x08\n\tvalidNV8            category = 0x18\n\tvalidXV8            category = 0x28\n\tdisallowed          category = 0x40\n\tdisallowedSTD3Valid category = 0x80\n\tignored             category = 0xC0\n)\n\n\nconst (\n\tjoiningL = (iota + 1)\n\tjoiningD\n\tjoiningT\n\tjoiningR\n\n\tjoinZWJ\n\tjoinZWNJ\n\tjoinVirama\n\tnumJoinTypes\n)\n\n\n\nfunc (c info) category() category {\n\tsmall := c & catSmallMask\n\tif small != 0 {\n\t\treturn category(small)\n\t}\n\treturn category(c & catBigMask)\n}\n\nfunc (c info) joinType() info {\n\tif c.isMapped() {\n\t\treturn 0\n\t}\n\treturn (c >> joinShift) & joinMask\n}\n\nfunc (c info) isModifier() bool {\n\treturn c&(modifier|catSmallMask) == modifier\n}\n\nfunc (c info) isViramaModifier() bool {\n\treturn c&(viramaModifier|catSmallMask) == viramaModifier\n}\n\nfunc (c info) isMapped() bool ", "output": "{\n\treturn c&0x3 != 0\n}"}
{"input": "package heckle\n\nimport (\n\t\"log\"\n\t\"strings\"\n\n\t\"github.com/ianremmler/bort\"\n)\n\nvar (\n\tretorts = retortMap{}\n)\n\ntype retortMap map[string]string\n\nfunc responder(retort string) bort.HandleFunc {\n\treturn func(in, out *bort.Message) error {\n\t\tout.Type = bort.PrivMsg\n\t\tout.Text = strings.Replace(retort, \"%m\", in.Match, -1)\n\t\treturn nil\n\t}\n}\n\n\n\nfunc init() {\n\tbort.RegisterSetup(setup)\n}\n\nfunc setup() error ", "output": "{\n\tif err := bort.GetConfig(&struct{ Retorts retortMap }{retorts}); err != nil {\n\t\treturn err\n\t}\n\tfor watch, retort := range retorts {\n\t\tif _, err := bort.RegisterMatcher(bort.PrivMsg, watch, responder(retort)); err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package iso20022\n\n\ntype ATMContext4 struct {\n\n\tSessionReference *Max35Text `xml:\"SsnRef,omitempty\"`\n\n\tService *ATMService4 `xml:\"Svc\"`\n}\n\n\n\nfunc (a *ATMContext4) AddService() *ATMService4 {\n\ta.Service = new(ATMService4)\n\treturn a.Service\n}\n\nfunc (a *ATMContext4) SetSessionReference(value string) ", "output": "{\n\ta.SessionReference = (*Max35Text)(&value)\n}"}
{"input": "package middleware\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"context\"\n\n\t\"github.com/remind101/pkg/httpx\"\n)\n\n\n\nfunc TestErrorWithHandler(t *testing.T) ", "output": "{\n\tvar called bool\n\tboomErr := errors.New(\"boom\")\n\n\th := &Error{\n\t\tErrorHandler: func(ctx context.Context, err error, w http.ResponseWriter, r *http.Request) {\n\t\t\tcalled = true\n\t\t},\n\t\thandler: httpx.HandlerFunc(func(ctx context.Context, w http.ResponseWriter, r *http.Request) error {\n\t\t\treturn boomErr\n\t\t}),\n\t}\n\n\tctx := context.Background()\n\treq, _ := http.NewRequest(\"GET\", \"/path\", nil)\n\tresp := httptest.NewRecorder()\n\n\terr := h.ServeHTTPContext(ctx, resp, req)\n\tif err != boomErr {\n\t\tt.Fatal(\"Expected error to be returned\")\n\t}\n\n\tif !called {\n\t\tt.Fatal(\"Expected the error handler to be called\")\n\t}\n}"}
{"input": "package mathEx\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"time\"\n)\n\nconst (\n\tPrecision = 0.00000000000001\n)\n\n\n\nfunc LogBaseX(base int32, x float64) float64 {\n\tswitch base {\n\tcase 2:\n\t\treturn math.Log2(x)\n\tcase 10:\n\t\treturn math.Log10(x)\n\t}\n\treturn math.Log2(x) / math.Log2(float64(base))\n}\n\n\nfunc NearEqual(a, b, precision float64) bool {\n\tdiff := math.Abs(a - b)\n\treturn diff < precision\n}\n\n\nfunc RandRangeFloat64(min, max float64) float64 {\n\tif max < min {\n\t\tmax, min = min, max\n\t}\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\treturn r.Float64()*(max-min) + min\n}\n\n\nfunc RandRangeInt64(min, max int64) int64 {\n\tif max < min {\n\t\tmax, min = min, max\n\t}\n\tif max-min == 0 {\n\t\treturn min\n\t}\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\treturn r.Int63n(max-min) + min\n}\n\n\n\n\nfunc Sqrt(x float64) float64 ", "output": "{\n\tswitch {\n\tcase x == 0 || math.IsNaN(x) || math.IsInf(x, 1):\n\t\treturn x\n\tcase x < 0:\n\t\treturn math.NaN()\n\t}\n\n\tconst BEGIN, PRECISION = 1.0, Precision\n\tvar result = BEGIN\n\n\tfor {\n\t\ttemp := result - ((result*result - x) / (2 * result))\n\t\tif diff := math.Abs(result - temp); diff < PRECISION {\n\t\t\tbreak\n\t\t} else {\n\t\t\tresult = temp\n\t\t}\n\t}\n\n\tresultString := fmt.Sprintf(\"%.20f\", result)\n\tresult, _ = strconv.ParseFloat(resultString, 20)\n\n\treturn result\n}"}
{"input": "package amqp\n\nimport \"github.com/NeowayLabs/wabbit\"\n\ntype Publisher struct {\n\tconn    wabbit.Conn\n\tchannel wabbit.Publisher\n}\n\nfunc NewPublisher(conn wabbit.Conn, channel wabbit.Channel) (*Publisher, error) {\n\tvar err error\n\n\tpb := Publisher{\n\t\tconn: conn,\n\t}\n\n\tif channel == nil {\n\t\tchannel, err = conn.Channel()\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tpb.channel = channel\n\n\treturn &pb, nil\n}\n\n\n\nfunc (pb *Publisher) Publish(exc string, route string, message []byte, opt wabbit.Option) error ", "output": "{\n\terr := pb.channel.Publish(\n\t\texc,   \n\t\troute, \n\t\tmessage,\n\t\topt,\n\t)\n\n\treturn err\n}"}
{"input": "package disruptor\n\nimport \"testing\"\n\nfunc BenchmarkWriterReserve(b *testing.B) {\n\tread, written := NewCursor(), NewCursor()\n\twriter := NewWriter(written, read, 1024)\n\titerations := int64(b.N)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor i := int64(0); i < iterations; i++ {\n\t\tsequence := writer.Reserve(1)\n\t\tread.Store(sequence)\n\t}\n}\n\nfunc BenchmarkWriterNextWrapPoint(b *testing.B) {\n\tread, written := NewCursor(), NewCursor()\n\twriter := NewWriter(written, read, 1024)\n\titerations := int64(b.N)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tread.Store(MaxSequenceValue)\n\tfor i := int64(0); i < iterations; i++ {\n\t\twriter.Reserve(1)\n\t}\n}\n\nfunc BenchmarkWriterAwait(b *testing.B) {\n\twritten, read := NewCursor(), NewCursor()\n\twriter := NewWriter(written, read, 1024*64)\n\titerations := int64(b.N)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor i := int64(0); i < iterations; i++ {\n\t\twriter.Await(i)\n\t\tread.Store(i)\n\t}\n}\n\n\n\nfunc BenchmarkWriterCommit(b *testing.B) ", "output": "{\n\twriter := NewWriter(NewCursor(), nil, 1024)\n\titerations := int64(b.N)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor i := int64(0); i < iterations; i++ {\n\t\twriter.Commit(i, i)\n\t}\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetCrossConnectRequest struct {\n\n\tCrossConnectId *string `mandatory:\"true\" contributesTo:\"path\" name:\"crossConnectId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetCrossConnectRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request GetCrossConnectRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\n\n\n\nfunc (request GetCrossConnectRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetCrossConnectResponse struct {\n\n\tRawResponse *http.Response\n\n\tCrossConnect `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response GetCrossConnectResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response GetCrossConnectResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request GetCrossConnectRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) ", "output": "{\n\n\treturn nil, false\n\n}"}
{"input": "package e2enode\n\n\n\n\nfunc IsCgroup2UnifiedMode() bool ", "output": "{\n\treturn false\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi\"\n)\n\ntype todosResource struct{}\n\n\n\n\nfunc (rs todosResource) List(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todos list of stuff..\"))\n}\n\nfunc (rs todosResource) Create(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todos create\"))\n}\n\nfunc (rs todosResource) Get(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todo get\"))\n}\n\nfunc (rs todosResource) Update(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todo update\"))\n}\n\nfunc (rs todosResource) Delete(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todo delete\"))\n}\n\nfunc (rs todosResource) Sync(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"todo sync\"))\n}\n\nfunc (rs todosResource) Routes() chi.Router ", "output": "{\n\tr := chi.NewRouter()\n\n\tr.Get(\"/\", rs.List)    \n\tr.Post(\"/\", rs.Create) \n\tr.Put(\"/\", rs.Delete)\n\n\tr.Route(\"/{id}\", func(r chi.Router) {\n\t\tr.Get(\"/\", rs.Get)       \n\t\tr.Put(\"/\", rs.Update)    \n\t\tr.Delete(\"/\", rs.Delete) \n\t\tr.Get(\"/sync\", rs.Sync)\n\t})\n\n\treturn r\n}"}
{"input": "package tools\n\nimport (\n\t\"strings\"\n\n\t\"golang.org/x/tools/go/callgraph\"\n\t\"golang.org/x/tools/go/callgraph/rta\"\n\t\"golang.org/x/tools/go/ssa\"\n)\n\n\n\ntype CallGraphNode struct {\n\tName string\n\n\tDepth int\n}\n\n\n\ntype CallGraph []*CallGraphNode\n\n\n\n\ntype ProfileTarget struct {\n\tQualifiedName string\n\n\tPkgPrefix string\n\n\tssaFunc *ssa.Function\n}\n\n\n\n\n\n\n\n\n\n\nfunc (pt *ProfileTarget) CallGraph() CallGraph {\n\tcg := make(CallGraph, 0)\n\tif pt.ssaFunc == nil {\n\t\treturn append(cg, &CallGraphNode{\n\t\t\tName: pt.QualifiedName,\n\t\t})\n\t}\n\n\tvar visitFn func(node *callgraph.Node, depth int)\n\tcalleeCache := make(map[string]struct{}, 0)\n\tvisitFn = func(node *callgraph.Node, depth int) {\n\t\ttarget := ssaQualifiedFuncName(node.Func)\n\n\t\tif !includeInGraph(target, pt.PkgPrefix) {\n\t\t\treturn\n\t\t}\n\n\t\tif _, exists := calleeCache[target]; exists {\n\t\t\treturn\n\t\t}\n\t\tcalleeCache[target] = struct{}{}\n\n\t\tcg = append(cg, &CallGraphNode{\n\t\t\tName:  target,\n\t\t\tDepth: depth,\n\t\t})\n\n\t\tfor _, outEdge := range node.Out {\n\t\t\tvisitFn(outEdge.Callee, depth+1)\n\t\t}\n\t}\n\n\trtaRes := rta.Analyze([]*ssa.Function{pt.ssaFunc}, true)\n\tvisitFn(rtaRes.CallGraph.Root, 0)\n\n\treturn cg\n}\n\n\n\n\nfunc includeInGraph(target string, pkgPrefix string) bool ", "output": "{\n\treturn strings.HasPrefix(target, pkgPrefix)\n}"}
{"input": "package debug\n\nimport (\n\t\"runtime\"\n\t\"fmt\"\n\t\"strings\"\n\t\"encoding/json\"\n\t\"github.com/e154/smart-home-node/system/validation\"\n)\n\n\n\n\nfunc Trace() (trace string) {\n\n\ti := 1 \n\tfor skip := i; ; skip++ {\n\t\tname, file, line, ok := CallerName(skip)\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tfn := strings.Title(strings.Split(name, \".\")[1]) + \"()\"\n\t\ttrace += \"\\n\"\n\t\ttrace += fmt.Sprintf(\"called: %s:%s line: %d\", file, fn, line)\n\t}\n\n\treturn\n}\n\nfunc Println(i interface{}) {\n\tb, _ := json.MarshalIndent(i, \" \", \"  \")\n\tfmt.Println(string(b))\n}\n\nfunc PrintValidationErrs(errs []*validation.Error) {\n\tfor _, err := range errs {\n\t\tfmt.Printf(\"%s - %s\", err.Name, err.String())\n\t}\n}\n\nfunc CallerName(skip int) (name, file string, line int, ok bool) ", "output": "{\n\tvar pc uintptr\n\tif pc, file, line, ok = runtime.Caller(skip + 1); !ok {\n\t\treturn\n\t}\n\tname = runtime.FuncForPC(pc).Name()\n\treturn\n}"}
{"input": "package statsd\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n\ntype ServiceCheckStatus byte\n\nconst (\n\tOk ServiceCheckStatus = 0\n\tWarn ServiceCheckStatus = 1\n\tCritical ServiceCheckStatus = 2\n\tUnknown ServiceCheckStatus = 3\n)\n\n\ntype ServiceCheck struct {\n\tName string\n\tStatus ServiceCheckStatus\n\tTimestamp time.Time\n\tHostname string\n\tMessage string\n\tTags []string\n}\n\n\n\nfunc NewServiceCheck(name string, status ServiceCheckStatus) *ServiceCheck {\n\treturn &ServiceCheck{\n\t\tName:   name,\n\t\tStatus: status,\n\t}\n}\n\n\n\n\nfunc (sc *ServiceCheck) Check() error ", "output": "{\n\tif len(sc.Name) == 0 {\n\t\treturn fmt.Errorf(\"statsd.ServiceCheck name is required\")\n\t}\n\tif byte(sc.Status) < 0 || byte(sc.Status) > 3 {\n\t\treturn fmt.Errorf(\"statsd.ServiceCheck status has invalid value\")\n\t}\n\treturn nil\n}"}
{"input": "package codegen\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"goa.design/goa/v3/codegen/service\"\n\t\"goa.design/goa/v3/expr\"\n)\n\n\nfunc RunHTTPDSL(t *testing.T, dsl func()) *expr.RootExpr {\n\tservice.Services = make(service.ServicesData)\n\tHTTPServices = make(ServicesData)\n\treturn expr.RunDSL(t, dsl)\n}\n\n\n\n\n\n\nfunc makeGolden(t *testing.T, p string) *os.File ", "output": "{\n\tt.Helper()\n\tif os.Getenv(\"GOLDEN\") == \"\" {\n\t\treturn nil\n\t}\n\tf, err := os.OpenFile(p, os.O_CREATE|os.O_WRONLY, 0600)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn f\n}"}
{"input": "package router\n\nimport (\n\t\"sync/atomic\"\n\n\t\"github.com/AsynkronIT/protoactor-go/actor\"\n)\n\ntype roundRobinGroupRouter struct {\n\tGroupRouter\n}\n\ntype roundRobinPoolRouter struct {\n\tPoolRouter\n}\n\ntype roundRobinState struct {\n\tindex   int32\n\troutees *actor.PIDSet\n\tvalues  []actor.PID\n}\n\nfunc (state *roundRobinState) SetRoutees(routees *actor.PIDSet) {\n\tstate.routees = routees\n\tstate.values = routees.Values()\n}\n\nfunc (state *roundRobinState) GetRoutees() *actor.PIDSet {\n\treturn state.routees\n}\n\n\n\nfunc NewRoundRobinPool(size int) *actor.Props {\n\treturn actor.FromSpawnFunc(spawner(&roundRobinPoolRouter{PoolRouter{PoolSize: size}}))\n}\n\nfunc NewRoundRobinGroup(routees ...*actor.PID) *actor.Props {\n\treturn actor.FromSpawnFunc(spawner(&roundRobinGroupRouter{GroupRouter{Routees: actor.NewPIDSet(routees...)}}))\n}\n\nfunc (config *roundRobinPoolRouter) CreateRouterState() Interface {\n\treturn &roundRobinState{}\n}\n\nfunc (config *roundRobinGroupRouter) CreateRouterState() Interface {\n\treturn &roundRobinState{}\n}\n\nfunc roundRobinRoutee(index *int32, routees []actor.PID) actor.PID {\n\ti := int(atomic.AddInt32(index, 1))\n\tif i < 0 {\n\t\t*index = 0\n\t\ti = 0\n\t}\n\tmod := len(routees)\n\troutee := routees[i%mod]\n\treturn routee\n}\n\nfunc (state *roundRobinState) RouteMessage(message interface{}, sender *actor.PID) ", "output": "{\n\tpid := roundRobinRoutee(&state.index, state.values)\n\tpid.Request(message, sender)\n}"}
{"input": "package state\n\nimport \"github.com/loadcloud/gosiege/config\"\n\n\nfunc InitGoSiegeState() (err error) {\n\n\t_ = config.KeyValueStoreOption()\n\treturn nil\n}\n\nfunc ReadValue(key string) (value []byte, err error) {\n\n\treturn nil, nil\n}\n\n\n\nfunc WriteValue(key string, value []byte) (err error) ", "output": "{\n\treturn nil\n}"}
{"input": "package layers\n\nimport (\n\t\"github.com/tsg/gopacket\"\n\t\"testing\"\n)\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n\nfunc checkLayers(p gopacket.Packet, want []gopacket.LayerType, t *testing.T) ", "output": "{\n\tlayers := p.Layers()\n\tt.Log(\"Checking packet layers, want\", want)\n\tfor _, l := range layers {\n\t\tt.Logf(\"  Got layer %v, %d bytes, payload of %d bytes\", l.LayerType(),\n\t\t\tlen(l.LayerContents()), len(l.LayerPayload()))\n\t}\n\tt.Log(p)\n\tif len(layers) != len(want) {\n\t\tt.Errorf(\"  Number of layers mismatch: got %d want %d\", len(layers),\n\t\t\tlen(want))\n\t\treturn\n\t}\n\tfor i, l := range layers {\n\t\tif l.LayerType() != want[i] {\n\t\t\tt.Errorf(\"  Layer %d mismatch: got %v want %v\", i, l.LayerType(),\n\t\t\t\twant[i])\n\t\t}\n\t}\n}"}
{"input": "package ikepolicies\n\nimport \"github.com/gophercloud/gophercloud\"\n\nconst (\n\trootPath     = \"vpn\"\n\tresourcePath = \"ikepolicies\"\n)\n\n\n\nfunc resourceURL(c *gophercloud.ServiceClient, id string) string {\n\treturn c.ServiceURL(rootPath, resourcePath, id)\n}\n\nfunc rootURL(c *gophercloud.ServiceClient) string ", "output": "{\n\treturn c.ServiceURL(rootPath, resourcePath)\n}"}
{"input": "package assertion\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\nconst (\n\tEqualOp       = \"equal\"\n\tNotEqualOp    = \"not_equal\"\n\tContainsOp    = \"contain\"\n\tNotContainsOp = \"not_contain\"\n)\n\ntype Operator func(val interface{}, expected interface{}) (bool, error)\n\nvar opMap = map[string]Operator{\n\tEqualOp:       equal,\n\tNotEqualOp:    notEqual,\n\tContainsOp:    contain,\n\tNotContainsOp: notContain,\n}\n\nfunc AvailableOps() []string {\n\tvar ops []string\n\tfor op := range opMap {\n\t\tops = append(ops, op)\n\t}\n\treturn ops\n}\n\nfunc NewOperator(op string) (Operator, error) {\n\topFunc, ok := opMap[op]\n\tif !ok {\n\t\treturn nil, errors.New(\"operator not supported\")\n\t}\n\n\treturn opFunc, nil\n}\n\nfunc equal(val interface{}, expected interface{}) (bool, error) {\n\tif !reflect.DeepEqual(val, expected) {\n\t\treturn false, errors.New(fmt.Sprintf(\"expected equal %s, given %s\", expected, val))\n\t}\n\treturn true, nil\n}\n\nfunc notEqual(val interface{}, expected interface{}) (bool, error) {\n\tif reflect.DeepEqual(val, expected) {\n\t\treturn false, errors.New(fmt.Sprintf(\"expected not equal %s, given %s\", expected, val))\n\t}\n\treturn true, nil\n}\n\nfunc contain(val interface{}, expected interface{}) (bool, error) {\n\tvalStr := val.(string)\n\texpectedStr := expected.(string)\n\tif !strings.Contains(valStr, expectedStr) {\n\t\treturn false, errors.New(fmt.Sprintf(\"expected contain %s, given %s\", expected, val))\n\t}\n\treturn true, nil\n}\n\n\n\nfunc notContain(val interface{}, expected interface{}) (bool, error) ", "output": "{\n\tvalStr := val.(string)\n\texpectedStr := expected.(string)\n\tif strings.Contains(valStr, expectedStr) {\n\t\treturn false, errors.New(fmt.Sprintf(\"expected not contain %s, given %s\", expected, val))\n\t}\n\treturn true, nil\n}"}
{"input": "package request\n\nimport (\n\t\"fmt\"\n\n\t\"dchaykin/meetup_api/settings\"\n)\n\ntype EventAddressRequest struct {\n\tEventIDList string\n}\n\nconst EventPageSize = 100\n\nconst URL_EVENT_ADDRESS string = \"%s/2/events?key=%s&event_id=%s&status=upcoming,past&page=%d&sign=true\"\n\nfunc (request EventAddressRequest) WithOffset() bool {\n\treturn true\n}\n\n\n\nfunc (request EventAddressRequest) Address() string ", "output": "{\n\treturn fmt.Sprintf(URL_EVENT_ADDRESS, settings.BaseURL, settings.GetApiKey(), request.EventIDList, EventPageSize)\n}"}
{"input": "package b\n\nimport \"./a\"\n\n\n\nfunc Fp() {\n\ta.Fp()\n\ta.Fip()\n}\n\nfunc Gp() {\n\ta.Gp()\n\ta.Gip()\n}\n\nfunc Hp() {\n\ta.Hp()\n\ta.Hip()\n}\n\nfunc F() ", "output": "{\n\ta.F()\n\ta.Fi()\n}"}
{"input": "package main\n\n\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n\n\n\n\n\n\nfunc Variance(x []float64) float64 {\n\tvariance := 0.0\n\tn := len(x)\n\tif n == 0 {\n\t\treturn variance\n\t}\n\tmean := Mean(x)\n\tfor i := 0; i < n; i++ {\n\t\tvariance += (x[i] - mean) * (x[i] - mean)\n\t}\n\treturn variance / float64(n)\n}\n\n\nfunc Std(x []float64) float64 {\n\treturn math.Sqrt(Variance(x))\n}\n\nfunc main() {\n\tx := []float64{12, 65, 91, 52, 18, 72}\n\tfmt.Println(Std(x))\n}\n\nfunc Mean(x []float64) float64 ", "output": "{\n\tsum := 0.0\n\tn := len(x)\n\tif n == 0 {\n\t\treturn sum\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tsum = sum + x[i]\n\t}\n\treturn sum / float64(n)\n}"}
{"input": "package colonycore\n\nimport (\n\t\"errors\"\n\t\"github.com/eaciit/dbox\"\n\t_ \"github.com/eaciit/dbox/dbc/jsons\"\n\t\"github.com/eaciit/toolkit\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nvar ConfigPath string\n\nfunc validateConfig() error {\n\tif ConfigPath == \"\" {\n\t\treturn errors.New(\"gocore.validateConfig: ConfigPath is empty\")\n\t}\n\t_, e := os.Stat(ConfigPath)\n\tif e != nil {\n\t\treturn errors.New(\"gocore.validateConfig: \" + e.Error())\n\t}\n\treturn nil\n}\n\n\n\nfunc getConnection() (dbox.IConnection, error) {\n\tif e := validateConfig(); e != nil {\n\t\treturn nil, errors.New(\"gocore.GetConnection: \" + e.Error())\n\t}\n\n\tc, e := dbox.NewConnection(\"jsons\", &dbox.ConnectionInfo{ConfigPath, \"\", \"\", \"\", toolkit.M{}.Set(\"newfile\", true)})\n\tif e != nil {\n\t\treturn nil, errors.New(\"gocore.GetConnection: \" + e.Error())\n\t}\n\te = c.Connect()\n\tif e != nil {\n\t\treturn nil, errors.New(\"gocore.GetConnection: Connect: \" + e.Error())\n\t}\n\treturn c, nil\n}\n\nfunc getJsonFilePath(o interface{}) string ", "output": "{\n\ttns := strings.Split(strings.ToLower(toolkit.TypeName(o)), \".\")\n\tfn := tns[len(tns)-1] + \".json\"\n\treturn filepath.Join(ConfigPath, fn)\n}"}
{"input": "package nameref\n\nimport (\n\t\"fmt\"\n\n\t\"sigs.k8s.io/kustomize/kyaml/yaml\"\n)\n\ntype setFn func(*yaml.RNode) error\n\ntype seqFilter struct {\n\tsetScalarFn  setFn\n\tsetMappingFn setFn\n}\n\nfunc (sf seqFilter) Filter(node *yaml.RNode) (*yaml.RNode, error) {\n\tif yaml.IsMissingOrNull(node) {\n\t\treturn node, nil\n\t}\n\tswitch node.YNode().Kind {\n\tcase yaml.ScalarNode:\n\t\terr := sf.setScalarFn(node)\n\t\treturn node, err\n\tcase yaml.MappingNode:\n\t\terr := sf.setMappingFn(node)\n\t\treturn node, err\n\tdefault:\n\t\treturn node, fmt.Errorf(\n\t\t\t\"%#v is expected to be either a string or a map of string\", node)\n\t}\n}\n\n\n\n\nfunc applyFilterToSeq(filter yaml.Filter, node *yaml.RNode) error ", "output": "{\n\tif node.YNode().Kind != yaml.SequenceNode {\n\t\treturn fmt.Errorf(\"expect a sequence node but got %v\", node.YNode().Kind)\n\t}\n\n\tfor _, elem := range node.Content() {\n\t\trnode := yaml.NewRNode(elem)\n\t\terr := rnode.PipeE(filter)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}"}
{"input": "package logstash\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n\n\n\n\n\nfunc allFilesExist(dir string, filenames []string) bool {\n\tfor _, filename := range filenames {\n\t\tpath := filepath.Join(dir, filename)\n\t\tif _, err := os.Stat(path); err != nil {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc copyFile(sourcePath, destPath string) error {\n\tr, err := os.Open(sourcePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\tw, err := os.Create(destPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = io.Copy(w, r)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn w.Close()\n}\n\nfunc copyAllFiles(sourceDirs []string, sourceFiles []string, dest string) (string, error) ", "output": "{\n\tfor _, sourceDir := range sourceDirs {\n\t\tif !allFilesExist(sourceDir, sourceFiles) {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, sourceFile := range sourceFiles {\n\t\t\tsrcFile := filepath.Join(sourceDir, sourceFile)\n\t\t\tdestFile := filepath.Join(dest, sourceFile)\n\t\t\tif err := copyFile(srcFile, destFile); err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\t\treturn sourceDir, nil\n\t}\n\treturn \"\", fmt.Errorf(\"couldn't find the wanted files (%s) in any of these directories: %s\",\n\t\tstrings.Join(sourceFiles, \", \"), strings.Join(sourceDirs, \", \"))\n}"}
{"input": "package webclient\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype httpClient interface {\n\tGet(path string) ([]byte, error)\n}\n\ntype JSONClient struct {\n\tHTTPClient httpClient\n}\n\n\n\nfunc (c *JSONClient) Get(route string, responseData interface{}) error ", "output": "{\n\tresponseBody, err := c.HTTPClient.Get(route)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = json.Unmarshal(responseBody, &responseData)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"server returned malformed JSON: %s\", err)\n\t}\n\treturn nil\n}"}
{"input": "package dbutil\n\nimport (\n\t\"database/sql\"\n\t\"sync\"\n\n\t\"github.com/jmoiron/sqlx\"\n)\n\ntype SqlxMixin struct {\n\tDB                    *sqlx.DB\n\tsqlxPreparedStmtCache map[string]*sqlx.Stmt\n\tlock                  sync.RWMutex\n}\n\n\n\n\n\n\nfunc (db *SqlxMixin) GetOrPrepare(query string) (*sqlx.Stmt, error) {\n\tvar err error\n\n\tdb.lock.RLock()\n\tprepared, ok := db.sqlxPreparedStmtCache[query]\n\tdb.lock.RUnlock()\n\tif ok {\n\t\treturn prepared, nil\n\t}\n\n\tprepared, err = db.DB.Preparex(db.DB.Rebind(query))\n\n\tif err != nil {\n\t\treturn prepared, err\n\t}\n\tdb.lock.Lock()\n\tdb.sqlxPreparedStmtCache[query] = prepared\n\tdb.lock.Unlock()\n\treturn prepared, nil\n}\n\n\nfunc (db *SqlxMixin) Get(dest interface{}, query string, args ...interface{}) error {\n\tprep, err := db.GetOrPrepare(query)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn prep.Get(dest, args...)\n}\n\n\nfunc (db *SqlxMixin) Select(dest interface{}, query string, args ...interface{}) error {\n\tprep, err := db.GetOrPrepare(query)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn prep.Select(dest, args...)\n}\n\n\nfunc (db *SqlxMixin) Exec(query string, args ...interface{}) (sql.Result, error) {\n\tprep, err := db.GetOrPrepare(query)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn prep.Exec(args...)\n}\n\nfunc (db *SqlxMixin) InitSqlxMixin(sqldb *sqlx.DB) ", "output": "{\n\tdb.sqlxPreparedStmtCache = make(map[string]*sqlx.Stmt)\n\tdb.DB = sqldb\n}"}
{"input": "package fake\n\nimport (\n\tunversionedcore \"k8s.io/kubernetes/pkg/client/typed/generated/core/unversioned\"\n\tfakeunversionedcore \"k8s.io/kubernetes/pkg/client/typed/generated/core/unversioned/fake\"\n\tunversionedextensions \"k8s.io/kubernetes/pkg/client/typed/generated/extensions/unversioned\"\n\tfakeunversionedextensions \"k8s.io/kubernetes/pkg/client/typed/generated/extensions/unversioned/fake\"\n)\n\n\n\n\n\nfunc (c *Clientset) Extensions() unversionedextensions.ExtensionsInterface {\n\treturn &fakeunversionedextensions.FakeExtensions{&c.Fake}\n}\n\nfunc (c *Clientset) Core() unversionedcore.CoreInterface ", "output": "{\n\treturn &fakeunversionedcore.FakeCore{&c.Fake}\n}"}
{"input": "package commands\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/spf13/viper\"\n\t\"gopkg.in/mgo.v2\"\n\t\"gopkg.in/mgo.v2/bson\"\n)\n\nvar mongodbSession *mgo.Session\n\nfunc init() {\n\tCreateUniqueIndexes()\n}\n\nfunc DBSession() *mgo.Session {\n\tif mongodbSession == nil {\n\t\turi := os.Getenv(\"MONGODB_URI\")\n\t\tif uri == \"\" {\n\t\t\turi = viper.GetString(\"mongodb_uri\")\n\n\t\t\tif uri == \"\" {\n\t\t\t\tlog.Fatalln(\"No connection uri for MongoDB provided\")\n\t\t\t}\n\t\t}\n\n\t\tvar err error\n\t\tmongodbSession, err = mgo.Dial(uri)\n\t\tif mongodbSession == nil || err != nil {\n\t\t\tlog.Fatalf(\"Can't connect to mongo, go error %v\\n\", err)\n\t\t}\n\n\t\tmongodbSession.SetSafe(&mgo.Safe{})\n\t}\n\treturn mongodbSession\n}\n\nfunc Items() *mgo.Collection {\n\treturn DB().C(\"items\")\n}\n\nfunc Channels() *mgo.Collection {\n\treturn DB().C(\"channels\")\n}\n\nfunc DB() *mgo.Database {\n\treturn DBSession().DB(viper.GetString(\"dbname\"))\n}\n\n\n\nfunc AllChannels() []Chnl {\n\tvar channels []Chnl\n\tresults2 := Channels().Find(bson.M{}).Sort(\"-lastbuilddate\")\n\tresults2.All(&channels)\n\treturn channels\n}\n\nfunc CreateUniqueIndexes() ", "output": "{\n\tidx := mgo.Index{\n\t\tKey:        []string{\"key\"},\n\t\tUnique:     true,\n\t\tDropDups:   true,\n\t\tBackground: true,\n\t\tSparse:     true,\n\t}\n\n\tif err := Items().EnsureIndex(idx); err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tif err := Channels().EnsureIndex(idx); err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\tftidx := mgo.Index{\n\t\tKey:        []string{\"$text:fullcontent\"},\n\t\tUnique:     false,\n\t\tDropDups:   false,\n\t\tBackground: true,\n\t\tSparse:     true,\n\t}\n\n\tif err := Items().EnsureIndex(ftidx); err != nil {\n\t\tfmt.Println(err)\n\t}\n}"}
{"input": "package gutil\n\nimport (\n\t\"github.com/gogf/gf/v2/util/gconv\"\n\t\"reflect\"\n)\n\n\n\nfunc SliceCopy(data []interface{}) []interface{} {\n\tnewData := make([]interface{}, len(data))\n\tcopy(newData, data)\n\treturn newData\n}\n\n\n\nfunc SliceDelete(data []interface{}, index int) (newSlice []interface{}) {\n\tif index < 0 || index >= len(data) {\n\t\treturn data\n\t}\n\tif index == 0 {\n\t\treturn data[1:]\n\t} else if index == len(data)-1 {\n\t\treturn data[:index]\n\t}\n\treturn append(data[:index], data[index+1:]...)\n}\n\n\n\n\n\n\nfunc SliceToMap(slice interface{}) map[string]interface{} {\n\tvar (\n\t\treflectValue = reflect.ValueOf(slice)\n\t\treflectKind  = reflectValue.Kind()\n\t)\n\tfor reflectKind == reflect.Ptr {\n\t\treflectValue = reflectValue.Elem()\n\t\treflectKind = reflectValue.Kind()\n\t}\n\tswitch reflectKind {\n\tcase reflect.Slice, reflect.Array:\n\t\tlength := reflectValue.Len()\n\t\tif length%2 != 0 {\n\t\t\treturn nil\n\t\t}\n\t\tdata := make(map[string]interface{})\n\t\tfor i := 0; i < reflectValue.Len(); i += 2 {\n\t\t\tdata[gconv.String(reflectValue.Index(i).Interface())] = reflectValue.Index(i + 1).Interface()\n\t\t}\n\t\treturn data\n\t}\n\treturn nil\n}\n\n\n\n\n\n\n\n\nfunc SliceToMapWithColumnAsKey(slice interface{}, key interface{}) map[interface{}]interface{} ", "output": "{\n\tvar (\n\t\treflectValue = reflect.ValueOf(slice)\n\t\treflectKind  = reflectValue.Kind()\n\t)\n\tfor reflectKind == reflect.Ptr {\n\t\treflectValue = reflectValue.Elem()\n\t\treflectKind = reflectValue.Kind()\n\t}\n\tdata := make(map[interface{}]interface{})\n\tswitch reflectKind {\n\tcase reflect.Slice, reflect.Array:\n\t\tfor i := 0; i < reflectValue.Len(); i++ {\n\t\t\tif k, ok := ItemValue(reflectValue.Index(i), key); ok {\n\t\t\t\tdata[k] = reflectValue.Index(i).Interface()\n\t\t\t}\n\t\t}\n\t}\n\treturn data\n}"}
{"input": "package metrics\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\treportertest \"github.com/google/knative-gcp/pkg/metrics/testing\"\n\n\t\"knative.dev/pkg/metrics/metricskey\"\n\t\"knative.dev/pkg/metrics/metricstest\"\n)\n\n\n\nfunc TestReportLatency(t *testing.T) ", "output": "{\n\treportertest.ResetBrokerCellMetrics()\n\tr, err := NewBrokerCellLatencyReporter()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlatencySamples := []time.Duration{\n\t\t10 * time.Millisecond,\n\t\t100 * time.Millisecond,\n\t\t1000 * time.Millisecond,\n\t}\n\tfor _, latencySample := range latencySamples {\n\t\treportertest.ExpectMetrics(t, func() error {\n\t\t\tr.ReportLatency(context.Background(), latencySample, \"Trigger\", \"Test trigger\", \"TestNamespace\")\n\t\t\treturn nil\n\t\t})\n\t}\n\texpectedTags := map[string]string{\n\t\tlabelResourceKind:             \"Trigger\",\n\t\tlabelResourceName:             \"Test trigger\",\n\t\tmetricskey.LabelNamespaceName: \"TestNamespace\",\n\t}\n\tmetricstest.CheckDistributionData(t, LatencyMetricName, expectedTags, 3, 10.0, 1000.0)\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\t\"regexp\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n)\n\nvar (\n\tusers = []string{\"Joe\", \"Veer\", \"Zion\"}\n)\n\n\n\n\n\nfunc allowOrigin(origin string) (bool, error) {\n\treturn regexp.MatchString(`^https:\\/\\/labstack\\.(net|com)$`, origin)\n}\n\nfunc main() {\n\te := echo.New()\n\te.Use(middleware.Logger())\n\te.Use(middleware.Recover())\n\n\te.Use(middleware.CORSWithConfig(middleware.CORSConfig{\n\t\tAllowOriginFunc: allowOrigin,\n\t\tAllowMethods:    []string{http.MethodGet, http.MethodPut, http.MethodPost, http.MethodDelete},\n\t}))\n\n\te.GET(\"/api/users\", getUsers)\n\n\te.Logger.Fatal(e.Start(\":1323\"))\n}\n\nfunc getUsers(c echo.Context) error ", "output": "{\n\treturn c.JSON(http.StatusOK, users)\n}"}
{"input": "package testutil\n\nimport (\n\t\"testing\"\n\n\tci \"gx/ipfs/QmPGxZ1DP2w45WcogpW1h43BvseXbfke9N91qotpoQcUeS/go-libp2p-crypto\"\n\tma \"gx/ipfs/QmSWLfmj5frN9xVLMMN846dMDriy5wN5jeghUm7aTW3DAG/go-multiaddr\"\n\tpeer \"gx/ipfs/QmWUswjn261LSyVxWAEpMVtPdy8zmKBJJfBpG3Qdpa8ZsE/go-libp2p-peer\"\n)\n\ntype Identity interface {\n\tAddress() ma.Multiaddr\n\tID() peer.ID\n\tPrivateKey() ci.PrivKey\n\tPublicKey() ci.PubKey\n}\n\n\n\nfunc RandIdentity() (Identity, error) {\n\tp, err := RandPeerNetParams()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &identity{*p}, nil\n}\n\n\n\n\ntype identity struct {\n\tPeerNetParams\n}\n\nfunc (p *identity) ID() peer.ID {\n\treturn p.PeerNetParams.ID\n}\n\nfunc (p *identity) Address() ma.Multiaddr {\n\treturn p.Addr\n}\n\nfunc (p *identity) PrivateKey() ci.PrivKey {\n\treturn p.PrivKey\n}\n\nfunc (p *identity) PublicKey() ci.PubKey {\n\treturn p.PubKey\n}\n\nfunc RandIdentityOrFatal(t *testing.T) Identity ", "output": "{\n\tp, err := RandPeerNetParams()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn &identity{*p}\n}"}
{"input": "package goxpath\n\nimport (\n\txml \"encoding/xml\"\n)\n\ntype FuncOpts func(*Opts)\n\nfunc MustParse(_ string) XPathExec {\n\treturn XPathExec{}\n}\n\ntype Opts struct {\n\tNS    map[string]string\n\tFuncs map[xml.Name]interface{}\n\tVars  map[string]interface{}\n}\n\nfunc Parse(_ string) (XPathExec, error) {\n\treturn XPathExec{}, nil\n}\n\nfunc ParseExec(_ string, _ interface{}, _ ...FuncOpts) (interface{}, error) {\n\treturn nil, nil\n}\n\ntype XPathExec struct{}\n\n\n\nfunc (_ XPathExec) ExecBool(_ interface{}, _ ...FuncOpts) (bool, error) {\n\treturn false, nil\n}\n\nfunc (_ XPathExec) ExecNode(_ interface{}, _ ...FuncOpts) (interface{}, error) {\n\treturn nil, nil\n}\n\nfunc (_ XPathExec) ExecNum(_ interface{}, _ ...FuncOpts) (float64, error) {\n\treturn 0, nil\n}\n\nfunc (_ XPathExec) MustExec(_ interface{}, _ ...FuncOpts) interface{} {\n\treturn nil\n}\n\nfunc (_ XPathExec) Exec(_ interface{}, _ ...FuncOpts) (interface{}, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "package cgroups\n\nimport (\n\t\"github.com/containerd/cgroups\"\n\tv1 \"github.com/containerd/containerd/metrics/cgroups/v1\"\n\tv2 \"github.com/containerd/containerd/metrics/cgroups/v2\"\n\t\"github.com/containerd/containerd/platforms\"\n\t\"github.com/containerd/containerd/plugin\"\n\t\"github.com/containerd/containerd/runtime\"\n\tmetrics \"github.com/docker/go-metrics\"\n)\n\n\ntype Config struct {\n\tNoPrometheus bool `toml:\"no_prometheus\"`\n}\n\n\n\n\nfunc New(ic *plugin.InitContext) (interface{}, error) {\n\tvar ns *metrics.Namespace\n\tconfig := ic.Config.(*Config)\n\tif !config.NoPrometheus {\n\t\tns = metrics.NewNamespace(\"container\", \"\", nil)\n\t}\n\tvar (\n\t\ttm  runtime.TaskMonitor\n\t\terr error\n\t)\n\tif cgroups.Mode() == cgroups.Unified {\n\t\ttm, err = v2.NewTaskMonitor(ic.Context, ic.Events, ns)\n\t} else {\n\t\ttm, err = v1.NewTaskMonitor(ic.Context, ic.Events, ns)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif ns != nil {\n\t\tmetrics.Register(ns)\n\t}\n\tic.Meta.Platforms = append(ic.Meta.Platforms, platforms.DefaultSpec())\n\treturn tm, nil\n}\n\nfunc init() ", "output": "{\n\tplugin.Register(&plugin.Registration{\n\t\tType:   plugin.TaskMonitorPlugin,\n\t\tID:     \"cgroups\",\n\t\tInitFn: New,\n\t\tConfig: &Config{},\n\t})\n}"}
{"input": "package url\n\nimport (\n\t\"github.com/dpb587/metalink\"\n\t\"github.com/dpb587/metalink/file\"\n)\n\ntype MultiLoader struct {\n\tloaders []Loader\n}\n\nvar _ Loader = &MultiLoader{}\n\nfunc NewMultiLoader(loaders ...Loader) *MultiLoader {\n\treturn &MultiLoader{\n\t\tloaders: loaders,\n\t}\n}\n\nfunc (l *MultiLoader) SupportsURL(source metalink.URL) bool {\n\tfor _, loader := range l.loaders {\n\t\tif loader.SupportsURL(source) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n\n\nfunc (l *MultiLoader) Add(add Loader) {\n\tl.loaders = append(l.loaders, add)\n}\n\nfunc (l *MultiLoader) LoadURL(source metalink.URL) (file.Reference, error) ", "output": "{\n\tfor _, loader := range l.loaders {\n\t\tif !loader.SupportsURL(source) {\n\t\t\tcontinue\n\t\t}\n\n\t\tref, err := loader.LoadURL(source)\n\t\tif err == UnsupportedURLError {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn ref, err\n\t}\n\n\treturn nil, UnsupportedURLError\n}"}
{"input": "package main\n\nimport (\n\t\"exectime/timer\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc printError(e interface{}) {\n\tfmt.Printf(\"\\033[1;31m%v\\033[m\\n\", e)\n}\n\n\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tprintError(\"Add at least one argument!\")\n\t\treturn\n\t}\n\tf := func() {\n\t\tif e := launchCommand(os.Args[1], os.Args[2:]...); e != nil {\n\t\t\tprintError(e)\n\t\t}\n\t}\n\tt := timer.NewFunc(f)\n\tt.Exec()\n\tfmt.Println(t)\n}\n\nfunc launchCommand(name string, args ...string) error ", "output": "{\n\tcmd := exec.Command(name, args...)\n\tcmd.Stdin, cmd.Stdout, cmd.Stderr = os.Stdin, os.Stdout, os.Stderr\n\treturn cmd.Run()\n}"}
{"input": "package defaultsystem\n\nimport (\n\t\"os\"\n\n\t\"knative.dev/pkg/system\"\n)\n\n\n\nfunc init() ", "output": "{\n\tif ns := os.Getenv(system.NamespaceEnvKey); ns != \"\" {\n\t\treturn\n\t}\n\tos.Setenv(system.NamespaceEnvKey, \"knative-eventing\")\n}"}
{"input": "package hu\n\nimport \"strings\"\n\n\n\nfunc AddDefaultBindings(environment Environment) {\n\tenvironment.Define(\"true\", Boolean(true))\n\tenvironment.Define(\"false\", Boolean(false))\n\n\tAddPrimitive(environment, \"lambda\", lambda)\n\tAddPrimitive(environment, \"operator\", operator)\n\n\tAddPrimitive(environment, \"=\", is_number_equal_proc)\n\tAddPrimitive(environment, \"<\", is_less_than_proc)\n\tAddPrimitive(environment, \">\", is_greater_than_proc)\n\n\tAddPrimitive(environment, \"+\", add_numbers)\n\tenvironment.Define(\"add_numbers\", Primitive(add_numbersP))\n\tAddPrimitive(environment, \"concat\", add_lists)\n\n\tAddPrimitive(environment, \"-\", subtract_proc)\n\n\tAddPrimitive(environment, \"*\", multiply_proc)\n\n\tAddPrimitive(environment, \"define\", define)\n\tAddPrimitive(environment, \"variable\", variable)\n\tAddPrimitive(environment, \"set\", set)\n\tAddPrimitive(environment, \"get\", get)\n\tAddPrimitive(environment, \"begin\", begin)\n\tAddPrimitive(environment, \"if\", ifPrimitive)\n\tAddPrimitive(environment, \"and\", and)\n\tAddPrimitive(environment, \"or\", or)\n\tAddPrimitive(environment, \"apply\", apply)\n\tAddPrimitive(environment, \"eval\", evalPrimitive)\n\tAddPrimitive(environment, \"let\", let)\n\n\tEvaluate(environment, Read(strings.NewReader(`{define plus {operator ((lhs) (rhs)) {+ lhs rhs}}}\n{define plus_list_operator {operator (lhs rhs) {concat lhs rhs}}} {1 2 plus 3 4}}\n\t`)))\n}\n\nfunc AddPrimitive(environment Environment, name string, function PrimitiveFunction) ", "output": "{\n\tenvironment.Define(Symbol(name), function)\n}"}
{"input": "package jpsplus\n\nimport (\n\t\"container/heap\"\n)\n\ntype PriorityQueue struct {\n\tpos  int\n\tnode map[int]*Node\n}\n\nfunc newPriorityQueue() *PriorityQueue {\n\tp := new(PriorityQueue)\n\tp.node = make(map[int]*Node)\n\treturn p\n}\n\nfunc (p *PriorityQueue) Len() int {\n\treturn len(p.node)\n}\n\nfunc (p *PriorityQueue) Less(i, j int) bool {\n\treturn p.node[i].finalCost < p.node[j].finalCost\n}\n\nfunc (p *PriorityQueue) Swap(i, j int) {\n\tp.node[i], p.node[j] = p.node[j], p.node[i]\n\tp.node[i].heapIndex = i\n\tp.node[j].heapIndex = j\n}\n\n\n\nfunc (p *PriorityQueue) Pop() interface{} {\n\tp.pos--\n\titem := p.node[p.pos]\n\tdelete(p.node, p.pos)\n\treturn item\n}\n\nfunc (p *PriorityQueue) PushNode(n *Node) {\n\theap.Push(p, n)\n}\n\nfunc (p *PriorityQueue) PopNode() *Node {\n\treturn heap.Pop(p).(*Node)\n}\n\nfunc (p *PriorityQueue) RemoveNode(n *Node) {\n\theap.Remove(p, n.heapIndex)\n}\n\nfunc (p *PriorityQueue) Push(x interface{}) ", "output": "{\n\titem, ok := x.(*Node)\n\tif ok {\n\t\titem.heapIndex = p.pos\n\t\tp.node[p.pos] = item\n\t\tp.pos++\n\t}\n}"}
{"input": "package remote\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/golang/glog\"\n\t\"google.golang.org/grpc\"\n\n\truntimeapi \"k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1\"\n\t\"k8s.io/kubernetes/pkg/kubelet/dockershim\"\n\t\"k8s.io/kubernetes/pkg/kubelet/util\"\n\t\"k8s.io/kubernetes/pkg/util/interrupt\"\n)\n\n\ntype DockerServer struct {\n\tendpoint string\n\tservice DockerService\n\tserver *grpc.Server\n}\n\n\nfunc NewDockerServer(endpoint string, s dockershim.DockerService) *DockerServer {\n\treturn &DockerServer{\n\t\tendpoint: endpoint,\n\t\tservice:  NewDockerService(s),\n\t}\n}\n\n\nfunc (s *DockerServer) Start() error {\n\tglog.V(2).Infof(\"Start dockershim grpc server\")\n\tl, err := util.CreateListener(s.endpoint)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to listen on %q: %v\", s.endpoint, err)\n\t}\n\ts.server = grpc.NewServer()\n\truntimeapi.RegisterRuntimeServiceServer(s.server, s.service)\n\truntimeapi.RegisterImageServiceServer(s.server, s.service)\n\tgo func() {\n\t\th := interrupt.New(nil, s.Stop)\n\t\terr := h.Run(func() error { return s.server.Serve(l) })\n\t\tif err != nil {\n\t\t\tglog.Errorf(\"Failed to serve connections: %v\", err)\n\t\t}\n\t}()\n\treturn nil\n}\n\n\n\n\nfunc (s *DockerServer) Stop() ", "output": "{\n\tglog.V(2).Infof(\"Stop docker server\")\n\ts.server.Stop()\n}"}
{"input": "package hsm\n\nimport (\n\t\"github.com/intel-hpdd/go-lustre\"\n\t\"github.com/intel-hpdd/go-lustre/fs\"\n\t\"github.com/intel-hpdd/go-lustre/llapi\"\n)\n\n\n\nfunc RequestArchive(root fs.RootDir, archiveID uint, fids []*lustre.Fid) error {\n\treturn hsmRequest(root, llapi.HsmUserArchive, archiveID, fids)\n}\n\n\n\nfunc RequestRestore(root fs.RootDir, archiveID uint, fids []*lustre.Fid) error {\n\treturn hsmRequest(root, llapi.HsmUserRestore, archiveID, fids)\n}\n\n\n\nfunc RequestRelease(root fs.RootDir, archiveID uint, fids []*lustre.Fid) error {\n\treturn hsmRequest(root, llapi.HsmUserRelease, archiveID, fids)\n}\n\n\n\n\n\n\n\nfunc RequestCancel(root fs.RootDir, archiveID uint, fids []*lustre.Fid) error {\n\treturn hsmRequest(root, llapi.HsmUserCancel, archiveID, fids)\n}\n\nfunc hsmRequest(root fs.RootDir, cmd llapi.HsmUserAction, archiveID uint, fids []*lustre.Fid) error {\n\tif _, err := llapi.HsmRequest(root.Path(), cmd, archiveID, fids); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc RequestRemove(root fs.RootDir, archiveID uint, fids []*lustre.Fid) error ", "output": "{\n\treturn hsmRequest(root, llapi.HsmUserRemove, archiveID, fids)\n}"}
{"input": "package abcjson\n\nconst (\n\tAccountBalanceNtfnMethod = \"accountbalance\"\n\n\tBtcdConnectedNtfnMethod = \"abcdconnected\"\n\n\tWalletLockStateNtfnMethod = \"walletlockstate\"\n\n\tNewTxNtfnMethod = \"newtx\"\n)\n\n\ntype AccountBalanceNtfn struct {\n\tAccount   string\n\tBalance   float64 \n\tConfirmed bool    \n}\n\n\n\nfunc NewAccountBalanceNtfn(account string, balance float64, confirmed bool) *AccountBalanceNtfn {\n\treturn &AccountBalanceNtfn{\n\t\tAccount:   account,\n\t\tBalance:   balance,\n\t\tConfirmed: confirmed,\n\t}\n}\n\n\ntype BtcdConnectedNtfn struct {\n\tConnected bool\n}\n\n\n\n\n\n\ntype WalletLockStateNtfn struct {\n\tLocked bool\n}\n\n\n\nfunc NewWalletLockStateNtfn(locked bool) *WalletLockStateNtfn {\n\treturn &WalletLockStateNtfn{\n\t\tLocked: locked,\n\t}\n}\n\n\ntype NewTxNtfn struct {\n\tAccount string\n\tDetails ListTransactionsResult\n}\n\n\n\nfunc NewNewTxNtfn(account string, details ListTransactionsResult) *NewTxNtfn {\n\treturn &NewTxNtfn{\n\t\tAccount: account,\n\t\tDetails: details,\n\t}\n}\n\nfunc init() {\n\tflags := UFWalletOnly | UFWebsocketOnly | UFNotification\n\n\tMustRegisterCmd(AccountBalanceNtfnMethod, (*AccountBalanceNtfn)(nil), flags)\n\tMustRegisterCmd(BtcdConnectedNtfnMethod, (*BtcdConnectedNtfn)(nil), flags)\n\tMustRegisterCmd(WalletLockStateNtfnMethod, (*WalletLockStateNtfn)(nil), flags)\n\tMustRegisterCmd(NewTxNtfnMethod, (*NewTxNtfn)(nil), flags)\n}\n\nfunc NewBtcdConnectedNtfn(connected bool) *BtcdConnectedNtfn ", "output": "{\n\treturn &BtcdConnectedNtfn{\n\t\tConnected: connected,\n\t}\n}"}
{"input": "package iso20022\n\n\ntype UnitOrFaceAmountOrCode1Choice struct {\n\n\tUnit *DecimalNumber `xml:\"Unit\"`\n\n\tFaceAmount *ActiveCurrencyAndAmount `xml:\"FaceAmt\"`\n\n\tCode *Quantity1Code `xml:\"Cd\"`\n}\n\nfunc (u *UnitOrFaceAmountOrCode1Choice) SetUnit(value string) {\n\tu.Unit = (*DecimalNumber)(&value)\n}\n\nfunc (u *UnitOrFaceAmountOrCode1Choice) SetFaceAmount(value, currency string) {\n\tu.FaceAmount = NewActiveCurrencyAndAmount(value, currency)\n}\n\n\n\nfunc (u *UnitOrFaceAmountOrCode1Choice) SetCode(value string) ", "output": "{\n\tu.Code = (*Quantity1Code)(&value)\n}"}
{"input": "package elastic\n\n\n\n\n\n\n\n\n\ntype MissingAggregation struct {\n\tfield           string\n\tsubAggregations map[string]Aggregation\n\tmeta            map[string]interface{}\n}\n\nfunc NewMissingAggregation() *MissingAggregation {\n\treturn &MissingAggregation{\n\t\tsubAggregations: make(map[string]Aggregation),\n\t}\n}\n\n\n\nfunc (a *MissingAggregation) SubAggregation(name string, subAggregation Aggregation) *MissingAggregation {\n\ta.subAggregations[name] = subAggregation\n\treturn a\n}\n\n\nfunc (a *MissingAggregation) Meta(metaData map[string]interface{}) *MissingAggregation {\n\ta.meta = metaData\n\treturn a\n}\n\nfunc (a *MissingAggregation) Source() (interface{}, error) {\n\n\tsource := make(map[string]interface{})\n\topts := make(map[string]interface{})\n\tsource[\"missing\"] = opts\n\n\tif a.field != \"\" {\n\t\topts[\"field\"] = a.field\n\t}\n\n\tif len(a.subAggregations) > 0 {\n\t\taggsMap := make(map[string]interface{})\n\t\tsource[\"aggregations\"] = aggsMap\n\t\tfor name, aggregate := range a.subAggregations {\n\t\t\tsrc, err := aggregate.Source()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\taggsMap[name] = src\n\t\t}\n\t}\n\n\tif len(a.meta) > 0 {\n\t\tsource[\"meta\"] = a.meta\n\t}\n\n\treturn source, nil\n}\n\nfunc (a *MissingAggregation) Field(field string) *MissingAggregation ", "output": "{\n\ta.field = field\n\treturn a\n}"}
{"input": "package configfiles\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\n\t\"k8s.io/apimachinery/pkg/runtime/serializer\"\n\t\"k8s.io/kubernetes/pkg/kubelet/apis/kubeletconfig\"\n\tkubeletscheme \"k8s.io/kubernetes/pkg/kubelet/apis/kubeletconfig/scheme\"\n\tutilcodec \"k8s.io/kubernetes/pkg/kubelet/kubeletconfig/util/codec\"\n\tutilfs \"k8s.io/kubernetes/pkg/util/filesystem\"\n)\n\nconst kubeletFile = \"kubelet\"\n\n\ntype Loader interface {\n\tLoad() (*kubeletconfig.KubeletConfiguration, error)\n}\n\n\ntype fsLoader struct {\n\tfs utilfs.Filesystem\n\tkubeletCodecs *serializer.CodecFactory\n\tconfigDir string\n}\n\n\n\n\nfunc (loader *fsLoader) Load() (*kubeletconfig.KubeletConfiguration, error) {\n\tpath := filepath.Join(loader.configDir, kubeletFile)\n\tdata, err := loader.fs.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read init config file %q, error: %v\", path, err)\n\t}\n\n\tif len(data) == 0 {\n\t\treturn nil, fmt.Errorf(\"init config file %q was empty, but some parameters are required\", path)\n\t}\n\n\tkc, err := utilcodec.DecodeKubeletConfiguration(loader.kubeletCodecs, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresolveRelativePaths(kubeletconfig.KubeletConfigurationPathRefs(kc), loader.configDir)\n\treturn kc, nil\n}\n\n\nfunc resolveRelativePaths(paths []*string, root string) {\n\tfor _, path := range paths {\n\t\tif len(*path) > 0 && !filepath.IsAbs(*path) {\n\t\t\t*path = filepath.Join(root, *path)\n\t\t}\n\t}\n}\n\nfunc NewFsLoader(fs utilfs.Filesystem, configDir string) (Loader, error) ", "output": "{\n\t_, kubeletCodecs, err := kubeletscheme.NewSchemeAndCodecs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &fsLoader{\n\t\tfs:            fs,\n\t\tkubeletCodecs: kubeletCodecs,\n\t\tconfigDir:     configDir,\n\t}, nil\n}"}
{"input": "package domain\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nconst (\n\tNameRegex = \"^[A-Za-z0-9]+$\"\n\tURLRegex  = `^((ftp|http|https):\\/\\/)?(\\S+(:\\S*)?@)?((([1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(\\.(1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.([0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|((www\\.)?)?(([a-z\\x{00a1}-\\x{ffff}0-9]+-?-?_?)*[a-z\\x{00a1}-\\x{ffff}0-9]+)(?:\\.([a-z\\x{00a1}-\\x{ffff}]{2,}))?)|localhost)(:(\\d{1,5}))?((\\/|\\?|#)[^\\s]*)?$`\n\n\tNOT_FOUND_ERROR = \"not found\"\n\tMALFORMED_ERROR = \"malformed\"\n)\n\ntype NamesRepository interface {\n\tGet(name Name) (URL, error)\n\tPut(name Name, url URL) error\n\tDeleteAll() error\n}\n\nvar (\n\tnameRegex *regexp.Regexp\n\turlRegex  *regexp.Regexp\n)\n\nfunc init() {\n\tnameRegex = regexp.MustCompile(NameRegex)\n\tnameRegex.Longest()\n\n\turlRegex = regexp.MustCompile(URLRegex)\n}\n\ntype Validator interface {\n\tValidate() error\n}\n\ntype Name string\n\n\n\ntype URL string\n\nfunc (t URL) Validate() error {\n\n\tif len(t) == 0 {\n\t\treturn fmt.Errorf(\"malformed url\")\n\t}\n\n\tif !urlRegex.MatchString(string(t)) {\n\t\treturn fmt.Errorf(\"malformed url [%s]\", t)\n\t}\n\treturn nil\n}\n\nfunc (t Name) Validate() error ", "output": "{\n\n\tif len(t) == 0 {\n\t\treturn fmt.Errorf(\"malformed name\")\n\t}\n\n\tif !nameRegex.MatchString(string(t)) {\n\t\treturn fmt.Errorf(\"malformed name [%s]\", t)\n\t}\n\n\treturn nil\n}"}
{"input": "package main\n\nimport \"net/http\"\n\n\n\n\ntype Action func(rw http.ResponseWriter, r *http.Request) error\n\n\ntype AppController struct{}\n\n\n\n\n\n\nfunc (c *AppController) Action(a Action) http.HandlerFunc ", "output": "{\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif err := a(w, r); err != nil {\n\t\t\thttp.Error(w, err.Error(), 500)\n\t\t}\n\t})\n}"}
{"input": "package comparisons\n\nimport \"jvmgo/ch07/instructions/base\"\nimport \"jvmgo/ch07/rtda\"\n\n\ntype LCMP struct{ base.NoOperandsInstruction }\n\n\n\nfunc (self *LCMP) Execute(frame *rtda.Frame) ", "output": "{\n\tstack := frame.OperandStack()\n\tv2 := stack.PopLong()\n\tv1 := stack.PopLong()\n\tif v1 > v2 {\n\t\tstack.PushInt(1)\n\t} else if v1 == v2 {\n\t\tstack.PushInt(0)\n\t} else {\n\t\tstack.PushInt(-1)\n\t}\n}"}
{"input": "package cli\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"testing\"\n\n\tc \"github.com/opensds/opensds/client\"\n)\n\nfunc init() {\n\tclient = c.NewFakeClient(&c.Config{Endpoint: c.TestEp})\n}\n\n\n\nfunc TestFileShareSnapshotCreateAction(t *testing.T) {\n\tvar args []string\n\targs = append(args, \"bd5b12a8-a101-11e7-941e-d77981b584d8\")\n\tfileShareSnapshotCreateAction(fileShareSnapshotCreateCommand, args)\n}\n\nfunc TestFileShareSnapshotShowAction(t *testing.T) {\n\tvar args []string\n\targs = append(args, \"3769855c-a102-11e7-b772-17b880d2f537\")\n\tfileShareSnapshotShowAction(fileShareSnapshotShowCommand, args)\n}\n\nfunc TestFileShareSnapshotListAction(t *testing.T) {\n\tvar args []string\n\tfileShareSnapshotListAction(fileShareSnapshotListCommand, args)\n}\n\nfunc TestFileShareSnapshotDeleteAction(t *testing.T) {\n\tvar args []string\n\targs = append(args, \"3769855c-a102-11e7-b772-17b880d2f537\")\n\tfileShareSnapshotDeleteAction(fileShareSnapshotDeleteCommand, args)\n}\n\nfunc TestFileShareSnapshotUpdateAction(t *testing.T) {\n\tvar args []string\n\targs = append(args, \"3769855c-a102-11e7-b772-17b880d2f537\")\n\tfileShareSnapshotUpdateAction(fileShareSnapshotDeleteCommand, args)\n}\n\nfunc TestFileShareSnapshotAction(t *testing.T) ", "output": "{\n\tbeCrasher := os.Getenv(\"BE_CRASHER\")\n\n\tif beCrasher == \"1\" {\n\t\tvar args []string\n\t\tfileShareSnapshotAction(fileShareSnapshotCommand, args)\n\n\t\treturn\n\t}\n\n\tcmd := exec.Command(os.Args[0], \"-test.run=TestFileShareSnapshotAction\")\n\tcmd.Env = append(os.Environ(), \"BE_CRASHER=1\")\n\terr := cmd.Run()\n\te, ok := err.(*exec.ExitError)\n\n\tif ok && (\"exit status 1\" == e.Error()) {\n\t\treturn\n\t}\n\n\tt.Fatalf(\"process ran with %s, want exit status 1\", e.Error())\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\t\"text/template\"\n)\n\nfunc init() {\n\thttp.Handle(\"/view\", appHandler(viewRecord))\n}\n\n\n\nfunc viewRecord(w http.ResponseWriter, r *http.Request) error {\n\tc := appengine.NewContext(r)\n\tkey := datastore.NewKey(c, \"Record\", r.FormValue(\"id\"), 0, nil)\n\trecord := new(Record)\n\tif err := datastore.Get(c, key, record); err != nil {\n\t\treturn err\n\t}\n\treturn viewTemplate.Execute(w, record)\n}\n\n\n\ntype appHandler func(http.ResponseWriter, *http.Request) error\n\nfunc (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif err := fn(w, r); err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t}\n}\n\n\n\ntype ap struct{}\n\n\n\ntype ctx struct{}\n\nfunc (*ctx) Errorf(string, ...interface{}) {}\n\nvar appengine ap\n\ntype ds struct{}\n\nfunc (ds) NewKey(*ctx, string, string, int, *int) string { return \"\" }\nfunc (ds) Get(*ctx, string, *Record) error               { return nil }\n\nvar datastore ds\n\ntype Record struct{}\n\nvar viewTemplate *template.Template\n\nfunc main() {}\n\nfunc (ap) NewContext(*http.Request) *ctx ", "output": "{ return nil }"}
{"input": "package jack\n\nimport \"C\"\nimport \"unsafe\"\n\ntype ProcessCallback func(uint32) int\ntype BufferSizeCallback func(uint32) int\ntype SampleRateCallback func(uint32) int\ntype PortRegistrationCallback func(PortId, bool)\ntype PortRenameCallback func(PortId, string, string) int\ntype PortConnectCallback func(PortId, PortId, bool)\ntype ShutdownCallback func()\n\n\nfunc goProcess(nframes uint, wrapper unsafe.Pointer) int {\n\tcallback := (*ProcessCallback)(wrapper)\n\treturn (*callback)(uint32(nframes))\n}\n\n\nfunc goBufferSize(nframes uint, wrapper unsafe.Pointer) int {\n\tcallback := (*BufferSizeCallback)(wrapper)\n\treturn (*callback)(uint32(nframes))\n}\n\n\nfunc goSampleRate(nframes uint, wrapper unsafe.Pointer) int {\n\tcallback := (*SampleRateCallback)(wrapper)\n\treturn (*callback)(uint32(nframes))\n}\n\n\nfunc goPortRegistration(port uint, register int, wrapper unsafe.Pointer) {\n\tcallback := (*PortRegistrationCallback)(wrapper)\n\t(*callback)(PortId(port), register != 0)\n}\n\n\nfunc goPortRename(port uint, oldName, newName *C.char, wrapper unsafe.Pointer) int {\n\tcallback := (*PortRenameCallback)(wrapper)\n\treturn (*callback)(PortId(port), C.GoString(oldName), C.GoString(newName))\n}\n\n\nfunc goPortConnect(aport, bport uint, connect int, wrapper unsafe.Pointer) {\n\tcallback := (*PortConnectCallback)(wrapper)\n\t(*callback)(PortId(aport), PortId(bport), connect != 0)\n}\n\n\n\n\nfunc goShutdown(wrapper unsafe.Pointer) ", "output": "{\n\tcallback := (*ShutdownCallback)(wrapper)\n\t(*callback)()\n}"}
{"input": "package ast\n\nimport (\n  \"fmt\"\n  \"github.com/kedebug/LispEx/binder\"\n  \"github.com/kedebug/LispEx/constants\"\n  \"github.com/kedebug/LispEx/scope\"\n  . \"github.com/kedebug/LispEx/value\"\n)\n\ntype Set struct {\n  Pattern *Name\n  Value   Node\n}\n\nfunc NewSet(pattern *Name, val Node) *Set {\n  return &Set{Pattern: pattern, Value: val}\n}\n\n\n\nfunc (self *Set) String() string {\n  return fmt.Sprintf(\"(%s %s %s)\", constants.SET, self.Pattern, self.Value)\n}\n\nfunc (self *Set) Eval(env *scope.Scope) Value ", "output": "{\n  val := self.Value.Eval(env)\n  binder.Assign(env, self.Pattern.Identifier, val)\n  return nil\n}"}
{"input": "package core\n\nimport (\n\t\"net\"\n\t\"strconv\"\n)\n\nconst (\n\tAddrTypeIP     = byte(0x01)\n\tAddrTypeDomain = byte(0x03)\n)\n\ntype VAddress struct {\n\tType   byte\n\tIP     net.IP\n\tDomain string\n\tPort   uint16\n}\n\nfunc IPAddress(ip []byte, port uint16) VAddress {\n\treturn VAddress{\n\t\tAddrTypeIP,\n\t\tnet.IP(ip),\n\t\t\"\",\n\t\tport}\n}\n\nfunc DomainAddress(domain string, port uint16) VAddress {\n\treturn VAddress{\n\t\tAddrTypeDomain,\n\t\tnil,\n\t\tdomain,\n\t\tport}\n}\n\nfunc (addr VAddress) IsIPv4() bool {\n\treturn addr.Type == AddrTypeIP && len(addr.IP) == net.IPv4len\n}\n\n\n\nfunc (addr VAddress) IsDomain() bool {\n\treturn addr.Type == AddrTypeDomain\n}\n\nfunc (addr VAddress) String() string {\n\tvar host string\n\tswitch addr.Type {\n\tcase AddrTypeIP:\n\t\thost = addr.IP.String()\n\t\tif len(addr.IP) == net.IPv6len {\n\t\t\thost = \"[\" + host + \"]\"\n\t\t}\n\n\tcase AddrTypeDomain:\n\t\thost = addr.Domain\n\tdefault:\n\t\tpanic(\"Unknown Address Type \" + strconv.Itoa(int(addr.Type)))\n\t}\n\treturn host + \":\" + strconv.Itoa(int(addr.Port))\n}\n\nfunc (addr VAddress) IsIPv6() bool ", "output": "{\n\treturn addr.Type == AddrTypeIP && len(addr.IP) == net.IPv6len\n}"}
{"input": "package stringcmap\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestJSON(t *testing.T) {\n\tcm := New()\n\tfor i := 0; i < 100; i++ {\n\t\tsi := strconv.Itoa(i)\n\t\tcm.Set(si, si)\n\t}\n\n\tj, err := json.Marshal(cm)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar mwj MapWithJSON\n\n\tif err = json.Unmarshal(j, &mwj); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tokeys, nkeys := cm.Keys(), mwj.Keys()\n\n\tsort.Strings(okeys)\n\tsort.Strings(nkeys)\n\n\tif !reflect.DeepEqual(okeys, nkeys) {\n\t\tt.Fatal(\"!reflect.DeepEqual(okeys, nkeys)\")\n\t}\n}\n\n\n\nfunc TestJSONType(t *testing.T) ", "output": "{\n\tcm := New()\n\tcm.Set(\"1\", uint64(1))\n\n\tj, err := json.Marshal(cm)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar mwj MapWithJSON\n\tmwj.UnmarshalValueFn = func(j json.RawMessage) (interface{}, error) {\n\t\tvar u uint64\n\t\terr = json.Unmarshal(j, &u)\n\t\treturn u, err\n\t}\n\n\tif err = json.Unmarshal(j, &mwj); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor kv := range cm.Iter(context.Background(), 0) {\n\t\tif v, ok := kv.Value.(uint64); !ok || kv.Key != \"1\" || v != 1 {\n\t\t\tt.Fatalf(\"bad kv: %#+v\", kv)\n\t\t}\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/wtolson/go-taglib\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\ntype Track struct {\n\tTitle  string\n\tArtist string\n\tAlbum  string\n\tExt    string\n\tNumber int\n\tPath   string\n}\n\n\n\n\n\nfunc (t Track) TransferTo(dir string) error {\n\tdst := assemblePath(dir, t)\n\tif err := os.MkdirAll(filepath.Dir(dst), 0777); err != nil {\n\t\tlog.Fatal(\"can't create \" + filepath.Dir(dst) + \"dir\")\n\t\treturn err\n\t}\n\tif err := copy(t.Path, dst); err != nil {\n\t\tlog.Fatal(\"can't copy \" + t.Path + \" to \" + dst)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc assemblePath(dir string, t Track) string {\n\treturn fmt.Sprintf(\"%s/%s/%s/%02d-%s%s\", dir, t.Artist, t.Album, t.Number, t.Title, t.Ext)\n}\n\nfunc copy(src, dst string) error {\n\ts, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer s.Close()\n\td, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.Copy(d, s); err != nil {\n\t\td.Close()\n\t\treturn err\n\t}\n\treturn d.Close()\n}\n\nfunc NewTrack(fileName string) (Track, error) ", "output": "{\n\tf, err := taglib.Read(fileName)\n\tif err != nil {\n\t\tlog.Fatal(\"can't \" + fileName + \" file read\")\n\t\treturn Track{}, err\n\t}\n\n\tfileAbsPath, err := filepath.Abs(fileName)\n\tif err != nil {\n\t\tlog.Fatal(\"can't get \" + fileName + \"absolute file path\")\n\t\treturn Track{}, err\n\t}\n\n\tt := Track{\n\t\tTitle:  f.Title(),\n\t\tArtist: f.Artist(),\n\t\tAlbum:  f.Album(),\n\t\tNumber: f.Track(),\n\t\tExt:    filepath.Ext(fileName),\n\t\tPath:   fileAbsPath,\n\t}\n\n\treturn t, nil\n}"}
{"input": "package events\n\nimport (\n\t\"errors\"\n\n\t\"github.com/miketheprogrammer/go-thrust/lib/commands\"\n\t\"github.com/miketheprogrammer/go-thrust/lib/dispatcher\"\n)\n\n\n\n\n\ntype Handler interface {\n\tHandle(cr commands.CommandResponse)\n\tRegister()\n\tSetHandleFunc(fn interface{})\n}\n\ntype ThrustEventHandler struct {\n\tType    string\n\tEvent   string\n\tHandler interface{}\n}\n\nfunc (teh ThrustEventHandler) Handle(cr commands.CommandResponse) {\n\tif cr.Action != \"event\" {\n\t\treturn\n\t}\n\tif cr.Type != teh.Event && teh.Event != \"*\" {\n\t\treturn\n\t}\n\tcr.Event.Type = cr.Type\n\tif fn, ok := teh.Handler.(func(commands.CommandResponse)); ok == true {\n\t\tfn(cr)\n\t\treturn\n\t}\n\tif fn, ok := teh.Handler.(func(commands.EventResult)); ok == true {\n\t\tfn(cr.Event)\n\t\treturn\n\t}\n}\n\nfunc (teh *ThrustEventHandler) SetHandleFunc(fn interface{}) error {\n\tif fn, ok := fn.(func(commands.CommandResponse)); ok == true {\n\t\tteh.Handler = fn\n\t\treturn nil\n\t}\n\tif fn, ok := fn.(func(commands.EventResult)); ok == true {\n\t\tteh.Handler = fn\n\t\treturn nil\n\t}\n\n\treturn errors.New(\"Invalid Handler Definition\")\n}\n\nfunc NewHandler(event string, fn interface{}) (ThrustEventHandler, error) ", "output": "{\n\th := ThrustEventHandler{}\n\th.Event = event\n\th.Type = \"event\"\n\terr := h.SetHandleFunc(fn)\n\tdispatcher.RegisterHandler(h)\n\treturn h, err\n}"}
{"input": "package orm\n\nimport (\n\t\"time\"\n)\n\nfunc String(s string) *string {\n\treturn &s\n}\n\nfunc Int(i int) *int {\n\treturn &i\n}\n\nfunc Int8(i int8) *int8 {\n\treturn &i\n}\n\nfunc Int16(i int16) *int16 {\n\treturn &i\n}\n\nfunc Int32(i int32) *int32 {\n\treturn &i\n}\n\nfunc Int64(i int64) *int64 {\n\treturn &i\n}\n\nfunc Bool(b bool) *bool {\n\treturn &b\n}\n\nfunc Byte(b byte) *byte {\n\treturn &b\n}\n\nfunc Float32(f float32) *float32 {\n\treturn &f\n}\n\nfunc Float64(f float64) *float64 {\n\treturn &f\n}\n\nfunc Rune(r rune) *rune {\n\treturn &r\n}\n\nfunc Uint(u uint) *uint {\n\treturn &u\n}\n\nfunc Uint8(u uint8) *uint8 {\n\treturn &u\n}\n\n\n\nfunc Uint32(u uint32) *uint32 {\n\treturn &u\n}\n\nfunc Uint64(u uint64) *uint64 {\n\treturn &u\n}\n\nfunc Is(b *bool) bool {\n\treturn b != nil && *b\n}\n\nfunc Time(t time.Time) *time.Time {\n\treturn &t\n}\n\nfunc Duration(d time.Duration) *time.Duration {\n\treturn &d\n}\n\nfunc Uint16(u uint16) *uint16 ", "output": "{\n\treturn &u\n}"}
{"input": "package server\n\nimport (\n\t\"github.com/labstack/echo\"\n\t\"net/http\"\n)\n\n\n\nfunc (s *Server) Githook(c echo.Context) error ", "output": "{\n\treturn c.String(http.StatusOK, \"Hello, World!\")\n}"}
{"input": "package logger\n\n\n\n\n\nimport (\n\t\"log\"\n\t\"log/syslog\"\n)\n\n\n\n\n\n\n\ntype SysLogger struct {\n\twriter *syslog.Writer\n}\n\n\n\nfunc NewSysLogger(tag string) (Logger, error) {\n\twriter, err := syslog.New(syslog.LOG_DEBUG|syslog.LOG_LOCAL0, tag)\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot init syslog: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn &SysLogger{writer}, nil\n}\n\n\nfunc (sl *SysLogger) Debug(info, msg string) {\n\tsl.writer.Debug(info + \" \" + msg)\n}\n\n\nfunc (sl *SysLogger) Info(info, msg string) {\n\tsl.writer.Info(info + \" \" + msg)\n}\n\n\nfunc (sl *SysLogger) Warning(info, msg string) {\n\tsl.writer.Warning(info + \" \" + msg)\n}\n\n\n\n\n\nfunc (sl *SysLogger) Critical(info, msg string) {\n\tsl.writer.Crit(info + \" \" + msg)\n}\n\n\nfunc (sl *SysLogger) Fatal(info, msg string) {\n\tsl.writer.Emerg(info + \" \" + msg)\n}\n\nfunc (sl *SysLogger) Error(info, msg string) ", "output": "{\n\tsl.writer.Err(info + \" \" + msg)\n}"}
{"input": "package exif\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n)\n\n\n\n\n\nfunc toInt16(bo binary.ByteOrder, buf []byte) int16 {\n\tvar i int16\n\tb := bytes.NewReader(buf)\n\terr := binary.Read(b, bo, &i)\n\tif err != nil {\n\t\tfmt.Println(\"binary.Read failed:\", err)\n\t}\n\treturn i\n}\n\n\nfunc toUint32(bo binary.ByteOrder, buf []byte) uint32 {\n\tvar i uint32\n\tb := bytes.NewReader(buf)\n\terr := binary.Read(b, bo, &i)\n\tif err != nil {\n\t\tfmt.Println(\"binary.Read failed:\", err)\n\t}\n\treturn i\n}\n\n\nfunc toInt32(bo binary.ByteOrder, buf []byte) int32 {\n\tvar i int32\n\tb := bytes.NewReader(buf)\n\terr := binary.Read(b, bo, &i)\n\tif err != nil {\n\t\tfmt.Println(\"binary.Read failed:\", err)\n\t}\n\treturn i\n}\n\nfunc toUint16(bo binary.ByteOrder, buf []byte) uint16 ", "output": "{\n\tvar i uint16\n\tb := bytes.NewReader(buf)\n\terr := binary.Read(b, bo, &i)\n\tif err != nil {\n\t\tfmt.Println(\"binary.Read failed:\", err)\n\t}\n\treturn i\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/veandco/go-sdl2/sdl\"\n\t\"lsystem/turt\"\n)\n\ntype SiriTriangle struct {\n\tcur []Symbol\n\tpen *turt.Turtle\n}\n\nfunc NewSiriTriangle() *SiriTriangle {\n\treturn &SiriTriangle{\n\t\tcur: []Symbol{F, Minus, G, Minus, G},\n\t\tpen: turt.NewTurtle(300, 200, 10),\n\t}\n}\n\nfunc (s *SiriTriangle) currentSymbolSet() []Symbol {\n\treturn s.cur\n}\n\nfunc (st *SiriTriangle) setCurrentSymbolSet(s []Symbol) {\n\tst.cur = s\n}\n\nfunc (st *SiriTriangle) applyDrawRule(s Symbol, surf *sdl.Surface) {\n\tswitch s {\n\tcase F, G:\n\t\tst.pen.Forward()\n\t\trect := sdl.Rect{int32(st.pen.Location.X), int32(st.pen.Location.Y), 1, 1}\n\t\tsurf.FillRect(&rect, 0xffff0000)\n\tcase Minus:\n\t\tst.pen.Turn(turt.RIGHT, 120)\n\tcase Plus:\n\t\tst.pen.Turn(turt.LEFT, 120)\n\tdefault:\n\t\treturn\n\t}\n}\n\n\n\nfunc (st *SiriTriangle) applyRule(s Symbol) []Symbol {\n\tswitch s {\n\tcase F:\n\t\treturn []Symbol{F, Minus, G, Plus, F, Plus, G, Minus, F}\n\tcase G:\n\t\treturn []Symbol{G, G}\n\tcase Minus:\n\t\treturn []Symbol{Minus}\n\tcase Plus:\n\t\treturn []Symbol{Plus}\n\tdefault:\n\t\treturn []Symbol{s}\n\t}\n}\n\n\n\n\n\n\n\nfunc (st *SiriTriangle) String() string ", "output": "{\n\tvar s string\n\tbod := st.currentSymbolSet()\n\tlbod := len(bod)\n\tfor i := 0; i < lbod; i++ {\n\t\tsym := bod[i]\n\t\tswitch sym {\n\t\tcase F:\n\t\t\ts += \"F \"\n\t\tcase G:\n\t\t\ts += \"G \"\n\t\tcase Minus:\n\t\t\ts += \"Minus \"\n\t\tcase Plus:\n\t\t\ts += \"Plus \"\n\t\t}\n\t}\n\treturn s\n}"}
{"input": "package model\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/huaweicloud/huaweicloud-sdk-go-v3/core/converter\"\n\t\"strings\"\n)\n\n\ntype CreateScalingTagsRequestBody struct {\n\tTags *[]TagsSingleValue `json:\"tags,omitempty\"`\n\tAction *CreateScalingTagsRequestBodyAction `json:\"action,omitempty\"`\n}\n\n\n\ntype CreateScalingTagsRequestBodyAction struct {\n\tvalue string\n}\n\ntype CreateScalingTagsRequestBodyActionEnum struct {\n\tCREATE CreateScalingTagsRequestBodyAction\n}\n\nfunc GetCreateScalingTagsRequestBodyActionEnum() CreateScalingTagsRequestBodyActionEnum {\n\treturn CreateScalingTagsRequestBodyActionEnum{\n\t\tCREATE: CreateScalingTagsRequestBodyAction{\n\t\t\tvalue: \"create\",\n\t\t},\n\t}\n}\n\nfunc (c CreateScalingTagsRequestBodyAction) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(c.value)\n}\n\nfunc (c *CreateScalingTagsRequestBodyAction) UnmarshalJSON(b []byte) error {\n\tmyConverter := converter.StringConverterFactory(\"string\")\n\tif myConverter != nil {\n\t\tval, err := myConverter.CovertStringToInterface(strings.Trim(string(b[:]), \"\\\"\"))\n\t\tif err == nil {\n\t\t\tc.value = val.(string)\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t} else {\n\t\treturn errors.New(\"convert enum data to string error\")\n\t}\n}\n\nfunc (o CreateScalingTagsRequestBody) String() string ", "output": "{\n\tdata, _ := json.Marshal(o)\n\treturn strings.Join([]string{\"CreateScalingTagsRequestBody\", string(data)}, \" \")\n}"}
{"input": "package yaormfilter\n\n\ntype NilFilter struct {\n\tvaluefilterimpl\n}\n\n\nfunc NewNilFilter() ValueFilter {\n\treturn &NilFilter{}\n}\n\n\nfunc (f *NilFilter) Equals(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) NotEquals(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Like(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) ILike(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Nil(v bool) ValueFilter {\n\tf.nil(v)\n\treturn f\n\n}\n\n\nfunc (f *NilFilter) In(values ...interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) NotIn(values ...interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Lt(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Lte(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Gt(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Gte(v interface{}) ValueFilter {\n\treturn f\n}\n\n\n\n\nfunc (f *NilFilter) Raw(s RawFilterFunc) ValueFilter ", "output": "{\n\tf.raw(s)\n\treturn f\n}"}
{"input": "package request\n\nimport (\n\t\"CitySourcedAPI/data\"\n\t\"CitySourcedAPI/logs\"\n\t\"CitySourcedAPI/response\"\n\n\t\"fmt\"\n\t\"time\"\n)\n\n\n\n\n\ntype CreateReportComment struct {\n\tRequest\n\tProcessor\n\tReportID string `xml:\"ReportId\" json:\"ReportId\"`\n\treportID int64\n\tComment  string `xml:\"Comment\" json:\"Comment\"`\n}\n\n\n\nfunc (st *CreateReportComment) Run() (string, error) {\n\terr := data.NewComment(st.reportID, data.CustomTime{time.Now()}, st.Comment)\n\tif err != nil {\n\t\treturn response.StatusMsg(fmt.Sprintf(\"CreateReportComment failed: %q\", err), st.start), nil\n\t}\n\treturn response.StatusMsg(\"Comment created.\", st.start), nil\n}\n\nfunc (st CreateReportComment) String() string {\n\tls := new(logs.LogString)\n\tls.AddS(\"CreateReportComment\\n\")\n\tls.AddS(st.Request.String())\n\tls.AddF(\"ID %s/%d\\n\", st.ReportID, st.reportID)\n\tls.AddF(\"Comment: %v\\n\", st.Comment)\n\treturn ls.Box(90)\n}\n\nfunc (st *CreateReportComment) Validate(start time.Time) string ", "output": "{\n\tvar v validate\n\tst.start = start\n\tst.reportID = v.int(\"ReportID\", st.ReportID)\n\treturn v.errmsg\n}"}
{"input": "package synth\n\nimport \"strings\"\n\ntype builder struct {\n\tb []string\n}\n\nfunc build(s ...string) *builder {\n\tb := &builder{\n\t\tb: s,\n\t}\n\treturn b\n}\n\nfunc (b *builder) push(s ...string) {\n\tb.b = append(b.b, s...)\n}\n\nfunc (b *builder) csv(values []string, each func(string)) {\n\tfor i, value := range values {\n\t\teach(value)\n\t\tif i != len(values)-1 {\n\t\t\tb.push(\",\")\n\t\t}\n\t}\n}\n\n\n\nfunc (b *builder) join() string {\n\treturn strings.Join(b.b, \" \")\n}\n\n\n\nfunc CreateTable(temporary bool, name string, header []string) string {\n\tb := build(\"CREATE\")\n\n\tif temporary {\n\t\tb.push(\"TEMPORARY\")\n\t}\n\n\tb.push(\"TABLE\", name, \"(\")\n\n\tb.csv(header, func(h string) {\n\t\tb.push(h, \"TEXT\")\n\t})\n\n\tb.push(\");\")\n\n\treturn b.join()\n}\n\n\n\n\nfunc Insert(name string, header []string) string {\n\tb := build(\"INSERT INTO\", name, \"(\")\n\n\tb.csv(header, func(h string) {\n\t\tb.push(h)\n\t})\n\n\tb.push(\")\")\n\tb.values(header)\n\treturn b.join()\n}\n\n\n\nfunc Values(preface string, header []string) string {\n\tb := build(preface)\n\tb.values(header)\n\treturn b.join()\n}\n\nfunc (b *builder) values(hdr []string) ", "output": "{\n\tb.push(\"VALUES (\")\n\tb.csv(hdr, func(string) {\n\t\tb.push(\"?\")\n\t})\n\tb.push(\");\")\n}"}
{"input": "package language\n\n\n\nconst (\n\tcurDigitBits = 3\n\tcurDigitMask = 1<<curDigitBits - 1\n\tcurRoundBits = 0 \n)\n\ntype currencyInfo int\n\nfunc mkCurrencyInfo(round, decimal int) string {\n\treturn string([]byte{byte(round<<curDigitBits | decimal)})\n}\n\n\n\nfunc (c currencyInfo) decimals() int {\n\treturn int(c & curDigitMask)\n}\n\n\ntype langAliasType int8\n\nconst (\n\tlangDeprecated langAliasType = iota\n\tlangMacro\n\tlangLegacy\n\n\tlangAliasTypeUnknown langAliasType = -1\n)\n\nfunc (c currencyInfo) round() int ", "output": "{\n\treturn int(c >> curDigitBits)\n}"}
{"input": "package oauth2\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n\n\n\n\n\n\ntype SecretMiddleware struct {\n\toauth *Spec\n}\n\n\nfunc NewSecretMiddleware(oauth *Spec) *SecretMiddleware {\n\treturn &SecretMiddleware{oauth}\n}\n\n\nfunc (m *SecretMiddleware) Handler(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlog.Debug(\"Starting Oauth2Secret middleware\")\n\n\t\tif \"\" != r.Header.Get(\"Authorization\") {\n\t\t\tlog.Debug(\"Authorization is set, proxying\")\n\t\t\thandler.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tclientID := r.URL.Query().Get(\"client_id\")\n\t\tif \"\" == clientID {\n\t\t\tlog.Debug(\"ClientID not set, proxying\")\n\t\t\thandler.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tclientSecret, exists := m.oauth.Secrets[clientID]\n\t\tif false == exists {\n\t\t\tpanic(ErrClientIDNotFound)\n\t\t}\n\n\t\tm.changeRequest(r, clientID, clientSecret)\n\t\thandler.ServeHTTP(w, r)\n\t})\n}\n\n\n\n\nfunc (m *SecretMiddleware) changeRequest(req *http.Request, clientID, clientSecret string) ", "output": "{\n\tlog.Debug(\"Modifying request\")\n\tauthString := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf(\"%s:%s\", clientID, clientSecret)))\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Basic %s\", authString))\n}"}
{"input": "package vars\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/Sirupsen/logrus\"\n\t\"github.com/daticahealth/cli/commands/services\"\n)\n\nfunc CmdUnset(svcName string, variables []string, iv IVars, is services.IServices) error {\n\tservice, err := is.RetrieveByLabel(svcName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif service == nil {\n\t\treturn fmt.Errorf(\"Could not find a service with the label \\\"%s\\\". You can list services with the \\\"datica services list\\\" command.\", svcName)\n\t}\n\tfor _, variable := range variables {\n\t\terr := iv.Unset(service.ID, variable)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tlogrus.Printf(\"Unset. For these environment variable changes to take effect, you will need to redeploy your service with \\\"datica redeploy %s\\\"\", svcName)\n\treturn nil\n}\n\n\n\n\n\n\nfunc (v *SVars) Unset(svcID, variable string) error ", "output": "{\n\theaders := v.Settings.HTTPManager.GetHeaders(v.Settings.SessionToken, v.Settings.Version, v.Settings.Pod, v.Settings.UsersID)\n\tresp, statusCode, err := v.Settings.HTTPManager.Delete(nil, fmt.Sprintf(\"%s%s/environments/%s/services/%s/env/%s\", v.Settings.PaasHost, v.Settings.PaasHostVersion, v.Settings.EnvironmentID, svcID, variable), headers)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn v.Settings.HTTPManager.ConvertResp(resp, statusCode, nil)\n}"}
{"input": "package dashboard\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (s *Server) HandleHistory(w http.ResponseWriter, r *http.Request) ", "output": "{\n\ttype HistoryData struct {\n\t\tClock      int32\n\t\tTotalHits  uint64\n\t\tDirections []interface{}\n\t}\n\n\tdata := HistoryData{\n\t\tClock:      s.counter.Clock.GetTime(),\n\t\tTotalHits:  s.counter.Count.Count(),\n\t\tDirections: make([]interface{}, 0, len(s.counter.Directions)),\n\t}\n\n\tfor _, direction := range s.counter.Directions {\n\t\tdirection.Store.CleanUp(data.Clock)\n\n\t\tdirData := map[string]interface{}{\n\t\t\t\"name\":           direction.Name,\n\t\t\t\"blocked-values\": direction.BlockedValues(),\n\t\t}\n\n\t\tdata.Directions = append(data.Directions, dirData)\n\t}\n\n\tjson, _ := json.Marshal(data)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write(json)\n}"}
{"input": "package image\n\nimport (\n\t\"time\"\n\n\t\"github.com/Symantec/Dominator/lib/filesystem\"\n\t\"github.com/Symantec/Dominator/lib/filter\"\n\t\"github.com/Symantec/Dominator/lib/hash\"\n\t\"github.com/Symantec/Dominator/lib/objectserver\"\n\t\"github.com/Symantec/Dominator/lib/triggers\"\n)\n\ntype Annotation struct {\n\tObject *hash.Hash \n\tURL    string\n}\n\ntype DirectoryMetadata struct {\n\tOwnerGroup string\n}\n\ntype Directory struct {\n\tName     string\n\tMetadata DirectoryMetadata\n}\n\ntype Image struct {\n\tCreatedBy    string \n\tFilter       *filter.Filter\n\tFileSystem   *filesystem.FileSystem\n\tTriggers     *triggers.Triggers\n\tReleaseNotes *Annotation\n\tBuildLog     *Annotation\n\tCreatedOn    time.Time\n\tExpiresAt    time.Time\n\tPackages     []Package\n}\n\ntype Package struct {\n\tName    string\n\tSize    uint64 \n\tVersion string\n}\n\n\n\n\nfunc (image *Image) ForEachObject(objectFunc func(hash.Hash) error) error {\n\treturn image.forEachObject(objectFunc)\n}\n\nfunc (image *Image) ListMissingObjects(\n\tobjectsChecker objectserver.ObjectsChecker) ([]hash.Hash, error) {\n\treturn image.listMissingObjects(objectsChecker)\n}\n\n\n\n\n\nfunc (image *Image) ReplaceStrings(replaceFunc func(string) string) {\n\timage.replaceStrings(replaceFunc)\n}\n\n\n\nfunc (image *Image) Verify() error {\n\treturn image.verify()\n}\n\nfunc (image *Image) VerifyObjects(checker objectserver.ObjectsChecker) error {\n\treturn image.verifyObjects(checker)\n}\n\n\n\n\n\n\n\nfunc (image *Image) VerifyRequiredPaths(requiredPaths map[string]rune) error {\n\treturn image.verifyRequiredPaths(requiredPaths)\n}\n\nfunc SortDirectories(directories []Directory) {\n\tsortDirectories(directories)\n}\n\nfunc (image *Image) ListObjects() []hash.Hash ", "output": "{\n\treturn image.listObjects()\n}"}
{"input": "package meta\n\nimport (\n\t\"fmt\"\n\n\t\"k8s.io/kubernetes/pkg/api/unversioned\"\n)\n\n\ntype AmbiguousResourceError struct {\n\tPartialResource unversioned.GroupVersionResource\n\n\tMatchingResources []unversioned.GroupVersionResource\n\tMatchingKinds     []unversioned.GroupVersionKind\n}\n\nfunc (e *AmbiguousResourceError) Error() string {\n\tswitch {\n\tcase len(e.MatchingKinds) > 0 && len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v and kinds %v\", e.PartialResource, e.MatchingResources, e.MatchingKinds)\n\tcase len(e.MatchingKinds) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple kinds %v\", e.PartialResource, e.MatchingKinds)\n\tcase len(e.MatchingResources) > 0:\n\t\treturn fmt.Sprintf(\"%v matches multiple resources %v\", e.PartialResource, e.MatchingResources)\n\n\t}\n\n\treturn fmt.Sprintf(\"%v matches multiple resources or kinds\", e.PartialResource)\n}\n\nfunc IsAmbiguousResourceError(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\n\t_, ok := err.(*AmbiguousResourceError)\n\treturn ok\n}\n\n\ntype NoResourceMatchError struct {\n\tPartialResource unversioned.GroupVersionResource\n}\n\nfunc (e *NoResourceMatchError) Error() string {\n\treturn fmt.Sprintf(\"no matches for %v\", e.PartialResource)\n}\n\n\n\nfunc IsNoResourceMatchError(err error) bool ", "output": "{\n\tif err == nil {\n\t\treturn false\n\t}\n\n\t_, ok := err.(*NoResourceMatchError)\n\treturn ok\n}"}
{"input": "package gzip\n\nimport (\n\t\"net/http\"\n\t\"path\"\n\n\t\"github.com/mholt/caddy/middleware\"\n)\n\n\ntype Filter interface {\n\tShouldCompress(*http.Request) bool\n}\n\n\nvar defaultExtensions = []string{\"\", \".txt\", \".htm\", \".html\", \".css\", \".php\", \".js\", \".json\", \".md\", \".xml\"}\n\n\nfunc DefaultExtFilter() ExtFilter {\n\tm := ExtFilter{Exts: make(Set)}\n\tfor _, extension := range defaultExtensions {\n\t\tm.Exts.Add(extension)\n\t}\n\treturn m\n}\n\n\ntype ExtFilter struct {\n\tExts Set\n}\n\n\nconst ExtWildCard = \"*\"\n\n\n\n\nfunc (e ExtFilter) ShouldCompress(r *http.Request) bool {\n\text := path.Ext(r.URL.Path)\n\treturn e.Exts.Contains(ExtWildCard) || e.Exts.Contains(ext)\n}\n\n\ntype PathFilter struct {\n\tIgnoredPaths Set\n}\n\n\n\n\n\n\n\ntype Set map[string]struct{}\n\n\nfunc (s Set) Add(value string) {\n\ts[value] = struct{}{}\n}\n\n\nfunc (s Set) Remove(value string) {\n\tdelete(s, value)\n}\n\n\nfunc (s Set) Contains(value string) bool {\n\t_, ok := s[value]\n\treturn ok\n}\n\n\n\n\nfunc (s Set) ContainsFunc(f func(string) bool) bool {\n\tfor k := range s {\n\t\tif f(k) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p PathFilter) ShouldCompress(r *http.Request) bool ", "output": "{\n\treturn !p.IgnoredPaths.ContainsFunc(func(value string) bool {\n\t\treturn middleware.Path(r.URL.Path).Matches(value)\n\t})\n}"}
{"input": "package database\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetAutonomousPatchRequest struct {\n\n\tAutonomousPatchId *string `mandatory:\"true\" contributesTo:\"path\" name:\"autonomousPatchId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetAutonomousPatchRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request GetAutonomousPatchRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request GetAutonomousPatchRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetAutonomousPatchResponse struct {\n\n\tRawResponse *http.Response\n\n\tAutonomousPatch `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response GetAutonomousPatchResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response GetAutonomousPatchResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request GetAutonomousPatchRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) ", "output": "{\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}"}
{"input": "package lsp\n\nimport \"fmt\"\n\n\nconst (\n\tDefaultEpochLimit  = 5\n\tDefaultEpochMillis = 2000\n\tDefaultWindowSize  = 1\n)\n\n\ntype Params struct {\n\tEpochLimit int\n\n\tEpochMillis int\n\n\tWindowSize int\n}\n\n\n\n\n\n\n\n\nfunc (p *Params) String() string {\n\treturn fmt.Sprintf(\"[EpochLimit: %d, EpochMillis: %d, WindowSize: %d]\",\n\t\tp.EpochLimit, p.EpochMillis, p.WindowSize)\n}\n\nfunc NewParams() *Params ", "output": "{\n\treturn &Params{\n\t\tEpochLimit:  DefaultEpochLimit,\n\t\tEpochMillis: DefaultEpochMillis,\n\t\tWindowSize:  DefaultWindowSize,\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n)\n\nconst (\n\tsemanticAlphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-\"\n\n\tsemanticBuildAlphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-.\"\n)\n\n\n\nconst (\n\tAppName  string = \"dcrdata\"\n\tAppMajor uint   = 6\n\tAppMinor uint   = 1\n\tAppPatch uint   = 0\n)\n\n\nvar (\n\tappPreRelease = \"pre\"\n\n\tappBuild = \"dev\"\n)\n\n\n\n\n\n\n\nfunc normalizeSemString(str, alphabet string) string {\n\tvar result bytes.Buffer\n\tfor _, r := range str {\n\t\tif strings.ContainsRune(alphabet, r) {\n\t\t\tresult.WriteRune(r)\n\t\t}\n\t}\n\treturn result.String()\n}\n\n\n\n\n\nfunc normalizePreRelString(str string) string {\n\treturn normalizeSemString(str, semanticAlphabet)\n}\n\n\n\n\n\nfunc normalizeBuildString(str string) string {\n\treturn normalizeSemString(str, semanticBuildAlphabet)\n}\n\nfunc Version() string ", "output": "{\n\tversion := fmt.Sprintf(\"%d.%d.%d\", AppMajor, AppMinor, AppPatch)\n\n\tpreRelease := normalizePreRelString(appPreRelease)\n\tif preRelease != \"\" {\n\t\tversion = fmt.Sprintf(\"%s-%s\", version, preRelease)\n\t}\n\n\tbuild := normalizeBuildString(appBuild)\n\tif build != \"\" {\n\t\tversion = fmt.Sprintf(\"%s+%s\", version, build)\n\t}\n\n\treturn version\n}"}
{"input": "package install\n\nimport (\n\t\"k8s.io/apimachinery/pkg/apimachinery/announced\"\n\t\"k8s.io/apimachinery/pkg/apimachinery/registered\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\t\"k8s.io/kubernetes/pkg/api/legacyscheme\"\n\n\t\"github.com/openshift/origin/pkg/api/legacy\"\n\tsecurityapi \"github.com/openshift/origin/pkg/security/apis/security\"\n\tsecurityapiv1 \"github.com/openshift/origin/pkg/security/apis/security/v1\"\n)\n\nfunc init() {\n\tInstall(legacyscheme.GroupFactoryRegistry, legacyscheme.Registry, legacyscheme.Scheme)\n\tlegacy.InstallLegacySecurity(legacyscheme.Scheme, legacyscheme.Registry)\n}\n\n\n\n\nfunc Install(groupFactoryRegistry announced.APIGroupFactoryRegistry, registry *registered.APIRegistrationManager, scheme *runtime.Scheme) ", "output": "{\n\tif err := announced.NewGroupMetaFactory(\n\t\t&announced.GroupMetaFactoryArgs{\n\t\t\tGroupName:                  securityapi.GroupName,\n\t\t\tVersionPreferenceOrder:     []string{securityapiv1.SchemeGroupVersion.Version},\n\t\t\tRootScopedKinds:            sets.NewString(\"SecurityContextConstraints\"),\n\t\t\tAddInternalObjectsToScheme: securityapi.AddToScheme,\n\t\t},\n\t\tannounced.VersionToSchemeFunc{\n\t\t\tsecurityapiv1.SchemeGroupVersion.Version: securityapiv1.AddToScheme,\n\t\t},\n\t).Announce(groupFactoryRegistry).RegisterAndEnable(registry, scheme); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"input": "package netserver\n\nimport \"github.com/caddyserver/caddy/caddytls\"\n\n\ntype Config struct {\n\tType string\n\n\tHostname string\n\n\tListenPort string\n\n\tTLS *caddytls.Config\n\n\tParameters []string\n\tTokens     map[string][]string\n}\n\n\nfunc (c Config) TLSConfig() *caddytls.Config {\n\treturn c.TLS\n}\n\n\n\n\n\nfunc (c Config) Port() string {\n\treturn c.ListenPort\n}\n\nfunc (c Config) Host() string ", "output": "{\n\treturn c.Hostname\n}"}
{"input": "package todoist\n\nimport \"fmt\"\n\ntype IntBool bool\n\nfunc (i IntBool) Bool() bool {\n\tif i {\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}\n\nfunc (i IntBool) MarshalJSON() ([]byte, error) {\n\tif i {\n\t\treturn []byte(\"1\"), nil\n\t} else {\n\t\treturn []byte(\"0\"), nil\n\t}\n}\n\nfunc (i *IntBool) UnmarshalJSON(b []byte) (err error) {\n\tswitch string(b) {\n\tcase \"1\":\n\t\t*i = true\n\tcase \"0\":\n\t\t*i = false\n\tdefault:\n\t\treturn fmt.Errorf(\"Could not unmarshal into intbool: %s\", string(b))\n\t}\n\treturn nil\n}\n\ntype ColorStringer interface {\n\tString() string\n\tColorString() string\n}\n\ntype NoColorString struct {\n\ts string\n}\n\nfunc NewNoColorString(s string) NoColorString {\n\treturn NoColorString{s}\n}\n\n\n\nfunc (n NoColorString) ColorString() string {\n\treturn n.s\n}\n\nfunc (n NoColorString) String() string ", "output": "{\n\treturn n.s\n}"}
{"input": "package analytics\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"testing\"\n\t\"time\"\n\n\tadaptertest \"istio.io/istio/mixer/pkg/adapter/test\"\n)\n\nfunc TestLegacySelect(t *testing.T) {\n\n\tenv := adaptertest.NewEnv(t)\n\n\topts := Options{\n\t\tLegacyEndpoint:   true,\n\t\tBufferPath:       \"\",\n\t\tStagingFileLimit: 10,\n\t\tBaseURL:          &url.URL{},\n\t\tKey:              \"key\",\n\t\tSecret:           \"secret\",\n\t\tClient:           http.DefaultClient,\n\t\tnow:              time.Now,\n\t}\n\n\tm, err := NewManager(env, opts)\n\tm.Close()\n\tif err != nil {\n\t\tt.Fatalf(\"newManager: %s\", err)\n\t}\n\n\tif _, ok := m.(*legacyAnalytics); !ok {\n\t\tt.Errorf(\"want an *legacyAnalytics type, got: %#v\", m)\n\t}\n}\n\nfunc TestStandardSelect(t *testing.T) {\n\n\tenv := adaptertest.NewEnv(t)\n\n\topts := Options{\n\t\tBufferPath:         \"/tmp/apigee-ax/buffer/\",\n\t\tStagingFileLimit:   10,\n\t\tBaseURL:            &url.URL{},\n\t\tKey:                \"key\",\n\t\tSecret:             \"secret\",\n\t\tClient:             http.DefaultClient,\n\t\tnow:                time.Now,\n\t\tCollectionInterval: time.Minute,\n\t}\n\n\tm, err := NewManager(env, opts)\n\tif err != nil {\n\t\tt.Fatalf(\"newManager: %s\", err)\n\t}\n\tm.Close()\n\n\tif _, ok := m.(*manager); !ok {\n\t\tt.Errorf(\"want an *manager type, got: %#v\", m)\n\t}\n}\n\n\n\nfunc TestStandardBadOptions(t *testing.T) ", "output": "{\n\n\tenv := adaptertest.NewEnv(t)\n\n\topts := Options{\n\t\tBufferPath:       \"/tmp/apigee-ax/buffer/\",\n\t\tStagingFileLimit: 0,\n\t\tBaseURL:          &url.URL{},\n\t\tKey:              \"\",\n\t\tSecret:           \"\",\n\t\tClient:           http.DefaultClient,\n\t\tnow:              time.Now,\n\t}\n\n\twant := \"all analytics options are required\"\n\tm, err := NewManager(env, opts)\n\tif err == nil || err.Error() != want {\n\t\tt.Errorf(\"want: %s, got: %s\", want, err)\n\t}\n\tif m != nil {\n\t\tt.Errorf(\"should not get manager\")\n\t\tm.Close()\n\t}\n}"}
{"input": "package channel\n\nimport (\n\t\"database/sql\"\n\t\"github.com/bragfoo/saman/util/db\"\n)\n\n\n\nfunc GetChannel() (*sql.Stmt, error) {\n\treturn db.Prepare(getQuery)\n}\n\n\n\nfunc PutChannel() (*sql.Stmt, error) {\n\treturn db.Prepare(putQuery)\n}\n\nfunc DelChannel() (*sql.Stmt, error) {\n\treturn db.Prepare(delQuery)\n}\n\nfunc PostChannel() (*sql.Stmt, error) ", "output": "{\n\treturn db.Prepare(postQuery)\n}"}
{"input": "package v1alpha1\n\nimport (\n\t\"github.com/satori/go.uuid\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n)\n\n\n\nfunc SetDefaults_InstanceSpec(spec *InstanceSpec) {\n\tif spec.OSBGUID == \"\" {\n\t\tspec.OSBGUID = uuid.NewV4().String()\n\t}\n}\n\nfunc SetDefaults_BindingSpec(spec *BindingSpec) {\n\tif spec.OSBGUID == \"\" {\n\t\tspec.OSBGUID = uuid.NewV4().String()\n\t}\n}\n\nfunc addDefaultingFuncs(scheme *runtime.Scheme) error ", "output": "{\n\tRegisterDefaults(scheme)\n\treturn scheme.AddDefaultingFuncs(\n\t\tSetDefaults_InstanceSpec,\n\t\tSetDefaults_BindingSpec,\n\t)\n}"}
{"input": "package terraform\n\nimport (\n\t\"fmt\"\n)\n\n\ntype NodeDestroyableModuleVariable struct {\n\tPathValue []string\n}\n\nfunc (n *NodeDestroyableModuleVariable) Name() string {\n\tresult := \"plan-destroy\"\n\tif len(n.PathValue) > 1 {\n\t\tresult = fmt.Sprintf(\"%s.%s\", modulePrefixStr(n.PathValue), result)\n\t}\n\n\treturn result\n}\n\n\nfunc (n *NodeDestroyableModuleVariable) Path() []string {\n\treturn n.PathValue\n}\n\n\n\n\nfunc (n *NodeDestroyableModuleVariable) EvalTree() EvalNode ", "output": "{\n\treturn &EvalDiffDestroyModule{Path: n.PathValue}\n}"}
{"input": "package stun\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"github.com/willscott/goturn/common\"\n\t\"net\"\n)\n\nconst (\n\tMappedAddress stun.AttributeType = 0x1\n)\n\ntype MappedAddressAttribute struct {\n\tFamily  uint16\n\tPort    uint16\n\tAddress net.IP\n}\n\nfunc NewMappedAddressAttribute() stun.Attribute {\n\treturn stun.Attribute(new(MappedAddressAttribute))\n}\n\nfunc (h *MappedAddressAttribute) Type() stun.AttributeType {\n\treturn MappedAddress\n}\n\nfunc (h *MappedAddressAttribute) Encode(msg *stun.Message) ([]byte, error) {\n\tbuf := new(bytes.Buffer)\n\terr := stun.WriteAttributeHeader(buf, stun.Attribute(h), msg)\n\terr = binary.Write(buf, binary.BigEndian, h.Family)\n\terr = binary.Write(buf, binary.BigEndian, h.Port)\n\terr = binary.Write(buf, binary.BigEndian, h.Address)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\n\n\n\nfunc (h *MappedAddressAttribute) Length(_ *stun.Message) uint16 {\n\tif h.Family == 1 {\n\t\treturn 8\n\t} else {\n\t\treturn 20\n\t}\n}\n\nfunc (h *MappedAddressAttribute) Decode(data []byte, _ uint16, _ *stun.Parser) error ", "output": "{\n\tif data[0] != 0 && data[1] != 1 && data[0] != 2 {\n\t\treturn errors.New(\"Incorrect Mapped Address Family.\")\n\t}\n\th.Family = uint16(data[1])\n\tif (h.Family == 1 && len(data) < 8) || (h.Family == 2 && len(data) < 20) {\n\t\treturn errors.New(\"Mapped Address Attribute unexpectedly Truncated.\")\n\t}\n\th.Port = uint16(data[2])<<8 + uint16(data[3])\n\tif h.Family == 1 {\n\t\th.Address = data[4:8]\n\t} else {\n\t\th.Address = data[4:20]\n\t}\n\treturn nil\n}"}
{"input": "package template\n\nimport (\n\t\"github.com/dpb587/metalink\"\n)\n\ntype templateFile metalink.File\n\nfunc (tf templateFile) MD5() string {\n\tfor _, hash := range tf.Hashes {\n\t\tif hash.Type == \"md5\" {\n\t\t\treturn hash.Hash\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\nfunc (tf templateFile) SHA1() string {\n\tfor _, hash := range tf.Hashes {\n\t\tif hash.Type == \"sha-1\" {\n\t\t\treturn hash.Hash\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\n\n\nfunc (tf templateFile) SHA512() string {\n\tfor _, hash := range tf.Hashes {\n\t\tif hash.Type == \"sha-512\" {\n\t\t\treturn hash.Hash\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\nfunc (tf templateFile) SHA256() string ", "output": "{\n\tfor _, hash := range tf.Hashes {\n\t\tif hash.Type == \"sha-256\" {\n\t\t\treturn hash.Hash\n\t\t}\n\t}\n\n\treturn \"\"\n}"}
{"input": "package credentials\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype FakeProvider struct {\n\tError       error\n\tCredentials *Credentials\n}\n\nfunc (p *FakeProvider) GetCredentials() (*Credentials, error) {\n\tif p.Credentials != nil {\n\t\treturn p.Credentials, nil\n\t}\n\n\tif p.Error != nil {\n\t\treturn nil, p.Error\n\t}\n\n\tpanic(\"Specify either Credentials or Error\")\n}\n\n\n\nfunc TestFakeProviderAssignable(t *testing.T) ", "output": "{\n\tvar provider interface{}\n\tprovider = &FakeProvider{}\n\n\t_, ok := provider.(Provider)\n\tassert.True(t, ok, \"\")\n}"}
{"input": "package system \n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\nfunc MkdirAllWithACL(path string, perm os.FileMode, sddl string) error {\n\treturn os.MkdirAll(path, perm)\n}\n\n\n\nfunc MkdirAll(path string, perm os.FileMode) error {\n\treturn os.MkdirAll(path, perm)\n}\n\n\n\n\n\n\n\n\n\n\n\n\nfunc CreateSequential(name string) (*os.File, error) {\n\treturn os.Create(name)\n}\n\n\n\n\n\nfunc OpenSequential(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\n\n\n\n\n\nfunc OpenFileSequential(name string, flag int, perm os.FileMode) (*os.File, error) {\n\treturn os.OpenFile(name, flag, perm)\n}\n\n\n\n\n\n\n\n\n\n\nfunc TempFileSequential(dir, prefix string) (f *os.File, err error) {\n\treturn ioutil.TempFile(dir, prefix)\n}\n\nfunc IsAbs(path string) bool ", "output": "{\n\treturn filepath.IsAbs(path)\n}"}
{"input": "package goutil\n\n\nfunc MinInt(vals []int) int {\n\tif len(vals) == 0 {\n\t\treturn 0\n\t} else if len(vals) == 1 {\n\t\treturn vals[0]\n\t}\n\n\tmin := vals[0]\n\n\tfor _, v := range vals[1:] {\n\t\tif v < min {\n\t\t\tmin = v\n\t\t}\n\t}\n\n\treturn min\n}\n\n\nfunc MinInt8(vals []int8) int8 {\n\tif len(vals) == 0 {\n\t\treturn 0\n\t} else if len(vals) == 1 {\n\t\treturn vals[0]\n\t}\n\n\tmin := vals[0]\n\n\tfor _, v := range vals[1:] {\n\t\tif v < min {\n\t\t\tmin = v\n\t\t}\n\t}\n\n\treturn min\n}\n\n\nfunc MinInt16(vals []int16) int16 {\n\tif len(vals) == 0 {\n\t\treturn 0\n\t} else if len(vals) == 1 {\n\t\treturn vals[0]\n\t}\n\n\tmin := vals[0]\n\n\tfor _, v := range vals[1:] {\n\t\tif v < min {\n\t\t\tmin = v\n\t\t}\n\t}\n\n\treturn min\n}\n\n\n\n\n\nfunc MinInt64(vals []int64) int64 {\n\tif len(vals) == 0 {\n\t\treturn 0\n\t} else if len(vals) == 1 {\n\t\treturn vals[0]\n\t}\n\n\tmin := vals[0]\n\n\tfor _, v := range vals[1:] {\n\t\tif v < min {\n\t\t\tmin = v\n\t\t}\n\t}\n\n\treturn min\n}\n\nfunc MinInt32(vals []int32) int32 ", "output": "{\n\tif len(vals) == 0 {\n\t\treturn 0\n\t} else if len(vals) == 1 {\n\t\treturn vals[0]\n\t}\n\n\tmin := vals[0]\n\n\tfor _, v := range vals[1:] {\n\t\tif v < min {\n\t\t\tmin = v\n\t\t}\n\t}\n\n\treturn min\n}"}
{"input": "package iso20022\n\n\ntype DocumentToSend2 struct {\n\n\tType *Max140Text `xml:\"Tp\"`\n\n\tRecipient *PartyIdentification2Choice `xml:\"Rcpt\"`\n\n\tMethodOfTransmission *CommunicationMethod3Choice `xml:\"MtdOfTrnsmssn\"`\n}\n\nfunc (d *DocumentToSend2) SetType(value string) {\n\td.Type = (*Max140Text)(&value)\n}\n\n\n\nfunc (d *DocumentToSend2) AddMethodOfTransmission() *CommunicationMethod3Choice {\n\td.MethodOfTransmission = new(CommunicationMethod3Choice)\n\treturn d.MethodOfTransmission\n}\n\nfunc (d *DocumentToSend2) AddRecipient() *PartyIdentification2Choice ", "output": "{\n\td.Recipient = new(PartyIdentification2Choice)\n\treturn d.Recipient\n}"}
{"input": "package global\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"testing\"\n\n\t\"github.com/mperham/inspeqtor/conf/global/ast\"\n\t\"github.com/mperham/inspeqtor/conf/global/lexer\"\n\t\"github.com/mperham/inspeqtor/conf/global/parser\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestBasicParsing(t *testing.T) ", "output": "{\n\tdata, err := ioutil.ReadFile(\"fixtures/inspeqtor.conf\")\n\tassert.Nil(t, err)\n\n\ts := lexer.NewLexer([]byte(data))\n\tp := parser.NewParser()\n\tobj, err := p.Parse(s)\n\tassert.Nil(t, err)\n\tassert.NotNil(t, obj)\n\n\tconfig := obj.(ast.Config)\n\tassert.Equal(t, \"15\", config.Variables[\"cycle_time\"])\n\tassert.Equal(t, 3, len(config.Routes))\n\tassert.Equal(t, \"b!l$a%rgh^fazz\\\"\", config.Routes[\"analytics\"].Config[\"password\"])\n\tassert.Equal(t, \"smtp.example.com\", config.Routes[\"analytics\"].Config[\"smtp_server\"])\n\tlog.Printf(\"%+v\", config)\n}"}
{"input": "package redis\n\nimport (\n\t\"bytes\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/wandoulabs/codis/extern/redis-port/pkg/libs/tests\"\n)\n\nfunc TestEncodeString(t *testing.T) {\n\tresp := &String{\"OK\"}\n\ttestEncodeAndCheck(t, resp, []byte(\"+OK\\r\\n\"))\n}\n\nfunc TestEncodeError(t *testing.T) {\n\tresp := &Error{\"Error\"}\n\ttestEncodeAndCheck(t, resp, []byte(\"-Error\\r\\n\"))\n}\n\nfunc TestEncodeInt(t *testing.T) {\n\tresp := &Int{}\n\tfor _, v := range []int{-1, 0, 1024 * 1024} {\n\t\tresp.Value = int64(v)\n\t\ttestEncodeAndCheck(t, resp, []byte(\":\"+strconv.FormatInt(int64(v), 10)+\"\\r\\n\"))\n\t}\n}\n\nfunc TestEncodeBulkBytes(t *testing.T) {\n\tresp := &BulkBytes{}\n\tresp.Value = nil\n\ttestEncodeAndCheck(t, resp, []byte(\"$-1\\r\\n\"))\n\tresp.Value = []byte{}\n\ttestEncodeAndCheck(t, resp, []byte(\"$0\\r\\n\\r\\n\"))\n\tresp.Value = []byte(\"helloworld!!\")\n\ttestEncodeAndCheck(t, resp, []byte(\"$12\\r\\nhelloworld!!\\r\\n\"))\n}\n\n\n\nfunc testEncodeAndCheck(t *testing.T, resp Resp, expect []byte) {\n\tb, err := EncodeToBytes(resp)\n\ttests.AssertNoError(t, err)\n\ttests.Assert(t, bytes.Equal(b, expect))\n}\n\nfunc TestEncodeArray(t *testing.T) ", "output": "{\n\tresp := &Array{}\n\tresp.Value = nil\n\ttestEncodeAndCheck(t, resp, []byte(\"*-1\\r\\n\"))\n\tresp.Value = []Resp{}\n\ttestEncodeAndCheck(t, resp, []byte(\"*0\\r\\n\"))\n\tresp.Append(&Int{0})\n\ttestEncodeAndCheck(t, resp, []byte(\"*1\\r\\n:0\\r\\n\"))\n\tresp.Append(&BulkBytes{nil})\n\ttestEncodeAndCheck(t, resp, []byte(\"*2\\r\\n:0\\r\\n$-1\\r\\n\"))\n\tresp.Append(&BulkBytes{[]byte(\"test\")})\n\ttestEncodeAndCheck(t, resp, []byte(\"*3\\r\\n:0\\r\\n$-1\\r\\n$4\\r\\ntest\\r\\n\"))\n}"}
{"input": "package admission\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"k8s.io/apimachinery/pkg/runtime\"\n)\n\n\ntype Defaulter interface {\n\truntime.Object\n\tDefault()\n}\n\n\nfunc DefaultingWebhookFor(defaulter Defaulter) *Webhook {\n\treturn &Webhook{\n\t\tHandler: &mutatingHandler{defaulter: defaulter},\n\t}\n}\n\ntype mutatingHandler struct {\n\tdefaulter Defaulter\n\tdecoder   *Decoder\n}\n\nvar _ DecoderInjector = &mutatingHandler{}\n\n\nfunc (h *mutatingHandler) InjectDecoder(d *Decoder) error {\n\th.decoder = d\n\treturn nil\n}\n\n\n\n\nfunc (h *mutatingHandler) Handle(ctx context.Context, req Request) Response ", "output": "{\n\tif h.defaulter == nil {\n\t\tpanic(\"defaulter should never be nil\")\n\t}\n\n\tobj := h.defaulter.DeepCopyObject().(Defaulter)\n\terr := h.decoder.Decode(req, obj)\n\tif err != nil {\n\t\treturn Errored(http.StatusBadRequest, err)\n\t}\n\n\tobj.Default()\n\tmarshalled, err := json.Marshal(obj)\n\tif err != nil {\n\t\treturn Errored(http.StatusInternalServerError, err)\n\t}\n\n\treturn PatchResponseFromRaw(req.Object.Raw, marshalled)\n}"}
{"input": "package storsimple8000series\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype ManagementClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\nfunc New(subscriptionID string) ManagementClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) ManagementClient ", "output": "{\n\treturn ManagementClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/service/ssm\"\n\n\t\"gopkg.in/alecthomas/kingpin.v2\"\n)\n\ntype readCommand struct {\n\tName    string\n\tDecrypt bool\n}\n\nfunc configureReadCommand(app *kingpin.Application) {\n\trc := &readCommand{}\n\tread := app.Command(\"read\", \"Read secret from parameter store\").Action(rc.runRead)\n\tread.Arg(\"name\", \"Secret name\").StringVar(&rc.Name)\n\tread.Flag(\"decrypt\", \"Return decrypted value\").BoolVar(&rc.Decrypt)\n}\n\n\n\nfunc (rc *readCommand) runRead(ctx *kingpin.ParseContext) error ", "output": "{\n\tconfig := aws.NewConfig().WithRegion(*region)\n\tsess, err := newSession(config, mfaSerial, roleArn)\n\tif err != nil {\n\t\treturn err\n\t}\n\tssmClient := ssm.New(sess, config)\n\n\tgpInput := &ssm.GetParameterInput{\n\t\tName:           &rc.Name,\n\t\tWithDecryption: &rc.Decrypt,\n\t}\n\tgpOutput, err := ssmClient.GetParameter(gpInput)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(*gpOutput.Parameter.Value)\n\n\treturn nil\n}"}
{"input": "package sysinfo\n\nimport (\n\t\"runtime\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n\n\n\n\n\n\n\n\nfunc NumCPU() int {\n\tif ncpu := numCPU(); ncpu > 0 {\n\t\treturn ncpu\n\t}\n\treturn runtime.NumCPU()\n}\n\nfunc numCPU() int ", "output": "{\n\tpid, _, _ := unix.RawSyscall(unix.SYS_GETPID, 0, 0, 0)\n\n\tvar mask [1024 / 64]uintptr\n\t_, _, err := unix.RawSyscall(unix.SYS_SCHED_GETAFFINITY, pid, uintptr(len(mask)*8), uintptr(unsafe.Pointer(&mask[0])))\n\tif err != 0 {\n\t\treturn 0\n\t}\n\n\tncpu := 0\n\tfor _, e := range mask {\n\t\tif e == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tncpu += int(popcnt(uint64(e)))\n\t}\n\treturn ncpu\n}"}
{"input": "package testing\n\nimport (\n\t\"github.com/juju/testing\"\n\n\t\"github.com/juju/juju/core/auditlog\"\n)\n\n\ntype FakeAuditLog struct {\n\ttesting.Stub\n}\n\nfunc (l *FakeAuditLog) AddConversation(m auditlog.Conversation) error {\n\tl.Stub.AddCall(\"AddConversation\", m)\n\treturn l.Stub.NextErr()\n}\n\nfunc (l *FakeAuditLog) AddRequest(m auditlog.Request) error {\n\tl.Stub.AddCall(\"AddRequest\", m)\n\treturn l.Stub.NextErr()\n}\n\nfunc (l *FakeAuditLog) AddResponse(m auditlog.ResponseErrors) error {\n\tl.Stub.AddCall(\"AddResponse\", m)\n\treturn l.Stub.NextErr()\n}\n\n\n\nfunc (l *FakeAuditLog) Close() error ", "output": "{\n\tl.Stub.AddCall(\"Close\")\n\treturn l.Stub.NextErr()\n}"}
{"input": "package unibyte\n\nimport \"unicode\"\n\n\nfunc IsLower(b byte) bool {\n\treturn b >= 'a' && b <= 'z'\n}\n\n\nfunc IsUpper(b byte) bool {\n\treturn b >= 'A' && b <= 'Z'\n}\n\n\nfunc IsLetter(b byte) bool {\n\treturn IsLower(b) || IsUpper(b)\n}\n\n\nfunc IsSpaceQuote(b byte) bool {\n\treturn IsSpace(b) || b == '\"' || b == '\\''\n}\n\n\n\n\n\nfunc ToLower(b byte) byte {\n\tif IsUpper(b) {\n\t\tb = b - 'A' + 'a'\n\t}\n\n\treturn b\n}\n\n\nfunc ToUpper(b byte) byte {\n\tif IsLower(b) {\n\t\tb = b - 'a' + 'A'\n\t}\n\n\treturn b\n}\n\n\nfunc ToLowerString(b byte) string {\n\tif IsUpper(b) {\n\t\tb = b - 'A' + 'a'\n\t}\n\n\treturn string(b)\n}\n\n\nfunc ToUpperString(b byte) string {\n\tif IsLower(b) {\n\t\tb = b - 'a' + 'A'\n\t}\n\n\treturn string(b)\n}\n\nfunc IsSpace(b byte) bool ", "output": "{\n\treturn unicode.IsSpace(rune(b))\n}"}
{"input": "package cli\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/spf13/cobra\"\n)\n\nvar (\n\tgoSubtitleCmd = &cobra.Command{\n\t\tUse:   \"go-subtitle\",\n\t\tShort: \"A command line client for parsing a subtitle file\",\n\t\tLong: `A CLI for parsing a subtitle file\n\nTo get help about a resource or command, please run \"go-subtitle help\"`,\n\t}\n)\n\n\n\nfunc Execute() ", "output": "{\n\tif err := goSubtitleCmd.Execute(); err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(-1)\n\t}\n}"}
{"input": "package basic\n\nimport (\n\t\"html/template\"\n\n\tuuid \"github.com/nu7hatch/gouuid\"\n)\n\nvar display *template.Template\n\ntype data struct {\n\tUUID         *uuid.UUID\n\tInteger      int\n\tReversedUUID string\n}\n\n\n\nfunc initTemplate() ", "output": "{\n\tt := `\n\t\t<html>\n\t\t\t<body>\n\t\t\t\t<strong>Basic Module</strong><br/>\n\t\t\t\tUUID: {{.UUID}}. <br/>\n\t\t\t\tInteger: {{.Integer}}. <br/>\n\t\t\t\tReverse UUID: {{.ReversedUUID}}. <br/>\n\t\t\t</body>\n\t\t</html>\n\t`\n\tdisplay = template.Must(template.New(\"html\").Parse(t))\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/swag\"\n)\n\n\n\ntype ReplyKeyboardMarkup struct {\n\n\tKeyboard ReplyKeyboardMarkupKeyboard `json:\"keyboard\"`\n\n\tOneTimeKeyboard bool `json:\"one_time_keyboard,omitempty\"`\n\n\tResizeKeyboard bool `json:\"resize_keyboard,omitempty\"`\n\n\tSelective bool `json:\"selective,omitempty\"`\n}\n\n\n\n\n\nfunc (m *ReplyKeyboardMarkup) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\nfunc (m *ReplyKeyboardMarkup) UnmarshalBinary(b []byte) error {\n\tvar res ReplyKeyboardMarkup\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *ReplyKeyboardMarkup) Validate(formats strfmt.Registry) error ", "output": "{\n\tvar res []error\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package syscall\n\nimport \"unsafe\"\n\n\n\nfunc naclClose(fd int) (err error) {\n\t_, _, e1 := Syscall(sys_close, uintptr(fd), 0, 0)\n\tif e1 != 0 {\n\t\terr = errnoErr(e1)\n\t}\n\treturn\n}\n\n\n\nfunc naclFstat(fd int, stat *Stat_t) (err error) {\n\t_, _, e1 := Syscall(sys_fstat, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)\n\tif e1 != 0 {\n\t\terr = errnoErr(e1)\n\t}\n\treturn\n}\n\n\n\n\n\n\n\nfunc naclSeek(fd int, off *int64, whence int) (err error) {\n\t_, _, e1 := Syscall(sys_lseek, uintptr(fd), uintptr(unsafe.Pointer(off)), uintptr(whence))\n\tif e1 != 0 {\n\t\terr = errnoErr(e1)\n\t}\n\treturn\n}\n\n\n\nfunc naclGetRandomBytes(b []byte) (err error) {\n\tvar _p0 unsafe.Pointer\n\tif len(b) > 0 {\n\t\t_p0 = unsafe.Pointer(&b[0])\n\t} else {\n\t\t_p0 = unsafe.Pointer(&_zero)\n\t}\n\t_, _, e1 := Syscall(sys_get_random_bytes, uintptr(_p0), uintptr(len(b)), 0)\n\tif e1 != 0 {\n\t\terr = errnoErr(e1)\n\t}\n\treturn\n}\n\nfunc naclRead(fd int, b []byte) (n int, err error) ", "output": "{\n\tvar _p0 unsafe.Pointer\n\tif len(b) > 0 {\n\t\t_p0 = unsafe.Pointer(&b[0])\n\t} else {\n\t\t_p0 = unsafe.Pointer(&_zero)\n\t}\n\tr0, _, e1 := Syscall(sys_read, uintptr(fd), uintptr(_p0), uintptr(len(b)))\n\tn = int(r0)\n\tif e1 != 0 {\n\t\terr = errnoErr(e1)\n\t}\n\treturn\n}"}
{"input": "package swt\n\nimport \"github.com/timob/javabind\"\nimport \"unsafe\"\n\n\n\nimport \"C\"\n\n\n\nvar EventsArmListenerNativeMap = make(map[int]EventsArmListenerInterface)\n\ntype EventsArmListenerNative struct {\n\t*javabind.Callable\n\tEventsArmListenerInterface\n}\n\nfunc NewEventsArmListenerNative(implementation EventsArmListenerInterface) *EventsArmListenerNative {\n\n\tobj, err := javabind.GetEnv().NewObject(\"org/eclipse/swt/events/ArmListenerNative\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tx := &EventsArmListenerNative{}\n\tx.Callable = &javabind.Callable{obj}\n\n    hash, err := x.Callable.CallMethod(javabind.GetEnv(), \"hashCode\", javabind.Int)\n    if err != nil {\n        panic(err)\n    }\n    EventsArmListenerNativeMap[hash.(int)] = implementation\n\treturn x\n}\n\n\n    func init() {\n        javabind.OnJVMStart(func() {\n        javabind.GetEnv().RegisterNative(\"org/eclipse/swt/events/ArmListenerNative\", \"widgetArmed\", javabind.Void, []interface{}{\"org/eclipse/swt/events/ArmEvent\"}, C.go_callback_EventsArmListenerNative_WidgetArmed)\n\n        })\n    }\n\nfunc go_callback_EventsArmListenerNative_WidgetArmed(env unsafe.Pointer, obj uintptr, arg_0 uintptr) ", "output": "{\n    rObj := &javabind.Callable{javabind.WrapJObject(obj, \"org/eclipse/swt/events/ArmListenerNative\", false)}\n    hash, err := rObj.CallMethod(javabind.GetEnv(), \"hashCode\", javabind.Int)\n    if err != nil {\n        panic(err)\n    }\n\n    i := EventsArmListenerNativeMap[hash.(int)]\n        \tretcon_a := javabind.NewJavaToGoCallable()\n\tdst_a := &javabind.Callable{}\n\tretcon_a.Dest(dst_a)\n\tif err := retcon_a.Convert(javabind.WrapJObject(arg_0, \"org/eclipse/swt/events/ArmEvent\", false)); err != nil {\n\t\tpanic(err)\n\t}\n\targ_a := &EventsArmEvent{}\n\targ_a.Callable = dst_a\ni.WidgetArmed(arg_a)\n}"}
{"input": "package main\n\nimport \"fmt\"\n\n\n\n\ntype printable interface {\n    print()\n}\n\n\n\ntype human struct {\n    name string\n    age int\n}\n\n\n\n\nfunc (h *human) print() {\n    fmt.Printf(\"%v.%d\", h.name, h.age)\n}\n\ntype account struct {\n    bank string\n    balance int\n}\n\nfunc (a account) print() {\n    fmt.Printf(\"[%v] %d\", a.bank, a.balance)\n}\n\nfunc main() {\n    accounts := []account {\n        {\"Bank of America\", 1000},\n        {\"Chase\", 500},\n    }\n    humans := []human {\n        {\"Steve\", 30},\n        {\"Katie\", 28},\n        {\"John\", 23},\n    }\n    printables := make([]printable, 0, len(accounts) + len(humans))\n    for _, acc := range accounts {\n        printables = append(printables, acc)\n    }\n    for i := range humans {\n        \n        \n        \n        printables = append(printables, &humans[i])\n    }\n    use(printables)\n}\n\nfunc use(printables []printable) ", "output": "{\n    for _, p := range printables {\n        p.print()\n        fmt.Println()\n    }\n}"}
{"input": "package grpclog \n\nimport \"os\"\n\nvar logger = newLoggerV2()\n\n\nfunc V(l int) bool {\n\treturn logger.V(l)\n}\n\n\nfunc Info(args ...interface{}) {\n\tlogger.Info(args...)\n}\n\n\nfunc Infof(format string, args ...interface{}) {\n\tlogger.Infof(format, args...)\n}\n\n\nfunc Infoln(args ...interface{}) {\n\tlogger.Infoln(args...)\n}\n\n\nfunc Warning(args ...interface{}) {\n\tlogger.Warning(args...)\n}\n\n\nfunc Warningf(format string, args ...interface{}) {\n\tlogger.Warningf(format, args...)\n}\n\n\n\n\n\nfunc Error(args ...interface{}) {\n\tlogger.Error(args...)\n}\n\n\nfunc Errorf(format string, args ...interface{}) {\n\tlogger.Errorf(format, args...)\n}\n\n\nfunc Errorln(args ...interface{}) {\n\tlogger.Errorln(args...)\n}\n\n\n\nfunc Fatal(args ...interface{}) {\n\tlogger.Fatal(args...)\n\tos.Exit(1)\n}\n\n\n\nfunc Fatalf(format string, args ...interface{}) {\n\tlogger.Fatalf(format, args...)\n\tos.Exit(1)\n}\n\n\n\nfunc Fatalln(args ...interface{}) {\n\tlogger.Fatalln(args...)\n\tos.Exit(1)\n}\n\n\n\n\nfunc Print(args ...interface{}) {\n\tlogger.Info(args...)\n}\n\n\n\n\nfunc Printf(format string, args ...interface{}) {\n\tlogger.Infof(format, args...)\n}\n\n\n\n\nfunc Println(args ...interface{}) {\n\tlogger.Infoln(args...)\n}\n\nfunc Warningln(args ...interface{}) ", "output": "{\n\tlogger.Warningln(args...)\n}"}
{"input": "package stateful\n\nimport \"sync\"\n\n\n\n\ntype ScopePool interface {\n\tGet() *Scope\n\tPut(scope *Scope)\n\n\tReferenceVariables() []string\n}\n\ntype scopePool struct {\n\treferenceVariables []string\n\tpool               sync.Pool\n}\n\n\n\n\nfunc (s *scopePool) ReferenceVariables() []string {\n\treturn s.referenceVariables\n}\n\n\n\nfunc (s *scopePool) Get() *Scope {\n\treturn s.pool.Get().(*Scope)\n}\n\n\nfunc (s *scopePool) Put(scope *Scope) {\n\tscope.Reset()\n\ts.pool.Put(scope)\n}\n\nfunc NewScopePool(referenceVariables []string) ScopePool ", "output": "{\n\tscopePool := &scopePool{\n\t\treferenceVariables: referenceVariables,\n\t}\n\n\tscopePool.pool = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\tscope := NewScope()\n\t\t\tfor _, refVariable := range scopePool.referenceVariables {\n\t\t\t\tscope.Set(refVariable, empty)\n\t\t\t}\n\n\t\t\treturn scope\n\t\t},\n\t}\n\n\treturn scopePool\n}"}
{"input": "package nl\n\nimport (\n\t\"syscall\"\n\t\"unsafe\"\n)\n\ntype RtMsg struct {\n\tsyscall.RtMsg\n}\n\n\n\nfunc NewRtDelMsg() *RtMsg {\n\treturn &RtMsg{\n\t\tRtMsg: syscall.RtMsg{\n\t\t\tTable: syscall.RT_TABLE_MAIN,\n\t\t\tScope: syscall.RT_SCOPE_NOWHERE,\n\t\t},\n\t}\n}\n\nfunc (msg *RtMsg) Len() int {\n\treturn syscall.SizeofRtMsg\n}\n\nfunc DeserializeRtMsg(b []byte) *RtMsg {\n\treturn (*RtMsg)(unsafe.Pointer(&b[0:syscall.SizeofRtMsg][0]))\n}\n\nfunc (msg *RtMsg) Serialize() []byte {\n\treturn (*(*[syscall.SizeofRtMsg]byte)(unsafe.Pointer(msg)))[:]\n}\n\ntype RtNexthop struct {\n\tsyscall.RtNexthop\n}\n\nfunc DeserializeRtNexthop(b []byte) *RtNexthop {\n\treturn (*RtNexthop)(unsafe.Pointer(&b[0:syscall.SizeofRtNexthop][0]))\n}\n\nfunc (msg *RtNexthop) Serialize() []byte {\n\treturn (*(*[syscall.SizeofRtNexthop]byte)(unsafe.Pointer(msg)))[:]\n}\n\nfunc NewRtMsg() *RtMsg ", "output": "{\n\treturn &RtMsg{\n\t\tRtMsg: syscall.RtMsg{\n\t\t\tTable:    syscall.RT_TABLE_MAIN,\n\t\t\tScope:    syscall.RT_SCOPE_UNIVERSE,\n\t\t\tProtocol: syscall.RTPROT_BOOT,\n\t\t\tType:     syscall.RTN_UNICAST,\n\t\t},\n\t}\n}"}
{"input": "package sayhi\n\nimport (\n  \"routes\"\n  \"net/http\"\n)\n\n\n\nfunc Sayhi()  ", "output": "{\n  routes.HelloR.HandleFunc(\"/hi/{name}\", func (w http.ResponseWriter, r *http.Request)  {\n    params := routes.GetParams(r)\n    w.Write([]byte(\"Hi \"+params[\"name\"]))\n  })\n}"}
{"input": "package migrations\n\nimport (\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"code.cloudfoundry.org/bbs/migration\"\n)\n\nvar migrationsRegistry = migration.Migrations{}\n\nfunc appendMigration(migrationTemplate migration.Migration) {\n\tmigrationsRegistry = append(migrationsRegistry, migrationTemplate)\n}\n\n\n\nfunc AllMigrations() migration.Migrations {\n\tmigs := make(migration.Migrations, len(migrationsRegistry))\n\tfor i, mig := range migrationsRegistry {\n\t\trt := reflect.TypeOf(mig)\n\t\tif rt.Kind() == reflect.Ptr {\n\t\t\trt = rt.Elem()\n\t\t}\n\t\tmigs[i] = reflect.New(rt).Interface().(migration.Migration)\n\t}\n\treturn migs\n}\n\nfunc migrationString(m migration.Migration) string ", "output": "{\n\t_, filename, _, ok := runtime.Caller(1)\n\tif !ok {\n\t\treturn strconv.FormatInt(m.Version(), 10)\n\t}\n\treturn strings.Split(filepath.Base(filename), \".\")[0]\n}"}
{"input": "package log\n\nimport (\n\t\"sync\"\n\n\t\"github.com/asim/go-micro/v3/util/ring\"\n\t\"github.com/google/uuid\"\n)\n\n\ntype osLog struct {\n\tformat FormatFunc\n\tonce   sync.Once\n\n\tsync.RWMutex\n\tbuffer *ring.Buffer\n\tsubs   map[string]*osStream\n}\n\ntype osStream struct {\n\tstream chan Record\n}\n\n\nfunc (o *osLog) Read(...ReadOption) ([]Record, error) {\n\tvar records []Record\n\n\tfor _, v := range o.buffer.Get(100) {\n\t\trecords = append(records, v.Value.(Record))\n\t}\n\n\treturn records, nil\n}\n\n\nfunc (o *osLog) Write(r Record) error {\n\to.buffer.Put(r)\n\treturn nil\n}\n\n\n\n\nfunc (o *osStream) Chan() <-chan Record {\n\treturn o.stream\n}\n\nfunc (o *osStream) Stop() error {\n\treturn nil\n}\n\nfunc NewLog(opts ...Option) Log {\n\toptions := Options{\n\t\tFormat: DefaultFormat,\n\t}\n\tfor _, o := range opts {\n\t\to(&options)\n\t}\n\n\tl := &osLog{\n\t\tformat: options.Format,\n\t\tbuffer: ring.New(1024),\n\t\tsubs:   make(map[string]*osStream),\n\t}\n\n\treturn l\n}\n\nfunc (o *osLog) Stream() (Stream, error) ", "output": "{\n\to.Lock()\n\tdefer o.Unlock()\n\n\tst := &osStream{\n\t\tstream: make(chan Record, 128),\n\t}\n\n\to.subs[uuid.New().String()] = st\n\n\treturn st, nil\n}"}
{"input": "package scene\n\nimport (\n\t\"github.com/mikee385/GolangRayTracer/geometry\"\n\t\"github.com/mikee385/GolangRayTracer/material\"\n\t\"math\"\n)\n\ntype Sphere struct {\n\tcenter   geometry.Point3D\n\tradius   float32\n\tradius2  float32\n\tmaterial material.Material\n}\n\nfunc NewSphere(center geometry.Point3D, radius float32, material material.Material) Sphere {\n\treturn Sphere{\n\t\tcenter:   center,\n\t\tradius:   radius,\n\t\tradius2:  radius * radius,\n\t\tmaterial: material,\n\t}\n}\n\n\n\nfunc (sphere Sphere) Radius() float32 {\n\treturn sphere.radius\n}\n\nfunc (sphere Sphere) Intersect(ray geometry.Ray3D) (float32, bool) {\n\tvar sphereToRay = geometry.NewVector_BetweenPoints(ray.Origin, sphere.center)\n\tvar b = geometry.Dot(sphereToRay, ray.Direction.ToVector())\n\tif b < 0.0 {\n\t\treturn 0.0, false\n\t}\n\n\tvar d2 = geometry.Dot(sphereToRay, sphereToRay) - b*b\n\tif d2 > sphere.radius2 {\n\t\treturn 0.0, false\n\t}\n\n\tvar c = float32(math.Sqrt(float64(sphere.radius2 - d2)))\n\tvar t = b - c\n\tif t < 0 {\n\t\tt = b + c\n\t}\n\n\treturn t, true\n}\n\nfunc (sphere Sphere) Normal(point geometry.Point3D) geometry.Direction3D {\n\treturn geometry.NewDirection_BetweenPoints(sphere.center, point)\n}\n\nfunc (sphere Sphere) Material(point geometry.Point3D) material.Material {\n\treturn sphere.material\n}\n\nfunc (sphere Sphere) Center() geometry.Point3D ", "output": "{\n\treturn sphere.center\n}"}
{"input": "package g\n\nimport (\n\t\"database/sql\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"sync\"\n)\n\n\nvar (\n\tdbLock    sync.RWMutex\n\tdbConnMap map[string]*sql.DB\n)\n\nvar DB *sql.DB\n\nfunc InitDB() {\n\tvar err error\n\tDB, err = makeDbConn()\n\tif DB == nil || err != nil {\n\t\tlog.Fatalln(\"g.InitDB, get db conn fail\", err)\n\t}\n\n\tdbConnMap = make(map[string]*sql.DB)\n\tlog.Println(\"g.InitDB ok\")\n}\n\nfunc GetDbConn(connName string) (c *sql.DB, e error) {\n\tdbLock.Lock()\n\tdefer dbLock.Unlock()\n\n\tvar err error\n\tvar dbConn *sql.DB\n\tdbConn = dbConnMap[connName]\n\tif dbConn == nil {\n\t\tdbConn, err = makeDbConn()\n\t\tif dbConn == nil || err != nil {\n\t\t\tcloseDbConn(dbConn)\n\t\t\treturn nil, err\n\t\t}\n\t\tdbConnMap[connName] = dbConn\n\t}\n\n\terr = dbConn.Ping()\n\tif err != nil {\n\t\tcloseDbConn(dbConn)\n\t\tdelete(dbConnMap, connName)\n\t\treturn nil, err\n\t}\n\n\treturn dbConn, err\n}\n\n\nfunc makeDbConn() (conn *sql.DB, err error) {\n\tconn, err = sql.Open(\"mysql\", Config().DB.Dsn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconn.SetMaxIdleConns(Config().DB.MaxIdle)\n\terr = conn.Ping()\n\n\treturn conn, err\n}\n\n\n\nfunc closeDbConn(conn *sql.DB) ", "output": "{\n\tif conn != nil {\n\t\tconn.Close()\n\t}\n}"}
{"input": "package goroutine\n\nimport \"testing\"\n\n\n\nfunc TestContainer(t *testing.T) ", "output": "{\n\tcontainer()\n}"}
{"input": "package response\n\nimport \"encoding/json\"\nimport \"net/http\"\n\n\ntype Response struct {\n\tStatusCode int         `json:\"status_code\"`\n\tMessage    string      `json:\"message\"`\n\tData       interface{} `json:\"data\"`\n}\n\n\nfunc createResponse(result Response) []byte {\n\tres, _ := json.Marshal(result)\n\treturn res\n}\n\n\nfunc Success(result interface{}) []byte {\n\treturn createResponse(Response{\n\t\tStatusCode: 200,\n\t\tMessage:    \"ok\",\n\t\tData:       result,\n\t})\n}\n\n\n\n\nfunc SendJSONResponseHeader(w http.ResponseWriter) {\n\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\tw.WriteHeader(http.StatusOK)\n}\n\nfunc Failed(message string) []byte ", "output": "{\n\treturn createResponse(Response{\n\t\tStatusCode: 500,\n\t\tMessage:    message,\n\t})\n}"}
{"input": "package router\n\nimport (\n\t\"sync/atomic\"\n\n\t\"github.com/AsynkronIT/protoactor-go/actor\"\n)\n\ntype roundRobinGroupRouter struct {\n\tGroupRouter\n}\n\ntype roundRobinPoolRouter struct {\n\tPoolRouter\n}\n\ntype roundRobinState struct {\n\tindex   int32\n\troutees *actor.PIDSet\n\tvalues  []actor.PID\n}\n\nfunc (state *roundRobinState) SetRoutees(routees *actor.PIDSet) {\n\tstate.routees = routees\n\tstate.values = routees.Values()\n}\n\n\n\nfunc (state *roundRobinState) RouteMessage(message interface{}, sender *actor.PID) {\n\tpid := roundRobinRoutee(&state.index, state.values)\n\tpid.Request(message, sender)\n}\n\nfunc NewRoundRobinPool(size int) *actor.Props {\n\treturn actor.FromSpawnFunc(spawner(&roundRobinPoolRouter{PoolRouter{PoolSize: size}}))\n}\n\nfunc NewRoundRobinGroup(routees ...*actor.PID) *actor.Props {\n\treturn actor.FromSpawnFunc(spawner(&roundRobinGroupRouter{GroupRouter{Routees: actor.NewPIDSet(routees...)}}))\n}\n\nfunc (config *roundRobinPoolRouter) CreateRouterState() Interface {\n\treturn &roundRobinState{}\n}\n\nfunc (config *roundRobinGroupRouter) CreateRouterState() Interface {\n\treturn &roundRobinState{}\n}\n\nfunc roundRobinRoutee(index *int32, routees []actor.PID) actor.PID {\n\ti := int(atomic.AddInt32(index, 1))\n\tif i < 0 {\n\t\t*index = 0\n\t\ti = 0\n\t}\n\tmod := len(routees)\n\troutee := routees[i%mod]\n\treturn routee\n}\n\nfunc (state *roundRobinState) GetRoutees() *actor.PIDSet ", "output": "{\n\treturn state.routees\n}"}
{"input": "package goutils\n\nimport (\n\t\"time\"\n)\n\n\ntype Future interface {\n\tGet() interface{}\n\tGetTimeout(timeout time.Duration) interface{}\n\tIsDone() bool\n\tOutput(interface{})\n}\n\ntype FutureTask struct {\n\tch   chan interface{}\n\tdone bool\n}\n\n\nfunc NewFutureTask() *FutureTask {\n\treturn &FutureTask{make(chan interface{}, 1), false}\n}\n\n\n\nfunc (f *FutureTask) GetTimeout(timeout time.Duration) interface{} {\n\tselect {\n\tcase v := <-f.ch:\n\t\tf.done = true\n\t\treturn v\n\tcase <-time.After(timeout):\n\t\treturn nil\n\t}\n}\n\nfunc (f *FutureTask) IsDone() bool {\n\treturn f.done\n}\n\n\nfunc (f *FutureTask) Output(v interface{}) {\n\tf.ch <- v\n}\n\nfunc (f *FutureTask) Get() interface{} ", "output": "{\n\tv := <-f.ch\n\tf.done = true\n\n\treturn v\n}"}
{"input": "package iradix\n\n\n\n\ntype rawIterator struct {\n\tnode *Node\n\n\tstack []rawStackEntry\n\n\tpos *Node\n\n\tpath string\n}\n\n\n\ntype rawStackEntry struct {\n\tpath  string\n\tedges edges\n}\n\n\n\n\n\n\nfunc (i *rawIterator) Path() string {\n\treturn i.path\n}\n\n\nfunc (i *rawIterator) Next() {\n\tif i.stack == nil && i.node != nil {\n\t\ti.stack = []rawStackEntry{\n\t\t\t{\n\t\t\t\tedges: edges{\n\t\t\t\t\tedge{node: i.node},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tfor len(i.stack) > 0 {\n\t\tn := len(i.stack)\n\t\tlast := i.stack[n-1]\n\t\telem := last.edges[0].node\n\n\t\tif len(last.edges) > 1 {\n\t\t\ti.stack[n-1].edges = last.edges[1:]\n\t\t} else {\n\t\t\ti.stack = i.stack[:n-1]\n\t\t}\n\n\t\tif len(elem.edges) > 0 {\n\t\t\tpath := last.path + string(elem.prefix)\n\t\t\ti.stack = append(i.stack, rawStackEntry{path, elem.edges})\n\t\t}\n\n\t\ti.pos = elem\n\t\ti.path = last.path + string(elem.prefix)\n\t\treturn\n\t}\n\n\ti.pos = nil\n\ti.path = \"\"\n}\n\nfunc (i *rawIterator) Front() *Node ", "output": "{\n\treturn i.pos\n}"}
{"input": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/lmorg/murex/lang\"\n\t\"github.com/lmorg/murex/test/count\"\n)\n\n\n\nfunc TestMurex(t *testing.T) {\n\tcount.Tests(t, 1)\n\n\tlang.InitEnv()\n\n\tblock := []rune(\"a [Mon..Fri]->regexp m/^T/\")\n\n\t_, err := lang.ShellProcess.Fork(lang.F_NO_STDIN | lang.F_NO_STDOUT | lang.F_NO_STDERR).Execute(block)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n}\n\nfunc TestRunCommandLine(t *testing.T) {\n\tcount.Tests(t, 1)\n\n\trunCommandLine(`out: \"testing\" -> null`)\n}\n\n\n\nfunc TestRunSourceGzMods(t *testing.T) {\n\tcount.Tests(t, 1)\n\n\tfile := \"test/source.mx.gz\"\n\trunSource(file)\n}\n\nfunc TestRunSource(t *testing.T) ", "output": "{\n\tcount.Tests(t, 1)\n\n\tfile := \"test/source.mx\"\n\trunSource(file)\n}"}
{"input": "package profile_test\n\nimport (\n\t\"flag\"\n\t\"os\"\n\n\t\"github.com/pkg/profile\"\n)\n\nfunc ExampleStart() {\n\tdefer profile.Start().Stop()\n}\n\nfunc ExampleCPUProfile() {\n\tdefer profile.Start(profile.CPUProfile).Stop()\n}\n\nfunc ExampleMemProfile() {\n\tdefer profile.Start(profile.MemProfile).Stop()\n}\n\nfunc ExampleMemProfileRate() {\n\tdefer profile.Start(profile.MemProfileRate(2048)).Stop()\n}\n\nfunc ExampleProfilePath() {\n\tdefer profile.Start(profile.ProfilePath(os.Getenv(\"HOME\"))).Stop()\n}\n\nfunc ExampleNoShutdownHook() {\n\tdefer profile.Start(profile.NoShutdownHook).Stop()\n}\n\n\n\nfunc ExampleStart_withFlags() ", "output": "{\n\tmode := flag.String(\"profile.mode\", \"\", \"enable profiling mode, one of [cpu, mem, mutex, block]\")\n\tflag.Parse()\n\tswitch *mode {\n\tcase \"cpu\":\n\t\tdefer profile.Start(profile.CPUProfile).Stop()\n\tcase \"mem\":\n\t\tdefer profile.Start(profile.MemProfile).Stop()\n\tcase \"mutex\":\n\t\tdefer profile.Start(profile.MutexProfile).Stop()\n\tcase \"block\":\n\t\tdefer profile.Start(profile.BlockProfile).Stop()\n\tdefault:\n\t}\n}"}
{"input": "package driverskeleton\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"periph.io/x/periph\"\n\t\"periph.io/x/periph/conn/i2c/i2ctest\"\n)\n\nfunc TestDriverSkeleton(t *testing.T) {\n\tbus := i2ctest.Playback{\n\t\tOps: []i2ctest.IO{\n\t\t\t{Addr: 42, W: []byte(\"in\"), R: []byte(\"IN\")},\n\t\t\t{Addr: 42, W: []byte(\"what\"), R: []byte(\"Hello world!\")},\n\t\t},\n\t\tDontPanic: true,\n\t}\n\tdev, err := New(&bus)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif data := dev.Read(); data != \"Hello world!\" {\n\t\tt.Fatal(data)\n\t}\n\n\tif data := dev.Read(); !strings.HasPrefix(data, \"i2ctest: unexpected Tx()\") {\n\t\tt.Fatal(data)\n\t}\n}\n\nfunc TestDriverSkeleton_empty(t *testing.T) {\n\tif dev, err := New(&i2ctest.Playback{DontPanic: true}); dev != nil || err == nil {\n\t\tt.Fatal(\"Tx should have failed\")\n\t}\n}\n\n\n\nfunc TestInit(t *testing.T) {\n\tif state, err := periph.Init(); err != nil {\n\t\tt.Fatal(state, err)\n\t}\n}\n\nfunc TestDriverSkeleton_init_failed(t *testing.T) ", "output": "{\n\tbus := i2ctest.Playback{\n\t\tOps: []i2ctest.IO{\n\t\t\t{Addr: 42, W: []byte(\"in\"), R: []byte(\"xx\")},\n\t\t},\n\t}\n\tif dev, err := New(&bus); dev != nil || err == nil {\n\t\tt.Fatal(\"New should have failed\")\n\t}\n}"}
{"input": "package main\n\nimport(\n  \"log\"\n  \"net/http\"\n  \"os\"\n  \"encoding/json\"\n  \"fmt\"\n)\n\ntype Response struct {\n  RouteDesc string\n  StopDesc string\n  List []struct {\n    Sched string\n    Est string\n  }\n}\n\n\n\nfunc checkArgs(args []string) {\n  if len(args) < 2 {\n    log.Fatal(\"Usage: cm-nextbus StopID\")\n  }\n}\n\nfunc main() {\n\n  checkArgs(os.Args)\n\n  stopID := os.Args[1]\n\n  url := \"http://www.capmetro.org/planner/s_nextbus2.asp?stopid=\" + stopID + \"&opt=2\"\n\n  resp, err := http.Get(url)\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  if resp.StatusCode != http.StatusOK {\n    log.Fatal(resp.Status)\n  }\n\n  r := new(Response)\n  err = json.NewDecoder(resp.Body).Decode(r)\n\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  printResults(*r)\n}\n\nfunc printResults(r Response) ", "output": "{\n  fmt.Println(\"Route:\", r.RouteDesc)\n  fmt.Println(\"Stop:\", r.StopDesc)\n  if len(r.List) > 0 {\n    for i, list := range r.List {\n      fmt.Printf(\"Trip #%d\\n\", i+1)\n      fmt.Printf(\"\\tScheduled Time: %s\\n\", list.Sched)\n      fmt.Printf(\"\\tEstimated Time: %s\\n\", list.Est)\n    }\n  } else {\n    fmt.Println(\"No available trips found\")\n  }\n}"}
{"input": "package bing\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\n\t\"github.com/zquestz/s/providers\"\n)\n\n\n\n\ntype BingProvider struct {\n}\n\n\nfunc (p *BingProvider) BuildURI(q string) string {\n\treturn fmt.Sprintf(\"https://www.bing.com/search?q=%s\", url.QueryEscape(q))\n}\n\nfunc init() ", "output": "{\n\tproviders.AddProvider(\"bing\", &BingProvider{})\n}"}
{"input": "package main\n\nimport \"github.com/nsf/termbox-go\"\nimport \"fmt\"\n\nfunc print_tb(x, y int, fg, bg termbox.Attribute, msg string) {\n\tfor _, c := range msg {\n\t\ttermbox.SetCell(x, y, c, fg, bg)\n\t\tx++\n\t}\n}\n\n\n\nfunc printf_tb(x, y int, fg, bg termbox.Attribute, format string, args ...interface{}) ", "output": "{\n\ts := fmt.Sprintf(format, args...)\n\tprint_tb(x, y, fg, bg, s)\n}"}
{"input": "package xbp\n\ntype Conn struct {\n\tProtocol Protocol\n\tnextSeq  uint16\n}\n\nfunc NewConnection(protocol Protocol) *Conn {\n\treturn &Conn{\n\t\tProtocol: protocol,\n\t}\n}\n\nfunc (conn *Conn) getNextSeq() uint16 {\n\tconn.nextSeq++\n\treturn conn.nextSeq\n}\n\n\n\nfunc (conn *Conn) SendMessage(text string, payload []byte) error {\n\treturn conn.sendPacket(FlagMessage, conn.getNextSeq(), text, payload)\n}\n\nfunc (conn *Conn) SendRequest(text string, payload []byte) (uint16, error) {\n\tseq := conn.getNextSeq()\n\treturn seq, conn.sendPacket(FlagRequest, seq, text, payload)\n}\n\nfunc (conn *Conn) SendResponse(seq uint16, text string, payload []byte) error {\n\treturn conn.sendPacket(FlagResponse, seq, text, payload)\n}\n\nfunc (conn *Conn) ReadPacket() (*Packet, error) {\n\treturn conn.Protocol.ReadPacket()\n}\n\nfunc (conn *Conn) Close() error {\n\treturn conn.Protocol.Close()\n}\n\nfunc (conn *Conn) sendPacket(flag byte, seq uint16, text string, payload []byte) error ", "output": "{\n\treturn conn.Protocol.SendPacket(&Packet{\n\t\tFlag:    flag,\n\t\tSeq:     seq,\n\t\tText:    text,\n\t\tPayload: payload,\n\t})\n}"}
{"input": "package textproto\n\nimport (\n\t\"sync\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype Pipeline struct {\n\tmu       sync.Mutex\n\tid       uint\n\trequest  sequencer\n\tresponse sequencer\n}\n\n\nfunc (p *Pipeline) Next() uint {\n\tp.mu.Lock()\n\tid := p.id\n\tp.id++\n\tp.mu.Unlock()\n\treturn id\n}\n\n\n\nfunc (p *Pipeline) StartRequest(id uint) {\n\tp.request.Start(id)\n}\n\n\n\nfunc (p *Pipeline) EndRequest(id uint) {\n\tp.request.End(id)\n}\n\n\n\n\n\n\n\nfunc (p *Pipeline) EndResponse(id uint) {\n\tp.response.End(id)\n}\n\n\n\n\n\ntype sequencer struct {\n\tmu   sync.Mutex\n\tid   uint\n\twait map[uint]chan uint\n}\n\n\n\n\nfunc (s *sequencer) Start(id uint) {\n\ts.mu.Lock()\n\tif s.id == id {\n\t\ts.mu.Unlock()\n\t\treturn\n\t}\n\tc := make(chan uint)\n\tif s.wait == nil {\n\t\ts.wait = make(map[uint]chan uint)\n\t}\n\ts.wait[id] = c\n\ts.mu.Unlock()\n\t<-c\n}\n\n\n\n\nfunc (s *sequencer) End(id uint) {\n\ts.mu.Lock()\n\tif s.id != id {\n\t\tpanic(\"out of sync\")\n\t}\n\tid++\n\ts.id = id\n\tif s.wait == nil {\n\t\ts.wait = make(map[uint]chan uint)\n\t}\n\tc, ok := s.wait[id]\n\tif ok {\n\t\tdelete(s.wait, id)\n\t}\n\ts.mu.Unlock()\n\tif ok {\n\t\tc <- 1\n\t}\n}\n\nfunc (p *Pipeline) StartResponse(id uint) ", "output": "{\n\tp.response.Start(id)\n}"}
{"input": "package minicon\n\nimport \"bytes\"\n\n\n\n\n\ntype Hardlines struct {\n\tpendingWord  bytes.Buffer\n\tcurrentLine  []string\n\tlinesOfWords [][]string\n}\n\n\n\n\nfunc (this *Hardlines) AppendWord(w string) {\n\tthis.StartNewWord() \n\tthis.currentLine = append(this.currentLine, w)\n}\n\n\n\n\nfunc (this *Hardlines) AppendRune(ch rune) {\n\tthis.pendingWord.WriteRune(ch)\n}\n\n\n\n\nfunc (this *Hardlines) StartNewWord() {\n\tif this.pendingWord.Len() > 0 {\n\t\tthis.currentLine = append(this.currentLine, this.pendingWord.String())\n\t\tthis.pendingWord.Reset()\n\t}\n}\n\n\n\n\nfunc (this *Hardlines) StartNewLine() {\n\tthis.StartNewWord()\n\tthis.linesOfWords = append(this.linesOfWords, this.currentLine)\n\tthis.currentLine = nil\n}\n\n\n\n\n\n\n\n\n\nfunc (this *Hardlines) NumLines() int {\n\tcnt := len(this.linesOfWords)\n\tif !this.IsCurrentLineEmpy() {\n\t\tcnt++\n\t}\n\treturn cnt\n}\n\n\n\n\nfunc (this Hardlines) Reflow(width int) []string {\n\toutput := NewCursorOutput(width)\n\tif this.NumLines() > 0 {\n\t\tlines, currentLine := this.linesOfWords, this.currentLine\n\t\tfor _, words := range lines {\n\t\t\toutput.AddWords(words)\n\t\t\toutput.AddLine()\n\t\t}\n\t\tif this.pendingWord.Len() > 0 {\n\t\t\tcurrentLine = append(currentLine, this.pendingWord.String())\n\t\t}\n\t\tif len(currentLine) > 0 {\n\t\t\toutput.AddWords(currentLine)\n\t\t\toutput.AddSpace()\n\t\t}\n\t}\n\treturn output.Flush()\n}\n\nfunc (this *Hardlines) IsCurrentLineEmpy() bool ", "output": "{\n\treturn len(this.currentLine) == 0 && this.pendingWord.Len() == 0\n}"}
{"input": "package api\n\nimport (\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/zhaoweiguo/log\"\n)\n\n\n\n\n\n\n\nfunc GetStringFieldWithDefault(r *http.Request, fieldName, defaultValue string) string {\n\tif fieldValue, err := GetStringField(r, fieldName); err == nil {\n\t\treturn fieldValue\n\t}\n\treturn defaultValue\n}\n\n\nfunc GetMultipleFields(r *http.Request, fieldName string) ([]string, error) {\n\tvalue, ok := r.Form[fieldName]\n\tif !ok {\n\t\treturn []string{}, MissingFieldError{fieldName}\n\t}\n\treturn value, nil\n}\n\n\n\nfunc GetIntField(r *http.Request, fieldName string) (int, error) {\n\tstringField, err := GetStringField(r, fieldName)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tintField, err := strconv.Atoi(stringField)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn intField, nil\n}\n\n\n\n\nfunc GetTimestampField(r *http.Request, fieldName string) (time.Time, error) {\n\tif _, ok := r.Form[fieldName]; !ok {\n\t\treturn time.Now(), MissingFieldError{fieldName}\n\t} else {\n\t\tparsedTime, err := time.Parse(time.RFC1123, r.FormValue(fieldName))\n\t\tif err != nil {\n\t\t\tlog.Infof(\"Failed to convert timestamp %v: %v\", r.FormValue(fieldName), err)\n\t\t\treturn time.Now(), InvalidFormatError{fieldName, r.FormValue(fieldName)}\n\t\t}\n\t\treturn parsedTime, nil\n\t}\n}\n\nfunc GetStringField(r *http.Request, fieldName string) (string, error) ", "output": "{\n\tif _, ok := r.Form[fieldName]; !ok {\n\t\treturn \"\", MissingFieldError{fieldName}\n\t}\n\treturn r.FormValue(fieldName), nil\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/kataras/iris/v12/_examples/mvc/vuejs-todo-mvc/src/todo\"\n\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/mvc\"\n\t\"github.com/kataras/iris/v12/sessions\"\n\t\"github.com/kataras/iris/v12/websocket\"\n)\n\n\ntype TodoController struct {\n\tService todo.Service\n\n\tSession *sessions.Session\n\n\tNS *websocket.NSConn\n}\n\n\n\n\n\nfunc (c *TodoController) BeforeActivation(b mvc.BeforeActivation) {\n\tb.Dependencies().Register(func(ctx iris.Context) (items []todo.Item) {\n\t\tctx.ReadJSON(&items)\n\t\treturn\n\t}) \n}\n\n\nfunc (c *TodoController) Get() []todo.Item {\n\treturn c.Service.Get(c.Session.ID())\n}\n\n\n\ntype PostItemResponse struct {\n\tSuccess bool `json:\"success\"`\n}\n\nvar emptyResponse = PostItemResponse{Success: false}\n\n\nfunc (c *TodoController) Post(newItems []todo.Item) PostItemResponse {\n\tif err := c.Service.Save(c.Session.ID(), newItems); err != nil {\n\t\treturn emptyResponse\n\t}\n\n\treturn PostItemResponse{Success: true}\n}\n\n\n\nfunc (c *TodoController) Save(msg websocket.Message) error ", "output": "{\n\tid := c.Session.ID()\n\tc.NS.Conn.Server().Broadcast(nil, websocket.Message{\n\t\tNamespace: msg.Namespace,\n\t\tEvent:     \"saved\",\n\t\tTo:        id,\n\t\tBody:      websocket.Marshal(c.Service.Get(id)),\n\t})\n\n\treturn nil\n}"}
{"input": "package slices\n\nfunc FitCapToLenInt(slice []int) []int {\n\tif l := len(slice); l != cap(slice) {\n\t\tnewslice := make([]int, l)\n\t\tcopy(newslice, slice)\n\t\treturn newslice\n\t}\n\n\treturn slice\n}\n\n\n\nfunc IntsMap(eles []int, mapper func(int) int) []int {\n\tfor i, l := 0, len(eles); i < l; i++ {\n\t\teles[i] = mapper(eles[i])\n\t}\n\treturn eles\n}\n\nfunc IntsFilter(eles []int, filter func(int) bool) []int {\n\tvar newEles []int\n\tfor i, l := 0, len(eles); i < l; i++ {\n\t\tif e := eles[i]; filter(e) {\n\t\t\tnewEles = append(newEles, e)\n\t\t}\n\t}\n\n\treturn newEles\n}\n\nfunc IntsFilterInplace(eles []int, filter func(int) bool) []int {\n\tvar prev = -1\n\n\tfor i, l := 0, len(eles); i < l; i++ {\n\t\tif e := eles[i]; filter(e) {\n\t\t\tprev++\n\t\t\teles[prev] = e\n\t\t}\n\t}\n\n\treturn eles[:prev+1]\n}\n\nfunc IncrAppendInt(slice []int, s int) []int ", "output": "{\n\tl := len(slice)\n\tnewslice := make([]int, l+1)\n\tcopy(newslice, slice)\n\tnewslice[l] = s\n\n\treturn newslice\n}"}
{"input": "package validator\n\nimport (\n\t\"github.com/vektah/gqlparser/ast\"\n\t. \"github.com/vektah/gqlparser/validator\"\n)\n\n\n\nfunc init() ", "output": "{\n\tAddRule(\"UniqueVariableNames\", func(observers *Events, addError AddErrFunc) {\n\t\tobservers.OnOperation(func(walker *Walker, operation *ast.OperationDefinition) {\n\t\t\tseen := map[string]bool{}\n\t\t\tfor _, def := range operation.VariableDefinitions {\n\t\t\t\tif seen[def.Variable] {\n\t\t\t\t\taddError(\n\t\t\t\t\t\tMessage(`There can be only one variable named \"%s\".`, def.Variable),\n\t\t\t\t\t\tAt(def.Position),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tseen[def.Variable] = true\n\t\t\t}\n\t\t})\n\t})\n}"}
{"input": "package unit\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"encoding/json\"\n\t\"github.com/quickscript/unit/exstring\"\n)\n\nfunc PathExists(path string) (bool, error) {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n\nfunc IsDir(path string) (bool, error) {\n\tfile, err := os.Stat(path)\n\tif err == nil {\n\t\treturn file.IsDir(), nil\n\t}\n\treturn false, err\n}\n\n\n\nfunc GetParentDirectory(directory string) string {\n\treturn exstring.Substr(directory, 0, strings.LastIndex(directory, \"/\"))\n}\n\nfunc GetCurrentDirectory() string {\n\tdir, err := filepath.Abs(filepath.Dir(os.Args[0]))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn strings.Replace(dir, \"\\\\\", \"/\", -1)\n}\n\nfunc Json2map(jsonStr string) (s map[string]interface{}, err error) {\n\tvar result map[string]interface{}\n\tif err := json.Unmarshal([]byte(jsonStr), &result); err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\nfunc ReadTextLine(path string, handler func(string)) error ", "output": "{\n\texist, _ := PathExists(path)\n\tif !exist {\n\t\treturn nil\n\t}\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf := bufio.NewReader(file)\n\tfor {\n\t\tline, err := buf.ReadString('\\n')\n\t\tline = strings.TrimSpace(line)\n\t\thandler(line)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package iris2\n\nimport (\n\t\"fmt\"\n)\n\ntype Mux struct {\n\trunning     bool\n\tsources     []<-chan interface{}\n\tselector    chan Word\n\tdestination chan interface{}\n\terr         chan error\n\n\tControl     <-chan Word\n\tSelect      chan<- Word\n\tDestination <-chan interface{}\n\tError       <-chan error\n}\n\nfunc NewMux(control chan<- Word) *Mux {\n\tvar mux Mux\n\tmux.err = make(chan error)\n\tmux.destination = make(chan interface{})\n\tmux.selector = make(chan Word)\n\tmux.Error = mux.err\n\tmux.Destination = mux.destination\n\tmux.Control = control\n\tmux.Select = mux.selector\n\treturn &mux\n}\nfunc (this *Mux) AddSource(src <-chan interface{}) {\n\tthis.sources = append(this.sources, src)\n}\nfunc (this *Mux) body() {\n\tfor this.running {\n\t\tselect {\n\t\tcase index, more := <-this.selector:\n\t\t\tif more {\n\t\t\t\tif index >= Word(len(this.sources)) {\n\t\t\t\t\tthis.err <- fmt.Errorf(\"Selected non existent source: %d\", index)\n\t\t\t\t} else if index < 0 {\n\t\t\t\t\tthis.err <- fmt.Errorf(\"Select source %d is less than zero!\", index)\n\t\t\t\t} else {\n\t\t\t\t\tthis.destination <- <-this.sources[index]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (this *Mux) queryControl() {\n\t<-this.Control\n\tif err := this.shutdown(); err != nil {\n\t\tthis.err <- err\n\t}\n}\n\n\n\nfunc (this *Mux) Startup() error {\n\tif this.running {\n\t\treturn fmt.Errorf(\"Given multiplexer is already running!\")\n\t} else {\n\t\tthis.running = true\n\t\tgo this.body()\n\t\tgo this.queryControl()\n\t\treturn nil\n\t}\n}\n\nfunc (this *Mux) shutdown() error ", "output": "{\n\tif !this.running {\n\t\treturn fmt.Errorf(\"Attempted to shutdown a multiplexer which isn't running\")\n\t} else {\n\t\tthis.running = false\n\t\tclose(this.selector)\n\t\treturn nil\n\t}\n}"}
{"input": "package m3\n\nimport (\n\txresource \"github.com/m3db/m3/src/x/resource\"\n\txwatch \"github.com/m3db/m3/src/x/watch\"\n)\n\ntype clusterNamespacesWatcher struct {\n\twatchable xwatch.Watchable\n}\n\n\nfunc NewClusterNamespacesWatcher() ClusterNamespacesWatcher {\n\twatchable := xwatch.NewWatchable()\n\treturn &clusterNamespacesWatcher{watchable: watchable}\n}\n\nfunc (n *clusterNamespacesWatcher) Update(namespaces ClusterNamespaces) error {\n\treturn n.watchable.Update(namespaces)\n}\n\nfunc (n *clusterNamespacesWatcher) Get() ClusterNamespaces {\n\tvalue := n.watchable.Get()\n\tif value == nil {\n\t\treturn nil\n\t}\n\n\treturn value.(ClusterNamespaces)\n}\n\n\n\nfunc (n *clusterNamespacesWatcher) Close() {\n\tn.watchable.Close()\n}\n\nfunc (n *clusterNamespacesWatcher) RegisterListener(\n\tlistener ClusterNamespacesListener,\n) xresource.SimpleCloser ", "output": "{\n\t_, watch, _ := n.watchable.Watch()\n\n\tnamespaces := watch.Get()\n\n\tif namespaces != nil {\n\t\t<-watch.C() \n\t\tlistener.OnUpdate(namespaces.(ClusterNamespaces))\n\t}\n\n\tgo func() {\n\t\tfor range watch.C() {\n\t\t\tlistener.OnUpdate(watch.Get().(ClusterNamespaces))\n\t\t}\n\t}()\n\n\treturn watch\n}"}
{"input": "package config\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"tracker/proto/config\"\n\n\t\"github.com/golang/protobuf/jsonpb\"\n)\n\n\n\nfunc Config2Json(config *config.Config) (string, error) {\n\tvar m jsonpb.Marshaler\n\tjson, err := m.MarshalToString(config)\n\tif err != nil {\n\t\tlog.Fatal(\"Could not parse config.\", err.Error())\n\t}\n\treturn json, nil\n}\n\nfunc ParseJSONFile(file string) (map[string]interface{}, error) {\n\traw, err := ioutil.ReadFile(file)\n\tif err != nil {\n\t\tlog.Fatal(err.Error())\n\t\tos.Exit(1)\n\t}\n\n\tvar response map[string]interface{}\n\tjson.Unmarshal([]byte(raw), &response)\n\treturn response, nil\n}\n\n\nfunc JsonWriter(jin, outfile string) {\n\tioutil.WriteFile(outfile, []byte(jin), 0644)\n\tfmt.Printf(\"Wrote Json File to %s\", outfile)\n}\n\nfunc LoadConfig(configfile string) (*config.Config, error) {\n\ts, err := ioutil.ReadFile(configfile)\n\tcheck(err)\n\tconfig, err := Json2Config(string(s))\n\tcheck(err)\n\treturn config, nil\n}\n\nfunc check(e error) {\n\tif e != nil {\n\t\tlog.Panic(\"Failed with error\", e.Error())\n\t}\n}\n\nfunc Json2Config(json string) (*config.Config, error) ", "output": "{\n\tvar res config.Config\n\terr := jsonpb.UnmarshalString(json, &res)\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to convert json to config\", err.Error())\n\t}\n\treturn &res, nil\n\n}"}
{"input": "package zookeeper\n\nimport (\n\t\"h12.io/realtest/container\"\n)\n\nconst (\n\tinternalPort = 2181\n)\n\nvar (\n\tcontainerName = container.ContainerName{Name: \"realtest-zookeeper-a34ea1a3e95244de8f278c79e9b2cb94\"}\n)\n\ntype ZooKeeper struct {\n\tc *container.Container\n}\n\nfunc New() (*ZooKeeper, error) {\n\tc, err := containerName.FindOrCreate(\"h12w/zookeeper:latest\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &ZooKeeper{\n\t\tc: c,\n\t}, nil\n}\n\nfunc (s *ZooKeeper) Addr() string {\n\treturn s.c.Addr(internalPort)\n}\n\nfunc (s *ZooKeeper) ID() string {\n\treturn s.c.ID\n}\n\n\n\nfunc (s *ZooKeeper) Name() string {\n\treturn containerName.Name\n}\n\nfunc (s *ZooKeeper) IP() string ", "output": "{\n\treturn s.c.IP\n}"}
{"input": "package wml_test\n\nimport (\n\t\"encoding/xml\"\n\t\"testing\"\n\n\t\"baliance.com/gooxml/schema/soo/wml\"\n)\n\nfunc TestCT_PermStartConstructor(t *testing.T) {\n\tv := wml.NewCT_PermStart()\n\tif v == nil {\n\t\tt.Errorf(\"wml.NewCT_PermStart must return a non-nil value\")\n\t}\n\tif err := v.Validate(); err != nil {\n\t\tt.Errorf(\"newly constructed wml.CT_PermStart should validate: %s\", err)\n\t}\n}\n\n\n\nfunc TestCT_PermStartMarshalUnmarshal(t *testing.T) ", "output": "{\n\tv := wml.NewCT_PermStart()\n\tbuf, _ := xml.Marshal(v)\n\tv2 := wml.NewCT_PermStart()\n\txml.Unmarshal(buf, v2)\n}"}
{"input": "package sdproxy\n\nimport (\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"sync\"\n)\n\ntype Upstream struct {\n\tservers     []*httputil.ReverseProxy\n\tcurrent     int\n\tcurrentLock *sync.Mutex\n}\n\nfunc (up *Upstream) AddServer(servers ...*httputil.ReverseProxy) {\n\tif len(servers) == 0 {\n\t\treturn\n\t}\n\tup.servers = append(up.servers, servers...)\n}\n\nfunc (up *Upstream) nextServer() *httputil.ReverseProxy {\n\tif len(up.servers) == 0 {\n\t\treturn nil\n\t}\n\tup.currentLock.Lock()\n\tdefer up.currentLock.Unlock()\n\tif up.current >= len(up.servers) {\n\t\tup.current = 0\n\t}\n\tserver := up.servers[up.current]\n\tup.current++\n\treturn server\n}\n\nfunc (up *Upstream) Serve(rw http.ResponseWriter, req *http.Request) {\n\tserver := up.nextServer()\n\tif server == nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)\n\t\treturn\n\t}\n\tserver.ServeHTTP(rw, req)\n}\n\n\n\nfunc NewUpstream(servers ...string) *Upstream ", "output": "{\n\tup := &Upstream{\n\t\tcurrentLock: &sync.Mutex{},\n\t}\n\tif len(servers) > 0 {\n\t\tfor _, server := range servers {\n\t\t\tup.AddServer(NewReverseProxy(server))\n\t\t}\n\t}\n\treturn up\n}"}
{"input": "package gull\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype Up struct {\n\tEnvironment     string\n\tSourceDirectory string\n\tMigrateTarget   MigrationTarget\n\tMigrations      *Migrations\n}\n\nfunc NewUp(source string, target MigrationTarget) *Up {\n\treturn &Up{\n\t\tEnvironment:     target.GetEnvironment(),\n\t\tMigrateTarget:   target,\n\t\tSourceDirectory: source,\n\t\tMigrations:      NewMigrations(),\n\t}\n}\n\n\n\nfunc (u *Up) Ingest() error {\n\treturn filepath.Walk(u.SourceDirectory, u.IngestFile)\n}\n\nfunc (u *Up) IngestFile(path string, f os.FileInfo, err error) error {\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !f.IsDir() {\n\t\tmigration, err := NewMigrationFromGullFile(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = u.Migrations.Add(migration)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (u *Up) Migrate() error ", "output": "{\n\terr := u.Ingest()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif u.MigrateTarget.IsPerformingFullMigration() {\n\t\tu.MigrateTarget.GetLogger().Info(\"Deleting configuration for [%v]/[%v]\", u.MigrateTarget.GetApplication(), u.MigrateTarget.GetEnvironment())\n\t\t_ = u.MigrateTarget.DeleteEnvironment()\n\t}\n\treturn u.Migrations.Apply(u.MigrateTarget)\n}"}
{"input": "package dhcp\n\nimport (\n\t\"fmt\"\n\t\"github.com/adrianco/spigo/tooling/archaius\"\n\t\"github.com/adrianco/spigo/tooling/names\"\n)\n\nvar (\n\tallocated [][]int\n\tmapped    map[string]string\n)\n\n\n\nfunc Lookup(name string) string {\n\tip := mapped[name]\n\tif ip != \"\" {\n\t\treturn ip\n\t}\n\tr := names.Region(name)\n\tri := 0\n\tz := names.Zone(name)\n\tzi := 0\n\tfor i, rr := range archaius.Conf.RegionNames {\n\t\tif rr == r {\n\t\t\tri = i\n\t\t\tbreak\n\t\t}\n\t}\n\tfor i, zr := range archaius.Conf.ZoneNames {\n\t\tif zr == z {\n\t\t\tzi = i\n\t\t\tbreak\n\t\t}\n\t}\n\tallocated[ri][zi]++\n\tnode := allocated[ri][zi]\n\taddr := fmt.Sprintf(\"%v%v.%v\", archaius.Conf.IPRanges[ri][zi], node/256, node%256)\n\tmapped[name] = addr\n\treturn addr\n}\n\nfunc init() ", "output": "{\n\tallocated = make([][]int, len(archaius.Conf.RegionNames))\n\tfor i := range allocated {\n\t\tallocated[i] = make([]int, len(archaius.Conf.ZoneNames))\n\t}\n\tmapped = make(map[string]string, archaius.Conf.Population)\n}"}
{"input": "package file\n\nimport (\n\t\"os\"\n\n\t\"io\"\n\n\t\"path/filepath\"\n\n\t\"github.com/philchia/gol/adapter\"\n\t\"github.com/philchia/gol/level\"\n)\n\nvar _ adapter.Adapter = (*fileAdapter)(nil)\n\ntype fileAdapter struct {\n\tio.WriteCloser\n\tlogLevel level.LogLevel\n}\n\n\nfunc NewAdapter(name string, l ...level.LogLevel) adapter.Adapter {\n\tpath, err := filepath.Abs(name)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tfile, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_RDWR, 0644)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\tadapter := &fileAdapter{\n\t\tWriteCloser: file,\n\t}\n\tif len(l) > 0 {\n\t\tadapter.logLevel = l[0]\n\t}\n\treturn adapter\n}\n\n\n\nfunc (f *fileAdapter) Level() level.LogLevel ", "output": "{\n\treturn f.logLevel\n}"}
{"input": "package logs\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"os\"\n\t\"runtime\"\n)\n\ntype Brush func(string) string\n\nfunc NewBrush(color string) Brush {\n\tpre := \"\\033[\"\n\treset := \"\\033[0m\"\n\treturn func(text string) string {\n\t\treturn pre + color + \"m\" + text + reset\n\t}\n}\n\nvar colors = []Brush{\n\tNewBrush(\"1;37\"), \n\tNewBrush(\"1;36\"), \n\tNewBrush(\"1;35\"), \n\tNewBrush(\"1;31\"), \n\tNewBrush(\"1;33\"), \n\tNewBrush(\"1;32\"), \n\tNewBrush(\"1;34\"), \n\tNewBrush(\"1;34\"), \n}\n\n\ntype ConsoleWriter struct {\n\tlg    *log.Logger\n\tLevel int `json:\"level\"`\n}\n\n\nfunc NewConsole() LoggerInterface {\n\tcw := new(ConsoleWriter)\n\tcw.lg = log.New(os.Stdout, \"\", log.Ldate|log.Ltime)\n\tcw.Level = LevelDebug\n\treturn cw\n}\n\n\n\nfunc (c *ConsoleWriter) Init(jsonconfig string) error {\n\tif len(jsonconfig) == 0 {\n\t\treturn nil\n\t}\n\terr := json.Unmarshal([]byte(jsonconfig), c)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\nfunc (c *ConsoleWriter) WriteMsg(msg string, level int) error {\n\tif level > c.Level {\n\t\treturn nil\n\t}\n\tif goos := runtime.GOOS; goos == \"windows\" {\n\t\tc.lg.Println(msg)\n\t} else {\n\t\tc.lg.Println(colors[level](msg))\n\t}\n\treturn nil\n}\n\n\nfunc (c *ConsoleWriter) Destroy() {\n\n}\n\n\nfunc (c *ConsoleWriter) Flush() {\n\n}\n\n\n\nfunc init() ", "output": "{\n\tRegister(\"console\", NewConsole)\n}"}
{"input": "package sphero\n\nimport (\n\t\"io\"\n\n\t\"gobot.io/x/gobot\"\n\n\tserial \"go.bug.st/serial.v1\"\n)\n\n\ntype Adaptor struct {\n\tname      string\n\tport      string\n\tsp        io.ReadWriteCloser\n\tconnected bool\n\tconnect   func(string) (io.ReadWriteCloser, error)\n}\n\n\nfunc NewAdaptor(port string) *Adaptor {\n\treturn &Adaptor{\n\t\tname: gobot.DefaultName(\"Sphero\"),\n\t\tport: port,\n\t\tconnect: func(port string) (io.ReadWriteCloser, error) {\n\t\t\treturn serial.Open(port, &serial.Mode{BaudRate: 115200})\n\t\t},\n\t}\n}\n\n\nfunc (a *Adaptor) Name() string { return a.name }\n\n\nfunc (a *Adaptor) SetName(n string) { a.name = n }\n\n\nfunc (a *Adaptor) Port() string { return a.port }\n\n\nfunc (a *Adaptor) SetPort(p string) { a.port = p }\n\n\nfunc (a *Adaptor) Connect() (err error) {\n\tsp, e := a.connect(a.Port())\n\tif e != nil {\n\t\treturn e\n\t}\n\n\ta.sp = sp\n\ta.connected = true\n\treturn\n}\n\n\n\n\n\n\n\nfunc (a *Adaptor) Disconnect() error {\n\tif a.connected {\n\t\tif e := a.sp.Close(); e != nil {\n\t\t\treturn e\n\t\t}\n\t\ta.connected = false\n\t}\n\treturn nil\n}\n\n\nfunc (a *Adaptor) Finalize() error {\n\treturn a.Disconnect()\n}\n\nfunc (a *Adaptor) Reconnect() (err error) ", "output": "{\n\tif a.connected {\n\t\ta.Disconnect()\n\t}\n\treturn a.Connect()\n}"}
{"input": "package crypto\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n)\n\n\nfunc HS512Byte(in, secret []byte) []byte {\n\th := hmac.New(sha512.New, secret)\n\th.Write(in)\n\treturn h.Sum(nil)\n}\n\n\nfunc HS512Base64(in, secret string) string {\n\tkey := []byte(secret)\n\th := hmac.New(sha512.New, key)\n\th.Write([]byte(in))\n\treturn base64.StdEncoding.EncodeToString(h.Sum(nil))\n}\n\n\n\n\n\nfunc CompareHS512Hex(in, secret, hs512Hex string) bool {\n\tif HS512Hex(in, secret) == hs512Hex {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc HS512Hex(in, secret string) string ", "output": "{\n\tkey := []byte(secret)\n\th := hmac.New(sha512.New, key)\n\th.Write([]byte(in))\n\treturn hex.EncodeToString(h.Sum(nil))\n}"}
{"input": "package addon\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"time\"\n)\n\nconst graceSeconds = 120\n\ntype AccessToken struct {\n\tValue     string `json:\"access_token\"`\n\tTokenType string `json:\"token_type\"`\n\tScope     string `json:\"scope\"`\n\tExpiresIn int32  `json:\"expires_in\"`\n\tExpiresAt int64  `json:\"-\"`\n}\n\n\n\nfunc (t *AccessToken) Valid() bool {\n\treturn t.Value != \"\" && !t.IsExpired()\n}\n\nfunc (t *AccessToken) String() string {\n\treturn t.Value\n}\n\nfunc NewAccessTokenFromJson(r io.Reader) (*AccessToken, error) {\n\n\ttoken := &AccessToken{}\n\n\tif err := json.NewDecoder(r).Decode(token); err != nil {\n\t\treturn nil, err\n\t}\n\n\ttoken.ExpiresAt = nextUnixExpiry(token.ExpiresIn)\n\n\treturn token, nil\n}\n\nfunc nextUnixExpiry(secondsFromNow int32) int64 {\n\treturn time.Now().Unix() + int64(secondsFromNow) - graceSeconds\n}\n\nfunc (t *AccessToken) IsExpired() bool ", "output": "{\n\treturn t.ExpiresAt < time.Now().Unix()\n}"}
{"input": "package digest\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\n\t\"github.com/scionproto/scion/go/lib/serrors\"\n\tcppb \"github.com/scionproto/scion/go/pkg/proto/control_plane\"\n)\n\ntype Digest struct {\n\tDigest []byte\n}\n\nconst DigestLength = 16\n\ntype Extension struct {\n\tEpic Digest\n}\n\nfunc ExtensionFromPB(d *cppb.DigestExtension) *Extension {\n\tif d == nil {\n\t\treturn nil\n\t}\n\tif d.Epic == nil {\n\t\treturn &Extension{\n\t\t\tEpic: Digest{},\n\t\t}\n\t}\n\te := make([]byte, DigestLength)\n\tcopy(e, d.Epic.Digest)\n\treturn &Extension{\n\t\tEpic: Digest{\n\t\t\tDigest: e,\n\t\t},\n\t}\n}\n\nfunc ExtensionToPB(d *Extension) *cppb.DigestExtension {\n\tif d == nil {\n\t\treturn nil\n\t}\n\te := make([]byte, DigestLength)\n\tcopy(e, d.Epic.Digest)\n\treturn &cppb.DigestExtension{\n\t\tEpic: &cppb.DigestExtension_Digest{\n\t\t\tDigest: e,\n\t\t},\n\t}\n}\n\nfunc (d *Digest) Set(input []byte) {\n\td.Digest = calculateDigest(input)\n}\n\nfunc (d *Digest) Validate(input []byte) error {\n\tb := calculateDigest(input)\n\tif !bytes.Equal(b, d.Digest) {\n\t\treturn serrors.New(\"digest validation failed\", \"calculated\", hex.EncodeToString(b),\n\t\t\t\"stored\", hex.EncodeToString(d.Digest))\n\t}\n\treturn nil\n}\n\n\n\nfunc calculateDigest(input []byte) []byte ", "output": "{\n\th := sha256.New()\n\th.Write(input)\n\treturn h.Sum(nil)[0:DigestLength]\n}"}
{"input": "package access_manager\n\n\n\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/go-openapi/runtime\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"openpitrix.io/openpitrix/test/models\"\n)\n\n\ntype CanDoReader struct {\n\tformats strfmt.Registry\n}\n\n\nfunc (o *CanDoReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {\n\tswitch response.Code() {\n\n\tcase 200:\n\t\tresult := NewCanDoOK()\n\t\tif err := result.readResponse(response, consumer, o.formats); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn result, nil\n\n\tdefault:\n\t\treturn nil, runtime.NewAPIError(\"unknown error\", response, response.Code())\n\t}\n}\n\n\nfunc NewCanDoOK() *CanDoOK {\n\treturn &CanDoOK{}\n}\n\n\ntype CanDoOK struct {\n\tPayload *models.OpenpitrixCanDoResponse\n}\n\nfunc (o *CanDoOK) Error() string {\n\treturn fmt.Sprintf(\"[POST /v1/cando][%d] canDoOK  %+v\", 200, o.Payload)\n}\n\n\n\nfunc (o *CanDoOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error ", "output": "{\n\n\to.Payload = new(models.OpenpitrixCanDoResponse)\n\n\tif err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package objectstorage\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n\t\"net/http\"\n)\n\n\ntype ListMultipartUploadsRequest struct {\n\n\tNamespaceName *string `mandatory:\"true\" contributesTo:\"path\" name:\"namespaceName\"`\n\n\tBucketName *string `mandatory:\"true\" contributesTo:\"path\" name:\"bucketName\"`\n\n\tLimit *int `mandatory:\"false\" contributesTo:\"query\" name:\"limit\"`\n\n\tPage *string `mandatory:\"false\" contributesTo:\"query\" name:\"page\"`\n\n\tOpcClientRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-client-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request ListMultipartUploadsRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request ListMultipartUploadsRequest) HTTPRequest(method, path string) (http.Request, error) {\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\n\n\n\ntype ListMultipartUploadsResponse struct {\n\n\tRawResponse *http.Response\n\n\tItems []MultipartUpload `presentIn:\"body\"`\n\n\tOpcClientRequestId *string `presentIn:\"header\" name:\"opc-client-request-id\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n\n\tOpcNextPage *string `presentIn:\"header\" name:\"opc-next-page\"`\n}\n\nfunc (response ListMultipartUploadsResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response ListMultipartUploadsResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request ListMultipartUploadsRequest) RetryPolicy() *common.RetryPolicy ", "output": "{\n\treturn request.RequestMetadata.RetryPolicy\n}"}
{"input": "package redis_test\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/go-redis/redis\"\n\tredistrace \"gopkg.in/DataDog/dd-trace-go.v1/contrib/go-redis/redis\"\n\t\"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/ext\"\n\t\"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer\"\n)\n\n\n\nfunc Example() {\n\topts := &redis.Options{Addr: \"127.0.0.1\", Password: \"\", DB: 0}\n\tc := redistrace.NewClient(opts)\n\n\tc.Set(\"test_key\", \"test_value\", 0)\n\n\troot, ctx := tracer.StartSpanFromContext(context.Background(), \"parent.request\",\n\t\ttracer.SpanType(ext.SpanTypeRedis),\n\t\ttracer.ServiceName(\"web\"),\n\t\ttracer.ResourceName(\"/home\"),\n\t)\n\n\tc = c.WithContext(ctx)\n\n\tc.Set(\"food\", \"cheese\", 0)\n\troot.Finish()\n}\n\n\n\n\n\nfunc Example_pipeliner() ", "output": "{\n\topts := &redis.Options{Addr: \"127.0.0.1\", Password: \"\", DB: 0}\n\tc := redistrace.NewClient(opts, redistrace.WithServiceName(\"my-redis-service\"))\n\n\tpipe := c.Pipeline()\n\n\tpipe.Incr(\"pipeline_counter\")\n\tpipe.Expire(\"pipeline_counter\", time.Hour)\n\n\tpipe.Exec()\n}"}
{"input": "package wire\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\nconst (\n\tMaxFilterAddDataSize = 520\n)\n\n\n\n\n\n\ntype MsgFilterAdd struct {\n\tData []byte\n}\n\n\n\nfunc (msg *MsgFilterAdd) BtcDecode(r io.Reader, pver uint32, enc MessageEncoding) error {\n\tif pver < BIP0037Version {\n\t\tstr := fmt.Sprintf(\"filteradd message invalid for protocol \"+\n\t\t\t\"version %d\", pver)\n\t\treturn messageError(\"MsgFilterAdd.BtcDecode\", str)\n\t}\n\n\tvar err error\n\tmsg.Data, err = ReadVarBytes(r, pver, MaxFilterAddDataSize,\n\t\t\"filteradd data\")\n\treturn err\n}\n\n\n\nfunc (msg *MsgFilterAdd) BtcEncode(w io.Writer, pver uint32, enc MessageEncoding) error {\n\tif pver < BIP0037Version {\n\t\tstr := fmt.Sprintf(\"filteradd message invalid for protocol \"+\n\t\t\t\"version %d\", pver)\n\t\treturn messageError(\"MsgFilterAdd.BtcEncode\", str)\n\t}\n\n\tsize := len(msg.Data)\n\tif size > MaxFilterAddDataSize {\n\t\tstr := fmt.Sprintf(\"filteradd size too large for message \"+\n\t\t\t\"[size %v, max %v]\", size, MaxFilterAddDataSize)\n\t\treturn messageError(\"MsgFilterAdd.BtcEncode\", str)\n\t}\n\n\treturn WriteVarBytes(w, pver, msg.Data)\n}\n\n\n\nfunc (msg *MsgFilterAdd) Command() string {\n\treturn CmdFilterAdd\n}\n\n\n\n\n\n\n\nfunc NewMsgFilterAdd(data []byte) *MsgFilterAdd {\n\treturn &MsgFilterAdd{\n\t\tData: data,\n\t}\n}\n\nfunc (msg *MsgFilterAdd) MaxPayloadLength(pver uint32) uint32 ", "output": "{\n\treturn uint32(VarIntSerializeSize(MaxFilterAddDataSize)) +\n\t\tMaxFilterAddDataSize\n}"}
{"input": "package service\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\n\n\nfunc Test_Action(t *testing.T) ", "output": "{\n\tvar (\n\t\tmid int64 = 14771787\n\t\taid int64 = 4052445\n\t\ttid int64 = 10176\n\t\tnow       = time.Now()\n\t)\n\tConvey(\"testLike service\", t, WithService(func(s *Service) {\n\t\ttestSvc.Like(context.Background(), mid, aid, tid, now)\n\t}))\n\tConvey(\"testHate service\", t, WithService(func(s *Service) {\n\t\ttestSvc.Hate(context.Background(), mid, aid, tid, now)\n\t}))\n}"}
{"input": "package appui\n\nimport (\n\t\"image\"\n\t\"testing\"\n\n\ttermui \"github.com/gizak/termui\"\n\t\"github.com/moncho/dry/docker\"\n\t\"github.com/moncho/dry/ui\"\n)\n\ntype dockerMonitor struct {\n}\n\nfunc (dockerMonitor) Containers(filters []docker.ContainerFilter, mode docker.SortMode) []*docker.Container {\n\treturn nil\n}\n\nfunc (dockerMonitor) StatsChannel(container *docker.Container) (*docker.StatsChannel, error) {\n\treturn nil, nil\n}\n\ntype screenBuffererRender struct {\n}\n\nfunc (screenBuffererRender) Bounds() image.Rectangle {\n\treturn image.Rectangle{}\n}\n\n\nfunc (screenBuffererRender) Flush() *ui.Screen {\n\treturn nil\n}\nfunc (screenBuffererRender) RenderBufferer(bs ...termui.Bufferer) {\n\n}\n\nfunc TestMonitor_RepeatedUnmount(t *testing.T) {\n\ttype fields struct {\n\t\tdaemon   DockerMonitor\n\t\trenderer ScreenBuffererRender\n\t}\n\tm := NewMonitor(dockerMonitor{}, screenBuffererRender{})\n\tm.Mount()\n\tm.Unmount()\n\tm.Unmount()\n}\n\nfunc (screenBuffererRender) Cursor() *ui.Cursor ", "output": "{\n\treturn &ui.Cursor{}\n}"}
{"input": "package core\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n)\n\ntype Pin struct {\n\tpfd *os.File\n\tmfd *os.File\n\tio  byte\n}\n\nfunc (this *Pin) Init() (err error) {\n\tname := fmt.Sprintf(\"%s%s%d\", GPIO_PIN_DIR, GPIO_IF_PREFIX, this.io)\n\tif this.pfd, err = os.OpenFile(name, os.O_RDWR, 0644); err != nil {\n\t\treturn\n\t}\n\tname = fmt.Sprintf(\"%s%s%d\", GPIO_MODE_DIR, GPIO_IF_PREFIX, this.io)\n\tif this.mfd, err = os.OpenFile(name, os.O_RDWR, 0644); err != nil {\n\t\treturn\n\t}\n\truntime.SetFinalizer(this, func(p *Pin) {\n\t\tif p.pfd != nil {\n\t\t\tp.pfd.Close()\n\t\t}\n\t\tif p.mfd != nil {\n\t\t\tp.mfd.Close()\n\t\t}\n\t})\n\treturn nil\n}\n\nfunc NewPin(pin byte) (*Pin, error) {\n\tp := &Pin{}\n\tp.io = pin\n\treturn p, p.Init()\n}\n\n\n\nfunc (this *Pin) DigitalWrite(value byte) {\n\tDigitalWrite(this.io, value)\n}\n\nfunc (this *Pin) DigitalRead() byte {\n\treturn DigitalRead(this.io)\n}\n\nfunc (this *Pin) Mode(mode byte) (err error) ", "output": "{\n\tdefer func() {\n\t\te := recover()\n\t\tif e == nil {\n\t\t\treturn\n\t\t}\n\t\tif panicErr, ok := e.(error); ok {\n\t\t\terr = panicErr\n\t\t}\n\t}()\n\tPinMode(this.io, mode)\n\treturn err\n}"}
{"input": "package util\n\ntype Bool struct {\n\tb bool\n}\n\nfunc (b *Bool) Value() bool {\n\treturn b.b\n}\n\nvar True = &Bool{true}\nvar False = &Bool{false}\n\n\n\nfunc BoolFor(val bool) *Bool ", "output": "{\n\tif val {\n\t\treturn True\n\t}\n\treturn False\n}"}
{"input": "package log\n\nimport (\n\t\"github.com/sirupsen/logrus\"\n)\n\ntype LogLevel uint32\n\nconst (\n\tPanicLevel LogLevel = iota\n\tFatalLevel\n\tErrorLevel\n\tWarnLevel\n\tInfoLevel\n\tDebugLevel\n\tTraceLevel\n)\n\ntype Fields map[string]interface{}\n\ntype Logger interface {\n\tPanic(msg string, fields Fields)\n\tFatal(msg string, fields Fields)\n\tError(msg string, fields Fields)\n\tWarn(msg string, fields Fields)\n\tInfo(msg string, fields Fields)\n\tDebug(msg string, fields Fields)\n\tSetLevel(level LogLevel)\n\tGetLevel() LogLevel\n}\n\ntype DefaultLogger struct {\n\tlogger *logrus.Logger\n}\n\nfunc (l *DefaultLogger) Panic(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Panic(msg)\n}\n\nfunc (l *DefaultLogger) Fatal(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Fatal(msg)\n}\n\nfunc (l *DefaultLogger) Error(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Error(msg)\n}\n\nfunc (l *DefaultLogger) Warn(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Warn(msg)\n}\n\nfunc (l *DefaultLogger) Info(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Info(msg)\n}\n\nfunc (l *DefaultLogger) Debug(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Debug(msg)\n}\n\nfunc (l *DefaultLogger) SetLevel(level LogLevel) {\n\tl.logger.SetLevel(logrus.Level(level))\n}\n\nfunc (l *DefaultLogger) GetLevel() LogLevel {\n\treturn LogLevel(l.logger.GetLevel())\n}\n\n\n\nfunc NewDefaultLogger() *DefaultLogger ", "output": "{\n\treturn &DefaultLogger{\n\t\tlogger: logrus.New(),\n\t}\n}"}
{"input": "package common\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"strings\"\n)\n\ntype Repository struct {\n\tURL       string `json:\"url,omitempty\"`\n\turlPieces []string\n}\n\nfunc (r *Repository) urlFragment(n int) *string {\n\tif r.urlPieces == nil {\n\t\tr.urlPieces = strings.Split(r.URL, \"/\")\n\t}\n\treturn &r.urlPieces[n]\n}\n\nfunc (r *Repository) Host() *string {\n\treturn r.urlFragment(0)\n}\n\nfunc (r *Repository) Owner() *string {\n\treturn r.urlFragment(1)\n}\n\nfunc (r *Repository) Name() *string {\n\treturn r.urlFragment(2)\n}\n\n\n\nfunc LoadRepositories(filename string) (*[]Repository, error) ", "output": "{\n\tdata, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trs := []Repository{}\n\tif err := json.Unmarshal(data, &rs); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &rs, nil\n}"}
{"input": "package fake\n\nimport (\n\tv1beta1 \"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/clients/generated/client/clientset/versioned/typed/privateca/v1beta1\"\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n)\n\ntype FakePrivatecaV1beta1 struct {\n\t*testing.Fake\n}\n\nfunc (c *FakePrivatecaV1beta1) PrivateCACAPools(namespace string) v1beta1.PrivateCACAPoolInterface {\n\treturn &FakePrivateCACAPools{c, namespace}\n}\n\nfunc (c *FakePrivatecaV1beta1) PrivateCACertificateAuthorities(namespace string) v1beta1.PrivateCACertificateAuthorityInterface {\n\treturn &FakePrivateCACertificateAuthorities{c, namespace}\n}\n\n\n\n\n\nfunc (c *FakePrivatecaV1beta1) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakePrivatecaV1beta1) PrivateCACertificateTemplates(namespace string) v1beta1.PrivateCACertificateTemplateInterface ", "output": "{\n\treturn &FakePrivateCACertificateTemplates{c, namespace}\n}"}
{"input": "package profiling\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/keybase/client/go/logger\"\n\t\"github.com/keybase/clockwork\"\n\t\"golang.org/x/net/context\"\n)\n\ntype ctxKeyType string\n\nvar ctxKey = ctxKeyType(\"timebuckets\")\n\ntype TimeBuckets struct {\n\tsync.Mutex\n\tclock clockwork.Clock\n\tlog   logger.Logger\n\ttimes map[string]time.Duration\n}\n\nfunc NewTimeBuckets(clock clockwork.Clock, log logger.Logger) *TimeBuckets {\n\treturn &TimeBuckets{\n\t\tclock: clock,\n\t\tlog:   log,\n\t\ttimes: make(map[string]time.Duration),\n\t}\n}\n\n\n\nfunc (t *TimeBuckets) Get(bucketName string) time.Duration {\n\tt.Lock()\n\tdefer t.Unlock()\n\treturn t.times[bucketName]\n}\n\nfunc (t *TimeBuckets) Log(ctx context.Context, bucketName string) {\n\tt.log.CDebugf(ctx, \"TimeBucket %s [time=%s]\", bucketName, t.Get(bucketName))\n}\n\nfunc (t *TimeBuckets) LogIfNonZero(ctx context.Context, bucketName string) {\n\td := t.Get(bucketName)\n\tif d != 0 {\n\t\tt.log.CDebugf(ctx, \"TimeBucket %s [time=%s]\", bucketName, d)\n\t}\n}\n\ntype FinFn func()\n\nfunc WithTimeBuckets(ctx context.Context, clock clockwork.Clock, log logger.Logger) (context.Context, *TimeBuckets) {\n\tv, ok := ctx.Value(ctxKey).(*TimeBuckets)\n\tif ok && v != nil {\n\t\treturn ctx, v\n\t}\n\tbuckets := NewTimeBuckets(clock, log)\n\tctx = context.WithValue(ctx, ctxKey, buckets)\n\treturn ctx, buckets\n}\n\nfunc (t *TimeBuckets) Record(bucketName string) FinFn ", "output": "{\n\tstart := t.clock.Now()\n\treturn func() {\n\t\tduration := t.clock.Since(start)\n\t\tt.Lock()\n\t\tdefer t.Unlock()\n\t\tt.times[bucketName] += duration\n\t}\n}"}
{"input": "package send\n\nimport (\n\t\"bytes\"\n\n\t\"github.com/webx-top/echo/param\"\n)\n\n\n\n\n\ntype Content struct {\n\temailContent    []byte\n\tmarkdownContent []byte\n}\n\n\nfunc (c *Content) EmailContent(params param.Store) []byte {\n\tif c.emailContent == nil {\n\t\tb := new(bytes.Buffer)\n\t\tMailTpl().Execute(b, params)\n\t\tc.emailContent = b.Bytes()\n\t}\n\treturn c.emailContent\n}\n\n\nfunc (c *Content) MarkdownContent(params param.Store) []byte {\n\tif c.markdownContent == nil {\n\t\tb := new(bytes.Buffer)\n\t\tMarkdownTmpl().Execute(b, params)\n\t\tc.markdownContent = b.Bytes()\n\t}\n\treturn c.markdownContent\n}\n\nfunc NewContent() *Content ", "output": "{\n\treturn &Content{}\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/snapcore/snapd/seed\"\n)\n\nvar (\n\tRun                      = run\n\tSystemSnapFromSeed       = systemSnapFromSeed\n\tChooseTargetSnapdVersion = chooseTargetSnapdVersion\n)\n\nfunc MockOsGetuid(f func() int) (restore func()) {\n\toldOsGetuid := osGetuid\n\tosGetuid = f\n\treturn func() { osGetuid = oldOsGetuid }\n}\n\n\n\nfunc MockSnapdMountPath(path string) (restore func()) {\n\toldMountPath := snapdMountPath\n\tsnapdMountPath = path\n\treturn func() { snapdMountPath = oldMountPath }\n}\n\nfunc MockSystemSnapFromSeed(f func(rootDir string) (string, error)) (restore func()) {\n\toldSystemSnapFromSeed := systemSnapFromSeed\n\tsystemSnapFromSeed = f\n\treturn func() { systemSnapFromSeed = oldSystemSnapFromSeed }\n}\n\nfunc MockSeedOpen(f func(rootDir, label string) (seed.Seed, error)) (restore func()) {\n\toldSeedOpen := seedOpen\n\tseedOpen = f\n\treturn func() {\n\t\tseedOpen = oldSeedOpen\n\t}\n}\n\nfunc SnapdPathAndVersion(targetSnapd *targetSnapdInfo) (string, string) {\n\treturn targetSnapd.path, targetSnapd.version\n}\n\nfunc MockSyscallChroot(f func(string) error) (restore func()) ", "output": "{\n\toldSyscallChroot := syscallChroot\n\tsyscallChroot = f\n\treturn func() { syscallChroot = oldSyscallChroot }\n}"}
{"input": "package chatwork\n\nimport (\n\t\"encoding/json\"\n\t\"net/url\"\n\t\"strings\"\n)\n\ntype MessageResult struct {\n\tMessageId int `json:\"message_id\"`\n}\n\nvar format string = \"/rooms/{roomId}/messages\"\n\n\n\nfunc escapeMessage(message string) string {\n\treplacer := strings.NewReplacer(\"&\", \"&amp;\", \"<\", \"&lt;\", \">\", \"&gt;\")\n\treturn replacer.Replace(message)\n}\n\nfunc (api *Client) PostMessage(roomId, text string) int ", "output": "{\n\ttext = escapeMessage(text)\n\tapiUrl := CHATWORK_API + strings.Replace(format, \"{roomId}\", roomId, 1)\n\n\tvalues := url.Values{}\n\tvalues.Add(\"body\", text)\n\n\tcontents := api.Request(\"POST\", apiUrl, values.Encode())\n\tvar result MessageResult\n\tjson.Unmarshal(contents, &result)\n\treturn result.MessageId\n}"}
{"input": "package cat\n\nimport(\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/ProhtMeyhet/libgosimpleton/iotool\"\n\t\"github.com/ProhtMeyhet/libgosimpleton/parallel\"\n\n\t\"github.com/ProhtMeyhet/gonixutils/library/abstract\"\n)\n\n\n\n\nfunc CopyFilesTo(mainOutput abstract.OutputInterface, helper *iotool.FileHelper, paths ...string) (e error) {\n\treturn CopyFilesFilteredTo(mainOutput, helper, nil, paths...)\n}\n\nfunc CopyFilesFilteredTo(mainOutput abstract.OutputInterface, helper *iotool.FileHelper,\n\t\tfilter func(io.Reader) io.Reader, paths ...string) (e error) {\n\toutput := mainOutput\n\tparallel.ReadFilesSequential(helper, paths, func(buffered *iotool.NamedBuffer) {\n\t\tvar filtered io.Reader\n\t\tif output.PrintSubBufferNames() {\n\t\t\toutput = mainOutput.NewSubBuffer(fmt.Sprintf(\"==>%v<==\\n\", buffered.Name()), 0)\n\t\t}\n\n\t\tif filter != nil { filtered = filter(buffered) }\n\t\tif filtered == nil { filtered = buffered }\n\n\t\t_, e = io.Copy(output, filtered)\n\t\tif output.PrintSubBufferNames() { output.Done() }\n\t}).Wait(); return\n}\n\nfunc Cat(input *Input) (exitCode uint8) ", "output": "{\n\toutput := abstract.NewOutput(input.Stdout, input.Stderr)\n\tif input.Verbose { output.TogglePrintSubBufferNames() }\n\thelper := prepareFileHelper(input, output, &exitCode)\n\n\te := CopyFilesTo(output, helper, input.Paths...); if e != nil && exitCode == 0 {\n\t\texitCode = abstract.ERROR_UNHANDLED\n\t}\n\n\toutput.Done(); output.Wait(); return\n}"}
{"input": "package raft\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype waitItem struct {\n\tch chan interface{}\n\tcb func()\n\tcancel func()\n}\n\ntype wait struct {\n\tl sync.Mutex\n\tm map[uint64]waitItem\n}\n\nfunc newWait() *wait {\n\treturn &wait{m: make(map[uint64]waitItem)}\n}\n\n\n\nfunc (w *wait) trigger(id uint64, x interface{}) bool {\n\tw.l.Lock()\n\twaitItem, ok := w.m[id]\n\tdelete(w.m, id)\n\tw.l.Unlock()\n\tif ok {\n\t\tif waitItem.cb != nil {\n\t\t\twaitItem.cb()\n\t\t}\n\t\twaitItem.ch <- x\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (w *wait) cancel(id uint64) {\n\tw.l.Lock()\n\twaitItem, ok := w.m[id]\n\tdelete(w.m, id)\n\tw.l.Unlock()\n\tif ok {\n\t\tif waitItem.cancel != nil {\n\t\t\twaitItem.cancel()\n\t\t}\n\t\tclose(waitItem.ch)\n\t}\n}\n\nfunc (w *wait) cancelAll() {\n\tw.l.Lock()\n\tdefer w.l.Unlock()\n\n\tfor id, waitItem := range w.m {\n\t\tdelete(w.m, id)\n\t\tif waitItem.cancel != nil {\n\t\t\twaitItem.cancel()\n\t\t}\n\t\tclose(waitItem.ch)\n\t}\n}\n\nfunc (w *wait) register(id uint64, cb func(), cancel func()) <-chan interface{} ", "output": "{\n\tw.l.Lock()\n\tdefer w.l.Unlock()\n\t_, ok := w.m[id]\n\tif !ok {\n\t\tch := make(chan interface{}, 1)\n\t\tw.m[id] = waitItem{ch: ch, cb: cb, cancel: cancel}\n\t\treturn ch\n\t}\n\tpanic(fmt.Sprintf(\"duplicate id %x\", id))\n}"}
{"input": "package table\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/documize/community/core/env\"\n\t\"github.com/documize/community/domain/section/provider\"\n\t\"github.com/documize/community/domain/store\"\n)\n\n\ntype Provider struct {\n\tRuntime *env.Runtime\n\tStore   *store.Store\n}\n\n\n\n\n\nfunc (*Provider) Command(ctx *provider.Context, w http.ResponseWriter, r *http.Request) {\n\tprovider.WriteEmpty(w)\n}\n\n\nfunc (*Provider) Render(ctx *provider.Context, config, data string) string {\n\treturn data\n}\n\n\nfunc (*Provider) Refresh(ctx *provider.Context, config, data string) string {\n\treturn data\n}\n\nfunc (*Provider) Meta() provider.TypeMeta ", "output": "{\n\tsection := provider.TypeMeta{}\n\n\tsection.ID = \"81a2ea93-2dfc-434d-841e-54b832492c92\"\n\tsection.Title = \"Tabular\"\n\tsection.Description = \"Rows, columns for tabular data\"\n\tsection.ContentType = \"table\"\n\tsection.PageType = \"section\"\n\tsection.Order = 9996\n\tsection.Retired = true\n\n\treturn section\n}"}
{"input": "package ig\n\nimport \"fmt\"\n\n\nfunc (ic *IntelliClimate) SetTempTarget(target float64) error {\n\treturn fmt.Errorf(\"not implemented\")\n}\n\n\nfunc (ic *IntelliClimate) SetCO2Target(target float64) error {\n\treturn fmt.Errorf(\"not implemented\")\n}\n\n\nfunc (ic *IntelliClimate) SetRHTarget(target float64) error {\n\treturn fmt.Errorf(\"not implemented\")\n}\n\n\n\n\n\nfunc (ic *IntelliClimate) DisableCO2Dosing() error {\n\treturn fmt.Errorf(\"not implemented\")\n}\n\nfunc (ic *IntelliClimate) EnableCO2Dosing() error ", "output": "{\n\treturn fmt.Errorf(\"not implemented\")\n}"}
{"input": "package gstruct\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/onsi/gomega/format\"\n\t\"github.com/onsi/gomega/types\"\n)\n\n\n\n\n\nfunc PointTo(matcher types.GomegaMatcher) types.GomegaMatcher {\n\treturn &PointerMatcher{\n\t\tMatcher: matcher,\n\t}\n}\n\ntype PointerMatcher struct {\n\tMatcher types.GomegaMatcher\n\n\tfailure string\n}\n\nfunc (m *PointerMatcher) Match(actual interface{}) (bool, error) {\n\tval := reflect.ValueOf(actual)\n\n\tif val.Kind() != reflect.Ptr {\n\t\treturn false, fmt.Errorf(\"PointerMatcher expects a pointer but we have '%s'\", val.Kind())\n\t}\n\n\tif !val.IsValid() || val.IsNil() {\n\t\tm.failure = format.Message(actual, \"not to be <nil>\")\n\t\treturn false, nil\n\t}\n\n\telem := val.Elem().Interface()\n\tmatch, err := m.Matcher.Match(elem)\n\tif !match {\n\t\tm.failure = m.Matcher.FailureMessage(elem)\n\t}\n\treturn match, err\n}\n\nfunc (m *PointerMatcher) FailureMessage(_ interface{}) (message string) {\n\treturn m.failure\n}\n\n\n\nfunc (m *PointerMatcher) NegatedFailureMessage(actual interface{}) (message string) ", "output": "{\n\treturn m.Matcher.NegatedFailureMessage(actual)\n}"}
{"input": "package stringset\n\nvar exists = struct{}{}\n\ntype Set struct {\n\tm map[string]struct{}\n}\n\ntype EnumerateFunc func(str string)\n\nfunc NewSet(strs...string) *Set {\n\ts := &Set{\n\t\tm: make(map[string]struct{}),\n\t}\n\ts.Add(strs...)\n\treturn s\n}\n\nfunc (s *Set) Add(values ...string) {\n\tfor _, v := range values {\n\t\ts.m[v] = exists\n\t}\n}\n\nfunc (s *Set) Remove(values ...string) {\n\tfor _, v := range values {\n\t\tdelete(s.m, v)\n\t}\n}\n\nfunc (s *Set) Contains(value string) bool {\n\t_, c := s.m[value]\n\treturn c\n}\n\nfunc (s *Set) Enumerate(f EnumerateFunc) {\n\tfor key := range s.m {\n\t\tf(key)\n\t}\n}\n\nfunc (s *Set) Merge(another *Set) {\n\tanother.Enumerate(func(str string) {\n\t\ts.Add(str)\n\t})\n}\n\n\n\nfunc (s *Set) Length() int {\n\treturn len(s.m)\n}\n\nfunc (s *Set) GetSlice() []string ", "output": "{\n\tslice := make([]string, 0 ,len(s.m))\n\ts.Enumerate(func(str string) {\n\t\tslice = append(slice, str)\n\t})\n\treturn slice\n}"}
{"input": "package bitswap\n\nimport (\n\tbsnet \"github.com/ipfs/go-ipfs/exchange/bitswap/network\"\n\tmockrouting \"github.com/ipfs/go-ipfs/routing/mock\"\n\ttestutil \"github.com/ipfs/go-ipfs/thirdparty/testutil\"\n\tpeer \"gx/ipfs/QmQGwpJy9P4yXZySmqkZEXCmbBpJUb8xntCv8Ca4taZwDC/go-libp2p-peer\"\n\tds \"gx/ipfs/QmZ6A6P6AMo8SR3jXAwzTuSU6B9R2Y4eqW2yW9VvfUayDN/go-datastore\"\n\tcontext \"gx/ipfs/QmZy2y8t9zQH2a1b8q2ZSLKp17ATuJoCNxxyMFG5qFExpt/go-net/context\"\n\tmockpeernet \"gx/ipfs/QmdBpVuSYuTGDA8Kn66CbKvEThXqKUh2nTANZEhzSxqrmJ/go-libp2p/p2p/net/mock\"\n)\n\ntype peernet struct {\n\tmockpeernet.Mocknet\n\troutingserver mockrouting.Server\n}\n\nfunc StreamNet(ctx context.Context, net mockpeernet.Mocknet, rs mockrouting.Server) (Network, error) {\n\treturn &peernet{net, rs}, nil\n}\n\n\n\nfunc (pn *peernet) HasPeer(p peer.ID) bool {\n\tfor _, member := range pn.Mocknet.Peers() {\n\t\tif p == member {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nvar _ Network = &peernet{}\n\nfunc (pn *peernet) Adapter(p testutil.Identity) bsnet.BitSwapNetwork ", "output": "{\n\tclient, err := pn.Mocknet.AddPeer(p.PrivateKey(), p.Address())\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\trouting := pn.routingserver.ClientWithDatastore(context.TODO(), p, ds.NewMapDatastore())\n\treturn bsnet.NewFromIpfsHost(client, routing)\n}"}
{"input": "package utils\n\nimport \"sync\"\n\ntype queueNode struct {\n\tdata interface{}\n\tnext *queueNode\n}\n\ntype queue struct {\n\thead  *queueNode\n\ttail  *queueNode\n\tcount int\n\tlock  *sync.Mutex\n}\n\nfunc NewQueue() *queue {\n\treturn &queue{lock: &sync.Mutex{}}\n}\n\nfunc (q *queue) Len() int {\n\tq.lock.Lock()\n\tdefer q.lock.Unlock()\n\n\treturn q.count\n}\n\nfunc (q *queue) Push(v interface{}) {\n\tq.lock.Lock()\n\tdefer q.lock.Unlock()\n\n\tnode := &queueNode{data: v}\n\n\tif q.tail == nil {\n\t\tq.tail = node\n\t\tq.head = node\n\t} else {\n\t\tq.tail.next = node\n\t\tq.tail = node\n\t}\n\n\tq.count++\n}\n\nfunc (q *queue) Pop() interface{} {\n\tq.lock.Lock()\n\tdefer q.lock.Unlock()\n\n\tif q.head == nil {\n\t\treturn nil\n\t}\n\n\tnode := q.head\n\tq.head = node.next\n\n\tif q.head == nil {\n\t\tq.tail = nil\n\t}\n\n\tq.count--\n\n\treturn node.data\n}\n\n\n\nfunc (q *queue) Peek() interface{} ", "output": "{\n\tq.lock.Lock()\n\tdefer q.lock.Unlock()\n\n\tnode := q.head\n\tif node == nil || node.data == nil {\n\t\treturn nil\n\t}\n\n\treturn node.data\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype String string\n\ntype Struct struct {\n\tGreeting string\n\tPunct    string\n\tWho      string\n}\n\n\n\nfunc (s Struct) ServeHTTP(\n\tw http.ResponseWriter,\n\tr *http.Request) {\n\tfmt.Fprint(w, s)\n}\n\nfunc main() {\n\thttp.Handle(\"/string\", String(\"I'm a frayed knot.\"))\n\thttp.Handle(\"/struct\", Struct{\"Hello\", \":\", \"Gophers!\"})\n\n\thttp.ListenAndServe(\"localhost:4000\", nil)\n}\n\nfunc (s String) ServeHTTP(\n\tw http.ResponseWriter,\n\tr *http.Request) ", "output": "{\n\tfmt.Fprint(w, s)\n}"}
{"input": "package fi\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/golang/glog\"\n)\n\ntype Task interface {\n\tRun(*Context) error\n}\n\n\n\n\nfunc TaskAsString(t Task) string {\n\treturn fmt.Sprintf(\"%T %s\", t, DebugAsJsonString(t))\n}\n\ntype HasCheckExisting interface {\n\tCheckExisting(c *Context) bool\n}\n\n\ntype ModelBuilder interface {\n\tBuild(context *ModelBuilderContext) error\n}\n\n\ntype ModelBuilderContext struct {\n\tTasks map[string]Task\n}\n\nfunc (c *ModelBuilderContext) AddTask(task Task) {\n\tkey := buildTaskKey(task)\n\n\texisting, found := c.Tasks[key]\n\tif found {\n\t\tglog.Fatalf(\"found duplicate tasks with name %q: %v and %v\", key, task, existing)\n\t}\n\tc.Tasks[key] = task\n}\n\n\n\n\n\nfunc (c *ModelBuilderContext) EnsureTask(task Task) error {\n\tkey := buildTaskKey(task)\n\n\texisting, found := c.Tasks[key]\n\tif found {\n\t\tif reflect.DeepEqual(task, existing) {\n\t\t\tglog.V(8).Infof(\"EnsureTask ignoring identical \")\n\t\t\treturn nil\n\t\t} else {\n\t\t\tglog.Warningf(\"EnsureTask found task mismatch for %q\", key)\n\t\t\tglog.Warningf(\"\\tExisting: %v\", existing)\n\t\t\tglog.Warningf(\"\\tNew: %v\", task)\n\n\t\t\treturn fmt.Errorf(\"cannot add different task with same key %q\", key)\n\t\t}\n\t}\n\tc.Tasks[key] = task\n\treturn nil\n}\n\n\n\nfunc TypeNameForTask(task interface{}) string {\n\ttypeName := fmt.Sprintf(\"%T\", task)\n\tlastDot := strings.LastIndex(typeName, \".\")\n\ttypeName = typeName[lastDot+1:]\n\treturn typeName\n}\n\nfunc buildTaskKey(task Task) string ", "output": "{\n\thasName, ok := task.(HasName)\n\tif !ok {\n\t\tglog.Fatalf(\"task %T does not implement HasName\", task)\n\t}\n\n\tname := StringValue(hasName.GetName())\n\tif name == \"\" {\n\t\tglog.Fatalf(\"task %T (%v) did not have a Name\", task, task)\n\t}\n\n\ttypeName := TypeNameForTask(task)\n\n\tkey := typeName + \"/\" + name\n\n\treturn key\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/pkg/errors\"\n)\n\nvar coreHousekeepingURI = CorePrefix + \"coreHousekeeping\"\n\n\nfunc coreHousekeeping(el Element, notification *ChangeNotification, trans *Transaction) error {\n\tuOfD := trans.uOfD\n\ttrans.ReadLockElement(el)\n\tunderlyingNotification := notification.GetUnderlyingChange()\n\tif underlyingNotification != nil && HasReportedPreviously(el.GetConceptID(trans), underlyingNotification) {\n\t\treturn nil\n\t}\n\terr := el.notifyListeners(notification, trans)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"coreHousekeeping failed\")\n\t}\n\tswitch el.(type) {\n\tcase Reference:\n\t\tif el.GetOwningConcept(trans) != nil && !(notification.GetNatureOfChange() == OwningConceptChanged && notification.GetReportingElementID() != el.GetConceptID(trans)) {\n\t\t\tforwardingNotification, err := uOfD.NewForwardingChangeNotification(el, ForwardedChange, notification, trans)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"coreHousekeeping failed\")\n\t\t\t}\n\t\t\terr = uOfD.queueFunctionExecutions(el.GetOwningConcept(trans), forwardingNotification, trans)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"element.SetDefinition failed\")\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n\n\n\nfunc HasReportedPreviously(elID string, notification *ChangeNotification) bool ", "output": "{\n\tif notification.GetReportingElementID() == elID {\n\t\treturn true\n\t}\n\tnestedNotification := notification.GetUnderlyingChange()\n\tif nestedNotification != nil {\n\t\treturn HasReportedPreviously(elID, nestedNotification)\n\t}\n\treturn false\n}"}
{"input": "package page\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/krix38/ScorchedGo/web/viewResolver\"\n)\n\n\n\nfunc Main(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tviewResolver.Render(w, \"main\", nil)\n}"}
{"input": "package test\n\nimport \"unicode/utf8\"\n\n\n\nfunc matchEndOfText(s string) (end int) ", "output": "{\n\tend = -1\n\tvar r rune\n\tvar rlen int\n\ti := 0\n\t_, _, _ = r, rlen, i\n\tr, rlen = utf8.DecodeRuneInString(s[i:])\n\tif rlen == 0 {\n\t\treturn\n\t}\n\ti += rlen\n\tswitch {\n\tcase r == 97:\n\t\tgoto s2\n\t}\n\treturn\ns2:\n\tswitch {\n\tcase i == len(s):\n\t\tend = i\n\t}\n\treturn\n}"}
{"input": "package framework\n\nimport (\n\t\"github.com/google/uuid\"\n)\n\n\n\nvar RunID string\n\nfunc init() {\n\tuuid, _ := uuid.NewUUID()\n\tRunID = uuid.String()\n}\n\n\n\nfunc GenPortName(name string) string ", "output": "{\n\treturn \"Port\" + name\n}"}
{"input": "package mssql \n\nimport \"gopkg.in/reform.v1\"\n\ntype mssql struct{}\n\nfunc (mssql) String() string {\n\treturn \"mssql\"\n}\n\n\n\nfunc (mssql) Placeholders(start, count int) []string {\n\tres := make([]string, count)\n\tfor i := 0; i < count; i++ {\n\t\tres[i] = \"?\"\n\t}\n\treturn res\n}\n\nfunc (mssql) QuoteIdentifier(identifier string) string {\n\treturn \"[\" + identifier + \"]\"\n}\n\nfunc (mssql) LastInsertIdMethod() reform.LastInsertIdMethod {\n\treturn reform.OutputInserted\n}\n\nfunc (mssql) SelectLimitMethod() reform.SelectLimitMethod {\n\treturn reform.SelectTop\n}\n\nfunc (mssql) DefaultValuesMethod() reform.DefaultValuesMethod {\n\treturn reform.DefaultValues\n}\n\n\nvar Dialect mssql\n\n\nvar _ reform.Dialect = Dialect\n\nfunc (mssql) Placeholder(index int) string ", "output": "{\n\treturn \"?\"\n}"}
{"input": "package api\n\n\n\ntype AgentsService struct {\n\tclient *Client\n}\n\n\ntype Agent struct {\n\tName              string   `json:\"name\"`\n\tAccessToken       string   `json:\"access_token\"`\n\tHostname          string   `json:\"hostname\"`\n\tEndpoint          string   `json:\"endpoint\"`\n\tPingInterval      int      `json:\"ping_interval\"`\n\tHearbeatInterval  int      `json:\"heartbeat_interval\"`\n\tOS                string   `json:\"os\"`\n\tArch              string   `json:\"arch\"`\n\tScriptEvalEnabled bool     `json:\"script_eval_enabled\"`\n\tPriority          string   `json:\"priority,omitempty\"`\n\tVersion           string   `json:\"version\"`\n\tBuild             string   `json:\"build\"`\n\tMetaData          []string `json:\"meta_data\"`\n\tPID               int      `json:\"pid,omitempty\"`\n}\n\n\n\nfunc (as *AgentsService) Register(agent *Agent) (*Agent, *Response, error) {\n\treq, err := as.client.NewRequest(\"POST\", \"register\", agent)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(Agent)\n\tresp, err := as.client.Do(req, a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, err\n}\n\n\nfunc (as *AgentsService) Connect() (*Response, error) {\n\treq, err := as.client.NewRequest(\"POST\", \"connect\", nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn as.client.Do(req, nil)\n}\n\n\n\n\nfunc (as *AgentsService) Disconnect() (*Response, error) ", "output": "{\n\treq, err := as.client.NewRequest(\"POST\", \"disconnect\", nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn as.client.Do(req, nil)\n}"}
{"input": "package core \n\nimport (\n\t\"sync\"\n\n\t\"barista.run/bar\"\n\tl \"barista.run/logging\"\n\t\"barista.run/sink\"\n)\n\n\n\ntype ModuleSet struct {\n\tmodules   []*Module\n\tupdateCh  chan int\n\toutputs   []bar.Segments\n\toutputsMu sync.RWMutex\n}\n\n\nfunc NewModuleSet(modules []bar.Module) *ModuleSet {\n\tset := &ModuleSet{\n\t\tmodules:  make([]*Module, len(modules)),\n\t\toutputs:  make([]bar.Segments, len(modules)),\n\t\tupdateCh: make(chan int),\n\t}\n\tfor i, m := range modules {\n\t\tl.Fine(\"%s added as %s[%d]\", l.ID(m), l.ID(set), i)\n\t\tset.modules[i] = NewModule(m)\n\t}\n\treturn set\n}\n\n\n\nfunc (m *ModuleSet) Stream() <-chan int {\n\tfor i, mod := range m.modules {\n\t\tgo mod.Stream(m.sinkFn(i))\n\t}\n\treturn m.updateCh\n}\n\n\n\n\nfunc (m *ModuleSet) Len() int {\n\treturn len(m.modules)\n}\n\n\n\nfunc (m *ModuleSet) LastOutput(idx int) bar.Segments {\n\tm.outputsMu.RLock()\n\tdefer m.outputsMu.RUnlock()\n\treturn m.outputs[idx]\n}\n\n\n\n\nfunc (m *ModuleSet) LastOutputs() []bar.Segments {\n\tm.outputsMu.RLock()\n\tdefer m.outputsMu.RUnlock()\n\tcp := make([]bar.Segments, len(m.outputs))\n\tcopy(cp, m.outputs)\n\treturn cp\n}\n\nfunc (m *ModuleSet) sinkFn(idx int) bar.Sink ", "output": "{\n\treturn sink.Func(func(out bar.Segments) {\n\t\tl.Fine(\"%s new output from %s\",\n\t\t\tl.ID(m), l.ID(m.modules[idx].original))\n\t\tm.outputsMu.Lock()\n\t\tm.outputs[idx] = out\n\t\tm.outputsMu.Unlock()\n\t\tm.updateCh <- idx\n\t})\n}"}
{"input": "package resource\n\nimport (\n\t\"github.com/aelsabbahy/goss/system\"\n\t\"github.com/aelsabbahy/goss/util\"\n)\n\ntype Gossfile struct {\n\tTitle string `json:\"title,omitempty\" yaml:\"title,omitempty\"`\n\tMeta  meta   `json:\"meta,omitempty\" yaml:\"meta,omitempty\"`\n\tPath  string `json:\"-\" yaml:\"-\"`\n}\n\nfunc (g *Gossfile) ID() string      { return g.Path }\nfunc (g *Gossfile) SetID(id string) { g.Path = id }\n\nfunc (g *Gossfile) GetTitle() string { return g.Title }\n\n\nfunc NewGossfile(sysGossfile system.Gossfile, config util.Config) (*Gossfile, error) {\n\tpath := sysGossfile.Path()\n\treturn &Gossfile{\n\t\tPath: path,\n\t}, nil\n}\n\nfunc (g *Gossfile) GetMeta() meta    ", "output": "{ return g.Meta }"}
{"input": "package main\n\nimport (\n\t\"github.com/streadway/amqp\"\n\t\"log\"\n\t\"time\"\n)\n\nvar (\n\trabbitConn       *amqp.Connection\n\trabbitCloseError chan *amqp.Error\n\trunningFlag      chan bool\n)\n\n\n\n\nfunc connectToRabbitMQ(uri string) *amqp.Connection {\n\tfor {\n\t\tconn, err := amqp.Dial(uri)\n\n\t\tif err == nil {\n\t\t\treturn conn\n\t\t}\n\n\t\tlog.Println(err)\n\t\tlog.Printf(\"Trying to reconnect to RabbitMQ at %s\\n\", uri)\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}\n\n\n\n\n\n\nfunc main() {\n\trabbitCloseError = make(chan *amqp.Error)\n\n\tgo rabbitConnector(\"amqp:guest:guest@localhost:5672/\")\n\n\trabbitCloseError <- amqp.ErrClosed\n\n\t<-runningFlag\n\n}\n\nfunc rabbitConnector(uri string) ", "output": "{\n\tvar rabbitErr *amqp.Error\n\n\tfor {\n\t\trabbitErr = <-rabbitCloseError\n\t\tif rabbitErr != nil {\n\t\t\tlog.Printf(\"Connecting to %s\\n\", \"amqp:guest:guest@localhost:5672/\")\n\n\t\t\trabbitConn = connectToRabbitMQ(uri)\n\t\t\trabbitCloseError = make(chan *amqp.Error)\n\t\t\trabbitConn.NotifyClose(rabbitCloseError)\n\n\t\t}\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tvar m map[string]string\n\tfmt.Printf(\"len(m):%2d\\n\", len(m)) \n\n\tfor k, _ := range m { \n\t\tfmt.Println(k)\n\t}\n\n\tv, ok := m[\"2\"]\n\tfmt.Printf(\"v:%s, ok:%v\\n\\n\", v, ok) \n\n\n\treq, err := NewGet(\n\t\t\"http:www.baidu.com\",\n\t\tmap[string]string{\n\t\t\t\"USER-AGENT\": \"golang/gopher\", \n\t\t}, \n\t)\n\tfmt.Println(\"_______________________\")\n\tfmt.Println(req.Method) \n\tfmt.Println(req.URL)    \n\tfmt.Println(req.Header) \n\tfmt.Println(err)        \n\tfmt.Println(\"_______________________\")\n\n\treq2, err := NewGet(\"http:www.baidu.com\", map[string]string{}) \n\tfmt.Println(req2)\n\treq3, err := NewGet(\"http:www.baidu.com\", nil) \n\tfmt.Println(req3)\n\n\tvar m1 map[int]int \n\tfmt.Println(m1 == nil)\n\tfmt.Println(\"=============\")\n\tm2 := make(map[int]int, 0) \n\tfmt.Println(m2 == nil)\n\tm2[5] = 55      \n\tfmt.Println(m2) \n\n}\n\n\n\nfunc NewGet(url string, headers map[string]string) (*http.Request, error) ", "output": "{\n\treq, err := http.NewRequest(http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor k, v := range headers {\n\t\treq.Header.Set(k, v)\n\t}\n\n\treturn req, nil\n}"}
{"input": "package vo\n\n\ntype Resolution struct {\n\twidth  int\n\theight int\n}\n\n\nfunc NewResolution(x, y int) Resolution {\n\treturn Resolution{x, y}\n}\n\n\n\n\n\nfunc (r Resolution) GetHeight() int {\n\treturn r.height\n}\n\nfunc (r Resolution) GetWidth() int ", "output": "{\n\treturn r.width\n}"}
{"input": "package rat\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\n\n\nfunc (s *TestSuite) TestWriter_Write(c *C) {\n\tf := bytes.NewBuffer(nil)\n\tw := NewWriter(f)\n\tw.WriteHeader(&tar.Header{Name: \"foo.txt\", Size: 3})\n\n\tn, err := w.Write([]byte(\"foo\"))\n\tc.Assert(err, IsNil)\n\tc.Assert(n, Equals, 3)\n}\n\nfunc (s *TestSuite) TestWriter_Flush(c *C) {\n\tf := bytes.NewBuffer(nil)\n\tw := NewWriter(f)\n\tw.WriteHeader(&tar.Header{Name: \"foo.txt\", Size: 3})\n\n\terr := w.Flush()\n\tc.Assert(err, Not(IsNil))\n}\n\nfunc (s *TestSuite) TestWriter_Close(c *C) {\n\tf := bytes.NewBuffer(nil)\n\tw := NewWriter(f)\n\tw.WriteHeader(&tar.Header{Name: \"foo.txt\", Size: 3})\n\tw.Write([]byte(\"foo\"))\n\n\tc.Assert(f.Len(), Equals, 515)\n\terr := w.Close()\n\tc.Assert(err, IsNil)\n\tc.Assert(f.Len(), Equals, 2103)\n}\n\nfunc (s *TestSuite) TestWriter_CloseFailed(c *C) {\n\tf := bytes.NewBuffer(nil)\n\tw := NewWriter(f)\n\tw.WriteHeader(&tar.Header{Name: \"foo.txt\", Size: 3})\n\n\terr := w.Close()\n\tc.Assert(err, Not(IsNil))\n}\n\nfunc (s *TestSuite) TestWriter_WriteHeader(c *C) ", "output": "{\n\tf := bytes.NewBuffer(nil)\n\tw := NewWriter(f)\n\tc.Assert(w.i.Entries, HasLen, 0)\n\n\terr := w.WriteHeader(&tar.Header{Name: \"foo.txt\", Size: 3, Typeflag: tar.TypeReg})\n\tc.Assert(err, IsNil)\n\n\tc.Assert(w.i.Entries, HasLen, 1)\n\te := w.i.Entries[\"foo.txt\"]\n\tc.Assert(e.Name, Equals, \"foo.txt\")\n\tc.Assert(e.Header, Equals, int64(0))\n\tc.Assert(e.Start, Equals, int64(512))\n\tc.Assert(e.End, Equals, int64(515))\n\tc.Assert(e.Typeflag, Equals, byte(tar.TypeReg))\n}"}
{"input": "package mock_concurrent\n\nimport (\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n\ntype MockMath struct {\n\tctrl     *gomock.Controller\n\trecorder *MockMathMockRecorder\n}\n\n\ntype MockMathMockRecorder struct {\n\tmock *MockMath\n}\n\n\nfunc NewMockMath(ctrl *gomock.Controller) *MockMath {\n\tmock := &MockMath{ctrl: ctrl}\n\tmock.recorder = &MockMathMockRecorder{mock}\n\treturn mock\n}\n\n\nfunc (m *MockMath) EXPECT() *MockMathMockRecorder {\n\treturn m.recorder\n}\n\n\nfunc (m *MockMath) Sum(arg0, arg1 int) int {\n\tret := m.ctrl.Call(m, \"Sum\", arg0, arg1)\n\tret0, _ := ret[0].(int)\n\treturn ret0\n}\n\n\n\n\nfunc (mr *MockMathMockRecorder) Sum(arg0, arg1 interface{}) *gomock.Call ", "output": "{\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Sum\", reflect.TypeOf((*MockMath)(nil).Sum), arg0, arg1)\n}"}
{"input": "package client\n\nimport (\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/api\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/labels\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/watch\"\n)\n\n\n\ntype FakeReplicationControllers struct {\n\tFake      *Fake\n\tNamespace string\n}\n\nfunc (c *FakeReplicationControllers) List(selector labels.Selector) (*api.ReplicationControllerList, error) {\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"list-controllers\"})\n\treturn api.Scheme.CopyOrDie(&c.Fake.CtrlList).(*api.ReplicationControllerList), nil\n}\n\nfunc (c *FakeReplicationControllers) Get(name string) (*api.ReplicationController, error) {\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"get-controller\", Value: name})\n\treturn api.Scheme.CopyOrDie(&c.Fake.Ctrl).(*api.ReplicationController), nil\n}\n\n\n\nfunc (c *FakeReplicationControllers) Update(controller *api.ReplicationController) (*api.ReplicationController, error) {\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"update-controller\", Value: controller})\n\treturn &api.ReplicationController{}, nil\n}\n\nfunc (c *FakeReplicationControllers) Delete(controller string) error {\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"delete-controller\", Value: controller})\n\treturn nil\n}\n\nfunc (c *FakeReplicationControllers) Watch(label, field labels.Selector, resourceVersion string) (watch.Interface, error) {\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"watch-controllers\", Value: resourceVersion})\n\treturn c.Fake.Watch, nil\n}\n\nfunc (c *FakeReplicationControllers) Create(controller *api.ReplicationController) (*api.ReplicationController, error) ", "output": "{\n\tc.Fake.Actions = append(c.Fake.Actions, FakeAction{Action: \"create-controller\", Value: controller})\n\treturn &api.ReplicationController{}, nil\n}"}
{"input": "package flamingo\n\ntype Selectors map[string]interface{}\n\n\n\ntype MongoQuery struct {\n}\n\nfunc (ms *MongoQuery) One(result interface{}) error {\n\treturn nil\n}\n\nfunc (ms *MongoQuery) All(result interface{}) error {\n\treturn nil\n}\n\n\ntype MongoCollection struct {\n}\n\nfunc (ms *MongoCollection) Query(selectors Selectors) *MongoQuery {\n\treturn &MongoQuery{}\n}\n\nfunc (ms *MongoCollection) FindById(id interface{}) *MongoQuery {\n\treturn &MongoQuery{}\n}\n\nfunc (ms *MongoCollection) Insert(entity interface{}) error {\n\treturn nil\n}\n\nfunc (ms *MongoCollection) Update(entity interface{}) error {\n\treturn nil\n}\n\nfunc (ms *MongoCollection) Remove(selectors Selectors) error {\n\treturn nil\n}\n\nfunc (ms *MongoCollection) RemoveById(id interface{}) error {\n\treturn nil\n}\n\n\n\ntype MongoSession struct {\n}\n\nfunc (ms *MongoSession) Close() error {\n\treturn nil\n}\n\nfunc (ms *MongoSession) Db(name string) *MongoSession {\n\treturn ms\n}\n\nfunc (ms *MongoSession) Collection(name string) *MongoCollection {\n\treturn &MongoCollection{}\n}\n\n\n\ntype MongoClient struct {\n\tloggerFactory *LoggerFactory\n}\n\nfunc (m *MongoClient) OpenSession() (MongoSession, error) {\n\treturn MongoSession{}, nil\n}\n\n\n\nfunc NewMongoClient(uri string, loggerFactory *LoggerFactory) MongoClient ", "output": "{\n\treturn MongoClient{loggerFactory}\n}"}
{"input": "package service\n\nimport (\n\t\"github.com/JacobXie/leanote/app/db\"\n\t\"github.com/JacobXie/leanote/app/info\"\n\t\"gopkg.in/mgo.v2/bson\"\n)\n\n\ntype NoteContentHistoryService struct {\n}\n\n\nvar maxSize = 10\n\n\n\nfunc (this *NoteContentHistoryService) AddHistory(noteId, userId string, eachHistory info.EachHistory) {\n\tif eachHistory.Content == \"\" {\n\t\treturn\n\t}\n\n\thistory := info.NoteContentHistory{}\n\tdb.GetByIdAndUserId(db.NoteContentHistories, noteId, userId, &history)\n\tif history.NoteId == \"\" {\n\t\tthis.newHistory(noteId, userId, eachHistory)\n\t} else {\n\t\tl := len(history.Histories)\n\t\tif l >= maxSize {\n\t\t\thistory.Histories = history.Histories[:maxSize]\n\t\t}\n\t\tnewHistory := []info.EachHistory{eachHistory}\n\t\tnewHistory = append(newHistory, history.Histories...) \n\t\thistory.Histories = newHistory\n\n\t\tdb.UpdateByIdAndUserId(db.NoteContentHistories, noteId, userId, history)\n\t}\n\treturn\n}\n\n\nfunc (this *NoteContentHistoryService) newHistory(noteId, userId string, eachHistory info.EachHistory) {\n\thistory := info.NoteContentHistory{NoteId: bson.ObjectIdHex(noteId),\n\t\tUserId:    bson.ObjectIdHex(userId),\n\t\tHistories: []info.EachHistory{eachHistory},\n\t}\n\n\tdb.Insert(db.NoteContentHistories, history)\n}\n\n\n\n\nfunc (this *NoteContentHistoryService) ListHistories(noteId, userId string) []info.EachHistory ", "output": "{\n\thistories := info.NoteContentHistory{}\n\tdb.GetByIdAndUserId(db.NoteContentHistories, noteId, userId, &histories)\n\treturn histories.Histories\n}"}
{"input": "package main\n\nimport (\n\t\"io\"\n\t\"os\"\n\n\t\"net/http\"\n\n\t\"github.com/labstack/echo\"\n\tmw \"github.com/labstack/echo/middleware\"\n)\n\n\n\nfunc main() {\n\te := echo.New()\n\te.Use(mw.Logger())\n\te.Use(mw.Recover())\n\n\te.Static(\"/\", \"public\")\n\te.Post(\"/upload\", upload)\n\n\te.Run(\":1323\")\n}\n\nfunc upload(c *echo.Context) error ", "output": "{\n\treq := c.Request()\n\treq.ParseMultipartForm(16 << 20) \n\n\tname := c.Form(\"name\")\n\temail := c.Form(\"email\")\n\n\tfiles := req.MultipartForm.File[\"files\"]\n\tfor _, f := range files {\n\t\tsrc, err := f.Open()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer src.Close()\n\n\t\tdst, err := os.Create(f.Filename)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer dst.Close()\n\n\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn c.String(http.StatusOK, \"Thank You! %s <%s>, %d files uploaded successfully.\",\n\t\tname, email, len(files))\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/lxc/lxd/lxd/cluster\"\n\t\"github.com/lxc/lxd/lxd/db\"\n\t\"github.com/lxc/lxd/lxd/node\"\n\t\"github.com/lxc/lxd/lxd/state\"\n\t\"github.com/lxc/lxd/shared\"\n)\n\nfunc daemonConfigRender(state *state.State) (map[string]interface{}, error) {\n\tconfig := map[string]interface{}{}\n\n\terr := state.Cluster.Transaction(func(tx *db.ClusterTx) error {\n\t\tclusterConfig, err := cluster.ConfigLoad(tx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor key, value := range clusterConfig.Dump() {\n\t\t\tconfig[key] = value\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = state.Node.Transaction(func(tx *db.NodeTx) error {\n\t\tnodeConfig, err := node.ConfigLoad(tx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor key, value := range nodeConfig.Dump() {\n\t\t\tconfig[key] = value\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn config, nil\n}\n\n\n\nfunc daemonConfigSetProxy(d *Daemon, config *cluster.Config) ", "output": "{\n\td.proxy = shared.ProxyFromConfig(\n\t\tconfig.ProxyHTTPS(),\n\t\tconfig.ProxyHTTP(),\n\t\tconfig.ProxyIgnoreHosts(),\n\t)\n\n\timageStreamCacheLock.Lock()\n\tfor k := range imageStreamCache {\n\t\tdelete(imageStreamCache, k)\n\t}\n\timageStreamCacheLock.Unlock()\n}"}
{"input": "package vault\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/hashicorp/hcl\"\n)\n\nconst (\n\tPathPolicyDeny  = \"deny\"\n\tPathPolicyRead  = \"read\"\n\tPathPolicyWrite = \"write\"\n\tPathPolicySudo  = \"sudo\"\n)\n\nvar (\n\tpathPolicyLevel = map[string]int{\n\t\tPathPolicyDeny:  0,\n\t\tPathPolicyRead:  1,\n\t\tPathPolicyWrite: 2,\n\t\tPathPolicySudo:  3,\n\t}\n)\n\n\n\ntype Policy struct {\n\tName  string        `hcl:\"name\"`\n\tPaths []*PathPolicy `hcl:\"path,expand\"`\n\tRaw   string\n}\n\n\ntype PathPolicy struct {\n\tPrefix string `hcl:\",key\"`\n\tPolicy string\n}\n\n\n\n\n\n\nfunc Parse(rules string) (*Policy, error) ", "output": "{\n\tp := &Policy{Raw: rules}\n\tif err := hcl.Decode(p, rules); err != nil {\n\t\treturn nil, fmt.Errorf(\"Failed to parse ACL rules: %v\", err)\n\t}\n\n\tfor _, pp := range p.Paths {\n\t\tswitch pp.Policy {\n\t\tcase PathPolicyDeny:\n\t\tcase PathPolicyRead:\n\t\tcase PathPolicyWrite:\n\t\tcase PathPolicySudo:\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Invalid path policy: %#v\", pp)\n\t\t}\n\t}\n\treturn p, nil\n}"}
{"input": "package argerror\n\nimport \"testing\"\n\n\n\nfunc TestNew(t *testing.T) ", "output": "{\n\tmessage := \"Hello\"\n\targs := map[string]string{\n\t\t\"arg\":  \"Arg value\",\n\t\t\"barg\": \"Barg\\nvalue\\nbaz\",\n\t}\n\tvar err error = New(message, args)\n\tactual := err.Error()\n\texpected := \"Hello; arg=\\\"Arg value\\\" barg=\\\"Barg value baz\\\"\"\n\tif actual != expected {\n\t\tt.Errorf(\"Expected error to be '%s', but was '%s'\", expected, actual)\n\t}\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSEMRCluster_HadoopJarStepConfig struct {\n\n\tArgs []string `json:\"Args,omitempty\"`\n\n\tJar string `json:\"Jar,omitempty\"`\n\n\tMainClass string `json:\"MainClass,omitempty\"`\n\n\tStepProperties []AWSEMRCluster_KeyValue `json:\"StepProperties,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSEMRCluster_HadoopJarStepConfig) AWSCloudFormationType() string {\n\treturn \"AWS::EMR::Cluster.HadoopJarStepConfig\"\n}\n\n\n\nfunc (r *AWSEMRCluster_HadoopJarStepConfig) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSEMRCluster_HadoopJarStepConfig) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSEMRCluster_HadoopJarStepConfig) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSEMRCluster_HadoopJarStepConfig) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\n\n\nfunc (r *AWSEMRCluster_HadoopJarStepConfig) SetDeletionPolicy(policy policies.DeletionPolicy) ", "output": "{\n\tr._deletionPolicy = policy\n}"}
{"input": "package logs\n\nimport (\n\t\"io\"\n\n\t\"github.com/cloudfoundry/dropsonde/log_sender\"\n\t\"github.com/cloudfoundry/sonde-go/events\"\n)\n\ntype LogSender interface {\n\tSendAppLog(appID, message, sourceType, sourceInstance string) error\n\tSendAppErrorLog(appID, message, sourceType, sourceInstance string) error\n\tScanLogStream(appID, sourceType, sourceInstance string, reader io.Reader)\n\tScanErrorLogStream(appID, sourceType, sourceInstance string, reader io.Reader)\n\tLogMessage(msg []byte, msgType events.LogMessage_MessageType) log_sender.LogChainer\n}\n\nvar logSender LogSender\n\n\n\nfunc Initialize(ls LogSender) {\n\tlogSender = ls\n}\n\n\n\n\nfunc SendAppLog(appID, message, sourceType, sourceInstance string) error {\n\tif logSender == nil {\n\t\treturn nil\n\t}\n\treturn logSender.SendAppLog(appID, message, sourceType, sourceInstance)\n}\n\n\n\n\n\n\n\n\nfunc ScanLogStream(appID, sourceType, sourceInstance string, reader io.Reader) {\n\tif logSender == nil {\n\t\treturn\n\t}\n\tlogSender.ScanLogStream(appID, sourceType, sourceInstance, reader)\n}\n\n\n\nfunc ScanErrorLogStream(appID, sourceType, sourceInstance string, reader io.Reader) {\n\tif logSender == nil {\n\t\treturn\n\t}\n\tlogSender.ScanErrorLogStream(appID, sourceType, sourceInstance, reader)\n}\n\n\n\nfunc LogMessage(msg []byte, msgType events.LogMessage_MessageType) log_sender.LogChainer {\n\treturn logSender.LogMessage(msg, msgType)\n}\n\nfunc SendAppErrorLog(appID, message, sourceType, sourceInstance string) error ", "output": "{\n\tif logSender == nil {\n\t\treturn nil\n\t}\n\treturn logSender.SendAppErrorLog(appID, message, sourceType, sourceInstance)\n}"}
{"input": "package cryptoauth\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc BenchmarkCrypto_box_keypair(*testing.B) ", "output": "{\n\tpk := make([]byte, 32)\n\tsk := make([]byte, 32)\n\n\tcrypto_box_keypair(pk, sk)\n}"}
{"input": "package vm\n\ntype Networks map[string]Network\n\ntype Network struct {\n\tType string `json:\"type\"`\n\n\tIP      string `json:\"ip,omitempty\"`\n\tNetmask string `json:\"netmask,omitempty\"`\n\tGateway string `json:\"gateway,omitempty\"`\n\n\tDNS     []string `json:\"dns,omitempty\"`\n\tDefault []string `json:\"default,omitempty\"`\n\n\tPreconfigured bool `json:\"preconfigured,omitempty\"`\n\n\tMAC string `json:\"mac,omitempty\"`\n\n\tCloudProperties map[string]interface{} `json:\"cloud_properties,omitempty\"`\n}\n\nfunc (ns Networks) First() Network {\n\tfor _, net := range ns {\n\t\treturn net\n\t}\n\n\treturn Network{}\n}\n\n\n\nfunc (n Network) AppendDNS(dns string) Network {\n\tif len(dns) > 0 {\n\t\tn.DNS = append(n.DNS, dns)\n\t\treturn n\n\t}\n\treturn n\n}\n\nfunc (n Network) IsDynamic() bool ", "output": "{ return n.Type == \"dynamic\" }"}
{"input": "package edgeorder\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\nfunc UserAgent() string {\n\treturn \"Azure-SDK-For-Go/\" + Version() + \" edgeorder/2021-12-01\"\n}\n\n\n\n\nfunc Version() string ", "output": "{\n\treturn version.Number\n}"}
