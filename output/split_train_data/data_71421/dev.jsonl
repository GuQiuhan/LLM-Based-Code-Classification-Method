{"input": "package models \n\n\nconst (\n\tprime64  = 1099511628211\n\toffset64 = 14695981039346656037\n)\n\n\n\ntype InlineFNV64a uint64\n\n\nfunc NewInlineFNV64a() InlineFNV64a {\n\treturn offset64\n}\n\n\nfunc (s *InlineFNV64a) Write(data []byte) (int, error) {\n\thash := uint64(*s)\n\tfor _, c := range data {\n\t\thash ^= uint64(c)\n\t\thash *= prime64\n\t}\n\t*s = InlineFNV64a(hash)\n\treturn len(data), nil\n}\n\n\n\n\nfunc (s *InlineFNV64a) Sum64() uint64 ", "output": "{\n\treturn uint64(*s)\n}"}
{"input": "package commands\n\nimport (\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/spf13/cobra\"\n)\n\n\n\nfunc setupCommands(rootCmd *cobra.Command) {\n\trootCmd.AddCommand(botCommand)\n\trootCmd.AddCommand(statsCommand)\n\trootCmd.AddCommand(reqCommand)\n}\n\nfunc checkedRun(run func(cmd *cobra.Command, args []string) error) func(cmd *cobra.Command, args []string) {\n\n\treturn func(cmd *cobra.Command, args []string) {\n\t\tif err := run(cmd, args); err != nil {\n\t\t\tlog.Fatalf(\"%v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n}\n\nfunc Execute() ", "output": "{\n\trootCmd := &cobra.Command{Use: \"htflood\"}\n\tsetupCommands(rootCmd)\n\trootCmd.Execute()\n}"}
{"input": "package solid\n\nimport \"github.com/cpmech/gosl/chk\"\n\n\ntype OnedState struct {\n\n\tSig float64 \n\n\tAlp     []float64 \n\tDgam    float64   \n\tLoading bool      \n\n\tPhi []float64 \n\n\tF float64 \n}\n\n\n\nfunc NewOnedState(nalp, nphi int) *OnedState {\n\tvar state OnedState\n\tif nalp > 0 {\n\t\tstate.Alp = make([]float64, nalp)\n\t}\n\tif nphi > 0 {\n\t\tstate.Phi = make([]float64, nphi)\n\t}\n\treturn &state\n}\n\n\n\n\n\n\n\nfunc (o *OnedState) GetCopy() *OnedState {\n\tother := NewOnedState(len(o.Alp), len(o.Phi))\n\tother.Set(o)\n\treturn other\n}\n\nfunc (o *OnedState) Set(other *OnedState) ", "output": "{\n\to.Sig = other.Sig\n\to.Dgam = other.Dgam\n\to.Loading = other.Loading\n\tchk.IntAssert(len(o.Alp), len(other.Alp))\n\tchk.IntAssert(len(o.Phi), len(other.Phi))\n\tcopy(o.Alp, other.Alp)\n\tcopy(o.Phi, other.Phi)\n\to.F = other.F\n}"}
{"input": "package v2\n\nimport (\n\tv1 \"k8s.io/api/core/v1\"\n)\n\n\n\ntype ResourceMetricSourceApplyConfiguration struct {\n\tName   *v1.ResourceName                `json:\"name,omitempty\"`\n\tTarget *MetricTargetApplyConfiguration `json:\"target,omitempty\"`\n}\n\n\n\n\n\n\n\n\nfunc (b *ResourceMetricSourceApplyConfiguration) WithName(value v1.ResourceName) *ResourceMetricSourceApplyConfiguration {\n\tb.Name = &value\n\treturn b\n}\n\n\n\n\nfunc (b *ResourceMetricSourceApplyConfiguration) WithTarget(value *MetricTargetApplyConfiguration) *ResourceMetricSourceApplyConfiguration {\n\tb.Target = value\n\treturn b\n}\n\nfunc ResourceMetricSource() *ResourceMetricSourceApplyConfiguration ", "output": "{\n\treturn &ResourceMetricSourceApplyConfiguration{}\n}"}
{"input": "package controllers\n\nimport (\n\t\"strings\"\n\n\t\"github.com/astaxie/beego\"\n)\n\nconst (\n\tMSG_OK  = 0\n\tMSG_ERR = -1\n)\n\n\ntype BaseController struct {\n\tbeego.Controller\n\tcontrollerName string\n\tactionName     string\n}\n\n\nfunc (b *BaseController) Prepare() {\n\tcontrollerName, actionName := b.GetControllerAndAction()\n\tb.controllerName = strings.ToLower(controllerName[0 : len(controllerName)-10])\n\tb.actionName = strings.ToLower(actionName)\n\n\tb.Data[\"siteName\"] = beego.AppConfig.String(\"site.name\")\n\tb.Data[\"curRoute\"] = b.controllerName + \".\" + b.actionName\n\tb.Data[\"curController\"] = b.controllerName\n}\n\nfunc (b *BaseController) display(tpl ...string) {\n\tvar tplname string\n\tif len(tpl) > 0 {\n\t\ttplname = tpl[0] + \".html\"\n\t} else {\n\t\ttplname = b.controllerName + \"/\" + b.actionName + \".html\"\n\t}\n\tb.Layout = \"layout.html\"\n\tb.TplName = tplname\n}\n\nfunc (b *BaseController) redirect(url string) {\n\tb.Redirect(url, 302)\n\tb.StopRun()\n}\n\n\n\nfunc (b *BaseController) ajaxMsg(msg interface{}, msgno int) {\n\tout := make(map[string]interface{})\n\tout[\"status\"] = msgno\n\tout[\"msg\"] = msg\n\tstatus := 200\n\tif msgno != MSG_OK {\n\t\tstatus = 500\n\t}\n\tb.Data[\"json\"] = out\n\tb.Ctx.Output.SetStatus(status)\n\tb.ServeJSON()\n\tb.StopRun()\n}\n\nfunc (b *BaseController) showError(args ...string) ", "output": "{\n\tb.Data[\"error\"] = args[0]\n\tredirect := b.Ctx.Request.Referer()\n\tif len(args) > 1 {\n\t\tredirect = args[1]\n\t}\n\n\tb.Data[\"redirect\"] = redirect\n\tb.Data[\"pageTitle\"] = \"Error\"\n\tb.display(\"error/error\")\n\tb.Render()\n\tb.StopRun()\n}"}
{"input": "package service\n\nimport (\n\tgofig \"github.com/akutz/gofig/types\"\n\n\t\"github.com/rexray/rexray/libstorage/api/registry\"\n\t\"github.com/rexray/rexray/libstorage/api/server/handlers\"\n\t\"github.com/rexray/rexray/libstorage/api/server/httputils\"\n\t\"github.com/rexray/rexray/libstorage/api/types\"\n\t\"github.com/rexray/rexray/libstorage/api/utils/schema\"\n)\n\nfunc init() {\n\tregistry.RegisterRouter(&router{})\n}\n\ntype router struct {\n\troutes []types.Route\n}\n\nfunc (r *router) Name() string {\n\treturn \"service-router\"\n}\n\n\n\n\nfunc (r *router) Routes() []types.Route {\n\treturn r.routes\n}\n\nfunc (r *router) initRoutes() {\n\n\tr.routes = []types.Route{\n\n\t\thttputils.NewGetRoute(\n\t\t\t\"services\",\n\t\t\t\"/services\",\n\t\t\tr.servicesList,\n\t\t\thandlers.NewAuthAllSvcsHandler(),\n\t\t\thandlers.NewSchemaValidator(nil, schema.ServiceInfoMapSchema, nil)),\n\n\t\thttputils.NewGetRoute(\n\t\t\t\"serviceInspect\",\n\t\t\t\"/services/{service}\",\n\t\t\tr.serviceInspect,\n\t\t\thandlers.NewServiceValidator(),\n\t\t\thandlers.NewAuthSvcHandler(),\n\t\t\thandlers.NewSchemaValidator(nil, schema.ServiceInfoSchema, nil)),\n\t}\n}\n\nfunc (r *router) Init(config gofig.Config) ", "output": "{\n\tr.initRoutes()\n}"}
{"input": "package net\n\nimport (\n\t\"os\"\n\t\"syscall\"\n)\n\nfunc setDefaultSockopts(s, family, sotype int, ipv6only bool) error {\n\tif family == syscall.AF_INET6 && sotype != syscall.SOCK_RAW {\n\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, boolint(ipv6only))\n\t}\n\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1))\n}\n\n\n\nfunc setDefaultMulticastSockopts(s int) error {\n\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1))\n}\n\nfunc setDefaultListenerSockopts(s int) error ", "output": "{\n\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1))\n}"}
{"input": "package cache\n\nimport (\n\t\"k8s.io/kubernetes/pkg/client\"\n\t\"k8s.io/kubernetes/pkg/fields\"\n\t\"k8s.io/kubernetes/pkg/runtime\"\n\t\"k8s.io/kubernetes/pkg/watch\"\n)\n\n\ntype ListFunc func() (runtime.Object, error)\n\n\ntype WatchFunc func(resourceVersion string) (watch.Interface, error)\n\n\n\n\ntype ListWatch struct {\n\tListFunc  ListFunc\n\tWatchFunc WatchFunc\n}\n\n\nfunc NewListWatchFromClient(c *client.Client, resource string, namespace string, fieldSelector fields.Selector) *ListWatch {\n\tlistFunc := func() (runtime.Object, error) {\n\t\treturn c.Get().\n\t\t\tNamespace(namespace).\n\t\t\tResource(resource).\n\t\t\tFieldsSelectorParam(fieldSelector).\n\t\t\tDo().\n\t\t\tGet()\n\t}\n\twatchFunc := func(resourceVersion string) (watch.Interface, error) {\n\t\treturn c.Get().\n\t\t\tPrefix(\"watch\").\n\t\t\tNamespace(namespace).\n\t\t\tResource(resource).\n\t\t\tFieldsSelectorParam(fieldSelector).\n\t\t\tParam(\"resourceVersion\", resourceVersion).Watch()\n\t}\n\treturn &ListWatch{ListFunc: listFunc, WatchFunc: watchFunc}\n}\n\n\nfunc (lw *ListWatch) List() (runtime.Object, error) {\n\treturn lw.ListFunc()\n}\n\n\n\n\nfunc (lw *ListWatch) Watch(resourceVersion string) (watch.Interface, error) ", "output": "{\n\treturn lw.WatchFunc(resourceVersion)\n}"}
{"input": "package cloudguard\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype RiskScoreAggregationCollection struct {\n\n\tItems []RiskScoreAggregation `mandatory:\"true\" json:\"items\"`\n}\n\n\n\nfunc (m RiskScoreAggregationCollection) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n)\n\nfunc main() {\n\ttest(\"internal\")\n\ttest(\"external\")\n}\n\n\n\nfunc test(linkmode string) ", "output": "{\n\tout, err := exec.Command(\"go\", \"run\", \"-ldflags\", \"-B=0x12345678 -linkmode=\"+linkmode, filepath.Join(\"fixedbugs\", \"issue10607a.go\")).CombinedOutput()\n\tif err != nil {\n\t\tfmt.Printf(\"BUG: linkmode=%s %v\\n%s\\n\", linkmode, err, out)\n\t\tos.Exit(1)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"sort\"\n\t\"strings\"\n)\n\ntype helloTransport interface {\n\tConnect(addr string) error\n\tClose() error\n\tRequest(req string) (reply string, err error)\n}\n\ntype transGenerator func() (helloTransport, error)\n\nvar transporter map[string]transGenerator = make(map[string]transGenerator)\n\nfunc registerTransport(id string, gen transGenerator) {\n\ttransporter[id] = gen\n}\n\nfunc transportList() []string {\n\tvar transports = make([]string, 0, len(transporter))\n\tfor id := range transporter {\n\t\ttransports = append(transports, id)\n\t}\n\tsort.StringSlice(transports).Sort()\n\treturn transports\n}\n\n\n\nfunc firstTransport() string {\n\tvar transports = transportList()\n\treturn transports[0]\n}\n\nfunc defaultAddr(addr string) string {\n\treturn fmt.Sprintf(\"%s://%s\", firstTransport(), addr)\n}\n\nfunc newTransport(addr string) (helloTransport, error) {\n\tvar uri, err = url.Parse(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif generate, ok := transporter[uri.Scheme]; ok {\n\t\treturn generate()\n\t}\n\treturn nil, fmt.Errorf(\"invalid transport %q\", uri.Scheme)\n}\n\nfunc availableTransports() string ", "output": "{\n\tvar transports = transportList()\n\treturn strings.Join(transports, \",\")\n}"}
{"input": "package mount\n\nimport \"github.com/moby/sys/mountinfo\"\n\n\n\nfunc MakeShared(mountPoint string) error {\n\treturn ensureMountedAs(mountPoint, SHARED)\n}\n\n\n\nfunc MakeRShared(mountPoint string) error {\n\treturn ensureMountedAs(mountPoint, RSHARED)\n}\n\n\n\nfunc MakePrivate(mountPoint string) error {\n\treturn ensureMountedAs(mountPoint, PRIVATE)\n}\n\n\n\n\n\n\n\nfunc MakeSlave(mountPoint string) error {\n\treturn ensureMountedAs(mountPoint, SLAVE)\n}\n\n\n\nfunc MakeRSlave(mountPoint string) error {\n\treturn ensureMountedAs(mountPoint, RSLAVE)\n}\n\n\n\nfunc MakeUnbindable(mountPoint string) error {\n\treturn ensureMountedAs(mountPoint, UNBINDABLE)\n}\n\n\n\nfunc MakeRUnbindable(mountPoint string) error {\n\treturn ensureMountedAs(mountPoint, RUNBINDABLE)\n}\n\n\n\nfunc MakeMount(mnt string) error {\n\tmounted, err := mountinfo.Mounted(mnt)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif mounted {\n\t\treturn nil\n\t}\n\n\treturn mount(mnt, mnt, \"none\", uintptr(BIND), \"\")\n}\n\nfunc ensureMountedAs(mnt string, flags int) error {\n\tif err := MakeMount(mnt); err != nil {\n\t\treturn err\n\t}\n\n\treturn mount(\"\", mnt, \"none\", uintptr(flags), \"\")\n}\n\nfunc MakeRPrivate(mountPoint string) error ", "output": "{\n\treturn ensureMountedAs(mountPoint, RPRIVATE)\n}"}
{"input": "package goarken\n\ntype Broadcaster struct {\n\tlisteners []chan interface{}\n}\n\nfunc NewBroadcaster() *Broadcaster {\n\tb := &Broadcaster{\n\t\tlisteners: []chan interface{}{},\n\t}\n\treturn b\n}\n\n\n\nfunc (b *Broadcaster) Listen() chan interface{} {\n\tchannel := make(chan interface{})\n\tb.listeners = append(b.listeners, channel)\n\treturn channel\n\n}\n\nfunc (b *Broadcaster) Write(message interface{}) ", "output": "{\n\tfor _, channel := range b.listeners {\n\t\tchannel <- message\n\t}\n}"}
{"input": "package api\n\nimport (\n\t\"context\"\n\n\t\"github.com/syncthing/syncthing/lib/connections\"\n)\n\ntype mockedConnections struct{}\n\nfunc (m *mockedConnections) ListenerStatus() map[string]connections.ListenerStatusEntry {\n\treturn nil\n}\n\nfunc (m *mockedConnections) ConnectionStatus() map[string]connections.ConnectionStatusEntry {\n\treturn nil\n}\n\nfunc (m *mockedConnections) NATType() string {\n\treturn \"\"\n}\n\nfunc (m *mockedConnections) Serve(ctx context.Context) error { return nil }\n\n\n\nfunc (m *mockedConnections) AllAddresses() []string { return nil }\n\nfunc (m *mockedConnections) ExternalAddresses() []string ", "output": "{ return nil }"}
{"input": "package v2\n\nimport (\n\t\"os\"\n\n\t\"code.cloudfoundry.org/cli/cf/cmd\"\n\t\"code.cloudfoundry.org/cli/commands\"\n\t\"code.cloudfoundry.org/cli/commands/flags\"\n)\n\ntype SetStagingEnvironmentVariableGroupCommand struct {\n\tRequiredArgs    flags.ParamsAsJSON `positional-args:\"yes\"`\n\tusage           interface{}        `usage:\"CF_NAME set-staging-environment-variable-group '{\\\"name\\\":\\\"value\\\",\\\"name\\\":\\\"value\\\"}'\"`\n\trelatedCommands interface{}        `related_commands:\"set-env, staging-environment-variable-group\"`\n}\n\n\n\nfunc (_ SetStagingEnvironmentVariableGroupCommand) Execute(args []string) error {\n\tcmd.Main(os.Getenv(\"CF_TRACE\"), os.Args)\n\treturn nil\n}\n\nfunc (_ SetStagingEnvironmentVariableGroupCommand) Setup(config commands.Config, ui commands.UI) error ", "output": "{\n\treturn nil\n}"}
{"input": "package generic_test\n\nimport (\n\t\"github.com/starkandwayne/cf-cli/generic\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\n\n\nfunc init() ", "output": "{\n\tDescribe(\"IsSliceable\", func() {\n\t\tIt(\"should return false when the type cannot be sliced\", func() {\n\t\t\tExpect(generic.IsSliceable(\"bad slicing\")).To(BeFalse())\n\t\t})\n\n\t\tIt(\"should return true if the type can be sliced\", func() {\n\t\t\tExpect(generic.IsSliceable([]string{\"a string\"})).To(BeTrue())\n\t\t})\n\n\t\tIt(\"should return true if the type can be sliced\", func() {\n\t\t\tExpect(generic.IsSliceable([]interface{}{1, 2, 3})).To(BeTrue())\n\t\t})\n\t})\n}"}
{"input": "package garbageman_test\n\nimport (\n\t\"net/http\"\n\n\tcf \"github.com/pivotalservices/pezdispenser/cloudfoundryclient\"\n)\n\ntype mockCFClient struct {\n\tUserList cf.UserAPIResponse\n\tError    error\n}\n\nfunc (s *mockCFClient) QueryAPIInfo() (a *cf.CloudFoundryAPIInfo, b error) {\n\treturn\n}\n\nfunc (s *mockCFClient) QueryUserGUID(username string) (a string, b error) {\n\treturn\n}\n\nfunc (s *mockCFClient) AddRole(rolePathPrefix string, targetGUID string, roleType string, userGUID string) (a error) {\n\treturn\n}\n\n\n\nfunc (s *mockCFClient) AddSpace(spaceName string, orgGUID string) (spaceGUID string, err error) {\n\treturn\n}\n\nfunc (s *mockCFClient) AddUser(username string) (a error) {\n\treturn\n}\n\nfunc (s *mockCFClient) RemoveOrg(orgGUID string) (err error) {\n\treturn\n}\n\nfunc (s *mockCFClient) QueryUsers(int, int, string, string) (userList cf.UserAPIResponse, err error) {\n\tuserList = s.UserList\n\terr = s.Error\n\treturn\n}\n\nfunc (s *mockCFClient) Query(verb string, domain string, path string, args interface{}) (response *http.Response) {\n\treturn\n}\n\nfunc (s *mockCFClient) AddOrg(orgName string) (orgGUID string, err error) ", "output": "{\n\treturn\n}"}
{"input": "package glacier\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/rdwilliamson/aws\"\n)\n\n\ntype Connection struct {\n\tClient *http.Client\n\n\tSignature *aws.Signature\n}\n\nfunc (c *Connection) client() *http.Client {\n\tif c.Client == nil {\n\t\treturn http.DefaultClient\n\t}\n\treturn c.Client\n}\n\n\nfunc (c *Connection) vault(vault string) string {\n\treturn \"https://\" + c.Signature.Region.Glacier + \"/-/vaults/\" + vault\n}\n\n\nfunc (c *Connection) policy(policy string) string {\n\treturn \"https://\" + c.Signature.Region.Glacier + \"/-/policies/\" + policy\n}\n\n\n\nfunc NewConnection(secret, access string, r *aws.Region) *Connection {\n\treturn &Connection{\n\t\tSignature: aws.NewSignature(secret, access, r, \"glacier\"),\n\t}\n}\n\n\n\n\nfunc toHex(x []byte) string {\n\treturn fmt.Sprintf(\"%x\", x)\n}\n\n\n\ntype parameters url.Values\n\n\n\n\n\n\n\nfunc (p parameters) encode() string {\n\tif encoded := url.Values(p).Encode(); encoded != \"\" {\n\t\treturn \"?\" + encoded\n\t}\n\treturn \"\"\n}\n\nfunc (p parameters) add(key, value string) ", "output": "{\n\turl.Values(p).Add(key, value)\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/julienschmidt/httprouter\"\n\t\"github.com/spf13/viper\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\n\n\ntype ResponseObj struct {\n\tOperation string      `json:\"operation\"`\n\tErr       int         `json:\"error\"`\n\tTimestamp time.Time   `json:\"timestamp\"`\n\tPath      string      `json:\"path\"`\n\tContent   interface{} `json:\"content\"`\n}\n\nfunc main() {\n\trouter := httprouter.New()\n\n\trouter.GET(\"/*path\", readHandler)\n\trouter.PUT(\"/*path\", writeHandler)\n\trouter.DELETE(\"/*path\", deleteHandler)\n\trouter.POST(\"/*path\", modifyHandler)\n\n\tlog.Println(\"Summer server listening at port\" + \":\" + viper.Get(\"appPort\").(string))\n\n\tlog.Fatal(http.ListenAndServe(\":\"+viper.Get(\"appPort\").(string), middleware(authenticator(router))))\n}\n\nfunc init() ", "output": "{\n\tviper.AddConfigPath(\".\")\n\tviper.SetConfigName(\"config\")\n\t_ = viper.ReadInConfig()\n}"}
{"input": "package fftw\n\nimport (\n\t\"github.com/cpmech/gosl/chk\"\n\t\"github.com/cpmech/gosl/io\"\n)\n\nfunc init() {\n\tio.Verbose = false\n}\n\n\n\nfunc verbose() ", "output": "{\n\tio.Verbose = true\n\tchk.Verbose = true\n}"}
{"input": "package ov\nimport (\n  \"fmt\"\n  \"runtime\"\n  \"github.com/docker/machine/log\"\n)\n\n\n\nfunc Ov1() (error) ", "output": "{\n  runtime.Gosched()\n  fmt.Println(\"in Ov1 another test foo\")\n  log.Fatalf(\"the force is with you\")\n  return nil\n}"}
{"input": "package util\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/go-gl/mathgl/mgl32\"\n)\n\n\n\n\nfunc RandUint8() uint8 {\n\treturn uint8(rand.Uint32() % 256)\n}\n\nfunc RandVec3() mgl32.Vec3 {\n\treturn mgl32.Vec3{rand.Float32(), rand.Float32(), rand.Float32()}.Normalize()\n}\n\nfunc RandQuat() mgl32.Quat {\n\treturn mgl32.AnglesToQuat(rand.Float32(), rand.Float32(), rand.Float32(), mgl32.ZYX).Normalize() \n}\n\n\n\n\n\n\n\n\n\n\nfunc ScaleQuatRotation(q mgl32.Quat, percent float32) mgl32.Quat {\n\treturn mgl32.QuatSlerp(mgl32.QuatIdent(), q, percent) \n}\n\nfunc IsPowerOfTwo(n int) bool {\n\treturn (n > 0) && (n&(n-1)) == 0\n}\n\n\n\nfunc RoundUpToPowerOfTwo(n int) int {\n\tpower := 1\n\tfor power < n {\n\t\tpower *= 2\n\t}\n\treturn power\n}\n\nfunc GetTimeMillis() int64 ", "output": "{\n\treturn time.Now().UnixNano() / (int64(time.Millisecond) / int64(time.Nanosecond))\n}"}
{"input": "package main\n\nimport (\n\t\"io\"\n)\n\ntype I interface {\n\tM()\n}\n\nfunc main() {\n\tvar x I\n\tswitch x.(type) {\n\tcase string: \n\t\tprintln(\"FAIL\")\n\t}\n\n\n\tvar r io.Reader\n\n\t_, _ = r.(io.Writer)\n\n\tswitch r.(type) {\n\tcase io.Writer:\n\t}\n\n\tswitch _ := r.(type) { \n\t}\n}\n\n\n\nfunc noninterface() ", "output": "{\n\tvar i int\n\tswitch i.(type) { \n\tcase string:\n\tcase int:\n\t}\n\n\ttype S struct {\n\t\tname string\n\t}\n\tvar s S\n\tswitch s.(type) { \n\t}\n}"}
{"input": "package httpserver\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc TestNewResponseRecorder(t *testing.T) {\n\tw := httptest.NewRecorder()\n\trecordRequest := NewResponseRecorder(w)\n\tif !(recordRequest.ResponseWriter == w) {\n\t\tt.Fatalf(\"Expected Response writer in the Recording to be same as the one sent\\n\")\n\t}\n\tif recordRequest.status != http.StatusOK {\n\t\tt.Fatalf(\"Expected recorded status  to be http.StatusOK (%d) , but found %d\\n \", http.StatusOK, recordRequest.status)\n\t}\n}\n\n\nfunc TestWrite(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tresponseTestString := \"test\"\n\trecordRequest := NewResponseRecorder(w)\n\tbuf := []byte(responseTestString)\n\t_, _ = recordRequest.Write(buf)\n\tif recordRequest.size != len(buf) {\n\t\tt.Fatalf(\"Expected the bytes written counter to be %d, but instead found %d\\n\", len(buf), recordRequest.size)\n\t}\n\tif w.Body.String() != responseTestString {\n\t\tt.Fatalf(\"Expected Response Body to be %s , but found %s\\n\", responseTestString, w.Body.String())\n\t}\n}\n\nfunc TestWriteHeader(t *testing.T) ", "output": "{\n\tw := httptest.NewRecorder()\n\trecordRequest := NewResponseRecorder(w)\n\trecordRequest.WriteHeader(401)\n\tif w.Code != 401 || recordRequest.status != 401 {\n\t\tt.Fatalf(\"Expected Response status to be set to 401, but found %d\\n\", recordRequest.status)\n\t}\n}"}
{"input": "package grpcweb\n\nimport \"google.golang.org/grpc/metadata\"\n\ntype callInfo struct {\n\theaders         metadata.MD\n\ttrailers        metadata.MD\n\tforceWebsockets bool\n}\n\n\ntype CallOption interface {\n\tbefore(*callInfo) error\n\tafter(*callInfo)\n}\n\ntype beforeCall func(c *callInfo) error\n\nfunc (o beforeCall) before(c *callInfo) error { return o(c) }\nfunc (o beforeCall) after(c *callInfo)        {}\n\ntype afterCall func(c *callInfo)\n\nfunc (o afterCall) before(c *callInfo) error { return nil }\nfunc (o afterCall) after(c *callInfo)        { o(c) }\n\n\n\nfunc Header(headers *metadata.MD) CallOption {\n\treturn afterCall(func(c *callInfo) {\n\t\t*headers = c.headers\n\t})\n}\n\n\n\nfunc Trailer(trailers *metadata.MD) CallOption {\n\treturn afterCall(func(c *callInfo) {\n\t\t*trailers = c.trailers\n\t})\n}\n\n\n\n\nfunc ForceWebsocketTransport() CallOption ", "output": "{\n\treturn beforeCall(func(c *callInfo) error {\n\t\tc.forceWebsockets = true\n\t\treturn nil\n\t})\n}"}
{"input": "package ssh\n\nimport (\n\t\"testing\"\n\n\t\"golang.org/x/crypto/ssh\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\nfunc Test(t *testing.T) { TestingT(t) }\n\n\n\nfunc (s *SuiteCommon) TestOverrideConfigKeep(c *C) {\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"foo\",\n\t}\n\n\ttarget := &ssh.ClientConfig{\n\t\tUser: \"bar\",\n\t}\n\n\toverrideConfig(config, target)\n\tc.Assert(target.User, Equals, \"bar\")\n}\n\nfunc (s *SuiteCommon) TestOverrideConfig(c *C) ", "output": "{\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"foo\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password(\"yourpassword\"),\n\t\t},\n\t\tHostKeyCallback: ssh.FixedHostKey(nil),\n\t}\n\n\ttarget := &ssh.ClientConfig{}\n\toverrideConfig(config, target)\n\n\tc.Assert(target.User, Equals, \"foo\")\n\tc.Assert(target.Auth, HasLen, 1)\n\tc.Assert(target.HostKeyCallback, NotNil)\n}"}
{"input": "package util\n\nimport (\n\t\"path\"\n\t\"strings\"\n\n\t\"github.com/mholt/archiver/v3\"\n\t\"github.com/nuclio/errors\"\n\t\"github.com/nuclio/logger\"\n)\n\ntype Decompressor struct {\n\tlogger logger.Logger\n}\n\nfunc NewDecompressor(parentLogger logger.Logger) (*Decompressor, error) {\n\tnewDecompressor := &Decompressor{\n\t\tlogger: parentLogger,\n\t}\n\n\treturn newDecompressor, nil\n}\n\nfunc (d *Decompressor) Decompress(source string, target string) error {\n\tif err := archiver.Unarchive(source, target); err != nil {\n\t\treturn errors.Wrapf(err, \"Failed to decompress file %s\", source)\n\t}\n\n\treturn nil\n}\n\nfunc IsCompressed(source string) bool {\n\n\tif IsJar(source) {\n\t\treturn false\n\t}\n\n\tunarchiver, err := archiver.ByExtension(source)\n\tif err != nil {\n\t\treturn false\n\t}\n\tu, ok := unarchiver.(archiver.Unarchiver)\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn u != nil\n}\n\n\n\nfunc IsJar(source string) bool ", "output": "{\n\treturn strings.ToLower(path.Ext(source)) == \".jar\"\n}"}
{"input": "package packp\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\n\t\"gopkg.in/src-d/go-git.v4/plumbing\"\n\t\"gopkg.in/src-d/go-git.v4/plumbing/format/pktline\"\n)\n\nconst ackLineLen = 44\n\n\ntype ServerResponse struct {\n\tACKs []plumbing.Hash\n}\n\n\n\nfunc (r *ServerResponse) Decode(reader io.Reader, isMultiACK bool) error {\n\tif isMultiACK {\n\t\treturn errors.New(\"multi_ack and multi_ack_detailed are not supported\")\n\t}\n\n\ts := pktline.NewScanner(reader)\n\n\tfor s.Scan() {\n\t\tline := s.Bytes()\n\n\t\tif err := r.decodeLine(line); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !isMultiACK {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn s.Err()\n}\n\nfunc (r *ServerResponse) decodeLine(line []byte) error {\n\tif len(line) == 0 {\n\t\treturn fmt.Errorf(\"unexpected flush\")\n\t}\n\n\tif bytes.Compare(line[0:3], ack) == 0 {\n\t\treturn r.decodeACKLine(line)\n\t}\n\n\tif bytes.Compare(line[0:3], nak) == 0 {\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"unexpected content %q\", string(line))\n}\n\nfunc (r *ServerResponse) decodeACKLine(line []byte) error {\n\tif len(line) < ackLineLen {\n\t\treturn fmt.Errorf(\"malformed ACK %q\", line)\n\t}\n\n\tsp := bytes.Index(line, []byte(\" \"))\n\th := plumbing.NewHash(string(line[sp+1 : sp+41]))\n\tr.ACKs = append(r.ACKs, h)\n\treturn nil\n}\n\n\n\n\nfunc (r *ServerResponse) Encode(w io.Writer) error ", "output": "{\n\tif len(r.ACKs) > 1 {\n\t\treturn errors.New(\"multi_ack and multi_ack_detailed are not supported\")\n\t}\n\n\te := pktline.NewEncoder(w)\n\tif len(r.ACKs) == 0 {\n\t\treturn e.Encodef(\"%s\\n\", nak)\n\t}\n\n\treturn e.Encodef(\"%s %s\\n\", ack, r.ACKs[0].String())\n}"}
{"input": "package iomon\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/juju/utils/clock\"\n\ttomb \"gopkg.in/tomb.v2\"\n)\n\nconst DefaultUpdateInterval = time.Second\n\n\n\n\ntype Monitor struct {\n\ttomb tomb.Tomb\n\n\tp Params\n\n\tcurrentStatus Status\n\n\tmu      sync.Mutex\n\tcurrent int64\n}\n\n\ntype Params struct {\n\tSize int64\n\n\tSetter StatusSetter\n\n\tUpdateInterval time.Duration\n\n\tClock clock.Clock\n}\n\n\n\n\n\n\nfunc New(p Params) *Monitor {\n\tif p.UpdateInterval == 0 {\n\t\tp.UpdateInterval = DefaultUpdateInterval\n\t}\n\tif p.Clock == nil {\n\t\tp.Clock = clock.WallClock\n\t}\n\tm := &Monitor{\n\t\tp: p,\n\t}\n\tm.tomb.Go(m.run)\n\treturn m\n}\n\n\nfunc (m *Monitor) Kill() {\n\tm.tomb.Kill(nil)\n}\n\n\n\n\nfunc (m *Monitor) Wait() error {\n\tm.tomb.Wait()\n\treturn nil\n}\n\n\n\n\nfunc (m *Monitor) run() error {\n\tfor {\n\t\tm.setStatus()\n\t\tselect {\n\t\tcase <-m.p.Clock.After(m.p.UpdateInterval):\n\t\tcase <-m.tomb.Dying():\n\t\t\tm.setStatus()\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (m *Monitor) setStatus() {\n\tm.mu.Lock()\n\tcurrent := m.current\n\tm.mu.Unlock()\n\tstatus := Status{\n\t\tCurrent: current,\n\t\tTotal:   m.p.Size,\n\t}\n\tif status != m.currentStatus {\n\t\tm.p.Setter.SetStatus(status)\n\t\tm.currentStatus = status\n\t}\n}\n\nfunc (m *Monitor) Update(current int64) ", "output": "{\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.current = current\n}"}
{"input": "package ps\n\n\n\ntype Process interface {\n\tPid() int\n\n\tPPid() int\n\n\tCPids() []int\n\n\tExecutable() string\n}\n\n\n\n\n\n\n\nfunc Processes() ([]Process, error) {\n\treturn processes()\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc FindProcessByExecutable(name string) ([]Process, error) {\n\treturn findProcessByExecutable(name)\n}\n\nfunc FindProcessByPid(pid int) (Process, error) ", "output": "{\n\treturn findProcessByPid(pid)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/chai2010/gettext-go/gettext\"\n\n\t\"github.com/lxc/lxd\"\n\t\"github.com/lxc/lxd/shared\"\n\t\"github.com/lxc/lxd/shared/gnuflag\"\n)\n\ntype snapshotCmd struct {\n\tstateful bool\n}\n\nfunc (c *snapshotCmd) showByDefault() bool {\n\treturn true\n}\n\nfunc (c *snapshotCmd) usage() string {\n\treturn gettext.Gettext(\n\t\t`Create a read-only snapshot of a container.\n\nlxc snapshot [remote:]<source> <snapshot name> [--stateful]`)\n}\n\nfunc (c *snapshotCmd) flags() {\n\tgnuflag.BoolVar(&c.stateful, \"stateful\", false, gettext.Gettext(\"Whether or not to snapshot the container's running state\"))\n}\n\n\n\nfunc (c *snapshotCmd) run(config *lxd.Config, args []string) error ", "output": "{\n\tif len(args) < 1 {\n\t\treturn errArgs\n\t}\n\n\tvar snapname string\n\tif len(args) < 2 {\n\t\tsnapname = \"\"\n\t} else {\n\t\tsnapname = args[1]\n\t}\n\n\tremote, name := config.ParseRemoteAndContainer(args[0])\n\td, err := lxd.NewClient(config, remote)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif shared.IsSnapshot(snapname) {\n\t\treturn fmt.Errorf(gettext.Gettext(\"'/' not allowed in snapshot name\"))\n\t}\n\n\tresp, err := d.Snapshot(name, snapname, c.stateful)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn d.WaitForSuccess(resp.Operation)\n}"}
{"input": "package getmodules\n\nimport (\n\t\"path\"\n\n\tgetter \"github.com/hashicorp/go-getter\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc SplitPackageSubdir(given string) (packageAddr, subDir string) {\n\tpackageAddr, subDir = getter.SourceDirSubdir(given)\n\tif subDir != \"\" {\n\t\tsubDir = path.Clean(subDir)\n\t}\n\treturn packageAddr, subDir\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc ExpandSubdirGlobs(instDir string, subDir string) (string, error) ", "output": "{\n\treturn getter.SubdirGlob(instDir, subDir)\n}"}
{"input": "package session_test\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n)\n\n\n\nfunc TestSession(t *testing.T) ", "output": "{\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Session Suite\")\n}"}
{"input": "package stateful\n\nimport (\n\t\"regexp\"\n\t\"time\"\n\n\t\"github.com/influxdata/kapacitor/tick/ast\"\n)\n\ntype EvalRegexNode struct {\n\tNode *ast.RegexNode\n}\n\nfunc (n *EvalRegexNode) Type(scope ReadOnlyScope, executionState ExecutionState) (ast.ValueType, error) {\n\treturn ast.TRegex, nil\n}\n\nfunc (n *EvalRegexNode) EvalRegex(scope *Scope, executionState ExecutionState) (*regexp.Regexp, error) {\n\treturn n.Node.Regex, nil\n}\n\n\n\nfunc (n *EvalRegexNode) EvalFloat(scope *Scope, executionState ExecutionState) (float64, error) {\n\treturn float64(0), ErrTypeGuardFailed{RequestedType: ast.TFloat, ActualType: ast.TRegex}\n}\n\nfunc (n *EvalRegexNode) EvalInt(scope *Scope, executionState ExecutionState) (int64, error) {\n\treturn int64(0), ErrTypeGuardFailed{RequestedType: ast.TInt, ActualType: ast.TRegex}\n}\n\nfunc (n *EvalRegexNode) EvalBool(scope *Scope, executionState ExecutionState) (bool, error) {\n\treturn false, ErrTypeGuardFailed{RequestedType: ast.TBool, ActualType: ast.TRegex}\n}\nfunc (n *EvalRegexNode) EvalTime(scope *Scope, executionState ExecutionState) (time.Time, error) {\n\treturn time.Time{}, ErrTypeGuardFailed{RequestedType: ast.TTime, ActualType: ast.TRegex}\n}\nfunc (n *EvalRegexNode) EvalDuration(scope *Scope, executionState ExecutionState) (time.Duration, error) {\n\treturn 0, ErrTypeGuardFailed{RequestedType: ast.TDuration, ActualType: ast.TRegex}\n}\nfunc (n *EvalRegexNode) IsDynamic() bool {\n\treturn false\n}\n\nfunc (n *EvalRegexNode) EvalString(scope *Scope, executionState ExecutionState) (string, error) ", "output": "{\n\treturn \"\", ErrTypeGuardFailed{RequestedType: ast.TString, ActualType: ast.TRegex}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype Hello struct {}\n\n\n\nfunc main() {\n\tvar h Hello\n\terr := http.ListenAndServe(\"localhost:4000\", h)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc (h Hello) ServeHTTP(\n\tw http.ResponseWriter, \n\tr *http.Request) ", "output": "{\n\tfmt.Fprint(w, \"Hello!\")\n}"}
{"input": "package v1\n\nimport (\n\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\n\n\ntype ContainerStateRunningApplyConfiguration struct {\n\tStartedAt *v1.Time `json:\"startedAt,omitempty\"`\n}\n\n\n\n\n\n\n\n\nfunc (b *ContainerStateRunningApplyConfiguration) WithStartedAt(value v1.Time) *ContainerStateRunningApplyConfiguration {\n\tb.StartedAt = &value\n\treturn b\n}\n\nfunc ContainerStateRunning() *ContainerStateRunningApplyConfiguration ", "output": "{\n\treturn &ContainerStateRunningApplyConfiguration{}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/ysugimoto/go-cliargs\"\n\t\"github.com/ysugimoto/gssp\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\n\nfunc main() {\n\targs := cliarg.NewArguments()\n\targs.Alias(\"h\", \"help\", false)\n\targs.Alias(\"p\", \"pretty\", false)\n\n\targs.Parse()\n\n\tif help, _ := args.GetOptionAsBool(\"help\"); help {\n\t\tusage()\n\t}\n\n\tfile, exists := args.GetCommandAt(1)\n\tif !exists {\n\t\tfmt.Println(\"[ERROR] Source CSS file must be suppied.\")\n\t\tusage()\n\t}\n\tabsPath, _ := filepath.Abs(file)\n\tif _, err := os.Stat(absPath); err != nil {\n\t\tfmt.Println(\"[ERROR] Source CSS file \" + file + \" is not exists.\")\n\t\tos.Exit(1)\n\t}\n\n\tprettyPrint, _ := args.GetOptionAsBool(\"pretty\")\n\tresult := execute(absPath, prettyPrint)\n\n\tfmt.Print(result)\n}\n\nfunc execute(path string, pretty bool) string {\n\tparser := gssp.NewParser()\n\n\tfp, _ := os.Open(path)\n\tbuffer, _ := ioutil.ReadAll(fp)\n\n\tdefer func() {\n\t\tfp.Close()\n\t}()\n\n\tresult := parser.Parse(buffer)\n\tif pretty {\n\t\treturn result.ToPrettyJSONString()\n\t} else {\n\t\treturn result.ToJSONString()\n\t}\n}\n\nfunc usage() ", "output": "{\n\ttext := `=================================\nGSSP: Go Style-Sheet Postprocessor\n=================================\nUsage:\n    gssp [source_file] [options]\n\nOptions:\n    -h, --help   : Show this help\n    -p, --pretty : Pretty print JSON result\n`\n\tfmt.Println(text)\n\tos.Exit(0)\n}"}
{"input": "package client\n\nimport (\n\tuserapi \"github.com/openshift/origin/pkg/user/api\"\n\t_ \"github.com/openshift/origin/pkg/user/api/v1beta1\"\n)\n\n\ntype UsersInterface interface {\n\tUsers() UserInterface\n}\n\n\ntype UserInterface interface {\n\tGet(name string) (*userapi.User, error)\n}\n\n\ntype users struct {\n\tr *Client\n}\n\n\nfunc newUsers(c *Client) *users {\n\treturn &users{\n\t\tr: c,\n\t}\n}\n\n\n\n\nfunc (c *users) Get(name string) (result *userapi.User, err error) ", "output": "{\n\tresult = &userapi.User{}\n\terr = c.r.Get().Resource(\"users\").Name(name).Do().Into(result)\n\treturn\n}"}
{"input": "package cloudstorage\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype MockStorage struct {\n\tPutRequest          *http.Request\n\tGetURL              *url.URL\n\tOriginallySigned    bool\n\tListObjectsResponse *ListObjectsResponse\n}\n\nvar _ Storage = &MockStorage{}\n\nfunc (s *MockStorage) PresignPutObject(name string, accessType AccessType, header http.Header) (*http.Request, error) {\n\treturn s.PutRequest, nil\n}\n\nfunc (s *MockStorage) PresignGetObject(name string) (*url.URL, error) {\n\treturn s.GetURL, nil\n}\n\n\n\nfunc (s *MockStorage) RewriteGetURL(u *url.URL, name string) (*url.URL, bool, error) {\n\treturn s.GetURL, s.OriginallySigned, nil\n}\n\nfunc (s *MockStorage) ListObjects(r *ListObjectsRequest) (*ListObjectsResponse, error) {\n\treturn s.ListObjectsResponse, nil\n}\n\nfunc (s *MockStorage) DeleteObject(name string) error {\n\treturn nil\n}\n\nfunc (s *MockStorage) AccessType(header http.Header) AccessType {\n\treturn AccessTypeDefault\n}\n\nfunc (s *MockStorage) StandardToProprietary(header http.Header) http.Header {\n\treturn header\n}\n\nfunc (s *MockStorage) ProprietaryToStandard(header http.Header) http.Header {\n\treturn header\n}\n\nfunc (s *MockStorage) PresignHeadObject(name string) (*url.URL, error) ", "output": "{\n\treturn s.GetURL, nil\n}"}
{"input": "package kubelet\n\nimport (\n\t\"k8s.io/kubernetes/pkg/auth/authenticator\"\n\t\"k8s.io/kubernetes/pkg/auth/authorizer\"\n)\n\n\ntype KubeletAuth struct {\n\tauthenticator.Request\n\tauthorizer.RequestAttributesGetter\n\tauthorizer.Authorizer\n}\n\n\n\n\nfunc NewKubeletAuth(authenticator authenticator.Request, authorizerAttributeGetter authorizer.RequestAttributesGetter, authorizer authorizer.Authorizer) AuthInterface ", "output": "{\n\treturn &KubeletAuth{authenticator, authorizerAttributeGetter, authorizer}\n}"}
{"input": "package geth\n\nimport (\n\t\"errors\"\n\t\"math/big\"\n)\n\n\ntype BigInt struct {\n\tbigint *big.Int\n}\n\n\n\n\n\nfunc (bi *BigInt) GetBytes() []byte {\n\treturn bi.bigint.Bytes()\n}\n\n\nfunc (bi *BigInt) String() string {\n\treturn bi.bigint.String()\n}\n\n\n\nfunc (bi *BigInt) GetInt64() int64 {\n\treturn bi.bigint.Int64()\n}\n\n\n\nfunc (bi *BigInt) SetBytes(buf []byte) {\n\tbi.bigint.SetBytes(buf)\n}\n\n\nfunc (bi *BigInt) SetInt64(x int64) {\n\tbi.bigint.SetInt64(x)\n}\n\n\n\n\n\n\nfunc (bi *BigInt) SetString(x string, base int) {\n\tbi.bigint.SetString(x, base)\n}\n\n\ntype BigInts struct{ bigints []*big.Int }\n\n\nfunc (bi *BigInts) Size() int {\n\treturn len(bi.bigints)\n}\n\n\nfunc (bi *BigInts) Get(index int) (bigint *BigInt, _ error) {\n\tif index < 0 || index >= len(bi.bigints) {\n\t\treturn nil, errors.New(\"index out of bounds\")\n\t}\n\treturn &BigInt{bi.bigints[index]}, nil\n}\n\n\nfunc (bi *BigInts) Set(index int, bigint *BigInt) error {\n\tif index < 0 || index >= len(bi.bigints) {\n\t\treturn errors.New(\"index out of bounds\")\n\t}\n\tbi.bigints[index] = bigint.bigint\n\treturn nil\n}\n\nfunc NewBigInt(x int64) *BigInt ", "output": "{\n\treturn &BigInt{big.NewInt(x)}\n}"}
{"input": "package rocksdb\n\nimport (\n\t\"github.com/tecbot/gorocksdb\"\n)\n\ntype Iterator struct {\n\tstore    *Store\n\titerator *gorocksdb.Iterator\n}\n\nfunc newIterator(store *Store) *Iterator {\n\tropts := defaultReadOptions()\n\trv := Iterator{\n\t\tstore:    store,\n\t\titerator: store.db.NewIterator(ropts),\n\t}\n\treturn &rv\n}\n\nfunc newIteratorWithSnapshot(store *Store, snapshot *gorocksdb.Snapshot) *Iterator {\n\toptions := defaultReadOptions()\n\toptions.SetSnapshot(snapshot)\n\trv := Iterator{\n\t\tstore:    store,\n\t\titerator: store.db.NewIterator(options),\n\t}\n\treturn &rv\n}\n\nfunc (ldi *Iterator) SeekFirst() {\n\tldi.iterator.SeekToFirst()\n}\n\nfunc (ldi *Iterator) Seek(key []byte) {\n\tldi.iterator.Seek(key)\n}\n\nfunc (ldi *Iterator) Next() {\n\tldi.iterator.Next()\n}\n\nfunc (ldi *Iterator) Current() ([]byte, []byte, bool) {\n\tif ldi.Valid() {\n\t\treturn ldi.Key(), ldi.Value(), true\n\t}\n\treturn nil, nil, false\n}\n\nfunc (ldi *Iterator) Key() []byte {\n\treturn ldi.iterator.Key().Data()\n}\n\n\n\nfunc (ldi *Iterator) Valid() bool {\n\treturn ldi.iterator.Valid()\n}\n\nfunc (ldi *Iterator) Close() error {\n\tldi.iterator.Close()\n\treturn nil\n}\n\nfunc (ldi *Iterator) Value() []byte ", "output": "{\n\treturn ldi.iterator.Value().Data()\n}"}
{"input": "package pml_test\n\nimport (\n\t\"encoding/xml\"\n\t\"testing\"\n\n\t\"baliance.com/gooxml/schema/soo/pml\"\n)\n\n\n\nfunc TestEG_TopLevelSlideMarshalUnmarshal(t *testing.T) {\n\tv := pml.NewEG_TopLevelSlide()\n\tbuf, _ := xml.Marshal(v)\n\tv2 := pml.NewEG_TopLevelSlide()\n\txml.Unmarshal(buf, v2)\n}\n\nfunc TestEG_TopLevelSlideConstructor(t *testing.T) ", "output": "{\n\tv := pml.NewEG_TopLevelSlide()\n\tif v == nil {\n\t\tt.Errorf(\"pml.NewEG_TopLevelSlide must return a non-nil value\")\n\t}\n\tif err := v.Validate(); err != nil {\n\t\tt.Errorf(\"newly constructed pml.EG_TopLevelSlide should validate: %s\", err)\n\t}\n}"}
{"input": "package actor\n\nimport (\n\t\"testing\"\n)\n\nfunc TestActorCanReplyOnStarting(t *testing.T) {\n\tfuture := NewFuture(testTimeout)\n\ta := Spawn(FromFunc(func(context Context) {\n\t\tswitch context.Message().(type) {\n\t\tcase *Started:\n\t\t\tcontext.Tell(future.PID(), EchoResponse{})\n\t\t}\n\t}))\n\ta.GracefulStop()\n\tassertFutureSuccess(future, t)\n}\n\n\n\nfunc TestActorCanReplyOnStopping(t *testing.T) ", "output": "{\n\tfuture := NewFuture(testTimeout)\n\ta := Spawn(FromFunc(func(context Context) {\n\t\tswitch context.Message().(type) {\n\t\tcase *Stopping:\n\t\t\tcontext.Tell(future.PID(), EchoResponse{})\n\t\t}\n\t}))\n\ta.GracefulStop()\n\tassertFutureSuccess(future, t)\n}"}
{"input": "package netutil\n\nimport (\n\t\"io\"\n\t\"net\"\n\t\"time\"\n)\n\n\n\n\n\n\ntype ConnWrapper struct {\n\tio.Reader\n\tio.Writer\n\tUnderlyingConn net.Conn\n\tReadCloser     io.Closer\n\tWriteCloser    io.Closer\n}\n\nvar _ net.Conn = new(ConnWrapper)\n\n\n\nfunc (c *ConnWrapper) LocalAddr() net.Addr                { return c.UnderlyingConn.LocalAddr() }\nfunc (c *ConnWrapper) RemoteAddr() net.Addr               { return c.UnderlyingConn.RemoteAddr() }\nfunc (c *ConnWrapper) SetDeadline(t time.Time) error      { return c.UnderlyingConn.SetDeadline(t) }\nfunc (c *ConnWrapper) SetReadDeadline(t time.Time) error  { return c.UnderlyingConn.SetReadDeadline(t) }\nfunc (c *ConnWrapper) SetWriteDeadline(t time.Time) error { return c.UnderlyingConn.SetWriteDeadline(t) }\n\nfunc (c *ConnWrapper) Close() error ", "output": "{\n\tvar multiErr MultiError\n\tif c.ReadCloser != nil {\n\t\tmultiErr.RecordError(c.ReadCloser.Close())\n\t}\n\tif c.WriteCloser != nil {\n\t\tmultiErr.RecordError(c.WriteCloser.Close())\n\t}\n\tmultiErr.RecordError(c.UnderlyingConn.Close())\n\treturn multiErr.ToError()\n}"}
{"input": "package SignalHandler\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n)\n\n\ntype SignalHandler struct {\n\tsignalChannel chan os.Signal\n\tcallbacks     map[os.Signal][]func() error\n\toutputFunc    func(v ...interface{})\n}\n\n\nfunc ConstructSignalHandler() *SignalHandler {\n\treturn &SignalHandler{\n\t\tsignalChannel: make(chan os.Signal, 1),\n\t\tcallbacks:     make(map[os.Signal][]func() error, 10),\n\t\toutputFunc:    log.Println,\n\t}\n}\n\n\n\n\n\nfunc (handler *SignalHandler) Start() {\n\tgo handler.Listen()\n}\n\n\nfunc (handler *SignalHandler) Listen() {\n\tfor {\n\t\treceivedSignal := <-handler.signalChannel\n\n\t\tfor _, signalFunction := range handler.callbacks[receivedSignal] {\n\t\t\terr := signalFunction()\n\n\t\t\tif err != nil {\n\t\t\t\thandler.outputFunc(fmt.Sprintf(\"SignalHandler: error during signal %d func: %v\", receivedSignal, err))\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nfunc (handler *SignalHandler) RegisterSignalFunction(sig os.Signal, callback func() error) {\n\tif len(handler.callbacks[sig]) == 0 {\n\t\tsignal.Ignore(sig)\n\t\tsignal.Notify(handler.signalChannel, sig)\n\t}\n\n\thandler.callbacks[sig] = append(handler.callbacks[sig], callback)\n}\n\nfunc (handler *SignalHandler) SetOutput(outputFunction func(v ...interface{})) ", "output": "{\n\thandler.outputFunc = outputFunction\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n)\n\n\n\nfunc TestOutputFileName(t *testing.T) ", "output": "{\n\ta := assert.New(t)\n\ta.Equal(\"input.gen.go\", outputFileName(\"input.go\"))\n\ta.Equal(\"input.txt.gen.go\", outputFileName(\"input.txt\"))\n}"}
{"input": "package util\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/go-gl/mathgl/mgl32\"\n)\n\n\nfunc GetTimeMillis() int64 {\n\treturn time.Now().UnixNano() / (int64(time.Millisecond) / int64(time.Nanosecond))\n}\n\nfunc RandUint8() uint8 {\n\treturn uint8(rand.Uint32() % 256)\n}\n\nfunc RandVec3() mgl32.Vec3 {\n\treturn mgl32.Vec3{rand.Float32(), rand.Float32(), rand.Float32()}.Normalize()\n}\n\nfunc RandQuat() mgl32.Quat {\n\treturn mgl32.AnglesToQuat(rand.Float32(), rand.Float32(), rand.Float32(), mgl32.ZYX).Normalize() \n}\n\n\n\n\n\n\n\n\n\n\n\n\nfunc IsPowerOfTwo(n int) bool {\n\treturn (n > 0) && (n&(n-1)) == 0\n}\n\n\n\nfunc RoundUpToPowerOfTwo(n int) int {\n\tpower := 1\n\tfor power < n {\n\t\tpower *= 2\n\t}\n\treturn power\n}\n\nfunc ScaleQuatRotation(q mgl32.Quat, percent float32) mgl32.Quat ", "output": "{\n\treturn mgl32.QuatSlerp(mgl32.QuatIdent(), q, percent) \n}"}
{"input": "package state\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/juju/errors\"\n\t\"gopkg.in/juju/names.v2\"\n\n\t\"github.com/juju/juju/state/storage\"\n)\n\n\n\ntype rawState struct {\n\tbase    *State\n\tpersist Persistence\n}\n\n\n\nfunc NewResourceState(persist Persistence, base *State) Resources {\n\treturn &resourceState{\n\t\tpersist: NewResourcePersistence(persist),\n\t\traw: rawState{\n\t\t\tbase:    base,\n\t\t\tpersist: persist,\n\t\t},\n\t\tstorage: persist.NewStorage(),\n\t\tclock:   base.clock,\n\t}\n}\n\n\n\n\n\nfunc (st rawState) Storage() storage.Storage {\n\treturn st.persist.NewStorage()\n}\n\n\nfunc (st rawState) Units(applicationID string) (tags []names.UnitTag, err error) {\n\tapp, err := st.base.Application(applicationID)\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tunits, err := app.AllUnits()\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tfor _, u := range units {\n\t\ttags = append(tags, u.UnitTag())\n\t}\n\treturn tags, nil\n}\n\n\nfunc (st rawState) VerifyService(id string) error {\n\tapp, err := st.base.Application(id)\n\tif err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\tif app.Life() != Alive {\n\t\treturn errors.NewNotFound(nil, fmt.Sprintf(\"application %q dying or dead\", id))\n\t}\n\treturn nil\n}\n\nfunc (st rawState) Persistence() Persistence ", "output": "{\n\treturn st.persist\n}"}
{"input": "package routetemplate\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar routeTemplates []RouteTemplate\n\nfunc Add(template string) (err error) {\n\trouteTemplate, _ := Parse(template)\n\trouteTemplates = append(routeTemplates, routeTemplate)\n\treturn nil\n}\n\n\n\nfunc GetMatchTemplate(url string) (routeTemplateMatch RouteTemplateMatch, err error) {\n\n\trouteTemplateMatch = RouteTemplateMatch{}\n\tfor _, value := range routeTemplates {\n\t\twasMatched, _ := IsMatch(url, value)\n\t\tif wasMatched {\n\n\t\t\trouteTemplateMatch, _ = BindVariables(url, value)\n\t\t\tbreak\n\t\t}\n\t}\n\treturn routeTemplateMatch, nil\n}\n\nfunc GetMatchedTemplate(url string) (template string, err error) {\n\ttemplate = \"\"\n\n\tfor _, value := range routeTemplates {\n\n\t\twasMatched, _ := IsMatch(url, value)\n\t\tif wasMatched {\n\t\t\ttemplate = value.TemplatePath\n\t\t\tbreak\n\t\t}\n\t}\n\treturn template, nil\n}\n\nfunc AddRoute(name string, method string, urlTemplate string, handler interface{}) {\n\tfmt.Printf(\"%q\\n\", handler)\n\tvar x reflect.Value\n\tif fv, ok := handler.(reflect.Value); ok {\n\t\tx = fv\n\t} else {\n\t\tx = reflect.ValueOf(handler)\n\t}\n\n\targs := make([]reflect.Value, 0, 0)\n\tx.Call(args)\n\tfmt.Printf(\"%q\\n\", x)\n}\n\nfunc GetAllTemplates() (templates []RouteTemplate, err error) {\n\treturn routeTemplates, nil\n}\n\nfunc ClearAllTemplates() (err error) {\n\trouteTemplates = make([]RouteTemplate, 0)\n\treturn nil\n}\n\nfunc GetMatchedTemplateString(url string) (template string, err error) ", "output": "{\n\ttemplate = \"\"\n\n\tfor _, value := range routeTemplates {\n\n\t\twasMatched, _ := IsMatch(url, value)\n\t\tif wasMatched {\n\t\t\ttemplate = value.TemplatePath\n\t\t\tbreak\n\t\t}\n\t}\n\treturn template, nil\n}"}
{"input": "package iso20022\n\n\ntype ATMEnvironment3 struct {\n\n\tAcquirer *Acquirer7 `xml:\"Acqrr,omitempty\"`\n\n\tATMManagerIdentification *Max35Text `xml:\"ATMMgrId,omitempty\"`\n\n\tHostingEntity *TerminalHosting1 `xml:\"HstgNtty,omitempty\"`\n\n\tATM *AutomatedTellerMachine1 `xml:\"ATM\"`\n\n\tCustomer *ATMCustomer3 `xml:\"Cstmr\"`\n\n\tCard *PaymentCard17 `xml:\"Card,omitempty\"`\n}\n\nfunc (a *ATMEnvironment3) AddAcquirer() *Acquirer7 {\n\ta.Acquirer = new(Acquirer7)\n\treturn a.Acquirer\n}\n\nfunc (a *ATMEnvironment3) SetATMManagerIdentification(value string) {\n\ta.ATMManagerIdentification = (*Max35Text)(&value)\n}\n\n\n\nfunc (a *ATMEnvironment3) AddATM() *AutomatedTellerMachine1 {\n\ta.ATM = new(AutomatedTellerMachine1)\n\treturn a.ATM\n}\n\nfunc (a *ATMEnvironment3) AddCustomer() *ATMCustomer3 {\n\ta.Customer = new(ATMCustomer3)\n\treturn a.Customer\n}\n\nfunc (a *ATMEnvironment3) AddCard() *PaymentCard17 {\n\ta.Card = new(PaymentCard17)\n\treturn a.Card\n}\n\nfunc (a *ATMEnvironment3) AddHostingEntity() *TerminalHosting1 ", "output": "{\n\ta.HostingEntity = new(TerminalHosting1)\n\treturn a.HostingEntity\n}"}
{"input": "package database\n\nimport (\n\t\"labix.org/v2/mgo\"\n\t\"labix.org/v2/mgo/bson\"\n\t\"github.com/DewaldV/crucible/config\"\n)\n\ntype MgoConnection struct {\n\tDatabase   string\n\tCollection string\n}\n\n\n\nfunc (conn *MgoConnection) FindAll(m bson.M, d interface{}) {\n\tExecuteWithCollection(conn.Database, conn.Collection, func(c *mgo.Collection) error { return c.Find(m).All(d) })\n}\n\n\nfunc (conn *MgoConnection) Insert(d interface{}) {\n\tExecuteWithCollection(conn.Database, conn.Collection, func(c *mgo.Collection) error { return c.Insert(d) })\n}\n\n\n\nfunc ExecuteWithCollection(database, collection string, f func(*mgo.Collection) error) error {\n\tsession := GetSession(\"Default\")\n\tdefer session.Close()\n\n\tsession.SetMode(mgo.Monotonic, true)\n\n\tc := session.DB(database).C(collection)\n\n\treturn f(c)\n}\n\nvar sessionPool map[string]*mgo.Session\n\nfunc LoadSessions(dataSourceConfig map[string]*config.DataSourceConfiguration) {\n\tsessionPool = make(map[string]*mgo.Session)\n\tfor key, source := range dataSourceConfig {\n\t\ts, _ := mgo.Dial(source.ServerName)\n\t\tsessionPool[key] = s\n\t}\n}\n\nfunc GetSession(dataSource string) *mgo.Session {\n\ts := sessionPool[dataSource]\n\treturn s.Clone()\n}\n\nfunc (conn *MgoConnection) FindOne(m bson.M, d interface{}) ", "output": "{\n\tExecuteWithCollection(conn.Database, conn.Collection, func(c *mgo.Collection) error { return c.Find(m).One(d) })\n}"}
{"input": "package otr3\n\ntype policies int\n\ntype policy int\n\nconst (\n\tallowV2 policy = 2 << iota\n\tallowV3\n\trequireEncryption\n\tsendWhitespaceTag\n\twhitespaceStartAKE\n\terrorStartAKE\n)\n\n\n\nfunc (p *policies) has(c policy) bool {\n\treturn int(*p)&int(c) == int(c)\n}\n\nfunc (p *policies) add(c policy) {\n\t*p = policies(int(*p) | int(c))\n}\n\nfunc (p *policies) AllowV2() {\n\tp.add(allowV2)\n}\n\nfunc (p *policies) AllowV3() {\n\tp.add(allowV3)\n}\n\nfunc (p *policies) RequireEncryption() {\n\tp.add(requireEncryption)\n}\n\nfunc (p *policies) SendWhitespaceTag() {\n\tp.add(sendWhitespaceTag)\n}\n\nfunc (p *policies) WhitespaceStartAKE() {\n\tp.add(whitespaceStartAKE)\n}\n\nfunc (p *policies) ErrorStartAKE() {\n\tp.add(errorStartAKE)\n}\n\nfunc (p *policies) isOTREnabled() bool ", "output": "{\n\treturn p.has(allowV2) || p.has(allowV3)\n}"}
{"input": "package aspixml\n\nimport (\n\t\"encoding/xml\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestMarshalResponseFault(t *testing.T) {\n\tr := Response{\n\t\tType:  FaultResp,\n\t\tFault: &testFault1,\n\t}\n\tb, err := xml.MarshalIndent(&r, \"\", \"  \")\n\trequire.Nil(t, err)\n\tassert.Equal(t, []byte(testFault1XML), b)\n}\n\nfunc TestUnmarshalResponseFault(t *testing.T) {\n\tvar r Response\n\terr := xml.Unmarshal([]byte(testFault1XML), &r)\n\trequire.Nil(t, err)\n\tassert.Equal(t, FaultResp, r.Type)\n\tassert.Nil(t, r.MessageDelivery)\n\tassert.Equal(t, testFault1.Code, r.Fault.Code)\n\tassert.Equal(t, testFault1.Msg, r.Fault.Msg)\n\tassert.Empty(t, r.Fault.Detail)\n}\n\n\n\nfunc TestUnmarshalResponseMessageDelivery(t *testing.T) {\n\tvar r Response\n\terr := xml.Unmarshal([]byte(testMessageDelivery1XML), &r)\n\trequire.Nil(t, err)\n\tassert.Equal(t, MessageDeliveryResp, r.Type)\n\tassert.Nil(t, r.Fault)\n\tassert.Len(t, r.MessageDelivery.Messages, 2)\n}\n\nfunc TestMarshalResponseMessageDelivery(t *testing.T) ", "output": "{\n\tr := Response{\n\t\tType:            MessageDeliveryResp,\n\t\tMessageDelivery: &testMessageDelivery1,\n\t}\n\tb, err := xml.MarshalIndent(&r, \"\", \"  \")\n\trequire.Nil(t, err)\n\tassert.Equal(t, []byte(testMessageDelivery1XML), b)\n}"}
{"input": "package plugdeps\n\nimport \"encoding/json\"\n\n\ntype Command struct {\n\tName     string    `toml:\"name\" json:\"name\"`\n\tFlags    []string  `toml:\"flags,omitempty\" json:\"flags,omitempty\"`\n\tCommands []Command `toml:\"command,omitempty\" json:\"commands,omitempty\"`\n}\n\n\n\n\nfunc (p Command) String() string ", "output": "{\n\tb, _ := json.Marshal(p)\n\treturn string(b)\n}"}
{"input": "package metrics\n\n\n\n\n\ntype Healthcheck interface {\n\tCheck()\n\tError() error\n\tHealthy()\n\tUnhealthy(error)\n}\n\n\n\ntype StandardHealthcheck struct {\n\terr error\n\tf   func(Healthcheck)\n}\n\n\n\nfunc NewHealthcheck(f func(Healthcheck)) *StandardHealthcheck {\n\treturn &StandardHealthcheck{nil, f}\n}\n\n\n\n\n\nfunc (h *StandardHealthcheck) Error() error {\n\treturn h.err\n}\n\n\nfunc (h *StandardHealthcheck) Healthy() {\n\th.err = nil\n}\n\n\nfunc (h *StandardHealthcheck) Unhealthy(err error) {\n\th.err = err\n}\n\nfunc (h *StandardHealthcheck) Check() ", "output": "{\n\th.f(h)\n}"}
{"input": "package cmd\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/kubernetes-incubator/kube-aws/core/controlplane/cluster\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar (\n\tcmdVersion = &cobra.Command{\n\t\tUse:   \"version\",\n\t\tShort: \"Print version information and exit\",\n\t\tLong:  ``,\n\t\tRun:   runCmdVersion,\n\t}\n)\n\nfunc init() {\n\tRootCmd.AddCommand(cmdVersion)\n}\n\n\n\nfunc runCmdVersion(_ *cobra.Command, _ []string) ", "output": "{\n\tfmt.Printf(\"kube-aws version %s\\n\", cluster.VERSION)\n}"}
{"input": "package sender\n\nimport (\n    \"errors\"\n    \"github.com/labstack/echo\"\n    \"github.com/sdvdxl/dinghook\"\n    \"log\"\n    \"net/http\"\n)\n\ntype DingTalk struct {\n}\n\n\n\nfunc NewDingTalk() *DingTalk {\n    return &DingTalk{}\n}\n\nfunc (d *DingTalk) Send(token string, content, msgType string) error ", "output": "{\n    if token == \"\" {\n        return errors.New(\"need dingding token\")\n    }\n\n    \n    ding := dinghook.NewDing(token)\n    var result dinghook.Result\n    if msgType == dinghook.MsgTypeMarkdown {\n        result = ding.SendMarkdown(dinghook.Markdown{Title: \"告警\", Content: content})\n    } else {\n        result = ding.SendMessage(dinghook.Message{Content: content})\n    }\n    log.Println(result)\n    if !result.Success {\n        log.Println(\"token:\", token, \" send result:\", result)\n        return echo.NewHTTPError(http.StatusBadRequest, result.ErrMsg)\n    }\n\n    return nil\n}"}
{"input": "package big\n\nfunc mulWW(x, y Word) (z1, z0 Word) {\n\treturn mulWW_g(x, y)\n}\n\nfunc divWW(x1, x0, y Word) (q, r Word) {\n\treturn divWW_g(x1, x0, y)\n}\n\nfunc addVV(z, x, y []Word) (c Word) {\n\treturn addVV_g(z, x, y)\n}\n\nfunc subVV(z, x, y []Word) (c Word) {\n\treturn subVV_g(z, x, y)\n}\n\nfunc addVW(z, x []Word, y Word) (c Word) {\n\treturn addVW_g(z, x, y)\n}\n\nfunc subVW(z, x []Word, y Word) (c Word) {\n\treturn subVW_g(z, x, y)\n}\n\nfunc shlVU(z, x []Word, s uint) (c Word) {\n\treturn shlVU_g(z, x, s)\n}\n\nfunc shrVU(z, x []Word, s uint) (c Word) {\n\treturn shrVU_g(z, x, s)\n}\n\nfunc mulAddVWW(z, x []Word, y, r Word) (c Word) {\n\treturn mulAddVWW_g(z, x, y, r)\n}\n\nfunc addMulVVW(z, x []Word, y Word) (c Word) {\n\treturn addMulVVW_g(z, x, y)\n}\n\n\n\nfunc bitLen(x Word) (n int) {\n\treturn bitLen_g(x)\n}\n\nfunc divWVW(z []Word, xn Word, x []Word, y Word) (r Word) ", "output": "{\n\treturn divWVW_g(z, xn, x, y)\n}"}
{"input": "package client\n\nimport (\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/watch\"\n\n\tsdnapi \"github.com/projectatomic/atomic-enterprise/pkg/sdn/api\"\n)\n\n\ntype HostSubnetsInterface interface {\n\tHostSubnets() HostSubnetInterface\n}\n\n\ntype HostSubnetInterface interface {\n\tList() (*sdnapi.HostSubnetList, error)\n\tGet(name string) (*sdnapi.HostSubnet, error)\n\tCreate(sub *sdnapi.HostSubnet) (*sdnapi.HostSubnet, error)\n\tDelete(name string) error\n\tWatch(resourceVersion string) (watch.Interface, error)\n}\n\n\ntype hostSubnet struct {\n\tr *Client\n}\n\n\nfunc newHostSubnet(c *Client) *hostSubnet {\n\treturn &hostSubnet{\n\t\tr: c,\n\t}\n}\n\n\n\n\n\nfunc (c *hostSubnet) Get(hostName string) (result *sdnapi.HostSubnet, err error) {\n\tresult = &sdnapi.HostSubnet{}\n\terr = c.r.Get().Resource(\"hostSubnets\").Name(hostName).Do().Into(result)\n\treturn\n}\n\n\nfunc (c *hostSubnet) Create(hostSubnet *sdnapi.HostSubnet) (result *sdnapi.HostSubnet, err error) {\n\tresult = &sdnapi.HostSubnet{}\n\terr = c.r.Post().Resource(\"hostSubnets\").Body(hostSubnet).Do().Into(result)\n\treturn\n}\n\n\nfunc (c *hostSubnet) Delete(name string) error {\n\treturn c.r.Delete().Resource(\"hostSubnets\").Name(name).Do().Error()\n}\n\n\nfunc (c *hostSubnet) Watch(resourceVersion string) (watch.Interface, error) {\n\treturn c.r.Get().\n\t\tPrefix(\"watch\").\n\t\tResource(\"hostSubnets\").\n\t\tParam(\"resourceVersion\", resourceVersion).\n\t\tWatch()\n}\n\nfunc (c *hostSubnet) List() (result *sdnapi.HostSubnetList, err error) ", "output": "{\n\tresult = &sdnapi.HostSubnetList{}\n\terr = c.r.Get().\n\t\tResource(\"hostSubnets\").\n\t\tDo().\n\t\tInto(result)\n\treturn\n}"}
{"input": "package protocol\n\ntype DeleteTopicsResponse struct {\n\tTopicErrorCodes []*TopicErrorCode\n}\n\nfunc (c *DeleteTopicsResponse) Encode(e PacketEncoder) error {\n\te.PutArrayLength(len(c.TopicErrorCodes))\n\tfor _, t := range c.TopicErrorCodes {\n\t\te.PutString(t.Topic)\n\t\te.PutInt16(t.ErrorCode)\n\t}\n\treturn nil\n}\n\n\n\nfunc (c *DeleteTopicsResponse) Decode(d PacketDecoder) error ", "output": "{\n\tl, err := d.ArrayLength()\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.TopicErrorCodes = make([]*TopicErrorCode, l)\n\tfor i := range c.TopicErrorCodes {\n\t\ttopic, err := d.String()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terrorCode, err := d.Int16()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.TopicErrorCodes[i] = &TopicErrorCode{\n\t\t\tTopic:     topic,\n\t\t\tErrorCode: errorCode,\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package common\n\nimport (\n\t\"fmt\"\n\t\"github.com/mitchellh/multistep\"\n\t\"github.com/orivej/packer/packer\"\n)\n\n\n\n\n\n\n\n\n\n\n\ntype StepCompactDisk struct {\n\tSkip bool\n}\n\n\n\nfunc (*StepCompactDisk) Cleanup(multistep.StateBag) {}\n\nfunc (s *StepCompactDisk) Run(state multistep.StateBag) multistep.StepAction ", "output": "{\n\tdriver := state.Get(\"driver\").(Driver)\n\tvmName := state.Get(\"vmName\").(string)\n\tui := state.Get(\"ui\").(packer.Ui)\n\n\tif s.Skip {\n\t\tui.Say(\"Skipping disk compaction step...\")\n\t\treturn multistep.ActionContinue\n\t}\n\n\tui.Say(\"Compacting the disk image\")\n\tdiskPath, err := driver.DiskPath(vmName)\n\tif err != nil {\n\t\terr := fmt.Errorf(\"Error detecting virtual disk path: %s\", err)\n\t\tstate.Put(\"error\", err)\n\t\tui.Error(err.Error())\n\t\treturn multistep.ActionHalt\n\t}\n\n\tif err := driver.CompactDisk(diskPath); err != nil {\n\t\tstate.Put(\"error\", fmt.Errorf(\"Error compacting disk: %s\", err))\n\t\tui.Error(err.Error())\n\t\treturn multistep.ActionHalt\n\t}\n\n\treturn multistep.ActionContinue\n}"}
{"input": "package credentials\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype FakeProvider struct {\n\tError       error\n\tCredentials *Credentials\n}\n\n\n\nfunc TestFakeProviderAssignable(t *testing.T) {\n\tvar provider interface{}\n\tprovider = &FakeProvider{}\n\n\t_, ok := provider.(Provider)\n\tassert.True(t, ok, \"\")\n}\n\nfunc (p *FakeProvider) GetCredentials() (*Credentials, error) ", "output": "{\n\tif p.Credentials != nil {\n\t\treturn p.Credentials, nil\n\t}\n\n\tif p.Error != nil {\n\t\treturn nil, p.Error\n\t}\n\n\tpanic(\"Specify either Credentials or Error\")\n}"}
{"input": "package pool\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\nconst (\n\t_net = \"udp4\" \n)\n\nfunc createUDPConnection(address string) (*net.UDPConn, error) {\n\taddr, err := net.ResolveUDPAddr(_net, address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn, err := net.DialUDP(_net, nil, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}\n\nfunc worker(id int, address string, done chan bool, buffers <-chan []byte) {\n\n\tconn, err := createUDPConnection(address)\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\terr := conn.Close()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t}\n\t}()\n\n\tfor buffer := range buffers {\n\t\t_, err := conn.Write(buffer)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tdone <- true\n}\n\ntype UDPPool struct {\n\tbuffers chan []byte\n\tdone    chan bool\n}\n\n\n\n\nfunc (p *UDPPool) Fire(buffer []byte) {\n\tp.buffers <- buffer\n}\n\nfunc (p *UDPPool) Close() {\n\tclose(p.buffers)\n}\n\nfunc NewUDPPool(address string, workerNumber int) *UDPPool ", "output": "{\n\tbuffers := make(chan []byte, workerNumber)\n\tdone := make(chan bool)\n\n\tfor wid := 1; wid < workerNumber; wid++ {\n\t\tgo worker(wid, address, done, buffers)\n\t}\n\treturn &UDPPool{buffers, done}\n}"}
{"input": "package containerinstance\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\n\n\n\nfunc Version() string {\n\treturn version.Number\n}\n\nfunc UserAgent() string ", "output": "{\n\treturn \"Azure-SDK-For-Go/\" + Version() + \" containerinstance/2021-03-01\"\n}"}
{"input": "package logger\n\nimport (\n\t\"net/http\"\n\t\"time\"\n)\n\n\n\nfunc HTTPLogger(inner http.Handler, name string) http.Handler ", "output": "{\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tstart := time.Now()\n\n\t\tinner.ServeHTTP(w, r)\n\n\t\tInfo.Printf(\n\t\t\t\"%s\\t%s\\t%s\\t%s\",\n\t\t\tr.Method,\n\t\t\tr.RequestURI,\n\t\t\tname,\n\t\t\ttime.Since(start),\n\t\t)\n\t})\n}"}
{"input": "package gtka\n\nimport (\n\t\"github.com/twstrike/coyim/Godeps/_workspace/src/github.com/gotk3/gotk3/gtk\"\n\t\"github.com/twstrike/coyim/Godeps/_workspace/src/github.com/twstrike/gotk3adapter/gtki\"\n)\n\ntype headerBar struct {\n\t*container\n\tinternal *gtk.HeaderBar\n}\n\nfunc wrapHeaderBarSimple(v *gtk.HeaderBar) *headerBar {\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn &headerBar{wrapContainerSimple(&v.Container), v}\n}\n\n\n\nfunc unwrapHeaderBar(v gtki.HeaderBar) *gtk.HeaderBar {\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn v.(*headerBar).internal\n}\n\nfunc (v *headerBar) SetSubtitle(v1 string) {\n\tv.internal.SetSubtitle(v1)\n}\n\nfunc wrapHeaderBar(v *gtk.HeaderBar, e error) (*headerBar, error) ", "output": "{\n\treturn wrapHeaderBarSimple(v), e\n}"}
{"input": "package sanitize\n\nimport(\n\t\"os\"\n\t\"encoding/json\"\n)\n\n\nfunc WhitelistFromFile(filepath string) (*Whitelist, error) {\n\tbytes, err := readFileToBytes(filepath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\twhitelist, err := NewWhitelist(bytes)\n\treturn whitelist, nil\n}\n\n\n\n\n\nfunc NewWhitelist(jsonData []byte) (*Whitelist, error) {\n\tconfiguration := &Whitelist{}\n\terr := json.Unmarshal(jsonData, configuration)\n\n\treturn configuration, err\n}\n\nfunc readFileToBytes(filepath string) ([]byte, error) ", "output": "{\n\tf, err := os.Open(filepath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfileInfo, err := f.Stat()\n\tbytes := make([]byte, fileInfo.Size())\n\n\t_, err = f.Read(bytes)\n\treturn bytes, err\n}"}
{"input": "package main\n\nimport \"fmt\"\n\n\n\nfunc withDefer() {\n\tfmt.Println(\"### withDefer\")\n\tdefer fmt.Println(\"world\")\n\tfmt.Println(\"hello\")\n}\n\nfunc main() {\n\twithoutDefer()\n\twithDefer()\n\n\tdefer fmt.Println(\"Exiting func main\")\n\tpanic(-1) \n}\n\nfunc withoutDefer() ", "output": "{\n\tfmt.Println(\"### withoutDefer\")\n\tfmt.Println(\"world\")\n\tfmt.Println(\"hello\")\n\n}"}
{"input": "package core\n\nimport (\n\t\"reflect\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\ntype Class interface {\n\tSupers() []Class\n\tSlots() []Instance\n\tInitform(Instance) (Instance, bool)\n\tInitarg(Instance) (Instance, bool)\n\tClass() Class\n\tString() string\n}\n\ntype Instance interface {\n\tClass() Class\n\tString() string\n}\n\n\n\nfunc SubclassOf(super, sub Class) bool {\n\tvar subclassof func(p, c Class) bool\n\tsubclassof = func(p, c Class) bool {\n\t\tif DeepEqual(p, c) {\n\t\t\treturn true\n\t\t}\n\t\tfor _, d := range c.Supers() {\n\t\t\tif subclassof(p, d) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfor _, d := range sub.Supers() {\n\t\tif subclassof(super, d) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc InstanceOf(c Class, i Instance) bool {\n\tif DeepEqual(c, i.Class()) {\n\t\treturn true\n\t}\n\treturn SubclassOf(c, i.Class())\n}\n\nfunc DeepEqual(x, y interface{}) bool ", "output": "{\n\treturn reflect.DeepEqual(x, y) || cmp.Equal(x, y, cmp.AllowUnexported(BuiltInClass{}, StandardClass{}, Function{}))\n}"}
{"input": "package server\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/kyokomi/expcache\"\n)\n\ntype ImageCache interface {\n\tGetRandomImageURL() string\n}\n\ntype imageCache struct {\n\tExpire expcache.ExpireOnMemoryCache\n\tcache  []string\n\n\ttwAPI     TwitterAPI\n\trd        *rand.Rand\n\ttwitterID string\n\tcacheCnt  int\n}\n\n\n\nfunc (c *imageCache) GetRandomImageURL() string {\n\tvar result string\n\tc.Expire.WithRefreshLock(time.Now(), func() {\n\t\tidx := c.rd.Int31n(int32(len(c.cache))) - 1\n\t\tresult = c.cache[idx]\n\t})\n\treturn result\n}\n\nfunc (c *imageCache) Refresh() error {\n\timages, err := c.twAPI.GetFavoritesImages(c.cacheCnt, c.twitterID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.cache = images\n\treturn nil\n}\n\nvar _ expcache.OnMemoryCache = (*imageCache)(nil)\nvar _ ImageCache = (*imageCache)(nil)\n\nfunc NewImageCache(twAPI TwitterAPI, twitterID string, cacheCnt int) ImageCache ", "output": "{\n\te := &imageCache{\n\t\tcache:     []string{},\n\t\ttwAPI:     twAPI,\n\t\trd:        rand.New(rand.NewSource(time.Now().UnixNano())),\n\t\ttwitterID: twitterID,\n\t\tcacheCnt:  cacheCnt,\n\t}\n\te.Expire = expcache.NewExpireMemoryCache(e, 24*time.Hour)\n\treturn e\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSSESReceiptRule_StopAction struct {\n\n\tScope string `json:\"Scope,omitempty\"`\n\n\tTopicArn string `json:\"TopicArn,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSSESReceiptRule_StopAction) AWSCloudFormationType() string {\n\treturn \"AWS::SES::ReceiptRule.StopAction\"\n}\n\n\n\nfunc (r *AWSSESReceiptRule_StopAction) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSSESReceiptRule_StopAction) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\n\n\n\n\nfunc (r *AWSSESReceiptRule_StopAction) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSSESReceiptRule_StopAction) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSSESReceiptRule_StopAction) Metadata() map[string]interface{} ", "output": "{\n\treturn r._metadata\n}"}
{"input": "package user\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/m-o-s-e-s/mgm/mgm\"\n\t\"github.com/satori/go.uuid\"\n)\n\n\nfunc (um Manager) Auth(username string, password string) (mgm.User, bool) {\n\tum.uMutex.Lock()\n\tdefer um.uMutex.Unlock()\n\n\tvar user mgm.User\n\tfound := false\n\tfor _, u := range um.users {\n\t\tif strings.EqualFold(u.Name, username) {\n\t\t\tuser = u\n\t\t\tfound = true\n\t\t}\n\t}\n\n\tif found == false {\n\t\tum.log.Info(\"User %v does not exist\", username)\n\t\treturn user, false\n\t}\n\n\tvalid, guid, err := um.conn.Auth(username, password)\n\tif err != nil {\n\t\tum.log.Error(fmt.Sprintf(\"Cannot authenticate user: %v\", err.Error()))\n\t}\n\tif err != nil || valid == false {\n\t\tum.log.Info(\"User %v simian invalid\", username)\n\t\treturn user, valid\n\t}\n\n\tif guid != user.UserID {\n\t\tum.log.Error(fmt.Sprintf(\"Error: Authenticated user does not match local user\"))\n\t\treturn mgm.User{}, false\n\t}\n\tum.log.Info(\"User %v auth successful\", username)\n\treturn user, true\n}\n\n\n\n\nfunc (um Manager) SetPassword(userID uuid.UUID, password string) error ", "output": "{\n\t_, exists := um.GetUser(userID)\n\tif !exists {\n\t\treturn errors.New(\"User not found\")\n\t}\n\treturn um.conn.SetPassword(userID, password)\n}"}
{"input": "package main\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSum(t *testing.T) {\n\n\tt.Run(\"collections of any size\", func(t *testing.T) {\n\n\t\tnumbers := []int{1, 2, 3}\n\n\t\tgot := Sum(numbers)\n\t\twant := 6\n\n\t\tif got != want {\n\t\t\tt.Errorf(\"got %d want %d given, %v\", got, want, numbers)\n\t\t}\n\t})\n\n}\n\n\n\nfunc TestSumAllTails(t *testing.T) ", "output": "{\n\n\tcheckSums := func(t *testing.T, got, want []int) {\n\t\tif !reflect.DeepEqual(got, want) {\n\t\t\tt.Errorf(\"got %v want %v\", got, want)\n\t\t}\n\t}\n\n\tt.Run(\"make the sums of tails of\", func(t *testing.T) {\n\t\tgot := SumAllTails([]int{1, 2}, []int{0, 9})\n\t\twant := []int{2, 9}\n\t\tcheckSums(t, got, want)\n\t})\n\n\tt.Run(\"safely sum empty slices\", func(t *testing.T) {\n\t\tgot := SumAllTails([]int{}, []int{3, 4, 5})\n\t\twant := []int{0, 9}\n\t\tcheckSums(t, got, want)\n\t})\n\n}"}
{"input": "package user\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-swagger/go-swagger/errors\"\n\t\"github.com/go-swagger/go-swagger/httpkit/middleware\"\n\n\t\"github.com/go-swagger/go-swagger/examples/generated/models\"\n)\n\n\n\nfunc NewCreateUsersWithArrayInputParams() CreateUsersWithArrayInputParams {\n\treturn CreateUsersWithArrayInputParams{}\n}\n\n\n\n\n\ntype CreateUsersWithArrayInputParams struct {\n\tBody []*models.User\n}\n\n\n\n\n\nfunc (o *CreateUsersWithArrayInputParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error ", "output": "{\n\tvar res []error\n\n\tvar body []*models.User\n\tif err := route.Consumer.Consume(r.Body, &body); err != nil {\n\t\tres = append(res, errors.NewParseError(\"body\", \"body\", \"\", err))\n\t} else {\n\t\tfor _, io := range o.Body {\n\t\t\tif err := io.Validate(route.Formats); err != nil {\n\t\t\t\tres = append(res, err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif len(res) == 0 {\n\t\t\to.Body = body\n\t\t}\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package web\n\nimport (\n\t\"github.com/smartystreets/acidic/contracts\"\n\t\"github.com/smartystreets/acidic/contracts/models\"\n\t\"github.com/smartystreets/detour\"\n)\n\ntype Controller struct {\n\tsender contracts.MessageSender\n}\n\nfunc NewController(sender contracts.MessageSender) *Controller {\n\treturn &Controller{sender: sender}\n}\n\nfunc (this *Controller) Load(input *models.LoadInput) detour.Renderer {\n\treturn this.handle(input.ToMessage())\n}\n\nfunc (this *Controller) Store(input *models.StoreInput) detour.Renderer {\n\tdefer input.Close()\n\treturn this.handle(input.ToMessage())\n}\nfunc (this *Controller) Delete(input *models.DeleteInput) detour.Renderer {\n\treturn this.handle(input.ToMessage())\n}\n\nfunc (this *Controller) Commit(input *models.TransactionInput) detour.Renderer {\n\treturn this.handle(input.ToCommitMessage())\n}\n\n\nfunc (this *Controller) handle(message interface{}) detour.Renderer {\n\tresult := this.sender.Send(message)\n\treturn NewApplicationResultRenderer(result)\n}\n\nfunc (this *Controller) Abort(input *models.TransactionInput) detour.Renderer ", "output": "{\n\treturn this.handle(input.ToAbortMessage())\n}"}
{"input": "package engine\n\nimport (\n\t\"testing\"\n\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\n\n\nfunc TestUnitsCounterAddBalanceExists(t *testing.T) {\n\tuc := &UnitsCounter{\n\t\tDirection:   OUTBOUND,\n\t\tBalanceType: utils.SMS,\n\t\tBalances:    BalanceChain{&Balance{Value: 1}, &Balance{Value: 10, Weight: 20, DestinationIds: \"NAT\"}, &Balance{Weight: 10, DestinationIds: \"RET\"}},\n\t}\n\tuc.addUnits(5, \"0723\")\n\tif len(uc.Balances) != 3 || uc.Balances[1].Value != 15 {\n\t\tt.Error(\"Error adding minute bucket!\")\n\t}\n}\n\nfunc TestUnitsCounterAddBalance(t *testing.T) ", "output": "{\n\tuc := &UnitsCounter{\n\t\tDirection:   OUTBOUND,\n\t\tBalanceType: utils.SMS,\n\t\tBalances:    BalanceChain{&Balance{Value: 1}, &Balance{Weight: 20, DestinationIds: \"NAT\"}, &Balance{Weight: 10, DestinationIds: \"RET\"}},\n\t}\n\tuc.addUnits(20, \"test\")\n\tif len(uc.Balances) != 3 {\n\t\tt.Error(\"Error adding minute bucket: \", uc.Balances)\n\t}\n}"}
{"input": "package fixtures\n\nimport (\n\t\"github.com/google/uuid\"\n\t\"github.com/negz/q\"\n)\n\ntype predictableManager struct {\n\tq   q.Queue\n\terr error\n}\n\n\n\n\n\nfunc (m *predictableManager) Add(queue q.Queue) error {\n\treturn m.err\n}\n\nfunc (m *predictableManager) Get(id uuid.UUID) (q.Queue, error) {\n\treturn m.q, m.err\n}\n\nfunc (m *predictableManager) Delete(id uuid.UUID) error {\n\treturn m.err\n}\n\nfunc (m *predictableManager) List() ([]q.Queue, error) {\n\treturn []q.Queue{m.q}, m.err\n}\n\nfunc NewPredictableManager(queue q.Queue, err error) q.Manager ", "output": "{\n\treturn &predictableManager{q: queue, err: err}\n}"}
{"input": "package format\n\nimport (\n\t\"testing\"\n\n\tlog \"github.com/Sirupsen/logrus\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestSshWithComment(t *testing.T) {\n\tlog.SetLevel(log.DebugLevel)\n\n\tkeys := map[string][]string{\n\t\t\"ernoaapa\": {\n\t\t\t\"ssh-rsa AAAAB3NzsshPublicKeyBlah\",\n\t\t},\n\t}\n\n\tresult := ssh(keys, \"Generated file\")\n\n\tassert.Equal(t, \"# Generated file\\nssh-rsa AAAAB3NzsshPublicKeyBlah ernoaapa\\n# Generated file\\n\", result, \"Returned invalid ssh output\")\n}\n\nfunc TestSshWithoutComment(t *testing.T) ", "output": "{\n\tlog.SetLevel(log.DebugLevel)\n\n\tkeys := map[string][]string{\n\t\t\"ernoaapa\": {\n\t\t\t\"ssh-rsa AAAAB3NzsshPublicKeyBlah\",\n\t\t},\n\t}\n\n\tresult := ssh(keys, \"\")\n\n\tassert.Equal(t, \"ssh-rsa AAAAB3NzsshPublicKeyBlah ernoaapa\\n\", result, \"Returned invalid ssh output\")\n}"}
{"input": "package notificationhubs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\nfunc New(subscriptionID string) BaseClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient ", "output": "{\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}"}
{"input": "package taskmq\n\ntype Stub struct{}\n\nfunc (c Stub) Clone() *Stub {\n\treturn &Stub{}\n}\n\nfunc (c Stub) Push(name string, body []byte) error {\n\treturn nil\n}\n\n\n\nfunc (c Stub) Pop() []byte {\n\treturn []byte{}\n}\n\nfunc (c Stub) Ack() error {\n\treturn nil\n}\n\nfunc (c Stub) Nack() error {\n\treturn nil\n}\n\nfunc (c Stub) InitConsumer(queue string) []byte ", "output": "{\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestWallet(t *testing.T) ", "output": "{\n\n\tassertBalance := func(t *testing.T, wallet Wallet, want Bitcoin) {\n\t\tt.Helper()\n\t\tgot := wallet.Balance()\n\n\t\tif got != want {\n\t\t\tt.Errorf(\"got %s want %s\", got, want)\n\t\t}\n\t}\n\n\tt.Run(\"Deposit\", func(t *testing.T) {\n\t\twallet := Wallet{}\n\t\twallet.Deposit(Bitcoin(10))\n\t\tassertBalance(t, wallet, Bitcoin(10))\n\t})\n\n\tt.Run(\"Withdraw\", func(t *testing.T) {\n\t\twallet := Wallet{balance: Bitcoin(20)}\n\t\twallet.Withdraw(10)\n\t\tassertBalance(t, wallet, Bitcoin(10))\n\t})\n\n}"}
{"input": "package sourcetest\n\n\n\nfunc TestSourcePointerExtract() ", "output": "{\n\ts, _ := NewSource() \n\t_ = s\n}"}
{"input": "package gl\n\nimport (\n\t\"image\"\n)\n\n\n\n\nimport \"C\"\n\n\n\n\ntype Texture3D struct {\n\tobject C.GLuint\n\tformat TextureFormat\n}\n\n\nfunc NewTexture3D(levels int32, f TextureFormat, width, height, depth int32) Texture3D {\n\tvar t Texture3D\n\tt.format = f\n\tt.object = C.NewTexture3D(C.GLsizei(levels), C.GLenum(f), C.GLsizei(width), C.GLsizei(height), C.GLsizei(depth))\n\treturn t\n}\n\n\n\n\n\n\nfunc (t *Texture3D) GenerateMipmap() {\n\tC.TextureGenerateMipmap(t.object)\n}\n\n\nfunc (t *Texture3D) Bind(index uint32) {\n\tC.BindTextureUnit(C.GLuint(index), t.object)\n}\n\n\nfunc (t *Texture3D) Delete() {\n\tC.DeleteTexture(t.object)\n}\n\nfunc (t *Texture3D) SubImage(level int32, ox, oy, oz int32, img image.Image) ", "output": "{\n\tp, pf, pt := pointerFormatAndTypeOf(img)\n\tC.Texture3DSubImage(\n\t\tt.object,\n\t\tC.GLint(level),\n\t\tC.GLint(ox), C.GLint(oy), C.GLint(oz),\n\t\tC.GLsizei(img.Bounds().Dx()), C.GLsizei(img.Bounds().Dy()), C.GLsizei(1),\n\t\tpf, pt, p,\n\t)\n}"}
{"input": "package main\n\nimport (\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc TestFirst(t *testing.T) {\n\tresult := solveFirst([]int{\n\t\t0,\n\t\t3,\n\t\t0,\n\t\t1,\n\t\t-3,\n\t})\n\n\tcheckResult(t, result, 5)\n}\n\nfunc TestSecond(t *testing.T) {\n\tresult := solveSecond([]int{\n\t\t0,\n\t\t3,\n\t\t0,\n\t\t1,\n\t\t-3,\n\t})\n\n\tcheckResult(t, result, 10)\n}\n\n\n\nfunc checkResult(t *testing.T, actualResult int, requiredResult int) ", "output": "{\n\tt.Helper()\n\n\tif actualResult != requiredResult {\n\t\tt.Error(fmt.Printf(\"steps count must be %+v, but: %+v\", requiredResult, actualResult))\n\t}\n}"}
{"input": "package fv_test\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\t\"github.com/projectcalico/libcalico-go/lib/testutils\"\n\t\"github.com/sirupsen/logrus\"\n\n\t\"testing\"\n\n\t\"github.com/onsi/ginkgo/reporters\"\n)\n\nfunc init() {\n\ttestutils.HookLogrusForGinkgo()\n\tlogrus.SetLevel(logrus.InfoLevel)\n}\n\n\n\nfunc TestFv(t *testing.T) ", "output": "{\n\tRegisterFailHandler(Fail)\n\tjunitReporter := reporters.NewJUnitReporter(\"../../report/fv_suite.xml\")\n\tRunSpecsWithDefaultAndCustomReporters(t, \"Fv Suite\", []Reporter{junitReporter})\n}"}
{"input": "package keyvalue\n\nimport \"fmt\"\n\n\ntype Map map[interface{}]interface{}\n\n\nfunc (m Map) Get(key interface{}) (interface{}, error) {\n\tif v, ok := m[key]; ok {\n\t\treturn v, nil\n\t}\n\treturn nil, KeyError(fmt.Sprintf(\"%s\", key))\n}\n\n\nfunc (m Map) Set(key interface{}, v interface{}) error {\n\tm[key] = v\n\treturn nil\n}\n\n\nfunc NewMap() Map {\n\treturn Map(make(map[interface{}]interface{}))\n}\n\n\ntype StringKeyMap map[string]interface{}\n\n\nfunc (m StringKeyMap) Get(key interface{}) (interface{}, error) {\n\tif v, ok := m[key.(string)]; ok {\n\t\treturn v, nil\n\t}\n\treturn nil, KeyError(fmt.Sprintf(\"%s\", key))\n}\n\n\nfunc (m StringKeyMap) Set(key interface{}, v interface{}) error {\n\tm[key.(string)] = v\n\treturn nil\n}\n\n\nfunc (m StringKeyMap) Del(key interface{}) error {\n\tdelete(m, key.(string))\n\treturn nil\n}\n\n\n\n\nfunc NewStringKeyMap() StringKeyMap ", "output": "{\n\treturn StringKeyMap(make(map[string]interface{}))\n}"}
{"input": "package reading\n\nimport (\n\t\"time\"\n\n\t\"github.com/astaxie/beego/orm\"\n\t\"github.com/kapmahc/fly/plugins/nut\"\n)\n\n\ntype Book struct {\n\tID uint `orm:\"column(id)\" json:\"id\"`\n\n\tAuthor      string    `json:\"author\"`\n\tPublisher   string    `json:\"publisher\"`\n\tTitle       string    `json:\"title\"`\n\tType        string    `json:\"type\"`\n\tLang        string    `json:\"lang\"`\n\tFile        string    `json:\"-\"`\n\tSubject     string    `json:\"subject\"`\n\tDescription string    `json:\"description\"`\n\tPublishedAt time.Time `json:\"publishedAt\"`\n\tCover       string    `json:\"cover\"`\n\tUpdatedAt   time.Time `orm:\"auto_now\" json:\"updatedAt\"`\n\tCreatedAt   time.Time `orm:\"auto_now_add\" json:\"createdAt\"`\n}\n\n\nfunc (*Book) TableName() string {\n\treturn \"reading_books\"\n}\n\n\ntype Note struct {\n\tID        uint `orm:\"column(id)\" json:\"id\"`\n\tType      string\n\tBody      string\n\tUpdatedAt time.Time `orm:\"auto_now\" json:\"updatedAt\"`\n\tCreatedAt time.Time `orm:\"auto_now_add\" json:\"createdAt\"`\n\n\tUser *nut.User `orm:\"rel(fk)\"`\n\tBook *Book     `orm:\"rel(fk)\"`\n}\n\n\nfunc (*Note) TableName() string {\n\treturn \"reading_notes\"\n}\n\n\nfunc init() ", "output": "{\n\torm.RegisterModel(new(Book), new(Note))\n}"}
{"input": "package stack\n\nimport \"errors\"\n\ntype Stack []interface{}\n\nfunc (stack Stack) Len() int {\n\treturn len(stack)\n}\n\nfunc (stack Stack) Cap() int {\n\treturn cap(stack)\n}\n\nfunc (stack Stack) IsEmpty() bool {\n\treturn len(stack) == 0\n}\n\n\n\nfunc (stack Stack) Top() (interface{}, error) {\n\tif len(stack) == 0 {\n\t\treturn nil, errors.New(\"stack is empty\")\n\t}\n\treturn stack[len(stack)-1], nil\n}\n\nfunc (stack *Stack) Pop() (interface{}, error) {\n\tstk := *stack\t\n\tif len(stk) == 0 {\n\t\treturn nil, errors.New(\"stack is empty\")\n\t}\n\ttop := stk[len(stk)-1]\n\t*stack = stk[:len(stk)-1] \n\treturn top, nil\n}\n\nfunc (stack *Stack) Push(e interface{}) ", "output": "{\n\t*stack = append(*stack, e)\n}"}
{"input": "package metrics\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype KubeletMetrics Metrics\n\nfunc (m *KubeletMetrics) Equal(o KubeletMetrics) bool {\n\treturn (*Metrics)(m).Equal(Metrics(o))\n}\n\nfunc NewKubeletMetrics() KubeletMetrics {\n\tresult := NewMetrics()\n\treturn KubeletMetrics(result)\n}\n\n\n\nfunc GrabKubeletMetricsWithoutProxy(nodeName string) (KubeletMetrics, error) {\n\tmetricsEndpoint := \"http://%s/metrics\"\n\tresp, err := http.Get(fmt.Sprintf(metricsEndpoint, nodeName))\n\tif err != nil {\n\t\treturn KubeletMetrics{}, err\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn KubeletMetrics{}, err\n\t}\n\treturn parseKubeletMetrics(string(body))\n}\n\nfunc parseKubeletMetrics(data string) (KubeletMetrics, error) {\n\tresult := NewKubeletMetrics()\n\tif err := parseMetrics(data, (*Metrics)(&result)); err != nil {\n\t\treturn KubeletMetrics{}, err\n\t}\n\treturn result, nil\n}\n\n\n\nfunc (g *MetricsGrabber) getMetricsFromNode(nodeName string, kubeletPort int) (string, error) ", "output": "{\n\tfinished := make(chan struct{})\n\tvar err error\n\tvar rawOutput []byte\n\tgo func() {\n\t\trawOutput, err = g.client.Core().RESTClient().Get().\n\t\t\tResource(\"nodes\").\n\t\t\tSubResource(\"proxy\").\n\t\t\tName(fmt.Sprintf(\"%v:%v\", nodeName, kubeletPort)).\n\t\t\tSuffix(\"metrics\").\n\t\t\tDo().Raw()\n\t\tfinished <- struct{}{}\n\t}()\n\tselect {\n\tcase <-time.After(ProxyTimeout):\n\t\treturn \"\", fmt.Errorf(\"Timed out when waiting for proxy to gather metrics from %v\", nodeName)\n\tcase <-finished:\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn string(rawOutput), nil\n\t}\n}"}
{"input": "package templates\n\nimport (\n\t\"net/http\"\n)\n\ntype HttpResponseHandler func(w http.ResponseWriter, r *http.Request) *HttpResponse\n\ntype HttpResponse struct {\n\tRequest  *http.Request\n\tWriter   http.ResponseWriter\n\tTemplate string\n\tContext  map[string]interface{}\n\tError    error\n\tCode     int\n}\n\nfunc Response(code int, template string, ctx map[string]interface{}) *HttpResponse {\n\treturn &HttpResponse{Code: code, Template: template, Context: ctx}\n}\n\nfunc (resp *HttpResponse) SetBase(w http.ResponseWriter, r *http.Request) *HttpResponse {\n\tresp.Writer = w\n\tresp.Request = r\n\treturn resp\n}\n\nfunc (resp *HttpResponse) UpdateContext(ctx map[string]interface{}) *HttpResponse {\n\tif nil == resp.Context {\n\t\tresp.Context = ctx\n\t} else if nil != ctx {\n\t\tfor k, v := range resp.Context {\n\t\t\tresp.Context[k] = v\n\t\t}\n\t}\n\treturn resp\n}\n\n\n\nfunc HttpHandler(render *TemplateRender, f HttpResponseHandler) http.HandlerFunc {\n\tif nil == render {\n\t\trender = GlobalRender\n\t}\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tresp := f(w, r)\n\t\tif nil != resp {\n\t\t\tresp.Writer = w\n\t\t\tresp.Request = r\n\t\t\trender.RenderResponse(resp)\n\t\t} else {\n\t\t\thttp.Error(w, \"Invalid http response\", http.StatusInternalServerError)\n\t\t}\n\t}\n}\n\nfunc (resp *HttpResponse) SetContext(ctx map[string]interface{}) *HttpResponse ", "output": "{\n\tresp.Context = ctx\n\treturn resp\n}"}
{"input": "package api\n\nimport \"testing\"\n\n\n\nfunc assertWriteMeta(t *testing.T, wm *WriteMeta) {\n\tif wm.LastIndex == 0 {\n\t\tt.Fatalf(\"bad index: %d\", wm.LastIndex)\n\t}\n}\n\nfunc testJob() *Job {\n\ttask := NewTask(\"task1\", \"exec\").\n\t\tSetConfig(\"command\", \"/bin/sleep\").\n\t\tRequire(&Resources{\n\t\t\tCPU:      100,\n\t\t\tMemoryMB: 256,\n\t\t\tIOPS:     10,\n\t\t}).\n\t\tSetLogConfig(&LogConfig{\n\t\t\tMaxFiles:      1,\n\t\t\tMaxFileSizeMB: 2,\n\t\t})\n\n\tgroup := NewTaskGroup(\"group1\", 1).\n\t\tAddTask(task).\n\t\tRequireDisk(&EphemeralDisk{\n\t\t\tSizeMB: 25,\n\t\t})\n\n\tjob := NewBatchJob(\"job1\", \"redis\", \"region1\", 1).\n\t\tAddDatacenter(\"dc1\").\n\t\tAddTaskGroup(group)\n\n\treturn job\n}\n\nfunc testPeriodicJob() *Job {\n\tjob := testJob().AddPeriodicConfig(&PeriodicConfig{\n\t\tEnabled:  true,\n\t\tSpec:     \"*/30 * * * *\",\n\t\tSpecType: \"cron\",\n\t})\n\treturn job\n}\n\nfunc assertQueryMeta(t *testing.T, qm *QueryMeta) ", "output": "{\n\tif qm.LastIndex == 0 {\n\t\tt.Fatalf(\"bad index: %d\", qm.LastIndex)\n\t}\n\tif !qm.KnownLeader {\n\t\tt.Fatalf(\"expected known leader, got none\")\n\t}\n}"}
{"input": "package spoon\n\nimport \"fmt\"\n\n\ntype FileDescriptorError struct {\n\tinnerError error\n}\n\n\nfunc (f *FileDescriptorError) Error() string {\n\treturn fmt.Sprint(\"FileDescriptor Error:\" + f.innerError.Error())\n}\n\nvar _ error = new(FileDescriptorError)\n\n\ntype ChildStartError struct {\n\tinnerError error\n}\n\n\nfunc (s *ChildStartError) Error() string {\n\treturn fmt.Sprint(\"Child Process Failed to Start:\" + s.innerError.Error())\n}\n\nvar _ error = new(ChildStartError)\n\n\ntype ChildShutdownError struct {\n\tinnerError error\n}\n\n\nfunc (s *ChildShutdownError) Error() string {\n\treturn fmt.Sprint(\"Child Shutdown Error:\" + s.innerError.Error() + \"\\n\\nNOTE: could just be the force termination because timeout reached\")\n}\n\nvar _ error = new(ChildShutdownError)\n\n\ntype SignalParentError struct {\n\tinnerError error\n}\n\n\n\n\nvar _ error = new(SignalParentError)\n\n\ntype ChildCrashError struct {\n\tinnerError error\n}\n\n\nfunc (s *ChildCrashError) Error() string {\n\treturn fmt.Sprint(\"Child Crashed:\" + s.innerError.Error())\n}\n\nvar _ error = new(ChildCrashError)\n\n\ntype BinaryUpdateError struct {\n\tinnerError error\n}\n\n\nfunc (b *BinaryUpdateError) Error() string {\n\treturn fmt.Sprint(\"Binary Update Error:\" + b.innerError.Error())\n}\n\nvar _ error = new(BinaryUpdateError)\n\nfunc (s *SignalParentError) Error() string ", "output": "{\n\treturn fmt.Sprint(\"Error Signaling parent:\" + s.innerError.Error())\n}"}
{"input": "package cobra\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestCompleteNoDesCmdInFishScript(t *testing.T) {\n\trootCmd := &Command{Use: \"root\", Args: NoArgs, Run: emptyRun}\n\tchild := &Command{\n\t\tUse:               \"child\",\n\t\tValidArgsFunction: validArgsFunc,\n\t\tRun:               emptyRun,\n\t}\n\trootCmd.AddCommand(child)\n\n\tbuf := new(bytes.Buffer)\n\tassertNoErr(t, rootCmd.GenFishCompletion(buf, false))\n\toutput := buf.String()\n\n\tcheck(t, output, ShellCompNoDescRequestCmd)\n}\n\nfunc TestCompleteCmdInFishScript(t *testing.T) {\n\trootCmd := &Command{Use: \"root\", Args: NoArgs, Run: emptyRun}\n\tchild := &Command{\n\t\tUse:               \"child\",\n\t\tValidArgsFunction: validArgsFunc,\n\t\tRun:               emptyRun,\n\t}\n\trootCmd.AddCommand(child)\n\n\tbuf := new(bytes.Buffer)\n\tassertNoErr(t, rootCmd.GenFishCompletion(buf, true))\n\toutput := buf.String()\n\n\tcheck(t, output, ShellCompRequestCmd)\n\tcheckOmit(t, output, ShellCompNoDescRequestCmd)\n}\n\n\n\nfunc TestProgWithColon(t *testing.T) {\n\trootCmd := &Command{Use: \"root:colon\", Args: NoArgs, Run: emptyRun}\n\tbuf := new(bytes.Buffer)\n\tassertNoErr(t, rootCmd.GenFishCompletion(buf, false))\n\toutput := buf.String()\n\n\tcheck(t, output, \"__root_colon_perform_completion\")\n\tcheckOmit(t, output, \"__root:colon_perform_completion\")\n\n\tcheck(t, output, \"-c root:colon\")\n\tcheckOmit(t, output, \"-c root_colon\")\n}\n\nfunc TestProgWithDash(t *testing.T) ", "output": "{\n\trootCmd := &Command{Use: \"root-dash\", Args: NoArgs, Run: emptyRun}\n\tbuf := new(bytes.Buffer)\n\tassertNoErr(t, rootCmd.GenFishCompletion(buf, false))\n\toutput := buf.String()\n\n\tcheck(t, output, \"__root_dash_perform_completion\")\n\tcheckOmit(t, output, \"__root-dash_perform_completion\")\n\n\tcheck(t, output, \"-c root-dash\")\n\tcheckOmit(t, output, \"-c root_dash\")\n}"}
{"input": "package undertaker\n\nimport (\n\t\"github.com/juju/errors\"\n\t\"github.com/juju/names\"\n\n\t\"github.com/juju/juju/environs/config\"\n\t\"github.com/juju/juju/state\"\n)\n\n\n\ntype State interface {\n\tstate.EntityFinder\n\n\tModel() (Model, error)\n\n\tIsController() bool\n\n\tProcessDyingModel() (err error)\n\n\tRemoveAllModelDocs() error\n\n\tAllMachines() ([]Machine, error)\n\n\tAllServices() ([]Service, error)\n\n\tModelConfig() (*config.Config, error)\n}\n\ntype stateShim struct {\n\t*state.State\n}\n\nfunc (s *stateShim) AllMachines() ([]Machine, error) {\n\tstateMachines, err := s.State.AllMachines()\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tmachines := make([]Machine, len(stateMachines))\n\tfor i := range stateMachines {\n\t\tmachines[i] = stateMachines[i]\n\t}\n\n\treturn machines, nil\n}\n\n\n\ntype Machine interface {\n\tWatch() state.NotifyWatcher\n}\n\nfunc (s *stateShim) AllServices() ([]Service, error) {\n\tstateServices, err := s.State.AllServices()\n\tif err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\n\tservices := make([]Service, len(stateServices))\n\tfor i := range stateServices {\n\t\tservices[i] = stateServices[i]\n\t}\n\n\treturn services, nil\n}\n\n\n\ntype Service interface {\n\tWatch() state.NotifyWatcher\n}\n\n\n\n\n\ntype Model interface {\n\n\tOwner() names.UserTag\n\n\tLife() state.Life\n\n\tName() string\n\n\tUUID() string\n\n\tDestroy() error\n}\n\nfunc (s *stateShim) Model() (Model, error) ", "output": "{\n\treturn s.State.Model()\n}"}
{"input": "package iso20022\n\n\ntype AcceptorCancellationResponse4 struct {\n\n\tEnvironment *CardPaymentEnvironment33 `xml:\"Envt\"`\n\n\tTransaction *CardPaymentTransaction42 `xml:\"Tx\"`\n\n\tTransactionResponse *CardPaymentTransaction43 `xml:\"TxRspn\"`\n}\n\n\n\nfunc (a *AcceptorCancellationResponse4) AddTransaction() *CardPaymentTransaction42 {\n\ta.Transaction = new(CardPaymentTransaction42)\n\treturn a.Transaction\n}\n\nfunc (a *AcceptorCancellationResponse4) AddTransactionResponse() *CardPaymentTransaction43 {\n\ta.TransactionResponse = new(CardPaymentTransaction43)\n\treturn a.TransactionResponse\n}\n\nfunc (a *AcceptorCancellationResponse4) AddEnvironment() *CardPaymentEnvironment33 ", "output": "{\n\ta.Environment = new(CardPaymentEnvironment33)\n\treturn a.Environment\n}"}
{"input": "package types\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc HstoreScanner(typ reflect.Type) ScannerFunc {\n\tif typ.Key() == stringType && typ.Elem() == stringType {\n\t\treturn scanMapStringStringValue\n\t}\n\treturn func(v reflect.Value, rd Reader, n int) error {\n\t\treturn fmt.Errorf(\"pg.Hstore(unsupported %s)\", v.Type())\n\t}\n}\n\nfunc scanMapStringStringValue(v reflect.Value, rd Reader, n int) error {\n\tm, err := scanMapStringString(rd, n)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tv.Set(reflect.ValueOf(m))\n\treturn nil\n}\n\n\n\nfunc scanMapStringString(rd Reader, n int) (map[string]string, error) ", "output": "{\n\tif n == -1 {\n\t\treturn nil, nil\n\t}\n\n\tp := newHstoreParser(rd)\n\tm := make(map[string]string)\n\tfor {\n\t\tkey, err := p.NextKey()\n\t\tif err != nil {\n\t\t\tif err == errEndOfHstore {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvalue, err := p.NextValue()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tm[string(key)] = string(value)\n\t}\n\treturn m, nil\n}"}
{"input": "package out\n\nimport \"math\"\n\n\ntype Point struct {\n\tVid  int                  \n\tIpId int                  \n\tX    []float64            \n\tDist float64              \n\tVals map[string][]float64 \n}\n\n\ntype Points []*Point\n\n\nfunc (o Points) Len() int {\n\treturn len(o)\n}\n\n\nfunc (o Points) Swap(i, j int) {\n\to[i], o[j] = o[j], o[i]\n}\n\n\nfunc (o Points) Less(i, j int) bool {\n\treturn o[i].Dist < o[j].Dist\n}\n\n\n\nfunc get_ip_point(ipid int, A []float64) *Point {\n\tip := Ipoints[ipid]\n\tif ip != nil {\n\t\tvar dist float64\n\t\tif A != nil {\n\t\t\tdist = dist_point_point(ip.X, A)\n\t\t}\n\t\treturn &Point{-1, ipid, ip.X, dist, make(map[string][]float64)}\n\t}\n\treturn nil\n}\n\n\nfunc dist_point_point(a, b []float64) float64 {\n\tif len(a) == 2 {\n\t\treturn math.Sqrt((a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]))\n\t}\n\treturn math.Sqrt((a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]))\n}\n\nfunc get_nod_point(vid int, A []float64) *Point ", "output": "{\n\tnod := Dom.Vid2node[vid]\n\tif nod != nil {\n\t\tvar dist float64\n\t\tif A != nil {\n\t\t\tdist = dist_point_point(nod.Vert.C, A)\n\t\t}\n\t\treturn &Point{vid, -1, nod.Vert.C, dist, make(map[string][]float64)}\n\t}\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\n\t\"github.com/sergystepanov/bee1/Godeps/_workspace/src/github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\tConfigRuntime()\n\tStartWorkers()\n\tStartGin()\n}\n\nfunc ConfigRuntime() {\n\tnuCPU := runtime.NumCPU()\n\truntime.GOMAXPROCS(nuCPU)\n\tfmt.Printf(\"Running with %d CPUs\\n\", nuCPU)\n}\n\n\n\nfunc StartGin() {\n\tgin.SetMode(gin.ReleaseMode)\n\n\trouter := gin.New()\n\trouter.Use(rateLimit, gin.Recovery())\n\trouter.LoadHTMLGlob(\"resources/*.templ.html\")\n\trouter.Static(\"/static\", \"resources/static\")\n\trouter.GET(\"/\", index)\n\trouter.GET(\"/room/:roomid\", roomGET)\n\trouter.POST(\"/room-post/:roomid\", roomPOST)\n\trouter.GET(\"/stream/:roomid\", streamRoom)\n\n\trouter.Run(\":80\")\n}\n\nfunc StartWorkers() ", "output": "{\n\tgo statsWorker()\n}"}
{"input": "package commands\n\nimport (\n\n\n\n\t\"github.com/spf13/cobra\"\n\n\t\"github.com/hofstadter-io/geb/commands/view\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar ViewLong = `View information known to the geb tool.`\n\nvar ViewCmd = &cobra.Command{\n\n\tUse: \"view\",\n\n\tAliases: []string{\n\t\t\"v\",\n\t},\n\n\tShort: \"View information known to the geb tool.\",\n\n\tLong: ViewLong,\n}\n\n\n\nfunc init() {\n\n\tViewCmd.AddCommand(view.SystemCmd)\n\tViewCmd.AddCommand(view.DslCmd)\n\tViewCmd.AddCommand(view.GenCmd)\n\tViewCmd.AddCommand(view.ProjectCmd)\n\tViewCmd.AddCommand(view.DesignCmd)\n\tViewCmd.AddCommand(view.PlansCmd)\n}\n\nfunc init() ", "output": "{\n\tRootCmd.AddCommand(ViewCmd)\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\ntype NetMap struct {\n\tProtocol string\n\tFrom     string\n\tTo       string\n\tListen   string\n\tLogFile  string\n}\n\ntype SvrConfig struct {\n\tconfigfile string\n\tProtocol   string\n\tListen     string\n\tLogFile    string\n\tNetMapList []NetMap\n}\n\n\n\nfunc (self *SvrConfig) LoadConfig() error {\n\tfile, err := os.Open(self.configfile)\n\tif err != nil {\n\t\tlog.Printf(err.Error())\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tdec := json.NewDecoder(file)\n\terr = dec.Decode(&self)\n\tif err != nil {\n\t\tlog.Printf(err.Error())\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (self *SvrConfig) DumpConfig() {\n\tfmt.Printf(\"%v\", self)\n}\n\nfunc NewSvrConfig(configfile string) *SvrConfig ", "output": "{\n\treturn &SvrConfig{\n\t\tconfigfile: configfile,\n\t}\n}"}
{"input": "package domain_ban\n\nimport (\n\t\"github.com/jmoiron/sqlx\"\n\t\"github.com/sgt-kabukiman/kabukibot/bot\"\n)\n\ntype pluginStruct struct {\n\tdb *sqlx.DB\n}\n\nfunc NewPlugin() *pluginStruct {\n\treturn &pluginStruct{}\n}\n\nfunc (self *pluginStruct) Name() string {\n\treturn \"domain_ban\"\n}\n\n\n\nfunc (self *pluginStruct) CreateWorker(channel bot.Channel) bot.PluginWorker {\n\treturn &worker{\n\t\tchannel: channel.Name(),\n\t\tacl:     channel.ACL(),\n\t\tdb:      self.db,\n\t}\n}\n\nfunc (self *pluginStruct) Setup(bot *bot.Kabukibot) ", "output": "{\n\tself.db = bot.Database()\n}"}
{"input": "package docker_app_runner\n\nimport \"fmt\"\n\ntype appNotStartedError string\n\nfunc newAppNotStartedError(appName string) appNotStartedError {\n\treturn appNotStartedError(appName)\n}\n\n\n\nfunc (appName appNotStartedError) Error() string ", "output": "{\n\treturn fmt.Sprintf(\"%s is not started.\", string(appName))\n}"}
{"input": "package kubectl\n\nimport \"os/exec\"\n\ntype Kubectl struct {\n\tbin  string\n\targs []string\n}\n\nfunc NewKubectl(bin string, args []string) (kubectl *Kubectl, err error) {\n\tif bin == \"default\" {\n\t\tbin, err = WhereIs()\n\t}\n\tkubectl = &Kubectl{bin: bin, args: args}\n\treturn\n}\n\n\n\nfunc (k *Kubectl) Exec() (string, error) {\n\tcommand := exec.Command(k.bin, k.args...)\n\tcommandOutput, err := command.Output()\n\treturn string(commandOutput), err\n}\n\nfunc WhereIs() (kubectlBinPath string, err error) ", "output": "{\n\tkubectlBinPath, err = exec.LookPath(\"kubectl\")\n\treturn\n}"}
{"input": "package metadata\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\n\n\n\nfunc GetInstanceMetadata() (instanceID, instanceType, availabilityZone, vpcID string, err error) {\n\tinstanceID, err = getMetadata(\"instance-id\")\n\tif err != nil {\n\t\treturn\n\t}\n\n\tinstanceType, err = getMetadata(\"instance-type\")\n\tif err != nil {\n\t\treturn\n\t}\n\n\teth0MAC, err := getMetadata(\"mac\")\n\tif err != nil {\n\t\treturn\n\t}\n\n\tvpcIDPath := fmt.Sprintf(\"network/interfaces/macs/%s/vpc-id\", eth0MAC)\n\tvpcID, err = getMetadata(vpcIDPath)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tavailabilityZone, err = getMetadata(\"placement/availability-zone\")\n\treturn\n}\n\nfunc getMetadata(name string) (string, error) ", "output": "{\n\tresp, err := http.Get(\"http:169.254.169.254/latest/meta-data/\" + name)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"unable to retrieve instance-id from metadata server: %s\", err)\n\t}\n\n\tdefer resp.Body.Close()\n\tinstanceID, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"unable to read response body: %s\", err)\n\t}\n\n\treturn string(instanceID), nil\n}"}
{"input": "package header\n\nimport (\n\t\"sip/core\"\n\t\"strings\"\n)\n\n\ntype Extension struct {\n\tSIPHeader\n\n\tvalue string\n}\n\nfunc NewExtension(headerName string) *Extension {\n\tthis := &Extension{}\n\n\tthis.SIPHeader.super(headerName)\n\n\treturn this\n}\n\nfunc (this *Extension) super(headerName string) {\n\tthis.SIPHeader.super(headerName)\n}\n\n\n\nfunc (this *Extension) SetName(headerName string) {\n\tthis.headerName = headerName\n}\n\n\nfunc (this *Extension) SetValue(value string) {\n\tthis.value = value\n}\n\nfunc (this *Extension) GetValue() string {\n\treturn this.GetHeaderValue()\n}\n\n\nfunc (this *Extension) GetHeaderValue() string {\n\tif this.value != \"\" {\n\t\treturn this.value\n\t} else {\n\t\tvar encodedHdr string\n\t\tencodedHdr = this.String()\n\t\tbuffer := []byte(encodedHdr)\n\t\tfor len(buffer) > 0 && buffer[0] != ':' {\n\t\t\tbuffer = buffer[1:]\n\t\t}\n\t\tbuffer = buffer[1:]\n\t\tthis.value = strings.TrimSpace(string(buffer))\n\t\treturn this.value\n\t}\n}\n\n\nfunc (this *Extension) String() string {\n\treturn this.headerName + core.SIPSeparatorNames_COLON +\n\t\tcore.SIPSeparatorNames_SP + this.value +\n\t\tcore.SIPSeparatorNames_NEWLINE\n}\n\n\n\n\nfunc (this *Extension) EncodeBody() string ", "output": "{\n\treturn this.GetHeaderValue()\n}"}
{"input": "package billing\n\nimport original \"github.com/Azure/azure-sdk-for-go/services/billing/mgmt/2017-04-24-preview/billing\"\n\nconst (\n\tDefaultBaseURI = original.DefaultBaseURI\n)\n\ntype ManagementClient = original.ManagementClient\ntype InvoicesClient = original.InvoicesClient\ntype DownloadURL = original.DownloadURL\ntype ErrorDetails = original.ErrorDetails\ntype ErrorResponse = original.ErrorResponse\ntype Invoice = original.Invoice\ntype InvoiceProperties = original.InvoiceProperties\ntype InvoicesListResult = original.InvoicesListResult\ntype Operation = original.Operation\ntype OperationDisplay = original.OperationDisplay\ntype OperationListResult = original.OperationListResult\ntype Period = original.Period\ntype PeriodProperties = original.PeriodProperties\ntype PeriodsListResult = original.PeriodsListResult\ntype Resource = original.Resource\ntype OperationsClient = original.OperationsClient\ntype PeriodsClient = original.PeriodsClient\n\nfunc NewOperationsClient(subscriptionID string) OperationsClient {\n\treturn original.NewOperationsClient(subscriptionID)\n}\n\nfunc NewPeriodsClient(subscriptionID string) PeriodsClient {\n\treturn original.NewPeriodsClient(subscriptionID)\n}\nfunc NewPeriodsClientWithBaseURI(baseURI string, subscriptionID string) PeriodsClient {\n\treturn original.NewPeriodsClientWithBaseURI(baseURI, subscriptionID)\n}\nfunc UserAgent() string {\n\treturn original.UserAgent() + \" profiles/preview\"\n}\nfunc Version() string {\n\treturn original.Version()\n}\nfunc New(subscriptionID string) ManagementClient {\n\treturn original.New(subscriptionID)\n}\nfunc NewWithBaseURI(baseURI string, subscriptionID string) ManagementClient {\n\treturn original.NewWithBaseURI(baseURI, subscriptionID)\n}\nfunc NewInvoicesClient(subscriptionID string) InvoicesClient {\n\treturn original.NewInvoicesClient(subscriptionID)\n}\nfunc NewInvoicesClientWithBaseURI(baseURI string, subscriptionID string) InvoicesClient {\n\treturn original.NewInvoicesClientWithBaseURI(baseURI, subscriptionID)\n}\n\nfunc NewOperationsClientWithBaseURI(baseURI string, subscriptionID string) OperationsClient ", "output": "{\n\treturn original.NewOperationsClientWithBaseURI(baseURI, subscriptionID)\n}"}
{"input": "package core\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype PlatformConfig interface {\n}\n\ntype platformconfig struct {\n\tJsonData []byte\n\tType     string `json:\"type\"`\n}\n\n\n\n\n\nfunc (m *platformconfig) UnmarshalPolymorphicJSON(data []byte) (interface{}, error) {\n\n\tif data == nil || string(data) == \"null\" {\n\t\treturn nil, nil\n\t}\n\n\tvar err error\n\tswitch m.Type {\n\tcase \"AMD_MILAN_BM\":\n\t\tmm := AmdMilanBmPlatformConfig{}\n\t\terr = json.Unmarshal(data, &mm)\n\t\treturn mm, err\n\tdefault:\n\t\treturn *m, nil\n\t}\n}\n\nfunc (m platformconfig) String() string {\n\treturn common.PointerString(m)\n}\n\n\ntype PlatformConfigTypeEnum string\n\n\nconst (\n\tPlatformConfigTypeAmdMilanBm PlatformConfigTypeEnum = \"AMD_MILAN_BM\"\n)\n\nvar mappingPlatformConfigType = map[string]PlatformConfigTypeEnum{\n\t\"AMD_MILAN_BM\": PlatformConfigTypeAmdMilanBm,\n}\n\n\nfunc GetPlatformConfigTypeEnumValues() []PlatformConfigTypeEnum {\n\tvalues := make([]PlatformConfigTypeEnum, 0)\n\tfor _, v := range mappingPlatformConfigType {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}\n\nfunc (m *platformconfig) UnmarshalJSON(data []byte) error ", "output": "{\n\tm.JsonData = data\n\ttype Unmarshalerplatformconfig platformconfig\n\ts := struct {\n\t\tModel Unmarshalerplatformconfig\n\t}{}\n\terr := json.Unmarshal(data, &s.Model)\n\tif err != nil {\n\t\treturn err\n\t}\n\tm.Type = s.Model.Type\n\n\treturn err\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype CopyVolumeGroupBackupRequest struct {\n\n\tVolumeGroupBackupId *string `mandatory:\"true\" contributesTo:\"path\" name:\"volumeGroupBackupId\"`\n\n\tCopyVolumeGroupBackupDetails `contributesTo:\"body\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request CopyVolumeGroupBackupRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request CopyVolumeGroupBackupRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request CopyVolumeGroupBackupRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request CopyVolumeGroupBackupRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype CopyVolumeGroupBackupResponse struct {\n\n\tRawResponse *http.Response\n\n\tVolumeGroupBackup `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response CopyVolumeGroupBackupResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\n\n\nfunc (response CopyVolumeGroupBackupResponse) HTTPResponse() *http.Response ", "output": "{\n\treturn response.RawResponse\n}"}
{"input": "package restic\n\nimport \"syscall\"\n\nfunc (node Node) restoreSymlinkTimestamps(path string, utimes [2]syscall.Timespec) error {\n\treturn nil\n}\n\n\nfunc (s statT) mtim() syscall.Timespec { return s.Mtim }\nfunc (s statT) ctim() syscall.Timespec { return s.Ctim }\n\nfunc (s statT) atim() syscall.Timespec ", "output": "{ return s.Atim }"}
{"input": "package astar\n\nimport (\n\t\"os\"\n\t\"image\"\n)\n\nimport _ \"image/png\"\n\nfunc openImage(filename string) (image.Image) {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tdefer f.Close()\n\timg, _, _ := image.Decode(f)\n\treturn img\n}\n\nfunc parseImage(img image.Image) MapData {\n\tmax := uint32(65536-1) \n\n\tbounds := img.Bounds()\n\tmap_data := NewMapData(bounds.Max.X, bounds.Max.Y)\n\tfor y := bounds.Min.Y; y < bounds.Max.Y; y++ {\n\t\tfor x := bounds.Min.X; x < bounds.Max.X; x++ {\n\t\t\tr, g, b, a := img.At(x, y).RGBA()\n\n\t\t\tif(r == max && g == max && b == max && a == max) {\n\t\t\t\tmap_data[x][bounds.Max.Y-1-y] = LAND\n\t\t\t} else {\n\t\t\t\tmap_data[x][bounds.Max.Y-1-y] = WALL\n\t\t\t}\n\t\t}\n\t}\n\treturn map_data\n}\n\n\n\nfunc GetMapFromImage(filename string) MapData ", "output": "{\n\timg := openImage(filename)\n\tif(img == nil) {\n\t\treturn nil\n\t}\n\treturn parseImage(img)\n}"}
{"input": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/smtp\"\n)\n\ntype nullAuth struct{}\n\nfunc NullAuth() *nullAuth {\n\treturn &nullAuth{}\n}\n\nfunc (n *nullAuth) Start(start *smtp.ServerInfo) (proto string, toServer []byte, err error) {\n\treturn\n}\n\n\n\n\ntype loginAuth struct {\n\tusername []byte\n\tpassword []byte\n\thost     string\n}\n\nfunc LoginAuth(username string, password string, host string) *loginAuth {\n\treturn &loginAuth{[]byte(username), []byte(password), host}\n}\n\nfunc (a *loginAuth) Start(server *smtp.ServerInfo) (proto string, toServer []byte, err error) {\n\tif !server.TLS {\n\t\tadvertised := false\n\t\tfor _, mechanism := range server.Auth {\n\t\t\tif mechanism == \"LOGIN\" {\n\t\t\t\tadvertised = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !advertised {\n\t\t\treturn \"\", nil, errors.New(\"unencrypted connection\")\n\t\t}\n\t}\n\tif server.Name != a.host {\n\t\treturn \"\", nil, errors.New(\"wrong host name\")\n\t}\n\treturn \"LOGIN\", nil, nil\n}\n\n\nfunc (a *loginAuth) Next(fromServer []byte, more bool) (toServer []byte, err error) {\n\tif !more {\n\t\treturn nil, nil\n\t}\n\tif string(fromServer) == \"Username:\" {\n\t\treturn []byte(a.username), nil\n\t}\n\tif string(fromServer) == \"Password:\" {\n\t\treturn []byte(a.password), nil\n\t}\n\treturn nil, errors.New(fmt.Sprintf(\"unrecognized prompt: '%s'\", fromServer))\n}\n\nfunc (n *nullAuth) Next(fromServer []byte, more bool) (toServer []byte, err error) ", "output": "{\n\treturn\n}"}
{"input": "package systemd\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/google/cadvisor/container\"\n\t\"github.com/google/cadvisor/fs\"\n\tinfo \"github.com/google/cadvisor/info/v1\"\n\t\"github.com/google/cadvisor/watcher\"\n\n\t\"k8s.io/klog/v2\"\n)\n\ntype systemdFactory struct{}\n\nfunc (f *systemdFactory) String() string {\n\treturn \"systemd\"\n}\n\nfunc (f *systemdFactory) NewContainerHandler(name string, inHostNamespace bool) (container.ContainerHandler, error) {\n\treturn nil, fmt.Errorf(\"Not yet supported\")\n}\n\nfunc (f *systemdFactory) CanHandleAndAccept(name string) (bool, bool, error) {\n\tif strings.HasSuffix(name, \".mount\") {\n\t\treturn true, false, nil\n\t}\n\tklog.V(5).Infof(\"%s not handled by systemd handler\", name)\n\treturn false, false, nil\n}\n\nfunc (f *systemdFactory) DebugInfo() map[string][]string {\n\treturn map[string][]string{}\n}\n\n\n\n\nfunc Register(machineInfoFactory info.MachineInfoFactory, fsInfo fs.FsInfo, includedMetrics container.MetricSet) error ", "output": "{\n\tklog.V(1).Infof(\"Registering systemd factory\")\n\tfactory := &systemdFactory{}\n\tcontainer.RegisterContainerHandlerFactory(factory, []watcher.ContainerWatchSource{watcher.Raw})\n\treturn nil\n}"}
{"input": "package neat\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"runtime\"\n)\n\n\n\nfunc bsInt32(val int32) []byte {\n\ttbs := make([]byte, 4)\n\tbs := make([]byte, 4)\n\tn := binary.PutVarint(tbs, int64(val))\n\tfmt.Println(tbs)\n\tfor i := 0; i < n; i++ {\n\t\tbs[(4-n)+i] = tbs[i]\n\t}\n\tfmt.Println(byte(250))\n\tfmt.Println(bs)\n\treturn bs\n}\n\nfunc getFuncName(i interface{}) string ", "output": "{\n\treturn runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSECSTaskDefinition_DockerVolumeConfiguration struct {\n\n\tAutoprovision bool `json:\"Autoprovision,omitempty\"`\n\n\tDriver string `json:\"Driver,omitempty\"`\n\n\tDriverOpts map[string]string `json:\"DriverOpts,omitempty\"`\n\n\tLabels map[string]string `json:\"Labels,omitempty\"`\n\n\tScope string `json:\"Scope,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\n\n\n\n\nfunc (r *AWSECSTaskDefinition_DockerVolumeConfiguration) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSECSTaskDefinition_DockerVolumeConfiguration) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSECSTaskDefinition_DockerVolumeConfiguration) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSECSTaskDefinition_DockerVolumeConfiguration) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSECSTaskDefinition_DockerVolumeConfiguration) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSECSTaskDefinition_DockerVolumeConfiguration) AWSCloudFormationType() string ", "output": "{\n\treturn \"AWS::ECS::TaskDefinition.DockerVolumeConfiguration\"\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/sheenobu/go-gamekit\"\n\t\"golang.org/x/net/context\"\n)\n\ntype closeButton struct {\n\tX int32\n\tY int32\n\tW int32\n\tH int32\n\n\tClose func()\n}\n\n\n\nfunc (cb *closeButton) Run(ctx context.Context, m *gamekit.Mouse) ", "output": "{\n\tposS := m.Position.Subscribe()\n\tclickS := m.LeftButtonState.Subscribe()\n\tdefer posS.Close()\n\tdefer clickS.Close()\n\n\thovering := false\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase pos := <-posS.C:\n\t\t\tx := pos.L\n\t\t\ty := pos.R\n\t\t\thovering = x > cb.X && y > cb.Y && x < cb.X+cb.W && y < cb.Y+cb.H\n\t\tcase leftClick := <-clickS.C:\n\t\t\tif hovering && leftClick {\n\t\t\t\tcb.Close()\n\t\t\t}\n\t\t}\n\t}\n}"}
{"input": "package version\n\nimport (\n\t\"fmt\"\n\n\tversion \"github.com/hashicorp/go-version\"\n)\n\n\nvar Version = \"0.12.20\"\n\n\n\n\nvar Prerelease = \"\"\n\n\n\n\nvar SemVer *version.Version\n\n\n\n\n\nconst Header = \"Terraform-Version\"\n\n\nfunc String() string {\n\tif Prerelease != \"\" {\n\t\treturn fmt.Sprintf(\"%s-%s\", Version, Prerelease)\n\t}\n\treturn Version\n}\n\nfunc init() ", "output": "{\n\tSemVer = version.Must(version.NewVersion(Version))\n}"}
{"input": "package ri\n\n\nfunc (r *Ri) Sphere(radius, zmin, zmax, thetamax RtFloat, parameterlist ...Rter) error {\n\n\tvar out = []Rter{radius, zmin, zmax, thetamax, PARAMETERLIST}\n\tout = append(out, parameterlist...)\n\n\treturn r.writef(\"Sphere\", out...)\n}\n\n\nfunc (r *Ri) Cone(height, radius, thetamax RtFloat, parameterlist ...Rter) error {\n\n\tvar out = []Rter{height, radius, thetamax, PARAMETERLIST}\n\tout = append(out, parameterlist...)\n\n\treturn r.writef(\"Cone\", out...)\n}\n\n\nfunc (r *Ri) Cylinder(radius, zmin, zmax, thetamax RtFloat, parameterlist ...Rter) error {\n\n\tvar out = []Rter{radius, zmin, zmax, thetamax, PARAMETERLIST}\n\tout = append(out, parameterlist...)\n\n\treturn r.writef(\"Cylinder\", out...)\n}\n\n\nfunc (r *Ri) Hyperboloid(point1, point2 RtPoint, thetamax RtFloat, parameterlist ...Rter) error {\n\n\tvar out = []Rter{point1, point2, thetamax, PARAMETERLIST}\n\tout = append(out, parameterlist...)\n\n\treturn r.writef(\"Hyperboloid\", out...)\n}\n\n\n\n\n\nfunc (r *Ri) Torus(majorradius, minorradius, phimin, phimax, thetamax RtFloat, parameterlist ...Rter) error {\n\n\tvar out = []Rter{majorradius, minorradius, phimin, phimax, thetamax, PARAMETERLIST}\n\tout = append(out, parameterlist...)\n\n\treturn r.writef(\"Torus\", out...)\n}\n\nfunc (r *Ri) Disk(height, radius, thetamax RtFloat, parameterlist ...Rter) error ", "output": "{\n\n\tvar out = []Rter{height, radius, thetamax, PARAMETERLIST}\n\tout = append(out, parameterlist...)\n\n\treturn r.writef(\"Disk\", out...)\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/astaxie/beego/context\"\n\t\"github.com/yangji168/omsystem/hauth/hcache\"\n\t\"github.com/yangji168/omsystem/utils/hret\"\n)\n\nfunc IndexPage(ctx *context.Context) {\n\trst, err := hcache.GetStaticFile(\"AsofdateIndexPage\")\n\tif err != nil {\n\t\thret.WriteHttpErrMsgs(ctx.ResponseWriter, 404, \"页面不存在\")\n\t\treturn\n\t}\n\tctx.ResponseWriter.Write(rst)\n}\n\n\n\nfunc init() ", "output": "{\n\thcache.Register(\"AsofdateIndexPage\", \"./views/login.tpl\")\n}"}
{"input": "package codec\n\nimport (\n\t\"github.com/tehmaze/vc\"\n\tyaml \"gopkg.in/yaml.v2\"\n)\n\ntype yamlCodec struct {\n}\n\n\n\nfunc (c yamlCodec) Unmarshal(p []byte) (map[string]interface{}, error) {\n\tvar data map[string]interface{}\n\tif err := yaml.Unmarshal(p, &data); err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n\nfunc init() {\n\tvc.RegisterCodec(\"yaml\", new(yamlCodec))\n}\n\nfunc (c yamlCodec) Marshal(_ string, data map[string]interface{}) ([]byte, error) ", "output": "{\n\treturn yaml.Marshal(data)\n}"}
{"input": "package api\n\nfunc (c *Sys) SealStatus() (*SealStatusResponse, error) {\n\tr := c.c.NewRequest(\"GET\", \"/v1/sys/seal-status\")\n\treturn sealStatusRequest(c, r)\n}\n\nfunc (c *Sys) Seal() error {\n\tr := c.c.NewRequest(\"PUT\", \"/v1/sys/seal\")\n\tresp, err := c.c.RawRequest(r)\n\tif err == nil {\n\t\tdefer resp.Body.Close()\n\t}\n\treturn err\n}\n\nfunc (c *Sys) ResetUnsealProcess() (*SealStatusResponse, error) {\n\tbody := map[string]interface{}{\"reset\": true}\n\n\tr := c.c.NewRequest(\"PUT\", \"/v1/sys/unseal\")\n\tif err := r.SetJSONBody(body); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn sealStatusRequest(c, r)\n}\n\nfunc (c *Sys) Unseal(shard string) (*SealStatusResponse, error) {\n\tbody := map[string]interface{}{\"key\": shard}\n\n\tr := c.c.NewRequest(\"PUT\", \"/v1/sys/unseal\")\n\tif err := r.SetJSONBody(body); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn sealStatusRequest(c, r)\n}\n\n\n\ntype SealStatusResponse struct {\n\tType         string `json:\"type\"`\n\tSealed       bool   `json:\"sealed\"`\n\tT            int    `json:\"t\"`\n\tN            int    `json:\"n\"`\n\tProgress     int    `json:\"progress\"`\n\tNonce        string `json:\"nonce\"`\n\tVersion      string `json:\"version\"`\n\tClusterName  string `json:\"cluster_name,omitempty\"`\n\tClusterID    string `json:\"cluster_id,omitempty\"`\n\tRecoverySeal bool   `json:\"recovery_seal\"`\n}\n\nfunc sealStatusRequest(c *Sys, r *Request) (*SealStatusResponse, error) ", "output": "{\n\tresp, err := c.c.RawRequest(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar result SealStatusResponse\n\terr = resp.DecodeJSON(&result)\n\treturn &result, err\n}"}
{"input": "package cpumanager\n\nimport (\n\t\"k8s.io/api/core/v1\"\n\t\"k8s.io/klog\"\n\t\"k8s.io/kubernetes/pkg/kubelet/cm/cpumanager/state\"\n\t\"k8s.io/kubernetes/pkg/kubelet/cm/topologymanager\"\n)\n\ntype nonePolicy struct{}\n\nvar _ Policy = &nonePolicy{}\n\n\nconst PolicyNone policyName = \"none\"\n\n\nfunc NewNonePolicy() Policy {\n\treturn &nonePolicy{}\n}\n\nfunc (p *nonePolicy) Name() string {\n\treturn string(PolicyNone)\n}\n\nfunc (p *nonePolicy) Start(s state.State) {\n\tklog.Info(\"[cpumanager] none policy: Start\")\n}\n\nfunc (p *nonePolicy) AddContainer(s state.State, pod *v1.Pod, container *v1.Container) error {\n\treturn nil\n}\n\nfunc (p *nonePolicy) RemoveContainer(s state.State, podUID string, containerName string) error {\n\treturn nil\n}\n\n\n\nfunc (p *nonePolicy) GetTopologyHints(s state.State, pod v1.Pod, container v1.Container) map[string][]topologymanager.TopologyHint ", "output": "{\n\treturn nil\n}"}
{"input": "package plusTesting\n\nimport \"os\"\n\n\n\n\n\n\n\n\n\nfunc ChangeEnv(key, value string) func() ", "output": "{\n\told := os.Getenv(key)\n\tos.Setenv(key, value)\n\n\treturn func() {\n\t\tos.Setenv(key, old)\n\t}\n}"}
{"input": "package security\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/goincremental/web\"\n\t\"github.com/goincremental/web/security/models\"\n)\n\ntype securityContextKey int\n\nconst userKey securityContextKey = 0\n\nfunc SetUser(r *http.Request, val *models.User) {\n\tweb.SetContext(r, userKey, val)\n}\n\n\n\nfunc GetUser(r *http.Request) *models.User ", "output": "{\n\tif u := web.GetContext(r, userKey); u != nil {\n\t\tuser := u.(*models.User)\n\t\treturn user\n\t}\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype NumberType int\n\nvar (\n\tnonabundantLimit = 28123\n)\n\nconst (\n\tPerfect NumberType = iota\n\tAbundant\n\tDeficient\n\tUnknown\n)\n\n\n\n\n\nfunc Sum(numbers *[]int) int {\n\tsum := 0\n\tfor _, val := range *numbers {\n\t\tsum += val\n\t}\n\treturn sum\n}\n\n\nfunc Classify(number int) NumberType {\n\tsum := Sum(ProperDivisors(number))\n\tswitch {\n\tcase sum == number:\n\t\treturn Perfect\n\tcase sum > number:\n\t\treturn Abundant\n\tcase sum < number:\n\t\treturn Deficient\n\tdefault:\n\t\treturn Unknown\n\t}\n}\n\nfunc main() {\n\tabundantNumbers := []int{}\n\tfor i := 12; i <= nonabundantLimit; i++ {\n\t\tif Classify(i) == Abundant {\n\t\t\tabundantNumbers = append(abundantNumbers, i)\n\t\t}\n\t}\n\n\tabundantSumMap := map[int]bool{}\n\tfor _, a := range abundantNumbers {\n\t\tfor _, b := range abundantNumbers {\n\t\t\tsum := a + b\n\t\t\tif sum > nonabundantLimit {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tabundantSumMap[sum] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tsolution := []int{}\n\tfor i := 1; i <= nonabundantLimit; i++ {\n\t\t_, exists := abundantSumMap[i]\n\t\tif !exists {\n\t\t\tsolution = append(solution, i)\n\t\t}\n\t}\n\n\tfmt.Println(Sum(&solution))\n}\n\nfunc ProperDivisors(number int) *[]int ", "output": "{\n\tdivisorMap := map[int]bool{}\n\tlim := number\n\tfor i := 1; i < lim; i++ {\n\t\tif math.Mod(float64(number), float64(i)) == 0 {\n\t\t\tdivisorMap[i] = true\n\t\t\tpair := number / i\n\t\t\tlim = pair\n\t\t\tdivisorMap[pair] = true\n\t\t}\n\t}\n\n\tdivisors := []int{}\n\tfor k, _ := range divisorMap {\n\t\tif k != number {\n\t\t\tdivisors = append(divisors, k)\n\t\t}\n\t}\n\n\treturn &divisors\n}"}
{"input": "package api\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/sirupsen/logrus\"\n)\n\nvar loggerInstances = make(map[string]*InstanceLogger)\n\n\nfunc NewInstanceLogger(name string, path string) (*InstanceLogger, error) {\n\tif _, ok := loggerInstances[name]; !ok {\n\t\terr := createInstanceLogger(name, path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn loggerInstances[name], nil\n}\n\n\nfunc CloseInstanceLoggers() {\n\tfor name, instanceLogger := range loggerInstances {\n\t\tinstanceLogger.Close()\n\t\tdelete(loggerInstances, name)\n\t}\n}\n\n\ntype InstanceLogger struct {\n\tName   string\n\tPath   string\n\tfile   *os.File\n\tlogger *logrus.Logger\n}\n\n\nfunc (i *InstanceLogger) GetLogger() *logrus.Logger {\n\treturn i.logger\n}\n\n\nfunc (i *InstanceLogger) GetFile() io.Writer {\n\treturn i.file\n}\n\n\nfunc (i *InstanceLogger) Close() {\n\ti.file.Close()\n}\n\n\n\nfunc createInstanceLogger(name string, path string) error ", "output": "{\n\n\tfilename := filepath.Join(path, \"instance.log\")\n\n\tlogrus.Debugf(\"Create log for %s at %s\", name, path)\n\n\tf, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog := logrus.New()\n\tlog.Formatter = &logrus.TextFormatter{}\n\tlog.Out = f\n\n\tli := &InstanceLogger{\n\t\tName:   name,\n\t\tPath:   filename,\n\t\tfile:   f,\n\t\tlogger: log,\n\t}\n\n\tloggerInstances[name] = li\n\n\treturn nil\n}"}
{"input": "package pathing\n\ntype Node struct {\n\tTile                Vector2i\n\tParent              *Node\n\tFCost, GCost, HCost float64\n}\n\ntype ByFCost []Node\n\nfunc NewNode(vec Vector2i, parent *Node, gCost float64, hCost float64) Node {\n\treturn Node{\n\t\tTile:   vec,\n\t\tParent: parent,\n\t\tGCost:  gCost,\n\t\tHCost:  hCost,\n\t\tFCost:  gCost + hCost,\n\t}\n}\n\nfunc (node *Node) CompareTo(node2 *Node) int {\n\tif node.FCost > node2.FCost {\n\t\treturn +1\n\t}\n\tif node.FCost < node2.FCost {\n\t\treturn -1\n\t}\n\treturn 0\n}\n\n\n\nfunc (a ByFCost) Swap(i, j int) {\n\ta[i], a[j] = a[j], a[i]\n}\nfunc (a ByFCost) Less(i, j int) bool {\n\treturn a[i].FCost < a[j].FCost\n}\n\nfunc (a ByFCost) Len() int ", "output": "{\n\treturn len(a)\n}"}
{"input": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\n\n\nfunc Test_ShellSort(t *testing.T) ", "output": "{\n\tfor i := 1000; i < 1006; i++ {\n\t\tck := getCkints(i)\n\t\tShellSort(ck)\n\t\tif !sort.IsSorted(ck) {\n\t\t\tt.Error(\"ShellSort Error\")\n\t\t}\n\t}\n}"}
{"input": "package utils\n\nimport (\n\t\"crypto/sha512\"\n\t\"fmt\"\n)\n\nconst (\n\tmaxChainLength = 28\n\tchainPrefix    = \"CNI-\"\n\tprefixLength   = len(chainPrefix)\n)\n\n\n\n\nfunc FormatChainName(name string, id string) string {\n\tchainBytes := sha512.Sum512([]byte(name + id))\n\tchain := fmt.Sprintf(\"%s%x\", chainPrefix, chainBytes)\n\treturn chain[:maxChainLength]\n}\n\n\n\n\n\nfunc FormatComment(name string, id string) string ", "output": "{\n\treturn fmt.Sprintf(\"name: %q id: %q\", name, id)\n}"}
{"input": "package metric\n\nimport (\n\t\"github.com/astaxie/beego\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestInstanceName(t *testing.T) {\n\tbeego.AppConfig.Set(\"rpcaddr\", \"a\")\n\tbeego.AppConfig.Set(\"rpcport\", \"b\")\n\ti := InstanceName()\n\tif i != \"a:b\" {\n\t\tt.Fatalf(\"TestInstanceName failed\")\n\t}\n\tbeego.AppConfig.Set(\"httpaddr\", \"c\")\n\tbeego.AppConfig.Set(\"httpaddr\", \"d\")\n\ti = InstanceName()\n\tif i != \"a:b\" {\n\t\tt.Fatalf(\"TestInstanceName failed\")\n\t}\n}\n\n\n\nfunc TestPeriod(t *testing.T) ", "output": "{\n\tif getPeriod() != 30*time.Second {\n\t\tt.Fatalf(\"TestPeriod failed\")\n\t}\n\tos.Setenv(\"METRICS_INTERVAL\", time.Millisecond.String())\n\tif getPeriod() != 30*time.Second {\n\t\tt.Fatalf(\"TestPeriod failed\")\n\t}\n\tos.Setenv(\"METRICS_INTERVAL\", \"err\")\n\tif getPeriod() != 30*time.Second {\n\t\tt.Fatalf(\"TestPeriod failed\")\n\t}\n\tos.Setenv(\"METRICS_INTERVAL\", time.Second.String())\n\tif getPeriod() != time.Second {\n\t\tt.Fatalf(\"TestPeriod failed\")\n\t}\n}"}
{"input": "package backingstore\n\nimport (\n\t\"github.com/gostor/gotgt/pkg/api\"\n\t\"github.com/gostor/gotgt/pkg/scsi\"\n)\n\nfunc init() {\n\tscsi.RegisterBackingStore(\"null\", newNull)\n}\n\ntype NullBackingStore struct {\n\tscsi.BaseBackingStore\n}\n\nfunc newNull() (api.BackingStore, error) {\n\treturn &NullBackingStore{\n\t\tBaseBackingStore: scsi.BaseBackingStore{\n\t\t\tName:            \"null\",\n\t\t\tDataSize:        0,\n\t\t\tOflagsSupported: 0,\n\t\t},\n\t}, nil\n}\n\nfunc (bs *NullBackingStore) Open(dev *api.SCSILu, path string) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Close(dev *api.SCSILu) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Init(dev *api.SCSILu, Opts string) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Exit(dev *api.SCSILu) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Size(dev *api.SCSILu) uint64 {\n\treturn 0\n}\n\nfunc (bs *NullBackingStore) Read(offset, tl int64) ([]byte, error) {\n\treturn nil, nil\n}\n\nfunc (bs *NullBackingStore) Write(wbuf []byte, offset int64) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) DataSync(offset, tl int64) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) DataAdvise(offset, length int64, advise uint32) error {\n\treturn nil\n}\n\n\n\nfunc (bs *NullBackingStore) Unmap([]api.UnmapBlockDescriptor) error ", "output": "{\n\treturn nil\n}"}
{"input": "package mail\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype tokenTest struct {\n\ts string\n\tt []string\n}\n\nvar tokenTests = []tokenTest{\n\ttokenTest{``, []string{}},\n\ttokenTest{`a`, []string{`a`}},\n\ttokenTest{`af&' al43`, []string{`af&'`, `al43`}},\n\ttokenTest{\n\t\t`\"Joe Q. Public\" <john.q.public@example.com>`,\n\t\t[]string{`\"Joe Q. Public\"`, `<`, `john.q.public`, `@`, `example.com`, `>`},\n\t},\n\ttokenTest{\n\t\t`\"Giant; \\\"Big\\\" Box\" <sysservices@example.net>`,\n\t\t[]string{\n\t\t\t`\"Giant; \\\"Big\\\" Box\"`,\n\t\t\t`<`,\n\t\t\t`sysservices`,\n\t\t\t`@`,\n\t\t\t`example.net`,\n\t\t\t`>`,\n\t\t},\n\t},\n}\n\n\n\nfunc TestTokenize(t *testing.T) ", "output": "{\n\tfor _, tt := range tokenTests {\n\t\to, e := tokenize([]byte(tt.s))\n\t\tif e != nil {\n\t\t\tt.Errorf(\"tokenize returned error for %#V\", tt.s)\n\t\t} else {\n\t\t\trt := []string{}\n\t\t\tfor _, tok := range o {\n\t\t\t\trt = append(rt, string(tok))\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(rt, tt.t) {\n\t\t\t\tt.Errorf(\"tokenize(%#V) gave %#V; expected %#V\", tt.s, rt, tt.t)\n\t\t\t}\n\t\t}\n\t}\n}"}
{"input": "package models\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/gobuffalo/pop\"\n\t\"github.com/gobuffalo/uuid\"\n\t\"github.com/gobuffalo/validate\"\n\t\"github.com/gobuffalo/validate/validators\"\n\t\"github.com/gobuffalo/pop/slices\"\n)\n\n\ntype State struct {\n\tID        uuid.UUID `json:\"id\" db:\"id\"`\n\tJSON      slices.Map    `json:\"json\" db:\"json\"`\n}\n\ntype StateBinding struct {\n\tStatus               *string `json:\"status\"`\n\tDownloadedReport     *bool `json:\"downloaded_report\"`\n}\n\n\nfunc (c State) String() string {\n\tjc, _ := json.Marshal(c)\n\treturn string(jc)\n}\n\n\ntype States []State\n\n\nfunc (c States) String() string {\n\tjc, _ := json.Marshal(c)\n\treturn string(jc)\n}\n\n\n\n\n\n\n\nfunc (c *State) ValidateCreate(tx *pop.Connection) (*validate.Errors, error) {\n\treturn validate.NewErrors(), nil\n}\n\n\n\nfunc (c *State) ValidateUpdate(tx *pop.Connection) (*validate.Errors, error) {\n\treturn validate.NewErrors(), nil\n}\n\nfunc (c *State) Validate(tx *pop.Connection) (*validate.Errors, error) ", "output": "{\n\treturn validate.Validate(\n\t\t&validators.UUIDIsPresent{Field: c.ID, Name: \"ID\"},\n\t), nil\n}"}
{"input": "package allthingstalk\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\tio \"github.com/gillesdemey/All-Things-Go/io\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar httpClient = &http.Client{}\nvar httpUri = \"http://beta.smartliving.io\"\n\n\n\n\nfunc (device *Device) RegisterAsset(ioDevice *io.IODevice) ", "output": "{\n\n\tjson, _ := json.Marshal(io.Registration{\n\t\tName:        ioDevice.Name,\n\t\tDescription: ioDevice.Description,\n\t\tType:        ioDevice.Type,\n\t\tProfile:     ioDevice.Profile,\n\t\tDeviceID:    device.DeviceID,\n\t})\n\n\treq, err := http.NewRequest(\n\t\t\"PUT\",\n\t\tbuildAssetUri(device, ioDevice),\n\t\tbytes.NewReader(json))\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Auth-ClientKey\", device.ClientKey)\n\treq.Header.Set(\"Auth-ClientID\", device.ClientID)\n\n\t_, err = httpClient.Do(req)\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Error registering asset: %s\\n\", err)\n\t}\n\n\tlog.Printf(\"Successfuly registered IODevice: %+s\\n\", ioDevice.Name)\n}"}
{"input": "package pump\n\nimport (\n\t\"time\"\n\n\t\"github.com/vail130/orinoco/sieve\"\n\t\"github.com/vail130/orinoco/timeutils\"\n)\n\nfunc forkStream(streams [](map[string]string), eventArray []sieve.Event) {\n\tfor i := 0; i < len(streams); i++ {\n\t\tswitch {\n\t\tcase streams[i][\"type\"] == \"stdout\":\n\t\t\tstream := StdoutStream{}\n\t\t\tgo stream.Process(eventArray)\n\t\tcase streams[i][\"type\"] == \"log\":\n\t\t\tstream := LogStream{\n\t\t\t\tstreams[i][\"path\"],\n\t\t\t}\n\t\t\tgo stream.Process(eventArray)\n\t\tcase streams[i][\"type\"] == \"http\":\n\t\t\tstream := HTTPStream{\n\t\t\t\tstreams[i][\"url\"],\n\t\t\t}\n\t\t\tgo stream.Process(eventArray)\n\t\tcase streams[i][\"type\"] == \"s3\":\n\t\t\tstream := S3Stream{\n\t\t\t\tstreams[i][\"region\"],\n\t\t\t\tstreams[i][\"bucket\"],\n\t\t\t\tstreams[i][\"prefix\"],\n\t\t\t}\n\t\t\tgo stream.Process(eventArray)\n\t\t}\n\t}\n}\n\n\n\nfunc Pump(minBatchSize int, maxBatchDelay int, streams [](map[string]string), eventChannel chan *sieve.Event) ", "output": "{\n\tvar start time.Time\n\tvar now time.Time\n\tfor {\n\t\tstart = timeutils.UtcNow()\n\t\teventArray := make([]sieve.Event, 0)\n\t\tfor event := range eventChannel {\n\t\t\teventArray = append(eventArray, *event)\n\t\t\tnow = timeutils.UtcNow()\n\t\t\tif now.Sub(start) >= time.Duration(maxBatchDelay) || len(eventChannel) >= minBatchSize {\n\t\t\t\tforkStream(streams, eventArray)\n\t\t\t\tstart = now\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}"}
{"input": "package frontend\n\nimport (\n\t\"context\"\n\n\t\"go.chromium.org/luci/common/errors\"\n\t\"go.chromium.org/luci/common/logging\"\n\t\"go.chromium.org/luci/milo/common\"\n)\n\n\n\n\n\nfunc UpdateConfigHandler(c context.Context) error ", "output": "{\n\tprojErr := common.UpdateProjects(c)\n\tif projErr != nil {\n\t\tif merr, ok := projErr.(errors.MultiError); ok {\n\t\t\tfor _, ierr := range merr {\n\t\t\t\tlogging.WithError(ierr).Errorf(c, \"project update handler encountered error\")\n\t\t\t}\n\t\t} else {\n\t\t\tlogging.WithError(projErr).Errorf(c, \"project update handler encountered error\")\n\t\t}\n\t}\n\t_, servErr := common.UpdateServiceConfig(c)\n\tif servErr != nil {\n\t\tlogging.WithError(servErr).Errorf(c, \"service update handler encountered error\")\n\t}\n\n\treturn errors.Flatten(errors.NewMultiError(projErr, servErr))\n}"}
{"input": "package v1beta1\n\nimport (\n\t\"hash/fnv\"\n\t\"strconv\"\n\n\t\"stash.appscode.dev/apimachinery/crds\"\n\n\thashutil \"k8s.io/kubernetes/pkg/util/hash\"\n\t\"kmodules.xyz/client-go/apiextensions\"\n\tmeta_util \"kmodules.xyz/client-go/meta\"\n)\n\n\n\nfunc (b BackupConfiguration) GetSpecHash() string {\n\thash := fnv.New64a()\n\thashutil.DeepHashObject(hash, b.Spec)\n\treturn strconv.FormatUint(hash.Sum64(), 10)\n}\n\n\n\nfunc (b BackupConfiguration) OffshootLabels() map[string]string {\n\toverrides := make(map[string]string)\n\toverrides[meta_util.ComponentLabelKey] = StashBackupComponent\n\toverrides[meta_util.ManagedByLabelKey] = StashKey\n\n\treturn upsertLabels(b.Labels, overrides)\n}\n\nfunc upsertLabels(originalLabels, overrides map[string]string) map[string]string {\n\tif originalLabels == nil {\n\t\toriginalLabels = make(map[string]string, len(overrides))\n\t}\n\tfor k, v := range overrides {\n\t\toriginalLabels[k] = v\n\t}\n\treturn originalLabels\n}\n\nfunc (_ BackupConfiguration) CustomResourceDefinition() *apiextensions.CustomResourceDefinition ", "output": "{\n\treturn crds.MustCustomResourceDefinition(SchemeGroupVersion.WithResource(ResourcePluralBackupConfiguration))\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nvar router *gin.Engine\n\nfunc main() {\n\tgin.SetMode(gin.ReleaseMode)\n\n\trouter = gin.Default()\n\n\trouter.LoadHTMLGlob(\"templates/*\")\n\n\tinitializeRoutes()\n\n\trouter.Run()\n}\n\n\n\n\n\n\nfunc render(c *gin.Context, data gin.H, templateName string) ", "output": "{\n\tloggedInInterface, _ := c.Get(\"is_logged_in\")\n\tdata[\"is_logged_in\"] = loggedInInterface.(bool)\n\n\tswitch c.Request.Header.Get(\"Accept\") {\n\tcase \"application/json\":\n\t\tc.JSON(http.StatusOK, data[\"payload\"])\n\tcase \"application/xml\":\n\t\tc.XML(http.StatusOK, data[\"payload\"])\n\tdefault:\n\t\tc.HTML(http.StatusOK, templateName, data)\n\t}\n}"}
{"input": "package identity\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype cacheData struct {\n\tIdentity Identity `json:\"identity\"`\n}\n\n\ntype IdentityCache struct {\n\tFile string\n}\n\n\nfunc NewIdentityCache(dir string, jsonFile string) IdentityCacheInterface {\n\treturn &IdentityCache{\n\t\tFile: filepath.Join(dir, jsonFile),\n\t}\n}\n\n\nfunc (ic *IdentityCache) GetIdentity() (identity Identity, err error) {\n\tif !ic.cacheExists() {\n\t\terr = errors.New(\"cache file does not exist\")\n\t\treturn\n\t}\n\n\tcache, err := ic.readCache()\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn cache.Identity, nil\n}\n\n\nfunc (ic *IdentityCache) StoreIdentity(identity Identity) error {\n\tcache := cacheData{\n\t\tIdentity: identity,\n\t}\n\n\treturn ic.writeCache(cache)\n}\n\nfunc (ic *IdentityCache) cacheExists() bool {\n\tif _, err := os.Stat(ic.File); os.IsNotExist(err) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (ic *IdentityCache) readCache() (cache *cacheData, err error) {\n\tdata, err := ioutil.ReadFile(ic.File)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = json.Unmarshal(data, &cache)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\n\n\nfunc (ic *IdentityCache) writeCache(cache cacheData) (err error) ", "output": "{\n\tcacheString, err := json.Marshal(cache)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = ioutil.WriteFile(ic.File, cacheString, 0644)\n\treturn\n}"}
{"input": "package gouv\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestTTY(t *testing.T) {\n\tdoTest(t, testTTY, 3)\n}\n\n\n\nfunc testTTY(t *testing.T, loop *UvLoop) ", "output": "{\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif e := recover(); e != nil {\n\t\t\t\tfmt.Println(e)\n\t\t\t}\n\t\t}()\n\n\t\ttty, err := UvTTYInit(loop, 1, 1, nil) \n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfmt.Println(tty.GetWinsize())\n\n\n\n\n\n\t}()\n}"}
{"input": "package archive\n\nimport \"io\"\n\n\n\n\n\nfunc NewCompressedZipWriter(dst io.Writer, level int) *Archive ", "output": "{\n\ta := &Archive{\n\t\tDirMaxSize:  -1,\n\t\tDirMaxFiles: -1,\n\t\tdst:         dst,\n\t}\n\ta.archive = newCompressedZipArchive(dst)\n\treturn a\n}"}
{"input": "package s3\n\nimport (\n\t\"net/http\"\n\n\t\"gopkg.in/amz.v3/aws\"\n)\n\nvar originalStrategy = attempts\n\nfunc BuildError(resp *http.Response) error {\n\treturn buildError(resp)\n}\n\n\n\nfunc AttemptStrategy() aws.AttemptStrategy {\n\treturn attempts\n}\n\nfunc SetListPartsMax(n int) {\n\tlistPartsMax = n\n}\n\nfunc SetListMultiMax(n int) {\n\tlistMultiMax = n\n}\n\nfunc SetAttemptStrategy(s *aws.AttemptStrategy) ", "output": "{\n\tif s == nil {\n\t\tattempts = originalStrategy\n\t} else {\n\t\tattempts = *s\n\t}\n}"}
{"input": "package pain\n\nimport (\n\t\"encoding/xml\"\n\n\t\"github.com/fgrid/iso20022\"\n)\n\ntype Document00100102 struct {\n\tXMLName xml.Name                             `xml:\"urn:iso:std:iso:20022:tech:xsd:pain.001.001.02 Document\"`\n\tMessage *CustomerCreditTransferInitiationV02 `xml:\"pain.001.001.02\"`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype CustomerCreditTransferInitiationV02 struct {\n\n\tGroupHeader *iso20022.GroupHeader1 `xml:\"GrpHdr\"`\n\n\tPaymentInformation []*iso20022.PaymentInstructionInformation1 `xml:\"PmtInf\"`\n}\n\nfunc (c *CustomerCreditTransferInitiationV02) AddGroupHeader() *iso20022.GroupHeader1 {\n\tc.GroupHeader = new(iso20022.GroupHeader1)\n\treturn c.GroupHeader\n}\n\nfunc (c *CustomerCreditTransferInitiationV02) AddPaymentInformation() *iso20022.PaymentInstructionInformation1 {\n\tnewValue := new(iso20022.PaymentInstructionInformation1)\n\tc.PaymentInformation = append(c.PaymentInformation, newValue)\n\treturn newValue\n}\n\nfunc (d *Document00100102) AddMessage() *CustomerCreditTransferInitiationV02 ", "output": "{\n\td.Message = new(CustomerCreditTransferInitiationV02)\n\treturn d.Message\n}"}
{"input": "package storagesync\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient {\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}\n\nfunc New(subscriptionID string) BaseClient ", "output": "{\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}"}
{"input": "package log\n\nimport \"gopkg.in/inconshreveable/log15.v2\"\n\nvar (\n\tLogger log15.Logger\n)\n\n\n\n\n\nfunc Interactive() {\n\tLogger.SetHandler(log15.MultiHandler(\n\t\tlog15.LvlFilterHandler(\n\t\t\tlog15.LvlError,\n\t\t\tlog15.StderrHandler)))\n}\n\n\nfunc Debug(msg string, ctx ...interface{}) { Logger.Debug(msg, ctx...) }\nfunc Info(msg string, ctx ...interface{})  { Logger.Info(msg, ctx...) }\nfunc Warn(msg string, ctx ...interface{})  { Logger.Warn(msg, ctx...) }\nfunc Error(msg string, ctx ...interface{}) { Logger.Error(msg, ctx...) }\nfunc Crit(msg string, ctx ...interface{})  { Logger.Crit(msg, ctx...) }\n\nfunc init() ", "output": "{\n\tLogger = log15.New()\n\tLogger.SetHandler(log15.DiscardHandler())\n}"}
{"input": "package vfs\n\nimport (\n\t\"path\"\n\n\tgofig \"github.com/akutz/gofig/types\"\n\n\t\"github.com/codedellemc/rexray/libstorage/api/context\"\n\t\"github.com/codedellemc/rexray/libstorage/api/registry\"\n\t\"github.com/codedellemc/rexray/libstorage/api/types\"\n)\n\nconst (\n\tName = \"vfs\"\n)\n\nfunc init() {\n\tregistry.RegisterConfigReg(\n\t\t\"VFS\",\n\t\tfunc(ctx types.Context, r gofig.ConfigRegistration) {\n\t\t\tvfsRoot := path.Join(context.MustPathConfig(ctx).Lib, \"vfs\")\n\t\t\tr.Key(\n\t\t\t\tgofig.String,\n\t\t\t\t\"\",\n\t\t\t\tvfsRoot,\n\t\t\t\t\"\",\n\t\t\t\t\"vfs.root\")\n\t\t})\n}\n\n\n\n\n\nfunc DeviceFilePath(config gofig.Config) string {\n\treturn path.Join(RootDir(config), \"dev\")\n}\n\n\nfunc VolumesDirPath(config gofig.Config) string {\n\treturn path.Join(RootDir(config), \"vol\")\n}\n\n\nfunc SnapshotsDirPath(config gofig.Config) string {\n\treturn path.Join(RootDir(config), \"snap\")\n}\n\nfunc RootDir(config gofig.Config) string ", "output": "{\n\treturn config.GetString(\"vfs.root\")\n}"}
{"input": "package logging\n\nimport (\n\t\"github.com/Sirupsen/logrus\"\n\t\"github.com/zenoss/glog\"\n\t\"github.com/zenoss/logri\"\n)\n\ntype logControl struct{}\n\n\nvar _ LogControl = &logControl{}\n\nfunc NewLogControl() LogControl {\n\treturn logControl{}\n}\n\nfunc (l logControl) SetLevel(level logrus.Level) {\n\tlogri.SetLevel(level)\n\tlogrus.SetLevel(level)\n}\n\nfunc (l logControl) ApplyConfigFromFile(file string) error {\n\treturn logri.ApplyConfigFromFile(file)\n}\n\nfunc (l logControl) WatchConfigFile(file string) {\n\tlogri.WatchConfigFile(file)\n}\n\nfunc (l logControl) SetVerbosity(value int) {\n\tglog.SetVerbosity(value)\n}\n\nfunc (l logControl) GetVerbosity() int {\n\treturn int(glog.GetVerbosity())\n}\n\nfunc (l logControl) SetToStderr(value bool) {\n\tglog.SetToStderr(value)\n}\n\nfunc (l logControl) SetAlsoToStderr(value bool) {\n\tglog.SetAlsoToStderr(value)\n}\n\nfunc (l logControl) SetStderrThreshold(value string) error {\n\treturn glog.SetStderrThreshold(value)\n}\n\nfunc (l logControl) SetVModule(value string) error {\n\treturn glog.SetVModule(value)\n}\n\n\n\nfunc (l logControl) SetTraceLocation(value string) error ", "output": "{\n\treturn glog.SetTraceLocation(value)\n}"}
{"input": "package gexp\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\n\n\ntype Context struct {\n\tcontext context.Context\n\tcancel  context.CancelFunc\n}\n\n\n\n\nfunc NewContext() *Context {\n\treturn &Context{\n\t\tcontext: context.Background(),\n\t}\n}\n\n\n\n\n\n\nfunc (c *Context) WithCancel() *Context {\n\tchild, cancel := context.WithCancel(c.context)\n\treturn &Context{\n\t\tcontext: child,\n\t\tcancel:  cancel,\n\t}\n}\n\n\n\n\n\n\nfunc (c *Context) WithDeadline(sec int64, nsec int64) *Context {\n\tchild, cancel := context.WithDeadline(c.context, time.Unix(sec, nsec))\n\treturn &Context{\n\t\tcontext: child,\n\t\tcancel:  cancel,\n\t}\n}\n\n\n\n\n\n\n\n\nfunc (c *Context) WithTimeout(nsec int64) *Context ", "output": "{\n\tchild, cancel := context.WithTimeout(c.context, time.Duration(nsec))\n\treturn &Context{\n\t\tcontext: child,\n\t\tcancel:  cancel,\n\t}\n}"}
{"input": "package store\n\nimport (\n\t\"time\"\n\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"github.com/russross/meddler\"\n\tsq \"github.com/Masterminds/squirrel\"\n)\n\ntype Feature struct {\n\tId        int64      `json:\"id\"                         meddler:\"id,pk\"`\n\tCreatedAt *time.Time `json:\"created_at,omitempty\"       meddler:\"created_at\"`\n\tName      *string    `json:\"name,omitempty\"             meddler:\"name\"`\n}\n\nfunc (s *store) GetFeatureByName(name string) (*Feature, error) {\n\tfeature := new(Feature)\n\n\tquery := sq.Select(\"*\").From(\"feature\")\n\tquery = query.Where(sq.Eq{\"name\": name})\n\n\tsql, args, err := query.ToSql()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlog.Debug(sql)\n\n\terr = meddler.QueryRow(s.db, feature, sql, args...)\n\n\treturn feature, err\n}\n\nfunc (s *store) ListFeatures() ([]*Feature, error) {\n\tquery := sq.Select(\"*\").From(\"feature\")\n\n\tsql, args, err := query.ToSql()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlog.Debug(sql)\n\n\tfeatures := []*Feature{}\n\terr = meddler.QueryAll(s.db, &features, sql, args...)\n\n\treturn features, err\n}\n\nfunc (s *store) CreateFeature(feature *Feature) error {\n\tfeature.CreatedAt = Time(time.Now())\n\treturn meddler.Insert(s.db, \"feature\", feature)\n}\n\n\n\nfunc (s *store) UpdateFeature(feature *Feature) error ", "output": "{\n\treturn meddler.Update(s.db, \"feature\", feature)\n}"}
{"input": "package migrator\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/cgrates/cgrates/engine\"\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\n\n\nfunc (m *Migrator) migrateRatingPlans() (err error) {\n\tvar vrs engine.Versions\n\tcurrent := engine.CurrentDataDBVersions()\n\tif vrs, err = m.getVersions(utils.RatingPlan); err != nil {\n\t\treturn\n\t}\n\n\tmigrated := true\n\tfor {\n\t\tversion := vrs[utils.RatingPlan]\n\t\tfor {\n\t\t\tswitch version {\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"Unsupported version %v\", version)\n\t\t\tcase current[utils.RatingPlan]:\n\t\t\t\tmigrated = false\n\t\t\t\tif m.sameDataDB {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif err = m.migrateCurrentRatingPlans(); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif version == current[utils.RatingPlan] || err == utils.ErrNoMoreData {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif err == utils.ErrNoMoreData || !migrated {\n\t\t\tbreak\n\t\t}\n\t\tm.stats[utils.RatingPlan]++\n\t}\n\tif err = m.setVersions(utils.RatingPlan); err != nil {\n\t\treturn\n\t}\n\treturn m.ensureIndexesDataDB(engine.ColRpl)\n}\n\nfunc (m *Migrator) migrateCurrentRatingPlans() (err error) ", "output": "{\n\tvar ids []string\n\tids, err = m.dmIN.DataManager().DataDB().GetKeysForPrefix(utils.RatingPlanPrefix)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, id := range ids {\n\t\tidg := strings.TrimPrefix(id, utils.RatingPlanPrefix)\n\t\trp, err := m.dmIN.DataManager().GetRatingPlan(idg, true, utils.NonTransactional)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif rp == nil || m.dryRun {\n\t\t\tcontinue\n\t\t}\n\t\tif err := m.dmOut.DataManager().SetRatingPlan(rp); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := m.dmIN.DataManager().RemoveRatingPlan(idg, utils.NonTransactional); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tm.stats[utils.RatingPlan]++\n\t}\n\treturn\n}"}
{"input": "package datacatalog\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype DeleteCustomPropertyRequest struct {\n\n\tCatalogId *string `mandatory:\"true\" contributesTo:\"path\" name:\"catalogId\"`\n\n\tNamespaceId *string `mandatory:\"true\" contributesTo:\"path\" name:\"namespaceId\"`\n\n\tCustomPropertyKey *string `mandatory:\"true\" contributesTo:\"path\" name:\"customPropertyKey\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request DeleteCustomPropertyRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request DeleteCustomPropertyRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request DeleteCustomPropertyRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype DeleteCustomPropertyResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response DeleteCustomPropertyResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response DeleteCustomPropertyResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request DeleteCustomPropertyRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) ", "output": "{\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}"}
{"input": "package memory\n\nimport (\n\t\"testing\"\n\n\tmbtest \"github.com/elastic/beats/metricbeat/mb/testing\"\n)\n\nfunc TestData(t *testing.T) {\n\tf := mbtest.NewEventFetcher(t, getConfig())\n\n\terr := mbtest.WriteEvent(f, t)\n\tif err != nil {\n\t\tt.Fatal(\"write\", err)\n\t}\n}\n\n\n\nfunc getConfig() map[string]interface{} ", "output": "{\n\treturn map[string]interface{}{\n\t\t\"module\":     \"system\",\n\t\t\"metricsets\": []string{\"memory\"},\n\t}\n}"}
{"input": "package core\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/oci/oci-go-sdk/v43/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetVolumeKmsKeyRequest struct {\n\n\tVolumeId *string `mandatory:\"true\" contributesTo:\"path\" name:\"volumeId\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetVolumeKmsKeyRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request GetVolumeKmsKeyRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request GetVolumeKmsKeyRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\n\n\n\ntype GetVolumeKmsKeyResponse struct {\n\n\tRawResponse *http.Response\n\n\tVolumeKmsKey `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response GetVolumeKmsKeyResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response GetVolumeKmsKeyResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request GetVolumeKmsKeyRequest) RetryPolicy() *common.RetryPolicy ", "output": "{\n\treturn request.RequestMetadata.RetryPolicy\n}"}
{"input": "package flamingo\n\ntype Selectors map[string]interface{}\n\n\n\ntype MongoQuery struct {\n}\n\nfunc (ms *MongoQuery) One(result interface{}) error {\n\treturn nil\n}\n\nfunc (ms *MongoQuery) All(result interface{}) error {\n\treturn nil\n}\n\n\ntype MongoCollection struct {\n}\n\n\n\nfunc (ms *MongoCollection) FindById(id interface{}) *MongoQuery {\n\treturn &MongoQuery{}\n}\n\nfunc (ms *MongoCollection) Insert(entity interface{}) error {\n\treturn nil\n}\n\nfunc (ms *MongoCollection) Update(entity interface{}) error {\n\treturn nil\n}\n\nfunc (ms *MongoCollection) Remove(selectors Selectors) error {\n\treturn nil\n}\n\nfunc (ms *MongoCollection) RemoveById(id interface{}) error {\n\treturn nil\n}\n\n\n\ntype MongoSession struct {\n}\n\nfunc (ms *MongoSession) Close() error {\n\treturn nil\n}\n\nfunc (ms *MongoSession) Db(name string) *MongoSession {\n\treturn ms\n}\n\nfunc (ms *MongoSession) Collection(name string) *MongoCollection {\n\treturn &MongoCollection{}\n}\n\n\n\ntype MongoClient struct {\n\tloggerFactory *LoggerFactory\n}\n\nfunc (m *MongoClient) OpenSession() (MongoSession, error) {\n\treturn MongoSession{}, nil\n}\n\nfunc NewMongoClient(uri string, loggerFactory *LoggerFactory) MongoClient {\n\treturn MongoClient{loggerFactory}\n}\n\nfunc (ms *MongoCollection) Query(selectors Selectors) *MongoQuery ", "output": "{\n\treturn &MongoQuery{}\n}"}
{"input": "package integration\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/coreos/etcd/pkg/transport\"\n)\n\n\nfunc copyTLSFiles(ti transport.TLSInfo, dst string) (transport.TLSInfo, error) {\n\tci := transport.TLSInfo{\n\t\tKeyFile:        filepath.Join(dst, \"server-key.pem\"),\n\t\tCertFile:       filepath.Join(dst, \"server.pem\"),\n\t\tTrustedCAFile:  filepath.Join(dst, \"etcd-root-ca.pem\"),\n\t\tClientCertAuth: ti.ClientCertAuth,\n\t}\n\tif err := copyFile(ti.KeyFile, ci.KeyFile); err != nil {\n\t\treturn transport.TLSInfo{}, err\n\t}\n\tif err := copyFile(ti.CertFile, ci.CertFile); err != nil {\n\t\treturn transport.TLSInfo{}, err\n\t}\n\tif err := copyFile(ti.TrustedCAFile, ci.TrustedCAFile); err != nil {\n\t\treturn transport.TLSInfo{}, err\n\t}\n\treturn ci, nil\n}\n\n\n\nfunc copyFile(src, dst string) error ", "output": "{\n\tf, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tw, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer w.Close()\n\n\tif _, err = io.Copy(w, f); err != nil {\n\t\treturn err\n\t}\n\treturn w.Sync()\n}"}
{"input": "package cache\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n)\n\n\n\ntype FSCache struct {\n\tRoot string\n}\n\n\n\nfunc NewFSCache(root string) (Cache, error) {\n\tfs := &FSCache{root}\n\terr := fs.Setup()\n\n\treturn fs, err\n}\n\n\nfunc (fs *FSCache) Setup() error {\n\terr := os.MkdirAll(fs.Root, os.ModeDir|0777)\n\treturn err\n}\n\n\nfunc (fs *FSCache) Get(key string) ([]byte, error) {\n\tcontent, err := ioutil.ReadFile(path.Join(fs.Root, key))\n\tif os.IsNotExist(err) {\n\t\treturn content, ErrNoSuchKey\n\t}\n\n\treturn content, err\n}\n\n\nfunc (fs *FSCache) Set(key string, content []byte) error {\n\treturn ioutil.WriteFile(\n\t\tpath.Join(fs.Root, key),\n\t\tcontent,\n\t\t0600,\n\t)\n}\n\n\nfunc (fs *FSCache) Keys() ([]string, error) {\n\tkeys := []string{}\n\tfiles, err := ioutil.ReadDir(fs.Root)\n\tif err != nil {\n\t\treturn keys, err\n\t}\n\n\tfor _, entry := range files {\n\t\tif entry.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tkeys = append(keys, entry.Name())\n\t}\n\n\treturn keys, nil\n}\n\n\n\n\nfunc (fs *FSCache) Delete(key string) error ", "output": "{\n\terr := os.Remove(path.Join(fs.Root, key))\n\tif os.IsNotExist(err) {\n\t\treturn ErrNoSuchKey\n\t}\n\treturn err\n}"}
{"input": "package testutil\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"gopkg.in/yaml.v3\"\n)\n\ntype Context struct {\n\tName    string `yaml:\"name,omitempty\"`\n\tContext struct {\n\t\tNamespace string `yaml:\"namespace,omitempty\"`\n\t} `yaml:\"context,omitempty\"`\n}\n\nfunc Ctx(name string) *Context           { return &Context{Name: name} }\nfunc (c *Context) Ns(ns string) *Context { c.Context.Namespace = ns; return c }\n\ntype Kubeconfig map[string]interface{}\n\nfunc KC() *Kubeconfig {\n\treturn &Kubeconfig{\n\t\t\"apiVersion\": \"v1\",\n\t\t\"kind\":       \"Config\"}\n}\n\n\nfunc (k *Kubeconfig) WithCurrentCtx(s string) *Kubeconfig       { (*k)[\"current-context\"] = s; return k }\nfunc (k *Kubeconfig) WithCtxs(c ...*Context) *Kubeconfig        { (*k)[\"contexts\"] = c; return k }\n\nfunc (k *Kubeconfig) ToYAML(t *testing.T) string {\n\tt.Helper()\n\tvar v strings.Builder\n\tif err := yaml.NewEncoder(&v).Encode(*k); err != nil {\n\t\tt.Fatalf(\"failed to encode mock kubeconfig: %v\", err)\n\t}\n\treturn v.String()\n}\n\nfunc (k *Kubeconfig) Set(key string, v interface{}) *Kubeconfig ", "output": "{ (*k)[key] = v; return k }"}
{"input": "package blanket_emulator\n\nimport (\n\t\"fmt\"\n)\n\ntype Event interface {\n\tHash() uint64\n\tInspect() string\n}\n\ntype ReturnEvent uint64\ntype ReadEvent uint64\ntype WriteEvent struct {\n\tAddr  uint64\n\tValue uint64\n}\ntype SyscallEvent uint64\ntype InvalidInstructionEvent uint64\n\nfunc (addr ReadEvent) Hash() uint64 {\n\treturn ReadEventHash(uint64(addr))\n}\n\nfunc (s WriteEvent) Hash() uint64 {\n\treturn WriteEventHash(s.Addr, s.Value)\n}\n\nfunc (s SyscallEvent) Hash() uint64 {\n\treturn SysEventHash(uint64(s))\n}\n\nfunc (s ReturnEvent) Hash() uint64 {\n\treturn ReturnEventHash(uint64(s))\n}\n\n\n\nfunc (addr ReadEvent) Inspect() string {\n\treturn fmt.Sprintf(\"Read([%x])\", addr)\n}\n\nfunc (addr ReturnEvent) Inspect() string {\n\treturn fmt.Sprintf(\"Return([%x])\", addr)\n}\n\nfunc (s WriteEvent) Inspect() string {\n\treturn fmt.Sprintf(\"Write([%x]=%x)\", s.Addr, s.Value)\n}\n\nfunc (s SyscallEvent) Inspect() string {\n\treturn fmt.Sprintf(\"Sys(%x)\", s)\n}\n\nfunc (s InvalidInstructionEvent) Inspect() string {\n\treturn fmt.Sprintf(\"InvalidOpcode([%x])\", s)\n}\n\nfunc (s InvalidInstructionEvent) Hash() uint64 ", "output": "{\n\treturn InvalidInstructionEventHash(uint64(s))\n}"}
{"input": "package handlers\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\n\tcontr \"github.com/goaltools/contrib/controllers/static\"\n\n\t\"github.com/goaltools/goal/strconv\"\n)\n\n\n\n\n\n\n\nvar Static tStatic\n\n\nvar context = url.Values{}\n\n\ntype tStatic struct {\n}\n\n\n\nfunc (t tStatic) New(w http.ResponseWriter, r *http.Request, ctr, act string) *contr.Static {\n\tc := &contr.Static{}\n\treturn c\n}\n\n\n\nfunc (t tStatic) Before(c *contr.Static, w http.ResponseWriter, r *http.Request) http.Handler {\n\n\treturn nil\n}\n\n\n\nfunc (t tStatic) After(c *contr.Static, w http.ResponseWriter, r *http.Request) (h http.Handler) {\n\n\treturn\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Init() (routes []struct {\n\tMethod, Pattern, Label string\n\tHandler                http.HandlerFunc\n}) {\n\n\troutes = append(routes, initStatic()...)\n\n\treturn\n}\n\nfunc initStatic() (rs []struct {\n\tMethod, Pattern, Label string\n\tHandler                http.HandlerFunc\n}) {\n\tcontext.Add(\"Static\", \"Serve\")\n\trs = append(rs, []struct {\n\t\tMethod, Pattern, Label string\n\t\tHandler                http.HandlerFunc\n\t}{\n\t\t{\n\t\t\tMethod:  \"GET\",\n\t\t\tPattern: \"/*filepath\",\n\t\t\tLabel:   \"\",\n\t\t\tHandler: Static.Serve,\n\t\t},\n\t}...)\n\treturn\n}\n\nfunc init() {\n\t_ = strconv.MeaningOfLife\n}\n\nfunc (t tStatic) Serve(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tvar h http.Handler\n\tc := Static.New(w, r, \"Static\", \"Serve\")\n\tdefer func() {\n\t\tif h != nil {\n\t\t\th.ServeHTTP(w, r)\n\t\t}\n\t}()\n\tdefer Static.After(c, w, r)\n\tif res := Static.Before(c, w, r); res != nil {\n\t\th = res\n\t\treturn\n\t}\n\tif res := c.Serve(\n\t\tstrconv.String(r.Form, \"filepath\"),\n\t); res != nil {\n\t\th = res\n\t\treturn\n\t}\n}"}
{"input": "package iso20022\n\n\ntype TotalTransactions2 struct {\n\n\tTotalEntries *NumberAndSumOfTransactions2 `xml:\"TtlNtries,omitempty\"`\n\n\tTotalCreditEntries *NumberAndSumOfTransactions1 `xml:\"TtlCdtNtries,omitempty\"`\n\n\tTotalDebitEntries *NumberAndSumOfTransactions1 `xml:\"TtlDbtNtries,omitempty\"`\n\n\tTotalEntriesPerBankTransactionCode []*TotalsPerBankTransactionCode2 `xml:\"TtlNtriesPerBkTxCd,omitempty\"`\n}\n\n\n\nfunc (t *TotalTransactions2) AddTotalCreditEntries() *NumberAndSumOfTransactions1 {\n\tt.TotalCreditEntries = new(NumberAndSumOfTransactions1)\n\treturn t.TotalCreditEntries\n}\n\nfunc (t *TotalTransactions2) AddTotalDebitEntries() *NumberAndSumOfTransactions1 {\n\tt.TotalDebitEntries = new(NumberAndSumOfTransactions1)\n\treturn t.TotalDebitEntries\n}\n\nfunc (t *TotalTransactions2) AddTotalEntriesPerBankTransactionCode() *TotalsPerBankTransactionCode2 {\n\tnewValue := new(TotalsPerBankTransactionCode2)\n\tt.TotalEntriesPerBankTransactionCode = append(t.TotalEntriesPerBankTransactionCode, newValue)\n\treturn newValue\n}\n\nfunc (t *TotalTransactions2) AddTotalEntries() *NumberAndSumOfTransactions2 ", "output": "{\n\tt.TotalEntries = new(NumberAndSumOfTransactions2)\n\treturn t.TotalEntries\n}"}
{"input": "package mcon\n\nimport (\n\t\"github.com/mabetle/mgo/mcore/mterm\"\n)\n\n\ntype XtermConsole struct {\n\t*mterm.ColorTerm\n}\n\n\n\nfunc NewXtermConsole() *XtermConsole ", "output": "{\n\treturn &XtermConsole{ColorTerm: mterm.NewColorTerm()}\n}"}
{"input": "package ikepolicies\n\nimport \"github.com/gophercloud/gophercloud\"\n\nconst (\n\trootPath     = \"vpn\"\n\tresourcePath = \"ikepolicies\"\n)\n\nfunc rootURL(c *gophercloud.ServiceClient) string {\n\treturn c.ServiceURL(rootPath, resourcePath)\n}\n\n\n\nfunc resourceURL(c *gophercloud.ServiceClient, id string) string ", "output": "{\n\treturn c.ServiceURL(rootPath, resourcePath, id)\n}"}
{"input": "package spark\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultLivyAPIVersion = \"2019-11-01-preview\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tEndpoint       string\n\tLivyAPIVersion string\n\tSparkPoolName  string\n}\n\n\nfunc New(endpoint string, sparkPoolName string) BaseClient {\n\treturn NewWithoutDefaults(endpoint, sparkPoolName, DefaultLivyAPIVersion)\n}\n\n\n\n\nfunc NewWithoutDefaults(endpoint string, sparkPoolName string, livyAPIVersion string) BaseClient ", "output": "{\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tEndpoint:       endpoint,\n\t\tLivyAPIVersion: livyAPIVersion,\n\t\tSparkPoolName:  sparkPoolName,\n\t}\n}"}
{"input": "package kafka\n\nimport (\n\t\"strings\"\n\n\t\"github.com/funkygao/gafka/telemetry\"\n\t\"github.com/funkygao/go-metrics\"\n)\n\ntype producerMetrics struct {\n\tname string\n\ttag  string\n\n\tasyncSend metrics.Meter\n\tasyncOk   metrics.Meter\n\tasyncFail metrics.Meter\n\n\tsyncOk   metrics.Meter\n\tsyncFail metrics.Meter\n}\n\nfunc newMetrics(name string) *producerMetrics {\n\ttag := telemetry.Tag(strings.Replace(name, \".\", \"_\", -1), \"\", \"\")\n\treturn &producerMetrics{\n\t\tname:      name,\n\t\ttag:       tag,\n\t\tasyncSend: metrics.NewRegisteredMeter(tag+\"dbus.kafka.async.send\", metrics.DefaultRegistry),\n\t\tasyncOk:   metrics.NewRegisteredMeter(tag+\"dbus.kafka.async.ok\", metrics.DefaultRegistry),\n\t\tasyncFail: metrics.NewRegisteredMeter(tag+\"dbus.kafka.async.fail\", metrics.DefaultRegistry),\n\n\t}\n}\n\n\n\nfunc (m *producerMetrics) Close() ", "output": "{\n\tmetrics.Unregister(m.tag + \"dbus.kafka.async.send\")\n\tmetrics.Unregister(m.tag + \"dbus.kafka.async.ok\")\n\tmetrics.Unregister(m.tag + \"dbus.kafka.async.fail\")\n\n}"}
{"input": "package unicreds\n\nimport (\n\t\"crypto/rand\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar (\n\tdataKey    = []byte{0x6a, 0xcf, 0xeb, 0xd6, 0xe9, 0xa6, 0x19, 0xc1, 0x38, 0xb9, 0xfc, 0x2d, 0x53, 0x23, 0x4d, 0x78, 0x85, 0x48, 0x96, 0xd6, 0xd2, 0xf6, 0xf4, 0x42, 0x99, 0x9d, 0x8e, 0xa9, 0xed, 0xf0, 0xb3, 0xf2}\n\tcipherText = []byte{0xa3, 0xcc, 0x1e, 0xd7, 0x3a, 0xfd, 0x18, 0x3f, 0x8a, 0xb2, 0xd5, 0x6f, 0xdf, 0x1d, 0x98, 0x4d, 0xe4, 0xf6}\n)\n\nfunc TestEncrypt(t *testing.T) {\n\n\tplaintext := []byte(\"something test 123\")\n\n\tcdata, err := Encrypt(dataKey, plaintext)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, cdata, cipherText)\n}\n\n\n\nfunc readRandData(c int) []byte {\n\tb := make([]byte, c)\n\trand.Read(b)\n\treturn b\n}\n\nfunc TestDecrypt(t *testing.T) ", "output": "{\n\n\tplaintext := []byte(\"something test 123\")\n\n\tcdata, err := Decrypt(dataKey, cipherText)\n\n\tassert.Nil(t, err)\n\tassert.Equal(t, cdata, plaintext)\n}"}
{"input": "package routers\n\nimport (\n\t\"github.com/Odinman/ogo\"\n\n\t\"../models\"\n)\n\ntype TestRouter struct {\n\togo.Router\n}\n\n\n\nfunc init() ", "output": "{\n\tr := ogo.NewRouter(new(TestRouter), \"test\").(*TestRouter)\n\tr.GenericRoute(new(models.Test), ogo.GA_ALL)\n\tr.Init()\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n)\n\n\n\n\nfunc main() {\n\tfpath := \"testdata/sample.json\"\n\n\tfile, err := os.Open(fpath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer file.Close()\n\ttbytes, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tjsonStream := string(tbytes)\n\tdecodeString(jsonStream)\n\n\tdecodeFile(file)\n\n\tfile2, err := os.Open(fpath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdecodeFile(file2)\n}\n\nfunc decodeFile(file *os.File) {\n\trmap := map[string]string{}\n\tdec := json.NewDecoder(file)\n\tfor {\n\t\tif err := dec.Decode(&rmap); err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tfmt.Printf(\"%+v\\n\", rmap)\n}\n\n\n\nfunc decodeString(jsonStream string) ", "output": "{\n\trmap := map[string]string{}\n\tdec := json.NewDecoder(strings.NewReader(jsonStream))\n\tfor {\n\t\tif err := dec.Decode(&rmap); err == io.EOF {\n\t\t\tbreak\n\t\t} else if err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tfmt.Printf(\"%+v\\n\", rmap)\n}"}
{"input": "package console\n\nimport \"github.com/cgrates/cgrates/utils\"\n\nfunc init() {\n\tc := &ImportTpFromFolder{\n\t\tname:      \"import_tp_from_folder\",\n\t\trpcMethod: utils.APIerSv1ImportTariffPlanFromFolder,\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}\n\n\ntype ImportTpFromFolder struct {\n\tname      string\n\trpcMethod string\n\trpcParams *utils.AttrImportTPFromFolder\n\trpcResult string\n\t*CommandExecuter\n}\n\nfunc (self *ImportTpFromFolder) Name() string {\n\treturn self.name\n}\n\nfunc (self *ImportTpFromFolder) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\n\n\nfunc (self *ImportTpFromFolder) PostprocessRpcParams() error {\n\treturn nil\n}\n\nfunc (self *ImportTpFromFolder) RpcResult() interface{} {\n\tvar s string\n\treturn &s\n}\n\nfunc (self *ImportTpFromFolder) RpcParams(reset bool) interface{} ", "output": "{\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &utils.AttrImportTPFromFolder{}\n\t}\n\treturn self.rpcParams\n}"}
{"input": "package internal\n\nimport (\n\t\"encoding/json\"\n)\n\ntype User struct {\n\tGlobalKey string `json:\"global_key\"`\n\tEmail     string `json:\"email\"`\n\tAvatar    string `json:\"avatar\"`\n}\n\n\n\nfunc (c *Client) GetCurrentUser() (*User, error) ", "output": "{\n\tu := \"/account/current_user\"\n\tresp, err := c.Get(u, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuser := &User{}\n\terr = json.Unmarshal(resp, user)\n\tif err != nil {\n\t\treturn nil, APIClientErr{\"fail to parse current user data\", u, err}\n\t}\n\treturn user, nil\n}"}
{"input": "package retention_test\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/messagedb/messagedb/services/retention\"\n)\n\n\n\nfunc TestServiceSettingLogger(t *testing.T) {\n\n\tconfig := retention.NewConfig()\n\ts := retention.NewService(config)\n\n\tlogger := log.New(os.Stderr, \"[retention] \", log.LstdFlags)\n\ts.SetLogger(logger)\n\tif s.Logger() != logger {\n\t\tt.Fatalf(\"unexpected logger state: %v\", s.Logger())\n\t}\n\n}\n\nfunc TestServiceConstructor(t *testing.T) ", "output": "{\n\n\tconfig := retention.NewConfig()\n\n\ts := retention.NewService(config)\n\tif err := s.Open(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer s.Close()\n}"}
{"input": "package cmd\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/viper\"\n)\n\nvar cfgFile string\n\n\nvar RootCmd = &cobra.Command{\n\tUse:   \"docktor\",\n\tShort: \"Administration & Monitoring Deployment with Docker\",\n\tLong: `Docktor is a web application which aims to make the deployment of docke services easier\nWith it, you can manage several daemons, services and group.\nEach service can be deployed on a daemon for a group.\n\t`,\n}\n\nconst (\n\tconfigPath            = \"$HOME\"\n\tconfigFile            = \".docktor\"\n\tprefixForEnvVariables = \"docktor\"\n)\n\n\n\nfunc Execute() {\n\tif err := RootCmd.Execute(); err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(-1)\n\t}\n}\n\nfunc init() {\n\tcobra.OnInitialize(initConfig)\n\tRootCmd.PersistentFlags().StringVar(&cfgFile, \"config\", \"\", \"config file (default is $HOME/.docktor.yaml)\")\n}\n\n\n\n\nfunc initConfig() ", "output": "{\n\tif cfgFile != \"\" { \n\t\tviper.SetConfigFile(cfgFile)\n\t}\n\n\tviper.SetEnvPrefix(prefixForEnvVariables)                        \n\tviper.SetConfigName(configFile)                                  \n\tviper.AddConfigPath(configPath)                                  \n\tviper.AutomaticEnv()                                             \n\tviper.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\", \"-\", \"_\")) \n\n\terr := viper.ReadInConfig()\n\tif err == nil {\n\t\tfmt.Println(\"Using config file:\" + viper.ConfigFileUsed())\n\t} else {\n\t\tfmt.Println(\"Cant read config file:\" + viper.ConfigFileUsed())\n\t}\n}"}
{"input": "package geocoder\n\nimport \"testing\"\n\nfunc TestNewGeoPoint(t *testing.T) {\n\tgeoPoint, err := NewGeoPoint(\"59.939095 30.315868\")\n\tif err != nil {\n\t\tt.Fatal(\"Error parsing geo coordinates\")\n\t}\n\n\tif geoPoint.longitude != 59.939095 {\n\t\tt.Fatal(\"Error parsing longitude\")\n\t}\n\n\tif geoPoint.latitude != 30.315868 {\n\t\tt.Fatal(\"Error parsing latitude\")\n\t}\n}\n\n\n\nfunc TestLatitude(t *testing.T) {\n\tgeoPoint, _ := NewGeoPoint(\"59.939095 30.315868\")\n\tif geoPoint.Latitude() != 30.315868 {\n\t\tt.Fatal(\"Error return latitude\")\n\t}\n}\n\nfunc TestString(t *testing.T) {\n\tgeoPoint, _ := NewGeoPoint(\"59.939095 30.315868\")\n\tif geoPoint.String() != \"59.939095 30.315868\" {\n\t\tt.Fatal(\"Error return coordinates string\")\n\t}\n}\n\nfunc TestLongitude(t *testing.T) ", "output": "{\n\tgeoPoint, _ := NewGeoPoint(\"59.939095 30.315868\")\n\tif geoPoint.Longitude() != 59.939095 {\n\t\tt.Fatal(\"Error return longitude\")\n\t}\n}"}
{"input": "package latest\n\nimport (\n\t\"k8s.io/kubernetes/pkg/api/unversioned\"\n\t\"k8s.io/kubernetes/pkg/runtime\"\n\t\"k8s.io/kubernetes/pkg/runtime/serializer/json\"\n\t\"k8s.io/kubernetes/pkg/runtime/serializer/versioning\"\n\t\"k8s.io/kubernetes/plugin/pkg/scheduler/api\"\n\t_ \"k8s.io/kubernetes/plugin/pkg/scheduler/api/v1\"\n)\n\n\nconst Version = \"v1\"\n\n\nconst OldestVersion = \"v1\"\n\n\n\n\n\nvar Versions = []string{\"v1\"}\n\n\n\nvar Codec runtime.Codec\n\n\n\nfunc init() ", "output": "{\n\tjsonSerializer := json.NewSerializer(json.DefaultMetaFactory, api.Scheme, api.Scheme, true)\n\tCodec = versioning.NewCodecForScheme(\n\t\tapi.Scheme,\n\t\tjsonSerializer,\n\t\tjsonSerializer,\n\t\tunversioned.GroupVersion{Version: Version},\n\t\truntime.InternalGroupVersioner,\n\t)\n}"}
{"input": "package main\n\nimport (\n\t\"os\"\n\t\"fmt\"\n)\n\n\n\nfunc parseArgs(args []string) {\n\tvar usage = func() {\n        fmt.Fprintf(os.Stderr, \"usage: %s [inputFile] [outputFile]\\n\", os.Args[0])\n\t}\n\n\tif len(args) != 2 { \n\t\tusage()\n\t\tos.Exit(1)\n\t}\n}\n\nfunc main() {\n\targs := os.Args[1:]\n\tparseArgs(args)\n\n\tfin, err := os.Open(args[0])\n\tcheck(err)\n\tdefer fin.Close()\n\n\tfout, err := os.Create(args[1])\n\tcheck(err)\n\tdefer fout.Close()\n\n\tvar nLines uint32\n\t_, err = fmt.Fscanf(fin, \"%d\", &nLines)\n\tcheck(err)\n\n\tr := StreamBucketSort(fin, 8, int(nLines))\n\tfor _, v := range r {\n\t\tfmt.Fprintln(fout, v)\n\t}\n}\n\nfunc check(e error) ", "output": "{\n    if e != nil {\n        panic(e)\n    }\n}"}
{"input": "package keys\n\nimport \"context\"\n\n\ntype keySetType int\n\n\nconst keySet = keySetType(0)\n\n\nfunc Get(ctx context.Context) []interface{} {\n\tseen := map[interface{}]bool{}\n\tresult := make([]interface{}, 0, 10)\n\tfor link, _ := ctx.Value(keySet).(*Link); link != nil; link = link.Next {\n\t\tif !seen[link.Value] {\n\t\t\tseen[link.Value] = true\n\t\t\tresult = append(result, link.Value)\n\t\t}\n\t}\n\treturn result\n}\n\n\n\n\n\n\nfunc Clone(ctx context.Context, from context.Context) context.Context {\n\tfor _, key := range Get(from) {\n\t\tctx = WithValue(ctx, key, from.Value(key))\n\t}\n\treturn ctx\n}\n\nfunc WithValue(ctx context.Context, key interface{}, value interface{}) context.Context ", "output": "{\n\told, _ := ctx.Value(keySet).(*Link)\n\tctx = context.WithValue(ctx, key, value)\n\treturn context.WithValue(ctx, keySet, &Link{Value: key, Next: old})\n}"}
{"input": "package structs\n\nimport (\n\t\"time\"\n\n\t\"github.com/hashicorp/consul/types\"\n)\n\n\n\n\n\n\ntype CheckType struct {\n\n\tCheckID types.CheckID\n\tName    string\n\tStatus  string\n\tNotes   string\n\n\n\tScript            string\n\tHTTP              string\n\tHeader            map[string][]string\n\tMethod            string\n\tTCP               string\n\tInterval          time.Duration\n\tDockerContainerID string\n\tShell             string\n\tTLSSkipVerify     bool\n\tTimeout           time.Duration\n\tTTL               time.Duration\n\n\tDeregisterCriticalServiceAfter time.Duration\n}\ntype CheckTypes []*CheckType\n\n\nfunc (c *CheckType) Valid() bool {\n\treturn c.IsTTL() || c.IsMonitor() || c.IsHTTP() || c.IsTCP() || c.IsDocker()\n}\n\n\nfunc (c *CheckType) IsTTL() bool {\n\treturn c.TTL != 0\n}\n\n\nfunc (c *CheckType) IsMonitor() bool {\n\treturn c.Script != \"\" && c.DockerContainerID == \"\" && c.Interval != 0\n}\n\n\nfunc (c *CheckType) IsHTTP() bool {\n\treturn c.HTTP != \"\" && c.Interval != 0\n}\n\n\n\n\n\nfunc (c *CheckType) IsDocker() bool {\n\treturn c.DockerContainerID != \"\" && c.Script != \"\" && c.Interval != 0\n}\n\nfunc (c *CheckType) IsTCP() bool ", "output": "{\n\treturn c.TCP != \"\" && c.Interval != 0\n}"}
{"input": "package readline\n\nimport (\n\t\"github.com/golang/glog\"\n\t\"github.com/jcw/flow\"\n\n\t\"bufio\"\n\t\"os\"\n)\n\nfunc init() {\n\tglog.Info(\"ReadlineStdIn Init...\")\n\tflow.Registry[\"ReadlineStdIn\"] = func() flow.Circuitry { return new(ReadlineStdIn) }\n\n}\n\n\n\n\ntype ReadlineStdIn struct {\n\tflow.Gadget\n\n\tOut flow.Output \n}\n\n\n\nfunc (g *ReadlineStdIn) Run() ", "output": "{\n\n\texit := false\n\n\tsin := bufio.NewScanner(os.Stdin)\n\n\tfor exit == false {\n\n\t\tvar line string\n\t\tfor sin.Scan() {\n\t\t\tline = sin.Text()\n\t\t\tg.Out.Send(line)\n\t\t}\n\n\t\terr := sin.Err()\n\n\t\tif err != nil {\n\t\t\tglog.Errorln(\"ReadlineStdIn Error:\", err)\n\t\t}\n\n\t}\n\n}"}
{"input": "package android_review_watcher\n\nimport \"github.com/operando/golack\"\n\ntype SlackWriter struct {\n\twebhook golack.Webhook\n\tconf    golack.Slack\n}\n\n\n\nfunc NewSlackWriter(webhook golack.Webhook, conf golack.Slack) *SlackWriter {\n\treturn &SlackWriter{\n\t\twebhook: webhook,\n\t\tconf:    conf,\n\t}\n}\n\nfunc (s *SlackWriter) Write(p []byte) (n int, err error) ", "output": "{\n\tpayload := golack.Payload{\n\t\tSlack: s.conf,\n\t}\n\tpayload.Slack.Text = string(p)\n\tgolack.Post(payload, s.webhook)\n\treturn len(p), nil\n}"}
{"input": "package packages\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/limetext/lime-backend/lib/loaders\"\n\t\"github.com/limetext/lime-backend/lib/log\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype (\n\tPacket struct {\n\t\tpath string\n\t\tmarshalTo json.Unmarshaler\n\t}\n\n\tPackets []*Packet\n)\n\n\nfunc NewPacket(path string, marshal json.Unmarshaler) *Packet {\n\treturn &Packet{path, marshal}\n}\n\nfunc (p *Packet) Name() string {\n\treturn p.path\n}\n\n\n\nfunc (p *Packet) Get() interface{} {\n\te := []byte(`{}`)\n\tif p.group() == \"keymap\" {\n\t\te = []byte(`[]`)\n\t}\n\n\tif _, err := os.Stat(p.path); os.IsNotExist(err) {\n\t\tlog.Finest(\"%s doesn't exist yet\", p.path)\n\t\treturn e\n\t}\n\n\td, err := ioutil.ReadFile(p.path)\n\tif err != nil {\n\t\tlog.Errorf(\"Couldn't read file: %s\", err)\n\t\treturn e\n\t}\n\treturn d\n}\n\n\nfunc (p *Packet) FileChanged(name string) {\n\tp.Load()\n}\n\nfunc (p *Packet) Load() error {\n\treturn loaders.LoadJSON(p.Get().([]byte), p)\n}\n\nfunc (p *Packet) MarshalTo() json.Unmarshaler {\n\treturn p.marshalTo\n}\n\nfunc (p *Packet) UnmarshalJSON(data []byte) error {\n\treturn p.marshalTo.UnmarshalJSON(data)\n}\n\n\nfunc (p *Packet) group() string {\n\tfor _, key := range types {\n\t\tif strings.Contains(filepath.Ext(p.Name()), key) {\n\t\t\treturn key\n\t\t}\n\t}\n\treturn \"\"\n}\n\n\n\n\nfunc (p Packets) Filter(key string) Packets ", "output": "{\n\tvar pckts Packets\n\tfor _, pckt := range p {\n\t\tif strings.Contains(filepath.Ext(pckt.Name()), key) {\n\t\t\tpckts = append(pckts, pckt)\n\t\t}\n\t}\n\treturn pckts\n}"}
{"input": "package http\n\nimport (\n\t\"github.com/gorilla/mux\"\n\n\t\"github.com/harrowio/harrow/domain\"\n)\n\ntype featuresHandler struct{}\n\n\n\nfunc (self *featuresHandler) Feature(ctxt RequestContext) error {\n\tfeatures := domain.NewFeaturesFromConfig(c.FeaturesConfig())\n\tname := ctxt.PathParameter(\"name\")\n\n\tfor _, feature := range features {\n\t\tif feature.Name == name {\n\t\t\twriteAsJson(ctxt, feature)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn new(domain.NotFoundError)\n}\n\nfunc (self *featuresHandler) List(ctxt RequestContext) error {\n\tfeatures := domain.NewFeaturesFromConfig(c.FeaturesConfig())\n\tresult := []interface{}{}\n\n\tfor _, feature := range features {\n\t\tresult = append(result, feature)\n\t}\n\n\twriteCollectionPageAsJson(ctxt, &CollectionPage{\n\t\tCount:      len(result),\n\t\tTotal:      len(result),\n\t\tCollection: result,\n\t})\n\n\treturn nil\n}\n\nfunc MountFeaturesHandler(r *mux.Router, ctxt ServerContext) ", "output": "{\n\th := &featuresHandler{}\n\n\troot := r.PathPrefix(\"/api-features\").Subrouter()\n\titem := root.PathPrefix(\"/{name}\").Subrouter()\n\titem.Methods(\"GET\").Handler(HandlerFunc(ctxt, h.Feature))\n\troot.Methods(\"GET\").Handler(HandlerFunc(ctxt, h.List))\n}"}
{"input": "package libvirt\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/mitchellh/multistep\"\n\t\"github.com/mitchellh/packer/packer\"\n\t\"github.com/vtolstov/libvirt-go\"\n)\n\ntype stepCreateNetwork struct{}\n\nfunc (stepCreateNetwork) Run(state multistep.StateBag) multistep.StepAction {\n\tconfig := state.Get(\"config\").(*Config)\n\tui := state.Get(\"ui\").(packer.Ui)\n\n\tif config.NetworkType == \"user\" {\n\t\treturn multistep.ActionContinue\n\t}\n\n\tvar lvn libvirt.VirNetwork\n\tlv, err := libvirt.NewVirConnection(config.LibvirtUrl)\n\tif err != nil {\n\t\terr := fmt.Errorf(\"Error connecting to libvirt: %s\", err)\n\t\tstate.Put(\"error\", err)\n\t\tui.Error(err.Error())\n\t\treturn multistep.ActionHalt\n\t}\n\tdefer lv.CloseConnection()\n\tif lvn, err = lv.LookupNetworkByName(config.NetworkName); err != nil {\n\t\tlvn, err = lv.NetworkDefineXML(config.NetworkXml)\n\t\tif err != nil {\n\t\t\terr := fmt.Errorf(\"Error defining network: %s\", err)\n\t\t\tstate.Put(\"error\", err)\n\t\t\tui.Error(err.Error())\n\t\t\treturn multistep.ActionHalt\n\t\t}\n\t}\n\tdefer lvn.Free()\n\tif ok, err := lvn.IsActive(); !ok && err == nil {\n\t\terr = lvn.Create()\n\t\tif err != nil {\n\t\t\terr := fmt.Errorf(\"Error creating network: %s\", err)\n\t\t\tstate.Put(\"error\", err)\n\t\t\tui.Error(err.Error())\n\t\t\treturn multistep.ActionHalt\n\t\t}\n\t}\n\treturn multistep.ActionContinue\n}\n\n\n\nfunc (stepCreateNetwork) Cleanup(state multistep.StateBag) ", "output": "{\n\tconfig := state.Get(\"config\").(*Config)\n\tui := state.Get(\"ui\").(packer.Ui)\n\n\tif config.NetworkType == \"user\" {\n\t\treturn\n\t}\n\n\tlv, err := libvirt.NewVirConnection(config.LibvirtUrl)\n\tif err != nil {\n\t\terr := fmt.Errorf(\"Error connecting to libvirt: %s\", err)\n\t\tstate.Put(\"error\", err)\n\t\tui.Error(err.Error())\n\t\treturn\n\t}\n\n\tif lvn, err := lv.LookupNetworkByName(config.NetworkName); err == nil {\n\t\tdefer lvn.Free()\n\t\tif ok, err := lvn.IsActive(); !ok && err == nil {\n\t\t\terr = lvn.Destroy()\n\t\t\tif err != nil {\n\t\t\t\tui.Error(fmt.Sprintf(\"Error destroying network: %s\", err))\n\t\t\t}\n\t\t}\n\t}\n}"}
{"input": "package fips\n\nimport \"crypto/tls\"\n\n\n\n\n\n\n\nconst Enabled = enabled\n\n\n\nfunc CipherSuitesDARE() []byte {\n\treturn cipherSuitesDARE()\n}\n\n\n\nfunc CipherSuitesTLS() []uint16 {\n\treturn cipherSuitesTLS()\n}\n\n\n\n\n\nfunc EllipticCurvesTLS() []tls.CurveID ", "output": "{\n\treturn ellipticCurvesTLS()\n}"}
{"input": "package math\n\n\n\nfunc Log10(x float64) float64\n\n\n\n\n\nfunc Log2(x float64) float64\n\nfunc log2(x float64) float64 {\n\tfrac, exp := Frexp(x)\n\treturn Log(frac)*(1/Ln2) + float64(exp)\n}\n\nfunc log10(x float64) float64 ", "output": "{\n\treturn Log(x) * (1 / Ln10)\n}"}
{"input": "package fastly\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"sort\"\n\t\"strconv\"\n\n\t\"github.com/hashicorp/go-cleanhttp\"\n\t\"github.com/hashicorp/terraform/helper/hashcode\"\n\t\"github.com/hashicorp/terraform/helper/schema\"\n)\n\ntype dataSourceFastlyIPRangesResult struct {\n\tAddresses []string\n}\n\n\n\nfunc dataSourceFastlyIPRangesRead(d *schema.ResourceData, meta interface{}) error {\n\n\tconn := cleanhttp.DefaultClient()\n\n\tlog.Printf(\"[DEBUG] Reading IP ranges\")\n\n\tres, err := conn.Get(\"https://api.fastly.com/public-ip-list\")\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error listing IP ranges: %s\", err)\n\t}\n\n\tdefer res.Body.Close()\n\n\tdata, err := ioutil.ReadAll(res.Body)\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error reading response body: %s\", err)\n\t}\n\n\td.SetId(strconv.Itoa(hashcode.String(string(data))))\n\n\tresult := new(dataSourceFastlyIPRangesResult)\n\n\tif err := json.Unmarshal(data, result); err != nil {\n\t\treturn fmt.Errorf(\"Error parsing result: %s\", err)\n\t}\n\n\tsort.Strings(result.Addresses)\n\n\tif err := d.Set(\"cidr_blocks\", result.Addresses); err != nil {\n\t\treturn fmt.Errorf(\"Error setting ip ranges: %s\", err)\n\t}\n\n\treturn nil\n\n}\n\nfunc dataSourceFastlyIPRanges() *schema.Resource ", "output": "{\n\treturn &schema.Resource{\n\t\tRead: dataSourceFastlyIPRangesRead,\n\n\t\tSchema: map[string]*schema.Schema{\n\t\t\t\"cidr_blocks\": &schema.Schema{\n\t\t\t\tType:     schema.TypeList,\n\t\t\t\tComputed: true,\n\t\t\t\tElem:     &schema.Schema{Type: schema.TypeString},\n\t\t\t},\n\t\t},\n\t}\n}"}
{"input": "package plan\n\nimport (\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"gopkg.in/sqle/sqle.v0/mem\"\n\t\"gopkg.in/sqle/sqle.v0/sql\"\n)\n\n\n\nfunc TestDescribe_Empty(t *testing.T) {\n\tassert := assert.New(t)\n\n\td := NewDescribe(NewUnresolvedTable(\"test_table\"))\n\n\titer, err := d.RowIter()\n\tassert.Nil(err)\n\tassert.NotNil(iter)\n\n\tn, err := iter.Next()\n\tassert.Equal(io.EOF, err)\n\tassert.Nil(n)\n}\n\nfunc TestDescribe(t *testing.T) ", "output": "{\n\tassert := assert.New(t)\n\n\ttable := mem.NewTable(\"test\", sql.Schema{\n\t\t{Name: \"c1\", Type: sql.String},\n\t\t{Name: \"c2\", Type: sql.Integer},\n\t})\n\n\td := NewDescribe(table)\n\titer, err := d.RowIter()\n\tassert.Nil(err)\n\tassert.NotNil(iter)\n\n\tn, err := iter.Next()\n\tassert.Nil(err)\n\tassert.Equal(sql.NewRow(\"c1\", \"string\"), n)\n\n\tn, err = iter.Next()\n\tassert.Nil(err)\n\tassert.Equal(sql.NewRow(\"c2\", \"integer\"), n)\n\n\tn, err = iter.Next()\n\tassert.Equal(io.EOF, err)\n\tassert.Nil(n)\n}"}
{"input": "package server\n\nimport (\n\t\"testing\"\n\n\tsrvconfig \"github.com/containerd/containerd/services/server/config\"\n\t\"gotest.tools/v3/assert\"\n\tis \"gotest.tools/v3/assert/cmp\"\n)\n\nfunc TestCreateTopLevelDirectoriesErrorsWithSamePathForRootAndState(t *testing.T) {\n\tpath := \"/tmp/path/for/testing\"\n\terr := CreateTopLevelDirectories(&srvconfig.Config{\n\t\tRoot:  path,\n\t\tState: path,\n\t})\n\tassert.Check(t, is.Error(err, \"root and state must be different paths\"))\n}\n\n\n\nfunc TestCreateTopLevelDirectoriesWithEmptyRootPath(t *testing.T) {\n\tstatePath := \"/tmp/path/for/testing\"\n\trootPath := \"\"\n\terr := CreateTopLevelDirectories(&srvconfig.Config{\n\t\tRoot:  rootPath,\n\t\tState: statePath,\n\t})\n\tassert.Check(t, is.Error(err, \"root must be specified\"))\n}\n\nfunc TestCreateTopLevelDirectoriesWithEmptyStatePath(t *testing.T) ", "output": "{\n\tstatePath := \"\"\n\trootPath := \"/tmp/path/for/testing\"\n\terr := CreateTopLevelDirectories(&srvconfig.Config{\n\t\tRoot:  rootPath,\n\t\tState: statePath,\n\t})\n\tassert.Check(t, is.Error(err, \"state must be specified\"))\n}"}
{"input": "package reflecter\n\nimport (\n\t\"github.com/bouk/symme\"\n\t\"reflect\"\n\t\"unsafe\"\n)\n\nvar types []reflect.Type\n\ntype enterface struct{ typ, val uintptr }\n\n\n\n\nfunc Types() []reflect.Type {\n\treturn types\n}\n\nfunc init() ", "output": "{\n\treflect.SliceOf(reflect.TypeOf(1))\n\n\tt, err := symme.Table()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\trtypeType := reflect.TypeOf(1)\n\tvar typelinks func() []uintptr\n\ttlLocation := uintptr(t.LookupFunc(\"reflect.typelinks\").Value)\n\t*(*uintptr)(unsafe.Pointer(&typelinks)) = uintptr(unsafe.Pointer(&tlLocation))\n\n\tfor _, typ := range typelinks() {\n\t\t(*enterface)(unsafe.Pointer(&rtypeType)).val = typ\n\t\ttypes = append(types, rtypeType)\n\t}\n}"}
{"input": "package user\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n\ntype RangeList []*Range\n\n\nfunc ParseRangeList(str string) (*RangeList, error) {\n\trl := RangeList{}\n\tif len(str) == 0 {\n\t\treturn &rl, nil\n\t}\n\tparts := strings.Split(str, \",\")\n\tfor _, p := range parts {\n\t\tr, err := ParseRange(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trl = append(rl, r)\n\t}\n\treturn &rl, nil\n}\n\n\nfunc (l *RangeList) Empty() bool {\n\tif len(*l) == 0 {\n\t\treturn true\n\t}\n\tfor _, r := range *l {\n\t\tif !r.Empty() {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\nfunc (l *RangeList) Contains(uid int) bool {\n\tfor _, r := range *l {\n\t\tif r.Contains(uid) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc (l *RangeList) Type() string {\n\treturn \"user.RangeList\"\n}\n\n\nfunc (l *RangeList) Set(value string) error {\n\tnewRangeList, err := ParseRangeList(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*l = *newRangeList\n\treturn nil\n}\n\n\n\n\n\n\nfunc IsUserAllowed(user string, allowed *RangeList) bool {\n\tuid, err := strconv.Atoi(user)\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn allowed.Contains(uid)\n}\n\nfunc (l *RangeList) String() string ", "output": "{\n\trangeStrings := []string{}\n\tfor _, r := range *l {\n\t\trangeStrings = append(rangeStrings, r.String())\n\t}\n\treturn strings.Join(rangeStrings, \",\")\n}"}
{"input": "package v1beta1\n\nimport (\n\tv1beta1 \"k8s.io/api/policy/v1beta1\"\n)\n\n\n\ntype FSGroupStrategyOptionsApplyConfiguration struct {\n\tRule   *v1beta1.FSGroupStrategyType `json:\"rule,omitempty\"`\n\tRanges []IDRangeApplyConfiguration  `json:\"ranges,omitempty\"`\n}\n\n\n\nfunc FSGroupStrategyOptions() *FSGroupStrategyOptionsApplyConfiguration {\n\treturn &FSGroupStrategyOptionsApplyConfiguration{}\n}\n\n\n\n\n\n\n\n\n\nfunc (b *FSGroupStrategyOptionsApplyConfiguration) WithRanges(values ...*IDRangeApplyConfiguration) *FSGroupStrategyOptionsApplyConfiguration {\n\tfor i := range values {\n\t\tif values[i] == nil {\n\t\t\tpanic(\"nil value passed to WithRanges\")\n\t\t}\n\t\tb.Ranges = append(b.Ranges, *values[i])\n\t}\n\treturn b\n}\n\nfunc (b *FSGroupStrategyOptionsApplyConfiguration) WithRule(value v1beta1.FSGroupStrategyType) *FSGroupStrategyOptionsApplyConfiguration ", "output": "{\n\tb.Rule = &value\n\treturn b\n}"}
{"input": "package figure\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"strconv\"\n  \"strings\"\n)\n\nconst signature = \"flf2\"\nconst reverseFlag = \"1\"\nvar charDelimiters = [3]string{\"@\", \"#\", \"$\"}\nvar hardblanksBlacklist = [2]byte{'a', '2'}\n\nfunc getFile(name string) (file http.File) {\n  filePath := fmt.Sprintf(\"%s.flf\", name)\n  file, err := AssetFS().Open(filePath)\n  if err != nil {\n    log.Fatalf(\"invalid font name:%s.\",err)\n  }\n  return file\n}\n\nfunc getHeight(metadata string) int {\n  datum := strings.Fields(metadata)[1]\n  height, _ := strconv.Atoi(datum)\n  return height\n}\n\nfunc getBaseline(metadata string) int {\n  datum := strings.Fields(metadata)[2]\n  baseline, _ := strconv.Atoi(datum)\n  return baseline\n}\n\nfunc getHardblank(metadata string) byte {\n  datum := strings.Fields(metadata)[0]\n  hardblank := datum[len(datum)-1]\n  if hardblank == hardblanksBlacklist[0] || hardblank == hardblanksBlacklist[1] {\n    return ' '\n  } else {\n    return hardblank\n  }\n}\n\nfunc getReverse(metadata string) bool {\n  data := strings.Fields(metadata)\n  return len(data) > 6 && data[6] == reverseFlag\n}\n\n\n\nfunc lastCharLine(text string, height int) bool ", "output": "{\n  endOfLine, length := \"  \", 2\n  if height == 1 && len(text) > 0 {\n    length = 1\n  }\n  if len(text) >= length {\n    endOfLine = text[len(text)-length:]\n  }\n  return endOfLine == strings.Repeat(charDelimiters[0], length) ||\n           endOfLine == strings.Repeat(charDelimiters[1], length) ||\n           endOfLine == strings.Repeat(charDelimiters[2], length)\n}"}
{"input": "package runconfig\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"strings\"\n\n\t\"github.com/hyperhq/hypercli/pkg/broadcaster\"\n\t\"github.com/hyperhq/hypercli/pkg/ioutils\"\n)\n\n\n\n\n\n\n\n\n\n\ntype StreamConfig struct {\n\tstdout    *broadcaster.Unbuffered\n\tstderr    *broadcaster.Unbuffered\n\tstdin     io.ReadCloser\n\tstdinPipe io.WriteCloser\n}\n\n\n\nfunc NewStreamConfig() *StreamConfig {\n\treturn &StreamConfig{\n\t\tstderr: new(broadcaster.Unbuffered),\n\t\tstdout: new(broadcaster.Unbuffered),\n\t}\n}\n\n\nfunc (streamConfig *StreamConfig) Stdout() *broadcaster.Unbuffered {\n\treturn streamConfig.stdout\n}\n\n\nfunc (streamConfig *StreamConfig) Stderr() *broadcaster.Unbuffered {\n\treturn streamConfig.stderr\n}\n\n\nfunc (streamConfig *StreamConfig) Stdin() io.ReadCloser {\n\treturn streamConfig.stdin\n}\n\n\nfunc (streamConfig *StreamConfig) StdinPipe() io.WriteCloser {\n\treturn streamConfig.stdinPipe\n}\n\n\n\nfunc (streamConfig *StreamConfig) StdoutPipe() io.ReadCloser {\n\tbytesPipe := ioutils.NewBytesPipe(nil)\n\tstreamConfig.stdout.Add(bytesPipe)\n\treturn bytesPipe\n}\n\n\n\nfunc (streamConfig *StreamConfig) StderrPipe() io.ReadCloser {\n\tbytesPipe := ioutils.NewBytesPipe(nil)\n\tstreamConfig.stderr.Add(bytesPipe)\n\treturn bytesPipe\n}\n\n\nfunc (streamConfig *StreamConfig) NewInputPipes() {\n\tstreamConfig.stdin, streamConfig.stdinPipe = io.Pipe()\n}\n\n\nfunc (streamConfig *StreamConfig) NewNopInputPipe() {\n\tstreamConfig.stdinPipe = ioutils.NopWriteCloser(ioutil.Discard)\n}\n\n\n\n\nfunc (streamConfig *StreamConfig) CloseStreams() error ", "output": "{\n\tvar errors []string\n\n\tif streamConfig.stdin != nil {\n\t\tif err := streamConfig.stdin.Close(); err != nil {\n\t\t\terrors = append(errors, fmt.Sprintf(\"error close stdin: %s\", err))\n\t\t}\n\t}\n\n\tif err := streamConfig.stdout.Clean(); err != nil {\n\t\terrors = append(errors, fmt.Sprintf(\"error close stdout: %s\", err))\n\t}\n\n\tif err := streamConfig.stderr.Clean(); err != nil {\n\t\terrors = append(errors, fmt.Sprintf(\"error close stderr: %s\", err))\n\t}\n\n\tif len(errors) > 0 {\n\t\treturn fmt.Errorf(strings.Join(errors, \"\\n\"))\n\t}\n\n\treturn nil\n}"}
{"input": "package memstats\n\nimport (\n\t\"github.com/mono83/slf\"\n\t\"sync\"\n)\n\n\n\nfunc New() *MemStats {\n\treturn &MemStats{\n\t\tvalues: map[string]int64{},\n\t}\n}\n\n\n\ntype MemStats struct {\n\tm sync.Mutex\n\n\tvalues map[string]int64\n}\n\n\n\n\n\nfunc (m *MemStats) Get(key string) (value int64, found bool) {\n\tm.m.Lock()\n\tdefer m.m.Unlock()\n\n\tvalue, found = m.values[key]\n\treturn\n}\n\n\nfunc (m *MemStats) Values() map[string]int64 {\n\tm.m.Lock()\n\tdefer m.m.Unlock()\n\n\tclone := make(map[string]int64, len(m.values))\n\tfor k, v := range m.values {\n\t\tclone[k] = v\n\t}\n\n\treturn clone\n}\n\nfunc (m *MemStats) Receive(e slf.Event) ", "output": "{\n\tif e.Type == slf.TypeInc {\n\t\tm.m.Lock()\n\t\tprev, _ := m.values[e.Content]\n\t\tm.values[e.Content] = prev + e.I64\n\t\tm.m.Unlock()\n\t} else if e.Type == slf.TypeGauge {\n\t\tm.m.Lock()\n\t\tm.values[e.Content] = e.I64\n\t\tm.m.Unlock()\n\t}\n}"}
{"input": "package auth_test\n\nimport (\n\t\"testing\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\n\n\nfunc TestAuth(t *testing.T) ", "output": "{\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Auth Suite\")\n}"}
{"input": "package leet_20\n\ntype Stack []byte\n\nfunc (s *Stack) Pop() byte {\n\tc := s.Top()\n\tlength := len(*s)\n\tif length <= 1 {\n\t\t*s = nil\n\t} else {\n\t\t*s = (*s)[:length-1]\n\t}\n\treturn c\n}\n\n\n\nfunc (s *Stack) Push(x byte) {\n\t*s = append(*s, x)\n}\n\nfunc (s *Stack) Top() byte {\n\tlength := len(*s)\n\tif 0 == length {\n\t\treturn 0\n\t}\n\treturn (*s)[length-1]\n}\n\nfunc (s *Stack) String() string {\n\treturn string(*s)\n}\n\nfunc match(a, b byte) bool {\n\tif a == '[' && b == ']' {\n\t\treturn true\n\t}\n\tif a == '(' && b == ')' {\n\t\treturn true\n\t}\n\tif a == '{' && b == '}' {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isValid(s string) bool {\n\tarr := []byte(s)\n\tstack := new(Stack)\n\tfor _, c := range arr {\n\t\tswitch c {\n\t\tcase '[', '{', '(':\n\t\t\tstack.Push(c)\n\t\t\tcontinue\n\t\t}\n\t\ttop := stack.Top()\n\t\tif match(top, c) {\n\t\t\tstack.Pop()\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn stack.Empty()\n}\n\nfunc (s *Stack) Empty() bool ", "output": "{\n\treturn nil == s || *s == nil || len(*s) == 0\n}"}
{"input": "package command\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/mitchellh/cli\"\n\t\"github.com/pragkent/aliyun-disk/volume\"\n)\n\n\nfunc TestUnmountCommand_Run(t *testing.T) {\n\tvar bu bytes.Buffer\n\tui := &cli.BasicUi{\n\t\tWriter: &bu,\n\t}\n\n\tmeta := &Meta{\n\t\tUi:     ui,\n\t\tDriver: volume.NewFakeDriver(),\n\t}\n\n\tcmd := &UnmountCommand{*meta}\n\n\ttests := []struct {\n\t\targs   []string\n\t\tresult int\n\t\tstatus volume.DriverStatus\n\t}{\n\t\t{\n\t\t\t[]string{\"/mnt/xx\"},\n\t\t\t1,\n\t\t\tvolume.DriverStatus{\n\t\t\t\tStatus:  volume.StatusNotSupported,\n\t\t\t\tMessage: \"command not supported\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tbu.Reset()\n\n\t\tif result := cmd.Run(tt.args); result != tt.result {\n\t\t\tt.Errorf(\"cmd.Run() == %d; want %d\", result, tt.result)\n\t\t}\n\n\t\tvar ds volume.DriverStatus\n\t\tif err := json.Unmarshal(bu.Bytes(), &ds); err != nil {\n\t\t\tt.Errorf(\"json.Unmarshal error. %v\", err)\n\t\t}\n\n\t\tif !reflect.DeepEqual(ds, tt.status) {\n\t\t\tt.Errorf(\"Status = %#v; want %#v\", ds, tt.status)\n\t\t}\n\t}\n}\n\nfunc TestUnmountCommand_Run_ArgsError(t *testing.T) ", "output": "{\n\tui := &cli.BasicUi{}\n\n\tmeta := &Meta{\n\t\tUi:     ui,\n\t\tDriver: volume.NewFakeDriver(),\n\t}\n\n\tcmd := &UnmountCommand{*meta}\n\n\ttests := []struct {\n\t\targs   []string\n\t\tresult int\n\t}{\n\t\t{[]string{}, cli.RunResultHelp},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif result := cmd.Run(tt.args); result != tt.result {\n\t\t\tt.Errorf(\"cmd.Run() == %d; want %d\", result, tt.result)\n\t\t}\n\t}\n\n}"}
{"input": "package get\n\n\n\n\nimport (\n\t\"time\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/runtime\"\n\tcr \"github.com/go-openapi/runtime/client\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n)\n\n\n\nfunc NewGetPollersParams() *GetPollersParams {\n\n\treturn &GetPollersParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}\n\n\n\nfunc NewGetPollersParamsWithTimeout(timeout time.Duration) *GetPollersParams {\n\n\treturn &GetPollersParams{\n\n\t\ttimeout: timeout,\n\t}\n}\n\n\ntype GetPollersParams struct {\n\ttimeout time.Duration\n}\n\n\n\n\nfunc (o *GetPollersParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error ", "output": "{\n\n\tr.SetTimeout(o.timeout)\n\tvar res []error\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package iso20022\n\n\ntype MarketType17Choice struct {\n\n\tCode *MarketType4Code `xml:\"Cd\"`\n\n\tProprietary *GenericIdentification47 `xml:\"Prtry\"`\n}\n\nfunc (m *MarketType17Choice) SetCode(value string) {\n\tm.Code = (*MarketType4Code)(&value)\n}\n\n\n\nfunc (m *MarketType17Choice) AddProprietary() *GenericIdentification47 ", "output": "{\n\tm.Proprietary = new(GenericIdentification47)\n\treturn m.Proprietary\n}"}
{"input": "package gensupport\n\nimport (\n\t\"io\"\n\t\"time\"\n)\n\n\ntype errReader struct {\n\tbuf []byte\n\terr error\n}\n\nfunc (er *errReader) Read(p []byte) (int, error) {\n\tif len(er.buf) == 0 {\n\t\tif er.err == nil {\n\t\t\treturn 0, io.EOF\n\t\t}\n\t\treturn 0, er.err\n\t}\n\tn := copy(p, er.buf)\n\ter.buf = er.buf[n:]\n\treturn n, nil\n}\n\n\ntype UniformPauseStrategy time.Duration\n\nfunc (p UniformPauseStrategy) Pause() (time.Duration, bool) { return time.Duration(p), true }\nfunc (p UniformPauseStrategy) Reset()                       {}\n\n\nconst NoPauseStrategy = UniformPauseStrategy(0)\n\n\ntype LimitRetryStrategy struct {\n\tMax      int\n\tStrategy BackoffStrategy\n\tn        int\n}\n\nfunc (l *LimitRetryStrategy) Pause() (time.Duration, bool) {\n\tl.n++\n\tif l.n > l.Max {\n\t\treturn 0, false\n\t}\n\treturn l.Strategy.Pause()\n}\n\n\n\nfunc (l *LimitRetryStrategy) Reset() ", "output": "{\n\tl.n = 0\n\tl.Strategy.Reset()\n}"}
{"input": "package main\n\ntype Session struct {\n\tseq     int32\n\tservers map[int32]int32 \n}\n\n\nfunc NewSession(server int) *Session {\n\ts := new(Session)\n\ts.servers = make(map[int32]int32, server)\n\ts.seq = 0\n\treturn s\n}\n\nfunc (s *Session) nextSeq() int32 {\n\ts.seq++\n\treturn s.seq\n}\n\n\n\n\nfunc (s *Session) Servers() (seqs []int32, servers []int32) {\n\tvar (\n\t\ti           = len(s.servers)\n\t\tseq, server int32\n\t)\n\tseqs = make([]int32, i)\n\tservers = make([]int32, i)\n\tfor seq, server = range s.servers {\n\t\ti--\n\t\tseqs[i] = seq\n\t\tservers[i] = server\n\t}\n\treturn\n}\n\n\nfunc (s *Session) Del(seq int32) bool {\n\tdelete(s.servers, seq)\n\treturn (len(s.servers) == 0)\n}\n\nfunc (s *Session) Size() int {\n\treturn len(s.servers)\n}\n\nfunc (s *Session) Put(server int32) (seq int32) ", "output": "{\n\tseq = s.nextSeq()\n\ts.servers[seq] = server\n\treturn\n}"}
{"input": "package photo\n\nimport (\n\t\"github.com/golang/glog\"\n\t\"github.com/nebulaim/telegramd/baselib/base\"\n\t\"github.com/nebulaim/telegramd/baselib/mysql_client\"\n\t\"github.com/nebulaim/telegramd/service/document/biz/dal/dao/mysql_dao\"\n\t\"github.com/nebulaim/telegramd/service/idgen/client\"\n)\n\ntype photosDAO struct {\n\t*mysql_dao.PhotoDatasDAO\n\tidgen.UUIDGen\n}\n\ntype PhotoModel struct {\n\tdao *photosDAO\n}\n\n\n\nfunc NewPhotoModel(serverId int32, dbName, redisName string) *PhotoModel ", "output": "{\n\tm := &PhotoModel{dao: &photosDAO{}}\n\tdb := mysql_client.GetMysqlClient(dbName)\n\tif db == nil {\n\t\tglog.Fatal(\"not found db: \", dbName)\n\t}\n\n\tm.dao.PhotoDatasDAO = mysql_dao.NewPhotoDatasDAO(db)\n\n\tvar err error\n\tm.dao.UUIDGen, err = idgen.NewUUIDGen(\"snowflake\", base.Int32ToString(serverId))\n\tif err != nil {\n\t\tglog.Fatal(\"uuidgen init error: \", err)\n\t}\n\treturn m\n}"}
{"input": "package gce\n\nimport (\n\t\"context\"\n\n\t\"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud\"\n\t\"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud/meta\"\n)\n\n\ntype gceProjectRouter struct {\n\tgce *Cloud\n}\n\n\nfunc (r *gceProjectRouter) ProjectID(ctx context.Context, version meta.Version, service string) string {\n\tswitch service {\n\tcase \"Firewalls\", \"Routes\":\n\t\treturn r.gce.NetworkProjectID()\n\tdefault:\n\t\treturn r.gce.projectID\n\t}\n}\n\n\ntype gceRateLimiter struct {\n\tgce *Cloud\n}\n\n\n\n\n\n\nfunc (l *gceRateLimiter) Accept(ctx context.Context, key *cloud.RateLimitKey) error {\n\tif key.Operation == \"Get\" && key.Service == \"Operations\" {\n\t\trl := &cloud.MinimumRateLimiter{\n\t\t\tRateLimiter: &cloud.AcceptRateLimiter{\n\t\t\t\tAcceptor: l.gce.operationPollRateLimiter,\n\t\t\t},\n\t\t\tMinimum: operationPollInterval,\n\t\t}\n\t\treturn rl.Accept(ctx, key)\n\t}\n\treturn nil\n}\n\n\n\n\n\n\nfunc CreateGCECloudWithCloud(config *CloudConfig, c cloud.Cloud) (*Cloud, error) ", "output": "{\n\tgceCloud, err := CreateGCECloud(config)\n\tif err == nil {\n\t\tgceCloud.c = c\n\t}\n\treturn gceCloud, err\n}"}
{"input": "package termhook\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\n\n\nfunc addTerminatingSignals(c chan<- os.Signal) ", "output": "{\n\tsignal.Notify(c, os.Interrupt)\n\tsignal.Notify(c, syscall.SIGTERM)\n}"}
{"input": "package forms\n\nimport (\n\t\"bones/validation\"\n)\n\ntype LoginForm struct {\n\tCsrfToken string `schema:\"CsrfToken\"`\n\tEmail     string `schema:\"email\"`\n\tPassword  string `schema:\"password\"`\n}\n\n\n\nfunc (f *LoginForm) Validate() error ", "output": "{\n\tvalidate := validation.New()\n\n\tvalidate.String(f.Email).NotEmpty(\"Email cannot be blank\")\n\tvalidate.String(f.Password).NotEmpty(\"Password cannot be blank\")\n\n\treturn validate.Result()\n}"}
{"input": "package cluster\n\nimport (\n\t\"encoding/binary\"\n\t\"os\"\n)\n\ntype stateFile struct {\n\tHandle    *os.File\n\tName      string\n\tCount     int32\n\tTimestamp int64\n}\n\nfunc newStateFile(name string) *stateFile {\n\tsf := new(stateFile)\n\tsf.Name = name\n\treturn sf\n}\n\nfunc (sf *stateFile) access() error {\n\tvar err error\n\tsf.Handle, err = os.OpenFile(sf.Name, os.O_RDWR|os.O_CREATE, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (sf *stateFile) write() error {\n\terr := sf.Handle.Truncate(0)\n\tsf.Handle.Seek(0, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = binary.Write(sf.Handle, binary.LittleEndian, sf.Count)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = binary.Write(sf.Handle, binary.LittleEndian, sf.Timestamp)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\n\nfunc (sf *stateFile) read() error ", "output": "{\n\tsf.Handle.Seek(0, 0)\n\terr := binary.Read(sf.Handle, binary.LittleEndian, &sf.Count)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = binary.Read(sf.Handle, binary.LittleEndian, &sf.Timestamp)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package wikifier\n\ntype clearBlock struct {\n\t*parserBlock\n}\n\nfunc newClearBlock(name string, b *parserBlock) block {\n\treturn &clearBlock{parserBlock: b}\n}\n\n\n\nfunc (b *clearBlock) html(page *Page, el element) ", "output": "{\n\tel.addClass(\"clear\")\n}"}
{"input": "package handlers\n\nimport (\n\t\"github.com/bbiskup/edify-web/defs\"\n\t\"html/template\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar indexTemplates *template.Template\n\n\n\nfunc Index(w http.ResponseWriter, r *http.Request) {\n\terr := indexTemplates.ExecuteTemplate(w, \"layout\", nil)\n\tif err != nil {\n\t\tlog.Printf(\"Error executing template: %s\", err)\n\t}\n}\n\nfunc init() ", "output": "{\n\tindexTemplates = template.Must(template.ParseFiles(\n\t\tdefs.TemplatePaths(\"layout.html\", \"navbar.html\", \"index.html\")...,\n\t))\n}"}
{"input": "package exchange\n\nimport (\n\t\"os\"\n\n\t\"github.com/WICG/webpackage/go/signedexchange\"\n)\n\n\n\n\nfunc ReadExchangeFile(filename string) (*signedexchange.Exchange, error) ", "output": "{\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\treturn signedexchange.ReadExchange(f)\n}"}
{"input": "package time\n\nimport (\n\t\"syscall\"\n\t\"testing\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/unix\"\n\t\"gvisor.dev/gvisor/pkg/abi/linux\"\n)\n\n\n\nfunc TestClockGetTimeEINVAL(t *testing.T) {\n\tts := unix.Timespec{}\n\tif ret := vdsoClockGettime(-1, &ts); ret != -int(syscall.EINVAL) {\n\t\tt.Fatalf(\"Unexpected error code: %v\", ret)\n\t}\n}\n\nfunc TestClockGetTime(t *testing.T) ", "output": "{\n\tts := unix.Timespec{}\n\tif ret := vdsoClockGettime(linux.CLOCK_MONOTONIC, &ts); ret != 0 {\n\t\tt.Fatalf(\"Unexpected error code: %v\", ret)\n\t}\n\tsts := unix.Timespec{}\n\tif _, _, errno := unix.RawSyscall(unix.SYS_CLOCK_GETTIME,\n\t\tuintptr(linux.CLOCK_MONOTONIC),\n\t\tuintptr(unsafe.Pointer(&sts)), 0); errno != 0 {\n\t\tt.Fatalf(\"Unexpected error code: %v\", errno)\n\t}\n\tif sts.Sec < ts.Sec || sts.Sec > ts.Sec+5 {\n\t\tt.Fatalf(\"Unexpected delta: vdso %+v syscall %+v\", ts, sts)\n\t}\n}"}
{"input": "package runtime_data_area\n\nimport \"github.com/Frederick-S/jvmgo/runtime_data_area/heap\"\n\ntype Thread struct {\n\tpc       int\n\tjvmStack *JVMStack\n}\n\nfunc NewThread() *Thread {\n\treturn &Thread{\n\t\tjvmStack: newJVMStack(1024),\n\t}\n}\n\nfunc (thread *Thread) GetPC() int {\n\treturn thread.pc\n}\n\nfunc (thread *Thread) SetPC(pc int) {\n\tthread.pc = pc\n}\n\nfunc (thread *Thread) PushFrame(frame *Frame) {\n\tthread.jvmStack.PushFrame(frame)\n}\n\nfunc (thread *Thread) PopFrame() *Frame {\n\treturn thread.jvmStack.PopFrame()\n}\n\nfunc (thread *Thread) GetCurrentFrame() *Frame {\n\treturn thread.jvmStack.GetTopFrame()\n}\n\nfunc (thread *Thread) GetTopFrame() *Frame {\n\treturn thread.jvmStack.GetTopFrame()\n}\n\nfunc (thread *Thread) GetFrames() []*Frame {\n\treturn thread.jvmStack.GetFrames()\n}\n\nfunc (thread *Thread) NewFrame(method *heap.Method) *Frame {\n\treturn newFrame(thread, method)\n}\n\nfunc (thread *Thread) IsJVMStackEmpty() bool {\n\treturn thread.jvmStack.IsEmpty()\n}\n\n\n\nfunc (thread *Thread) ClearStack() ", "output": "{\n\tthread.jvmStack.Clear()\n}"}
{"input": "package console\n\nimport (\n\t\"github.com/cgrates/cgrates/engine\"\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\nfunc init() {\n\tc := &CmdGetAttributes{\n\t\tname:      \"attributes\",\n\t\trpcMethod: utils.APIerSv1GetAttributeProfile,\n\t\trpcParams: &utils.TenantID{},\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}\n\n\ntype CmdGetAttributes struct {\n\tname      string\n\trpcMethod string\n\trpcParams *utils.TenantID\n\t*CommandExecuter\n}\n\nfunc (self *CmdGetAttributes) Name() string {\n\treturn self.name\n}\n\n\n\nfunc (self *CmdGetAttributes) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &utils.TenantID{}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *CmdGetAttributes) PostprocessRpcParams() error {\n\treturn nil\n}\n\nfunc (self *CmdGetAttributes) RpcResult() interface{} {\n\tvar atr engine.AttributeProfile\n\treturn &atr\n}\n\nfunc (self *CmdGetAttributes) RpcMethod() string ", "output": "{\n\treturn self.rpcMethod\n}"}
{"input": "package sftp\n\n\n\n\nimport \"os\"\n\n\n\ntype FileOpenFlags struct {\n\tRead, Write, Append, Creat, Trunc, Excl bool\n}\n\nfunc newFileOpenFlags(flags uint32) FileOpenFlags {\n\treturn FileOpenFlags{\n\t\tRead:   flags&ssh_FXF_READ != 0,\n\t\tWrite:  flags&ssh_FXF_WRITE != 0,\n\t\tAppend: flags&ssh_FXF_APPEND != 0,\n\t\tCreat:  flags&ssh_FXF_CREAT != 0,\n\t\tTrunc:  flags&ssh_FXF_TRUNC != 0,\n\t\tExcl:   flags&ssh_FXF_EXCL != 0,\n\t}\n}\n\n\n\nfunc (r *Request) Pflags() FileOpenFlags {\n\treturn newFileOpenFlags(r.Flags)\n}\n\n\n\n\ntype FileAttrFlags struct {\n\tSize, UidGid, Permissions, Acmodtime bool\n}\n\nfunc newFileAttrFlags(flags uint32) FileAttrFlags {\n\treturn FileAttrFlags{\n\t\tSize:        (flags & ssh_FILEXFER_ATTR_SIZE) != 0,\n\t\tUidGid:      (flags & ssh_FILEXFER_ATTR_UIDGID) != 0,\n\t\tPermissions: (flags & ssh_FILEXFER_ATTR_PERMISSIONS) != 0,\n\t\tAcmodtime:   (flags & ssh_FILEXFER_ATTR_ACMODTIME) != 0,\n\t}\n}\n\n\n\nfunc (r *Request) AttrFlags() FileAttrFlags {\n\treturn newFileAttrFlags(r.Flags)\n}\n\n\n\n\n\n\nfunc (r *Request) Attributes() *FileStat {\n\tfs, _ := getFileStat(r.Flags, r.Attrs)\n\treturn fs\n}\n\nfunc (a FileStat) FileMode() os.FileMode ", "output": "{\n\treturn os.FileMode(a.Mode)\n}"}
{"input": "package tartest\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\tupTar \"archive/tar\"\n\n\tourTar \"github.com/vbatts/tar-split/archive/tar\"\n)\n\nvar testfile = \"./archive/tar/testdata/sparse-formats.tar\"\n\nfunc BenchmarkUpstreamTar(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tfh, err := os.Open(testfile)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\ttr := upTar.NewReader(fh)\n\t\tfor {\n\t\t\t_, err := tr.Next()\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfh.Close()\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tio.Copy(ioutil.Discard, tr)\n\t\t}\n\t\tfh.Close()\n\t}\n}\n\nfunc BenchmarkOurTarNoAccounting(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tfh, err := os.Open(testfile)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\ttr := ourTar.NewReader(fh)\n\t\ttr.RawAccounting = false \n\t\tfor {\n\t\t\t_, err := tr.Next()\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfh.Close()\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tio.Copy(ioutil.Discard, tr)\n\t\t}\n\t\tfh.Close()\n\t}\n}\n\n\nfunc BenchmarkOurTarYesAccounting(b *testing.B) ", "output": "{\n\tfor n := 0; n < b.N; n++ {\n\t\tfh, err := os.Open(testfile)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\ttr := ourTar.NewReader(fh)\n\t\ttr.RawAccounting = true \n\t\tfor {\n\t\t\t_ = tr.RawBytes()\n\t\t\t_, err := tr.Next()\n\t\t\t_ = tr.RawBytes()\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfh.Close()\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tio.Copy(ioutil.Discard, tr)\n\t\t\t_ = tr.RawBytes()\n\t\t}\n\t\tfh.Close()\n\t}\n}"}
{"input": "package database\n\nimport (\n\t\"os\"\n\t\"testing\"\n)\n\nvar db DB\n\n\n\nfunc TestMain(m *testing.M) ", "output": "{\n\tldb, err := DBConn(\"postgres\", \"postgres\", \"testuser\", \"testpassword\")\n\tif err != nil {\n\t\tpanic(\"Error creating database connection: \" + err.Error())\n\t}\n\n\tdb = ldb\n\t_, err = db.Exec(\"TRUNCATE users, readings\")\n\tif err != nil {\n\t\tpanic(\"Coudn't connect to table! \" + err.Error())\n\t}\n\n\tos.Exit(m.Run())\n}"}
{"input": "package tests\n\nimport (\n\t\"go2o/core/infrastructure/domain\"\n\t\"testing\"\n)\n\n\n\n\nfunc TestMasterPwd2(t *testing.T) {\n\tuser := \"master\"\n\tpwd := \"fs888888@txxfmall\"\n\tsha1 := domain.Sha1(domain.Md5(pwd) + user + domain.Sha1OffSet)\n\tt.Log(sha1)\n\tt.Log(domain.Sha1OffSet)\n}\n\nfunc TestMemberPwd(t *testing.T) {\n\tpwd := domain.Md5(\"594488\")\n\tt.Log(\"--pwd=\", pwd, \"\\n\")\n\tpwd = domain.Sha1(pwd)\n\tt.Log(\"--pwd=\", pwd, \"\\n\")\n}\n\n\nfunc TestMerchantPwd(t *testing.T) {\n\tpwd := \"123456\"\n\tencPwd := domain.MerchantSha1Pwd(pwd)\n\tt.Log(encPwd)\n}\n\nfunc TestMasterPwd(t *testing.T) ", "output": "{\n\tuser := \"master\"\n\tpwd := \"123456\"\n\tsha1 := domain.Sha1(domain.Md5(pwd) + user + domain.Sha1OffSet)\n\tt.Log(sha1)\n}"}
{"input": "package md5_test\n\nimport (\n\t\"io/ioutil\"\n\t\"testing\"\n\n\t\"github.com/ujanssen/learning-go-lang/md5\"\n)\n\nfunc report(got, want string, t *testing.T) {\n\tif want != got {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc testMd5(in, want string, t *testing.T) {\n\treport(md5.HashString(in), want, t)\n\n\twriteToFile(want, in)\n\tgot, _ := md5.HashFile(want)\n\treport(got, want, t)\n}\n\nfunc writeToFile(file, s string) {\n\tioutil.WriteFile(file, []byte(s), 0666)\n}\n\nconst text string = \" jagt im komplett verwahrlosten Taxi quer durch Bayern\"\n\nfunc TestFranz(t *testing.T) {\n\ttestMd5(\"Franz\"+text, \"a3cca2b2aa1e3b5b3b5aad99a8529074\", t)\n}\n\n\n\nfunc TestEmpty(t *testing.T) {\n\ttestMd5(\"\", \"d41d8cd98f00b204e9800998ecf8427e\", t)\n}\n\nfunc TestFrank(t *testing.T) ", "output": "{\n\ttestMd5(\"Frank\"+text, \"7e716d0e702df0505fc72e2b89467910\", t)\n}"}
{"input": "package virtcontainers\n\nimport (\n\t\"runtime\"\n\n\tgovmmQemu \"github.com/intel/govmm/qemu\"\n)\n\ntype qemuArm64 struct {\n\tqemuArchBase\n}\n\nconst defaultQemuPath = \"/usr/bin/qemu-system-aarch64\"\n\nconst defaultQemuMachineType = QemuVirt\n\nconst defaultQemuMachineOptions = \"gic-version=host,usb=off,accel=kvm\"\n\nvar qemuPaths = map[string]string{\n\tQemuVirt: defaultQemuPath,\n}\n\nvar kernelParams = []Param{\n\t{\"console\", \"ttyAMA0\"},\n\t{\"iommu.passthrough\", \"0\"},\n}\n\nvar kernelRootParams = []Param{\n\t{\"root\", \"/dev/vda1\"},\n}\n\nvar supportedQemuMachines = []govmmQemu.Machine{\n\t{\n\t\tType:    QemuVirt,\n\t\tOptions: defaultQemuMachineOptions,\n\t},\n}\n\n\nfunc maxQemuVCPUs() uint32 {\n\treturn uint32(runtime.NumCPU())\n}\n\n\n\nfunc newQemuArch(config HypervisrConfig) qemuArch ", "output": "{\n\tmachineType := config.HypervisorMachineType\n\tif machineType == \"\" {\n\t\tmachineType = defaultQemuMachineType\n\t}\n\n\tq := &qemuArm64{\n\t\tqemuArchBase{\n\t\t\tmachineType:           machineType,\n\t\t\tqemuPaths:             qemuPaths,\n\t\t\tsupportedQemuMachines: supportedQemuMachines,\n\t\t\tkernelParamsNonDebug:  kernelParamsNonDebug,\n\t\t\tkernelParamsDebug:     kernelParamsDebug,\n\t\t\tkernelParams:          kernelParams,\n\t\t},\n\t}\n\n\tif config.ImagePath != \"\" {\n\t\tq.kernelParams = append(q.kernelParams, kernelRootParams...)\n\t\tq.kernelParamsNonDebug = append(q.kernelParamsNonDebug, kernelParamsSystemdNonDebug...)\n\t\tq.kernelParamsDebug = append(q.kernelParamsDebug, kernelParamsSystemdDebug...)\n\t}\n\n\treturn q\n}"}
{"input": "package user\n\nimport (\n\t\"errors\"\n\n\t. \"github.com/1ambda/gokit-waffle/waffle-server/service/common\"\n\t\"github.com/1ambda/gokit-waffle/waffle-server/service/number\"\n)\n\ntype UserService interface {\n\tUsers() []User\n\tUser(string) (int, error)\n}\n\ntype service struct {\n\trepository number.NumberRepository\n}\n\n\n\nfunc (svc *service) Users() []User {\n\tvar users []User\n\n\tfor _, subs := range svc.repository.FindAll() {\n\t\tusers = append(users, subs.User)\n\t}\n\n\treturn users\n}\n\nfunc (svc service) User(u string) (int, error) {\n\tif u == \"\" {\n\t\treturn 0, errors.New(\"Empty `user`\")\n\t}\n\n\tuser := User(u)\n\tsubs, err := svc.repository.Find(user)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn subs.GetNumber(), err\n}\n\nfunc NewUserService(r number.NumberRepository) UserService ", "output": "{\n\treturn &service{repository: r}\n}"}
{"input": "package tccpoutputs\n\nimport \"github.com/giantswarm/microerror\"\n\nvar invalidConfigError = &microerror.Error{\n\tKind: \"invalidConfigError\",\n}\n\n\n\n\nfunc IsInvalidConfig(err error) bool ", "output": "{\n\treturn microerror.Cause(err) == invalidConfigError\n}"}
{"input": "package parser\n\nimport (\n\t\"github.com/dop251/goja/ast\"\n)\n\ntype _scope struct {\n\touter           *_scope\n\tallowIn         bool\n\tinIteration     bool\n\tinSwitch        bool\n\tinFunction      bool\n\tdeclarationList []ast.Declaration\n\n\tlabels []string\n}\n\nfunc (self *_parser) openScope() {\n\tself.scope = &_scope{\n\t\touter:   self.scope,\n\t\tallowIn: true,\n\t}\n}\n\n\n\nfunc (self *_scope) declare(declaration ast.Declaration) {\n\tself.declarationList = append(self.declarationList, declaration)\n}\n\nfunc (self *_scope) hasLabel(name string) bool {\n\tfor _, label := range self.labels {\n\t\tif label == name {\n\t\t\treturn true\n\t\t}\n\t}\n\tif self.outer != nil && !self.inFunction {\n\t\treturn self.outer.hasLabel(name)\n\t}\n\treturn false\n}\n\nfunc (self *_parser) closeScope() ", "output": "{\n\tself.scope = self.scope.outer\n}"}
{"input": "package statushistorypruner\n\nimport (\n\t\"time\"\n\n\t\"github.com/juju/errors\"\n\n\t\"github.com/juju/juju/state\"\n\t\"github.com/juju/juju/worker\"\n)\n\n\ntype HistoryPrunerParams struct {\n\tMaxLogsPerState int\n\tPruneInterval   time.Duration\n}\n\nconst DefaultMaxLogsPerState = 100\nconst DefaultPruneInterval = 5 * time.Minute\n\n\n\n\ntype pruneHistoryFunc func(*state.State, int) error\n\ntype pruneWorker struct {\n\tst     *state.State\n\tparams *HistoryPrunerParams\n\tpruner pruneHistoryFunc\n}\n\n\nfunc New(st *state.State, params *HistoryPrunerParams) worker.Worker {\n\tw := &pruneWorker{\n\t\tst:     st,\n\t\tparams: params,\n\t\tpruner: state.PruneStatusHistory,\n\t}\n\treturn worker.NewPeriodicWorker(w.doPruning, w.params.PruneInterval, worker.NewTimer)\n}\n\nfunc (w *pruneWorker) doPruning(stop <-chan struct{}) error {\n\terr := w.pruner(w.st, w.params.MaxLogsPerState)\n\tif err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\treturn nil\n}\n\nfunc NewHistoryPrunerParams() *HistoryPrunerParams ", "output": "{\n\treturn &HistoryPrunerParams{\n\t\tMaxLogsPerState: DefaultMaxLogsPerState,\n\t\tPruneInterval:   DefaultPruneInterval,\n\t}\n}"}
{"input": "package router\n\nimport (\n\t\"sync/atomic\"\n\n\t\"github.com/AsynkronIT/protoactor-go/actor\"\n)\n\ntype roundRobinGroupRouter struct {\n\tGroupRouter\n}\n\ntype roundRobinPoolRouter struct {\n\tPoolRouter\n}\n\ntype roundRobinState struct {\n\tindex   int32\n\troutees *actor.PIDSet\n\tvalues  []actor.PID\n}\n\nfunc (state *roundRobinState) SetRoutees(routees *actor.PIDSet) {\n\tstate.routees = routees\n\tstate.values = routees.Values()\n}\n\nfunc (state *roundRobinState) GetRoutees() *actor.PIDSet {\n\treturn state.routees\n}\n\nfunc (state *roundRobinState) RouteMessage(message interface{}, sender *actor.PID) {\n\tpid := roundRobinRoutee(&state.index, state.values)\n\tpid.Request(message, sender)\n}\n\nfunc NewRoundRobinPool(size int) *actor.Props {\n\treturn actor.FromSpawnFunc(spawner(&roundRobinPoolRouter{PoolRouter{PoolSize: size}}))\n}\n\n\n\nfunc (config *roundRobinPoolRouter) CreateRouterState() Interface {\n\treturn &roundRobinState{}\n}\n\nfunc (config *roundRobinGroupRouter) CreateRouterState() Interface {\n\treturn &roundRobinState{}\n}\n\nfunc roundRobinRoutee(index *int32, routees []actor.PID) actor.PID {\n\ti := int(atomic.AddInt32(index, 1))\n\tif i < 0 {\n\t\t*index = 0\n\t\ti = 0\n\t}\n\tmod := len(routees)\n\troutee := routees[i%mod]\n\treturn routee\n}\n\nfunc NewRoundRobinGroup(routees ...*actor.PID) *actor.Props ", "output": "{\n\treturn actor.FromSpawnFunc(spawner(&roundRobinGroupRouter{GroupRouter{Routees: actor.NewPIDSet(routees...)}}))\n}"}
{"input": "package service\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"log\"\n)\n\n\ntype Service struct {\n\tURL         string\n\tDNSName     string\n\tSecure      bool\n\tForceTLS    bool\n\tEncodedCert string\n\tEncodedKey  string\n\tparsedCert  tls.Certificate\n}\n\n\n\n\n\nfunc (s *Service) ParseCertificate() bool {\n\tif !s.Secure {\n\t\treturn false\n\t}\n\n\tparsedCert, err := tls.X509KeyPair([]byte(s.EncodedCert), []byte(s.EncodedKey))\n\tif err != nil {\n\t\tlog.Printf(\"Failed to parse certificate for %s\", s.DNSName)\n\t\treturn false\n\t}\n\n\ts.parsedCert = parsedCert\n\treturn true\n}\n\n\nfunc NewService(name string, port int, dnsName string, secure bool, forceTLS bool, encodedCert string, encodedKey string) Service {\n\turl := fmt.Sprintf(\"%s:%d\", name, port)\n\treturn Service{\n\t\tURL:         url,\n\t\tDNSName:     dnsName,\n\t\tSecure:      secure,\n\t\tForceTLS:    forceTLS,\n\t\tEncodedCert: encodedCert,\n\t\tEncodedKey:  encodedKey,\n\t}\n}\n\nfunc (s Service) Certificate() tls.Certificate ", "output": "{\n\treturn s.parsedCert\n}"}
{"input": "package main\n\nimport \"testing\"\n\nfunc TestSum(t *testing.T) {\n\ttype args struct {\n\t\tnumbers []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"foo\",\n\t\t\targs: args{\n\t\t\t\tnumbers: []int{1, 2},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Sum(tt.args.numbers...); got != tt.want {\n\t\t\t\tt.Errorf(\"Sum() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkSum(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSum(foo...)\n\t}\n}\n\n\n\nfunc BenchmarkSumParallel(b *testing.B) ", "output": "{\n\tfor i := 0; i < b.N; i++ {\n\t\tSumParallel(foo...)\n\t}\n}"}
{"input": "package options\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/spf13/pflag\"\n\tkclientcmd \"k8s.io/client-go/tools/clientcmd\"\n)\n\n\n\n\n\ntype FlagInfo kclientcmd.FlagInfo\n\n\n\n\n\nfunc (i FlagInfo) BindBoolFlag(flags *pflag.FlagSet, target *bool) {\n\tkclientcmd.FlagInfo(i).BindBoolFlag(flags, target)\n}\n\n\nfunc (i FlagInfo) BindIntFlag(flags *pflag.FlagSet, target *int) {\n\tif len(i.LongName) > 0 {\n\t\tintVal, _ := strconv.ParseInt(i.Default, 10, 0)\n\t\tflags.IntVarP(target, i.LongName, i.ShortName, int(intVal), i.Description)\n\t}\n}\n\n\n\n\nfunc (i FlagInfo) BindListFlag(flags *pflag.FlagSet, target *[]string) {\n\tif len(i.LongName) > 0 {\n\t\tflags.StringSliceVarP(target, i.LongName, i.ShortName, *target, i.Description)\n\t}\n}\n\n\nconst (\n\tFlagMasterConfigName        = \"master-config\"\n\tFlagNodeConfigName          = \"node-config\"\n\tFlagClusterContextName      = \"cluster-context\"\n\tFlagLevelName               = \"diaglevel\"\n\tFlagIsHostName              = \"host\"\n\tFlagPreventModificationName = \"prevent-modification\"\n)\n\nfunc (i FlagInfo) BindStringFlag(flags *pflag.FlagSet, target *string) ", "output": "{\n\tkclientcmd.FlagInfo(i).BindStringFlag(flags, target)\n}"}
{"input": "package executor\n\nimport (\n\t\"github.com/mesos/mesos-go/mesosproto\"\n\t\"github.com/stretchr/testify/mock\"\n)\n\n\ntype MockedExecutor struct {\n\tmock.Mock\n}\n\n\nfunc NewMockedExecutor() *MockedExecutor {\n\treturn &MockedExecutor{}\n}\n\n\nfunc (e *MockedExecutor) Registered(ExecutorDriver, *mesosproto.ExecutorInfo, *mesosproto.FrameworkInfo, *mesosproto.SlaveInfo) {\n\te.Called()\n}\n\n\nfunc (e *MockedExecutor) Reregistered(ExecutorDriver, *mesosproto.SlaveInfo) {\n\te.Called()\n}\n\n\n\n\n\nfunc (e *MockedExecutor) LaunchTask(ExecutorDriver, *mesosproto.TaskInfo) {\n\te.Called()\n}\n\n\nfunc (e *MockedExecutor) KillTask(ExecutorDriver, *mesosproto.TaskID) {\n\te.Called()\n}\n\n\nfunc (e *MockedExecutor) FrameworkMessage(ExecutorDriver, string) {\n\te.Called()\n}\n\n\nfunc (e *MockedExecutor) Shutdown(ExecutorDriver) {\n\te.Called()\n}\n\n\nfunc (e *MockedExecutor) Error(ExecutorDriver, string) {\n\te.Called()\n}\n\nfunc (e *MockedExecutor) Disconnected(ExecutorDriver) ", "output": "{\n\te.Called()\n}"}
{"input": "package rm\n\nvar commands = make([]Command, 0)\nvar moduleTypes = make([]DataType, 0)\n\n\nfunc getDataType(id int) *DataType {\n\treturn &moduleTypes[id]\n}\nfunc commandId(cmd Command) int {\n\tid := len(commands)\n\tcommands = append(commands, cmd)\n\treturn id\n}\n\nfunc dataTypeId(mt DataType) int {\n\tid := len(moduleTypes)\n\tmoduleTypes = append(moduleTypes, mt)\n\treturn id\n}\n\nfunc getCommand(id int) *Command ", "output": "{\n\treturn &commands[id]\n}"}
{"input": "package sys\n\n\nimport \"C\"\nimport (\n\t\"syscall\"\n\t\"unsafe\"\n)\n\n\ntype Winsize C.struct_winsize\n\n\n\n\n\nfunc GetWinsize(fd int) Winsize ", "output": "{\n\tvar ws Winsize\n\tIoctl(fd, syscall.TIOCGWINSZ, uintptr(unsafe.Pointer(&ws)))\n\treturn ws\n}"}
{"input": "package spark\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nvar httpClient *http.Client\n\nfunc init() {\n\thttpClient = &http.Client{}\n}\n\nfunc (s *Spark) request(req *http.Request) ([]byte, error) {\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", s.token))\n\treq.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\n\tres, err := httpClient.Do(req)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\tbs, err := ioutil.ReadAll(res.Body)\n\n\tif res.StatusCode != http.StatusOK {\n\t\tif res.StatusCode != 204 {\n\t\t\te := fmt.Sprintf(\"HTTP Status Code: %d\\n%s\", res.StatusCode, string(bs))\n\t\t\treturn nil, errors.New(e)\n\t\t}\n\t}\n\n\treturn bs, err\n}\n\nfunc (s *Spark) GetRequest(url string, uv *url.Values) ([]byte, error) {\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif uv != nil {\n\t\treq.URL.RawQuery = (*uv).Encode()\n\t}\n\treturn s.request(req)\n}\n\n\n\nfunc (s *Spark) DeleteRequest(url string) ([]byte, error) {\n\tfmt.Println(\"Delete url: \", url)\n\treq, err := http.NewRequest(\"DELETE\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.request(req)\n}\n\nfunc (s *Spark) PostRequest(url string, body *bytes.Buffer) ([]byte, error) ", "output": "{\n\treq, err := http.NewRequest(\"POST\", url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.request(req)\n}"}
{"input": "package common\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\nconst BACKEND_NIL = \"_nothing_\"\n\nvar Backend = NewDriver()\n\nfunc NewDriver() Driver {\n\treturn Driver{make(map[string]IBackend)}\n}\n\ntype Driver struct {\n\tds map[string]IBackend\n}\n\nfunc (d *Driver) Register(name string, driver IBackend) {\n\tif driver == nil {\n\t\tpanic(\"backend: register invalid nil backend\")\n\t}\n\tif d.ds[name] != nil {\n\t\tpanic(\"backend: register already exist\")\n\t}\n\td.ds[name] = driver\n}\n\nfunc (d *Driver) Get(name string) IBackend {\n\tb := d.ds[name]\n\tif b == nil || name == BACKEND_NIL {\n\t\treturn Nothing{}\n\t}\n\treturn b\n}\n\nfunc (d *Driver) Drivers() map[string]IBackend {\n\treturn d.ds\n}\n\ntype Nothing struct {}\nfunc (b Nothing) Init(params map[string]string, app *App) (IBackend, error) {\n\treturn &Nothing{}, nil\n}\nfunc (b Nothing) Ls(path string) ([]os.FileInfo, error) {\n\treturn nil, NewError(\"\", 401)\n}\nfunc (b Nothing) Cat(path string) (io.ReadCloser, error) {\n\treturn NewReadCloserFromReader(strings.NewReader(\"\")), NewError(\"\", 401)\n}\nfunc (b Nothing) Mkdir(path string) error {\n\treturn NewError(\"\", 401)\n}\nfunc (b Nothing) Rm(path string) error {\n\treturn NewError(\"\", 401)\n}\nfunc (b Nothing) Mv(from string, to string) error {\n\treturn NewError(\"\", 401)\n}\nfunc (b Nothing) Touch(path string) error {\n\treturn NewError(\"\", 401)\n}\n\nfunc (b Nothing) LoginForm() Form {\n\treturn Form{}\n}\n\nfunc (b Nothing) Save(path string, file io.Reader) error ", "output": "{\n\treturn NewError(\"\", 401)\n}"}
{"input": "package subtle \n\nimport \"unsafe\"\n\n\n\nfunc AnyOverlap(x, y []byte) bool {\n\treturn len(x) > 0 && len(y) > 0 &&\n\t\tuintptr(unsafe.Pointer(&x[0])) <= uintptr(unsafe.Pointer(&y[len(y)-1])) &&\n\t\tuintptr(unsafe.Pointer(&y[0])) <= uintptr(unsafe.Pointer(&x[len(x)-1]))\n}\n\n\n\n\n\n\n\n\n\nfunc InexactOverlap(x, y []byte) bool ", "output": "{\n\tif len(x) == 0 || len(y) == 0 || &x[0] == &y[0] {\n\t\treturn false\n\t}\n\treturn AnyOverlap(x, y)\n}"}
{"input": "package upgrades\n\n\n\n\nfunc stateStepsFor236() []Step ", "output": "{\n\treturn []Step{\n\t\t&upgradeStep{\n\t\t\tdescription: \"ensure container-image-stream config defaults to released\",\n\t\t\ttargets:     []Target{DatabaseMaster},\n\t\t\trun: func(context Context) error {\n\t\t\t\treturn context.State().EnsureContainerImageStreamDefault()\n\t\t\t},\n\t\t},\n\t}\n}"}
{"input": "package filters\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"context\"\n\n\t\"github.com/otiai10/chant/server/middleware\"\n\t\"github.com/otiai10/chant/server/models\"\n\t\"github.com/otiai10/marmoset\"\n)\n\n\ntype AuthFilter struct {\n\tmarmoset.Filter\n\tPolicy *Policy\n}\n\n\ntype AuthCtxKey string\n\n\nconst AuthKey AuthCtxKey = \"user\"\n\n\nvar policy *Policy\n\n\nfunc SharedPolicy() Policy {\n\treturn *policy\n}\n\n\n\n\n\n\nfunc (f *AuthFilter) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\n\tc, err := r.Cookie(\"chant_identity_token\")\n\tif err != nil {\n\t\thttp.Redirect(w, r, \"/login\", http.StatusTemporaryRedirect)\n\t\treturn\n\t}\n\tuser, err := models.DecodeUser(c.Value, os.Getenv(\"JWT_SALT\"))\n\tif err != nil {\n\t\thttp.Redirect(w, r, \"/login\", http.StatusTemporaryRedirect)\n\t\treturn\n\t}\n\tif user == nil {\n\t\thttp.Redirect(w, r, \"/login\", http.StatusTemporaryRedirect)\n\t\treturn\n\t}\n\tif !f.Policy.Allow(user) {\n\t\thttp.Redirect(w, r, \"/403\", http.StatusTemporaryRedirect)\n\t\treturn\n\t}\n\tctx := middleware.Context(r)\n\tmarmoset.Context().Set(r, context.WithValue(ctx, AuthKey, user))\n\tf.Next.ServeHTTP(w, r)\n\treturn\n\n}\n\n\nfunc RequestUser(r *http.Request) *models.User {\n\tuser, ok := marmoset.Context().Get(r).Value(AuthKey).(*models.User)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn user\n}\n\nfunc InitializeAuthFilter(policyfile io.Reader) *AuthFilter ", "output": "{\n\tpolicy = NewPolicy(policyfile)\n\treturn &AuthFilter{\n\t\tPolicy: policy,\n\t}\n}"}
{"input": "package config\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\t\"gopkg.in/yaml.v2\"\n)\n\ntype Config struct {\n\tCsCluster struct {\n\t\tHost string\n\t\tPort int\n\t}\n\tRabbit struct {\n\t\tHost string\n\t}\n}\n\nvar File string\n\n\nfunc ReadReturn(path string) (*Config, error) {\n\tf := OpenConfig(&path)\n\tc, err := ReadConfig(f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\n\nfunc OpenConfig(configFile *string) *os.File {\n\tf, err := os.Open(*configFile)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn f\n}\n\n\n\n\nfunc ReadConfig(r io.Reader) (*Config, error) ", "output": "{\n\tdata, err := ioutil.ReadAll(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar c Config\n\tyaml.Unmarshal(data, &c)\n\treturn &c, nil\n}"}
{"input": "package db\n\n\ntype Label struct {\n\tID int\n\n\tLabel        string\n\tIP           string\n\tContainerIPs []string\n}\n\n\ntype LabelSlice []Label\n\n\nfunc (db Database) InsertLabel() Label {\n\tresult := Label{ID: db.nextID()}\n\tdb.insert(result)\n\treturn result\n}\n\n\nfunc (db Database) SelectFromLabel(check func(Label) bool) []Label {\n\tlabelTable := db.accessTable(LabelTable)\n\tvar result []Label\n\tfor _, row := range labelTable.rows {\n\t\tif check == nil || check(row.(Label)) {\n\t\t\tresult = append(result, row.(Label))\n\t\t}\n\t}\n\n\treturn result\n}\n\n\nfunc (conn Conn) SelectFromLabel(check func(Label) bool) []Label {\n\tvar result []Label\n\tconn.Txn(LabelTable).Run(func(view Database) error {\n\t\tresult = view.SelectFromLabel(check)\n\t\treturn nil\n\t})\n\treturn result\n}\n\nfunc (r Label) getID() int {\n\treturn r.ID\n}\n\nfunc (r Label) String() string {\n\treturn defaultString(r)\n}\n\nfunc (r Label) less(row row) bool {\n\tr2 := row.(Label)\n\n\tswitch {\n\tcase r.Label != r2.Label:\n\t\treturn r.Label < r2.Label\n\tdefault:\n\t\treturn r.ID < r2.ID\n\t}\n}\n\n\n\n\n\nfunc (ls LabelSlice) Len() int {\n\treturn len(ls)\n}\n\n\nfunc (ls LabelSlice) Less(i, j int) bool {\n\treturn ls[i].less(ls[j])\n}\n\n\nfunc (ls LabelSlice) Swap(i, j int) {\n\tls[i], ls[j] = ls[j], ls[i]\n}\n\nfunc (ls LabelSlice) Get(i int) interface{} ", "output": "{\n\treturn ls[i]\n}"}
{"input": "package ip\n\n\ntype Veth struct {\n\tLink\n\tPeerName string\n}\n\n\nfunc (veth *Veth) additionalArgs() []string {\n\targs := []string{}\n\tif veth.PeerName != \"\" {\n\t\targs = append(args, \"peer\", \"name\", veth.PeerName)\n\t}\n\treturn args\n}\n\n\n\n\nfunc (veth *Veth) Add() error ", "output": "{\n\treturn veth.Link.add(\"veth\", veth.additionalArgs())\n}"}
{"input": "package vhostsourceproducer\n\nimport (\n\t\"context\"\n\n\t\"knative.dev/reconciler-test/pkg/environment\"\n\t\"knative.dev/reconciler-test/pkg/feature\"\n\t\"knative.dev/reconciler-test/pkg/manifest\"\n)\n\n\n\nfunc Install() feature.StepFn {\n\treturn func(ctx context.Context, t feature.T) {\n\t\tif _, err := manifest.InstallLocalYaml(ctx, map[string]interface{}{\"producerCount\": 10}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc init() ", "output": "{\n\tenvironment.RegisterPackage(manifest.ImagesLocalYaml()...)\n}"}
{"input": "package helper\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n)\n\nimport (\n\t\"cfg\"\n)\n\nvar (\n\t_debug_open bool\n)\n\nfunc init() {\n\tconfig := cfg.Get()\n\tif config[\"debug\"] == \"true\" {\n\t\t_debug_open = true\n\t}\n}\n\n\n\n\nfunc WARN(v ...interface{}) {\n\tlog.Printf(\"\\033[1;33m[WARN] %v \\033[0m\\n\", strings.TrimRight(fmt.Sprintln(v...), \"\\n\"))\n}\n\nfunc INFO(v ...interface{}) {\n\tlog.Printf(\"\\033[32m[INFO] %v \\033[0m\\n\", strings.TrimRight(fmt.Sprintln(v...), \"\\n\"))\n}\n\nfunc NOTICE(v ...interface{}) {\n\tlog.Printf(\"[NOTICE] %v\\n\", strings.TrimRight(fmt.Sprintln(v...), \"\\n\"))\n}\n\nfunc DEBUG(v ...interface{}) {\n\tif _debug_open {\n\t\tlog.Printf(\"\\033[1;35m[DEBUG] %v \\033[0m\\n\", strings.TrimRight(fmt.Sprintln(v...), \"\\n\"))\n\t}\n}\n\nfunc ERR(v ...interface{}) ", "output": "{\n\tlog.Printf(\"\\033[1;4;31m[ERROR] %v \\033[0m\\n\", strings.TrimRight(fmt.Sprintln(v...), \"\\n\"))\n}"}
{"input": "package ss\n\nimport (\n\t\"sync\"\n\n\t\"github.com/willf/bloom\"\n)\n\nconst (\n\tdefaultFilterCapacity  = 100000\n\tdefaultFilterFalseRate = 0.00001\n)\n\ntype bloomFilter struct {\n\tf    *bloom.BloomFilter\n\tlock sync.Mutex\n}\n\nfunc newBloomFilter() bytesFilter {\n\treturn &bloomFilter{\n\t\tf: bloom.NewWithEstimates(uint(defaultFilterCapacity), defaultFilterFalseRate),\n\t}\n}\n\n\n\nfunc (b *bloomFilter) TestAndAdd(v []byte) bool {\n\tb.lock.Lock()\n\tdefer b.lock.Unlock()\n\tif b == nil || b.f == nil {\n\t\treturn false\n\t}\n\treturn b.f.TestAndAdd(v)\n}\n\nfunc (b *bloomFilter) Close() error ", "output": "{\n\tb.lock.Lock()\n\tdefer b.lock.Unlock()\n\tb.f.ClearAll()\n\treturn nil\n}"}
{"input": "package model\n\n\nimport \"soy/db/link\"\nimport \"soy/vat\"\nimport \"math/rand\"\n\ntype PlayerModel struct {\n\tBaseModel\n}\n\nfunc _init_player() {\n\tplayer := new(PlayerModel)\n\tvar str string = \"未命名\" + vat.IntToString(rand.Int()%1000)\n\tprintln(\"设置名字:\", str)\n\tplayer.ChangeName(str, 1008)\n\tret := player.GetPlayerInfo(1008)\n\tprintln(\"获取用户:\", ret.String(\"name\"))\n}\n\n\n\n\n\nfunc (this *PlayerModel) ChangeName(name string, uid int32) {\n\ttx := this.Sql().Begin()\n\tdefer tx.Commit()\n\ttx.WriteQuery(\"UPDATE player SET name=? WHERE uid=?\", name, uid)\n}\n\n\nfunc (this *PlayerModel) RemovePlayerInfo(uid int32) {\n\ttx := this.Sql().Begin()\n\tdefer tx.Commit()\n\ttx.WriteQuery(\"DELETE FROM player WHERE uid=?\", uid)\n}\n\nfunc (this *PlayerModel) GetPlayerInfo(uid int32) link.IRowItem ", "output": "{\n\ttx := this.Sql().Begin()\n\tdefer tx.Commit()\n\tret := tx.ReadQuery(\"SELECT * FROM player WHERE uid=?\", uid)\n\tif ret == nil || ret.Empty() {\n\t\treturn nil\n\t}\n\treturn ret.Row(0)\n}"}
{"input": "package testbackend_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/stripe/veneur/ssf\"\n\t\"github.com/stripe/veneur/trace\"\n\t\"github.com/stripe/veneur/trace/testbackend\"\n)\n\n\n\nfunc ExampleNewBackend() ", "output": "{\n\tctx := context.Background()\n\n\tch := make(chan *ssf.SSFSpan, 1)\n\tclient, _ := trace.NewBackendClient(testbackend.NewBackend(ch))\n\n\tspan, ctx := trace.StartSpanFromContext(ctx, \"hi_there\")\n\tspan.ClientFinish(client)\n\trcvd := <-ch\n\tfmt.Println(rcvd.Name)\n}"}
{"input": "package terraform\n\n\ntype EvalSequence struct {\n\tNodes []EvalNode\n}\n\n\n\n\nfunc (n *EvalSequence) Filter(fn EvalNodeFilterFunc) {\n\tfor i, node := range n.Nodes {\n\t\tn.Nodes[i] = fn(node)\n\t}\n}\n\nfunc (n *EvalSequence) Eval(ctx EvalContext) (interface{}, error) ", "output": "{\n\tfor _, n := range n.Nodes {\n\t\tif n == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif _, err := EvalRaw(n, ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn nil, nil\n}"}
{"input": "package main\n\nimport \"fmt\"\n\n\n\nfunc main() {\n\tf(\"direct\")\n\n\tgo f(\"goroutine\")\n\n\tgo func(msg string) {\n\t\tfmt.Println(msg)\t\n\t}(\"going\")\n\n\tvar input string\n\tfmt.Scanln(&input)\n\tfmt.Println(\"done\")\n}\n\nfunc f(from string) ", "output": "{\n\tfor i := 0; i < 3; i++ {\n\t\tfmt.Println(from, \":\", i)\n\t}\n}"}
{"input": "package command\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/funkygao/gocli\"\n\t\"github.com/funkygao/golib/gofmt\"\n)\n\ntype Comma struct {\n\tUi  cli.Ui\n\tCmd string\n}\n\nfunc (this *Comma) Run(args []string) (exitCode int) {\n\tcmdFlags := flag.NewFlagSet(\"comma\", flag.ContinueOnError)\n\tcmdFlags.Usage = func() { this.Ui.Output(this.Help()) }\n\tif err := cmdFlags.Parse(args); err != nil {\n\t\treturn 2\n\t}\n\n\tif len(args) == 0 {\n\t\tthis.Ui.Error(\"missing <integer>\")\n\t\treturn 2\n\t}\n\n\targ := args[len(args)-1]\n\tfor _, n := range strings.Split(arg, \",\") {\n\t\ti, err := strconv.ParseInt(n, 10, 64)\n\t\tswallow(err)\n\t\tthis.Ui.Outputf(\"%s -> %s\", n, gofmt.Comma(i))\n\t}\n\n\treturn\n}\n\nfunc (*Comma) Synopsis() string {\n\treturn \"Place commas after every three orders of magnitude\"\n}\n\n\n\nfunc (this *Comma) Help() string ", "output": "{\n\thelp := fmt.Sprintf(`\nUsage: %s comma <integer[,integer]>\n\n    %s\n\n`, this.Cmd, this.Synopsis())\n\treturn strings.TrimSpace(help)\n}"}
{"input": "package conv\n\nimport (\n\t\"reflect\"\n)\n\nfunc IntPtrTo64(ptr interface{}) (value int64) {\n\tif v := reflect.ValueOf(ptr); v.Kind() == reflect.Ptr {\n\t\tp := v.Elem()\n\t\tswitch p.Kind() {\n\t\tcase reflect.Int:\n\t\t\tvalue = int64(*ptr.(*int))\n\t\tcase reflect.Int8:\n\t\t\tvalue = int64(*ptr.(*int8))\n\t\tcase reflect.Int16:\n\t\t\tvalue = int64(*ptr.(*int16))\n\t\tcase reflect.Int32:\n\t\t\tvalue = int64(*ptr.(*int32))\n\t\tcase reflect.Int64:\n\t\t\tvalue = *ptr.(*int64)\n\t\t}\n\t}\n\treturn\n}\n\n\n\nfunc UintPtrTo64(ptr interface{}) (value uint64) ", "output": "{\n\tif v := reflect.ValueOf(ptr); v.Kind() == reflect.Ptr {\n\t\tp := v.Elem()\n\t\tswitch p.Kind() {\n\t\tcase reflect.Uint:\n\t\t\tvalue = uint64(*ptr.(*uint))\n\t\tcase reflect.Uint8:\n\t\t\tvalue = uint64(*ptr.(*uint8))\n\t\tcase reflect.Uint16:\n\t\t\tvalue = uint64(*ptr.(*uint16))\n\t\tcase reflect.Uint32:\n\t\t\tvalue = uint64(*ptr.(*uint32))\n\t\tcase reflect.Uint64:\n\t\t\tvalue = *ptr.(*uint64)\n\t\t}\n\t}\n\treturn\n}"}
{"input": "package sarama\n\ntype offsetRequestBlock struct {\n\ttime       int64\n\tmaxOffsets int32\n}\n\nfunc (r *offsetRequestBlock) encode(pe packetEncoder) error {\n\tpe.putInt64(int64(r.time))\n\tpe.putInt32(r.maxOffsets)\n\treturn nil\n}\n\ntype OffsetRequest struct {\n\tblocks map[string]map[int32]*offsetRequestBlock\n}\n\nfunc (r *OffsetRequest) encode(pe packetEncoder) error {\n\tpe.putInt32(-1) \n\terr := pe.putArrayLength(len(r.blocks))\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor topic, partitions := range r.blocks {\n\t\terr = pe.putString(topic)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = pe.putArrayLength(len(partitions))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor partition, block := range partitions {\n\t\t\tpe.putInt32(partition)\n\t\t\terr = block.encode(pe)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (r *OffsetRequest) key() int16 {\n\treturn 2\n}\n\n\n\nfunc (r *OffsetRequest) AddBlock(topic string, partitionID int32, time int64, maxOffsets int32) {\n\tif r.blocks == nil {\n\t\tr.blocks = make(map[string]map[int32]*offsetRequestBlock)\n\t}\n\n\tif r.blocks[topic] == nil {\n\t\tr.blocks[topic] = make(map[int32]*offsetRequestBlock)\n\t}\n\n\ttmp := new(offsetRequestBlock)\n\ttmp.time = time\n\ttmp.maxOffsets = maxOffsets\n\n\tr.blocks[topic][partitionID] = tmp\n}\n\nfunc (r *OffsetRequest) version() int16 ", "output": "{\n\treturn 0\n}"}
{"input": "package bolthold\n\nimport (\n\t\"reflect\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\n\n\nfunc (s *Store) Delete(key, dataType interface{}) error {\n\treturn s.Bolt().Update(func(tx *bolt.Tx) error {\n\t\treturn s.TxDelete(tx, key, dataType)\n\t})\n}\n\n\nfunc (s *Store) TxDelete(tx *bolt.Tx, key, dataType interface{}) error {\n\tif !tx.Writable() {\n\t\treturn bolt.ErrTxNotWritable\n\t}\n\n\tstorer := newStorer(dataType)\n\tgk, err := encode(key)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tb := tx.Bucket([]byte(storer.Type()))\n\tif b == nil {\n\t\treturn ErrNotFound\n\t}\n\n\tvalue := reflect.New(reflect.TypeOf(dataType)).Interface()\n\n\tbVal := b.Get(gk)\n\n\terr = decode(bVal, value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = b.Delete(gk)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = indexDelete(storer, tx, gk, value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc (s *Store) DeleteMatching(dataType interface{}, query *Query) error {\n\treturn s.Bolt().Update(func(tx *bolt.Tx) error {\n\t\treturn s.TxDeleteMatching(tx, dataType, query)\n\t})\n}\n\n\n\n\nfunc (s *Store) TxDeleteMatching(tx *bolt.Tx, dataType interface{}, query *Query) error ", "output": "{\n\treturn deleteQuery(tx, dataType, query)\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSApplicationAutoScalingScalableTarget_ScheduledAction struct {\n\n\tEndTime string `json:\"EndTime,omitempty\"`\n\n\tScalableTargetAction *AWSApplicationAutoScalingScalableTarget_ScalableTargetAction `json:\"ScalableTargetAction,omitempty\"`\n\n\tSchedule string `json:\"Schedule,omitempty\"`\n\n\tScheduledActionName string `json:\"ScheduledActionName,omitempty\"`\n\n\tStartTime string `json:\"StartTime,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSApplicationAutoScalingScalableTarget_ScheduledAction) AWSCloudFormationType() string {\n\treturn \"AWS::ApplicationAutoScaling::ScalableTarget.ScheduledAction\"\n}\n\n\n\nfunc (r *AWSApplicationAutoScalingScalableTarget_ScheduledAction) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSApplicationAutoScalingScalableTarget_ScheduledAction) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSApplicationAutoScalingScalableTarget_ScheduledAction) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\n\n\n\n\nfunc (r *AWSApplicationAutoScalingScalableTarget_ScheduledAction) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSApplicationAutoScalingScalableTarget_ScheduledAction) SetMetadata(metadata map[string]interface{}) ", "output": "{\n\tr._metadata = metadata\n}"}
{"input": "package store\n\nimport (\n\t\"time\"\n\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"github.com/russross/meddler\"\n\tsq \"github.com/Masterminds/squirrel\"\n)\n\ntype Feature struct {\n\tId        int64      `json:\"id\"                         meddler:\"id,pk\"`\n\tCreatedAt *time.Time `json:\"created_at,omitempty\"       meddler:\"created_at\"`\n\tName      *string    `json:\"name,omitempty\"             meddler:\"name\"`\n}\n\n\n\nfunc (s *store) ListFeatures() ([]*Feature, error) {\n\tquery := sq.Select(\"*\").From(\"feature\")\n\n\tsql, args, err := query.ToSql()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlog.Debug(sql)\n\n\tfeatures := []*Feature{}\n\terr = meddler.QueryAll(s.db, &features, sql, args...)\n\n\treturn features, err\n}\n\nfunc (s *store) CreateFeature(feature *Feature) error {\n\tfeature.CreatedAt = Time(time.Now())\n\treturn meddler.Insert(s.db, \"feature\", feature)\n}\n\nfunc (s *store) UpdateFeature(feature *Feature) error {\n\treturn meddler.Update(s.db, \"feature\", feature)\n}\n\nfunc (s *store) GetFeatureByName(name string) (*Feature, error) ", "output": "{\n\tfeature := new(Feature)\n\n\tquery := sq.Select(\"*\").From(\"feature\")\n\tquery = query.Where(sq.Eq{\"name\": name})\n\n\tsql, args, err := query.ToSql()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlog.Debug(sql)\n\n\terr = meddler.QueryRow(s.db, feature, sql, args...)\n\n\treturn feature, err\n}"}
{"input": "package nacos\n\nimport (\n\t\"context\"\n\n\t\"github.com/asim/go-micro/v3/config/source\"\n\t\"github.com/nacos-group/nacos-sdk-go/v2/common/constant\"\n)\n\ntype addressKey struct{}\ntype configKey struct{}\ntype groupKey struct{}\ntype dataIdKey struct{}\ntype encoderKey struct{}\n\n\n\n\n\nfunc WithClientConfig(cc constant.ClientConfig) source.Option {\n\treturn func(o *source.Options) {\n\t\tif o.Context == nil {\n\t\t\to.Context = context.Background()\n\t\t}\n\t\to.Context = context.WithValue(o.Context, configKey{}, cc)\n\t}\n}\n\n\nfunc WithGroup(g string) source.Option {\n\treturn func(o *source.Options) {\n\t\tif o.Context == nil {\n\t\t\to.Context = context.Background()\n\t\t}\n\t\to.Context = context.WithValue(o.Context, groupKey{}, g)\n\t}\n}\n\n\nfunc WithDataId(id string) source.Option {\n\treturn func(o *source.Options) {\n\t\tif o.Context == nil {\n\t\t\to.Context = context.Background()\n\t\t}\n\t\to.Context = context.WithValue(o.Context, dataIdKey{}, id)\n\t}\n}\n\nfunc WithAddress(addrs []string) source.Option ", "output": "{\n\treturn func(o *source.Options) {\n\t\tif o.Context == nil {\n\t\t\to.Context = context.Background()\n\t\t}\n\t\to.Context = context.WithValue(o.Context, addressKey{}, addrs)\n\t}\n}"}
{"input": "package dyn4go\n\nimport (\n\t\"math\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"testing\"\n)\n\n\n\nfunc AssertEqual(t *testing.T, a, b interface{}) {\n\tif a != b {\n\t\tt.Error(preambleCorrection(\"Values not equal in assertion\"))\n\t}\n}\n\nfunc AssertEqualWithinError(t *testing.T, a, b, c float64) {\n\tif math.Abs(a)-math.Abs(b) > math.Abs(c) {\n\t\tt.Error(preambleCorrection(\"Values not equal within error in assertion\"))\n\t}\n}\n\nfunc AssertTrue(t *testing.T, a bool) {\n\tif !a {\n\t\tt.Error(preambleCorrection(\"Condition not true in assertion\"))\n\t}\n}\n\nfunc AssertNotEqual(t *testing.T, a, b interface{}) {\n\tif a == b {\n\t\tt.Error(preambleCorrection(\"Values equal in assertion\"))\n\t}\n}\n\nfunc AssertFalse(t *testing.T, a bool) {\n\tif a {\n\t\tt.Error(preambleCorrection(\"Condition not false in assertion\"))\n\t}\n}\n\n\nfunc deferredPreambleCorrection(message string) string {\n\t_, f, l, r := runtime.Caller(2)\n\tif !r {\n\t\treturn message\n\t}\n\treturn \"\\r\\t\" + filepath.Base(f) + \":\" + strconv.Itoa(l) + \": \" + message\n}\n\nfunc AssertPanic(t *testing.T) {\n\tif r := recover(); r == nil {\n\t\tt.Error(deferredPreambleCorrection(\"Function failed to panic\"))\n\t}\n}\n\nfunc AssertNoPanic(t *testing.T) {\n\tif r := recover(); r != nil {\n\t\tt.Error(deferredPreambleCorrection(\"Function paniced\"))\n\t}\n}\n\nfunc preambleCorrection(message string) string ", "output": "{\n\t_, f, l, r := runtime.Caller(2)\n\tif !r {\n\t\treturn message\n\t}\n\treturn \"\\r\\t\" + filepath.Base(f) + \":\" + strconv.Itoa(l) + \": \" + message\n}"}
{"input": "package server\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/influxdata/influxdb/chronograf\"\n\t\"github.com/influxdata/influxdb/chronograf/influx\"\n)\n\n\n\n\nfunc ToQueryConfig(query string) chronograf.QueryConfig {\n\tqc, err := influx.Convert(query)\n\tif err == nil {\n\t\treturn qc\n\t}\n\treturn chronograf.QueryConfig{\n\t\tRawText: &query,\n\t\tFields:  []chronograf.Field{},\n\t\tGroupBy: chronograf.GroupBy{\n\t\t\tTags: []string{},\n\t\t},\n\t\tTags: make(map[string][]string),\n\t}\n}\n\nvar validFieldTypes = map[string]bool{\n\t\"func\":     true,\n\t\"field\":    true,\n\t\"integer\":  true,\n\t\"number\":   true,\n\t\"regex\":    true,\n\t\"wildcard\": true,\n}\n\n\n\n\nfunc ValidateQueryConfig(q *chronograf.QueryConfig) error ", "output": "{\n\tfor _, fld := range q.Fields {\n\t\tinvalid := fmt.Errorf(`invalid field type \"%s\" ; expect func, field, integer, number, regex, wildcard`, fld.Type)\n\t\tif !validFieldTypes[fld.Type] {\n\t\t\treturn invalid\n\t\t}\n\t\tfor _, arg := range fld.Args {\n\t\t\tif !validFieldTypes[arg.Type] {\n\t\t\t\treturn invalid\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package utils\n\nimport (\n\t\"fmt\"\n\n\t\"gopkg.in/stretchr/testify.v1/mock\"\n)\n\ntype Printer interface {\n\tHelp()\n\tVersion()\n\tMessage(msg string)\n\tError(err error)\n\tCommands()\n}\n\ntype TextPrinter struct {\n\tversion string\n}\n\nfunc NewTextPrinter(version string) *TextPrinter {\n\treturn &TextPrinter{version}\n}\n\nfunc (p *TextPrinter) Help() {\n\thelpText := `Name:\n\tfiz - a file wizard\n\nVersion:\n\t` + p.version + `\n\nUsage:\n\tfiz <command>\n\n`\n\tp.Message(helpText)\n\tp.Commands()\n}\n\nfunc (p *TextPrinter) Version() {\n\tfmt.Println(\"fiz\", p.version)\n}\n\nfunc (p *TextPrinter) Message(msg string) {\n\tfmt.Print(msg)\n}\n\nfunc (p *TextPrinter) Error(err error) {\n\tfmt.Println(\"Error: \", err)\n}\n\nfunc (p *TextPrinter) Commands() {\n\tp.Message(COMMANDS_MSG)\n}\n\n\ntype MockPrinter struct {\n\tmock.Mock\n}\n\nfunc NewMockPrinter() *MockPrinter {\n\treturn &MockPrinter{}\n}\n\n\n\nfunc (m *MockPrinter) Version() {\n\tm.Called()\n}\n\nfunc (m *MockPrinter) Message(msg string) {\n\tm.Called(msg)\n}\n\nfunc (m *MockPrinter) Error(err error) {\n\tm.Called(err)\n}\n\nfunc (m *MockPrinter) Commands() {\n\tm.Called()\n}\n\nfunc (m *MockPrinter) Help() ", "output": "{\n\tm.Called()\n}"}
{"input": "package main\n\nimport . \"g2d\"\n\nvar screen = Point{480, 360}\nvar size = Point{20, 20}\n\ntype Ball struct {\n    x, y   int\n    dx, dy int\n}\n\nfunc NewBall(pos Point) *Ball {\n    return &Ball{pos.X, pos.Y, 5, 5}\n}\n\nfunc (b *Ball) Move() {\n    if !(0 <= b.x+b.dx && b.x+b.dx <= screen.X-size.X) {\n        b.dx = -b.dx\n    }\n    if !(0 <= b.y+b.dy && b.y+b.dy <= screen.Y-size.Y) {\n        b.dy = -b.dy\n    }\n    b.x += b.dx\n    b.y += b.dy\n}\n\nfunc (b *Ball) Position() Point {\n    return Point{b.x, b.y}\n}\n\n\nvar b1 = NewBall(Point{40, 80})\nvar b2 = NewBall(Point{80, 40})\n\nfunc mainConsole() {\n    for i := 0; i < 25; i++ {\n        Println(\"Ball 1 @\", b1.Position())\n        Println(\"Ball 2 @\", b2.Position())\n        b1.Move()\n        b2.Move()\n    }\n}\n\n\n\nfunc main() {\n    \n    InitCanvas(screen)\n    MainLoop(tick)\n}\n\nfunc tick() ", "output": "{\n    ClearCanvas()  \n    b1.Move()\n    b2.Move()\n    DrawImage(\"ball.png\", b1.Position())  \n    DrawImage(\"ball.png\", b2.Position())  \n}"}
{"input": "package deploymentmanager\n\n\n\n\n\n\n\n\ntype DeploymentMode string\n\nconst (\n\tComplete DeploymentMode = \"Complete\"\n\tIncremental DeploymentMode = \"Incremental\"\n)\n\n\nfunc PossibleDeploymentModeValues() []DeploymentMode {\n\treturn []DeploymentMode{Complete, Incremental}\n}\n\n\ntype StepType string\n\nconst (\n\tStepTypeStepProperties StepType = \"StepProperties\"\n\tStepTypeWait StepType = \"Wait\"\n)\n\n\n\n\n\ntype Type string\n\nconst (\n\tTypeAuthentication Type = \"Authentication\"\n\tTypeSas Type = \"Sas\"\n)\n\n\nfunc PossibleTypeValues() []Type {\n\treturn []Type{TypeAuthentication, TypeSas}\n}\n\nfunc PossibleStepTypeValues() []StepType ", "output": "{\n\treturn []StepType{StepTypeStepProperties, StepTypeWait}\n}"}
{"input": "package api\n\nimport \"code.google.com/p/go-uuid/uuid\"\n\n\n\nfunc NewUUID() string ", "output": "{\n\treturn uuid.New()\n}"}
{"input": "package introspect\n\nimport (\n\t\"encoding/xml\"\n\t\"strings\"\n\n\t\"github.com/godbus/dbus/v5\"\n)\n\n\n\n\n\nfunc Call(o dbus.BusObject) (*Node, error) ", "output": "{\n\tvar xmldata string\n\tvar node Node\n\n\terr := o.Call(\"org.freedesktop.DBus.Introspectable.Introspect\", 0).Store(&xmldata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = xml.NewDecoder(strings.NewReader(xmldata)).Decode(&node)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif node.Name == \"\" {\n\t\tnode.Name = string(o.Path())\n\t}\n\treturn &node, nil\n}"}
{"input": "package retention\n\nimport (\n\t\"time\"\n\n\txtime \"github.com/m3db/m3/src/x/time\"\n)\n\n\nfunc FlushTimeStart(opts Options, t xtime.UnixNano) xtime.UnixNano {\n\treturn FlushTimeStartForRetentionPeriod(opts.RetentionPeriod(), opts.BlockSize(), t)\n}\n\n\nfunc FlushTimeStartForRetentionPeriod(\n\tretentionPeriod time.Duration, blockSize time.Duration, t xtime.UnixNano) xtime.UnixNano {\n\treturn t.Add(-retentionPeriod).Truncate(blockSize)\n}\n\n\nfunc FlushTimeEnd(opts Options, t xtime.UnixNano) xtime.UnixNano {\n\treturn FlushTimeEndForBlockSize(opts.BlockSize(),\n\t\tt.Add(opts.FutureRetentionPeriod()).Add(-opts.BufferPast()))\n}\n\n\n\n\nfunc FlushTimeEndForBlockSize(blockSize time.Duration, t xtime.UnixNano) xtime.UnixNano ", "output": "{\n\treturn t.Add(-blockSize).Truncate(blockSize)\n}"}
{"input": "package framework\n\nimport (\n\t\"time\"\n\n\t\"k8s.io/api/core/v1\"\n\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/util/wait\"\n\n\t\"github.com/pkg/errors\"\n)\n\nfunc (f *Framework) WaitForConfigMapExist(ns, name string) (*v1.ConfigMap, error) {\n\tvar configMap *v1.ConfigMap\n\terr := wait.Poll(2*time.Second, f.DefaultTimeout, func() (bool, error) {\n\t\tvar err error\n\t\tconfigMap, err = f.\n\t\t\tKubeClient.\n\t\t\tCoreV1().\n\t\t\tConfigMaps(ns).\n\t\t\tGet(name, metav1.GetOptions{})\n\n\t\tif apierrors.IsNotFound(err) {\n\t\t\treturn false, nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn true, nil\n\t})\n\n\treturn configMap, errors.Wrapf(err, \"waiting for ConfigMap '%v' in namespace '%v'\", name, ns)\n}\n\n\n\nfunc (f *Framework) WaitForConfigMapNotExist(ns, name string) error ", "output": "{\n\terr := wait.Poll(2*time.Second, f.DefaultTimeout, func() (bool, error) {\n\t\tvar err error\n\t\t_, err = f.\n\t\t\tKubeClient.\n\t\t\tCoreV1().\n\t\t\tConfigMaps(ns).\n\t\t\tGet(name, metav1.GetOptions{})\n\n\t\tif apierrors.IsNotFound(err) {\n\t\t\treturn true, nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn false, nil\n\t})\n\n\treturn errors.Wrapf(err, \"waiting for ConfigMap '%v' in namespace '%v' to not exist\", name, ns)\n}"}
{"input": "package http\n\nimport (\n\t\"net/http\"\n\n\t\"go-common/app/service/main/card/conf\"\n\t\"go-common/app/service/main/card/service\"\n\t\"go-common/library/log\"\n\tbm \"go-common/library/net/http/blademaster\"\n\t\"go-common/library/net/http/blademaster/middleware/verify\"\n)\n\nvar (\n\tsrv       *service.Service\n\tverifySvc *verify.Verify\n)\n\n\n\n\nfunc route(e *bm.Engine) {\n\te.Ping(ping)\n\te.Register(register)\n\tgroup := e.Group(\"/x/internal/card\", verifySvc.Verify)\n\t{\n\t\tgroup.GET(\"/bymids\", byMids)\n\t}\n}\n\nfunc ping(c *bm.Context) {\n\tif err := srv.Ping(c); err != nil {\n\t\tlog.Error(\"ping error(%v)\", err)\n\t\tc.AbortWithStatus(http.StatusServiceUnavailable)\n\t}\n}\n\nfunc register(c *bm.Context) {\n\tc.JSON(map[string]interface{}{}, nil)\n}\n\nfunc Init(c *conf.Config, svc *service.Service) ", "output": "{\n\tsrv = svc\n\tverifySvc = verify.New(nil)\n\tengine := bm.DefaultServer(c.BM)\n\troute(engine)\n\tif err := engine.Start(); err != nil {\n\t\tlog.Error(\"bm Start error(%v)\", err)\n\t\tpanic(err)\n\t}\n}"}
{"input": "package profiler_test\n\nimport (\n\t\"cloud.google.com/go/profiler\"\n)\n\n\n\nfunc ExampleStart() ", "output": "{\n\tif err := profiler.Start(profiler.Config{Service: \"my-service\", ServiceVersion: \"v1\"}); err != nil {\n\t}\n}"}
{"input": "package streaming\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype DeleteStreamPoolRequest struct {\n\n\tStreamPoolId *string `mandatory:\"true\" contributesTo:\"path\" name:\"streamPoolId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request DeleteStreamPoolRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request DeleteStreamPoolRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request DeleteStreamPoolRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype DeleteStreamPoolResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response DeleteStreamPoolResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response DeleteStreamPoolResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request DeleteStreamPoolRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) ", "output": "{\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}"}
{"input": "package databasemigration\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype WorkRequestErrorCollection struct {\n\n\tItems []WorkRequestError `mandatory:\"true\" json:\"items\"`\n}\n\n\n\nfunc (m WorkRequestErrorCollection) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\n\ntype Monitor interface {\n\tGetVariables() []string\n\tGetValues([]string) map[string]interface{}\n}\n\nvar monitorDrivers = make(map[string]func(*json.RawMessage) Monitor)\n\nfunc AddMonitorDriver(monitor string, constructor func(*json.RawMessage) Monitor) {\n\tmonitorDrivers[monitor] = constructor\n}\n\ntype MonitorTrack struct {\n\tVariables map[string]*MonitorTrackVariable\n\tInterval  int\n\ttimer     *time.Timer\n}\n\nfunc newMonitorTrack() *MonitorTrack {\n\treturn &MonitorTrack{\n\t\tVariables: make(map[string]*MonitorTrackVariable),\n\t}\n}\n\ntype MonitorTrackVariable struct {\n\tHistory int\n\tData    []interface{}\n}\n\n\n\nfunc (mt *MonitorTrack) Start(monitor Monitor) {\n\tgo func() {\n\t\tmt.timer = time.NewTimer(time.Duration(1) * time.Second)\n\t\tfor _ = range mt.timer.C {\n\t\t\tif mt.Interval > 0 {\n\t\t\t\tmt.timer.Reset(time.Second * time.Duration(mt.Interval))\n\t\t\t}\n\t\t\tvariables := []string{}\n\t\t\tfor variable := range mt.Variables {\n\t\t\t\tvariables = append(variables, variable)\n\t\t\t}\n\t\t\tvalues := monitor.GetValues(variables)\n\t\t\tfor variable, vt := range mt.Variables {\n\t\t\t\tvt.Data = append(vt.Data, values[variable])\n\t\t\t\tif len(vt.Data) > vt.History {\n\t\t\t\t\tvt.Data = vt.Data[len(vt.Data)-vt.History:]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc (mt *MonitorTrack) SetTrack(variable string, history int) ", "output": "{\n\ttrack, ok := mt.Variables[variable]\n\tif !ok && history > 0 {\n\t\ttrack = &MonitorTrackVariable{}\n\t\tmt.Variables[variable] = track\n\t}\n\tif history == 0 && ok {\n\t\tdelete(mt.Variables, variable)\n\t\treturn\n\t}\n\ttrack.History = history\n}"}
{"input": "package intsort\n\ntype Uints []uint\n\n\n\nfunc (s Uints) Less(i int, j int) bool {\n\treturn s[i] < s[j]\n}\n\nfunc (s Uints) Swap(i int, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\nfunc (s Uints) Len() int ", "output": "{\n\treturn len(s)\n}"}
{"input": "package data_table\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/julienschmidt/httprouter\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc DataStoreHandler(tableStore TableStore) func(http.ResponseWriter, *http.Request, httprouter.Params) {\n\treturn func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {\n\t\trequest := newSearchRequest(r, ps)\n\t\tresult := tableStore.QueryData(request)\n\t\tjsonBytes, _ := json.Marshal(result)\n\t\tfmt.Fprint(w, string(jsonBytes))\n\t}\n}\n\n\n\nfunc ParseKey(key string) []string {\n\tres := make([]string, 0)\n\tvar currKey bytes.Buffer\n\n\tfor _, char := range key {\n\t\tif char == '[' || char == ']' {\n\t\t\tif currKey.Len() > 0 {\n\t\t\t\tres = append(res, currKey.String())\n\t\t\t\tcurrKey.Reset()\n\t\t\t}\n\t\t} else {\n\t\t\tcurrKey.WriteRune(char)\n\t\t}\n\t}\n\n\tif currKey.Len() > 0 {\n\t\tres = append(res, currKey.String())\n\t}\n\n\treturn res\n}\n\nfunc TreePostFormValues(values url.Values) map[string]interface{} ", "output": "{\n\tres := make(map[string]interface{})\n\tvar currValue map[string]interface{}\n\tfor rawKey, value := range values {\n\t\tif vs := value; len(vs) > 0 {\n\t\t\tcurrValue = res\n\t\t\tkeyPath := ParseKey(rawKey)\n\t\t\tlastIndex := len(keyPath) - 1\n\t\t\tfor index, key := range keyPath {\n\t\t\t\tif index == lastIndex {\n\t\t\t\t\tcurrValue[key] = vs[0]\n\t\t\t\t} else {\n\t\t\t\t\tif _, ok := currValue[key]; !ok {\n\t\t\t\t\t\tcurrValue[key] = make(map[string]interface{})\n\t\t\t\t\t}\n\t\t\t\t\tcurrValue = currValue[key].(map[string]interface{})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\treturn res\n}"}
{"input": "package taskqueue\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype ReqRepTask struct {\n\tMsg        string\n\tResultChan chan string\n}\n\ntype ReqRepTaskQueue chan *ReqRepTask\n\n\n\nfunc reqRepTaskQueueWorker(queue ReqRepTaskQueue, index int) {\n\tfor task := range queue {\n\t\trandom := rand.Intn(3)\n\t\ttime.Sleep(time.Duration(random) * time.Second)\n\n\t\techo := fmt.Sprintf(\"ReqRepTaskQueueWorker [%d] echo: %s\", index, task.Msg)\n\t\ttask.ResultChan <- echo\n\n\t\tclose(task.ResultChan)\n\t}\n}\n\nfunc NewReqRepTaskQueue(workerNum int) ReqRepTaskQueue ", "output": "{\n\tqueue := make(ReqRepTaskQueue, 500)\n\n\tfor i := 0; i < workerNum; i++ {\n\t\tgo reqRepTaskQueueWorker(queue, i)\n\t}\n\n\treturn queue\n}"}
{"input": "package routetable_test\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n\n\t\"github.com/onsi/ginkgo/reporters\"\n\n\t\"github.com/projectcalico/libcalico-go/lib/testutils\"\n)\n\n\n\nfunc TestRules(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tjunitReporter := reporters.NewJUnitReporter(\"../report/routetable_suite.xml\")\n\tRunSpecsWithDefaultAndCustomReporters(t, \"RouteTable Suite\", []Reporter{junitReporter})\n}\n\nfunc init() ", "output": "{\n\ttestutils.HookLogrusForGinkgo()\n}"}
{"input": "package iso20022\n\n\ntype IdentificationModification1 struct {\n\n\tIdentification *Max35Text `xml:\"Id\"`\n\n\tOriginalPartyAndAccountIdentification *IdentificationInformation1 `xml:\"OrgnlPtyAndAcctId,omitempty\"`\n\n\tUpdatedPartyAndAccountIdentification *IdentificationInformation1 `xml:\"UpdtdPtyAndAcctId\"`\n\n\tAdditionalInformation *Max140Text `xml:\"AddtlInf,omitempty\"`\n}\n\n\n\nfunc (i *IdentificationModification1) AddOriginalPartyAndAccountIdentification() *IdentificationInformation1 {\n\ti.OriginalPartyAndAccountIdentification = new(IdentificationInformation1)\n\treturn i.OriginalPartyAndAccountIdentification\n}\n\nfunc (i *IdentificationModification1) AddUpdatedPartyAndAccountIdentification() *IdentificationInformation1 {\n\ti.UpdatedPartyAndAccountIdentification = new(IdentificationInformation1)\n\treturn i.UpdatedPartyAndAccountIdentification\n}\n\nfunc (i *IdentificationModification1) SetAdditionalInformation(value string) {\n\ti.AdditionalInformation = (*Max140Text)(&value)\n}\n\nfunc (i *IdentificationModification1) SetIdentification(value string) ", "output": "{\n\ti.Identification = (*Max35Text)(&value)\n}"}
{"input": "package view\n\nimport (\n\t\"testing\"\n\n\t\"github.com/krotik/eliasdb/storage/file\"\n)\n\nfunc TestPageView(t *testing.T) {\n\tr := file.NewRecord(123, make([]byte, 20))\n\n\tpv := NewPageView(r, TypeDataPage)\n\n\n\tif r.ReadInt16(0) != 0x1991 {\n\t\tt.Error(\"Unexpected header value\")\n\t\treturn\n\t}\n\n\tif r.PageView() != GetPageView(r) {\n\t\tt.Error(\"Unexpected page view on record\")\n\t\treturn\n\t}\n\n\n\tr.WriteSingleByte(0, 0x18)\n\tr.SetPageView(nil)\n\n\ttestCheckMagicPanic(t, r)\n\n\tr.WriteSingleByte(0, 0x19)\n\n\n\tpv.checkMagic()\n\n\tif pv.Type() != TypeDataPage {\n\t\tt.Error(\"Wrong type for page view\")\n\t\treturn\n\t}\n\n\tif o := pv.String(); o != \"PageView: 123 (type:1 previous page:0 next page:0)\" {\n\t\tt.Error(\"Unexpected String output:\", o)\n\t}\n\n\n\tif pv.NextPage() != 0 {\n\t\tt.Error(\"Unexpected next page\")\n\t\treturn\n\t}\n\n\tpv.SetNextPage(1)\n\n\tif pv.NextPage() != 1 {\n\t\tt.Error(\"Unexpected next page\")\n\t\treturn\n\t}\n\n\tif pv.PrevPage() != 0 {\n\t\tt.Error(\"Unexpected prev page\")\n\t\treturn\n\t}\n\n\tpv.SetPrevPage(1)\n\n\tif pv.PrevPage() != 1 {\n\t\tt.Error(\"Unexpected Prev page\")\n\t\treturn\n\t}\n}\n\n\n\nfunc testCheckMagicPanic(t *testing.T, r *file.Record) ", "output": "{\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Error(\"Getting the page view from a corrupted record did not cause a panic.\")\n\t\t}\n\t}()\n\n\tGetPageView(r)\n}"}
{"input": "package wkb\n\nimport (\n\t\"encoding/binary\"\n\t\"github.com/foobaz/geom\"\n\t\"io\"\n)\n\n\n\nfunc writeMultiPoint(w io.Writer, byteOrder binary.ByteOrder, axes uint32, multiPoint geom.MultiPoint) error {\n\tif err := binary.Write(w, byteOrder, uint32(len(multiPoint))); err != nil {\n\t\treturn err\n\t}\n\tfor _, point := range multiPoint {\n\t\tif err := Write(w, byteOrder, axes, point); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc multiPointReader(r io.Reader, byteOrder binary.ByteOrder, dimension int) (geom.T, error) ", "output": "{\n\tvar numPoints uint32\n\tif err := binary.Read(r, byteOrder, &numPoints); err != nil {\n\t\treturn nil, err\n\t}\n\tpoints := make([]geom.Point, numPoints)\n\tfor i := range points {\n\t\tif g, err := Read(r); err == nil {\n\t\t\tvar ok bool\n\t\t\tpoints[i], ok = g.(geom.Point)\n\t\t\tif !ok {\n\t\t\t\treturn nil, &UnexpectedGeometryError{g}\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn geom.MultiPoint(points), nil\n}"}
{"input": "package mailru\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/markbates/goth\"\n)\n\n\ntype Session struct {\n\tAuthURL      string\n\tAccessToken  string\n\tRefreshToken string\n\tExpiresAt    time.Time\n}\n\n\nfunc (s *Session) GetAuthURL() (string, error) {\n\tif s.AuthURL == \"\" {\n\t\treturn \"\", errors.New(goth.NoAuthUrlErrorMessage)\n\t}\n\n\treturn s.AuthURL, nil\n}\n\n\nfunc (s *Session) Marshal() string {\n\tb, _ := json.Marshal(s)\n\treturn string(b)\n}\n\n\nfunc (s *Session) Authorize(provider goth.Provider, params goth.Params) (string, error) {\n\tp := provider.(*Provider)\n\ttoken, err := p.oauthConfig.Exchange(goth.ContextForClient(p.Client()), params.Get(\"code\"))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif !token.Valid() {\n\t\treturn \"\", errors.New(\"invalid token received from provider\")\n\t}\n\n\ts.AccessToken = token.AccessToken\n\ts.RefreshToken = token.RefreshToken\n\ts.ExpiresAt = token.Expiry\n\n\treturn s.AccessToken, err\n}\n\n\n\n\nfunc (p *Provider) UnmarshalSession(data string) (goth.Session, error) ", "output": "{\n\tsess := new(Session)\n\terr := json.NewDecoder(strings.NewReader(data)).Decode(&sess)\n\treturn sess, err\n}"}
{"input": "package service\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/spf13/cobra\"\n\n\t\"github.com/docker/docker/cli\"\n\t\"github.com/docker/docker/cli/command\"\n)\n\n\n\n\nfunc NewServiceCommand(dockerCli *command.DockerCli) *cobra.Command ", "output": "{\n\tcmd := &cobra.Command{\n\t\tUse:   \"service\",\n\t\tShort: \"Manage Docker services\",\n\t\tArgs:  cli.NoArgs,\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tfmt.Fprintf(dockerCli.Err(), \"\\n\"+cmd.UsageString())\n\t\t},\n\t}\n\tcmd.AddCommand(\n\t\tnewCreateCommand(dockerCli),\n\t\tnewInspectCommand(dockerCli),\n\t\tnewPsCommand(dockerCli),\n\t\tnewListCommand(dockerCli),\n\t\tnewRemoveCommand(dockerCli),\n\t\tnewScaleCommand(dockerCli),\n\t\tnewUpdateCommand(dockerCli),\n\t)\n\treturn cmd\n}"}
{"input": "package util\n\nimport (\n\t\"testing\"\n\t\"github.com/DanielDanteDosSantosViana/hire.me/config\"\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc init() {\n\tconfig.Conf.Base.Alfabeto = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n}\n\n\n\nfunc TestConverterPrimeiroElementoDaSequence(t *testing.T) {\n\tConvey(\"Dado o primeiro elemento da sequence (int64) 0\", t, func() {\n\t\tvar inteiro  uint64 = 0\n\t\tvar alias string = \"a\"\n\t\tConvey(\"Quando converto inteiro 0 para string \", func() {\n\t\t\tretorno := InteiroParaString(inteiro)\n\n\t\t\tConvey(\"O valor retornado deve ser a primeira letra contida em  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' \", func() {\n\t\t\t\tSo(retorno, ShouldEqual, alias)\n\t\t\t})\n\t\t})\n\t})\n}\n\nfunc TestConverterInteiro18446744073709551615ParaAliasv8QrKbgkrIp(t *testing.T) ", "output": "{\n\tConvey(\"Dado um inteiro (int64) 18446744073709551615\", t, func() {\n\t\tvar inteiro  uint64 = 18446744073709551615\n\t\tvar alias string = \"v8QrKbgkrIp\"\n\t\tConvey(\"Quando converto inteiro 18446744073709551615 para string \", func() {\n\t\t\tretorno := InteiroParaString(inteiro)\n\n\t\t\tConvey(\"O valor retornado deve ser o alias 'v8QrKbgKrIp' \", func() {\n\t\t\t\tSo(retorno, ShouldEqual, alias)\n\t\t\t})\n\t\t})\n\t})\n}"}
{"input": "package sacloud\n\ntype LoadBalancerServers []*LoadBalancerServer\n\n\nfunc (o *LoadBalancerServers) Add(server *LoadBalancerServer) {\n\tif o.Exist(server) {\n\t\treturn \n\t}\n\t*o = append(*o, server)\n}\n\n\nfunc (o *LoadBalancerServers) Exist(server *LoadBalancerServer) bool {\n\tfor _, v := range *o {\n\t\tif v.IPAddress == server.IPAddress {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc (o *LoadBalancerServers) ExistAt(ip string) bool {\n\treturn o.Exist(&LoadBalancerServer{IPAddress: ip})\n}\n\n\nfunc (o *LoadBalancerServers) Find(server *LoadBalancerServer) *LoadBalancerServer {\n\tfor _, v := range *o {\n\t\tif v.IPAddress == server.IPAddress {\n\t\t\treturn v\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (o *LoadBalancerServers) FindAt(ip string) *LoadBalancerServer {\n\treturn o.Find(&LoadBalancerServer{IPAddress: ip})\n}\n\n\n\n\n\nfunc (o *LoadBalancerServers) UpdateAt(ip string, new *LoadBalancerServer) {\n\to.Update(&LoadBalancerServer{IPAddress: ip}, new)\n}\n\n\nfunc (o *LoadBalancerServers) Delete(server *LoadBalancerServer) {\n\tvar res []*LoadBalancerServer\n\tfor _, v := range *o {\n\t\tif v.IPAddress != server.IPAddress {\n\t\t\tres = append(res, v)\n\t\t}\n\t}\n\t*o = res\n}\n\n\nfunc (o *LoadBalancerServers) DeleteAt(ip string) {\n\to.Delete(&LoadBalancerServer{IPAddress: ip})\n}\n\nfunc (o *LoadBalancerServers) Update(old *LoadBalancerServer, new *LoadBalancerServer) ", "output": "{\n\tfor _, v := range *o {\n\t\tif v.IPAddress == old.IPAddress {\n\t\t\t*v = *new\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"input": "package main\n\nimport \"sync/atomic\"\n\n\n\n\n\n\n\ntype BlackHole struct {\n\texitChan chan int\n\tStatus   int64\n}\n\n\nfunc NewBlackHole(config map[string]string) (*BlackHole, error) {\n\tblackHole := &BlackHole{}\n\tblackHole.exitChan = make(chan int)\n\tatomic.StoreInt64(&blackHole.Status, 1)\n\treturn blackHole, nil\n}\n\n\nfunc (blackHole *BlackHole) Stop() {\n\tclose(blackHole.exitChan)\n}\n\n\n\n\n\nfunc (blackHole *BlackHole) IsRunning() bool {\n\treturn atomic.LoadInt64(&blackHole.Status) > 0\n}\n\nfunc (blackHole *BlackHole) Start(dataChan chan map[string]interface{}) error ", "output": "{\n\tatomic.StoreInt64(&blackHole.Status, 1)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-dataChan:\n\t\t\tcase <-blackHole.exitChan:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}"}
{"input": "package bot\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/graffic/wanon/telegram\"\n\n\t\"gopkg.in/yaml.v2\"\n)\n\n\ntype ConfService struct {\n\tbytes []byte\n}\n\n\nfunc LoadConf(fileName string) (*ConfService, error) {\n\tconf := new(ConfService)\n\n\tfile, err := os.Open(fileName)\n\tif err != nil {\n\t\treturn conf, err\n\t}\n\n\tconf.bytes, err = ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn conf, err\n\t}\n\n\treturn conf, nil\n}\n\n\n\n\n\nfunc createAPI(conf *ConfService) (telegram.API, error) {\n\tvar apiConf telegram.Configuration\n\tconf.Get(&apiConf)\n\tapi := telegram.NewAPI(&http.Client{Timeout: time.Second * 15}, apiConf)\n\tresult, err := api.GetMe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlog.Info(\"%s online\", result.Username)\n\n\treturn api, nil\n}\n\nfunc (service *ConfService) Get(in interface{}) error ", "output": "{\n\treturn yaml.Unmarshal(service.bytes, in)\n}"}
{"input": "package errors\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n)\n\n\ntype HTTPError struct {\n\tStatusCode int\n\terror\n}\n\n\nfunc (e *HTTPError) Error() string {\n\treturn e.error.Error()\n}\n\n\n\n\nfunc NewMethodNotAllowed(method string) *HTTPError {\n\treturn &HTTPError{http.StatusMethodNotAllowed, errors.New(`Method is not allowed:\"` + method + `\"`)}\n}\n\n\nfunc NewBadRequest(err error) *HTTPError {\n\treturn &HTTPError{http.StatusBadRequest, err}\n}\n\n\n\n\n\n\n\nfunc NewBadRequestMissingParameter(s string) *HTTPError {\n\treturn NewBadRequestString(`Missing parameter \"` + s + `\"`)\n}\n\n\n\nfunc NewBadRequestUnwantedParameter(s string) *HTTPError {\n\treturn NewBadRequestString(`Unwanted parameter \"` + s + `\"`)\n}\n\nfunc NewBadRequestString(s string) *HTTPError ", "output": "{\n\treturn NewBadRequest(errors.New(s))\n}"}
{"input": "package chart\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n)\n\ntype CT_Thickness struct {\n\tValAttr ST_Thickness\n}\n\nfunc NewCT_Thickness() *CT_Thickness {\n\tret := &CT_Thickness{}\n\treturn ret\n}\n\nfunc (m *CT_Thickness) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tstart.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: \"val\"},\n\t\tValue: fmt.Sprintf(\"%v\", m.ValAttr)})\n\te.EncodeToken(start)\n\te.EncodeToken(xml.EndElement{Name: start.Name})\n\treturn nil\n}\n\n\n\n\nfunc (m *CT_Thickness) Validate() error {\n\treturn m.ValidateWithPath(\"CT_Thickness\")\n}\n\n\nfunc (m *CT_Thickness) ValidateWithPath(path string) error {\n\tif err := m.ValAttr.ValidateWithPath(path + \"/ValAttr\"); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (m *CT_Thickness) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error ", "output": "{\n\tfor _, attr := range start.Attr {\n\t\tif attr.Name.Local == \"val\" {\n\t\t\tparsed, err := ParseUnionST_Thickness(attr.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tm.ValAttr = parsed\n\t\t}\n\t}\n\tfor {\n\t\ttok, err := d.Token()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing CT_Thickness: %s\", err)\n\t\t}\n\t\tif el, ok := tok.(xml.EndElement); ok && el.Name == start.Name {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\ntype karma struct {\n\tdb     map[string]int\n\tdbFile io.ReadWriteSeeker\n}\n\nfunc (k *karma) increment(item string) int {\n\tk.db[item]++\n\treturn k.db[item]\n}\n\nfunc (k *karma) decrement(item string) int {\n\tk.db[item]--\n\treturn k.db[item]\n}\n\nfunc (k *karma) query(item string) int {\n\treturn k.db[item]\n}\n\nfunc newKarma(d io.ReadWriteSeeker) *karma {\n\tk := &karma{\n\t\tdb:     make(map[string]int),\n\t\tdbFile: d,\n\t}\n\n\treturn k\n}\n\nfunc (k *karma) read() error {\n\tif _, err := k.dbFile.Seek(io.SeekStart, 0); err != nil {\n\t\treturn err\n\t}\n\tdecoder := json.NewDecoder(k.dbFile)\n\tif err := decoder.Decode(&k.db); err != nil {\n\t\tif err != io.EOF {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (k *karma) save() error {\n\tmarshaledKarmaData, err := json.MarshalIndent(k.db, \"\", \"    \")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Println(\"Writing karma JSON to file.\")\n\tif _, err := k.dbFile.Seek(io.SeekStart, 0); err != nil {\n\t\treturn err\n\t}\n\tif _, err := k.dbFile.Write(marshaledKarmaData); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc readKarmaFileJSON(fileLoc string) (*karma, error) ", "output": "{\n\tvar err error\n\tvar dbFile *os.File\n\tif _, err := os.Stat(fileLoc); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tlog.Println(\"No karma JSON found, creating.\")\n\t\t}\n\t\tif dbFile, err = os.OpenFile(fileLoc, os.O_RDWR|os.O_CREATE, 0644); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn newKarma(dbFile), nil\n\t}\n\tlog.Println(\"Loading karma JSON from disk and populating karmaDB map.\")\n\tif dbFile, err = os.OpenFile(fileLoc, os.O_RDWR|os.O_CREATE, 0644); err != nil {\n\t\treturn nil, err\n\t}\n\tk := newKarma(dbFile)\n\tif err = k.read(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn k, nil\n}"}
{"input": "package gce\n\nimport (\n\t\"k8s.io/kops/upup/pkg/fi\"\n)\n\ntype GCEAPITarget struct {\n\tCloud *GCECloud\n}\n\nvar _ fi.Target = &GCEAPITarget{}\n\n\n\nfunc (t *GCEAPITarget) Finish(taskMap map[string]fi.Task) error {\n\treturn nil\n}\n\nfunc NewGCEAPITarget(cloud *GCECloud) *GCEAPITarget ", "output": "{\n\treturn &GCEAPITarget{\n\t\tCloud: cloud,\n\t}\n}"}
{"input": "package common\n\nimport \"encoding/json\"\n\ntype Result struct {\n\tStatusCode int         `json:\"status_code\"`\n\tMsg        string      `json:\"msg\"`\n\tData       interface{} `json:\"data\"`\n}\n\n\n\nfunc (result *Result) String() string ", "output": "{\n\tb, _ := json.Marshal(result)\n\treturn string(b)\n}"}
{"input": "package helpers\n\nimport \"testing\"\n\n\n\nfunc TestIsRegionNormalized(t *testing.T) {\n\tcases := []struct {\n\t\tinput          string\n\t\texpectedResult string\n\t}{\n\t\t{\n\t\t\tinput:          \"westus\",\n\t\t\texpectedResult: \"westus\",\n\t\t},\n\t\t{\n\t\t\tinput:          \"West US\",\n\t\t\texpectedResult: \"westus\",\n\t\t},\n\t\t{\n\t\t\tinput:          \"Eastern Africa\",\n\t\t\texpectedResult: \"easternafrica\",\n\t\t},\n\t\t{\n\t\t\tinput:          \"\",\n\t\t\texpectedResult: \"\",\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tresult := NormalizeAzureRegion(c.input)\n\t\tif c.expectedResult != result {\n\t\t\tt.Fatalf(\"NormalizeAzureRegion returned unexpected result: expected %s but got %s\", c.expectedResult, result)\n\t\t}\n\t}\n}\n\nfunc TestPointerToBool(t *testing.T) ", "output": "{\n\tboolVar := true\n\tret := PointerToBool(boolVar)\n\tif *ret != boolVar {\n\t\tt.Fatalf(\"expected PointerToBool(true) to return *true, instead returned %#v\", ret)\n\t}\n}"}
{"input": "package single\n\nimport (\n\t\"io\"\n\n\t\"github.com/ondrej-smola/mesos-go-http/lib/codec/framing\"\n)\n\ntype Reader struct {\n\tr io.Reader\n}\n\nfunc New(r io.Reader) *Reader {\n\treturn &Reader{r: r}\n}\n\n\n\nfunc NewProvider() framing.Provider {\n\treturn func(r io.Reader) framing.Reader {\n\t\treturn New(r)\n\t}\n}\n\n\n\nfunc (rr *Reader) Read(p []byte) (int, error) {\n\treturn rr.r.Read(p)\n}\n\nfunc (rr *Reader) ReadFrame(p []byte) (endOfFrame bool, n int, err error) ", "output": "{\n\tn, err = rr.r.Read(p)\n\n\tif err == io.EOF {\n\t\tendOfFrame = true\n\t}\n\n\treturn\n}"}
{"input": "package filesystem\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/windows\"\n)\n\nfunc umask(mask int) int {\n\treturn 0\n}\n\n\n\nfunc getFreeSpace(path string) (uint64, error) {\n\twpath, err := windows.UTF16PtrFromString(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvar freeBytes uint64\n\tif err := windows.GetDiskFreeSpaceEx(wpath, nil, nil, &freeBytes); err != nil {\n\t\treturn 0, err\n\t}\n\treturn freeBytes, nil\n}\n\nfunc addReadMode(mode os.FileMode) os.FileMode ", "output": "{\n\treturn mode | syscall.S_IRUSR\n}"}
{"input": "package main\n\n\n\nfunc max(nums ...float64) float64 {\n\tvar max float64\n\tfor i := 0; i < len(nums); i++ {\n\t\tif nums[i] > max {\n\t\t\tmax = nums[i]\n\t\t}\n\t}\n\treturn max\n}\n\nfunc avg(nums ...float64) float64 {\n\treturn sum(nums...) / float64(len(nums))\n}\n\nfunc sum(nums ...float64) float64 ", "output": "{\n\tvar sum float64\n\tfor i := 0; i < len(nums); i++ {\n\t\tsum += nums[i]\n\t}\n\treturn sum\n}"}
{"input": "package models\n\nimport (\n\t\"github.com/macococo/go-gamereviews/utils\"\n)\n\ntype User struct {\n\tId   int\n\tName string\n\tType int\n\tModel\n}\n\ntype UserManager struct {\n}\n\nfunc (this *UserManager) TableName() string {\n\treturn \"t_user\"\n}\n\nfunc (this *UserManager) AddTable() {\n\tDbMap.AddTableWithName(User{}, this.TableName()).SetKeys(true, \"Id\")\n}\n\n\n\nfunc (this *UserManager) Find(t int, pagination *Pagination) []*User {\n\tvar users []*User\n\t_, err := DbMap.Select(&users, \"SELECT * FROM \"+this.TableName()+\" WHERE type = ? LIMIT ?, ?\", t, (pagination.Page-1)*pagination.Length, pagination.Length)\n\tutils.HandleError(err)\n\n\treturn users\n}\n\nfunc (this *UserManager) Create(user *User) *User {\n\tutils.HandleError(DbMap.Insert(user))\n\treturn user\n}\n\nfunc (this *UserManager) Count(t int) int64 ", "output": "{\n\tcount, err := DbMap.SelectInt(\"SELECT count(*) FROM \"+this.TableName()+\" WHERE type = ?\", t)\n\tutils.HandleError(err)\n\n\treturn count\n}"}
{"input": "package servicecatalog\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetPrivateApplicationPackageRequest struct {\n\n\tPrivateApplicationPackageId *string `mandatory:\"true\" contributesTo:\"path\" name:\"privateApplicationPackageId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetPrivateApplicationPackageRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request GetPrivateApplicationPackageRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request GetPrivateApplicationPackageRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetPrivateApplicationPackageResponse struct {\n\n\tRawResponse *http.Response\n\n\tPrivateApplicationPackage `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response GetPrivateApplicationPackageResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response GetPrivateApplicationPackageResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request GetPrivateApplicationPackageRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) ", "output": "{\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}"}
{"input": "package errors\n\nimport (\n\t\"fmt\"\n\n\t. \"github.com/nttlabs/cli/cf/i18n\"\n)\n\ntype HttpError interface {\n\terror\n\tStatusCode() int   \n\tErrorCode() string \n}\n\ntype baseHttpError struct {\n\tstatusCode   int\n\tapiErrorCode string\n\tdescription  string\n}\n\ntype HttpNotFoundError struct {\n\tbaseHttpError\n}\n\nfunc NewHttpError(statusCode int, code string, description string) error {\n\terr := baseHttpError{\n\t\tstatusCode:   statusCode,\n\t\tapiErrorCode: code,\n\t\tdescription:  description,\n\t}\n\tswitch statusCode {\n\tcase 404:\n\t\treturn &HttpNotFoundError{err}\n\tdefault:\n\t\treturn &err\n\t}\n}\n\nfunc (err *baseHttpError) StatusCode() int {\n\treturn err.statusCode\n}\n\n\n\nfunc (err *baseHttpError) ErrorCode() string {\n\treturn err.apiErrorCode\n}\n\nfunc (err *baseHttpError) Error() string ", "output": "{\n\treturn fmt.Sprintf(T(\"Server error, status code: {{.ErrStatusCode}}, error code: {{.ErrApiErrorCode}}, message: {{.ErrDescription}}\",\n\t\tmap[string]interface{}{\"ErrStatusCode\": err.statusCode,\n\t\t\t\"ErrApiErrorCode\": err.apiErrorCode,\n\t\t\t\"ErrDescription\":  err.description}),\n\t)\n}"}
{"input": "package cmd\n\nimport (\n\t\"github.com/spf13/cobra\"\n)\n\n\nvar environmentsCmd = &cobra.Command{\n\tUse:   \"environments\",\n\tShort: \"Manage Vorteil environments\",\n\tLong: `To build a Vorteil Application the binary that will be executed needs to be\nsingled out. For compiled languages like C or Go this results in intuitive vcli\ncommands such as 'vcli run myapp'. For interpreted languages like Java, Python,\nor Nodejs, the process is less intuitive because the binary being run is the\ninterpreter, whilst the interesting program is simply an argument to it.\n\nTo make one of these programs run as a Vorteil Application the user would need\nto target the interpreter as the buildable binary, add the user's program (and\nany dependencies) to the filesystem, and adjust the binary args to target the\nuser's program. This is convoluted and tedious. To simplify the use of\ninterpreted language programs, vcli can apply a user's program to an\n'environment', which includes the interpreter and any dynamically-linked\nlibraries it depends upon.\n\nUse the 'environments' subcommands to download and manage environments. Use the\n'vcli prepare' command to apply an environment to an application.`,\n}\n\n\n\nfunc init() ", "output": "{\n\tRootCmd.AddCommand(environmentsCmd)\n}"}
{"input": "package ui\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar AppQuit chan struct{}\n\nfunc init() {\n\tAppQuit = newEvent()\n}\n\nfunc Go(main func()) error ", "output": "{\n\treturn ui(main)\n}"}
{"input": "package iotcentral\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\n\n\n\nfunc Version() string {\n\treturn version.Number\n}\n\nfunc UserAgent() string ", "output": "{\n\treturn \"Azure-SDK-For-Go/\" + Version() + \" iotcentral/2021-06-01\"\n}"}
{"input": "package transactional\n\nimport (\n\t\"gopkg.in/src-d/go-git.v4/plumbing/format/index\"\n\t\"gopkg.in/src-d/go-git.v4/plumbing/storer\"\n)\n\n\ntype IndexStorage struct {\n\tstorer.IndexStorer\n\ttemporal storer.IndexStorer\n\n\tset bool\n}\n\n\n\nfunc NewIndexStorage(s, temporal storer.IndexStorer) *IndexStorage {\n\treturn &IndexStorage{\n\t\tIndexStorer: s,\n\t\ttemporal:    temporal,\n\t}\n}\n\n\nfunc (s *IndexStorage) SetIndex(idx *index.Index) (err error) {\n\tif err := s.temporal.SetIndex(idx); err != nil {\n\t\treturn err\n\t}\n\n\ts.set = true\n\treturn nil\n}\n\n\n\n\n\nfunc (s *IndexStorage) Commit() error {\n\tif !s.set {\n\t\treturn nil\n\t}\n\n\tidx, err := s.temporal.Index()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn s.IndexStorer.SetIndex(idx)\n}\n\nfunc (s *IndexStorage) Index() (*index.Index, error) ", "output": "{\n\tif !s.set {\n\t\treturn s.IndexStorer.Index()\n\t}\n\n\treturn s.temporal.Index()\n}"}
{"input": "package uaa\n\nimport (\n\t\"sort\"\n\n\tbosherr \"github.com/cloudfoundry/bosh-utils/errors\"\n)\n\ntype Prompt struct {\n\tKey   string \n\tType  string \n\tLabel string \n}\n\ntype PromptAnswer struct {\n\tKey   string \n\tValue string\n}\n\nfunc (p Prompt) IsPassword() bool { return p.Type == \"password\" }\n\ntype PromptsResp struct {\n\tPrompts map[string][]string \n}\n\nfunc (u UAAImpl) Prompts() ([]Prompt, error) {\n\tresp, err := u.client.Prompts()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar prompts []Prompt\n\n\tfor key, pair := range resp.Prompts {\n\t\tprompts = append(prompts, Prompt{\n\t\t\tKey:   key,\n\t\t\tType:  pair[0],\n\t\t\tLabel: pair[1],\n\t\t})\n\t}\n\n\tsort.Sort(PromptSorting(prompts))\n\n\treturn prompts, nil\n}\n\nfunc (c Client) Prompts() (PromptsResp, error) {\n\tvar resp PromptsResp\n\n\terr := c.clientRequest.Get(\"/login\", &resp)\n\tif err != nil {\n\t\treturn resp, bosherr.WrapError(err, \"Requesting UAA prompts\")\n\t}\n\n\treturn resp, nil\n}\n\ntype PromptSorting []Prompt\n\n\nfunc (s PromptSorting) Less(i, j int) bool { return s[i].Type > s[j].Type }\nfunc (s PromptSorting) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\nfunc (s PromptSorting) Len() int           ", "output": "{ return len(s) }"}
{"input": "package flags\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n\n\ntype IniError struct {\n\tMessage string\n\n\tFile string\n\n\tLineNumber uint\n}\n\n\nfunc (x *IniError) Error() string {\n\treturn fmt.Sprintf(\"%s:%d: %s\",\n\t\tx.File,\n\t\tx.LineNumber,\n\t\tx.Message)\n}\n\n\ntype IniOptions uint\n\nconst (\n\tIniNone IniOptions = 0\n\n\tIniIncludeDefaults = 1 << iota\n\n\tIniCommentDefaults\n\n\tIniIncludeComments\n\n\tIniDefault = IniIncludeComments\n)\n\n\n\ntype IniParser struct {\n\tparser *Parser\n}\n\n\nfunc NewIniParser(p *Parser) *IniParser {\n\treturn &IniParser{\n\t\tparser: p,\n\t}\n}\n\n\n\n\n\nfunc IniParse(filename string, data interface{}) error {\n\tp := NewParser(data, Default)\n\treturn NewIniParser(p).ParseFile(filename)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (i *IniParser) Parse(reader io.Reader) error {\n\ti.parser.storeDefaults()\n\n\tini, err := readIni(reader, \"\")\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn i.parse(ini)\n}\n\n\n\n\nfunc (i *IniParser) WriteFile(filename string, options IniOptions) error {\n\tfile, err := os.Create(filename)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer file.Close()\n\ti.Write(file, options)\n\n\treturn nil\n}\n\n\n\n\n\n\nfunc (i *IniParser) Write(writer io.Writer, options IniOptions) {\n\twriteIni(i, writer, options)\n}\n\nfunc (i *IniParser) ParseFile(filename string) error ", "output": "{\n\ti.parser.storeDefaults()\n\n\tini, err := readIniFromFile(filename)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn i.parse(ini)\n}"}
{"input": "package protocol\n\nimport (\n\t\"io\"\n\t\"time\"\n)\n\ntype TestModel struct {\n\tdata     []byte\n\trepo     string\n\tname     string\n\toffset   int64\n\tsize     int\n\tclosedCh chan bool\n}\n\n\n\nfunc (t *TestModel) Index(nodeID string, files []FileInfo) {\n}\n\nfunc (t *TestModel) IndexUpdate(nodeID string, files []FileInfo) {\n}\n\nfunc (t *TestModel) Request(nodeID, repo, name string, offset int64, size int) ([]byte, error) {\n\tt.repo = repo\n\tt.name = name\n\tt.offset = offset\n\tt.size = size\n\treturn t.data, nil\n}\n\nfunc (t *TestModel) Close(nodeID string, err error) {\n\tclose(t.closedCh)\n}\n\nfunc (t *TestModel) isClosed() bool {\n\tselect {\n\tcase <-t.closedCh:\n\t\treturn true\n\tcase <-time.After(1 * time.Second):\n\t\treturn false \n\t}\n}\n\ntype ErrPipe struct {\n\tio.PipeWriter\n\twritten int\n\tmax     int\n\terr     error\n\tclosed  bool\n}\n\nfunc (e *ErrPipe) Write(data []byte) (int, error) {\n\tif e.closed {\n\t\treturn 0, e.err\n\t}\n\tif e.written+len(data) > e.max {\n\t\tn, _ := e.PipeWriter.Write(data[:e.max-e.written])\n\t\te.PipeWriter.CloseWithError(e.err)\n\t\te.closed = true\n\t\treturn n, e.err\n\t}\n\treturn e.PipeWriter.Write(data)\n}\n\nfunc newTestModel() *TestModel ", "output": "{\n\treturn &TestModel{\n\t\tclosedCh: make(chan bool),\n\t}\n}"}
{"input": "package termios\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\nfunc ptsname(fd uintptr) (string, error) {\n\tvar n uintptr\n\terr := ioctl(fd, syscall.TIOCGPTN, uintptr(unsafe.Pointer(&n)))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn fmt.Sprintf(\"/dev/pts/%d\", n), nil\n}\n\nfunc grantpt(fd uintptr) error {\n\tvar n uintptr\n\treturn ioctl(fd, syscall.TIOCGPTN, uintptr(unsafe.Pointer(&n)))\n}\n\n\n\nfunc unlockpt(fd uintptr) error ", "output": "{\n\tvar n uintptr\n\treturn ioctl(fd, syscall.TIOCSPTLCK, uintptr(unsafe.Pointer(&n)))\n}"}
{"input": "package fakesmtp\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n)\n\n\ntype Connection struct {\n\tconn    net.Conn\n\taddress string\n\ttime    int64\n\tbufin   *bufio.Reader\n\tbufout  *bufio.Writer\n}\n\n\nfunc (c *Connection) write(s string) {\n\tc.bufout.WriteString(s + \"\\r\\n\")\n\tc.bufout.Flush()\n}\n\n\n\n\nfunc (c *Connection) read() string ", "output": "{\n\treply, err := c.bufin.ReadString('\\n')\n\n\tif err != nil {\n\t\tfmt.Println(\"e \", err)\n\t}\n\treturn reply\n}"}
{"input": "package gohg\n\ntype showconfigOpts struct {\n\tglobalOpts\n\n\tUntrusted\n\n\tdebugOpts\n}\n\nfunc (cmdOpts *showconfigOpts) String() string {\n\treturn sprintfOpts(*cmdOpts)\n}\n\nfunc NewShowConfigCmd(opts []HgOption, configitems []string) HgCmd {\n\tcmd, _ := NewHgCmd(\"showconfig\", opts, configitems, new(showconfigOpts))\n\treturn *cmd\n}\n\n\n\n\n\n\n\nfunc (hgcl *HgClient) ShowConfig(opts []HgOption, configitems []string) ([]byte, error) ", "output": "{\n\tcmd := NewShowConfigCmd(opts, configitems)\n\treturn cmd.Exec(hgcl)\n}"}
{"input": "package appui\n\nimport (\n\t\"github.com/docker/docker/api/types\"\n\tgtermui \"github.com/gizak/termui\"\n\t\"github.com/moncho/dry/ui\"\n\t\"github.com/moncho/dry/ui/termui\"\n)\n\n\ntype ImageRunWidget struct {\n\timage types.ImageSummary\n\ttermui.TextInput\n}\n\n\nfunc NewImageRunWidget(image types.ImageSummary) *ImageRunWidget {\n\tw := &ImageRunWidget{\n\t\timage:     image,\n\t\tTextInput: *termui.NewTextInput(ui.ActiveScreen, \"\"),\n\t}\n\tw.Height = 3\n\tw.Width = ui.ActiveScreen.Dimensions().Width / 2\n\tw.X = (ui.ActiveScreen.Dimensions().Width - w.Width) / 2\n\tw.Y = ui.ActiveScreen.Dimensions().Height / 2\n\tw.Bg = gtermui.Attribute(DryTheme.Bg)\n\tw.TextBgColor = gtermui.Attribute(DryTheme.Bg)\n\tw.TextFgColor = gtermui.ColorWhite\n\tw.BorderLabel = widgetTitle(&image)\n\tw.BorderLabelFg = gtermui.ColorWhite\n\n\treturn w\n}\n\n\nfunc (w *ImageRunWidget) Mount() error {\n\treturn nil\n}\n\n\nfunc (w *ImageRunWidget) Unmount() error {\n\treturn nil\n}\n\n\n\n\nfunc widgetTitle(image *types.ImageSummary) string {\n\tif len(image.RepoTags) > 0 {\n\t\treturn \" docker run \" + image.RepoTags[0]\n\t} else if len(image.RepoDigests) > 0 {\n\t\treturn \" docker run \" + image.RepoDigests[0]\n\t}\n\treturn \" docker run <none>\"\n}\n\nfunc (w *ImageRunWidget) Name() string ", "output": "{\n\treturn \"ImageRunWidget.\" + w.image.ID\n}"}
{"input": "package parts\n\nimport (\n\t\"github.com/google/gxui\"\n)\n\ntype FocusableOuter interface{}\n\ntype Focusable struct {\n\touter         FocusableOuter\n\tfocusable     bool\n\thasFocus      bool\n\tonGainedFocus gxui.Event\n\tonLostFocus   gxui.Event\n}\n\nfunc (f *Focusable) Init(outer FocusableOuter) {\n\tf.outer = outer\n\tf.focusable = true\n}\n\n\n\n\nfunc (f *Focusable) HasFocus() bool {\n\treturn f.hasFocus\n}\n\nfunc (f *Focusable) SetFocusable(bool) {\n\tf.focusable = true\n}\n\nfunc (f *Focusable) OnGainedFocus(l func()) gxui.EventSubscription {\n\tif f.onGainedFocus == nil {\n\t\tf.onGainedFocus = gxui.CreateEvent(f.GainedFocus)\n\t}\n\treturn f.onGainedFocus.Listen(l)\n}\n\nfunc (f *Focusable) OnLostFocus(l func()) gxui.EventSubscription {\n\tif f.onLostFocus == nil {\n\t\tf.onLostFocus = gxui.CreateEvent(f.LostFocus)\n\t}\n\treturn f.onLostFocus.Listen(l)\n}\n\nfunc (f *Focusable) GainedFocus() {\n\tf.hasFocus = true\n\tif f.onGainedFocus != nil {\n\t\tf.onGainedFocus.Fire()\n\t}\n}\n\nfunc (f *Focusable) LostFocus() {\n\tf.hasFocus = false\n\tif f.onLostFocus != nil {\n\t\tf.onLostFocus.Fire()\n\t}\n}\n\nfunc (f *Focusable) IsFocusable() bool ", "output": "{\n\treturn f.focusable\n}"}
{"input": "package block\n\nimport (\n\t\"github.com/juju/cmd\"\n\n\t\"github.com/juju/juju/apiserver/params\"\n\t\"github.com/juju/juju/cmd/envcmd\"\n)\n\nvar (\n\tBlockClient   = &getBlockClientAPI\n\tUnblockClient = &getUnblockClientAPI\n\tListClient    = &getBlockListAPI\n\n\tNewDestroyCommand = newDestroyCommand\n\tNewRemoveCommand  = newRemoveCommand\n\tNewChangeCommand  = newChangeCommand\n\tNewListCommand    = newListCommand\n)\n\ntype MockBlockClient struct {\n\tBlockType string\n\tMsg       string\n}\n\nfunc (c *MockBlockClient) Close() error {\n\treturn nil\n}\n\nfunc (c *MockBlockClient) SwitchBlockOn(blockType, msg string) error {\n\tc.BlockType = blockType\n\tc.Msg = msg\n\treturn nil\n}\n\nfunc (c *MockBlockClient) SwitchBlockOff(blockType string) error {\n\tc.BlockType = blockType\n\tc.Msg = \"\"\n\treturn nil\n}\n\nfunc (c *MockBlockClient) List() ([]params.Block, error) {\n\tif c.BlockType == \"\" {\n\t\treturn []params.Block{}, nil\n\t}\n\n\treturn []params.Block{\n\t\tparams.Block{\n\t\t\tType:    c.BlockType,\n\t\t\tMessage: c.Msg,\n\t\t},\n\t}, nil\n}\n\n\n\nfunc NewUnblockCommandWithClient(client UnblockClientAPI) cmd.Command ", "output": "{\n\treturn envcmd.Wrap(&unblockCommand{client: client})\n}"}
{"input": "package mysql\n\nimport (\n\t\"github.com/jmoiron/sqlx\"\n\t\"github.com/upframe/shopy\"\n)\n\n\ntype LinkService struct {\n\tDB *sqlx.DB\n}\n\nvar linkMap = map[string]string{\n\t\"Hash\":    \"hash\",\n\t\"User\":    \"user_id\",\n\t\"Path\":    \"path\",\n\t\"Used\":    \"used\",\n\t\"Time\":    \"time\",\n\t\"Expires\": \"expires\",\n}\n\n\nfunc (s *LinkService) Get(hash string) (*shopy.Link, error) {\n\tlink := &shopy.Link{}\n\terr := s.DB.Get(link, \"SELECT * FROM links WHERE hash=?\", hash)\n\n\treturn link, err\n}\n\n\nfunc (s *LinkService) Gets(first, limit int, order string) ([]*shopy.Link, error) {\n\tlinks := []*shopy.Link{}\n\tvar err error\n\n\torder = fieldsToColumns(linkMap, order)[0]\n\n\tif limit == 0 {\n\t\terr = s.DB.Select(&links, \"SELECT * FROM links ORDER BY ?\", order)\n\t} else {\n\t\terr = s.DB.Select(&links, \"SELECT * FROM links ORDER BY ? LIMIT ? OFFSET ?\", order, limit, first)\n\t}\n\n\treturn links, err\n}\n\n\nfunc (s *LinkService) Create(l *shopy.Link) error {\n\t_, err := s.DB.NamedExec(insertQuery(\"links\", getAllColumns(linkMap)), l)\n\treturn err\n}\n\n\nfunc (s *LinkService) Update(l *shopy.Link, fields ...string) error {\n\t_, err := s.DB.NamedExec(updateQuery(\"links\", \"hash\", fieldsToColumns(linkMap, fields...)), l)\n\treturn err\n}\n\n\n\n\nfunc (s *LinkService) Delete(hash string) error ", "output": "{\n\tl, err := s.Get(hash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tl.Used = true\n\treturn s.Update(l, \"Used\")\n}"}
{"input": "package filter\n\nimport \"reflect\"\n\ntype Filter interface {\n\tCompare(Filter) bool\n\tTrigger(data interface{})\n}\n\ntype FilterEvent struct {\n\tfilter Filter\n\tdata   interface{}\n}\n\ntype Filters struct {\n\tid       int\n\twatchers map[int]Filter\n\tch       chan FilterEvent\n\n\tquit chan struct{}\n}\n\nfunc New() *Filters {\n\treturn &Filters{\n\t\tch:       make(chan FilterEvent),\n\t\twatchers: make(map[int]Filter),\n\t\tquit:     make(chan struct{}),\n\t}\n}\n\nfunc (self *Filters) Start() {\n\tgo self.loop()\n}\n\nfunc (self *Filters) Stop() {\n\tclose(self.quit)\n}\n\nfunc (self *Filters) Notify(filter Filter, data interface{}) {\n\tself.ch <- FilterEvent{filter, data}\n}\n\nfunc (self *Filters) Install(watcher Filter) int {\n\tself.watchers[self.id] = watcher\n\tself.id++\n\n\treturn self.id - 1\n}\n\nfunc (self *Filters) Uninstall(id int) {\n\tdelete(self.watchers, id)\n}\n\nfunc (self *Filters) loop() {\nout:\n\tfor {\n\t\tselect {\n\t\tcase <-self.quit:\n\t\t\tbreak out\n\t\tcase event := <-self.ch:\n\t\t\tfor _, watcher := range self.watchers {\n\t\t\t\tif reflect.TypeOf(watcher) == reflect.TypeOf(event.filter) {\n\t\t\t\t\tif watcher.Compare(event.filter) {\n\t\t\t\t\t\twatcher.Trigger(event.data)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (self *Filters) Match(a, b Filter) bool {\n\treturn reflect.TypeOf(a) == reflect.TypeOf(b) && a.Compare(b)\n}\n\n\n\nfunc (self *Filters) Get(i int) Filter ", "output": "{\n\treturn self.watchers[i]\n}"}
{"input": "package drum\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n)\n\ntype sampleHeader struct {\n\tID          int32\n\tLabelLength byte\n}\n\n\ntype Sample struct {\n\tID    int32\n\tLabel string\n\tSteps [16]bool\n}\n\n\nfunc ExtractSample(r io.Reader) (Sample, error) {\n\tvar header sampleHeader\n\tsample := Sample{}\n\terr := binary.Read(r, binary.LittleEndian, &header)\n\n\tif err != nil {\n\t\treturn sample, err\n\t}\n\tsample.ID = header.ID\n\tsample.Label, err = extractLabel(r, int(header.LabelLength))\n\tsample.Steps, err = extractSteps(r)\n\treturn sample, err\n}\n\nfunc extractLabel(r io.Reader, size int) (string, error) {\n\tlabelBytes := make([]byte, size)\n\terr := binary.Read(r, binary.LittleEndian, &labelBytes)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(labelBytes), nil\n}\n\nfunc extractSteps(r io.Reader) ([16]bool, error) {\n\tvar steps [16]bool\n\tvar rawSteps [16]byte\n\terr := binary.Read(r, binary.LittleEndian, &rawSteps)\n\tif err != nil {\n\t\treturn steps, err\n\t}\n\tfor i, b := range rawSteps {\n\t\tsteps[i] = (b == 0x01)\n\t}\n\treturn steps, nil\n}\n\n\n\nfunc (s Sample) stepsAsString() string {\n\tbuffer := bytes.NewBufferString(\"|\")\n\tfor i, b := range s.Steps {\n\t\tif b {\n\t\t\tbuffer.WriteString(\"x\")\n\t\t} else {\n\t\t\tbuffer.WriteString(\"-\")\n\t\t}\n\t\tif i%4 == 3 {\n\t\t\tbuffer.WriteString(\"|\")\n\t\t}\n\t}\n\treturn buffer.String()\n}\n\nfunc (s Sample) String() string ", "output": "{\n\treturn fmt.Sprintf(\"(%d) %s\\t%s\", s.ID, s.Label, s.stepsAsString())\n}"}
{"input": "package msgraph\n\nimport \"context\"\n\n\ntype FieldValueSetRequestBuilder struct{ BaseRequestBuilder }\n\n\n\n\n\ntype FieldValueSetRequest struct{ BaseRequest }\n\n\nfunc (r *FieldValueSetRequest) Get(ctx context.Context) (resObj *FieldValueSet, err error) {\n\tvar query string\n\tif r.query != nil {\n\t\tquery = \"?\" + r.query.Encode()\n\t}\n\terr = r.JSONRequest(ctx, \"GET\", query, nil, &resObj)\n\treturn\n}\n\n\nfunc (r *FieldValueSetRequest) Update(ctx context.Context, reqObj *FieldValueSet) error {\n\treturn r.JSONRequest(ctx, \"PATCH\", \"\", reqObj, nil)\n}\n\n\nfunc (r *FieldValueSetRequest) Delete(ctx context.Context) error {\n\treturn r.JSONRequest(ctx, \"DELETE\", \"\", nil, nil)\n}\n\nfunc (b *FieldValueSetRequestBuilder) Request() *FieldValueSetRequest ", "output": "{\n\treturn &FieldValueSetRequest{\n\t\tBaseRequest: BaseRequest{baseURL: b.baseURL, client: b.client},\n\t}\n}"}
{"input": "package event\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\n\ntype Modified struct {\n\ttarget   Target\n\tfinished bool\n}\n\n\nfunc NewModified(target Target) *Modified {\n\treturn &Modified{target: target}\n}\n\n\nfunc (e *Modified) Type() Type {\n\treturn ModifiedType\n}\n\n\n\n\n\nfunc (e *Modified) Cascade() bool {\n\treturn false\n}\n\n\nfunc (e *Modified) Finished() bool {\n\treturn e.finished\n}\n\n\nfunc (e *Modified) Finish() {\n\te.finished = true\n}\n\n\nfunc (e *Modified) String() string {\n\tvar buffer bytes.Buffer\n\tbuffer.WriteString(fmt.Sprintf(\"Modified[Target: %v\", e.target))\n\tif e.finished {\n\t\tbuffer.WriteString(\", Finished\")\n\t}\n\tbuffer.WriteString(\"]\")\n\treturn buffer.String()\n}\n\nfunc (e *Modified) Target() Target ", "output": "{\n\treturn e.target\n}"}
{"input": "package model\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/huaweicloud/huaweicloud-sdk-go-v3/core/utils\"\n\n\t\"errors\"\n\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/huaweicloud/huaweicloud-sdk-go-v3/core/converter\"\n\n\t\"strings\"\n)\n\n\ntype DetachServerVolumeRequest struct {\n\n\tServerId string `json:\"server_id\"`\n\n\tVolumeId string `json:\"volume_id\"`\n\n\tDeleteFlag *DetachServerVolumeRequestDeleteFlag `json:\"delete_flag,omitempty\"`\n}\n\n\n\ntype DetachServerVolumeRequestDeleteFlag struct {\n\tvalue string\n}\n\ntype DetachServerVolumeRequestDeleteFlagEnum struct {\n\tE_0 DetachServerVolumeRequestDeleteFlag\n\tE_1 DetachServerVolumeRequestDeleteFlag\n}\n\nfunc GetDetachServerVolumeRequestDeleteFlagEnum() DetachServerVolumeRequestDeleteFlagEnum {\n\treturn DetachServerVolumeRequestDeleteFlagEnum{\n\t\tE_0: DetachServerVolumeRequestDeleteFlag{\n\t\t\tvalue: \"0\",\n\t\t},\n\t\tE_1: DetachServerVolumeRequestDeleteFlag{\n\t\t\tvalue: \"1\",\n\t\t},\n\t}\n}\n\nfunc (c DetachServerVolumeRequestDeleteFlag) MarshalJSON() ([]byte, error) {\n\treturn utils.Marshal(c.value)\n}\n\nfunc (c *DetachServerVolumeRequestDeleteFlag) UnmarshalJSON(b []byte) error {\n\tmyConverter := converter.StringConverterFactory(\"string\")\n\tif myConverter != nil {\n\t\tval, err := myConverter.CovertStringToInterface(strings.Trim(string(b[:]), \"\\\"\"))\n\t\tif err == nil {\n\t\t\tc.value = val.(string)\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t} else {\n\t\treturn errors.New(\"convert enum data to string error\")\n\t}\n}\n\nfunc (o DetachServerVolumeRequest) String() string ", "output": "{\n\tdata, err := utils.Marshal(o)\n\tif err != nil {\n\t\treturn \"DetachServerVolumeRequest struct{}\"\n\t}\n\n\treturn strings.Join([]string{\"DetachServerVolumeRequest\", string(data)}, \" \")\n}"}
{"input": "package main\n\nimport (\n\t\"testing\"\n)\n\nfunc TestPerimeter(t *testing.T) {\n\trectangle := Rectangle{10.0, 10.0}\n\tgot := Perimeter(rectangle)\n\twant := 40.0\n\n\tif got != want {\n\t\tt.Errorf(\"got %.2f want %.2f\", got, want)\n\t}\n}\n\n\n\nfunc TestArea(t *testing.T) ", "output": "{\n\n\tareaTests := []struct {\n\t\tshape Shape\n\t\twant  float64\n\t}{\n\t\t{Rectangle{12, 6}, 72.0},\n\t\t{Circle{10}, 314.1592653589793},\n\t\t{Triangle{12, 6}, 36.0},\n\t}\n\n\tfor _, tt := range areaTests {\n\t\tgot := tt.shape.Area()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"got %.2f want %.2f\", got, tt.want)\n\t\t}\n\t}\n\n}"}
{"input": "package page\n\nimport (\n\t\"html/template\"\n\n\t\"github.com/gohugoio/hugo/lazy\"\n)\n\n\n\n\n\n\n\ntype LazyContentProvider struct {\n\tinit *lazy.Init\n\tcp   ContentProvider\n}\n\n\n\n\n\n\nfunc (lcp *LazyContentProvider) Reset() {\n\tlcp.init.Reset()\n}\n\nfunc (lcp *LazyContentProvider) Content() (interface{}, error) {\n\tlcp.init.Do()\n\treturn lcp.cp.Content()\n}\n\nfunc (lcp *LazyContentProvider) Plain() string {\n\tlcp.init.Do()\n\treturn lcp.cp.Plain()\n}\n\nfunc (lcp *LazyContentProvider) PlainWords() []string {\n\tlcp.init.Do()\n\treturn lcp.cp.PlainWords()\n}\n\nfunc (lcp *LazyContentProvider) Summary() template.HTML {\n\tlcp.init.Do()\n\treturn lcp.cp.Summary()\n}\n\nfunc (lcp *LazyContentProvider) Truncated() bool {\n\tlcp.init.Do()\n\treturn lcp.cp.Truncated()\n}\n\nfunc (lcp *LazyContentProvider) FuzzyWordCount() int {\n\tlcp.init.Do()\n\treturn lcp.cp.FuzzyWordCount()\n}\n\nfunc (lcp *LazyContentProvider) WordCount() int {\n\tlcp.init.Do()\n\treturn lcp.cp.WordCount()\n}\n\nfunc (lcp *LazyContentProvider) ReadingTime() int {\n\tlcp.init.Do()\n\treturn lcp.cp.ReadingTime()\n}\n\nfunc (lcp *LazyContentProvider) Len() int {\n\tlcp.init.Do()\n\treturn lcp.cp.Len()\n}\n\nfunc NewLazyContentProvider(f func() (ContentProvider, error)) *LazyContentProvider ", "output": "{\n\tlcp := LazyContentProvider{\n\t\tinit: lazy.New(),\n\t\tcp:   NopPage,\n\t}\n\tlcp.init.Add(func() (interface{}, error) {\n\t\tcp, err := f()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlcp.cp = cp\n\t\treturn nil, nil\n\t})\n\treturn &lcp\n}"}
{"input": "package server\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/summadb/summadb/database\"\n)\n\n\n\nfunc handlehttp(db *database.SummaDB, w http.ResponseWriter, r *http.Request) ", "output": "{\n\tw.Write([]byte(\"hello\"))\n}"}
{"input": "package learn\n\nimport (\n\t\"fmt\"\n)\n\ntype List struct {\n\tData     interface{}\n\tNextnode *List\n}\n\nfunc myPrint(t interface{}) {\n\tfmt.Println(t)\n}\n\n\nfunc (l *List) ListLength() int {\n\tvar i int = 0\n\tn := l\n\tfor n.Nextnode != nil {\n\t\ti++\n\t\tn = n.Nextnode\n\t}\n\treturn i + 1\n}\n\n\nfunc (l *List) GetEle(i int) (ele interface{}) {\n\tif i < 0 || i > l.ListLength() {\n\t\treturn nil\n\t}\n\tcur := l\n\tj := 1\n\tfor cur.Nextnode != nil {\n\t\tif j == i {\n\t\t\treturn cur.Data\n\t\t}\n\t\tj++\n\t\tcur = cur.Nextnode\n\n\t}\n\tif cur != nil && j == i {\n\t\treturn cur.Data\n\t}\n\treturn nil\n}\n\n\nfunc (l *List) ListInsert(i int, ele interface{}) bool {\n\tvar s List \n\tif i < 0 || i > l.ListLength() {\n\t\treturn false\n\t}\n\ts.Data = ele\n\tp := l\n\tj := 1\n\tfor j < i && p != nil {\n\t\tj++\n\t\tp = p.Nextnode\n\t}\n\tif p != nil && j <= i {\n\t\ts.Nextnode = p.Nextnode\n\t\tp.Nextnode = &s\n\t} else {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n\n\n\n\nfunc (l *List) ListAll() (all string) {\n\tp := l\n\tfor p != nil {\n\t\tall += fmt.Sprintf(\"%v+\", p.Data)\n\t\tp = p.Nextnode\n\t}\n\treturn all\n}\n\nfunc (l *List) ListDelete(i int) bool ", "output": "{\n\tp := l\n\tj := 1\n\tfor j < i && p != nil {\n\t\tj++\n\t\tp = p.Nextnode\n\t}\n\tif p == nil || j > i {\n\t\treturn false\n\t}\n\tp.Nextnode = p.Nextnode.Nextnode\n\treturn true\n}"}
{"input": "package saltboot\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/hortonworks/salt-bootstrap/saltboot/model\"\n)\n\n\n\nfunc HealthCheckHandler(w http.ResponseWriter, req *http.Request) ", "output": "{\n\tlog.Printf(\"[HealthCheckHandler] handleHealtchCheck executed\")\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tmodel.Response{Status: \"OK\", Version: Version + \"-\" + BuildTime}.WriteHttp(w)\n}"}
{"input": "package cli\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n\ntype Float64Flag struct {\n\tName   string\n\tValue  float64\n\tUsage  string\n\tEnvVar string\n\tHide   bool\n}\n\n\nfunc (f Float64Flag) String() string {\n\treturn withEnvHint(f.EnvVar, fmt.Sprintf(\"%s \\\"%v\\\"\\t%v\", prefixedNames(f.Name), f.Value, f.Usage))\n}\n\n\nfunc (f Float64Flag) Apply(set *flag.FlagSet) {\n\tif f.EnvVar != \"\" {\n\t\tfor _, envVar := range strings.Split(f.EnvVar, \",\") {\n\t\t\tenvVar = strings.TrimSpace(envVar)\n\t\t\tif envVal := os.Getenv(envVar); envVal != \"\" {\n\t\t\t\tenvValFloat, err := strconv.ParseFloat(envVal, 10)\n\t\t\t\tif err == nil {\n\t\t\t\t\tf.Value = float64(envValFloat)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\teachName(f.Name, func(name string) {\n\t\tset.Float64(name, f.Value, f.Usage)\n\t})\n}\n\nfunc (f Float64Flag) getName() string {\n\treturn f.Name\n}\n\n\n\nfunc (f Float64Flag) isNotHidden() bool ", "output": "{\n\treturn !f.Hide\n}"}
{"input": "package dnsutil\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\n\t\"github.com/miekg/dns\"\n)\n\n\n\n\nfunc ParseHostPortOrFile(s ...string) ([]string, error) {\n\tvar servers []string\n\tfor _, host := range s {\n\t\taddr, _, err := net.SplitHostPort(host)\n\t\tif err != nil {\n\t\t\tif net.ParseIP(host) == nil {\n\t\t\t\tss, err := tryFile(host)\n\t\t\t\tif err == nil {\n\t\t\t\t\tservers = append(servers, ss...)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn servers, fmt.Errorf(\"not an IP address or file: %q\", host)\n\t\t\t}\n\t\t\tss := net.JoinHostPort(host, \"53\")\n\t\t\tservers = append(servers, ss)\n\t\t\tcontinue\n\t\t}\n\n\t\tif net.ParseIP(addr) == nil {\n\t\t\tss, err := tryFile(host)\n\t\t\tif err == nil {\n\t\t\t\tservers = append(servers, ss...)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn servers, fmt.Errorf(\"not an IP address or file: %q\", host)\n\t\t}\n\t\tservers = append(servers, host)\n\t}\n\treturn servers, nil\n}\n\n\nfunc tryFile(s string) ([]string, error) {\n\tc, err := dns.ClientConfigFromFile(s)\n\tif err == os.ErrNotExist {\n\t\treturn nil, fmt.Errorf(\"failed to open file %q: %q\", s, err)\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\n\tservers := []string{}\n\tfor _, s := range c.Servers {\n\t\tservers = append(servers, net.JoinHostPort(s, c.Port))\n\t}\n\treturn servers, nil\n}\n\n\n\n\n\nfunc ParseHostPort(s, defaultPort string) (string, error) ", "output": "{\n\taddr, port, err := net.SplitHostPort(s)\n\tif port == \"\" {\n\t\tport = defaultPort\n\t}\n\tif err != nil {\n\t\tif net.ParseIP(s) == nil {\n\t\t\treturn \"\", fmt.Errorf(\"must specify an IP address: `%s'\", s)\n\t\t}\n\t\treturn net.JoinHostPort(s, port), nil\n\t}\n\n\tif net.ParseIP(addr) == nil {\n\t\treturn \"\", fmt.Errorf(\"must specify an IP address: `%s'\", addr)\n\t}\n\treturn net.JoinHostPort(addr, port), nil\n}"}
{"input": "package experiments\n\n\n\ntype Experiment string\n\n\n\n\n\n\n\n\n\nconst (\n\n)\n\nfunc init() {\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc GetCurrent(name string) (Experiment, error) {\n\texp := Experiment(name)\n\tif currentExperiments.Has(exp) {\n\t\treturn exp, nil\n\t}\n\n\tif msg, concluded := concludedExperiments[exp]; concluded {\n\t\treturn Experiment(\"\"), ConcludedError{ExperimentName: name, Message: msg}\n\t}\n\n\treturn Experiment(\"\"), UnavailableError{ExperimentName: name}\n}\n\n\n\nfunc (e Experiment) Keyword() string {\n\treturn string(e)\n}\n\n\n\nfunc (e Experiment) IsCurrent() bool {\n\treturn currentExperiments.Has(e)\n}\n\n\nfunc (e Experiment) IsConcluded() bool {\n\t_, exists := concludedExperiments[e]\n\treturn exists\n}\n\n\n\n\n\nvar currentExperiments = make(Set)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar concludedExperiments = make(map[Experiment]string)\n\nfunc registerCurrentExperiment(exp Experiment) {\n\tcurrentExperiments.Add(exp)\n}\n\n\n\nfunc registerConcludedExperiment(exp Experiment, message string) ", "output": "{\n\tconcludedExperiments[exp] = message\n}"}
{"input": "package test\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t_ \"ApiManager/routers\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/astaxie/beego\"\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc init() {\n\t_, file, _, _ := runtime.Caller(1)\n\tapppath, _ := filepath.Abs(filepath.Dir(filepath.Join(file, \"..\"+string(filepath.Separator))))\n\tbeego.TestBeegoInit(apppath)\n}\n\n\n\n\nfunc TestMain(t *testing.T) ", "output": "{\n\tr, _ := http.NewRequest(\"GET\", \"/\", nil)\n\tw := httptest.NewRecorder()\n\tbeego.BeeApp.Handlers.ServeHTTP(w, r)\n\n\tbeego.Trace(\"testing\", \"TestMain\", \"Code[%d]\\n%s\", w.Code, w.Body.String())\n\n\tConvey(\"Subject: Test Station Endpoint\\n\", t, func() {\n\t\tConvey(\"Status Code Should Be 200\", func() {\n\t\t\tSo(w.Code, ShouldEqual, 200)\n\t\t})\n\t\tConvey(\"The Result Should Not Be Empty\", func() {\n\t\t\tSo(w.Body.Len(), ShouldBeGreaterThan, 0)\n\t\t})\n\t})\n}"}
{"input": "package authorization\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/google/keytransparency/impl/authentication\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\tpb \"github.com/google/keytransparency/core/api/v1/keytransparency_go_proto\"\n\tauthzpb \"github.com/google/keytransparency/impl/authorization/authz_go_proto\"\n)\n\n\ntype AuthzFunc func(context.Context, interface{}) error\n\n\ntype AuthzPolicy struct {\n\tPolicy *authzpb.AuthorizationPolicy\n}\n\n\n\n\n\n\nfunc (a *AuthzPolicy) Authorize(ctx context.Context, m interface{}) error {\n\tsctx, ok := authentication.FromContext(ctx)\n\tif !ok {\n\t\treturn status.Error(codes.Unauthenticated, \"Request does not contain a ValidatedSecurity object\")\n\t}\n\n\tswitch t := m.(type) {\n\tcase *pb.UpdateEntryRequest:\n\t\treturn a.checkPermission(sctx, t.DirectoryId, t.EntryUpdate.UserId)\n\tdefault:\n\t\treturn status.Errorf(codes.PermissionDenied, \"message type %T not recognized\", t)\n\t}\n}\n\n\n\nfunc resourceLabel(directoryID string) (string, error) {\n\tif strings.Contains(directoryID, \"/\") {\n\t\treturn \"\", status.Errorf(codes.InvalidArgument, \"resource label contains invalid character '/'\")\n\t}\n\treturn fmt.Sprintf(\"directories/%v\", directoryID), nil\n}\n\nfunc isPrincipalInRole(role *authzpb.AuthorizationPolicy_Role, identity string) bool {\n\tfor _, p := range role.GetPrincipals() {\n\t\tif p == identity {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (a *AuthzPolicy) checkPermission(sctx *authentication.SecurityContext, directoryID, userID string) error ", "output": "{\n\tif sctx.Email == userID {\n\t\treturn nil\n\t}\n\n\trLabel, err := resourceLabel(directoryID)\n\tif err != nil {\n\t\treturn err\n\t}\n\troles, ok := a.Policy.GetResourceToRoleLabels()[rLabel]\n\tif !ok {\n\t\treturn status.Errorf(codes.PermissionDenied, \"%v does not have a defined policy\", rLabel)\n\t}\n\tfor _, l := range roles.GetLabels() {\n\t\trole := a.Policy.GetRoles()[l]\n\t\tif isPrincipalInRole(role, sctx.Email) {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn status.Errorf(codes.PermissionDenied, \"%v is not authorized to act on %v\", sctx.Email, rLabel)\n}"}
{"input": "package user\n\nimport (\n\t\"os/user\"\n)\n\n\ntype User struct {\n\t*user.User\n\tGroupname string\n\tUidNo int\n\tGidNo int\n}\n\n\n\n\n\nfunc Lookup(username string) (*User, error) {\n\tu, err := user.Lookup(username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn lookupGroup(u)\n}\n\n\nfunc LookupId(uid string) (*User, error) {\n\tu, err := user.LookupId(uid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn lookupGroup(u)\n}\n\nfunc Current() (*User, error) ", "output": "{\n\tu, err := user.Current()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn lookupGroup(u)\n}"}
{"input": "package httpclient\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype Foo struct {\n\tArgs    map[string]string `json:\"args\"`\n\tHeaders struct {\n\t\tAccept                    string `json:\"Accept\"`\n\t\tAccept_Encoding           string `json:\"Accept-Encoding\"`\n\t\tAccept_Language           string `json:\"Accept-Language\"`\n\t\tConnection                string `json:\"Connection\"`\n\t\tHost                      string `json:\"Host\"`\n\t\tUpgrade_Insecure_Requests string `json:\"Upgrade-Insecure-Requests\"`\n\t\tUser_Agent                string `json:\"User-Agent\"`\n\t} `json:\"headers\"`\n\tOrigin string `json:\"origin\"`\n\tURL    string `json:\"url\"`\n}\n\nfunc TestString(t *testing.T) {\n\treq := Get(context.Background(), \"http://httpbin.org/get\")\n\tresp, err := req.String()\n\tassert.Nil(t, err)\n\tassert.NotEmpty(t, resp)\n}\n\nfunc TestBytes(t *testing.T) {\n\treq := Get(context.Background(), \"http://httpbin.org/get\")\n\tresp, err := req.Bytes()\n\tassert.Nil(t, err)\n\tassert.NotEmpty(t, resp)\n}\n\n\n\nfunc TestTimeout(t *testing.T) {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Duration(1*time.Millisecond))\n\tdefer cancel()\n\treq := Get(ctx, \"http://httpbin.org/get\")\n\tresp, err := req.String()\n\tassert.Regexp(t, \"context deadline exceeded\", err)\n\tassert.Empty(t, resp)\n}\n\nfunc TestToJSON(t *testing.T) ", "output": "{\n\treq := Get(context.Background(), \"http://httpbin.org/get?a=b\")\n\tfoo := new(Foo)\n\terr := req.ToJSON(foo)\n\tassert.Nil(t, err)\n\tassert.Len(t, foo.Args, 1)\n\tassert.Equal(t, \"http://httpbin.org/get?a=b\", foo.URL)\n}"}
{"input": "package eng\n\nimport (\n\t\"math\"\n\n\t\"github.com/antha-lang/antha/antha/anthalib/wunit\"\n)\n\n\n\nfunc CentripetalForce(mass wunit.Mass, angularfrequency float64, radius wunit.Length) (force wunit.Force) {\n\tforcefloat := mass.SIValue() * math.Pow(angularfrequency, 2) * radius.SIValue()\n\tforce = wunit.NewForce(forcefloat, \"N\")\n\treturn force\n}\n\nfunc Angularfrequency(frequency float64) (angularfrequency float64) {\n\treturn 2 * math.Pi * frequency\n}\n\n\n\nfunc KLa_squaremicrowell(D float64, dv float64, ai float64, RE float64, a float64, froude float64, b float64) float64 {\n\treturn ((3.94E-4) * (D / dv) * ai * (math.Pow(RE, 1.91)) * (math.Pow(math.E, (a * (math.Pow(froude, b))))))\n} \n\nfunc RE(ro float64, n float64, mu float64, dv float64) float64 { \n\n\treturn (ro * n * dv * 2 / mu)\n}\n\n\n\nfunc Froude(dt float64, n float64, g float64) float64 { \n\treturn (dt * (math.Pow((2 * math.Pi * n), 2)) / (2 * g))\n}\n\nconst G float64 = 9.81 \n\n\n\nfunc Ncrit_srw(sigma float64, dv float64, Vl float64, ro float64, dt float64) wunit.Rate {\n\trps := math.Sqrt((sigma * dv) / (4 * math.Pi * Vl * ro * dt)) \n\trate, err := wunit.NewRate(rps, \"/s\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn rate\n}\n\nfunc Shakerspeed(TargetRE float64, ro float64, mu float64, dv float64) wunit.Rate  ", "output": "{ \n\trps := (TargetRE * mu / (ro * dv * 2))\n\trate, err := wunit.NewRate(rps, \"/s\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn rate\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\t\"strconv\"\n\t\"text/template\"\n\n\t\"github.com/pkg/browser\"\n)\n\n\n\nfunc webMain(w http.ResponseWriter, r *http.Request) {\n\thtmlBody := `<h1>Mail Classifier</h1>\n    <p><h2><a href=\"/gmailFetch\">E-Mails from Gmail</a></p>\n    <p><h2><a href=\"/crawlerMain\">Crawler</a></p>\n    `\n\n\tw.Write([]byte(htmlBody))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", webMain)\n\thttp.HandleFunc(\"/crawlerMain\", webCrawlerMedium)\n\thttp.ListenAndServe(\":8080\", nil)\n\tbrowser.OpenURL(\"http://localhost:8080\")\n}\n\nfunc webCrawlerMain(w http.ResponseWriter, r *http.Request) ", "output": "{\n\thtmlBody := `<h1>Crawler</h1>\n    <p><h2><a href=\"/crawlerQuora\">Quora</a></p>\n    <p><h2><a href=\"/crawlerMedium\">Medium</a></p>\n    `\n\n\tw.Write([]byte(htmlBody))\n}"}
{"input": "package golog\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/mndrix/golog/term\"\n\t\"github.com/mndrix/ps\"\n)\n\n\n\n\n\n\ntype clauses struct {\n\tn         int64 \n\tlowestId  int64\n\thighestId int64\n\tterms     ps.Map \n}\n\n\nfunc newClauses() *clauses {\n\tvar cs clauses\n\tcs.terms = ps.NewMap()\n\treturn &cs\n}\n\n\nfunc (self *clauses) count() int64 {\n\treturn self.n\n}\n\n\n\n\n\nfunc (self *clauses) snoc(t term.Term) *clauses {\n\tcs := self.clone()\n\tcs.n++\n\tcs.highestId++\n\tkey := strconv.FormatInt(cs.highestId, 10)\n\tcs.terms = self.terms.Set(key, t)\n\treturn cs\n}\n\n\nfunc (self *clauses) all() []term.Term {\n\tterms := make([]term.Term, 0)\n\tif self.count() == 0 {\n\t\treturn terms\n\t}\n\n\tfor i := self.lowestId; i <= self.highestId; i++ {\n\t\tkey := strconv.FormatInt(i, 10)\n\t\tt, ok := self.terms.Lookup(key)\n\t\tif ok {\n\t\t\tterms = append(terms, t.(term.Term))\n\t\t}\n\t}\n\treturn terms\n}\n\n\nfunc (self *clauses) forEach(f func(term.Term)) {\n\tfor _, t := range self.all() {\n\t\tf(t)\n\t}\n}\n\n\nfunc (self *clauses) clone() *clauses {\n\tcs := *self\n\treturn &cs\n}\n\nfunc (self *clauses) cons(t term.Term) *clauses ", "output": "{\n\tcs := self.clone()\n\tcs.n++\n\tcs.lowestId--\n\tkey := strconv.FormatInt(cs.lowestId, 10)\n\tcs.terms = self.terms.Set(key, t)\n\treturn cs\n}"}
{"input": "package gatt\n\nimport (\n\t\"errors\"\n\t\"io\"\n\n\t\"github.com/bettercap/gatt/linux/cmd\"\n)\n\n\n\n\n\n\n\nfunc LnxDeviceID(n int, chk bool) Option {\n\treturn func(d Device) error {\n\t\td.(*device).devID = n\n\t\td.(*device).chkLE = chk\n\t\treturn nil\n\t}\n}\n\n\n\n\nfunc LnxMaxConnections(n int) Option {\n\treturn func(d Device) error {\n\t\td.(*device).maxConn = n\n\t\treturn nil\n\t}\n}\n\n\n\nfunc LnxSetAdvertisingEnable(en bool) Option {\n\treturn func(d Device) error {\n\t\tdd := d.(*device)\n\t\tif dd == nil {\n\t\t\treturn errors.New(\"device is not initialized\")\n\t\t}\n\t\tif err := dd.update(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn dd.hci.SetAdvertiseEnable(en)\n\t}\n}\n\n\n\n\n\n\n\nfunc LnxSetScanResponseData(c *cmd.LESetScanResponseData) Option {\n\treturn func(d Device) error {\n\t\td.(*device).scanResp = c\n\t\treturn nil\n\t}\n}\n\n\n\nfunc LnxSetAdvertisingParameters(c *cmd.LESetAdvertisingParameters) Option {\n\treturn func(d Device) error {\n\t\td.(*device).advParam = c\n\t\treturn nil\n\t}\n}\n\n\n\nfunc LnxSendHCIRawCommand(c cmd.CmdParam, rsp io.Writer) Option {\n\treturn func(d Device) error {\n\t\tb, err := d.(*device).SendHCIRawCommand(c)\n\t\tif rsp == nil {\n\t\t\treturn err\n\t\t}\n\t\trsp.Write(b)\n\t\treturn err\n\t}\n}\n\nfunc LnxSetAdvertisingData(c *cmd.LESetAdvertisingData) Option ", "output": "{\n\treturn func(d Device) error {\n\t\td.(*device).advData = c\n\t\treturn nil\n\t}\n}"}
{"input": "package aws\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/aws/aws-sdk-go/service/outposts\"\n\t\"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource\"\n\t\"github.com/hashicorp/terraform-plugin-sdk/v2/terraform\"\n)\n\nfunc TestAccAWSOutpostsSitesDataSource_basic(t *testing.T) {\n\tdataSourceName := \"data.aws_outposts_sites.test\"\n\n\tresource.ParallelTest(t, resource.TestCase{\n\t\tPreCheck:     func() { testAccPreCheck(t); testAccPreCheckAWSOutpostsSites(t) },\n\t\tProviders:    testAccProviders,\n\t\tCheckDestroy: nil,\n\t\tSteps: []resource.TestStep{\n\t\t\t{\n\t\t\t\tConfig: testAccAWSOutpostsSitesDataSourceConfig(),\n\t\t\t\tCheck: resource.ComposeTestCheckFunc(\n\t\t\t\t\ttestAccCheckOutpostsSitesAttributes(dataSourceName),\n\t\t\t\t),\n\t\t\t},\n\t\t},\n\t})\n}\n\nfunc testAccCheckOutpostsSitesAttributes(dataSourceName string) resource.TestCheckFunc {\n\treturn func(s *terraform.State) error {\n\t\trs, ok := s.RootModule().Resources[dataSourceName]\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"Not found: %s\", dataSourceName)\n\t\t}\n\n\t\tif v := rs.Primary.Attributes[\"ids.#\"]; v == \"0\" {\n\t\t\treturn fmt.Errorf(\"expected at least one ids result, got none\")\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n\n\nfunc testAccAWSOutpostsSitesDataSourceConfig() string {\n\treturn `\ndata \"aws_outposts_sites\" \"test\" {}\n`\n}\n\nfunc testAccPreCheckAWSOutpostsSites(t *testing.T) ", "output": "{\n\tconn := testAccProvider.Meta().(*AWSClient).outpostsconn\n\n\tinput := &outposts.ListSitesInput{}\n\n\toutput, err := conn.ListSites(input)\n\n\tif testAccPreCheckSkipError(err) {\n\t\tt.Skipf(\"skipping acceptance testing: %s\", err)\n\t}\n\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected PreCheck error: %s\", err)\n\t}\n\n\tif output == nil || len(output.Sites) == 0 {\n\t\tt.Skip(\"skipping since no Sites Outpost found\")\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/gabriel-comeau/tbuikit\"\n\t\"github.com/nsf/termbox-go\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc doDisconnect(uiElement, event interface{}) {\n\tdisconnect()\n}\n\n\nfunc chatEnterHandler(uiElement, event interface{}) {\n\twidget, ok := uiElement.(*tbuikit.TextInputWidget)\n\tif ok {\n\t\tnetChatChan <- widget.GetBuffer().ReturnAndClear() + \"\\n\"\n\t}\n}\n\n\n\n\n\n\nfunc calculateTopTitleBar() (x1, x2, y1, y2 int) {\n\tw := tbuikit.GetTermboxWidth()\n\tx1 = 1\n\tx2 = w - 1\n\ty1 = 1\n\ty2 = TITLE_BAR_HEIGHT\n\treturn\n}\n\n\nfunc calculateChatBufferRect() (x1, x2, y1, y2 int) {\n\tw, h := termbox.Size()\n\tx1 = 1\n\tx2 = w - 1\n\ty1 = (h / 2) + (h / 4)\n\ty2 = h - 2\n\treturn\n}\n\n\n\n\n\nfunc calculateWhoRect() (x1, x2, y1, y2 int) {\n\tw, h := termbox.Size()\n\tx1 = w - (w / 4) + 1\n\tx2 = w - 1\n\ty1 = TITLE_BAR_HEIGHT + 6\n\ty2 = (h / 2) + (h / 4) - 1\n\treturn\n}\n\n\nfunc calculateWhoLabelRect() (x1, x2, y1, y2 int) {\n\tw := tbuikit.GetTermboxWidth()\n\tx1 = w - (w / 4) + 1\n\tx2 = w - 1\n\ty1 = TITLE_BAR_HEIGHT + 1\n\ty2 = TITLE_BAR_HEIGHT + 5\n\treturn\n}\n\nfunc calculateMessageBufferRect() (x1, x2, y1, y2 int) ", "output": "{\n\tw, h := termbox.Size()\n\tx1 = 1\n\tx2 = w - (w / 4)\n\ty1 = TITLE_BAR_HEIGHT + 1\n\ty2 = (h / 2) + (h / 4) - 1\n\treturn\n}"}
{"input": "package middleware\n\nimport \"gopkg.in/macaron.v1\"\n\n\n\nfunc SetMiddlewares(m *macaron.Macaron) ", "output": "{\n\n\tm.Use(macaron.Recovery())\n}"}
{"input": "package fake\n\nimport (\n\tpolicy \"k8s.io/api/policy/v1beta1\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\tcore \"k8s.io/client-go/testing\"\n)\n\n\n\nfunc (c *FakeEvictions) Evict(eviction *policy.Eviction) error ", "output": "{\n\taction := core.CreateActionImpl{}\n\taction.Verb = \"create\"\n\taction.Namespace = c.ns\n\taction.Resource = schema.GroupVersionResource{Group: \"\", Version: \"v1\", Resource: \"pods\"}\n\taction.Subresource = \"eviction\"\n\taction.Object = eviction\n\n\t_, err := c.Fake.Invokes(action, eviction)\n\treturn err\n}"}
{"input": "package networkloadbalancer\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ChangeNetworkLoadBalancerCompartmentRequest struct {\n\n\tNetworkLoadBalancerId *string `mandatory:\"true\" contributesTo:\"path\" name:\"networkLoadBalancerId\"`\n\n\tChangeNetworkLoadBalancerCompartmentDetails `contributesTo:\"body\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request ChangeNetworkLoadBalancerCompartmentRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request ChangeNetworkLoadBalancerCompartmentRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request ChangeNetworkLoadBalancerCompartmentRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request ChangeNetworkLoadBalancerCompartmentRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ChangeNetworkLoadBalancerCompartmentResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response ChangeNetworkLoadBalancerCompartmentResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\n\n\nfunc (response ChangeNetworkLoadBalancerCompartmentResponse) HTTPResponse() *http.Response ", "output": "{\n\treturn response.RawResponse\n}"}
{"input": "package tables\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/juju/errors\"\n\t\"github.com/pingcap/tidb/ast\"\n\t\"github.com/pingcap/tidb/model\"\n\t\"github.com/pingcap/tidb/parser\"\n)\n\n\nfunc getDefaultCharsetAndCollate() (string, string) {\n\treturn \"utf8\", \"utf8_bin\"\n}\n\n\n\ntype nameResolver struct {\n\ttableInfo *model.TableInfo\n\terr       error\n}\n\n\nfunc (nr *nameResolver) Enter(inNode ast.Node) (ast.Node, bool) {\n\treturn inNode, false\n}\n\n\n\n\n\n\n\n\nfunc parseExpression(expr string) (node ast.ExprNode, err error) {\n\texpr = fmt.Sprintf(\"select %s\", expr)\n\tcharset, collation := getDefaultCharsetAndCollate()\n\tstmts, err := parser.New().Parse(expr, charset, collation)\n\tif err == nil {\n\t\tnode = stmts[0].(*ast.SelectStmt).Fields.Fields[0].Expr\n\t}\n\treturn node, errors.Trace(err)\n}\n\n\nfunc simpleResolveName(node ast.ExprNode, tblInfo *model.TableInfo) (ast.ExprNode, error) {\n\tnr := nameResolver{tblInfo, nil}\n\tif _, ok := node.Accept(&nr); !ok {\n\t\treturn nil, errors.Trace(nr.err)\n\t}\n\treturn node, nil\n}\n\nfunc (nr *nameResolver) Leave(inNode ast.Node) (node ast.Node, ok bool) ", "output": "{\n\tswitch v := inNode.(type) {\n\tcase *ast.ColumnNameExpr:\n\t\tfor _, col := range nr.tableInfo.Columns {\n\t\t\tif col.Name.L == v.Name.Name.L {\n\t\t\t\tv.Refer = &ast.ResultField{\n\t\t\t\t\tColumn: col,\n\t\t\t\t\tTable:  nr.tableInfo,\n\t\t\t\t}\n\t\t\t\treturn inNode, true\n\t\t\t}\n\t\t}\n\t\tnr.err = errors.Errorf(\"can't find column %s in %s\", v.Name.Name.O, nr.tableInfo.Name.O)\n\t\treturn inNode, false\n\t}\n\treturn inNode, true\n}"}
{"input": "package slack\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\n\n\n\n\n\n\n\ntype backoff struct {\n\tattempts int\n\tInitial time.Duration\n\tJitter time.Duration\n\tMax time.Duration\n}\n\n\n\nfunc (b *backoff) Duration() (dur time.Duration) {\n\tif b.Max == 0 {\n\t\tb.Max = 10 * time.Second\n\t}\n\n\tif b.Initial == 0 {\n\t\tb.Initial = 100 * time.Millisecond\n\t}\n\n\tif dur = time.Duration(1 << uint(b.attempts)); dur > 0 {\n\t\tdur = dur * b.Initial\n\t} else {\n\t\tdur = b.Max\n\t}\n\n\tif b.Jitter > 0 {\n\t\tdur = dur + time.Duration(rand.Intn(int(b.Jitter)))\n\t}\n\n\tb.attempts++\n\n\treturn dur\n}\n\n\n\n\nfunc (b *backoff) Reset() ", "output": "{\n\tb.attempts = 0\n}"}
{"input": "package unit\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc TestPressureFormat(t *testing.T) {\n\tt.Parallel()\n\tfor _, test := range []struct {\n\t\tvalue  Pressure\n\t\tformat string\n\t\twant   string\n\t}{\n\t\t{1.23456789, \"%v\", \"1.23456789 Pa\"},\n\t\t{1.23456789, \"%.1v\", \"1 Pa\"},\n\t\t{1.23456789, \"%20.1v\", \"                1 Pa\"},\n\t\t{1.23456789, \"%20v\", \"       1.23456789 Pa\"},\n\t\t{1.23456789, \"%1v\", \"1.23456789 Pa\"},\n\t\t{1.23456789, \"%#v\", \"unit.Pressure(1.23456789)\"},\n\t\t{1.23456789, \"%s\", \"%!s(unit.Pressure=1.23456789 Pa)\"},\n\t} {\n\t\tgot := fmt.Sprintf(test.format, test.value)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Format %q %v: got: %q want: %q\", test.format, test.value, got, test.want)\n\t\t}\n\t}\n}\n\nfunc TestPressure(t *testing.T) ", "output": "{\n\tt.Parallel()\n\tfor _, value := range []float64{-1, 0, 1} {\n\t\tvar got Pressure\n\t\terr := got.From(Pressure(value).Unit())\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected error for %T conversion: %v\", got, err)\n\t\t}\n\t\tif got != Pressure(value) {\n\t\t\tt.Errorf(\"unexpected result from round trip of %T(%v): got: %v want: %v\", got, value, got, value)\n\t\t}\n\t\tif got != got.Pressure() {\n\t\t\tt.Errorf(\"unexpected result from self interface method call: got: %#v want: %#v\", got, value)\n\t\t}\n\t\terr = got.From(ether(1))\n\t\tif err == nil {\n\t\t\tt.Errorf(\"expected error for ether to %T conversion\", got)\n\t\t}\n\t}\n}"}
{"input": "package engine\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n\t\"testing\"\n)\n\nfunc TestEngineChef(t *testing.T) {\n\teng := new(engineChef)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}\n\nfunc TestEngineGeneric(t *testing.T) {\n\teng := new(engineGeneric)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}\n\nfunc TestEngineGolang(t *testing.T) {\n\teng := new(engineGolang)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}\n\nfunc TestEngineNode(t *testing.T) {\n\teng := new(engineNode)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}\n\n\n\nfunc TestEngineRuby(t *testing.T) {\n\teng := new(engineRuby)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}\n\nfunc TestEnginePython(t *testing.T) ", "output": "{\n\teng := new(enginePython)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}"}
{"input": "package mem\n\nimport (\n\t\"bytes\"\n\t\"sort\"\n\n\tsgmt \"github.com/m3db/m3/src/m3ninx/index/segment\"\n)\n\ntype bytesSliceIter struct {\n\terr  error\n\tdone bool\n\n\tcurrentIdx   int\n\tcurrent      []byte\n\tbackingSlice [][]byte\n\topts         Options\n}\n\nvar _ sgmt.FieldsIterator = &bytesSliceIter{}\n\nfunc newBytesSliceIter(slice [][]byte, opts Options) *bytesSliceIter {\n\tsortSliceOfByteSlices(slice)\n\treturn &bytesSliceIter{\n\t\tcurrentIdx:   -1,\n\t\tbackingSlice: slice,\n\t\topts:         opts,\n\t}\n}\n\nfunc (b *bytesSliceIter) Next() bool {\n\tif b.done || b.err != nil {\n\t\treturn false\n\t}\n\tb.currentIdx++\n\tif b.currentIdx >= len(b.backingSlice) {\n\t\tb.done = true\n\t\treturn false\n\t}\n\tb.current = b.backingSlice[b.currentIdx]\n\treturn true\n}\n\nfunc (b *bytesSliceIter) Current() []byte {\n\treturn b.current\n}\n\n\n\nfunc (b *bytesSliceIter) Len() int {\n\treturn len(b.backingSlice)\n}\n\nfunc (b *bytesSliceIter) Close() error {\n\tb.current = nil\n\tb.opts.BytesSliceArrayPool().Put(b.backingSlice)\n\treturn nil\n}\n\nfunc sortSliceOfByteSlices(b [][]byte) {\n\tsort.Slice(b, func(i, j int) bool {\n\t\treturn bytes.Compare(b[i], b[j]) < 0\n\t})\n}\n\nfunc (b *bytesSliceIter) Err() error ", "output": "{\n\treturn nil\n}"}
{"input": "package test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/nats-io/gnatsd/server\"\n\t\"github.com/nats-io/nats\"\n\n\tgnatsd \"github.com/nats-io/gnatsd/test\"\n)\n\n\ntype tLogger interface {\n\tFatalf(format string, args ...interface{})\n\tErrorf(format string, args ...interface{})\n}\n\ntype TestLogger tLogger\n\n\n\n\nfunc WaitTime(ch chan bool, timeout time.Duration) error {\n\tselect {\n\tcase <-ch:\n\t\treturn nil\n\tcase <-time.After(timeout):\n\t}\n\treturn errors.New(\"timeout\")\n}\n\n\n\n\n\nfunc NewDefaultConnection(t tLogger) *nats.Conn {\n\treturn NewConnection(t, nats.DefaultPort)\n}\n\nfunc NewConnection(t tLogger, port int) *nats.Conn {\n\turl := fmt.Sprintf(\"nats://localhost:%d\", port)\n\tnc, err := nats.Connect(url)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create default connection: %v\\n\", err)\n\t\treturn nil\n\t}\n\treturn nc\n}\n\nfunc NewEConn(t tLogger) *nats.EncodedConn {\n\tec, err := nats.NewEncodedConn(NewDefaultConnection(t), nats.DEFAULT_ENCODER)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create an encoded connection: %v\\n\", err)\n\t}\n\treturn ec\n}\n\n\n\n\n\nfunc RunDefaultServer() *server.Server {\n\treturn RunServerOnPort(nats.DefaultPort)\n}\n\nfunc RunServerOnPort(port int) *server.Server {\n\topts := gnatsd.DefaultTestOptions\n\topts.Port = port\n\treturn RunServerWithOptions(opts)\n}\n\nfunc RunServerWithOptions(opts server.Options) *server.Server {\n\treturn gnatsd.RunServer(&opts)\n}\n\nfunc Wait(ch chan bool) error ", "output": "{\n\treturn WaitTime(ch, 5*time.Second)\n}"}
{"input": "package router\n\n\n\n\nimport (\n\t\"github.com/weaveworks/mesh\"\n)\n\n\n\ntype AWSVPCConnection struct {\n\testablishedChan chan struct{}\n\terrorChan       chan error\n}\n\nfunc (conn *AWSVPCConnection) Confirm() {\n\tclose(conn.establishedChan)\n}\n\nfunc (conn *AWSVPCConnection) EstablishedChannel() <-chan struct{} {\n\treturn conn.establishedChan\n}\n\nfunc (conn *AWSVPCConnection) ErrorChannel() <-chan error {\n\treturn conn.errorChan\n}\n\nfunc (conn *AWSVPCConnection) Stop() {}\n\nfunc (conn *AWSVPCConnection) ControlMessage(tag byte, msg []byte) {\n}\n\nfunc (conn *AWSVPCConnection) DisplayName() string {\n\treturn \"awsvpc\"\n}\n\n\n\nfunc (conn *AWSVPCConnection) Forward(key ForwardPacketKey) FlowOp {\n\treturn DiscardingFlowOp{}\n}\n\ntype AWSVPC struct{}\n\nfunc NewAWSVPC() AWSVPC {\n\treturn AWSVPC{}\n}\n\n\n\nfunc (vpc AWSVPC) AddFeaturesTo(features map[string]string) {}\n\nfunc (vpc AWSVPC) PrepareConnection(params mesh.OverlayConnectionParams) (mesh.OverlayConnection, error) {\n\tconn := &AWSVPCConnection{\n\t\testablishedChan: make(chan struct{}),\n\t\terrorChan:       make(chan error, 1),\n\t}\n\treturn conn, nil\n}\n\n\n\n\n\nfunc (vpc AWSVPC) InvalidateRoutes() {}\n\nfunc (vpc AWSVPC) InvalidateShortIDs() {}\n\nfunc (vpc AWSVPC) StartConsumingPackets(localPeer *mesh.Peer, peers *mesh.Peers, consumer OverlayConsumer) error {\n\treturn nil\n}\n\nfunc (vpc AWSVPC) Diagnostics() interface{} ", "output": "{\n\treturn nil\n}"}
{"input": "package gtk_mock\n\nimport \"github.com/twstrike/coyim/Godeps/_workspace/src/github.com/twstrike/gotk3adapter/gtki\"\n\ntype MockTextView struct {\n\tMockContainer\n}\n\nfunc (*MockTextView) SetEditable(v1 bool) {\n}\n\nfunc (*MockTextView) SetCursorVisible(v1 bool) {\n}\n\nfunc (*MockTextView) SetBuffer(v1 gtki.TextBuffer) {\n}\n\nfunc (*MockTextView) GetBuffer() (gtki.TextBuffer, error) {\n\treturn nil, nil\n}\n\nfunc (*MockTextView) ForwardDisplayLine(gtki.TextIter) bool {\n\treturn false\n}\n\nfunc (*MockTextView) BackwardDisplayLine(gtki.TextIter) bool {\n\treturn false\n}\n\nfunc (*MockTextView) ForwardDisplayLineEnd(gtki.TextIter) bool {\n\treturn false\n}\n\nfunc (*MockTextView) BackwardDisplayLineStart(gtki.TextIter) bool {\n\treturn false\n}\n\nfunc (*MockTextView) StartsDisplayLine(gtki.TextIter) bool {\n\treturn false\n}\n\n\n\nfunc (*MockTextView) MoveVisually(gtki.TextIter, int) bool ", "output": "{\n\treturn false\n}"}
{"input": "package helper\n\nimport (\n\t\"bufio\"\n\t\"net\"\n)\n\ntype BufConn struct {\n\tnet.Conn\n\tBR *bufio.Reader\n}\n\nfunc (c *BufConn) Peek(n int) ([]byte, error) {\n\treturn c.BR.Peek(n)\n}\n\nfunc (c *BufConn) Read(b []byte) (n int, err error) {\n\treturn c.BR.Read(b)\n}\n\n\n\nfunc (c *BufConn) Reset(conn net.Conn) {\n\tc.Conn = conn\n}\n\nfunc NewBufConn(c net.Conn, r *bufio.Reader) *BufConn {\n\tconn := &BufConn{Conn: c}\n\tconn.BR = r\n\tif nil == r {\n\t\tconn.BR = bufio.NewReader(c)\n\t}\n\treturn conn\n}\n\nfunc (c *BufConn) Write(b []byte) (n int, err error) ", "output": "{\n\treturn c.Conn.Write(b)\n}"}
{"input": "package main\n\nimport (\n\t\"time\"\n\n\t\"github.com/PalmStoneGames/polymer\"\n)\n\n\n\ntype Timer struct {\n\t*polymer.Proto\n\n\tTime time.Time `polymer:\"bind\"`\n}\n\nfunc (t *Timer) Created() {\n\tgo func() {\n\t\tfor {\n\t\t\tt.Time = time.Now()\n\n\t\t\tt.Notify(\"time\")\n\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t}\n\t}()\n}\n\nfunc (t *Timer) ComputeTime() string {\n\treturn t.Time.String()\n}\n\nfunc main() {}\n\nfunc init() ", "output": "{\n\tpolymer.Register(\"tick-timer\", &Timer{})\n}"}
{"input": "package go1\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar (\n\tgobbytes []byte\n\tgobdata  *JSONResponse\n)\n\n\n\n\nfunc gobResponse(r *JSONResponse) *JSONResponse {\n\treturn &JSONResponse{gobNode(r.Tree), r.Username}\n}\n\nfunc gobNode(n *JSONNode) *JSONNode {\n\tn1 := new(JSONNode)\n\t*n1 = *n\n\tif len(n1.Kids) == 0 {\n\t\tn1.Kids = nil\n\t} else {\n\t\tfor i, k := range n1.Kids {\n\t\t\tn1.Kids[i] = gobNode(k)\n\t\t}\n\t}\n\treturn n1\n}\n\nfunc gobdec() {\n\tif gobbytes == nil {\n\t\tpanic(\"gobdata not initialized\")\n\t}\n\tvar r JSONResponse\n\tif err := gob.NewDecoder(bytes.NewBuffer(gobbytes)).Decode(&r); err != nil {\n\t\tpanic(err)\n\t}\n\t_ = r\n}\n\nfunc gobenc() {\n\tif err := gob.NewEncoder(ioutil.Discard).Encode(&gobdata); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc BenchmarkGobDecode(b *testing.B) {\n\tb.SetBytes(int64(len(gobbytes)))\n\tfor i := 0; i < b.N; i++ {\n\t\tgobdec()\n\t}\n}\n\nfunc BenchmarkGobEncode(b *testing.B) {\n\tb.SetBytes(int64(len(gobbytes)))\n\tfor i := 0; i < b.N; i++ {\n\t\tgobenc()\n\t}\n}\n\nfunc init() ", "output": "{\n\tgobdata = gobResponse(&jsondata)\n\n\tvar buf bytes.Buffer\n\tif err := gob.NewEncoder(&buf).Encode(gobdata); err != nil {\n\t\tpanic(err)\n\t}\n\tgobbytes = buf.Bytes()\n\n\tvar r JSONResponse\n\tif err := gob.NewDecoder(bytes.NewBuffer(gobbytes)).Decode(&r); err != nil {\n\t\tpanic(err)\n\t}\n\tif !reflect.DeepEqual(gobdata, &r) {\n\t\tlog.Printf(\"%v\\n%v\", jsondata, r)\n\t\tb, _ := json.Marshal(&jsondata)\n\t\tbr, _ := json.Marshal(&r)\n\t\tlog.Printf(\"%s\\n%s\\n\", b, br)\n\t\tpanic(\"gob: encode+decode lost data\")\n\t}\n}"}
{"input": "package repositories\n\n\n\n\nimport (\n\t\"net/http\"\n\n\tmiddleware \"github.com/go-openapi/runtime/middleware\"\n)\n\n\ntype GetOwnerRepositoriesHandlerFunc func(GetOwnerRepositoriesParams) middleware.Responder\n\n\nfunc (fn GetOwnerRepositoriesHandlerFunc) Handle(params GetOwnerRepositoriesParams) middleware.Responder {\n\treturn fn(params)\n}\n\n\ntype GetOwnerRepositoriesHandler interface {\n\tHandle(GetOwnerRepositoriesParams) middleware.Responder\n}\n\n\nfunc NewGetOwnerRepositories(ctx *middleware.Context, handler GetOwnerRepositoriesHandler) *GetOwnerRepositories {\n\treturn &GetOwnerRepositories{Context: ctx, Handler: handler}\n}\n\n\ntype GetOwnerRepositories struct {\n\tContext *middleware.Context\n\tHandler GetOwnerRepositoriesHandler\n}\n\n\n\nfunc (o *GetOwnerRepositories) ServeHTTP(rw http.ResponseWriter, r *http.Request) ", "output": "{\n\troute, rCtx, _ := o.Context.RouteInfo(r)\n\tif rCtx != nil {\n\t\tr = rCtx\n\t}\n\tvar Params = NewGetOwnerRepositoriesParams()\n\n\tif err := o.Context.BindValidRequest(r, route, &Params); err != nil { \n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\n\tres := o.Handler.Handle(Params) \n\n\to.Context.Respond(rw, r, route.Produces, route, res)\n\n}"}
{"input": "package daemon\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-openapi/runtime\"\n\n\t\"github.com/cilium/cilium/api/v1/models\"\n)\n\n\nconst GetMapNameOKCode int = 200\n\n\ntype GetMapNameOK struct {\n\n\tPayload *models.BPFMap `json:\"body,omitempty\"`\n}\n\n\n\n\n\nfunc (o *GetMapNameOK) WithPayload(payload *models.BPFMap) *GetMapNameOK {\n\to.Payload = payload\n\treturn o\n}\n\n\nfunc (o *GetMapNameOK) SetPayload(payload *models.BPFMap) {\n\to.Payload = payload\n}\n\n\nfunc (o *GetMapNameOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {\n\n\trw.WriteHeader(200)\n\tif o.Payload != nil {\n\t\tpayload := o.Payload\n\t\tif err := producer.Produce(rw, payload); err != nil {\n\t\t\tpanic(err) \n\t\t}\n\t}\n}\n\n\nconst GetMapNameNotFoundCode int = 404\n\n\ntype GetMapNameNotFound struct {\n}\n\n\nfunc NewGetMapNameNotFound() *GetMapNameNotFound {\n\n\treturn &GetMapNameNotFound{}\n}\n\n\nfunc (o *GetMapNameNotFound) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {\n\n\trw.Header().Del(runtime.HeaderContentType) \n\n\trw.WriteHeader(404)\n}\n\nfunc NewGetMapNameOK() *GetMapNameOK ", "output": "{\n\n\treturn &GetMapNameOK{}\n}"}
{"input": "package bleve\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/blevesearch/bleve/index\"\n\t\"github.com/blevesearch/bleve/search\"\n\t\"github.com/blevesearch/bleve/search/searchers\"\n)\n\ntype matchAllQuery struct {\n\tBoostVal float64 `json:\"boost,omitempty\"`\n}\n\n\n\nfunc NewMatchAllQuery() *matchAllQuery {\n\treturn &matchAllQuery{\n\t\tBoostVal: 1.0,\n\t}\n}\n\n\n\nfunc (q *matchAllQuery) SetBoost(b float64) Query {\n\tq.BoostVal = b\n\treturn q\n}\n\nfunc (q *matchAllQuery) Searcher(i index.IndexReader, m *IndexMapping, explain bool) (search.Searcher, error) {\n\treturn searchers.NewMatchAllSearcher(i, q.BoostVal, explain)\n}\n\nfunc (q *matchAllQuery) Validate() error {\n\treturn nil\n}\n\nfunc (q *matchAllQuery) Field() string {\n\treturn \"\"\n}\n\nfunc (q *matchAllQuery) SetField(f string) Query {\n\treturn q\n}\n\nfunc (q *matchAllQuery) MarshalJSON() ([]byte, error) {\n\ttmp := map[string]interface{}{\n\t\t\"boost\":     q.BoostVal,\n\t\t\"match_all\": map[string]interface{}{},\n\t}\n\treturn json.Marshal(tmp)\n}\n\nfunc (q *matchAllQuery) Boost() float64 ", "output": "{\n\treturn q.BoostVal\n}"}
{"input": "package bits_test\n\nimport (\n\t\"github.com/twmb/bits\"\n\t\"testing\"\n)\n\nfunc TestSet(t *testing.T) {\n\tfor i := 0; i < 256; i++ {\n\t\tif int(bits.SetU32(uint32(i))) != bits.Hamming(i, 0) {\n\t\t\tt.Errorf(\"Error in set: wanted %v for %v, got %v\",\n\t\t\t\tbits.Hamming(i, 0), i, bits.SetU32(uint32(i)))\n\t\t}\n\t}\n}\n\nfunc BenchmarkSetTable(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tbits.SetTable(i)\n\t}\n}\nfunc BenchmarkSetKernighan(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tbits.SetKernighan(uint(i))\n\t}\n}\nfunc BenchmarkSetU32(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tbits.SetU32(uint32(i))\n\t}\n}\n\n\nfunc BenchmarkSetU64(b *testing.B) ", "output": "{\n\tfor i := 0; i < b.N; i++ {\n\t\tbits.SetU64(uint64(i))\n\t}\n}"}
{"input": "package glfw\n\n\nimport \"C\"\n\n\n\n\n\n\n\nfunc GetTime() float64 {\n\treturn float64(C.glfwGetTime())\n}\n\n\n\n\n\n\n\n\n\nfunc SetTime(time float64) ", "output": "{\n\tC.glfwSetTime(C.double(time))\n}"}
{"input": "package mysql\n\nimport (\n\t\"net\"\n)\n\n\nfunc dial(address, socket string) (net.Conn, error) {\n\tvar (\n\t\tc       net.Conn\n\t\taddr    string\n\t\tnetwork string\n\t\terr     error\n\t)\n\n\tif socket != \"\" {\n\t\tnetwork, addr = \"socket\", socket\n\t} else {\n\t\tnetwork, addr = \"tcp\", address\n\t}\n\n\tif c, err = net.Dial(network, addr); err != nil {\n\t\treturn nil, myError(ErrConnection, err)\n\t}\n\treturn c, nil\n\n}\n\n\n\ntype readWriter interface {\n\tinit(c *Conn)\n\n\tread(b []byte, length int) (int, error)\n\n\twrite([]byte) (int, error)\n\n\treset()\n}\n\n\n\ntype defaultReadWriter struct {\n\tc *Conn\n}\n\n\nfunc (rw *defaultReadWriter) init(c *Conn) {\n\trw.c = c\n}\n\n\n\nfunc (rw *defaultReadWriter) read(b []byte, length int) (int, error) {\n\treturn rw.c.netRead(b[0:length])\n}\n\n\nfunc (rw *defaultReadWriter) write(b []byte) (int, error) {\n\treturn rw.c.netWrite(b)\n}\n\n\nfunc (rw *defaultReadWriter) reset() {\n}\n\n\n\nfunc (c *Conn) netRead(b []byte) (int, error) {\n\tvar (\n\t\tn, cur, end int\n\t\terr         error\n\t)\n\n\tend = len(b)\n\n\tfor {\n\t\tif n, err = c.conn.Read(b[cur:end]); err != nil {\n\n\t\t\tcur += n\n\t\t\treturn cur, myError(ErrRead, err)\n\t\t}\n\t\tcur += n\n\t\tif cur == end {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn end, nil\n}\n\n\n\n\nfunc (c *Conn) netWrite(b []byte) (int, error) ", "output": "{\n\tvar (\n\t\tn, cur, end int\n\t\terr         error\n\t)\n\n\tend = len(b)\n\n\tfor {\n\t\tif n, err = c.conn.Write(b[cur:end]); err != nil {\n\t\t\tcur += n\n\t\t\treturn cur, myError(ErrWrite, err)\n\t\t}\n\t\tcur += n\n\t\tif cur == end {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn end, nil\n}"}
{"input": "package types\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"sort\"\n)\n\n\ntype PluginsListResponse []*Plugin\n\n\nfunc (t *PluginInterfaceType) UnmarshalJSON(p []byte) error {\n\tversionIndex := len(p)\n\tprefixIndex := 0\n\tif len(p) < 2 || p[0] != '\"' || p[len(p)-1] != '\"' {\n\t\treturn fmt.Errorf(\"%q is not a plugin interface type\", p)\n\t}\n\tp = p[1 : len(p)-1]\nloop:\n\tfor i, b := range p {\n\t\tswitch b {\n\t\tcase '.':\n\t\t\tprefixIndex = i\n\t\tcase '/':\n\t\t\tversionIndex = i\n\t\t\tbreak loop\n\t\t}\n\t}\n\tt.Prefix = string(p[:prefixIndex])\n\tt.Capability = string(p[prefixIndex+1 : versionIndex])\n\tif versionIndex < len(p) {\n\t\tt.Version = string(p[versionIndex+1:])\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc (t PluginInterfaceType) String() string {\n\treturn fmt.Sprintf(\"%s.%s/%s\", t.Prefix, t.Capability, t.Version)\n}\n\n\n\ntype PluginPrivilege struct {\n\tName        string\n\tDescription string\n\tValue       []string\n}\n\n\ntype PluginPrivileges []PluginPrivilege\n\nfunc (s PluginPrivileges) Len() int {\n\treturn len(s)\n}\n\nfunc (s PluginPrivileges) Less(i, j int) bool {\n\treturn s[i].Name < s[j].Name\n}\n\nfunc (s PluginPrivileges) Swap(i, j int) {\n\tsort.Strings(s[i].Value)\n\tsort.Strings(s[j].Value)\n\ts[i], s[j] = s[j], s[i]\n}\n\nfunc (t *PluginInterfaceType) MarshalJSON() ([]byte, error) ", "output": "{\n\treturn json.Marshal(t.String())\n}"}
{"input": "package remotestate\n\nimport (\n\t\"context\"\n\n\t\"github.com/r3labs/terraform/backend\"\n\t\"github.com/r3labs/terraform/helper/schema\"\n\t\"github.com/r3labs/terraform/state\"\n\t\"github.com/r3labs/terraform/state/remote\"\n\t\"github.com/r3labs/terraform/terraform\"\n)\n\n\n\n\n\n\ntype Backend struct {\n\t*schema.Backend\n\n\tConfigureFunc func(ctx context.Context) (remote.Client, error)\n\n\tclient remote.Client\n}\n\n\n\nfunc (b *Backend) States() ([]string, error) {\n\treturn nil, backend.ErrNamedStatesNotSupported\n}\n\nfunc (b *Backend) DeleteState(name string) error {\n\treturn backend.ErrNamedStatesNotSupported\n}\n\nfunc (b *Backend) State(name string) (state.State, error) {\n\tif b.client == nil {\n\t\tpanic(\"nil remote client\")\n\t}\n\n\tif name != backend.DefaultStateName {\n\t\treturn nil, backend.ErrNamedStatesNotSupported\n\t}\n\n\ts := &remote.State{Client: b.client}\n\treturn s, nil\n}\n\nfunc (b *Backend) Configure(rc *terraform.ResourceConfig) error ", "output": "{\n\tb.Backend.ConfigureFunc = func(ctx context.Context) error {\n\t\tc, err := b.ConfigureFunc(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tb.client = c\n\t\treturn nil\n\t}\n\n\treturn b.Backend.Configure(rc)\n}"}
{"input": "package s0104\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc Answer_Old() interface{} {\n\tn := 2\n\tfcurr := new(big.Int).SetInt64(1)\n\tfprev := new(big.Int).SetInt64(1)\n\ttmp := new(big.Int)\n\tfor {\n\t\ttmp.Add(fcurr, fprev)\n\t\tfcurr, fprev, tmp = tmp, fcurr, fprev\n\t\tn++\n\t\tstr := fcurr.String()\n\t\tif len(str) >= 9 && IsAllDigits(str[:9]) && IsAllDigits(str[len(str)-9:]) {\n\t\t\treturn n\n\t\t}\n\t}\n}\n\n\n\nfunc Answer() interface{} {\n\tn := 2\n\n\tfCurrBack := int64(1)\n\tfPrevBack := int64(1)\n\n\tfCurrFront := float64(1)\n\tfPrevFront := float64(1)\n\n\tfor {\n\t\tfCurrBack, fPrevBack = (fCurrBack+fPrevBack)%1e9, fCurrBack\n\t\tfCurrFront, fPrevFront = fCurrFront+fPrevFront, fCurrFront\n\t\tif fCurrFront >= 1e9 {\n\t\t\tfCurrFront /= 10\n\t\t\tfPrevFront /= 10\n\t\t}\n\t\tn++\n\t\tif IsAllDigits(fmt.Sprintf(\"%d\", fCurrBack)) &&\n\t\t\tIsAllDigits(fmt.Sprintf(\"%d\", int(fCurrFront))) {\n\t\t\treturn n\n\t\t}\n\t}\n}\n\nfunc IsAllDigits(s string) bool ", "output": "{\n\tif len(s) < 9 {\n\t\treturn false\n\t}\n\tvar set [9]bool\n\tfor _, r := range s {\n\t\tif r == '0' {\n\t\t\treturn false\n\t\t}\n\t\tif set[r-'1'] {\n\t\t\treturn false\n\t\t}\n\t\tset[r-'1'] = true\n\t}\n\treturn true\n}"}
{"input": "package tfs\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/richardwilkes/toolbox/errs\"\n)\n\ntype vfs struct {\n\tstorage  string\n\tname     string\n\toffset   int64\n\tlength   int64\n\tmode     os.FileMode\n\tmodTime  time.Time\n\tchildren []*vfs\n}\n\nfunc (v *vfs) Name() string {\n\treturn v.name\n}\n\nfunc (v *vfs) Size() int64 {\n\treturn v.length\n}\n\nfunc (v *vfs) Mode() os.FileMode {\n\treturn v.mode\n}\n\nfunc (v *vfs) ModTime() time.Time {\n\treturn v.modTime\n}\n\nfunc (v *vfs) IsDir() bool {\n\treturn (v.mode & os.ModeDir) == os.ModeDir\n}\n\nfunc (v *vfs) Sys() interface{} {\n\treturn nil\n}\n\n\n\nfunc (v *vfs) open() (http.File, error) ", "output": "{\n\tif v.IsDir() {\n\t\treturn &vdir{owner: v}, nil\n\t}\n\tf, err := os.Open(v.storage)\n\tif err != nil {\n\t\treturn nil, errs.NewWithCausef(err, \"Unable to open %s\", v.name)\n\t}\n\treturn &vfile{\n\t\towner: v,\n\t\tfile:  f,\n\t\tsr:    io.NewSectionReader(f, v.offset, v.length),\n\t}, nil\n}"}
{"input": "package rundmc\n\nimport (\n\t\"strings\"\n\t\"sync\"\n)\n\n\n\ntype Properties interface {\n\tSet(handle string, key string, value string)\n\tGet(handle string, key string) (string, bool)\n}\n\ntype events struct {\n\tprops Properties\n\tmu    sync.Mutex\n}\n\nfunc NewEventStore(props Properties) *events {\n\treturn &events{\n\t\tprops: props,\n\t}\n}\n\nfunc (e *events) OnEvent(handle, event string) error {\n\te.mu.Lock()\n\tdefer e.mu.Unlock()\n\n\tevents := append(e.Events(handle), event)\n\te.props.Set(handle, \"rundmc.events\", strings.Join(events, \",\"))\n\treturn nil\n}\n\nfunc (e *events) Events(handle string) []string {\n\tif value, ok := e.props.Get(handle, \"rundmc.events\"); ok {\n\t\treturn strings.Split(value, \",\")\n\t}\n\n\treturn nil\n}\n\ntype states struct {\n\tprops Properties\n}\n\nfunc NewStateStore(props Properties) *states {\n\treturn &states{\n\t\tprops: props,\n\t}\n}\n\nfunc (s *states) StoreStopped(handle string) {\n\ts.props.Set(handle, \"rundmc.state\", \"stopped\")\n}\n\n\n\nfunc (s *states) IsStopped(handle string) bool ", "output": "{\n\tvalue, ok := s.props.Get(handle, \"rundmc.state\")\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn value == \"stopped\"\n}"}
{"input": "package botReactions\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/bwmarrin/discordgo\"\n\n\t\"github.com/adayoung/ada-bot/settings\"\n)\n\ntype decide struct {\n\tTrigger string\n}\n\nfunc (d *decide) Help() string {\n\treturn \"Let the bot decide between two or more things for you!\"\n}\n\nfunc (d *decide) HelpDetail() string {\n\treturn d.Help()\n}\n\nfunc (d *decide) Reaction(m *discordgo.Message, a *discordgo.Member, mType string) Reaction {\n\tchoices := strings.Split(m.Content[len(settings.Settings.Discord.BotPrefix)+len(d.Trigger):], \" or \")\n\ttheAnswer := choices[rand.Intn(len(choices))]\n\tresponse := fmt.Sprintf(\"The correct answer is **%s**\", strings.TrimSpace(theAnswer))\n\treturn Reaction{Text: response}\n}\n\n\n\nfunc init() ", "output": "{\n\trand.Seed(time.Now().Unix())\n\n\t_decide := &decide{\n\t\tTrigger: \"decide\",\n\t}\n\taddReaction(_decide.Trigger, \"CREATE\", _decide)\n}"}
{"input": "package errs\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/uther/go-uther/logger\"\n)\n\nfunc testErrors() *Errors {\n\treturn &Errors{\n\t\tPackage: \"TEST\",\n\t\tErrors: map[int]string{\n\t\t\t0: \"zero\",\n\t\t\t1: \"one\",\n\t\t},\n\t\tLevel: func(i int) (l logger.LogLevel) {\n\t\t\tif i == 0 {\n\t\t\t\tl = logger.ErrorLevel\n\t\t\t} else {\n\t\t\t\tl = logger.WarnLevel\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t}\n}\n\n\n\nfunc TestErrorSeverity(t *testing.T) {\n\terr0 := testErrors().New(0, \"zero detail\")\n\tif !err0.Fatal() {\n\t\tt.Errorf(\"error should be fatal\")\n\t}\n\terr1 := testErrors().New(1, \"one detail\")\n\tif err1.Fatal() {\n\t\tt.Errorf(\"error should not be fatal\")\n\t}\n}\n\nfunc TestErrorMessage(t *testing.T) ", "output": "{\n\terr := testErrors().New(0, \"zero detail %v\", \"available\")\n\tmessage := fmt.Sprintf(\"%v\", err)\n\texp := \"[TEST] ERROR: zero: zero detail available\"\n\tif message != exp {\n\t\tt.Errorf(\"error message incorrect. expected %v, got %v\", exp, message)\n\t}\n}"}
{"input": "package v1\n\nimport (\n\t\"k8s.io/kubernetes/pkg/api/unversioned\"\n\t\"k8s.io/kubernetes/pkg/runtime\"\n)\n\nconst GroupName = \"\"\n\n\nvar SchemeGroupVersion = unversioned.GroupVersion{Group: GroupName, Version: \"v1\"}\n\nfunc AddToScheme(scheme *runtime.Scheme) {\n\taddKnownTypes(scheme)\n\taddConversionFuncs(scheme)\n}\n\n\n\n\nfunc (obj *ProjectRequest) GetObjectKind() unversioned.ObjectKind { return &obj.TypeMeta }\nfunc (obj *Project) GetObjectKind() unversioned.ObjectKind        { return &obj.TypeMeta }\nfunc (obj *ProjectList) GetObjectKind() unversioned.ObjectKind    { return &obj.TypeMeta }\n\nfunc addKnownTypes(scheme *runtime.Scheme) ", "output": "{\n\tscheme.AddKnownTypes(SchemeGroupVersion,\n\t\t&Project{},\n\t\t&ProjectList{},\n\t\t&ProjectRequest{},\n\t)\n}"}
{"input": "package consul\n\nimport (\n\t\"sync\"\n)\n\n\n\n\n\ntype NotifyGroup struct {\n\tl      sync.Mutex\n\tnotify []chan struct{}\n}\n\n\n\nfunc (n *NotifyGroup) Notify() {\n\tn.l.Lock()\n\tdefer n.l.Unlock()\n\tfor _, ch := range n.notify {\n\t\tselect {\n\t\tcase ch <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t}\n\tn.notify = n.notify[:0]\n}\n\n\nfunc (n *NotifyGroup) Wait(ch chan struct{}) {\n\tn.l.Lock()\n\tdefer n.l.Unlock()\n\tn.notify = append(n.notify, ch)\n}\n\n\n\n\nfunc (n *NotifyGroup) WaitCh() chan struct{} ", "output": "{\n\tch := make(chan struct{}, 1)\n\tn.Wait(ch)\n\treturn ch\n}"}
{"input": "package darwini\n\nimport (\n\t\"net/http\"\n)\n\n\n\n\n\n\n\ntype Method struct {\n\tGET    http.HandlerFunc\n\tPOST   http.HandlerFunc\n\tPUT    http.HandlerFunc\n\tPATCH  http.HandlerFunc\n\tDELETE http.HandlerFunc\n\tCustom map[string]http.HandlerFunc\n}\n\nvar _ http.Handler = Method{}\n\n\n\nfunc (m Method) err(w http.ResponseWriter, req *http.Request) {\n\tif m.GET != nil {\n\t\tw.Header().Add(\"Allow\", \"GET\")\n\t}\n\tif m.POST != nil {\n\t\tw.Header().Add(\"Allow\", \"POST\")\n\t}\n\tif m.PUT != nil {\n\t\tw.Header().Add(\"Allow\", \"PUT\")\n\t}\n\tif m.PATCH != nil {\n\t\tw.Header().Add(\"Allow\", \"PATCH\")\n\t}\n\tif m.DELETE != nil {\n\t\tw.Header().Add(\"Allow\", \"DELETE\")\n\t}\n\tfor k, v := range m.Custom {\n\t\tif v != nil {\n\t\t\tw.Header().Add(\"Allow\", k)\n\t\t}\n\t}\n\thttp.Error(w, \"method not allowed\", http.StatusMethodNotAllowed)\n}\n\nfunc (m Method) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\th := m.get(req.Method)\n\tif h == nil {\n\t\tm.err(w, req)\n\t\treturn\n\t}\n\th.ServeHTTP(w, req)\n}\n\nfunc (m Method) get(method string) http.HandlerFunc ", "output": "{\n\tswitch method {\n\tcase \"GET\":\n\t\treturn m.GET\n\tcase \"POST\":\n\t\treturn m.POST\n\tcase \"PUT\":\n\t\treturn m.PUT\n\tcase \"PATCH\":\n\t\treturn m.PATCH\n\tcase \"DELETE\":\n\t\treturn m.DELETE\n\tdefault:\n\t\treturn m.Custom[method]\n\t}\n}"}
{"input": "package gmx\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\n\n\n\n\nfunc localSocketAddr() *net.TCPAddr {\n\treturn &net.TCPAddr{\n\t\tIP:   net.IPv4(127, 0, 0, 1),\n\t\tPort: 0,\n\t}\n}\n\nfunc localSocket() (net.Listener, error) ", "output": "{\n\tlistener, err := net.ListenTCP(\"tcp\", localSocketAddr())\n\tif err == nil {\n\t\t_, ok := listener.Addr().(net.Addr)\n\t\tif ok {\n\t\t\tfmt.Println(\"Listening at \", listener.Addr().String())\n\t\t}\n\t}\n\treturn listener, err\n}"}
{"input": "package config\n\nvar activeConfig map[string]*ServiceConfig\n\nfunc init() {\n\tactiveConfig = make(map[string]*ServiceConfig)\n}\n\n\n\n\nfunc RecordActiveConfig(serviceConfig *ServiceConfig) {\n\tif serviceConfig == nil || serviceConfig.Listener == nil {\n\t\treturn\n\t}\n\n\tactiveConfig[serviceConfig.Listener.Name] = serviceConfig\n\n\tserviceConfig.LogConfig()\n}\n\n\n\nfunc ActiveConfigForListener(listenerName string) *ServiceConfig {\n\treturn activeConfig[listenerName]\n}\n\n\n\n\n\nfunc ActiveListenerNames() []string ", "output": "{\n\tkeys := make([]string, len(activeConfig))\n\n\ti := 0\n\tfor k := range activeConfig {\n\t\tkeys[i] = k\n\t\ti++\n\t}\n\n\treturn keys\n}"}
{"input": "package storage\n\nimport (\n\t\"context\"\n)\n\n\n\n\nfunc NewTransactionOrDie(ctx context.Context, store Store, params ...TransactionParams) Transaction {\n\ttxn, err := store.NewTransaction(ctx, params...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn txn\n}\n\n\n\n\nfunc ReadOne(ctx context.Context, store Store, path Path) (interface{}, error) {\n\ttxn, err := store.NewTransaction(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer store.Abort(ctx, txn)\n\n\treturn store.Read(ctx, txn, path)\n}\n\n\n\n\nfunc WriteOne(ctx context.Context, store Store, op PatchOp, path Path, value interface{}) error {\n\ttxn, err := store.NewTransaction(ctx, WriteParams)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := store.Write(ctx, txn, op, path, value); err != nil {\n\t\tstore.Abort(ctx, txn)\n\t\treturn err\n\t}\n\n\treturn store.Commit(ctx, txn)\n}\n\n\n\n\n\n\n\nfunc Txn(ctx context.Context, store Store, params TransactionParams, f func(Transaction) error) error ", "output": "{\n\n\ttxn, err := store.NewTransaction(ctx, params)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := f(txn); err != nil {\n\t\tstore.Abort(ctx, txn)\n\t\treturn err\n\t}\n\n\treturn store.Commit(ctx, txn)\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/snapcore/snapd/seed\"\n)\n\nvar (\n\tRun                      = run\n\tSystemSnapFromSeed       = systemSnapFromSeed\n\tChooseTargetSnapdVersion = chooseTargetSnapdVersion\n)\n\nfunc MockOsGetuid(f func() int) (restore func()) {\n\toldOsGetuid := osGetuid\n\tosGetuid = f\n\treturn func() { osGetuid = oldOsGetuid }\n}\n\nfunc MockSyscallChroot(f func(string) error) (restore func()) {\n\toldSyscallChroot := syscallChroot\n\tsyscallChroot = f\n\treturn func() { syscallChroot = oldSyscallChroot }\n}\n\nfunc MockSnapdMountPath(path string) (restore func()) {\n\toldMountPath := snapdMountPath\n\tsnapdMountPath = path\n\treturn func() { snapdMountPath = oldMountPath }\n}\n\nfunc MockSystemSnapFromSeed(f func(rootDir string) (string, error)) (restore func()) {\n\toldSystemSnapFromSeed := systemSnapFromSeed\n\tsystemSnapFromSeed = f\n\treturn func() { systemSnapFromSeed = oldSystemSnapFromSeed }\n}\n\nfunc MockSeedOpen(f func(rootDir, label string) (seed.Seed, error)) (restore func()) {\n\toldSeedOpen := seedOpen\n\tseedOpen = f\n\treturn func() {\n\t\tseedOpen = oldSeedOpen\n\t}\n}\n\n\n\nfunc SnapdPathAndVersion(targetSnapd *targetSnapdInfo) (string, string) ", "output": "{\n\treturn targetSnapd.path, targetSnapd.version\n}"}
{"input": "package cmdtest\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"github.com/pkg/errors\"\n)\n\ntype Transport struct {\n\tMessage string\n\tStatus  int\n\tHeaders map[string][]string\n}\n\nfunc (t *Transport) RoundTrip(req *http.Request) (resp *http.Response, err error) {\n\tvar statusText string\n\tif text := http.StatusText(t.Status); text != \"\" {\n\t\tstatusText = fmt.Sprintf(\"%d %s\", t.Status, text)\n\t} else {\n\t\tstatusText = fmt.Sprintf(\"%d status code %d\", t.Status, t.Status)\n\t}\n\tresp = &http.Response{\n\t\tBody:       ioutil.NopCloser(bytes.NewBufferString(t.Message)),\n\t\tStatus:     statusText,\n\t\tStatusCode: t.Status,\n\t\tHeader:     http.Header(t.Headers),\n\t}\n\treturn resp, nil\n}\n\ntype ConditionalTransport struct {\n\tTransport\n\tCondFunc func(*http.Request) bool\n}\n\nfunc (t *ConditionalTransport) RoundTrip(req *http.Request) (*http.Response, error) {\n\tif !t.CondFunc(req) {\n\t\treturn &http.Response{Body: nil, StatusCode: 500}, errors.New(\"condition failed\")\n\t}\n\treturn t.Transport.RoundTrip(req)\n}\n\ntype MultiConditionalTransport struct {\n\tConditionalTransports []ConditionalTransport\n}\n\nfunc (m *MultiConditionalTransport) RoundTrip(req *http.Request) (*http.Response, error) {\n\tct := m.ConditionalTransports[0]\n\tm.ConditionalTransports = m.ConditionalTransports[1:]\n\treturn ct.RoundTrip(req)\n}\n\ntype AnyConditionalTransport struct {\n\tConditionalTransports []ConditionalTransport\n}\n\n\n\nfunc (m *AnyConditionalTransport) RoundTrip(req *http.Request) (*http.Response, error) ", "output": "{\n\tfor _, ct := range m.ConditionalTransports {\n\t\tif ct.CondFunc(req) {\n\t\t\treturn ct.Transport.RoundTrip(req)\n\t\t}\n\t}\n\treturn &http.Response{Body: nil, StatusCode: 500}, errors.New(\"all conditions failed\")\n}"}
{"input": "package gzip\n\nimport (\n\t\"net/http\"\n\t\"path\"\n\n\t\"github.com/mholt/caddy/middleware\"\n)\n\n\ntype Filter interface {\n\tShouldCompress(*http.Request) bool\n}\n\n\nvar defaultExtensions = []string{\"\", \".txt\", \".htm\", \".html\", \".css\", \".php\", \".js\", \".json\", \".md\", \".xml\"}\n\n\n\n\n\ntype ExtFilter struct {\n\tExts Set\n}\n\n\nconst ExtWildCard = \"*\"\n\n\n\n\nfunc (e ExtFilter) ShouldCompress(r *http.Request) bool {\n\text := path.Ext(r.URL.Path)\n\treturn e.Exts.Contains(ExtWildCard) || e.Exts.Contains(ext)\n}\n\n\ntype PathFilter struct {\n\tIgnoredPaths Set\n}\n\n\n\n\nfunc (p PathFilter) ShouldCompress(r *http.Request) bool {\n\treturn !p.IgnoredPaths.ContainsFunc(func(value string) bool {\n\t\treturn middleware.Path(r.URL.Path).Matches(value)\n\t})\n}\n\n\ntype Set map[string]struct{}\n\n\nfunc (s Set) Add(value string) {\n\ts[value] = struct{}{}\n}\n\n\nfunc (s Set) Remove(value string) {\n\tdelete(s, value)\n}\n\n\nfunc (s Set) Contains(value string) bool {\n\t_, ok := s[value]\n\treturn ok\n}\n\n\n\n\nfunc (s Set) ContainsFunc(f func(string) bool) bool {\n\tfor k := range s {\n\t\tif f(k) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc DefaultExtFilter() ExtFilter ", "output": "{\n\tm := ExtFilter{Exts: make(Set)}\n\tfor _, extension := range defaultExtensions {\n\t\tm.Exts.Add(extension)\n\t}\n\treturn m\n}"}
{"input": "package iso20022\n\n\ntype FinancialInstrumentDetails14 struct {\n\n\tFinancialInstrumentIdentification *SecurityIdentification14 `xml:\"FinInstrmId\"`\n\n\tFinancialInstrumentAttributes *FinancialInstrumentAttributes36 `xml:\"FinInstrmAttrbts,omitempty\"`\n\n\tSubBalance []*IntraPositionDetails28 `xml:\"SubBal\"`\n}\n\nfunc (f *FinancialInstrumentDetails14) AddFinancialInstrumentIdentification() *SecurityIdentification14 {\n\tf.FinancialInstrumentIdentification = new(SecurityIdentification14)\n\treturn f.FinancialInstrumentIdentification\n}\n\n\n\nfunc (f *FinancialInstrumentDetails14) AddSubBalance() *IntraPositionDetails28 {\n\tnewValue := new(IntraPositionDetails28)\n\tf.SubBalance = append(f.SubBalance, newValue)\n\treturn newValue\n}\n\nfunc (f *FinancialInstrumentDetails14) AddFinancialInstrumentAttributes() *FinancialInstrumentAttributes36 ", "output": "{\n\tf.FinancialInstrumentAttributes = new(FinancialInstrumentAttributes36)\n\treturn f.FinancialInstrumentAttributes\n}"}
{"input": "package help\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\ntype EvtPool struct {\n\theader DListNode\n}\n\nfunc (this *EvtPool) Init() {\n\tthis.header.Init(nil)\n}\n\nfunc (this *EvtPool) Eat(name string) {\n\tfmt.Printf(\"吃%s\\n\", name)\n}\n\nfunc (this *EvtPool) Post(d IEvent) bool {\n\n\tn := &DListNode{}\n\tn.Init(d)\n\n\tif !d.AddNode(n) {\n\t\treturn false\n\t}\n\n\told_pre := this.header.Pre\n\n\tthis.header.Pre = n\n\tn.Next = &this.header\n\tn.Pre = old_pre\n\told_pre.Next = n\n\n\treturn true\n}\n\nfunc (this *EvtPool) Run() {\n\tfor {\n\t\tif this.header.IsEmpty() {\n\t\t\tbreak\n\t\t}\n\n\t\tn := this.header.Next\n\n\t\tn.Data.(IEvent).Exec(this)\n\n\t\tn.Data.(IEvent).Destroy()\n\t}\n}\n\ntype Evt_eat struct {\n\tEvt_base\n\tFoodName string\n}\n\nfunc (this *Evt_eat) Exec() bool {\n\treturn true\n}\n\n\n\nfunc TestDlist(t *testing.T) ", "output": "{\n\n\tvar g_Pool EvtPool\n\tg_Pool.Init()\n\n\tg_Pool.Post(&Evt_eat{FoodName: \"西瓜\"})\n\tg_Pool.Post(&Evt_eat{FoodName: \"葡萄\"})\n\tg_Pool.Post(&Evt_eat{FoodName: \"黄瓜\"})\n\tg_Pool.Post(&Evt_eat{FoodName: \"大蒜\"})\n\n\tg_Pool.Run()\n}"}
{"input": "package linebot\n\nimport (\n\t\"context\"\n\n\t\"github.com/line/line-bot-sdk-go/linebot\"\n\t\"github.com/utahta/momoclo-channel/config\"\n\t\"google.golang.org/appengine/urlfetch\"\n)\n\ntype (\n\tClient interface {\n\t\tReplyText(context.Context, string, string) error\n\t\tReplyImage(context.Context, string, string, string) error\n\t}\n\n\tclient struct {\n\t}\n)\n\n\nfunc New() Client {\n\treturn &client{}\n}\n\n\n\n\n\nfunc (c *client) ReplyImage(ctx context.Context, replyToken, originalContentURL, previewImageURL string) error {\n\tbot, err := c.fromContext(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\timageMessage := linebot.NewImageMessage(originalContentURL, previewImageURL)\n\tif _, err := bot.ReplyMessage(replyToken, imageMessage).Do(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *client) fromContext(ctx context.Context) (*linebot.Client, error) {\n\treturn linebot.New(\n\t\tconfig.C().LineBot.ChannelSecret,\n\t\tconfig.C().LineBot.ChannelToken,\n\t\tlinebot.WithHTTPClient(urlfetch.Client(ctx)),\n\t)\n}\n\nfunc (c *client) ReplyText(ctx context.Context, replyToken, text string) error ", "output": "{\n\tbot, err := c.fromContext(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttextMessage := linebot.NewTextMessage(text)\n\tif _, err := bot.ReplyMessage(replyToken, textMessage).Do(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package markcontrolplane\n\nimport (\n\t\"fmt\"\n\n\t\"k8s.io/api/core/v1\"\n\tclientset \"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/kubernetes/cmd/kubeadm/app/constants\"\n\t\"k8s.io/kubernetes/cmd/kubeadm/app/util/apiclient\"\n)\n\n\n\n\nfunc taintExists(taint v1.Taint, taints []v1.Taint) bool {\n\tfor _, t := range taints {\n\t\tif t == taint {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc markControlPlaneNode(n *v1.Node, taints []v1.Taint) {\n\tn.ObjectMeta.Labels[constants.LabelNodeRoleMaster] = \"\"\n\n\tfor _, nt := range n.Spec.Taints {\n\t\tif !taintExists(nt, taints) {\n\t\t\ttaints = append(taints, nt)\n\t\t}\n\t}\n\n\tn.Spec.Taints = taints\n}\n\nfunc MarkControlPlane(client clientset.Interface, controlPlaneName string, taints []v1.Taint) error ", "output": "{\n\n\tfmt.Printf(\"[mark-control-plane] Marking the node %s as control-plane by adding the label \\\"%s=''\\\"\\n\", controlPlaneName, constants.LabelNodeRoleMaster)\n\n\tif taints != nil && len(taints) > 0 {\n\t\ttaintStrs := []string{}\n\t\tfor _, taint := range taints {\n\t\t\ttaintStrs = append(taintStrs, taint.ToString())\n\t\t}\n\t\tfmt.Printf(\"[mark-control-plane] Marking the node %s as control-plane by adding the taints %v\\n\", controlPlaneName, taintStrs)\n\t}\n\n\treturn apiclient.PatchNode(client, controlPlaneName, func(n *v1.Node) {\n\t\tmarkControlPlaneNode(n, taints)\n\t})\n}"}
{"input": "package syscall\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Getpagesize() int { return 4096 }\n\nfunc Gettimeofday(tv *Timeval) (err error)\nfunc Time(t *Time_t) (tt Time_t, err error)\n\n\n\nfunc NsecToTimespec(nsec int64) (ts Timespec) {\n\tts.Sec = nsec / 1e9\n\tts.Nsec = nsec % 1e9\n\treturn\n}\n\nfunc TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }\n\nfunc NsecToTimeval(nsec int64) (tv Timeval) {\n\tnsec += 999 \n\ttv.Sec = nsec / 1e9\n\ttv.Usec = nsec % 1e9 / 1e3\n\treturn\n}\n\nfunc (r *PtraceRegs) PC() uint64 { return r.Rip }\n\nfunc (r *PtraceRegs) SetPC(pc uint64) { r.Rip = pc }\n\nfunc (iov *Iovec) SetLen(length int) {\n\tiov.Len = uint64(length)\n}\n\nfunc (msghdr *Msghdr) SetControllen(length int) {\n\tmsghdr.Controllen = uint64(length)\n}\n\nfunc (cmsg *Cmsghdr) SetLen(length int) {\n\tcmsg.Len = uint64(length)\n}\n\nfunc TimespecToNsec(ts Timespec) int64 ", "output": "{ return int64(ts.Sec)*1e9 + int64(ts.Nsec) }"}
{"input": "package graphics\n\nfunc MaxF(x1, x2 float32) float32 {\n\tif x1 > x2 {\n\t\treturn x1\n\t}\n\treturn x2\n}\n\nfunc MinF(x1, x2 float32) float32 {\n\tif x1 < x2 {\n\t\treturn x1\n\t}\n\treturn x2\n}\n\n\nfunc Sin2Atan(d float32) float32 {\n\treturn 2.0 * d / (1.0 + d*d)\n}\n\n\n\n\nfunc Cos2Atan(d float32) float32 ", "output": "{\n\treturn (1.0 - d*d) / (1.0 + d*d)\n}"}
{"input": "package builder\n\nimport \"fmt\"\n\n\ntype Between struct {\n\tCol     string\n\tLessVal interface{}\n\tMoreVal interface{}\n}\n\nvar _ Cond = Between{}\n\n\n\n\n\nfunc (between Between) And(conds ...Cond) Cond {\n\treturn And(between, And(conds...))\n}\n\n\nfunc (between Between) Or(conds ...Cond) Cond {\n\treturn Or(between, Or(conds...))\n}\n\n\nfunc (between Between) IsValid() bool {\n\treturn len(between.Col) > 0\n}\n\nfunc (between Between) WriteTo(w Writer) error ", "output": "{\n\tif _, err := fmt.Fprintf(w, \"%s BETWEEN ? AND ?\", w.Key(between.Col)); err != nil {\n\t\treturn err\n\t}\n\tw.Append(between.LessVal, between.MoreVal)\n\treturn nil\n}"}
{"input": "package xmpp\n\nimport (\n\t\"encoding/xml\"\n\t\"testing\"\n)\n\n\n\nfunc TestStreamError(t *testing.T) ", "output": "{\n\tconst errStr = `<stream:error><conflict xmlns=\"urn:ietf:params:xml:ns:xmpp-streams\"></conflict></stream:error>`\n\n\tvar se streamError\n\tif err := xml.Unmarshal([]byte(errStr), &se); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif se.Error() != errStr {\n\t\tt.Fatal(\"stream error is wrong:\", se.Error())\n\t}\n}"}
{"input": "package main \nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\n\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n}\n\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\nfunc main() {\n\tf := MyFloat(-math.Sqrt2)\n\tfmt.Println(f.Abs())\n}\n\nfunc (v Vertex) Abs() float64 ", "output": "{\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}"}
{"input": "package udp\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n)\n\nconst (\n\tsenderAddr   = \"localhost:8090\"\n\treceiverAddr = \"localhost:8080\"\n)\n\nfunc TestUDPConnectionless(t *testing.T) {\n\tfmt.Println(\"Beginning test\")\n\n\trecChan := make(chan int, 1)\n\tla, err := net.ResolveUDPAddr(\"udp\", receiverAddr)\n\tif err != nil {\n\t\tt.Fatalf(\"Error resolving receiver address: %v\", err)\n\t}\n\n\tgo runReceiver(recChan, la, t)\n\ttime.Sleep(time.Second * 1)\n\trunSender(la, t)\n\n\t<-recChan\n\n\tfmt.Println(\"Exiting.\")\n\n}\n\n\n\n\nfunc runSender(la *net.UDPAddr, t *testing.T) {\n\tfmt.Println(\"Getting sender\")\n\tsendConn, err := net.ListenPacket(\"udp\", senderAddr) \n\tif err != nil {\n\t\tt.Fatalf(\"Error getting sender's connection established: %v\", err)\n\t}\n\tdefer sendConn.Close()\n\n\t_, err = sendConn.(*net.UDPConn).WriteToUDP([]byte(\"Hello receiver!\"), la) \n\tif err != nil {\n\t\tt.Fatalf(\"Error writing to UDP: %v\", err)\n\t}\n\tfmt.Println(\"Wrote to UDP connection\")\n}\n\nfunc runReceiver(recChan chan int, la *net.UDPAddr, t *testing.T) ", "output": "{\n\tfmt.Println(\"Getting listener\")\n\n\trecConn, err := net.ListenUDP(\"udp\", la)\n\tif err != nil {\n\t\tt.Fatalf(\"Error getting receiver's connection established: %v\", err)\n\t}\n\tdefer recConn.Close()\n\n\tfmt.Println(\"Starting receiver\")\n\n\tbuf := make([]byte, 1024)\n\t_, _, err = recConn.ReadFromUDP(buf)\n\tif err != nil {\n\t\tt.Fatalf(\"Error reading from UDP: %v\", err)\n\t}\n\tfmt.Println(\"Buffer said: \", string(buf))\n\trecChan <- 0\n}"}
{"input": "package cvss\n\nimport \"testing\"\n\nfunc TestBaseParse(t *testing.T) {\n\tm := BaseMetric{AccessVector: 1, AccessComplexity: 0.71, Authentication: 0.704, Confidentiality: 0.0, Integrity: 0.0, Avaliability: 0.66}\n\tcvssString := `AV:N/AC:L/Au:N/C:N/I:N/A:C`\n\n\tmetric, err := ParseBaseMetric(cvssString)\n\tif err != nil {\n\t\tt.Errorf(\"Could not parse %s: %s\", cvssString, err)\n\t}\n\tif metric != m {\n\t\tt.Errorf(\"Could not parse %s: Expected %+v, got %+v\", cvssString, m, metric)\n\t}\n}\n\n\nfunc TestCalculateBaseScore(t *testing.T) ", "output": "{\n\tcvssString := `AV:N/AC:L/Au:N/C:N/I:N/A:C`\n\tscore, err := CalculateBaseScore(cvssString, 3)\n\tif err == nil {\n\t\tt.Error(\"Version 3 should not be supported yet\")\n\t}\n\tscore, err = CalculateBaseScore(cvssString, 2)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif score != 7.8 {\n\t\tt.Errorf(\"Expected 7.8 BaseScore, got %f\", score)\n\t}\n\n}"}
{"input": "package schema\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Location struct {\n\tTimestamp time.Time `json:\"timestamp,omitempty\"`\n\tLatitude  float64   `json:\"latitude,omitempty\"`\n\tLongitude float64   `json:\"longitude,omitempty\"`\n\tAccuracy  float64   `json:\"accuracy,omitempty\"`\n\tSource    string    `json:\"source,omitempty\"`\n\tAddress   string    `json:\"address,omitempty\"`\n}\n\n\n\ntype Geofence struct {\n\tLatMin  float64 `json:\"lat_min,omitempty\"`\n\tLatMax  float64 `json:\"lat_max,omitempty\"`\n\tLngMin  float64 `json:\"lng_min,omitempty\"`\n\tLngMax  float64 `json:\"lng_max,omitempty\"`\n\tName    string  `json:\"name,omitempty\"`\n\tAddress string  `json:\"address,omitempty\"`\n}\n\ntype GeofenceChange struct {\n\tLocation Location `json:\"loc,omitempty\"`\n\tFence    Geofence `json:\"fence,omitempty\"`\n\tStatus   string   `json:\"status,omitempty\"`\n}\n\nfunc (m GeofenceChange) Text() string {\n\treturn fmt.Sprintf(\"%s %ss %s.\", m.Location.Source, m.Status, m.Fence.Name)\n}\n\nfunc (l Location) Text() string ", "output": "{\n\tts := l.Timestamp.Format(time.RFC1123)\n\tif l.Address != \"\" {\n\t\treturn l.Address + \" on \" + ts\n\t}\n\treturn fmt.Sprintf(\"%.4f, %.4f on %s\", l.Latitude, l.Longitude, ts)\n}"}
{"input": "package police_hu\n\nimport (\n\t\"fmt\"\n\t\"github.com/mmcdole/gofeed\"\n\t\"sort\"\n\t\"time\"\n)\n\nvar SITE_URL string = \"http://www.police.hu/rss/feed\"\n\nconst rfc2822 = \"Mon, 02 Jan 2006 15:04:05 +0000\"\n\ntype NEWS struct {\n\tpublished int64\n\tlink      string\n\ttitle     string\n}\ntype NEWSARRAY []NEWS\n\n\nfunc (d NEWSARRAY) Len() int           { return len(d) }\n\nfunc (d NEWSARRAY) Swap(i, j int)      { d[i], d[j] = d[j], d[i] }\n\nvar feedArray NEWSARRAY\n\nfunc Crawl() {\n\n\tfp := gofeed.NewParser()\n\tfeed, _ := fp.ParseURL(SITE_URL)\n\tfor _, v := range feed.Items {\n\n\t\tt, _ := time.Parse(rfc2822, v.Published)\n\t\ttimestamp := t.Unix()\n\t\tnews := NEWS{\n\t\t\tpublished: timestamp,\n\t\t\tlink:      v.Link,\n\t\t\ttitle:     v.Title,\n\t\t}\n\t\tfeedArray = append(feedArray, news)\n\t}\n\tsort.Sort(feedArray)\n\tfmt.Println(feedArray)\n}\n\nfunc (d NEWSARRAY) Less(i, j int) bool ", "output": "{ return d[i].published < d[j].published }"}
{"input": "package file\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"syscall\"\n\t\"time\"\n)\n\n\n\n\ntype darwinExFileInfo struct {\n\tos.FileInfo\n\tfid  FID\n\tpath string\n}\n\n\n\nfunc timespecToTime(ts syscall.Timespec) time.Time {\n\treturn time.Unix(int64(ts.Sec), int64(ts.Nsec))\n}\n\n\nfunc (fi *darwinExFileInfo) CTime() time.Time {\n\treturn timespecToTime(fi.Sys().(*syscall.Stat_t).Ctimespec)\n}\n\n\n\n\n\nfunc (fi *darwinExFileInfo) FID() FID {\n\treturn fi.fid\n}\n\n\nfunc (fi *darwinExFileInfo) Path() string {\n\treturn fi.path\n}\n\n\nfunc systemExFileInfo(fi os.FileInfo, path string) *darwinExFileInfo {\n\tfid := FID{\n\t\tIDLow: fi.Sys().(*syscall.Stat_t).Ino,\n\t}\n\tabsolute, _ := filepath.Abs(path)\n\treturn &darwinExFileInfo{\n\t\tFileInfo: fi,\n\t\tfid:      fid,\n\t\tpath:     filepath.Clean(absolute),\n\t}\n}\n\nfunc (fi *darwinExFileInfo) ATime() time.Time ", "output": "{\n\treturn timespecToTime(fi.Sys().(*syscall.Stat_t).Atimespec)\n}"}
{"input": "package metrics\n\nimport (\n\t\"github.com/cloudfoundry/dropsonde/metric_sender\"\n)\n\nvar metricSender metric_sender.MetricSender\nvar metricBatcher MetricBatcher\n\ntype MetricBatcher interface {\n\tBatchIncrementCounter(name string)\n\tBatchAddCounter(name string, delta uint64)\n\tClose()\n}\n\n\nfunc Initialize(ms metric_sender.MetricSender, mb MetricBatcher) {\n\tif metricBatcher != nil {\n\t\tmetricBatcher.Close()\n\t}\n\tmetricSender = ms\n\tmetricBatcher = mb\n}\n\n\n\n\n\n\nfunc SendValue(name string, value float64, unit string) error {\n\tif metricSender == nil {\n\t\treturn nil\n\t}\n\treturn metricSender.SendValue(name, value, unit)\n}\n\n\n\n\nfunc IncrementCounter(name string) error {\n\tif metricSender == nil {\n\t\treturn nil\n\t}\n\treturn metricSender.IncrementCounter(name)\n}\n\n\n\n\nfunc BatchIncrementCounter(name string) {\n\tif metricBatcher == nil {\n\t\treturn\n\t}\n\tmetricBatcher.BatchIncrementCounter(name)\n}\n\n\n\n\nfunc AddToCounter(name string, delta uint64) error {\n\tif metricSender == nil {\n\t\treturn nil\n\t}\n\treturn metricSender.AddToCounter(name, delta)\n}\n\n\n\n\nfunc BatchAddCounter(name string, delta uint64) {\n\tif metricBatcher == nil {\n\t\treturn\n\t}\n\tmetricBatcher.BatchAddCounter(name, delta)\n}\n\n\n\n\n\nfunc SendContainerMetric(applicationId string, instanceIndex int32, cpuPercentage float64, memoryBytes uint64, diskBytes uint64) error {\n\tif metricSender == nil {\n\t\treturn nil\n\t}\n\n\treturn metricSender.SendContainerMetric(applicationId, instanceIndex, cpuPercentage, memoryBytes, diskBytes)\n}\n\nfunc Close() ", "output": "{\n\tmetricBatcher.Close()\n}"}
{"input": "package mocks\n\nimport (\n\tcontext \"context\"\n\n\tmock \"github.com/stretchr/testify/mock\"\n)\n\n\ntype RevPortForward struct {\n\tmock.Mock\n}\n\n\n\n\nfunc (_m *RevPortForward) Start(ctx context.Context, podName string, port int) error ", "output": "{\n\tret := _m.Called(ctx, podName, port)\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func(context.Context, string, int) error); ok {\n\t\tr0 = rf(ctx, podName, port)\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}"}
{"input": "package binary\n\nimport \"fmt\"\n\ntype decodeError struct {\n\tmessage string\n}\n\nfunc (e decodeError) Error() string {\n\treturn e.message\n}\n\n\n\n\nfunc IsDecodeError(e error) bool {\n\t_, isDecodeError := e.(decodeError)\n\treturn isDecodeError\n}\n\nfunc decodeErrorf(f string, args ...interface{}) decodeError ", "output": "{\n\treturn decodeError{message: fmt.Sprintf(f, args...)}\n}"}
{"input": "package v1beta1\n\nimport (\n\tv1beta1 \"k8s.io/api/scheduling/v1beta1\"\n\tserializer \"k8s.io/apimachinery/pkg/runtime/serializer\"\n\t\"k8s.io/client-go/kubernetes/scheme\"\n\trest \"k8s.io/client-go/rest\"\n)\n\ntype SchedulingV1beta1Interface interface {\n\tRESTClient() rest.Interface\n\tPriorityClassesGetter\n}\n\n\ntype SchedulingV1beta1Client struct {\n\trestClient rest.Interface\n}\n\nfunc (c *SchedulingV1beta1Client) PriorityClasses() PriorityClassInterface {\n\treturn newPriorityClasses(c)\n}\n\n\nfunc NewForConfig(c *rest.Config) (*SchedulingV1beta1Client, error) {\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := rest.RESTClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &SchedulingV1beta1Client{client}, nil\n}\n\n\n\n\n\n\nfunc New(c rest.Interface) *SchedulingV1beta1Client {\n\treturn &SchedulingV1beta1Client{c}\n}\n\nfunc setConfigDefaults(config *rest.Config) error {\n\tgv := v1beta1.SchemeGroupVersion\n\tconfig.GroupVersion = &gv\n\tconfig.APIPath = \"/apis\"\n\tconfig.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: scheme.Codecs}\n\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = rest.DefaultKubernetesUserAgent()\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (c *SchedulingV1beta1Client) RESTClient() rest.Interface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.restClient\n}\n\nfunc NewForConfigOrDie(c *rest.Config) *SchedulingV1beta1Client ", "output": "{\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}"}
{"input": "package executor\n\nimport (\n\t\"github.com/mesos/mesos-go/mesosproto\"\n\t\"github.com/stretchr/testify/mock\"\n)\n\n\ntype MockedExecutor struct {\n\tmock.Mock\n}\n\n\nfunc NewMockedExecutor() *MockedExecutor {\n\treturn &MockedExecutor{}\n}\n\n\nfunc (e *MockedExecutor) Registered(ExecutorDriver, *mesosproto.ExecutorInfo, *mesosproto.FrameworkInfo, *mesosproto.SlaveInfo) {\n\te.Called()\n}\n\n\nfunc (e *MockedExecutor) Reregistered(ExecutorDriver, *mesosproto.SlaveInfo) {\n\te.Called()\n}\n\n\nfunc (e *MockedExecutor) Disconnected(ExecutorDriver) {\n\te.Called()\n}\n\n\nfunc (e *MockedExecutor) LaunchTask(ExecutorDriver, *mesosproto.TaskInfo) {\n\te.Called()\n}\n\n\nfunc (e *MockedExecutor) KillTask(ExecutorDriver, *mesosproto.TaskID) {\n\te.Called()\n}\n\n\n\n\n\nfunc (e *MockedExecutor) Shutdown(ExecutorDriver) {\n\te.Called()\n}\n\n\nfunc (e *MockedExecutor) Error(ExecutorDriver, string) {\n\te.Called()\n}\n\nfunc (e *MockedExecutor) FrameworkMessage(ExecutorDriver, string) ", "output": "{\n\te.Called()\n}"}
{"input": "package urlutil\n\nimport (\n\t\"net/url\"\n\t\"regexp\"\n\t\"strconv\"\n)\n\n\n\n\n\ntype URLMore struct {\n\tURL                  *url.URL\n\tURLWoQueryWoFragment string\n\tURLWoFragment        string\n\tPort                 int\n}\n\n\n\n\n\nfunc (urlMore *URLMore) Parse(rawurl string) error {\n\tmyURL, err := url.Parse(rawurl)\n\tif err != nil {\n\t\treturn err\n\t}\n\turlMore.URL = myURL\n\turlMore.Inflate()\n\treturn nil\n}\n\nfunc (urlMore *URLMore) Inflate() {\n\tmyURL := urlMore.URL\n\turlMore.URLWoQueryWoFragment = myURL.Scheme + \"://\" + myURL.Host + myURL.Path\n\tif len(myURL.RawQuery) > 0 {\n\t\turlMore.URLWoFragment = urlMore.URLWoQueryWoFragment + \"?\" + myURL.RawQuery\n\t} else {\n\t\turlMore.URLWoFragment = urlMore.URLWoQueryWoFragment\n\t}\n\trx := regexp.MustCompile(`:([0-9]+)$`)\n\trs := rx.FindStringSubmatch(myURL.Host)\n\tif len(rs) > 0 {\n\t\tport, err := strconv.Atoi(rs[1])\n\t\tif err == nil {\n\t\t\turlMore.Port = port\n\t\t}\n\t}\n}\n\nfunc NewURLMore() URLMore ", "output": "{\n\turlMore := URLMore{\n\t\tURLWoQueryWoFragment: \"\",\n\t\tURLWoFragment:        \"\"}\n\treturn urlMore\n}"}
{"input": "package mapreduce\n\nimport (\n\t\"hash/fnv\"\n\t\"os\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\n\n\n\nfunc doMap(\n\tjobName string, \n\tmapTaskNumber int, \n\tinFile string,\n\tnReduce int, \n\tmapF func(file string, contents string) []KeyValue,\n) {\n\tbytes, err := ioutil.ReadFile(inFile)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tkvs := mapF(inFile, string(bytes))\n\n\tencoders := make(map[string]*json.Encoder)\n\tfor i :=0;i<nReduce;i++{\n\t\trFile := reduceName(jobName, mapTaskNumber, i)\n\t\tfile, err := os.OpenFile(rFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0666)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer file.Close()\n\n\t\tencoders[rFile] = json.NewEncoder(file)\n\t}\n\n\tfor _, w := range kvs {\n\t\tr := ihash(w.Key) % uint32(nReduce)\n\t\trFile := reduceName(jobName, mapTaskNumber, int(r))\n\t\terr := encoders[rFile].Encode(&w)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n\n\n\nfunc ihash(s string) uint32 ", "output": "{\n\th := fnv.New32a()\n\th.Write([]byte(s))\n\treturn h.Sum32()\n}"}
{"input": "package ginkgoext\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\n\t\"github.com/cilium/cilium/pkg/lock\"\n)\n\n\n\ntype Writer struct {\n\tBuffer    *bytes.Buffer\n\toutWriter io.Writer\n\tlock      *lock.Mutex\n}\n\n\n\nfunc NewWriter(outWriter io.Writer) *Writer {\n\treturn &Writer{\n\t\tBuffer:    &bytes.Buffer{},\n\t\toutWriter: outWriter,\n\t\tlock:      &lock.Mutex{},\n\t}\n}\n\n\n\n\nfunc (w *Writer) Write(b []byte) (n int, err error) {\n\tw.lock.Lock()\n\tdefer w.lock.Unlock()\n\tn, err = w.Buffer.Write(b)\n\tif err != nil {\n\t\treturn n, err\n\t}\n\treturn w.outWriter.Write(b)\n}\n\n\n\n\n\nfunc (w *Writer) Bytes() []byte {\n\tw.lock.Lock()\n\tdefer w.lock.Unlock()\n\treturn w.Buffer.Bytes()\n}\n\nfunc (w *Writer) Reset() ", "output": "{\n\tw.lock.Lock()\n\tdefer w.lock.Unlock()\n\tw.Buffer.Reset()\n}"}
{"input": "package ldap\n\nimport (\n\t\"fmt\"\n\n\tber \"github.com/go-asn1-ber/asn1-ber\"\n)\n\n\ntype CompareRequest struct {\n\tDN        string\n\tAttribute string\n\tValue     string\n}\n\n\n\n\n\nfunc (l *Conn) Compare(dn, attribute, value string) (bool, error) {\n\tmsgCtx, err := l.doRequest(&CompareRequest{\n\t\tDN:        dn,\n\t\tAttribute: attribute,\n\t\tValue:     value})\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer l.finishMessage(msgCtx)\n\n\tpacket, err := l.readPacket(msgCtx)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif packet.Children[1].Tag == ApplicationCompareResponse {\n\t\terr := GetLDAPError(packet)\n\n\t\tswitch {\n\t\tcase IsErrorWithCode(err, LDAPResultCompareTrue):\n\t\t\treturn true, nil\n\t\tcase IsErrorWithCode(err, LDAPResultCompareFalse):\n\t\t\treturn false, nil\n\t\tdefault:\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn false, fmt.Errorf(\"unexpected Response: %d\", packet.Children[1].Tag)\n}\n\nfunc (req *CompareRequest) appendTo(envelope *ber.Packet) error ", "output": "{\n\tpkt := ber.Encode(ber.ClassApplication, ber.TypeConstructed, ApplicationCompareRequest, nil, \"Compare Request\")\n\tpkt.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, req.DN, \"DN\"))\n\n\tava := ber.Encode(ber.ClassUniversal, ber.TypeConstructed, ber.TagSequence, nil, \"AttributeValueAssertion\")\n\tava.AppendChild(ber.NewString(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, req.Attribute, \"AttributeDesc\"))\n\tava.AppendChild(ber.Encode(ber.ClassUniversal, ber.TypePrimitive, ber.TagOctetString, req.Value, \"AssertionValue\"))\n\n\tpkt.AppendChild(ava)\n\n\tenvelope.AppendChild(pkt)\n\n\treturn nil\n}"}
{"input": "package ncpdp\n\nimport (\n\t\"github.com/kdar/health/edifact\"\n\t\"time\"\n)\n\ntype Name struct {\n\tLast   string\n\tFirst  string\n\tMiddle string\n\tSuffix string\n\tPrefix string\n}\n\ntype Address struct {\n\tLine1             string\n\tCity              string\n\tState             string\n\tPostal            string\n\tLocationQualifier string\n\tLocation          string \n}\n\ntype Phone struct {\n\tNumber    string\n\tQualifier string\n}\n\n\ntype Patient struct {\n\tRelationship string \n\n\tDob time.Time \n\n\tName *Name \n\n\tGender string \n\n\tReferenceNumber string \n\n\tReferenceQualifier string \n\n\tAddress *Address \n\n\tPhones []*Phone \n}\n\nfunc (p *Patient) fill(values edifact.Values) {\n\tp.Relationship = getString(values, 1)\n\n\tdob := getString(values, 2)\n\tif len(dob) > 0 {\n\t\tdobTime, err := time.Parse(\"20060102\", dob)\n\t\tif err == nil {\n\t\t\tp.Dob = dobTime\n\t\t}\n\t}\n\n\tp.Name = getName(values, 3)\n\tp.Gender = getString(values, 4)\n\n\tsubValues := getValues(values, 5)\n\tp.ReferenceNumber = getString(subValues, 0)\n\tp.ReferenceQualifier = getString(subValues, 1)\n\n\tp.Address = getAddress(values, 6)\n\tp.Phones = getPhones(values, 7)\n}\n\n\nfunc newPatient() *Patient {\n\treturn &Patient{}\n}\n\n\n\n\n\n\n\n\ntype Provider struct {\n\n\tProviderCode string \n\n\n\tReferenceNumber string \n\n\tReferenceQualifier string \n\n\n\tName *Name \n\n\n\tPartyName string \n}\n\nfunc newProvider() *Provider {\n\treturn &Provider{}\n}\n\n\n\nfunc (p *Provider) fill(values edifact.Values) ", "output": "{\n\tsubValues := getValues(values, 2)\n\tp.ReferenceNumber = getString(subValues, 0)\n\tp.ReferenceQualifier = getString(subValues, 1)\n\n\tp.Name = getName(values, 5)\n\n\tp.PartyName = getString(values, 7)\n}"}
{"input": "package apm\n\nimport (\n\t\"fmt\"\n)\n\n\ntype KeyTransaction struct {\n\tID              int                       `json:\"id,omitempty\"`\n\tName            string                    `json:\"name,omitempty\"`\n\tTransactionName string                    `json:\"transaction_name,omitempty\"`\n\tHealthStatus    string                    `json:\"health_status,omitempty\"`\n\tLastReportedAt  string                    `json:\"last_reported_at,omitempty\"`\n\tReporting       bool                      `json:\"reporting\"`\n\tSummary         ApplicationSummary        `json:\"application_summary,omitempty\"`\n\tEndUserSummary  ApplicationEndUserSummary `json:\"end_user_summary,omitempty\"`\n\tLinks           KeyTransactionLinks       `json:\"links,omitempty\"`\n}\n\n\ntype KeyTransactionLinks struct {\n\tApplication int `json:\"application,omitempty\"`\n}\n\n\n\ntype ListKeyTransactionsParams struct {\n\tName string `url:\"filter[name],omitempty\"`\n\tIDs  []int  `url:\"filter[ids],omitempty,comma\"`\n}\n\n\n\n\n\nfunc (a *APM) GetKeyTransaction(id int) (*KeyTransaction, error) {\n\tresponse := keyTransactionResponse{}\n\turl := fmt.Sprintf(\"/key_transactions/%d.json\", id)\n\n\t_, err := a.client.Get(a.config.Region().RestURL(url), nil, &response)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response.KeyTransaction, nil\n}\n\ntype keyTransactionsResponse struct {\n\tKeyTransactions []*KeyTransaction `json:\"key_transactions,omitempty\"`\n}\n\ntype keyTransactionResponse struct {\n\tKeyTransaction KeyTransaction `json:\"key_transaction,omitempty\"`\n}\n\nfunc (a *APM) ListKeyTransactions(params *ListKeyTransactionsParams) ([]*KeyTransaction, error) ", "output": "{\n\tresults := []*KeyTransaction{}\n\tnextURL := a.config.Region().RestURL(\"key_transactions.json\")\n\n\tfor nextURL != \"\" {\n\t\tresponse := keyTransactionsResponse{}\n\t\tresp, err := a.client.Get(nextURL, &params, &response)\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tresults = append(results, response.KeyTransactions...)\n\n\t\tpaging := a.pager.Parse(resp)\n\t\tnextURL = paging.Next\n\t}\n\n\treturn results, nil\n}"}
{"input": "package collector\n\nimport (\n\t\"github.com/prometheus/client_golang/prometheus\"\n)\n\ntype conntrackCollector struct {\n\tcurrent *prometheus.Desc\n\tlimit   *prometheus.Desc\n}\n\nfunc init() {\n\tFactories[\"conntrack\"] = NewConntrackCollector\n}\n\n\n\n\n\nfunc (c *conntrackCollector) Update(ch chan<- prometheus.Metric) (err error) {\n\tvalue, err := readUintFromFile(procFilePath(\"sys/net/netfilter/nf_conntrack_count\"))\n\tif err != nil {\n\t\treturn nil\n\t}\n\tch <- prometheus.MustNewConstMetric(\n\t\tc.current, prometheus.GaugeValue, float64(value))\n\n\tvalue, err = readUintFromFile(procFilePath(\"sys/net/netfilter/nf_conntrack_max\"))\n\tif err != nil {\n\t\treturn nil\n\t}\n\tch <- prometheus.MustNewConstMetric(\n\t\tc.limit, prometheus.GaugeValue, float64(value))\n\n\treturn nil\n}\n\nfunc NewConntrackCollector() (Collector, error) ", "output": "{\n\treturn &conntrackCollector{\n\t\tcurrent: prometheus.NewDesc(\n\t\t\tprometheus.BuildFQName(Namespace, \"\", \"nf_conntrack_entries\"),\n\t\t\t\"Number of currently allocated flow entries for connection tracking.\",\n\t\t\tnil, nil,\n\t\t),\n\t\tlimit: prometheus.NewDesc(\n\t\t\tprometheus.BuildFQName(Namespace, \"\", \"nf_conntrack_entries_limit\"),\n\t\t\t\"Maximum size of connection tracking table.\",\n\t\t\tnil, nil,\n\t\t),\n\t}, nil\n}"}
{"input": "package caaa\n\nimport (\n\t\"encoding/xml\"\n\n\t\"github.com/fgrid/iso20022\"\n)\n\ntype Document01600102 struct {\n\tXMLName xml.Name                              `xml:\"urn:iso:std:iso:20022:tech:xsd:caaa.016.001.02 Document\"`\n\tMessage *AcceptorCurrencyConversionRequestV02 `xml:\"AccptrCcyConvsReq\"`\n}\n\nfunc (d *Document01600102) AddMessage() *AcceptorCurrencyConversionRequestV02 {\n\td.Message = new(AcceptorCurrencyConversionRequestV02)\n\treturn d.Message\n}\n\n\n\ntype AcceptorCurrencyConversionRequestV02 struct {\n\n\tHeader *iso20022.Header10 `xml:\"Hdr\"`\n\n\tCurrencyConversionRequest *iso20022.AcceptorCurrencyConversionRequest2 `xml:\"CcyConvsReq\"`\n\n\tSecurityTrailer *iso20022.ContentInformationType11 `xml:\"SctyTrlr\"`\n}\n\nfunc (a *AcceptorCurrencyConversionRequestV02) AddHeader() *iso20022.Header10 {\n\ta.Header = new(iso20022.Header10)\n\treturn a.Header\n}\n\n\n\nfunc (a *AcceptorCurrencyConversionRequestV02) AddSecurityTrailer() *iso20022.ContentInformationType11 {\n\ta.SecurityTrailer = new(iso20022.ContentInformationType11)\n\treturn a.SecurityTrailer\n}\n\nfunc (a *AcceptorCurrencyConversionRequestV02) AddCurrencyConversionRequest() *iso20022.AcceptorCurrencyConversionRequest2 ", "output": "{\n\ta.CurrencyConversionRequest = new(iso20022.AcceptorCurrencyConversionRequest2)\n\treturn a.CurrencyConversionRequest\n}"}
{"input": "package mathutil\n\nimport \"testing\"\n\n\n\n\n\nfunc TestMin(t *testing.T) {\n\tcases := []struct {\n\t\ta, b, want int\n\t}{\n\t\t{10, 20, 10},\n\t\t{-1, -10, -10},\n\t\t{10, 10, 10},\n\t}\n\tfor _, c := range cases {\n\t\tgot := Min(c.a, c.b)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"Min(%d, %d) == %d, want %d\", c.a, c.b, got, c.want)\n\t\t}\n\t}\n}\n\n\nfunc TestMaxVR(t *testing.T) {\t\n\ttestMaxV(t, \"MaxVR\")\n}\n\n\nfunc TestMaxVI(t *testing.T) {\t\t\n\ttestMaxV(t, \"MaxVI\")\n}\n\nfunc testMaxV(t *testing.T, fname string) {\n\tcases_pass := []struct {\n\t\ta []int\n\t\twant int\n\t}{\n\t\t{[]int{10, 20, 30}, 30},\n\t\t{[]int{-1, -10, -5}, -1},\n\t\t{[]int{10, 10, 10}, 10},\t\t\n\t\t{[]int{8, 9, 10, 100, 200, 300, -1, 10, -10}, 300},\t\t\n\t}\n\n\tfor _, c := range cases_pass {\n\t\tgot := MaxV(c.a...)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"%s(%v) == %d, want %d\", fname, c.a, got, c.want)\n\t\t}\n\t}\n}\n\nfunc TestMax(t *testing.T) ", "output": "{\n\tcases := []struct {\n\t\ta, b, want int\n\t}{\n\t\t{10, 20, 20},\n\t\t{-1, -10, -1},\n\t\t{10, 10, 10},\n\t}\n\tfor _, c := range cases {\n\t\tgot := Max(c.a, c.b)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"Max(%d, %d) == %d, want %d\", c.a, c.b, got, c.want)\n\t\t}\n\t}\n}"}
{"input": "package route\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"path\"\n\t\"strings\"\n)\n\n\nvar match matcher = prefixMatcher\n\n\ntype matcher func(uri string, r *Route) bool\n\n\nfunc prefixMatcher(uri string, r *Route) bool {\n\treturn strings.HasPrefix(uri, r.Path)\n}\n\n\n\n\n\nfunc SetMatcher(s string) error {\n\tswitch s {\n\tcase \"prefix\":\n\t\tmatch = prefixMatcher\n\tcase \"glob\":\n\t\tmatch = globMatcher\n\tdefault:\n\t\treturn fmt.Errorf(\"route: invalid matcher: %s\", s)\n\t}\n\treturn nil\n}\n\nfunc globMatcher(uri string, r *Route) bool ", "output": "{\n\tvar hasMatch, err = path.Match(r.Path, uri)\n\tif err != nil {\n\t\tlog.Printf(\"[ERROR] Glob matching error %s for path %s route %s\", err, uri, r.Path)\n\t\treturn false\n\t}\n\treturn hasMatch\n}"}
{"input": "package cceventmgmt\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/hyperledger/fabric/core/common/ccprovider\"\n)\n\n\ntype ChaincodeDefinition struct {\n\tName    string\n\tHash    []byte\n\tVersion string\n}\n\n\n\n\n\n\ntype ChaincodeLifecycleEventListener interface {\n\tHandleChaincodeDeploy(chaincodeDefinition *ChaincodeDefinition, dbArtifactsTar []byte) error\n}\n\n\ntype ChaincodeInfoProvider interface {\n\tIsChaincodeDeployed(chainid string, chaincodeDefinition *ChaincodeDefinition) (bool, error)\n\tRetrieveChaincodeArtifacts(chaincodeDefinition *ChaincodeDefinition) (installed bool, dbArtifactsTar []byte, err error)\n}\n\ntype chaincodeInfoProviderImpl struct {\n}\n\n\nfunc (p *chaincodeInfoProviderImpl) IsChaincodeDeployed(chainid string, chaincodeDefinition *ChaincodeDefinition) (bool, error) {\n\treturn ccprovider.IsChaincodeDeployed(chainid, chaincodeDefinition.Name, chaincodeDefinition.Version, chaincodeDefinition.Hash)\n}\n\n\nfunc (p *chaincodeInfoProviderImpl) RetrieveChaincodeArtifacts(chaincodeDefinition *ChaincodeDefinition) (installed bool, dbArtifactsTar []byte, err error) {\n\treturn ccprovider.ExtractStatedbArtifactsForChaincode(chaincodeDefinition.Name, chaincodeDefinition.Version)\n}\n\nfunc (cdef *ChaincodeDefinition) String() string ", "output": "{\n\treturn fmt.Sprintf(\"Name=%s, Version=%s, Hash=%#v\", cdef.Name, cdef.Version, cdef.Hash)\n}"}
{"input": "package mtlsfirstpartyjwt\n\nimport (\n\t\"testing\"\n\n\t\"istio.io/istio/pkg/test/framework\"\n\t\"istio.io/istio/pkg/test/framework/components/istio\"\n\t\"istio.io/istio/pkg/test/framework/components/pilot\"\n\t\"istio.io/istio/pkg/test/framework/label\"\n\t\"istio.io/istio/pkg/test/framework/resource\"\n\t\"istio.io/istio/pkg/test/framework/resource/environment\"\n)\n\nvar (\n\tinst istio.Instance\n\tp    pilot.Instance\n)\n\n\n\nfunc setupConfig(cfg *istio.Config) {\n\tif cfg == nil {\n\t\treturn\n\t}\n\tcfg.Values[\"global.jwtPolicy\"] = \"first-party-jwt\"\n\tcfg.Values[\"global.mtls.auto\"] = \"true\"\n}\n\nfunc TestMain(m *testing.M) ", "output": "{\n\tframework.\n\t\tNewSuite(\"mtls_first_party_jwt\", m).\n\t\tRequireEnvironment(environment.Kube).\n\t\tRequireSingleCluster().\n\t\tLabel(label.CustomSetup).\n\t\tSetupOnEnv(environment.Kube, istio.Setup(&inst, setupConfig)).\n\t\tSetup(func(ctx resource.Context) (err error) {\n\t\t\tif p, err = pilot.New(ctx, pilot.Config{}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}).\n\t\tRun()\n}"}
{"input": "package api\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"net/url\"\n)\n\nfunc decodeData(data string, out interface{}) error {\n\tdecoded, err := base64.StdEncoding.DecodeString(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := json.Unmarshal(decoded, &out); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\nfunc decodeUrlEncodedJSON(data string, out interface{}) error ", "output": "{\n\tdecoded, err := url.QueryUnescape(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := json.Unmarshal([]byte(decoded), &out); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package http\n\nimport (\n\t\"context\"\n\t\"github.com/go-kit/kit/endpoint\"\n\t\"github.com/kryptn/modulario/proto\"\n)\n\nfunc MakeLoginEndpoint(svc HttpService) endpoint.Endpoint {\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treq := request.(proto.LoginRequest)\n\t\tresp, err := svc.Login(ctx, req)\n\t\treturn resp, err\n\t}\n}\n\nfunc MakeVisitPostEndpoint(svc HttpService) endpoint.Endpoint {\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treq := request.(proto.VisitPostRequest)\n\t\treturn svc.VisitPost(ctx, req)\n\t}\n}\n\n\n\nfunc MakeCreatePostEndpoint(svc HttpService) endpoint.Endpoint {\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treq := request.(proto.CreatePostRequest)\n\t\treturn svc.CreatePost(ctx, req)\n\t}\n}\n\nfunc MakeViewPostEndpoint(svc HttpService) endpoint.Endpoint ", "output": "{\n\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treq := request.(proto.ViewPostRequest)\n\t\treturn svc.ViewPost(ctx, req)\n\t}\n}"}
{"input": "package main\n\nimport (\n\tkubeapiserver \"github.com/GoogleCloudPlatform/kubernetes/cmd/kube-apiserver/app\"\n)\n\n\n\n\n\nfunc NewKubeAPIServer() *Server ", "output": "{\n\ts := kubeapiserver.NewAPIServer()\n\n\thks := Server{\n\t\tSimpleUsage: \"apiserver\",\n\t\tLong:        \"The main API entrypoint and interface to the storage system.  The API server is also the focal point for all authorization decisions.\",\n\t\tRun: func(_ *Server, args []string) error {\n\t\t\treturn s.Run(args)\n\t\t},\n\t}\n\ts.AddFlags(hks.Flags())\n\treturn &hks\n}"}
{"input": "package tchannel\n\nimport (\n\t\"io\"\n\t\"regexp\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestErrorMetricKeys(t *testing.T) {\n\tcodes := []SystemErrCode{\n\t\tErrCodeInvalid,\n\t\tErrCodeTimeout,\n\t\tErrCodeCancelled,\n\t\tErrCodeBusy,\n\t\tErrCodeDeclined,\n\t\tErrCodeUnexpected,\n\t\tErrCodeBadRequest,\n\t\tErrCodeNetwork,\n\t\tErrCodeProtocol,\n\t}\n\n\texpected := regexp.MustCompile(`^[[:lower:]-]+$`)\n\tfor _, c := range codes {\n\t\tassert.True(t, expected.MatchString(c.MetricsKey()), \"Expected metrics key for code %s to be well-formed.\", c.String())\n\t}\n\n\tassert.Equal(t, \"SystemErrCode(13)\", SystemErrCode(13).MetricsKey(), \"Expected invalid error codes to use a fallback metrics key format.\")\n}\n\nfunc TestInvalidError(t *testing.T) {\n\tcode := GetSystemErrorCode(nil)\n\tassert.Equal(t, ErrCodeInvalid, code, \"nil error should produce ErrCodeInvalid\")\n}\n\n\n\nfunc TestSystemError(t *testing.T) {\n\tcode := GetSystemErrorCode(ErrTimeout)\n\tassert.Equal(t, ErrCodeTimeout, code, \"tchannel timeout error produces ErrCodeTimeout\")\n}\n\nfunc TestRelayMetricsKey(t *testing.T) {\n\tfor i := 0; i <= 256; i++ {\n\t\tcode := SystemErrCode(i)\n\t\tassert.Equal(t, \"relay-\"+code.MetricsKey(), code.relayMetricsKey(), \"Unexpected relay metrics key for %v\", code)\n\t}\n}\n\nfunc TestUnexpectedError(t *testing.T) ", "output": "{\n\tcode := GetSystemErrorCode(io.EOF)\n\tassert.Equal(t, ErrCodeUnexpected, code, \"non-tchannel SystemError should produce ErrCodeUnexpected\")\n}"}
{"input": "package system \n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\nfunc MkdirAllWithACL(path string, perm os.FileMode, sddl string) error {\n\treturn os.MkdirAll(path, perm)\n}\n\n\n\nfunc MkdirAll(path string, perm os.FileMode) error {\n\treturn os.MkdirAll(path, perm)\n}\n\n\nfunc IsAbs(path string) bool {\n\treturn filepath.IsAbs(path)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc OpenSequential(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\n\n\n\n\n\nfunc OpenFileSequential(name string, flag int, perm os.FileMode) (*os.File, error) {\n\treturn os.OpenFile(name, flag, perm)\n}\n\n\n\n\n\n\n\n\n\n\nfunc TempFileSequential(dir, prefix string) (f *os.File, err error) {\n\treturn ioutil.TempFile(dir, prefix)\n}\n\nfunc CreateSequential(name string) (*os.File, error) ", "output": "{\n\treturn os.Create(name)\n}"}
{"input": "package database\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetAutonomousDatabaseRegionalWalletRequest struct {\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetAutonomousDatabaseRegionalWalletRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request GetAutonomousDatabaseRegionalWalletRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request GetAutonomousDatabaseRegionalWalletRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetAutonomousDatabaseRegionalWalletResponse struct {\n\n\tRawResponse *http.Response\n\n\tAutonomousDatabaseWallet `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response GetAutonomousDatabaseRegionalWalletResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response GetAutonomousDatabaseRegionalWalletResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request GetAutonomousDatabaseRegionalWalletRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) ", "output": "{\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}"}
{"input": "package org\n\nimport (\n\t\"errors\"\n\n\t\"github.com/appcelerator/amp/api/rpc/account\"\n\t\"github.com/appcelerator/amp/cli\"\n\t\"github.com/spf13/cobra\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc/status\"\n)\n\ntype createOrgOptions struct {\n\tname  string\n\temail string\n}\n\n\n\n\nfunc createOrg(c cli.Interface, cmd *cobra.Command, opts createOrgOptions) error {\n\tif !cmd.Flag(\"org\").Changed {\n\t\topts.name = c.Console().GetInput(\"organization name\")\n\t}\n\tif !cmd.Flag(\"email\").Changed {\n\t\topts.email = c.Console().GetInput(\"email\")\n\t}\n\tconn := c.ClientConn()\n\tclient := account.NewAccountClient(conn)\n\trequest := &account.CreateOrganizationRequest{\n\t\tName:  opts.name,\n\t\tEmail: opts.email,\n\t}\n\tif _, err := client.CreateOrganization(context.Background(), request); err != nil {\n\t\tif s, ok := status.FromError(err); ok {\n\t\t\treturn errors.New(s.Message())\n\t\t}\n\t}\n\tif err := cli.SaveOrg(opts.name, c.Server()); err != nil {\n\t\treturn err\n\t}\n\tc.Console().Println(\"Organization has been created.\")\n\treturn nil\n}\n\nfunc NewOrgCreateCommand(c cli.Interface) *cobra.Command ", "output": "{\n\topts := createOrgOptions{}\n\tcmd := &cobra.Command{\n\t\tUse:     \"create [OPTIONS]\",\n\t\tShort:   \"Create organization\",\n\t\tPreRunE: cli.NoArgs,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn createOrg(c, cmd, opts)\n\t\t},\n\t}\n\tflags := cmd.Flags()\n\tflags.StringVar(&opts.name, \"org\", \"\", \"Organization name\")\n\tflags.StringVar(&opts.email, \"email\", \"\", \"Email address\")\n\treturn cmd\n}"}
{"input": "package engi\n\ntype glyph struct {\n\tregion   *Region\n\txoffset  float32\n\tyoffset  float32\n\txadvance float32\n}\n\ntype Font struct {\n\tglyphs map[rune]*glyph\n}\n\nfunc NewGridFont(texture *Texture, cellWidth, cellHeight int) *Font {\n\ti := 0\n\tglyphs := make(map[rune]*glyph)\n\n\tfor y := 0; y < int(texture.Height())/cellHeight; y++ {\n\t\tfor x := 0; x < int(texture.Width())/cellWidth; x++ {\n\t\t\tg := &glyph{xadvance: float32(cellWidth)}\n\t\t\tg.region = NewRegion(texture, x*cellWidth, y*cellHeight, cellWidth, cellHeight)\n\t\t\tglyphs[rune(i)] = g\n\t\t\ti += 1\n\t\t}\n\t}\n\n\treturn &Font{glyphs}\n}\n\n\n\nfunc (f *Font) Put(batch *Batch, r rune, x, y float32, color uint32) {\n\tif g, ok := f.glyphs[r]; ok {\n\t\tbatch.Draw(g.region, x+g.xoffset, y+g.yoffset, 0, 0, 1, 1, 0, color, 1)\n\t}\n}\n\nfunc (f *Font) Print(batch *Batch, text string, x, y float32, color uint32) {\n\txx := x\n\tfor _, r := range text {\n\t\tif g, ok := f.glyphs[r]; ok {\n\t\t\tbatch.Draw(g.region, xx+g.xoffset, y+g.yoffset, 0, 0, 1, 1, 0, color, 1)\n\t\t\txx += g.xadvance\n\t\t}\n\t}\n}\n\nfunc (f *Font) Remap(mapping string) ", "output": "{\n\tglyphs := make(map[rune]*glyph)\n\n\ti := 0\n\tfor _, v := range mapping {\n\t\tglyphs[v] = f.glyphs[rune(i)]\n\t\ti++\n\t}\n\n\tf.glyphs = glyphs\n}"}
{"input": "package parser\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/dockpit/assert/strategy\"\n)\n\n\n\ntype PlainT struct {\n\tvalues     map[string]E\n\tarchetypes []*strategy.Archetype\n}\n\nfunc newPlainT(ats []*strategy.Archetype) *PlainT {\n\tif ats == nil {\n\t\tats = []*strategy.Archetype{}\n\t}\n\n\treturn &PlainT{\n\t\tvalues:     map[string]E{},\n\t\tarchetypes: ats,\n\t}\n}\n\n\n\nfunc (t *PlainT) Set(key string, e E) {\n\tt.values[key] = e\n}\n\nfunc (t *PlainT) Get(key string) E {\n\treturn t.values[key]\n}\n\nfunc (t *PlainT) Follows(ex T) error {\n\n\tactual := t.Get(\".0\")\n\texample := ex.Get(\".0\")\n\n\tafn, err := example.ToAssert(t.archetypes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn afn(actual)\n}\n\n\n\n\ntype Plain struct {\n\tarchetypes []*strategy.Archetype\n}\n\nfunc NewPlain(ats []*strategy.Archetype) *Plain {\n\treturn &Plain{ats}\n}\n\n\nfunc (p *Plain) Parse(data []byte) (T, error) {\n\tt := newPlainT(p.archetypes)\n\n\tstr := strings.TrimRightFunc(string(data), unicode.IsSpace)\n\n\te := NewElement(str)\n\n\tt.Set(\".0\", e)\n\n\treturn t, nil\n}\n\nfunc (t *PlainT) All() map[string]E ", "output": "{\n\treturn t.values\n}"}
{"input": "package delete\n\n\n\n\nimport (\n\t\"time\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/runtime\"\n\tcr \"github.com/go-openapi/runtime/client\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n)\n\n\n\nfunc NewDeleteNodesIdentifierParams() *DeleteNodesIdentifierParams {\n\tvar ()\n\treturn &DeleteNodesIdentifierParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}\n\n\n\nfunc NewDeleteNodesIdentifierParamsWithTimeout(timeout time.Duration) *DeleteNodesIdentifierParams {\n\tvar ()\n\treturn &DeleteNodesIdentifierParams{\n\n\t\ttimeout: timeout,\n\t}\n}\n\n\ntype DeleteNodesIdentifierParams struct {\n\n\tIdentifier string\n\n\ttimeout time.Duration\n}\n\n\nfunc (o *DeleteNodesIdentifierParams) WithIdentifier(identifier string) *DeleteNodesIdentifierParams {\n\to.Identifier = identifier\n\treturn o\n}\n\n\n\n\nfunc (o *DeleteNodesIdentifierParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error ", "output": "{\n\n\tr.SetTimeout(o.timeout)\n\tvar res []error\n\n\tif err := r.SetPathParam(\"identifier\", o.Identifier); err != nil {\n\t\treturn err\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package http_auth\n\nimport \"crypto/rand\"\nimport \"fmt\"\nimport \"sync\"\nimport \"time\"\n\ntype Server struct {\n\tsync.Mutex\n\tAuthFun                           func(user, realm string) string\n\topaque                            string\n\tRealm                             string\n\tReaperWaitSeconds, ReapTTLSeconds int\n\trequests                          map[string]*reqState\n}\ntype reqState struct {\n\tnreq    int\n\tsectime int64\n}\n\nfunc newServer(realm string, authfun func(user, realm string) string) *Server {\n\ts := new(Server)\n\ts.Realm = realm\n\ts.opaque = newNonce()\n\ts.AuthFun = authfun\n\ts.requests = map[string]*reqState{}\n\ts.ReaperWaitSeconds = 600\n\ts.ReapTTLSeconds = 3600\n\tgo reaper(s)\n\n\treturn s\n}\n\nfunc newNonce() string {\n\tb := make([]byte, 8)\n\tn, e := rand.Read(b)\n\tif n != 8 || e != nil {\n\t\tpanic(\"rand.Reader failed!\")\n\t}\n\treturn fmt.Sprintf(\"%x\", b)\n}\n\nfunc reaper(s *Server) {\n\tfor {\n\t\ttime.Sleep(time.Duration(s.ReaperWaitSeconds) * time.Second)\n\t\tdo_reap(s)\n\t}\n}\n\n\n\nfunc do_reap(s *Server) ", "output": "{\n\tnow := time.Now().UnixNano()\n\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tfor k, v := range s.requests {\n\t\tif v.sectime+int64(s.ReapTTLSeconds) < now {\n\t\t\tdelete(s.requests, k)\n\t\t}\n\t}\n}"}
{"input": "package upcrm\n\nimport (\n\t\"time\"\n\n\t\"go-common/app/admin/main/up/model/upcrmmodel\"\n)\n\n\n\n\n\nfunc (d *Dao) QueryUpRankAll(date time.Time) (result []upcrmmodel.UpRank, err error) {\n\terr = d.crmdb.Model(&upcrmmodel.UpRank{}).Where(\"generate_date=?\", date.Format(upcrmmodel.TimeFmtDate)).Find(&result).Error\n\treturn\n}\n\n\nfunc (d *Dao) GetUpRankLatestDate() (date time.Time, err error) {\n\tvar rankInfo = upcrmmodel.UpRank{}\n\terr = d.crmdb.Model(&rankInfo).Select(\"generate_date\").Order(\"generate_date desc\").Limit(1).Find(&rankInfo).Error\n\tif err == nil {\n\t\tdate, err = time.Parse(time.RFC3339, rankInfo.GenerateDate)\n\t}\n\treturn\n}\n\nfunc (d *Dao) QueryUpRank(rankType int, date time.Time) (result []upcrmmodel.UpRank, err error) ", "output": "{\n\terr = d.crmdb.Model(&upcrmmodel.UpRank{}).Where(\"type=? and generate_date=?\", rankType, date.Format(upcrmmodel.TimeFmtDate)).Find(&result).Error\n\treturn\n}"}
{"input": "package dom\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\n\ntype Node interface {\n\tString() string\n\tParent() Node\n\tSetParent(node Node)\n\tChildren() []Node\n\tAddChild(child Node)\n\tClone() Node\n}\n\n\ntype Element struct {\n\ttext     string\n\tparent   Node\n\tchildren []Node\n}\n\n\nfunc NewElement(text string) *Element {\n\treturn &Element{\n\t\ttext:     text,\n\t\tparent:   nil,\n\t\tchildren: make([]Node, 0),\n\t}\n}\n\n\nfunc (e *Element) Parent() Node {\n\treturn e.parent\n}\n\n\nfunc (e *Element) SetParent(node Node) {\n\te.parent = node\n}\n\n\nfunc (e *Element) Children() []Node {\n\treturn e.children\n}\n\n\nfunc (e *Element) AddChild(child Node) {\n\tcopy := child.Clone()\n\tcopy.SetParent(e)\n\te.children = append(e.children, copy)\n}\n\n\n\nfunc (e *Element) Clone() Node {\n\tcopy := &Element{\n\t\ttext:     e.text,\n\t\tparent:   nil,\n\t\tchildren: make([]Node, 0),\n\t}\n\tfor _, child := range e.children {\n\t\tcopy.AddChild(child)\n\t}\n\treturn copy\n}\n\n\n\n\nfunc (e *Element) String() string ", "output": "{\n\tbuffer := bytes.NewBufferString(e.text)\n\n\tfor _, c := range e.Children() {\n\t\ttext := c.String()\n\t\tfmt.Fprintf(buffer, \"\\n %s\", text)\n\t}\n\n\treturn buffer.String()\n}"}
{"input": "package cwl\n\nimport (\n\n)\n\ntype ArraySchema struct {\n\tItems []CWLType_Type `yaml:\"items,omitempty\" bson:\"items,omitempty\" json:\"items,omitempty\"` \n\tType  string         `yaml:\"type,omitempty\" bson:\"type,omitempty\" json:\"type,omitempty\"`    \n\tLabel string         `yaml:\"label,omitempty\" bson:\"label,omitempty\" json:\"label,omitempty\"`\n}\n\nfunc (c *ArraySchema) Is_Type()            {}\nfunc (c *ArraySchema) Type2String() string { return \"array\" }\n\n\n\nfunc NewArraySchema() *ArraySchema ", "output": "{\n\treturn &ArraySchema{Type: \"array\"}\n}"}
{"input": "package v1alpha1\n\nimport (\n\t\"context\"\n\n\t\"k8s.io/apimachinery/pkg/api/equality\"\n\n\t\"knative.dev/pkg/apis\"\n\t\"knative.dev/serving/pkg/apis/serving\"\n)\n\n\nfunc (c *Configuration) Validate(ctx context.Context) (errs *apis.FieldError) {\n\tif !apis.IsInStatusUpdate(ctx) {\n\t\terrs = errs.Also(serving.ValidateObjectMetadata(ctx, c.GetObjectMeta()).ViaField(\"metadata\"))\n\t\tctx = apis.WithinParent(ctx, c.ObjectMeta)\n\t\terrs = errs.Also(c.Spec.Validate(apis.WithinSpec(ctx)).ViaField(\"spec\"))\n\t}\n\n\tif apis.IsInUpdate(ctx) {\n\t\toriginal := apis.GetBaseline(ctx).(*Configuration)\n\t\tif c.GetOwnerReferences() == nil {\n\t\t\terrs = errs.Also(apis.ValidateCreatorAndModifier(original.Spec, c.Spec, original.GetAnnotations(),\n\t\t\t\tc.GetAnnotations(), serving.GroupName).ViaField(\"metadata.annotations\"))\n\t\t}\n\t\terr := c.Spec.GetTemplate().VerifyNameChange(ctx,\n\t\t\toriginal.Spec.GetTemplate())\n\t\terrs = errs.Also(err.ViaField(\"spec.revisionTemplate\"))\n\t}\n\n\treturn errs\n}\n\n\n\n\nfunc (cs *ConfigurationSpec) Validate(ctx context.Context) *apis.FieldError ", "output": "{\n\tif equality.Semantic.DeepEqual(cs, &ConfigurationSpec{}) {\n\t\treturn apis.ErrMissingField(apis.CurrentField)\n\t}\n\n\terrs := apis.CheckDeprecated(ctx, cs)\n\n\tvar templateField string\n\tswitch {\n\tcase cs.DeprecatedRevisionTemplate != nil && cs.Template != nil:\n\t\treturn apis.ErrMultipleOneOf(\"revisionTemplate\", \"template\")\n\tcase cs.DeprecatedRevisionTemplate != nil:\n\t\ttemplateField = \"revisionTemplate\"\n\tcase cs.Template != nil:\n\t\ttemplateField = \"template\"\n\t\tctx = apis.DisallowDeprecated(ctx)\n\tdefault:\n\t\treturn apis.ErrMissingOneOf(\"revisionTemplate\", \"template\")\n\t}\n\n\treturn errs.Also(cs.GetTemplate().Validate(ctx).ViaField(templateField))\n}"}
{"input": "package astutil\n\nimport (\n\t\"go/ast\"\n\t\"go/token\"\n\t\"strings\"\n)\n\nfunc IsIdent(expr ast.Expr, ident string) bool {\n\tid, ok := expr.(*ast.Ident)\n\treturn ok && id.Name == ident\n}\n\n\n\nfunc IsBlank(id ast.Expr) bool {\n\tident, _ := id.(*ast.Ident)\n\treturn ident != nil && ident.Name == \"_\"\n}\n\n\n\n\nfunc IsZero(expr ast.Expr) bool {\n\treturn IsIntLiteral(expr, \"0\")\n}\n\nfunc Preamble(f *ast.File) string {\n\tcutoff := f.Package\n\tif f.Doc != nil {\n\t\tcutoff = f.Doc.Pos()\n\t}\n\tvar out []string\n\tfor _, cmt := range f.Comments {\n\t\tif cmt.Pos() >= cutoff {\n\t\t\tbreak\n\t\t}\n\t\tout = append(out, cmt.Text())\n\t}\n\treturn strings.Join(out, \"\\n\")\n}\n\nfunc GroupSpecs(fset *token.FileSet, specs []ast.Spec) [][]ast.Spec {\n\tif len(specs) == 0 {\n\t\treturn nil\n\t}\n\tgroups := make([][]ast.Spec, 1)\n\tgroups[0] = append(groups[0], specs[0])\n\n\tfor _, spec := range specs[1:] {\n\t\tg := groups[len(groups)-1]\n\t\tif fset.PositionFor(spec.Pos(), false).Line-1 !=\n\t\t\tfset.PositionFor(g[len(g)-1].End(), false).Line {\n\n\t\t\tgroups = append(groups, nil)\n\t\t}\n\n\t\tgroups[len(groups)-1] = append(groups[len(groups)-1], spec)\n\t}\n\n\treturn groups\n}\n\nfunc IsIntLiteral(expr ast.Expr, literal string) bool ", "output": "{\n\tlit, ok := expr.(*ast.BasicLit)\n\treturn ok && lit.Kind == token.INT && lit.Value == literal\n}"}
{"input": "package internalversion\n\nimport (\n\tapi \"k8s.io/kubernetes/pkg/api\"\n\tregistered \"k8s.io/kubernetes/pkg/apimachinery/registered\"\n\trestclient \"k8s.io/kubernetes/pkg/client/restclient\"\n)\n\ntype QuotaInterface interface {\n\tRESTClient() restclient.Interface\n\tClusterResourceQuotasGetter\n}\n\n\ntype QuotaClient struct {\n\trestClient restclient.Interface\n}\n\nfunc (c *QuotaClient) ClusterResourceQuotas() ClusterResourceQuotaInterface {\n\treturn newClusterResourceQuotas(c)\n}\n\n\n\n\n\n\nfunc NewForConfigOrDie(c *restclient.Config) *QuotaClient {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n\n\nfunc New(c restclient.Interface) *QuotaClient {\n\treturn &QuotaClient{c}\n}\n\nfunc setConfigDefaults(config *restclient.Config) error {\n\tg, err := registered.Group(\"quota.openshift.io\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tconfig.APIPath = \"/apis\"\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = restclient.DefaultKubernetesUserAgent()\n\t}\n\tif config.GroupVersion == nil || config.GroupVersion.Group != g.GroupVersion.Group {\n\t\tcopyGroupVersion := g.GroupVersion\n\t\tconfig.GroupVersion = &copyGroupVersion\n\t}\n\tconfig.NegotiatedSerializer = api.Codecs\n\n\tif config.QPS == 0 {\n\t\tconfig.QPS = 5\n\t}\n\tif config.Burst == 0 {\n\t\tconfig.Burst = 10\n\t}\n\treturn nil\n}\n\n\n\nfunc (c *QuotaClient) RESTClient() restclient.Interface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.restClient\n}\n\nfunc NewForConfig(c *restclient.Config) (*QuotaClient, error) ", "output": "{\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := restclient.RESTClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &QuotaClient{client}, nil\n}"}
{"input": "package jujuc\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"launchpad.net/gnuflag\"\n\n\t\"github.com/juju/core/cmd\"\n)\n\n\ntype UnitGetCommand struct {\n\tcmd.CommandBase\n\tctx Context\n\tKey string\n\tout cmd.Output\n}\n\nfunc NewUnitGetCommand(ctx Context) cmd.Command {\n\treturn &UnitGetCommand{ctx: ctx}\n}\n\nfunc (c *UnitGetCommand) Info() *cmd.Info {\n\treturn &cmd.Info{\n\t\tName:    \"unit-get\",\n\t\tArgs:    \"<setting>\",\n\t\tPurpose: \"print public-address or private-address\",\n\t}\n}\n\nfunc (c *UnitGetCommand) SetFlags(f *gnuflag.FlagSet) {\n\tc.out.AddFlags(f, \"smart\", cmd.DefaultFormatters)\n}\n\n\n\nfunc (c *UnitGetCommand) Run(ctx *cmd.Context) error {\n\tvalue, ok := \"\", false\n\tif c.Key == \"private-address\" {\n\t\tvalue, ok = c.ctx.PrivateAddress()\n\t} else {\n\t\tvalue, ok = c.ctx.PublicAddress()\n\t}\n\tif !ok {\n\t\treturn fmt.Errorf(\"%s not set\", c.Key)\n\t}\n\treturn c.out.Write(ctx, value)\n}\n\nfunc (c *UnitGetCommand) Init(args []string) error ", "output": "{\n\tif args == nil {\n\t\treturn errors.New(\"no setting specified\")\n\t}\n\tif args[0] != \"private-address\" && args[0] != \"public-address\" {\n\t\treturn fmt.Errorf(\"unknown setting %q\", args[0])\n\t}\n\tc.Key = args[0]\n\treturn cmd.CheckEmpty(args[1:])\n}"}
{"input": "package tracing\n\nimport (\n\t\"bufio\"\n\t\"net\"\n\t\"net/http\"\n)\n\ntype statusCodeRecoder interface {\n\thttp.ResponseWriter\n\tStatus() int\n}\n\ntype statusCodeWithoutCloseNotify struct {\n\thttp.ResponseWriter\n\tstatus int\n}\n\n\n\n\n\nfunc (s *statusCodeWithoutCloseNotify) Status() int {\n\treturn s.status\n}\n\n\nfunc (s *statusCodeWithoutCloseNotify) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\treturn s.ResponseWriter.(http.Hijacker).Hijack()\n}\n\n\nfunc (s *statusCodeWithoutCloseNotify) Flush() {\n\tif flusher, ok := s.ResponseWriter.(http.Flusher); ok {\n\t\tflusher.Flush()\n\t}\n}\n\ntype statusCodeWithCloseNotify struct {\n\t*statusCodeWithoutCloseNotify\n}\n\nfunc (s *statusCodeWithCloseNotify) CloseNotify() <-chan bool {\n\treturn s.ResponseWriter.(http.CloseNotifier).CloseNotify()\n}\n\n\nfunc newStatusCodeRecoder(rw http.ResponseWriter, status int) statusCodeRecoder {\n\trecorder := &statusCodeWithoutCloseNotify{rw, status}\n\tif _, ok := rw.(http.CloseNotifier); ok {\n\t\treturn &statusCodeWithCloseNotify{recorder}\n\t}\n\treturn recorder\n}\n\nfunc (s *statusCodeWithoutCloseNotify) WriteHeader(status int) ", "output": "{\n\ts.status = status\n\ts.ResponseWriter.WriteHeader(status)\n}"}
{"input": "package console\n\nimport \"github.com/accurateproject/accurate/api/v1\"\n\nfunc init() {\n\tc := &CmdExecuteScheduledActions{\n\t\tname:      \"scheduler_execute\",\n\t\trpcMethod: \"ApiV1.ExecuteScheduledActions\",\n\t\trpcParams: &v1.AttrsExecuteScheduledActions{},\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}\n\n\ntype CmdExecuteScheduledActions struct {\n\tname      string\n\trpcMethod string\n\trpcParams *v1.AttrsExecuteScheduledActions\n\t*CommandExecuter\n}\n\nfunc (self *CmdExecuteScheduledActions) Name() string {\n\treturn self.name\n}\n\nfunc (self *CmdExecuteScheduledActions) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\nfunc (self *CmdExecuteScheduledActions) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &v1.AttrsExecuteScheduledActions{}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *CmdExecuteScheduledActions) PostprocessRpcParams() error {\n\treturn nil\n}\n\n\n\nfunc (self *CmdExecuteScheduledActions) RpcResult() interface{} ", "output": "{\n\tvar s string\n\treturn &s\n}"}
{"input": "package web\n\nimport (\n\t\"strings\"\n\n\t\"github.com/gopherjs/gopherjs/js\"\n)\n\nfunc IsNodeJS() bool {\n\treturn js.Global.Get(\"require\") != js.Undefined\n}\n\n\n\nfunc IsIOSSafari() bool {\n\tua := js.Global.Get(\"navigator\").Get(\"userAgent\").String()\n\tif !strings.Contains(ua, \"iPhone\") {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc IsAndroidChrome() bool {\n\tua := js.Global.Get(\"navigator\").Get(\"userAgent\").String()\n\tif !strings.Contains(ua, \"Android\") {\n\t\treturn false\n\t}\n\tif !strings.Contains(ua, \"Chrome\") {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc IsMobileBrowser() bool {\n\treturn IsIOSSafari() || IsAndroidChrome()\n}\n\nfunc IsBrowser() bool ", "output": "{\n\treturn !IsNodeJS()\n}"}
{"input": "package processorconfig\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\n\t\"github.com/nuclio/nuclio/pkg/processor\"\n\n\t\"github.com/ghodss/yaml\"\n\t\"github.com/nuclio/errors\"\n)\n\n\ntype Reader struct {\n}\n\n\nfunc NewReader() (*Reader, error) {\n\treturn &Reader{}, nil\n}\n\n\n\n\nfunc (r *Reader) Read(reader io.Reader, processorConfiguration *processor.Configuration) error ", "output": "{\n\tbodyBytes, err := ioutil.ReadAll(reader)\n\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"Failed to read processor configuration\")\n\t}\n\n\tif err := yaml.Unmarshal(bodyBytes, processorConfiguration); err != nil {\n\t\treturn errors.Wrap(err, \"Failed to write configuration\")\n\t}\n\n\tif processorConfiguration.Spec.EventTimeout != \"\" {\n\t\t_, err := processorConfiguration.Spec.GetEventTimeout()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"Can't parse Spec.EventTimeout (%q) into time.Duration\", processorConfiguration.Spec.EventTimeout)\n\t\t}\n\t}\n\n\treturn nil\n}"}
{"input": "package responses\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\nfunc respond(w http.ResponseWriter, s interface{}, code int) {\n\tw.WriteHeader(code)\n\tif s != nil {\n\t\tjson.NewEncoder(w).Encode(s)\n\t}\n}\n\n\n\n\nfunc RespondSuccess(w http.ResponseWriter, s interface{}) {\n\trespond(w, s, http.StatusOK)\n}\n\n\nfunc RespondNotFound(w http.ResponseWriter) {\n\trespond(w, nil, http.StatusNotFound)\n}\n\n\nfunc RespondUnauthorizedBearerJWT(w http.ResponseWriter) {\n\tw.Header().Set(\"WWW-Authenticate\", `Bearer token_type=\"JWT\"`)\n\trespondError(w, \"You are not authorized\", http.StatusUnauthorized)\n}\n\n\nfunc RespondInternalError(w http.ResponseWriter, m string) {\n\trespondError(w, m, http.StatusInternalServerError)\n}\n\n\nfunc RespondBadRequest(w http.ResponseWriter, m string) {\n\trespondError(w, m, http.StatusBadRequest)\n}\n\nfunc respondError(w http.ResponseWriter, m string, code int) ", "output": "{\n\ts := struct {\n\t\tError string `json:\"error\"`\n\t}{\n\t\tError: m,\n\t}\n\n\trespond(w, s, code)\n}"}
{"input": "package postgres\n\nimport \"github.com/aodin/sol\"\n\n\n\n\n\ntype TableElem struct {\n\t*sol.TableElem\n}\n\nvar _ sol.Tabular = &TableElem{}\n\n\n\n\nfunc (table TableElem) Column(name string) ColumnElem {\n\treturn ColumnElem{ColumnElem: table.TableElem.Column(name)}\n}\n\n\nfunc (table TableElem) C(name string) ColumnElem {\n\treturn table.Column(name)\n}\n\n\nfunc (table *TableElem) Insert() InsertStmt {\n\treturn Insert(table)\n}\n\n\n\n\nfunc Table(name string, modifiers ...sol.Modifier) *TableElem ", "output": "{\n\treturn &TableElem{TableElem: sol.Table(name, modifiers...)}\n}"}
{"input": "package content\n\nimport (\n\t\"context\"\n\n\tcontentapi \"github.com/containerd/containerd/api/services/content/v1\"\n\tdigest \"github.com/opencontainers/go-digest\"\n)\n\ntype remoteReaderAt struct {\n\tctx    context.Context\n\tdigest digest.Digest\n\tsize   int64\n\tclient contentapi.ContentClient\n}\n\nfunc (ra *remoteReaderAt) Size() int64 {\n\treturn ra.size\n}\n\n\n\nfunc (ra *remoteReaderAt) Close() error {\n\treturn nil\n}\n\nfunc (ra *remoteReaderAt) ReadAt(p []byte, off int64) (n int, err error) ", "output": "{\n\trr := &contentapi.ReadContentRequest{\n\t\tDigest: ra.digest,\n\t\tOffset: off,\n\t\tSize_:  int64(len(p)),\n\t}\n\trc, err := ra.client.Read(ra.ctx, rr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tfor len(p) > 0 {\n\t\tvar resp *contentapi.ReadContentResponse\n\t\tresp, err = rc.Recv()\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\n\t\tcopied := copy(p, resp.Data)\n\t\tn += copied\n\t\tp = p[copied:]\n\t}\n\treturn n, nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nconst delta = 1e-10\n\n\n\nfunc main() {\n\tconst x = 2\n\tmine, theirs := Sqrt(x), math.Sqrt(x)\n\tfmt.Println(mine, theirs, mine-theirs)\n}\n\nfunc Sqrt(x float64) float64 ", "output": "{\n\tz := x\n\tfor {\n\t\tn := z - (z*z-x)/(2*z)\n\t\tif math.Abs(n-z) < delta {\n\t\t\tbreak\n\t\t}\n\t\tz = n\n\t}\n\treturn z\n}"}
{"input": "package handlers\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/xoriath/alexandria-go/fetch\"\n\t\"github.com/xoriath/alexandria-go/index\"\n\t\"github.com/xoriath/alexandria-go/types\"\n)\n\n\ntype ReloadBook struct {\n\tbooks *types.Books\n\tindex string\n}\n\n\nfunc NewReloadBookHandler(books *types.Books, index string) *ReloadBook {\n\treturn &ReloadBook{books: books, index: index}\n}\n\nfunc (rb *ReloadBook) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\ttempBooks, err := fetch.MainIndex(rb.index)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t} else {\n\t\trb.books = tempBooks\n\t\tjson.NewEncoder(w).Encode(rb.books)\n\t}\n}\n\n\ntype ReloadKeyword struct {\n\tbooks     *types.Books\n\tstore     *index.Store\n\tf1Pattern string\n}\n\n\nfunc NewReloadKeywordHandler(books *types.Books, store *index.Store, f1Pattern string) *ReloadKeyword {\n\treturn &ReloadKeyword{books: books, store: store, f1Pattern: f1Pattern}\n}\n\n\n\nfunc (rk *ReloadKeyword) ServeHTTP(w http.ResponseWriter, r *http.Request) ", "output": "{\n\trk.store = fetch.F1Indexes(rk.books, rk.store)\n\n\tstat := rk.store.GetStatistics()\n\tjson.NewEncoder(w).Encode(stat)\n}"}
{"input": "package sections\n\ntype Entry interface {\n\tFilename() string\n\tName() string\n\tContent() []byte\n\tPersist() error\n}\n\ntype commonSectionInfo struct {\n\tfilename   string\n\tname       string\n\tcontent    []byte\n\tcontentDir string\n}\n\nfunc (i *commonSectionInfo) Filename() string { return i.filename }\nfunc (i *commonSectionInfo) Name() string     { return i.name }\n\n\nfunc (i *commonSectionInfo) Content() []byte  ", "output": "{ return i.content }"}
{"input": "package util\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"strings\"\n\t\"syscall\"\n)\n\n\n\n\n\n\n\n\nfunc FindStringSubmatchMap(s string, r *regexp.Regexp) map[string]string {\n\tcaptures := make(map[string]string)\n\tmatch := r.FindStringSubmatch(s)\n\tif match == nil {\n\t\treturn captures\n\t}\n\tfor i, name := range r.SubexpNames() {\n\t\tif i != 0 {\n\t\t\tcaptures[name] = match[i]\n\t\t}\n\t}\n\treturn captures\n}\n\nfunc ExecCommandOutput(cmd string, args []string) (string, int, error) ", "output": "{\n\tLogDebug.Print(\"ExecCommandOutput called with \", cmd, args)\n\tc := exec.Command(cmd, args...)\n\tvar b bytes.Buffer\n\tc.Stdout = &b\n\tc.Stderr = &b\n\n\tif err := c.Start(); err != nil {\n\t\treturn \"\", 999, err\n\t}\n\n\n\terr := c.Wait()\n\tout := string(b.Bytes())\n\n\tfor _, line := range strings.Split(out, \"\\n\") {\n\t\tLogDebug.Print(\"out :\", line)\n\t}\n\n\tif err != nil {\n\t\tif badnews, ok := err.(*exec.ExitError); ok {\n\t\t\tif status, ok := badnews.Sys().(syscall.WaitStatus); ok {\n\t\t\t\treturn out, status.ExitStatus(), fmt.Errorf(\"rc=%d\", status.ExitStatus())\n\t\t\t}\n\t\t} else {\n\t\t\treturn out, 888, fmt.Errorf(\"unknown error\")\n\t\t}\n\t}\n\n\treturn out, 0, nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype App struct {\n\tservice *Service\n}\n\n\nfunc NewApp() (*App, error) {\n\trawAccessTokenExpiration := DefaultEnv(\"ACCESS_TOKEN_EXPIRATION\", \"15000\")\n\taccessTokenExpiration, err := strconv.Atoi(rawAccessTokenExpiration)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tauthenticator := NewUserServiceAuthenticator(\n\t\tRequireEnv(\"SERVICE_MODEL_USER\"),\n\t\tDefaultEnv(\"ISSUER\", \"service.api.auth\"),\n\t\taccessTokenExpiration,\n\t\t[]byte(RequireEnv(\"SIGNING_KEY\")),\n\t)\n\n\tservice := NewService(authenticator)\n\tservice.getParams = func(r *http.Request) map[string]string {\n\t\treturn mux.Vars(r)\n\t}\n\n\treturn &App{\n\t\tservice: service,\n\t}, nil\n}\n\nfunc (app *App) Shutdown() {\n}\n\nfunc (app *App) Listen() error {\n\thandler := app.CreateHandler()\n\n\treturn http.ListenAndServe(\":80\", handler)\n}\n\nfunc (app *App) CreateHandler() http.Handler {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(\"/authenticate\", app.service.Authenticate).Methods(\"POST\")\n\n\treturn router\n}\n\n\n\nfunc DefaultEnv(key string, def string) string {\n\tvalue, ok := os.LookupEnv(key)\n\tif !ok {\n\t\treturn def\n\t}\n\n\treturn value\n}\n\nfunc RequireEnv(key string) string ", "output": "{\n\tvalue, ok := os.LookupEnv(key)\n\tif !ok {\n\t\tpanic(fmt.Sprintf(\"Environment variable %s is mandatory\", key))\n\t}\n\n\treturn value\n}"}
{"input": "package testutil\n\nimport (\n\t\"testing\"\n\n\tci \"gx/ipfs/QmP1DfoUjiWH2ZBo1PBH6FupdBucbDepx3HpWmEY6JMUpY/go-libp2p-crypto\"\n\tma \"gx/ipfs/QmcyqRMCAXVtYPS4DiBrA7sezL9rRGfW8Ctx7cywL4TXJj/go-multiaddr\"\n\tpeer \"gx/ipfs/QmdS9KpbDyPrieswibZhkod1oXqRwZJrUPzxCofAMWpFGq/go-libp2p-peer\"\n)\n\ntype Identity interface {\n\tAddress() ma.Multiaddr\n\tID() peer.ID\n\tPrivateKey() ci.PrivKey\n\tPublicKey() ci.PubKey\n}\n\n\n\n\n\nfunc RandIdentityOrFatal(t *testing.T) Identity {\n\tp, err := RandPeerNetParams()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn &identity{*p}\n}\n\n\ntype identity struct {\n\tPeerNetParams\n}\n\nfunc (p *identity) ID() peer.ID {\n\treturn p.PeerNetParams.ID\n}\n\nfunc (p *identity) Address() ma.Multiaddr {\n\treturn p.Addr\n}\n\nfunc (p *identity) PrivateKey() ci.PrivKey {\n\treturn p.PrivKey\n}\n\nfunc (p *identity) PublicKey() ci.PubKey {\n\treturn p.PubKey\n}\n\nfunc RandIdentity() (Identity, error) ", "output": "{\n\tp, err := RandPeerNetParams()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &identity{*p}, nil\n}"}
{"input": "package network\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n)\n\nconst (\n\tresolverFileName    = \"/etc/resolv.conf\"\n\tclusterDomainEnvKey = \"CLUSTER_DOMAIN\"\n\tdefaultDomainName   = \"cluster.local\"\n)\n\nvar (\n\tdomainName = defaultDomainName\n\tonce       sync.Once\n)\n\n\n\n\n\n\nfunc GetClusterDomainName() string {\n\tonce.Do(func() {\n\t\tf, err := os.Open(resolverFileName)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer f.Close()\n\t\tdomainName = getClusterDomainName(f)\n\t})\n\treturn domainName\n}\n\nfunc getClusterDomainName(r io.Reader) string {\n\tfor scanner := bufio.NewScanner(r); scanner.Scan(); {\n\t\telements := strings.Split(scanner.Text(), \" \")\n\t\tif elements[0] != \"search\" {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, e := range elements[1:] {\n\t\t\tif strings.HasPrefix(e, \"svc.\") {\n\t\t\t\treturn strings.TrimSuffix(e[4:], \".\")\n\t\t\t}\n\t\t}\n\t}\n\n\tif domain := os.Getenv(clusterDomainEnvKey); len(domain) > 0 {\n\t\treturn domain\n\t}\n\n\treturn defaultDomainName\n}\n\nfunc GetServiceHostname(name, namespace string) string ", "output": "{\n\treturn fmt.Sprintf(\"%s.%s.svc.%s\", name, namespace, GetClusterDomainName())\n}"}
{"input": "package discovery\n\nimport (\n\t\"fmt\"\n\t\"github.com/spencergibb/go-nuvem/util\"\n\t\"github.com/spf13/viper\"\n\t\"net\"\n\t\"strconv\"\n)\n\ntype StaticDiscovery struct {\n\tNamespace string\n\tInstances []string\n}\n\nfunc (s *StaticDiscovery) Configure(namespace string) {\n\tif s.Namespace != \"\" {\n\t\tfmt.Errorf(\"%s already inited: %s\", StaticFactoryKey, s.Namespace)\n\t\treturn\n\t}\n\ts.Namespace = namespace\n\tinstances := viper.GetStringSlice(util.GetStaticRegistryKey(s))\n\tfmt.Printf(\"instances %+v\\n\", instances)\n\ts.Instances = instances\n}\n\n\n\nfunc (s *StaticDiscovery) GetNamespace() string {\n\treturn s.Namespace\n}\n\nfunc NewStaticDiscovery() Discovery {\n\treturn &StaticDiscovery{}\n}\n\nvar StaticFactoryKey = \"StaticDiscovery\"\n\nfunc init() {\n\tprintln(\"registering static discovery\")\n\tRegister(StaticFactoryKey, NewStaticDiscovery)\n}\n\nfunc (s *StaticDiscovery) GetIntances() []util.Instance ", "output": "{\n\tinstances := make([]util.Instance, len(s.Instances))\n\n\tfor i, config := range s.Instances {\n\t\thost, portStr, err := net.SplitHostPort(config)\n\n\t\tport, err := strconv.Atoi(portStr)\n\n\t\tprint(err) \n\n\t\tinstances[i] = util.Instance{Host: host, Port: port}\n\t}\n\n\treturn instances\n}"}
{"input": "package helpers\n\nimport (\n\t\"fmt\"\n\n\t. \"github.com/onsi/ginkgo\"\n)\n\nconst V7 = true\n\n\n\n\n\n\nfunc SkipIfV7() {\n\tSkip(fmt.Sprintf(\"Not implemented for V7 yet\"))\n}\n\nfunc SkipIfV7AndVersionLessThan(minVersion string) ", "output": "{\n\tSkipIfVersionLessThan(minVersion)\n}"}
{"input": "package checker_test\n\nimport (\n\t\"go/token\"\n\t\"testing\"\n\n\t. \"github.com/s2gatev/lingo/checker\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestLineLengthChecker(t *testing.T) ", "output": "{\n\tinput := `package foo\n\n\tfunc TestFooBarFunctionVeryLong(a int, b int, c int, d int) (error, float64) {}`\n\n\tchecker := NewFileChecker()\n\tchecker.Register(NewLineLengthChecker(&LineLengthConfig{\n\t\tMaxLength: 80,\n\t\tTabWidth:  4,\n\t}))\n\n\tfileSet := token.NewFileSet()\n\tfile := ParseFileContentInSet(fileSet, input)\n\n\tvar report Report\n\tchecker.Check(file, input, &report)\n\n\tassert.Equal(t,\n\t\tReport{\n\t\t\tErrors: []Error{\n\t\t\t\t{\n\t\t\t\t\tPos:     14,\n\t\t\t\t\tMessage: \"line is too long\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\treport)\n\tassert.Equal(t, 3, fileSet.Position(report.Errors[0].Pos).Line)\n}"}
{"input": "package scanner\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestMd5(t *testing.T) {\n\tfile, _ := ioutil.TempFile(os.TempDir(), \"prefix\")\n\tdefer os.Remove(file.Name())\n\n\tioutil.WriteFile(file.Name(), []byte(\"constant text string\"), 0644)\n\n\tmd5, _ := ComputeMd5(file.Name())\n\tt.Log(\"Path=\", file.Name(), \", MD5=\", md5)\n\n\texpected := []byte{196, 84, 116, 50, 184, 145, 163, 237, 46, 107, 22, 229, 141, 66, 249, 123}\n\tif !bytes.Equal(md5, expected) {\n\t\tt.Error(\"bad md5=\", md5, \", expected=\", expected)\n\t}\n}\n\n\n\nfunc TestSize(t *testing.T) ", "output": "{\n\tfile, _ := ioutil.TempFile(os.TempDir(), \"prefix\")\n\tdefer os.Remove(file.Name())\n\n\tioutil.WriteFile(file.Name(), []byte(\"constant text string\"), 0644)\n\n\tsize, _, _ := GetFileStats(file.Name())\n\n\texpected := int64(20)\n\tif size != expected {\n\t\tt.Error(\"bad size=\", size, \", expected=\", expected)\n\t}\n}"}
{"input": "package devicehive_go\n\nimport (\n\t\"strings\"\n\t\"time\"\n)\n\n\ntype ISO8601Time struct {\n\ttime.Time\n}\n\nfunc (t *ISO8601Time) String() string {\n\treturn t.Time.Format(timestampLayout)\n}\n\nfunc (t *ISO8601Time) UnmarshalJSON(b []byte) (err error) {\n\ts := strings.Trim(string(b), \"\\\"\")\n\n\tif s == \"null\" || s == \"\" {\n\t\tt.Time = time.Time{}\n\t\treturn\n\t}\n\n\tt.Time, err = time.Parse(timestampLayout, s)\n\n\treturn\n}\n\n\n\nfunc (t *ISO8601Time) MarshalJSON() (b []byte, err error) ", "output": "{\n\tif t.Time.UnixNano() <= 0 {\n\t\treturn []byte(\"\\\"\\\"\"), nil\n\t}\n\n\treturn []byte(\"\\\"\" + t.String() + \"\\\"\"), nil\n}"}
{"input": "package bandwidth\n\n\n\nfunc (api *Client) TerminateConference(id string) error{\n\treturn api.UpdateConference(id, &UpdateConferenceData{State: \"completed\"})\n}\n\n\n\nfunc (api *Client) MuteConference(id string, mute bool) error{\n\treturn api.UpdateConference(id, &UpdateConferenceData{Mute: mute})\n}\n\n\n\n\n\n\n\nfunc (api *Client) MuteConferenceMember(id string, memberID string, mute bool) error{\n\treturn api.UpdateConferenceMember(id, memberID, &UpdateConferenceMemberData{Mute: mute})\n}\n\n\n\nfunc (api *Client) HoldConferenceMember(id string, memberID string, hold bool) error{\n\treturn api.UpdateConferenceMember(id, memberID, &UpdateConferenceMemberData{Hold: hold})\n}\n\nfunc (api *Client) DeleteConferenceMember(id string, memberID string) error", "output": "{\n\treturn api.UpdateConferenceMember(id, memberID, &UpdateConferenceMemberData{State: \"completed\"})\n}"}
{"input": "package interval\n\n\ntype SegmentTree struct {\n\tsize int\n\tdata []int\n}\n\n\nfunc NewSegmentTree(size int) *SegmentTree {\n\tt := &SegmentTree{\n\t\tsize: size,\n\t\tdata: make([]int, size*2),\n\t}\n\treturn t\n}\n\n\nfunc (t *SegmentTree) Build(values []int) {\n\tt.size = len(values)\n\tfor i := 0; i < t.size; i++ {\n\t\tt.data[t.size+i] = values[i]\n\t}\n\tfor i := t.size - 1; i > 0; i-- {\n\t\tt.data[i] = t.data[i<<1] + t.data[i<<1|1]\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (t *SegmentTree) QueryRange(i, j int) int {\n\tvar res int\n\ti += t.size\n\tj += t.size\n\tfor i < j {\n\t\tif (i & 1) == 1 {\n\t\t\tres = res + t.data[i]\n\t\t\ti++\n\t\t}\n\t\tif (j & 1) == 1 {\n\t\t\tj--\n\t\t\tres = res + t.data[j]\n\n\t\t}\n\t\ti >>= 1\n\t\tj >>= 1\n\t}\n\treturn res\n}\n\nfunc (t *SegmentTree) Modify(i int, value int) ", "output": "{\n\ti += t.size\n\tt.data[i] = value\n\tfor ; i > 1; i >>= 1 {\n\t\tt.data[i>>1] = t.data[i] + t.data[i^1]\n\t}\n}"}
{"input": "package ego\n\nimport (\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\n\nconst AuthUserKey = \"user\"\n\ntype (\n\tAccounts  map[string]string\n\tauthPairs []authPair\n)\n\ntype authPair struct {\n\tvalue string\n\tuser  string\n}\n\nfunc (a authPairs) searchCredential(authValue string) (string, bool) {\n\tif authValue == \"\" {\n\t\treturn \"\", false\n\t}\n\tfor _, pair := range a {\n\t\tif pair.value == authValue {\n\t\t\treturn pair.user, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n\n\n\n\nfunc BasicAuthForRealm(accounts Accounts, realm string) HandlerFunc {\n\tif realm == \"\" {\n\t\trealm = \"Authorization Required\"\n\t}\n\trealm = \"Basic realm=\" + strconv.Quote(realm)\n\tpairs := processAccounts(accounts)\n\treturn func(c *Context) {\n\t\tuser, found := pairs.searchCredential(c.requestHeader(\"Authorization\"))\n\t\tif !found {\n\t\t\tc.Header(\"WWW-Authenticate\", realm)\n\t\t\tc.AbortWithStatus(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tc.Set(AuthUserKey, user)\n\t}\n}\n\n\n\nfunc BasicAuth(accounts Accounts) HandlerFunc {\n\treturn BasicAuthForRealm(accounts, \"\")\n}\n\n\n\nfunc authorizationHeader(user, password string) string {\n\tbase := user + \":\" + password\n\treturn \"Basic \" + base64.StdEncoding.EncodeToString([]byte(base))\n}\n\nfunc secureCompare(given, actual string) bool {\n\tif subtle.ConstantTimeEq(int32(len(given)), int32(len(actual))) == 1 {\n\t\treturn subtle.ConstantTimeCompare([]byte(given), []byte(actual)) == 1\n\t}\n\treturn subtle.ConstantTimeCompare([]byte(actual), []byte(actual)) == 1 && false\n}\n\nfunc processAccounts(accounts Accounts) authPairs ", "output": "{\n\tassert1(len(accounts) > 0, \"Empty list of authorized credentials\")\n\tpairs := make(authPairs, 0, len(accounts))\n\tfor user, password := range accounts {\n\t\tassert1(user != \"\", \"User can not be empty\")\n\t\tvalue := authorizationHeader(user, password)\n\t\tpairs = append(pairs, authPair{\n\t\t\tvalue: value,\n\t\t\tuser:  user,\n\t\t})\n\t}\n\treturn pairs\n}"}
{"input": "package shutdown\n\nimport (\n\t\"log\"\n\t\"os/exec\"\n\t\"strconv\"\n)\n\nfunc abort() {\n\trun(\"/a\")\n}\n\n\n\n\nfunc run(args ...string) {\n\tcmd := exec.Command(\"shutdown\", args...)\n\terr := cmd.Run()\n\tif err != nil {\n\t\tlog.Println(\"error: \" + err.Error())\n\t}\n}\n\nfunc start(sec int) ", "output": "{\n\trun(\"/s\", \"/t\", strconv.Itoa(sec))\n}"}
{"input": "package gobot\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"gobot.io/x/gobot/gobottest\"\n)\n\nfunc TestEventerAddEvent(t *testing.T) {\n\te := NewEventer()\n\te.AddEvent(\"test\")\n\n\tif _, ok := e.Events()[\"test\"]; !ok {\n\t\tt.Errorf(\"Could not add event to list of Event names\")\n\t}\n\tgobottest.Assert(t, e.Event(\"test\"), \"test\")\n}\n\n\n\nfunc TestEventerOn(t *testing.T) {\n\te := NewEventer()\n\te.AddEvent(\"test\")\n\n\tsem := make(chan bool)\n\te.On(\"test\", func(data interface{}) {\n\t\tsem <- true\n\t})\n\n\tgo func() {\n\t\te.Publish(\"test\", true)\n\t}()\n\n\tselect {\n\tcase <-sem:\n\tcase <-time.After(10 * time.Millisecond):\n\t\tt.Errorf(\"On was not called\")\n\t}\n}\n\nfunc TestEventerOnce(t *testing.T) {\n\te := NewEventer()\n\te.AddEvent(\"test\")\n\n\tsem := make(chan bool)\n\te.Once(\"test\", func(data interface{}) {\n\t\tsem <- true\n\t})\n\n\tgo func() {\n\t\te.Publish(\"test\", true)\n\t}()\n\n\tselect {\n\tcase <-sem:\n\tcase <-time.After(10 * time.Millisecond):\n\t\tt.Errorf(\"Once was not called\")\n\t}\n\n\tgo func() {\n\t\te.Publish(\"test\", true)\n\t}()\n\n\tselect {\n\tcase <-sem:\n\t\tt.Errorf(\"Once was called twice\")\n\tcase <-time.After(10 * time.Millisecond):\n\t}\n}\n\nfunc TestEventerDeleteEvent(t *testing.T) ", "output": "{\n\te := NewEventer()\n\te.AddEvent(\"test1\")\n\te.DeleteEvent(\"test1\")\n\n\tif _, ok := e.Events()[\"test1\"]; ok {\n\t\tt.Errorf(\"Could not add delete event from list of Event names\")\n\t}\n}"}
{"input": "package renameio\n\nimport \"os\"\n\n\n\ntype Option interface {\n\tapply(*config)\n}\n\ntype optionFunc func(*config)\n\nfunc (fn optionFunc) apply(cfg *config) {\n\tfn(cfg)\n}\n\n\n\n\nfunc WithTempDir(dir string) Option {\n\treturn optionFunc(func(cfg *config) {\n\t\tcfg.dir = dir\n\t})\n}\n\n\n\n\n\n\n\n\nfunc IgnoreUmask() Option {\n\treturn optionFunc(func(cfg *config) {\n\t\tcfg.ignoreUmask = true\n\t})\n}\n\n\n\n\nfunc WithStaticPermissions(perm os.FileMode) Option {\n\tperm &= os.ModePerm\n\treturn optionFunc(func(cfg *config) {\n\t\tcfg.chmod = &perm\n\t})\n}\n\n\n\n\n\nfunc WithExistingPermissions() Option {\n\treturn optionFunc(func(c *config) {\n\t\tc.attemptPermCopy = true\n\t})\n}\n\nfunc WithPermissions(perm os.FileMode) Option ", "output": "{\n\tperm &= os.ModePerm\n\treturn optionFunc(func(cfg *config) {\n\t\tcfg.createPerm = perm\n\t})\n}"}
{"input": "package handler_frontend\n\nimport (\n\t\"git.vdo.space/berk/model\"\n\tdm \"git.vdo.space/foy/model\"\n\t\"git.vdo.space/foy/proto\"\n)\n\n\nfunc (m *FController) FeedbacksCreate(ts []*model.Feedback) (*dm.ResultModel, error) {\n\n\trm := dm.ResultModel{}\n\n\tt, err := model.NewFeedbacks(ts)\n\n\tif err != nil {\n\t\trm.Errors = append(rm.Errors, dm.NewError(err))\n\t} else {\n\t\trm.Data = t\n\t}\n\n\treturn &rm, nil\n}\n\n\n\n\nfunc (m *FController) FeedbackList(req *proto.RequestParams) (*dm.ResultModel, error) ", "output": "{\n\n\trm := dm.ResultModel{}\n\n\tts, count, err := model.FindFeedbacksByParams(req, true)\n\n\tif err != nil {\n\n\n\t\trm.Errors = append(rm.Errors, dm.NewError(err))\n\t} else {\n\t\tpm := dm.PageModelBase{}\n\t\tpm.PageData = ts\n\t\tpm.Count = count\n\t\trm.Data = pm\n\t}\n\n\treturn &rm, nil\n}"}
{"input": "package elasticsearch\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/luopengift/gohttp\"\n)\n\nconst (\n\tenter = '\\n'\n)\n\ntype Meta struct {\n\tIndex string `json:\"_index\"`\n\tType  string `json:\"_type\"`\n\tId    string `json:\"_id,omitempty\"`\n}\n\nfunc NewMeta(_index, _type, _id string) *Meta {\n\treturn &Meta{_index, _type, _id}\n}\n\ntype Bulk struct {\n\tIndex  *Meta  `json:\"index,omitempty\"`\n\tUpdate *Meta  `json:\"update,omitempty\"`\n\tSource []byte `json:\"-\"`\n}\n\nfunc NewBulkIndex(_index, _type, _id string, source []byte) *Bulk {\n\treturn &Bulk{\n\t\tIndex:  NewMeta(_index, _type, _id),\n\t\tSource: source,\n\t}\n}\n\n\n\nfunc (b *Bulk) Bytes() ([]byte, error) {\n\tp, err := json.Marshal(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp = append(p, enter)\n\tp = append(p, b.Source...)\n\tp = append(p, enter)\n\treturn p, nil\n}\n\nfunc Send(addr string, p []byte) error {\n\tresp, err := gohttp.NewClient().URLString(\"http://\"+addr).Path(\"/_bulk\").Header(\"Accept\", \"application/json\").Body(p).Post()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif resp.Code() != 200 {\n\t\treturn fmt.Errorf(resp.String())\n\t}\n\treturn nil\n\n}\n\nfunc NewBulkUpdate(_index, _type, _id string, source []byte) *Bulk ", "output": "{\n\treturn &Bulk{\n\t\tUpdate: NewMeta(_index, _type, _id),\n\t\tSource: source,\n\t}\n}"}
{"input": "package github\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/bmizerany/assert\"\n)\n\n\n\nfunc TestEditor_openAndEdit_readFileIfExist(t *testing.T) {\n\ttempFile, _ := ioutil.TempFile(\"\", \"editor-test\")\n\ttempFile.Close()\n\n\tioutil.WriteFile(tempFile.Name(), []byte(\"hello\"), 0644)\n\teditor := Editor{\n\t\tProgram: \"memory\",\n\t\tFile:    tempFile.Name(),\n\t\topenEditor: func(program string, file string) error {\n\t\t\tassert.Equal(t, \"memory\", program)\n\t\t\tassert.Equal(t, tempFile.Name(), file)\n\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tcontent, err := editor.openAndEdit()\n\tassert.Equal(t, nil, err)\n\tassert.Equal(t, \"hello\", string(content))\n}\n\nfunc TestEditor_openAndEdit_writeFileIfNotExist(t *testing.T) {\n\ttempFile, _ := ioutil.TempFile(\"\", \"PULLREQ\")\n\ttempFile.Close()\n\n\teditor := Editor{\n\t\tProgram: \"memory\",\n\t\tFile:    tempFile.Name(),\n\t\topenEditor: func(program string, file string) error {\n\t\t\tassert.Equal(t, \"memory\", program)\n\t\t\tassert.Equal(t, tempFile.Name(), file)\n\n\t\t\treturn ioutil.WriteFile(file, []byte(\"hello\"), 0644)\n\t\t},\n\t}\n\n\tcontent, err := editor.openAndEdit()\n\tassert.Equal(t, nil, err)\n\tassert.Equal(t, \"hello\", string(content))\n}\n\nfunc TestEditor_openAndEdit_deleteFileWhenOpeningEditorFails(t *testing.T) ", "output": "{\n\ttempFile, _ := ioutil.TempFile(\"\", \"editor-test\")\n\ttempFile.Close()\n\n\tioutil.WriteFile(tempFile.Name(), []byte(\"hello\"), 0644)\n\teditor := Editor{\n\t\tProgram: \"memory\",\n\t\tFile:    tempFile.Name(),\n\t\tTopic:   \"test\",\n\t\topenEditor: func(program string, file string) error {\n\t\t\tassert.Equal(t, \"memory\", program)\n\t\t\tassert.Equal(t, tempFile.Name(), file)\n\t\t\treturn fmt.Errorf(\"error\")\n\t\t},\n\t}\n\n\t_, err := os.Stat(tempFile.Name())\n\tassert.Equal(t, nil, err)\n\n\t_, err = editor.openAndEdit()\n\tassert.Equal(t, \"error using text editor for test message\", fmt.Sprintf(\"%s\", err))\n\n\t_, err = os.Stat(tempFile.Name())\n\tassert.T(t, os.IsNotExist(err))\n}"}
{"input": "package v1alpha1\n\nimport (\n\tv1alpha1 \"k8s.io/api/discovery/v1alpha1\"\n\t\"k8s.io/client-go/deprecated/scheme\"\n\trest \"k8s.io/client-go/rest\"\n)\n\ntype DiscoveryV1alpha1Interface interface {\n\tRESTClient() rest.Interface\n\tEndpointSlicesGetter\n}\n\n\ntype DiscoveryV1alpha1Client struct {\n\trestClient rest.Interface\n}\n\nfunc (c *DiscoveryV1alpha1Client) EndpointSlices(namespace string) EndpointSliceInterface {\n\treturn newEndpointSlices(c, namespace)\n}\n\n\nfunc NewForConfig(c *rest.Config) (*DiscoveryV1alpha1Client, error) {\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := rest.RESTClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &DiscoveryV1alpha1Client{client}, nil\n}\n\n\n\nfunc NewForConfigOrDie(c *rest.Config) *DiscoveryV1alpha1Client {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n\n\nfunc New(c rest.Interface) *DiscoveryV1alpha1Client {\n\treturn &DiscoveryV1alpha1Client{c}\n}\n\n\n\n\n\nfunc (c *DiscoveryV1alpha1Client) RESTClient() rest.Interface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.restClient\n}\n\nfunc setConfigDefaults(config *rest.Config) error ", "output": "{\n\tgv := v1alpha1.SchemeGroupVersion\n\tconfig.GroupVersion = &gv\n\tconfig.APIPath = \"/apis\"\n\tconfig.NegotiatedSerializer = scheme.Codecs.WithoutConversion()\n\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = rest.DefaultKubernetesUserAgent()\n\t}\n\n\treturn nil\n}"}
{"input": "package dicom\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n)\n\ntype dcmWriter struct {\n\tio.Writer\n}\n\nfunc (dw *dcmWriter) Tag(order binary.ByteOrder, tag DataElementTag) error {\n\tif err := dw.UInt16(order, tag.GroupNumber()); err != nil {\n\t\treturn err\n\t}\n\treturn dw.UInt16(order, tag.ElementNumber())\n}\n\nfunc (dw *dcmWriter) Delimiter(order binary.ByteOrder, tag DataElementTag) error {\n\tif err := dw.Tag(order, tag); err != nil {\n\t\treturn fmt.Errorf(\"writing delimiter tag: %v\", err)\n\t}\n\tif err := dw.UInt32(order, 0); err != nil {\n\t\treturn fmt.Errorf(\"writing item length of delimiter: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (dw *dcmWriter) UInt16(order binary.ByteOrder, v uint16) error {\n\tbuf := make([]byte, 2)\n\torder.PutUint16(buf, v)\n\treturn dw.Bytes(buf)\n}\n\nfunc (dw *dcmWriter) UInt32(order binary.ByteOrder, v uint32) error {\n\tbuf := make([]byte, 4)\n\torder.PutUint32(buf, v)\n\treturn dw.Bytes(buf)\n}\n\n\n\nfunc (dw *dcmWriter) Bytes(b []byte) error {\n\t_, err := dw.Write(b)\n\treturn err\n}\n\nfunc (dw *dcmWriter) String(s string) error ", "output": "{\n\t_, err := dw.Write([]byte(s))\n\treturn err\n}"}
{"input": "package state\n\nimport (\n\t\"github.com/hashicorp/consul/agent/structs\"\n\t\"sync\"\n\t\"time\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\ntype Delay struct {\n\tdelay map[string]time.Time\n\n\tlock sync.RWMutex\n}\n\n\nfunc NewDelay() *Delay {\n\treturn &Delay{delay: make(map[string]time.Time)}\n}\n\n\n\n\n\n\n\n\nfunc (d *Delay) SetExpiration(key string, now time.Time, delay time.Duration, entMeta *structs.EnterpriseMeta) {\n\td.lock.Lock()\n\tdefer d.lock.Unlock()\n\n\td.delay[key] = now.Add(delay)\n\ttime.AfterFunc(delay, func() {\n\t\td.lock.Lock()\n\t\tdelete(d.delay, key)\n\t\td.lock.Unlock()\n\t})\n}\n\nfunc (d *Delay) GetExpiration(key string, entMeta *structs.EnterpriseMeta) time.Time ", "output": "{\n\td.lock.RLock()\n\texpires := d.delay[key]\n\td.lock.RUnlock()\n\treturn expires\n}"}
{"input": "package proxy\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/stretchr/testify/mock\"\n)\n\n\ntype TargetsManagerMock struct {\n\tmock.Mock\n}\n\n\n\n\n\nfunc (m *TargetsManagerMock) RemoveFromPool(poolID, ID string) error {\n\targs := m.Called(poolID, ID)\n\treturn args.Error(0)\n}\n\n\nfunc (m *TargetsManagerMock) CreatePool(conf *TargetConfig) error {\n\targs := m.Called(conf)\n\treturn args.Error(0)\n}\n\n\nfunc (m *TargetsManagerMock) Proxy(ctx *gin.Context) {\n\tm.Called(ctx)\n}\n\n\ntype GatekeeperMock struct {\n\tmock.Mock\n}\n\n\nfunc (m *GatekeeperMock) CheckAccess(token string, accessPrivileges int, updateToken bool) (string, error) {\n\targs := m.Called(token, accessPrivileges, updateToken)\n\treturn args.String(0), args.Error(1)\n}\n\nfunc (m *TargetsManagerMock) AddToPool(poolID, ID, targetURI string) error ", "output": "{\n\targs := m.Called(poolID, ID, targetURI)\n\treturn args.Error(0)\n}"}
{"input": "package types\n\nimport (\n\t\"encoding/json\"\n)\n\ntype Msg struct {\n\tMsgType byte\n\tMsgBody []byte\n\tMsgJson *map[string]interface{}\n}\n\nfunc NewSendMsg(msgType byte) *Msg {\n\treturn &Msg{MsgType: msgType}\n}\n\n\n\nfunc Marshal(pobj *Msg) (data []byte, err error) {\n\tif pobj.MsgType < 100 {\n\t\tlmsgType := []byte{pobj.MsgType}\n\t\tdata, err = json.Marshal(pobj.MsgJson)\n\t\tdata = append(lmsgType, data...)\n\t} else if pobj.MsgType == 100 {\n\t\tdata = pobj.MsgBody\n\t}\n\n\treturn\n}\n\nfunc Unmarshal(data []byte, pobj *Msg) (err error, kind byte) ", "output": "{\n\tmsgType := data[0]\n\tpobj.MsgType = msgType\n\tif msgType < 100 {\n\t\terr = json.Unmarshal(data[1:], pobj.MsgJson)\n\t\tkind = 0\n\t} else if msgType == 100 {\n\t\tpobj.MsgBody = data[1:]\n\t\tkind = 1\n\t}\n\n\treturn\n}"}
{"input": "package types\n\nimport (\n\t\"fmt\"\n\t\"go/token\"\n)\n\n\ntype Package struct {\n\tpath     string\n\tname     string\n\tscope    *Scope\n\tcomplete bool\n\timports  []*Package\n\tfake     bool \n\tcgo      bool \n}\n\n\n\nfunc NewPackage(path, name string) *Package {\n\tscope := NewScope(Universe, token.NoPos, token.NoPos, fmt.Sprintf(\"package %q\", path))\n\treturn &Package{path: path, name: name, scope: scope}\n}\n\n\n\n\n\nfunc (pkg *Package) Name() string { return pkg.name }\n\n\nfunc (pkg *Package) SetName(name string) { pkg.name = name }\n\n\n\n\nfunc (pkg *Package) Scope() *Scope { return pkg.scope }\n\n\n\nfunc (pkg *Package) Complete() bool { return pkg.complete }\n\n\nfunc (pkg *Package) MarkComplete() { pkg.complete = true }\n\n\n\n\n\n\n\nfunc (pkg *Package) Imports() []*Package { return pkg.imports }\n\n\n\nfunc (pkg *Package) SetImports(list []*Package) { pkg.imports = list }\n\nfunc (pkg *Package) String() string {\n\treturn fmt.Sprintf(\"package %s (%q)\", pkg.name, pkg.path)\n}\n\nfunc (pkg *Package) Path() string ", "output": "{ return pkg.path }"}
{"input": "package application\n\nimport (\n\t\"encoding/base64\"\n\t\"github.com/gorilla/securecookie\"\n\t\"net/http\"\n\t\"testing\"\n)\n\n\nconst cookieName = \"recaptcha\"\nconst testHashKey = \"RovMQmutMbSogUuGQFZYLb37jwgwFNuMR7wrEz9EILQ9W039UHCFlCfkpX1EbecktHA563XX+7clPRinBPeaeQ==\"\nconst testBlockKey = \"+sSXCAbwswiYNqHx4zCuJJTD3hmRQp4f4uJKy+aFL70=\"\n\nfunc generateGorillaSecureCookie() *securecookie.SecureCookie {\n\thashKey, _ := base64.StdEncoding.DecodeString(testHashKey)\n\tblockKey, _ := base64.StdEncoding.DecodeString(testBlockKey)\n\treturn securecookie.New(hashKey, blockKey)\n}\n\n\n\nfunc TestSecureRecaptchaCookie_Encode(t *testing.T) {\n\tvalidCookie := &http.Cookie{Value: \"Some Value\"}\n\n\tsecureRecaptchaCookie := NewSecureRecaptchaCookie(cookieName, validCookie, generateGorillaSecureCookie())\n\tsecureRecaptchaCookie.Value = secureRecaptchaCookie.Encode(validCookie.Value)\n\n\tif secureRecaptchaCookie.IsValid(validCookie.Value) != true {\n\t\tt.Error(\"The cookie value should have been encoded and decoded correctly\")\n\t}\n}\n\nfunc TestNewSecureRecaptchaCookie(t *testing.T) ", "output": "{\n\tsecureRecaptchaCookie1 := NewSecureRecaptchaCookie(cookieName, nil, generateGorillaSecureCookie())\n\tif secureRecaptchaCookie1.Name != cookieName || len(secureRecaptchaCookie1.Value) != 0 {\n\t\tt.Error(\"The new secure cookie based on an empty cookie should have no value\")\n\t}\n\n\tvalidCookie := &http.Cookie{Value: \"Some Value\"}\n\tsecureRecaptchaCookie2 := NewSecureRecaptchaCookie(cookieName, validCookie, generateGorillaSecureCookie())\n\tif secureRecaptchaCookie2.Name != cookieName || len(secureRecaptchaCookie2.Value) == 0 {\n\t\tt.Error(\"The new secure cookie based on a valid cookie should have a value\")\n\t}\n}"}
{"input": "package decide\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/trinchan/slackbot/robots\"\n)\n\ntype bot struct {\n\tRandom *rand.Rand\n}\n\nfunc init() {\n\td := &bot{}\n\td.Random = rand.New(rand.NewSource(time.Now().UnixNano()))\n\trobots.RegisterRobot(\"decide\", d)\n}\n\nfunc (d bot) Run(p *robots.Payload) (slashCommandImmediateReturn string) {\n\tgo d.DeferredAction(p)\n\ttext := strings.TrimSpace(p.Text)\n\tif text == \"\" {\n\t\treturn \"I need something to decide on!\"\n\t}\n\treturn \"\"\n}\n\nfunc (d bot) DeferredAction(p *robots.Payload) {\n\tresponse := robots.IncomingWebhook{\n\t\tDomain:      p.TeamDomain,\n\t\tChannel:     p.ChannelID,\n\t\tUsername:    \"Fate Bot\",\n\t\tIconEmoji:   \":ghost:\",\n\t\tUnfurlLinks: true,\n\t\tParse:       robots.ParseStyleFull,\n\t}\n\ttext := strings.TrimSpace(p.Text)\n\tif text != \"\" {\n\t\tsplit := strings.Split(text, \", \")\n\t\tresponse.Text = fmt.Sprintf(\"@%s: Deciding between: (%s) -> %s\", p.UserName, strings.Join(split, \", \"), d.decide(split))\n\t\tresponse.Send()\n\t}\n}\n\n\n\nfunc (d bot) decide(fates []string) (result string) {\n\tn := len(fates)\n\tif n > 0 {\n\t\treturn fates[d.Random.Intn(n)]\n\t}\n\treturn fmt.Sprintf(\"Error\")\n}\n\nfunc (d bot) Description() (description string) ", "output": "{\n\treturn \"Decides your fate!\\n\\tUsage: /decide Life Death ...\\n\\tExpected Response: Deciding on (Life, Death, ...)\\n\\tDecided on Life!\"\n}"}
{"input": "package cache\n\nimport (\n\t\"github.com/open-falcon/hbs/db\"\n\t\"sync\"\n)\n\n\ntype SafeHostGroupsMap struct {\n\tsync.RWMutex\n\tM map[int][]int\n}\n\nvar HostGroupsMap = &SafeHostGroupsMap{M: make(map[int][]int)}\n\n\n\nfunc (this *SafeHostGroupsMap) Init() {\n\tm, err := db.QueryHostGroups()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tthis.Lock()\n\tdefer this.Unlock()\n\tthis.M = m\n}\n\nfunc (this *SafeHostGroupsMap) GetGroupIds(hid int) ([]int, bool) ", "output": "{\n\tthis.RLock()\n\tdefer this.RUnlock()\n\tgids, exists := this.M[hid]\n\treturn gids, exists\n}"}
{"input": "package cmd\n\nimport (\n\t\"time\"\n\n\t\"github.com/codegangsta/cli\"\n)\n\n\n\nfunc boolFlag(name, usage string) cli.BoolFlag {\n\treturn cli.BoolFlag{\n\t\tName:  name,\n\t\tUsage: usage,\n\t}\n}\n\nfunc intFlag(name string, value int, usage string) cli.IntFlag {\n\treturn cli.IntFlag{\n\t\tName:  name,\n\t\tValue: value,\n\t\tUsage: usage,\n\t}\n}\n\nfunc durationFlag(name string, value time.Duration, usage string) cli.DurationFlag {\n\treturn cli.DurationFlag{\n\t\tName:  name,\n\t\tValue: value,\n\t\tUsage: usage,\n\t}\n}\n\nfunc stringFlag(name, value, usage string) cli.StringFlag ", "output": "{\n\treturn cli.StringFlag{\n\t\tName:  name,\n\t\tValue: value,\n\t\tUsage: usage,\n\t}\n}"}
{"input": "package azure\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"perkeep.org/pkg/blob\"\n\t\"perkeep.org/pkg/blobserver\"\n)\n\nvar _ blobserver.MaxEnumerateConfig = (*azureStorage)(nil)\n\n\n\nfunc (sto *azureStorage) EnumerateBlobs(ctx context.Context, dest chan<- blob.SizedRef, after string, limit int) (err error) {\n\tdefer close(dest)\n\tobjs, err := sto.azureClient.ListBlobs(ctx, sto.container, 5000)\n\tif err != nil {\n\t\tlog.Printf(\"azure ListBlobs: %v\", err)\n\t\treturn err\n\t}\n\tfor _, obj := range objs {\n\t\tif obj.Name <= after {\n\t\t\tcontinue\n\t\t}\n\t\tbr, ok := blob.Parse(obj.Name)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tselect {\n\t\tcase dest <- blob.SizedRef{Ref: br, Size: uint32(obj.Properties.ContentLength)}:\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\t}\n\t\tlimit--\n\t\tif limit == 0 {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (sto *azureStorage) MaxEnumerate() int ", "output": "{ return 5000 }"}
{"input": "package ib\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Portfolio struct {\n}\n\nfunc (p *Portfolio) UnMarshall(d string) {\n\n}\n\n\ntype IB struct {\n\tPortFolio    chan *Portfolio\n\tCreateBackup bool\n\tBackupFile   string\n\tConn         net.Conn\n\tQuit         chan bool\n\tClientId     int64\n\tRid          int64\n\tOutStream    *bytes.Buffer\n}\n\n\nfunc (b *IB) processPortfolioMsg(d string) {\n\ts := &Portfolio{}\n\ts.UnMarshall(d)\n\n\tb.PortFolio <- s\n}\n\n\nfunc (b *IB) processReceiver(d string) {\n\tdata := d\n\tb.processPortfolioMsg(data)\n\n}\n\n\n\n\n\nfunc (b *IB) Start(connectString string) *IB {\n\tb.OutStream = bytes.NewBuffer(make([]byte, 0, 4096))\n\terr := b.connect(connectString)\n\tif err != nil {\n\t\tlog.Printf(\"Could not connect to IB: %s\", err)\n\t}\n\tb.PortFolio = make(chan *Portfolio)\n\n\treturn b\n}\n\nfunc (b *IB) read() ", "output": "{\n\tr := bufio.NewReader(b.Conn)\n\tfor {\n\t\tselect {\n\t\tcase <-b.Quit:\n\t\t\tlog.Println(\"Client quitting\")\n\t\t\tb.Conn.Close()\n\t\t\tos.Exit(0)\n\t\t\tbreak\n\t\tdefault:\n\t\t\tstr, err := r.ReadString(DELIM_BYTE)\n\t\t\tif err == nil {\n\t\t\t\td := strings.TrimRight(str, DELIM_STR)\n\t\t\t\tfmt.Printf(d)\n\t\t\t\tb.processReceiver(d)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Could not read: %s\", err)\n\t\t\t\tb.Quit <- true\n\t\t\t}\n\n\t\t}\n\t}\n\n}"}
{"input": "package core\n\nimport (\n\t\"fmt\"\n\n\tctypes \"github.com/tendermint/tendermint/rpc/core/types\"\n\t\"github.com/tendermint/tendermint/types\"\n\t. \"github.com/tendermint/tmlibs/common\"\n)\n\n\n\n\nfunc BlockchainInfo(minHeight, maxHeight int) (*ctypes.ResultBlockchainInfo, error) {\n\tif maxHeight == 0 {\n\t\tmaxHeight = blockStore.Height()\n\t} else {\n\t\tmaxHeight = MinInt(blockStore.Height(), maxHeight)\n\t}\n\tif minHeight == 0 {\n\t\tminHeight = MaxInt(1, maxHeight-20)\n\t} else {\n\t\tminHeight = MaxInt(minHeight, maxHeight-20)\n\t}\n\n\tlogger.Debug(\"BlockchainInfoHandler\", \"maxHeight\", maxHeight, \"minHeight\", minHeight)\n\n\tblockMetas := []*types.BlockMeta{}\n\tfor height := maxHeight; height >= minHeight; height-- {\n\t\tblockMeta := blockStore.LoadBlockMeta(height)\n\t\tblockMetas = append(blockMetas, blockMeta)\n\t}\n\n\treturn &ctypes.ResultBlockchainInfo{blockStore.Height(), blockMetas}, nil\n}\n\n\n\n\n\n\n\nfunc Commit(height int) (*ctypes.ResultCommit, error) {\n\tif height == 0 {\n\t\treturn nil, fmt.Errorf(\"Height must be greater than 0\")\n\t}\n\tstoreHeight := blockStore.Height()\n\tif height > storeHeight {\n\t\treturn nil, fmt.Errorf(\"Height must be less than or equal to the current blockchain height\")\n\t}\n\n\theader := blockStore.LoadBlockMeta(height).Header\n\n\tif height == storeHeight {\n\t\tcommit := blockStore.LoadSeenCommit(height)\n\t\treturn &ctypes.ResultCommit{header, commit, false}, nil\n\t}\n\n\tcommit := blockStore.LoadBlockCommit(height)\n\treturn &ctypes.ResultCommit{header, commit, true}, nil\n}\n\nfunc Block(height int) (*ctypes.ResultBlock, error) ", "output": "{\n\tif height == 0 {\n\t\treturn nil, fmt.Errorf(\"Height must be greater than 0\")\n\t}\n\tif height > blockStore.Height() {\n\t\treturn nil, fmt.Errorf(\"Height must be less than the current blockchain height\")\n\t}\n\n\tblockMeta := blockStore.LoadBlockMeta(height)\n\tblock := blockStore.LoadBlock(height)\n\treturn &ctypes.ResultBlock{blockMeta, block}, nil\n}"}
{"input": "package bridge\n\ntype setupStep func(*networkConfiguration, *bridgeInterface) error\n\ntype bridgeSetup struct {\n\tconfig *networkConfiguration\n\tbridge *bridgeInterface\n\tsteps  []setupStep\n}\n\nfunc newBridgeSetup(c *networkConfiguration, i *bridgeInterface) *bridgeSetup {\n\treturn &bridgeSetup{config: c, bridge: i}\n}\n\n\n\nfunc (b *bridgeSetup) queueStep(step setupStep) {\n\tb.steps = append(b.steps, step)\n}\n\nfunc (b *bridgeSetup) apply() error ", "output": "{\n\tfor _, fn := range b.steps {\n\t\tif err := fn(b.config, b.bridge); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package contrailCni\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\n\tlog \"../logging\"\n)\n\n\nconst FileNotExist = \"File/Dir does not exist\"\n\n\nfunc checkFileOrDirExists(fname string) bool {\n\tif _, err := os.Stat(fname); err != nil {\n\t\tlog.Infof(\"File/Dir - %s does not exist. Error - %+v\", fname, err)\n\t\treturn false\n\t}\n\n\tlog.Infof(\"File/Dir - %s exists\", fname)\n\treturn true\n}\n\n\n\n\n\nfunc readContrailAddMsg(fname string) (contrailAddMsg, error) {\n\tvar msg contrailAddMsg\n\tif checkFileOrDirExists(fname) {\n\t\tfile, err := ioutil.ReadFile(fname)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error reading file %s. Error : %s\", fname, err)\n\t\t\treturn msg, fmt.Errorf(\"Error reading file %s. Error : %+v\", fname, err)\n\t\t}\n\n\t\terr = json.Unmarshal(file, &msg)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error decoding file. Error : %+v\", err)\n\t\t\treturn msg, err\n\t\t}\n\n\t\treturn msg, nil\n\t}\n\terr := errors.New(FileNotExist)\n\treturn msg, err\n}\n\nfunc getFilesinDir(dirName string) ([]os.FileInfo, error) ", "output": "{\n\tif checkFileOrDirExists(dirName) {\n\t\tfiles, err := ioutil.ReadDir(dirName)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Error in reading directory - %s. Error - %+v\", dirName, err)\n\t\t\treturn nil, err\n\t\t}\n\t\treturn files, nil\n\t}\n\terr := errors.New(FileNotExist)\n\treturn nil, err\n}"}
{"input": "package main\n\nimport \"os\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar (\n\tversion   string\n\tbuildtime string\n)\n\nfunc main() {\n\tcli := &CLI{}\n\tcli.Run()\n}\n\nfunc usage() ", "output": "{\n\tdata := []byte(`\nUsage: fid [-version] [-h|--help] [-debug] [ options ]\n\nFidias is a distributed and decentralized datastore with no node being special\n\nAgent:\n\n  -agent [ options ]                Run the fidias agent\n\n    -data-dir <directory>           Data directory\n    -gossip-addr <address:port>     Gossip advertise address\n    -data-addr <address:port>       Data and DHT advertise address\n    -rpc-addr <address:port>        GRPC advertise address\n    -join <peer1,peer2>             List of peers to join\n    -retry-join <peer1,peers>       List of peers to retry joins\n\nClient (experimental):\n\n  set <key> <value>    Set a key-value pair\n  get <key>            Get a key\n  rm  <key>            Remove a key\n  ls  <prefix>         List a prefix\n\n`)\n\n\tos.Stderr.Write(data)\n}"}
{"input": "package scheduler\n\nimport (\n\t\"github.com/goharbor/harbor/src/jobservice/job\"\n)\n\n\nconst (\n\tJobNameScheduler = \"SCHEDULER\"\n)\n\n\ntype PeriodicJob struct{}\n\n\nfunc (pj *PeriodicJob) MaxFails() uint {\n\treturn 3\n}\n\n\n\n\n\nfunc (pj *PeriodicJob) ShouldRetry() bool {\n\treturn true\n}\n\n\nfunc (pj *PeriodicJob) Validate(params job.Parameters) error {\n\treturn nil\n}\n\n\nfunc (pj *PeriodicJob) Run(ctx job.Context, params job.Parameters) error {\n\treturn ctx.Checkin(\"checkin\")\n}\n\nfunc (pj *PeriodicJob) MaxCurrency() uint ", "output": "{\n\treturn 0\n}"}
{"input": "package config\n\nimport (\n\t\"encoding/json\"\n\t\"path\"\n\n\t\"github.com/golang/glog\"\n)\n\n\nfunc Store(client ETCDInterface, cfg Config) error {\n\tbuf, err := json.Marshal(cfg)\n\tif err != nil {\n\t\tglog.Errorf(\"Failed to marshal global config: %v\", err)\n\t\treturn err\n\t}\n\tif _, err := client.Set(\"/goship/config\", string(buf), 0); err != nil {\n\t\tglog.Errorf(\"Failed to store global config: %v\", err)\n\t\treturn err\n\t}\n\tfor _, p := range cfg.Projects {\n\t\tif err := storeProject(client, p, \"/goship\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n\n\nfunc storeEnvironment(client ETCDInterface, env Environment, dir string) error {\n\tbuf, err := json.Marshal(env)\n\tif err != nil {\n\t\tglog.Errorf(\"Failed to marshal environment config of %s: %v\", env.Name, err)\n\t\treturn err\n\t}\n\tif _, err := client.Set(path.Join(dir, env.Name), string(buf), 0); err != nil {\n\t\tglog.Errorf(\"Failed to store environment config of %s: %v\", env.Name, err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc storeProject(client ETCDInterface, p Project, base string) error ", "output": "{\n\tbuf, err := json.Marshal(p)\n\tif err != nil {\n\t\tglog.Errorf(\"Failed to marshal project config of %s: %v\", p.Name, err)\n\t\treturn err\n\t}\n\tdir := path.Join(base, \"projects\", p.Name)\n\tif _, err := client.Set(path.Join(dir, \"config\"), string(buf), 0); err != nil {\n\t\tglog.Errorf(\"Failed to store project config of %s: %v\", p.Name, err)\n\t\treturn err\n\t}\n\tfor _, env := range p.Environments {\n\t\tif err := storeEnvironment(client, env, path.Join(dir, \"environments\")); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package internalversion\n\nimport (\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"github.com/hyperhq/client-go/tools/cache\"\n\tcore \"k8s.io/kubernetes/pkg/apis/core\"\n)\n\n\ntype EventLister interface {\n\tList(selector labels.Selector) (ret []*core.Event, err error)\n\tEvents(namespace string) EventNamespaceLister\n\tEventListerExpansion\n}\n\n\ntype eventLister struct {\n\tindexer cache.Indexer\n}\n\n\nfunc NewEventLister(indexer cache.Indexer) EventLister {\n\treturn &eventLister{indexer: indexer}\n}\n\n\nfunc (s *eventLister) List(selector labels.Selector) (ret []*core.Event, err error) {\n\terr = cache.ListAll(s.indexer, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*core.Event))\n\t})\n\treturn ret, err\n}\n\n\nfunc (s *eventLister) Events(namespace string) EventNamespaceLister {\n\treturn eventNamespaceLister{indexer: s.indexer, namespace: namespace}\n}\n\n\ntype EventNamespaceLister interface {\n\tList(selector labels.Selector) (ret []*core.Event, err error)\n\tGet(name string) (*core.Event, error)\n\tEventNamespaceListerExpansion\n}\n\n\n\ntype eventNamespaceLister struct {\n\tindexer   cache.Indexer\n\tnamespace string\n}\n\n\n\n\n\nfunc (s eventNamespaceLister) Get(name string) (*core.Event, error) {\n\tobj, exists, err := s.indexer.GetByKey(s.namespace + \"/\" + name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn nil, errors.NewNotFound(core.Resource(\"event\"), name)\n\t}\n\treturn obj.(*core.Event), nil\n}\n\nfunc (s eventNamespaceLister) List(selector labels.Selector) (ret []*core.Event, err error) ", "output": "{\n\terr = cache.ListAllByNamespace(s.indexer, s.namespace, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*core.Event))\n\t})\n\treturn ret, err\n}"}
{"input": "package tika\n\nimport (\n\t\"github.com/c2h5oh/datasize\"\n\t\"time\"\n)\n\n\ntype Config struct {\n\tTikaExtractorURL string            \n\tRequestTimeout   time.Duration     \n\tMaxFileSize      datasize.ByteSize \n}\n\n\n\n\nfunc DefaultConfig() *Config ", "output": "{\n\treturn &Config{\n\t\tTikaExtractorURL: \"http://localhost:8081\",\n\t\tRequestTimeout:   300 * time.Duration(time.Second),\n\t\tMaxFileSize:      4 * 1024 * 1024 * 1024, \n\t}\n}"}
{"input": "package cmd\n\nimport (\n\t\"fmt\"\n)\n\nfunc printf(format string, a ...interface{}) {\n\tif !quietFlag {\n\t\tfmt.Printf(format, a...)\n\t}\n}\n\nfunc println(a ...interface{}) {\n\tif !quietFlag {\n\t\tfmt.Println(a...)\n\t}\n}\n\nfunc dprintf(format string, a ...interface{}) {\n\tif debugFlag {\n\t\tprintf(format, a...)\n\t}\n}\n\nfunc dprintln(a ...interface{}) {\n\tif debugFlag {\n\t\tprintln(a...)\n\t}\n}\n\nfunc vprintf(format string, a ...interface{}) {\n\tif verboseFlag {\n\t\tprintf(format, a...)\n\t}\n}\n\n\n\nfunc contains(strings []string, str string) bool {\n\tfor _, s := range strings {\n\t\tif s == str {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc vprintln(a ...interface{}) ", "output": "{\n\tif verboseFlag {\n\t\tprintln(a...)\n\t}\n}"}
{"input": "package awstasks\n\nimport (\n\t\"encoding/json\"\n\n\t\"k8s.io/kops/upup/pkg/fi\"\n)\n\n\n\n\ntype realIAMInstanceProfile IAMInstanceProfile\n\nfunc (o *IAMInstanceProfile) UnmarshalJSON(data []byte) error {\n\tvar jsonName string\n\tif err := json.Unmarshal(data, &jsonName); err == nil {\n\t\to.Name = &jsonName\n\t\treturn nil\n\t}\n\n\tvar r realIAMInstanceProfile\n\tif err := json.Unmarshal(data, &r); err != nil {\n\t\treturn err\n\t}\n\t*o = IAMInstanceProfile(r)\n\treturn nil\n}\n\nvar _ fi.HasName = &IAMInstanceProfile{}\n\n\n\nfunc (e *IAMInstanceProfile) SetName(name string) {\n\te.Name = &name\n}\n\nfunc (e *IAMInstanceProfile) String() string {\n\treturn fi.TaskAsString(e)\n}\n\nfunc (e *IAMInstanceProfile) GetName() *string ", "output": "{\n\treturn e.Name\n}"}
{"input": "package upgrades\n\nimport (\n\t\"github.com/juju/juju/environs\"\n\t\"github.com/juju/juju/state\"\n)\n\n\n\n\n\nfunc stateStepsFor126() []Step {\n\treturn []Step{\n\t\t&upgradeStep{\n\t\t\tdescription: \"add the version field to all settings docs\",\n\t\t\ttargets:     []Target{DatabaseMaster},\n\t\t\trun: func(context Context) error {\n\t\t\t\treturn state.MigrateSettingsSchema(context.State())\n\t\t\t},\n\t\t},\n\t\t&upgradeStep{\n\t\t\tdescription: \"add status to filesystem\",\n\t\t\ttargets:     []Target{DatabaseMaster},\n\t\t\trun: func(context Context) error {\n\t\t\t\treturn state.AddFilesystemStatus(context.State())\n\t\t\t},\n\t\t},\n\t\t&upgradeStep{\n\t\t\tdescription: \"upgrade environment config\",\n\t\t\ttargets:     []Target{DatabaseMaster},\n\t\t\trun: func(context Context) error {\n\t\t\t\tst := context.State()\n\t\t\t\treturn upgradeEnvironConfig(st, st, environs.GlobalProviderRegistry())\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc stepsFor126() []Step ", "output": "{\n\treturn []Step{}\n}"}
{"input": "package main\n\nvar log string\n\ntype T int\n\nfunc (t T) a(s string) T {\n\tlog += \"a(\" + s + \")\"\n\treturn t\n}\n\nfunc (T) b(s string) string {\n\tlog += \"b\"\n\treturn s\n}\n\ntype F func(s string) F\n\nfunc a(s string) F {\n\tlog += \"a(\" + s + \")\"\n\treturn F(a)\n}\n\n\n\ntype I interface {\n\ta(s string) I\n\tb(s string) string\n}\n\ntype T1 int\n\nfunc (t T1) a(s string) I {\n\tlog += \"a(\" + s + \")\"\n\treturn t\n}\n\nfunc (T1) b(s string) string {\n\tlog += \"b\"\n\treturn s\n}\n\nvar ok = true\n\nfunc bad() {\n\tif !ok {\n\t\tprintln(\"BUG\")\n\t\tok = false\n\t}\n\tprintln(log)\n}\n\nfunc main() {\n\tvar t T\n\tif t.a(\"1\").a(t.b(\"2\")); log != \"a(1)ba(2)\" {\n\t\tbad()\n\t}\n\tlog = \"\"\n\tif a(\"3\")(b(\"4\"))(b(\"5\")); log != \"a(3)ba(4)ba(5)\" {\n\t\tbad()\n\t}\n\tlog = \"\"\n\tvar i I = T1(0)\n\tif i.a(\"6\").a(i.b(\"7\")).a(i.b(\"8\")).a(i.b(\"9\")); log != \"a(6)ba(7)ba(8)ba(9)\" {\n\t\tbad()\n\t}\n}\n\nfunc b(s string) string ", "output": "{\n\tlog += \"b\"\n\treturn s\n}"}
{"input": "package core\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/oracle/oci-go-sdk/common\"\n)\n\n\ntype ExportImageViaObjectStorageUriDetails struct {\n\n\tDestinationUri *string `mandatory:\"true\" json:\"destinationUri\"`\n}\n\nfunc (m ExportImageViaObjectStorageUriDetails) String() string {\n\treturn common.PointerString(m)\n}\n\n\n\n\nfunc (m ExportImageViaObjectStorageUriDetails) MarshalJSON() (buff []byte, e error) ", "output": "{\n\ttype MarshalTypeExportImageViaObjectStorageUriDetails ExportImageViaObjectStorageUriDetails\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"destinationType\"`\n\t\tMarshalTypeExportImageViaObjectStorageUriDetails\n\t}{\n\t\t\"objectStorageUri\",\n\t\t(MarshalTypeExportImageViaObjectStorageUriDetails)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"gopkg.in/yaml.v2\"\n\t\"k8s.io/klog\"\n)\n\ntype githubDirContent struct {\n\tName        string `yaml:\"name\"`\n\tPath        string `yaml:\"path\"`\n\tDownloadURL string `yaml:\"download_url\"`\n\tType        string `yaml:\"type\"`\n\tURL         string `yaml:\"url\"`\n}\n\n\n\n\n\n\n\n\nfunc GetConfigsFromGithub(url string) ([]string, error) {\n\tvar result []string\n\tcontents, err := getGithubDirContents(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, c := range contents {\n\t\tif c.Type == \"file\" && strings.HasSuffix(c.Name, \".yaml\") {\n\t\t\tresult = append(result, c.DownloadURL)\n\t\t}\n\t}\n\treturn result, nil\n}\n\n\n\nfunc getGithubDirContents(url string) ([]githubDirContent, error) ", "output": "{\n\tklog.Infof(\"Downloading github spec from %v\", url)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif token := os.Getenv(\"GITHUB_TOKEN\"); len(token) != 0 {\n\t\treq.Header.Add(\"Authorization\", fmt.Sprintf(\"Bearer %s\", token))\n\t}\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error calling github API %s: %v\", url, err)\n\t}\n\tb, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading github response %s: %v\", url, err)\n\t}\n\tvar decoded []githubDirContent\n\terr = yaml.Unmarshal(b, &decoded)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn decoded, nil\n}"}
{"input": "package dockerfile\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/openshift/oc/pkg/helpers/newapp\"\n)\n\ntype StatFunc func(path string) (os.FileInfo, error)\n\nfunc (t StatFunc) Has(dir string) (string, bool, error) {\n\tpath := filepath.Join(dir, \"Dockerfile\")\n\t_, err := t(path)\n\tif os.IsNotExist(err) {\n\t\treturn \"\", false, nil\n\t}\n\tif err != nil {\n\t\treturn \"\", false, err\n\t}\n\treturn path, true, nil\n}\n\nfunc NewTester() newapp.Tester {\n\treturn StatFunc(os.Stat)\n}\n\n\ntype Finder interface {\n\tFind(dir string) ([]string, error)\n}\n\ntype finder struct {\n\tfsWalk func(dir string, fn filepath.WalkFunc) error\n}\n\n\nfunc NewFinder() Finder {\n\treturn &finder{fsWalk: filepath.Walk}\n}\n\n\nfunc (f *finder) Find(dir string) ([]string, error) {\n\tdockerfiles := []string{}\n\terr := f.fsWalk(dir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() && strings.HasPrefix(info.Name(), \".\") {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\t\tif isDockerfile(info) {\n\t\t\trelpath, err := filepath.Rel(dir, path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdockerfiles = append(dockerfiles, relpath)\n\t\t}\n\t\treturn nil\n\t})\n\treturn dockerfiles, err\n}\n\n\n\n\n\nfunc isDockerfile(info os.FileInfo) bool ", "output": "{\n\treturn info.Name() == \"Dockerfile\" && (info.Mode().IsRegular() || info.Mode()&os.ModeSymlink != 0)\n}"}
{"input": "package model\n\nimport (\n\t\"encoding/json\"\n\n\t\"strings\"\n)\n\n\ntype ShowServerRemoteConsoleRequest struct {\n\tServerId string                              `json:\"server_id\"`\n\tBody     *ShowServerRemoteConsoleRequestBody `json:\"body,omitempty\"`\n}\n\n\n\nfunc (o ShowServerRemoteConsoleRequest) String() string ", "output": "{\n\tdata, _ := json.Marshal(o)\n\treturn strings.Join([]string{\"ShowServerRemoteConsoleRequest\", string(data)}, \" \")\n}"}
{"input": "package ga\n\nimport (\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc GroupAnagrams(input []string) [][]string {\n\treturn ga2(input)\n}\n\n\n\n\n\nfunc sortString(w string) string {\n\ts := strings.Split(w, \"\")\n\tsort.Strings(s)\n\treturn strings.Join(s, \"\")\n}\n\nfunc ga2(str []string) [][]string {\n\tn := len(str)\n\tlc := make(map[string][]string, n)\n\tfor _, st := range str {\n\t\tbucket := make([]int, 26)\n\t\tfor i := range st {\n\t\t\tbucket[st[i]-'a']++\n\t\t}\n\t\tvar sb strings.Builder\n\t\tfor i := 0; i < 26; i++ {\n\t\t\tsb.WriteRune('#')\n\t\t\tsb.WriteString(strconv.FormatInt(int64(bucket[i]), 10))\n\t\t}\n\t\tkey := sb.String()\n\t\tcv := lc[key]\n\t\tlc[key] = append(cv, st)\n\t}\n\tout := make([][]string, 0, len(lc))\n\tfor _, v := range lc {\n\t\tout = append(out, v)\n\t}\n\treturn out\n}\n\nfunc useHashmap(input []string) [][]string ", "output": "{\n\tn := len(input)\n\tlc := make(map[string][]string, n)\n\tfor _, str := range input {\n\t\tk := sortString(str)\n\t\tlc[k] = append(lc[k], str)\n\t}\n\tout := make([][]string, 0, len(lc))\n\tfor _, v := range lc {\n\t\tout = append(out, v)\n\t}\n\n\treturn out\n}"}
{"input": "package model\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSubmitTest(t *testing.T) {\n\ttestResp := Response{\n\t\tReqUrl:  testSrv.URL + \"?k1=v1&k2=v2\",\n\t\tStatus:  \"200 OK\",\n\t\tTest:    \"k1=v1&k2=v2 k3=v3&k4=v4\",\n\t\tReqBody: \"k3=v3&k4=v4\",\n\t}\n\n\tresp, err := SubmitModel.Submit(testData0)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tt.Logf(\"%#v\", resp)\n\tif !reflect.DeepEqual(testResp, resp) {\n\t\tt.Fatal(\"response not equal!\")\n\t}\n}\n\n\n\nfunc TestSubmitBenckmark(t *testing.T) ", "output": "{\n\ttestData1 := testData0\n\ttestData1.Bm = Bm{\n\t\tSwitch: true,\n\t\tN:      10,\n\t\tC:      1,\n\t}\n\n\tresp, err := SubmitModel.Submit(testData1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tt.Log(resp.Bm)\n\tif resp.Bm == \"\" {\n\t\tt.Fatal(\"no benchmark data?\")\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"bufio\"\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/crackcell/asciitype/engine\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc showHelp() {\n\tfmt.Println(\"usage: asciifont -f [font file]\")\n}\n\n\n\nfunc convert(raw string, fb *engine.Framebuffer, st *engine.SymbolTable) {\n\tfb.Clear()\n\traw = strings.ToUpper(raw)\n\tfor _, r := range raw {\n\t\tfb.Append(st.GetSymbol(r))\n\t}\n\n\tfb.Flush(os.Stdout)\n}\n\nfunc main() {\n\th := flag.Bool(\"h\", false, \"show help messages\")\n\tf := flag.String(\"f\", \"./fonts/tukasans.afont\", \"specify font file\")\n\tflag.Parse()\n\tif *h {\n\t\tshowHelp()\n\t\treturn\n\t}\n\n\tst := new(engine.SymbolTable)\n\tst.Load(*f)\n\n\tfb := engine.NewFramebuffer()\n\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tline, err := reader.ReadString('\\n')\n\t\tline = strings.Trim(line, \"\\n\")\n\t\tif len(line) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tconvert(line, fb, st)\n\t}\n\n}\n\nfunc readStdin() ", "output": "{\n\treader := bufio.NewReader(os.Stdin)\n\tfor {\n\t\tline, err := reader.ReadString('\\n')\n\t\tline = strings.Trim(line, \"\\n\")\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n}"}
{"input": "package radix\n\nimport (\n\t\"reflect\"\n\t\"sync\"\n\t\"time\"\n\n\tgoradix \"github.com/armon/go-radix\"\n\t\"github.com/bradberger/gocache/cache\"\n)\n\nvar (\n\t_ cache.Cache = (*Tree)(nil)\n)\n\n\ntype Tree struct {\n\ttree *goradix.Tree\n\tsync.RWMutex\n}\n\n\nfunc New() *Tree {\n\treturn &Tree{tree: goradix.New()}\n}\n\n\n\n\n\nfunc (t *Tree) Set(key string, val interface{}, exp time.Duration) error {\n\tt.Lock()\n\tt.Tree().Insert(key, val)\n\tt.Unlock()\n\tif exp > 0 {\n\t\tgo func(key string, exp time.Duration) {\n\t\t\tselect {\n\t\t\tcase <-time.After(exp):\n\t\t\t\tt.Del(key)\n\t\t\t}\n\t\t}(key, exp)\n\t}\n\treturn nil\n}\n\n\nfunc (t *Tree) Del(key string) error {\n\tt.Lock()\n\tt.Tree().Delete(key)\n\tt.Unlock()\n\treturn nil\n}\n\n\nfunc (t *Tree) Exists(key string) bool {\n\tt.RLock()\n\t_, found := t.Tree().Get(key)\n\tt.RUnlock()\n\treturn found\n}\n\n\nfunc (t *Tree) Tree() *goradix.Tree {\n\treturn t.tree\n}\n\nfunc (t *Tree) Get(key string, dstVal interface{}) error ", "output": "{\n\tt.RLock()\n\tval, found := t.Tree().Get(key)\n\tt.RUnlock()\n\tif !found {\n\t\treturn cache.ErrCacheMiss\n\t}\n\tel := reflect.ValueOf(dstVal)\n\tif el.Kind() == reflect.Ptr {\n\t\tel = el.Elem()\n\t}\n\tif !el.CanSet() {\n\t\treturn cache.ErrInvalidDstVal\n\t}\n\tel.Set(reflect.ValueOf(val))\n\treturn nil\n}"}
{"input": "package authorization\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/ransoni/uchiwa/uchiwa/authentication\"\n\t\"github.com/ransoni/uchiwa/uchiwa/logger\"\n)\n\n\n\ntype Authorization interface {\n\tHandler(http.Handler) http.Handler\n}\n\n\ntype Uchiwa struct{}\n\n\n\n\nfunc isAuthorized(isReadOnly bool, method string) bool {\n\tif (method != http.MethodHead && method != http.MethodGet) && isReadOnly {\n\t\treturn false\n\t}\n\treturn true\n}\n\n\n\nfunc isReadOnly(r *http.Request) bool {\n\tvar role *authentication.Role\n\n\ttoken := authentication.GetJWTFromContext(r)\n\tif token == nil { \n\t\tlogger.Debug(\"No JWT found in context\")\n\t\treturn false\n\t}\n\n\trole, err := authentication.GetRoleFromToken(token)\n\tif err != nil {\n\t\tlogger.Debug(\"Invalid token: %s\", err)\n\t\treturn true\n\t}\n\n\treturn role.Readonly\n}\n\nfunc (u *Uchiwa) Handler(next http.Handler) http.Handler ", "output": "{\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\treadonly := isReadOnly(r)\n\t\tauthorized := isAuthorized(readonly, r.Method)\n\t\tif !authorized {\n\t\t\thttp.Error(w, \"Request forbidden\", http.StatusForbidden)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}"}
{"input": "package models\n\nimport (\n\t\"fmt\"\n\t\"github.com/astaxie/beego/orm\"\n)\n\ntype CardReceiver struct {\n\tId         uint64 `orm:\"fk;auto\"`\n\tCard       string `orm:\"size(50)\"`\n\tGuid       string `orm:\"size(50)\"`\n\tType       int8\n\tSchoolGuid string `orm:\"size(50)\"`\n}\n\n\n\nfunc (this *CardReceiver) Del() (bool, string) {\n\to := orm.NewOrm()\n\t_, err := o.QueryTable(this).Filter(\"card\", this.Card).Filter(\"guid\", this.Guid).Delete()\n\tfmt.Printf(\"%#v\", this)\n\tif err == nil {\n\t\treturn true, \"success!\"\n\t} else {\n\t\treturn false, err.Error()\n\t}\n}\n\nfunc (this *CardReceiver) Add() (bool, string) ", "output": "{\n\to := orm.NewOrm()\n\terr := o.Read(this, \"card\", \"guid\")\n\tif err == nil {\n\t\treturn false, \"该卡的通知对象已经有该家庭成员!\"\n\t} else {\n\t\t_, err2 := o.Insert(this)\n\t\tif err2 == nil {\n\t\t\treturn true, \"success!\"\n\t\t} else {\n\t\t\treturn false, err2.Error()\n\t\t}\n\t}\n}"}
{"input": "package api\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype CustomSystemdUnit struct {\n\tName        string                    `yaml:\"name\"`\n\tCommand     string                    `yaml:\"command,omitempty\"`\n\tContent     string                    `yaml:\"content,omitempty\"`\n\tEnable      bool                      `yaml:\"enable,omitempty\"`\n\tRuntime     bool                      `yaml:\"runtime,omitempty\"`\n\tDropIns     []CustomSystemdUnitDropIn `yaml:\"drop-ins,omitempty\"`\n\tUnknownKeys `yaml:\",inline\"`\n}\n\nfunc (c CustomSystemdUnit) ContentPresent() bool {\n\tif len(c.Content) > 0 {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (c CustomSystemdUnit) DropInsPresent() bool {\n\tif len(c.DropIns) > 0 {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (c CustomSystemdUnit) ContentArray() []string {\n\ttrimmedContent := strings.TrimRight(c.Content, \"\\n\")\n\treturn strings.Split(trimmedContent, \"\\n\")\n}\n\n\n\nfunc (c CustomSystemdUnit) RuntimeString() string {\n\treturn strconv.FormatBool(c.Runtime)\n}\n\nfunc (c CustomSystemdUnit) EnableString() string ", "output": "{\n\treturn strconv.FormatBool(c.Enable)\n}"}
{"input": "package v2action\n\nimport \"os\"\n\n\n\n\n\nfunc fixMode(mode os.FileMode) os.FileMode ", "output": "{\n\treturn mode\n}"}
{"input": "package network\n\nimport (\n\t\"context\"\n\t\"sort\"\n\n\t\"github.com/docker/cli/cli\"\n\t\"github.com/docker/cli/cli/command\"\n\t\"github.com/docker/cli/cli/command/formatter\"\n\t\"github.com/docker/cli/opts\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/fvbommel/sortorder\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype listOptions struct {\n\tquiet   bool\n\tnoTrunc bool\n\tformat  string\n\tfilter  opts.FilterOpt\n}\n\n\n\nfunc runList(dockerCli command.Cli, options listOptions) error {\n\tclient := dockerCli.Client()\n\tlistOptions := types.NetworkListOptions{Filters: options.filter.Value()}\n\tnetworkResources, err := client.NetworkList(context.Background(), listOptions)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tformat := options.format\n\tif len(format) == 0 {\n\t\tif len(dockerCli.ConfigFile().NetworksFormat) > 0 && !options.quiet {\n\t\t\tformat = dockerCli.ConfigFile().NetworksFormat\n\t\t} else {\n\t\t\tformat = formatter.TableFormatKey\n\t\t}\n\t}\n\n\tsort.Slice(networkResources, func(i, j int) bool {\n\t\treturn sortorder.NaturalLess(networkResources[i].Name, networkResources[j].Name)\n\t})\n\n\tnetworksCtx := formatter.Context{\n\t\tOutput: dockerCli.Out(),\n\t\tFormat: NewFormat(format, options.quiet),\n\t\tTrunc:  !options.noTrunc,\n\t}\n\treturn FormatWrite(networksCtx, networkResources)\n}\n\nfunc newListCommand(dockerCli command.Cli) *cobra.Command ", "output": "{\n\toptions := listOptions{filter: opts.NewFilterOpt()}\n\n\tcmd := &cobra.Command{\n\t\tUse:     \"ls [OPTIONS]\",\n\t\tAliases: []string{\"list\"},\n\t\tShort:   \"List networks\",\n\t\tArgs:    cli.NoArgs,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn runList(dockerCli, options)\n\t\t},\n\t}\n\n\tflags := cmd.Flags()\n\tflags.BoolVarP(&options.quiet, \"quiet\", \"q\", false, \"Only display network IDs\")\n\tflags.BoolVar(&options.noTrunc, \"no-trunc\", false, \"Do not truncate the output\")\n\tflags.StringVar(&options.format, \"format\", \"\", \"Pretty-print networks using a Go template\")\n\tflags.VarP(&options.filter, \"filter\", \"f\", \"Provide filter values (e.g. 'driver=bridge')\")\n\n\treturn cmd\n}"}
{"input": "package fuzztraversal\n\nimport (\n\t\"github.com/hashicorp/hcl2/hcl\"\n\t\"github.com/hashicorp/hcl2/hcl/hclsyntax\"\n)\n\n\n\nfunc Fuzz(data []byte) int ", "output": "{\n\t_, diags := hclsyntax.ParseTraversalAbs(data, \"<fuzz-trav>\", hcl.Pos{Line: 1, Column: 1})\n\n\tif diags.HasErrors() {\n\t\treturn 0\n\t}\n\n\treturn 1\n}"}
{"input": "package influx\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"log\"\n\n\t\"github.com/influxdata/telegraf\"\n)\n\n\ntype reader struct {\n\tmetrics    []telegraf.Metric\n\tserializer *Serializer\n\toffset     int\n\tbuf        *bytes.Buffer\n}\n\n\nfunc NewReader(metrics []telegraf.Metric, serializer *Serializer) io.Reader {\n\treturn &reader{\n\t\tmetrics:    metrics,\n\t\tserializer: serializer,\n\t\toffset:     0,\n\t\tbuf:        bytes.NewBuffer(make([]byte, 0, serializer.maxLineBytes)),\n\t}\n}\n\n\nfunc (r *reader) SetMetrics(metrics []telegraf.Metric) {\n\tr.metrics = metrics\n\tr.offset = 0\n\tr.buf.Reset()\n}\n\n\n\n\n\n\n\n\n\nfunc (r *reader) Read(p []byte) (int, error) ", "output": "{\n\tif r.buf.Len() > 0 {\n\t\treturn r.buf.Read(p)\n\t}\n\n\tif r.offset >= len(r.metrics) {\n\t\treturn 0, io.EOF\n\t}\n\n\tfor _, metric := range r.metrics[r.offset:] {\n\t\t_, err := r.serializer.Write(r.buf, metric)\n\t\tr.offset += 1\n\t\tif err != nil {\n\t\t\tr.buf.Reset()\n\t\t\tif _, ok := err.(*MetricError); ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlog.Printf(\"E! [serializers.influx] could not serialize metric: %v; discarding metric\", err)\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\treturn r.buf.Read(p)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype result struct {\n\tsubperms []string\n\tletter   string\n}\n\nvar cache = make(map[string][]string)\nvar count = 0\nvar mutex = &sync.Mutex{}\n\nfunc multiperm(word string) []string {\n\tvar list []string\n\tch := make(chan result, len(word))\n\tfor i, l := range word {\n\t\tgo func(i int, l string) {\n\t\t\tch <- result{perm(word[:i] + word[i+1:]), l}\n\t\t}(i, string(l))\n\t}\n\tfor i := 0; i < len(word); i++ {\n\t\tresult := <-ch\n\t\tfor _, p := range result.subperms {\n\t\t\tlist = append(list, result.letter+p)\n\t\t}\n\t}\n\treturn list\n}\n\n\n\nfunc main() {\n\tword := \"abcdefghi\"\n\tfmt.Println(len(multiperm(word)))\n\tfmt.Println(count)\n}\n\nfunc perm(word string) []string ", "output": "{\n\tmutex.Lock()\n\tprevResult, ok := cache[word]\n\tcount++\n\tmutex.Unlock()\n\tif ok {\n\t\treturn prevResult\n\t}\n\n\tif len(word) <= 1 {\n\t\treturn []string{word}\n\t}\n\tvar list []string\n\tfor i, l := range word {\n\t\tsubperm := perm(word[:i] + word[i+1:])\n\t\tfor _, c := range subperm {\n\t\t\tlist = append(list, string(l)+c)\n\t\t}\n\t}\n\tmutex.Lock()\n\tcache[word] = list\n\tmutex.Unlock()\n\treturn list\n}"}
{"input": "package parser\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n\n\n\ntype Value interface {\n\tValue() interface{}\n\tString() string\n\tRef() *SourceRef\n}\n\n\n\ntype Identifier string\n\n\n\n\n\ntype Any struct {\n\tvalue interface{}\n\tref   *SourceRef\n}\n\nfunc (a Any) Value() interface{} {\n\treturn a.value\n}\n\nfunc (a Any) String() string {\n\tswitch data := a.value.(type) {\n\tcase []Value:\n\t\tvar elt []string\n\t\tfor _, v := range data {\n\t\t\telt = append(elt, v.String())\n\t\t}\n\t\treturn fmt.Sprintf(\"<[]Value>(%s)\", strings.Join(elt, \" \"))\n\tcase Identifier:\n\t\treturn data.String()\n\tdefault:\n\t\treturn fmt.Sprintf(\"<%T>%#+v\", data, data)\n\t}\n}\n\nfunc (a Any) Ref() *SourceRef {\n\treturn a.ref\n}\n\nfunc NewAny(v interface{}, ref *SourceRef) Value {\n\treturn Any{\n\t\tvalue: v,\n\t\tref:   ref,\n\t}\n}\n\nfunc (id Identifier) String() string ", "output": "{\n\treturn fmt.Sprintf(\"<id>%q\", string(id))\n}"}
{"input": "package alert\n\nimport (\n\t. \"aliyun-openapi-go-sdk/core\"\n)\n\ntype GetContactGroupRequest struct {\n\tRoaRequest\n\tProjectName string\n\tGroupName   string\n}\n\nfunc (r *GetContactGroupRequest) SetProjectName(value string) {\n\tr.ProjectName = value\n\tr.PathParams.Set(\"ProjectName\", value)\n}\nfunc (r *GetContactGroupRequest) GetProjectName() string {\n\treturn r.ProjectName\n}\nfunc (r *GetContactGroupRequest) SetGroupName(value string) {\n\tr.GroupName = value\n\tr.PathParams.Set(\"GroupName\", value)\n}\n\n\nfunc (r *GetContactGroupRequest) Init() {\n\tr.RoaRequest.Init()\n\tr.PathPattern = \"/projects/ProjectName/groups/GroupName\"\n\tr.SetMethod(\"GET\")\n\tr.SetProtocol(\"HTTP\")\n\tr.SetProduct(Product)\n}\n\ntype GetContactGroupResponse struct {\n\tcode    string `xml:\"code\" json:\"code\"`\n\tmessage string `xml:\"message\" json:\"message\"`\n\tsuccess string `xml:\"success\" json:\"success\"`\n\ttraceId string `xml:\"traceId\" json:\"traceId\"`\n\tresult  string `xml:\"result\" json:\"result\"`\n}\n\nfunc GetContactGroup(req *GetContactGroupRequest, accessId, accessSecret string) (*GetContactGroupResponse, error) {\n\tvar pResponse GetContactGroupResponse\n\tbody, err := ApiHttpRequest(accessId, accessSecret, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tApiUnmarshalResponse(req.GetFormat(), body, &pResponse)\n\treturn &pResponse, err\n}\n\nfunc (r *GetContactGroupRequest) GetGroupName() string ", "output": "{\n\treturn r.GroupName\n}"}
{"input": "package gonum\n\nimport \"gonum.org/v1/gonum/lapack\"\n\n\n\n\ntype Implementation struct{}\n\nvar _ lapack.Float64 = Implementation{}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n\n\nconst (\n\tdlamchE = 1.0 / (1 << 53)\n\n\tdlamchB = 2\n\n\tdlamchP = dlamchB * dlamchE\n\n\tdlamchS = 1.0 / (1 << 256) / (1 << 256) / (1 << 256) / (1 << 254)\n)\n\nfunc abs(a int) int ", "output": "{\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}"}
{"input": "package importx\n\nimport (\n\t\"encoding/json\"\n\t\"flag\"\n\t\"io/ioutil\"\n\t\"os\"\n\n\t\"github.com/vmware/govmomi/ovf\"\n\t\"github.com/vmware/govmomi/vim25/types\"\n)\n\ntype Property struct {\n\ttypes.KeyValue\n\tSpec ovf.Property\n}\n\ntype Options struct {\n\tAllDeploymentOptions []string\n\tDeployment           string\n\n\tAllDiskProvisioningOptions []string\n\tDiskProvisioning           string\n\n\tAllIPAllocationPolicyOptions []string\n\tIPAllocationPolicy           string\n\n\tAllIPProtocolOptions []string\n\tIPProtocol           string\n\n\tPropertyMapping []Property\n\n\tPowerOn      bool\n\tInjectOvfEnv bool\n\tWaitForIP    bool\n}\n\ntype OptionsFlag struct {\n\tOptions Options\n\n\tpath string\n}\n\n\n\nfunc (flag *OptionsFlag) Process() error {\n\tif len(flag.path) > 0 {\n\t\tf, err := os.Open(flag.path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\n\t\to, err := ioutil.ReadAll(f)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := json.Unmarshal(o, &flag.Options); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (flag *OptionsFlag) Register(f *flag.FlagSet) ", "output": "{\n\tf.StringVar(&flag.path, \"options\", \"\", \"Options spec file path for VM deployment\")\n}"}
{"input": "package keyvalue\n\nimport (\n\t\"errors\"\n\n\t\"github.com/xujiajun/nutsdb\"\n)\n\n\n\n\n\ntype dbStore struct {\n\tdb     *nutsdb.DB\n\tbucket string\n}\n\n\n\nfunc (s *dbStore) Get(key string) (value []byte, err error) {\n\terr = s.db.View(func(tx *nutsdb.Tx) error {\n\t\tentry, err := tx.Get(s.bucket, []byte(key))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvalue = entry.Value\n\t\treturn nil\n\t})\n\tif errors.Is(err, nutsdb.ErrNotFoundKey) {\n\t\treturn nil, ErrNotFound\n\t}\n\treturn value, err\n}\n\n\nfunc (s *dbStore) Set(key string, value []byte) error {\n\treturn s.db.Update(func(tx *nutsdb.Tx) error {\n\t\treturn tx.Put(s.bucket, []byte(key), value, 0)\n\t})\n}\n\n\nfunc (s *dbStore) Delete(key string) error {\n\treturn s.db.Update(func(tx *nutsdb.Tx) error {\n\t\treturn tx.Delete(s.bucket, []byte(key))\n\t})\n}\n\n\nfunc (s *dbStore) Iter(f func(key string, value []byte)) {\n\ts.db.View(func(tx *nutsdb.Tx) error {\n\t\tentries, _, err := tx.PrefixScan(s.bucket, []byte{}, 0, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, entry := range entries {\n\t\t\tf(string(entry.Key), entry.Value)\n\t\t}\n\t\treturn nil\n\t})\n}\n\n\nfunc (s *dbStore) Close() error {\n\treturn s.db.Close()\n}\n\nfunc NewNutsDBStore(db *nutsdb.DB, bucket string) Store ", "output": "{\n\treturn &dbStore{\n\t\tdb:     db,\n\t\tbucket: bucket,\n\t}\n}"}
{"input": "package local \n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/tiborvass/docker/errdefs\"\n\t\"github.com/pkg/errors\"\n)\n\ntype optsConfig struct{}\n\n\n\nfunc (r *Root) scopedPath(realPath string) bool {\n\tif strings.HasPrefix(realPath, filepath.Join(r.scope, volumesPathName)) && realPath != filepath.Join(r.scope, volumesPathName) {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n\nfunc (v *localVolume) needsMount() bool {\n\treturn false\n}\n\nfunc (v *localVolume) mount() error {\n\treturn nil\n}\n\nfunc (v *localVolume) postMount() error {\n\treturn nil\n}\n\nfunc (v *localVolume) CreatedAt() (time.Time, error) {\n\tfileInfo, err := os.Stat(v.path)\n\tif err != nil {\n\t\treturn time.Time{}, err\n\t}\n\tft := fileInfo.Sys().(*syscall.Win32FileAttributeData).CreationTime\n\treturn time.Unix(0, ft.Nanoseconds()), nil\n}\n\nfunc setOpts(v *localVolume, opts map[string]string) error ", "output": "{\n\tif len(opts) > 0 {\n\t\treturn errdefs.InvalidParameter(errors.New(\"options are not supported on this platform\"))\n\t}\n\treturn nil\n}"}
{"input": "package network\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n)\n\ntype authorization interface {\n\tAuthorization() string\n}\n\n\n\nfunc NewTokenAuthorization(token string) TokenAuthorization {\n\treturn TokenAuthorization(token)\n}\n\n\n\n\ntype TokenAuthorization string\n\n\n\n\n\n\n\nfunc NewBasicAuthorization(username, password string) BasicAuthorization {\n\treturn BasicAuthorization{\n\t\tusername: username,\n\t\tpassword: password,\n\t}\n}\n\n\n\n\ntype BasicAuthorization struct {\n\tusername string\n\tpassword string\n}\n\n\n\nfunc (b BasicAuthorization) Authorization() string {\n\tauth := b.username + \":\" + b.password\n\treturn fmt.Sprintf(\"Basic %s\", base64.StdEncoding.EncodeToString([]byte(auth)))\n}\n\nfunc (a TokenAuthorization) Authorization() string ", "output": "{\n\treturn fmt.Sprintf(\"Bearer %s\", a)\n}"}
{"input": "package factory\n\nimport (\n\t\"github.com/vlorc/gioc/types\"\n\t\"github.com/vlorc/gioc/utils\"\n\t\"reflect\"\n)\n\n\n\nfunc newRequestFactory(typ reflect.Type, factory types.BeanFactory, create func(func([]reflect.Value) []reflect.Value) func([]reflect.Value) []reflect.Value) types.BeanFactory ", "output": "{\n\treturn NewFuncFactory(func(provider types.Provider) (interface{}, error) {\n\t\tproxy := create(func([]reflect.Value) []reflect.Value {\n\t\t\tinstance, err := factory.Instance(provider)\n\t\t\tif nil != err {\n\t\t\t\tutils.Panic(err)\n\t\t\t}\n\t\t\treturn []reflect.Value{utils.Convert(reflect.ValueOf(instance), typ.Out(0))}\n\t\t})\n\t\treturn reflect.MakeFunc(typ, proxy).Interface(), nil\n\t})\n}"}
{"input": "package fake\n\nimport (\n\tclientset \"github.com/openshift/origin/pkg/security/generated/clientset\"\n\tsecurityv1 \"github.com/openshift/origin/pkg/security/generated/clientset/typed/security/v1\"\n\tfakesecurityv1 \"github.com/openshift/origin/pkg/security/generated/clientset/typed/security/v1/fake\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n\t\"k8s.io/client-go/discovery\"\n\tfakediscovery \"k8s.io/client-go/discovery/fake\"\n\t\"k8s.io/client-go/testing\"\n)\n\n\n\n\n\nfunc NewSimpleClientset(objects ...runtime.Object) *Clientset {\n\to := testing.NewObjectTracker(scheme, codecs.UniversalDecoder())\n\tfor _, obj := range objects {\n\t\tif err := o.Add(obj); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tfakePtr := testing.Fake{}\n\tfakePtr.AddReactor(\"*\", \"*\", testing.ObjectReaction(o))\n\tfakePtr.AddWatchReactor(\"*\", testing.DefaultWatchReactor(watch.NewFake(), nil))\n\n\treturn &Clientset{fakePtr, &fakediscovery.FakeDiscovery{Fake: &fakePtr}}\n}\n\n\n\n\ntype Clientset struct {\n\ttesting.Fake\n\tdiscovery *fakediscovery.FakeDiscovery\n}\n\nfunc (c *Clientset) Discovery() discovery.DiscoveryInterface {\n\treturn c.discovery\n}\n\nvar _ clientset.Interface = &Clientset{}\n\n\nfunc (c *Clientset) SecurityV1() securityv1.SecurityV1Interface {\n\treturn &fakesecurityv1.FakeSecurityV1{Fake: &c.Fake}\n}\n\n\n\n\nfunc (c *Clientset) Security() securityv1.SecurityV1Interface ", "output": "{\n\treturn &fakesecurityv1.FakeSecurityV1{Fake: &c.Fake}\n}"}
{"input": "package configuration\n\ntype MemoryLoader struct {\n\tData map[string]interface{}\n}\n\nfunc NewMemoryLoader() *MemoryLoader {\n\treturn &MemoryLoader{map[string]interface{}{}}\n}\n\nfunc NewMemoryLoaderFrom(data map[string]interface{}) *MemoryLoader {\n\tl := NewMemoryLoader()\n\tl.SetAll(data)\n\treturn l\n}\n\nfunc (k *MemoryLoader) Set(key string, value interface{}) {\n\tk.Data[key] = value\n}\n\nfunc (k *MemoryLoader) SetAll(data map[string]interface{}) {\n\tk.Data = data\n}\n\n\n\nfunc (k *MemoryLoader) Load() (map[string]interface{}, error) {\n\treturn k.Data, nil\n}\n\nfunc (k *MemoryLoader) Delete(key string) ", "output": "{\n\tdelete(k.Data, key)\n}"}
{"input": "package flavors\n\nimport (\n\t\"github.com/gophercloud/gophercloud\"\n)\n\nfunc getURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id)\n}\n\nfunc listURL(client *gophercloud.ServiceClient) string {\n\treturn client.ServiceURL(\"flavors\", \"detail\")\n}\n\nfunc createURL(client *gophercloud.ServiceClient) string {\n\treturn client.ServiceURL(\"flavors\")\n}\n\nfunc deleteURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id)\n}\n\nfunc accessURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-flavor-access\")\n}\n\nfunc accessActionURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"action\")\n}\n\nfunc extraSpecsListURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\")\n}\n\nfunc extraSpecsGetURL(client *gophercloud.ServiceClient, id, key string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\", key)\n}\n\nfunc extraSpecsCreateURL(client *gophercloud.ServiceClient, id string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\")\n}\n\nfunc extraSpecUpdateURL(client *gophercloud.ServiceClient, id, key string) string {\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\", key)\n}\n\n\n\nfunc extraSpecDeleteURL(client *gophercloud.ServiceClient, id, key string) string ", "output": "{\n\treturn client.ServiceURL(\"flavors\", id, \"os-extra_specs\", key)\n}"}
{"input": "package safeio\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\n\nfunc WriteToFile(src io.Reader, path string, perm os.FileMode) (written int64, err error) {\n\ttempName, written, err := writeToTempFile(src, path, perm)\n\n\tif err == nil {\n\t\terr = Rename(tempName, path)\n\t}\n\n\treturn written, err\n}\n\n\n\n\n\n\n\nfunc Remove(fn string) error {\n\terr := os.Remove(fn)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn syncParentDir(fn)\n}\n\n\n\n\nfunc Rename(oldname, newname string) error {\n\terr := os.Rename(oldname, newname)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn syncParentDir(newname)\n}\n\nfunc syncParentDir(name string) error {\n\tf, err := os.Open(filepath.Dir(name))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\treturn f.Sync()\n}\n\nfunc writeToTempFile(src io.Reader, path string, perm os.FileMode) (tempName string, written int64, err error) ", "output": "{\n\tdir := filepath.Dir(path)\n\tname := filepath.Base(path)\n\n\tf, err := ioutil.TempFile(dir, name+\".tmp\")\n\tif err != nil {\n\t\treturn \"\", 0, err\n\t}\n\n\ttempName = f.Name()\n\n\tcleanup := func(written int64, err error) (string, int64, error) {\n\t\t_ = f.Close()\n\t\t_ = os.Remove(tempName)\n\t\treturn \"\", written, err\n\t}\n\n\tif err = f.Chmod(perm); err != nil {\n\t\treturn cleanup(0, err)\n\t}\n\n\twritten, err = io.Copy(f, src)\n\tif err != nil {\n\t\treturn cleanup(written, err)\n\t}\n\n\tif err := f.Sync(); err != nil {\n\t\treturn cleanup(written, err)\n\t}\n\n\tif err := f.Close(); err != nil {\n\t\treturn cleanup(written, err)\n\t}\n\n\treturn tempName, written, nil\n}"}
{"input": "package fuse\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\t\"testing\"\n)\n\n\n\nfunc TestToStatus(t *testing.T) ", "output": "{\n\terrNo := ToStatus(os.ErrPermission)\n\tif errNo != EPERM {\n\t\tt.Errorf(\"Wrong conversion %v != %v\", errNo, syscall.EPERM)\n\t}\n\n\te := os.NewSyscallError(\"syscall\", syscall.EPERM)\n\terrNo = ToStatus(e)\n\tif errNo != EPERM {\n\t\tt.Errorf(\"Wrong conversion %v != %v\", errNo, syscall.EPERM)\n\t}\n\n\te = os.Remove(\"this-file-surely-does-not-exist\")\n\terrNo = ToStatus(e)\n\tif errNo != ENOENT {\n\t\tt.Errorf(\"Wrong conversion %v != %v\", errNo, syscall.ENOENT)\n\t}\n}"}
{"input": "package route\n\nimport (\n\t\"database/sql\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/julienschmidt/httprouter\"\n)\n\n\n\n\nfunc initPort() string {\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\n\treturn port\n}\n\nfunc StartServer(db *sql.DB) ", "output": "{\n\tr := httprouter.New()\n\n\tr.ServeFiles(\"/public/*filepath\", http.Dir(\"public/static/\"))\n\tr.GET(\"/api/:name\", apiHandler(db))\n\tr.GET(\"/\", mainHandler())\n\n\tlog.Fatal(http.ListenAndServe(\":\"+initPort(), r))\n}"}
{"input": "package math\n\nimport \"jvmgo/ch11/instructions/base\"\nimport \"jvmgo/ch11/rtda\"\n\n\ntype DMUL struct{ base.NoOperandsInstruction }\n\n\n\n\ntype FMUL struct{ base.NoOperandsInstruction }\n\nfunc (self *FMUL) Execute(frame *rtda.Frame) {\n\tstack := frame.OperandStack()\n\tv2 := stack.PopFloat()\n\tv1 := stack.PopFloat()\n\tresult := v1 * v2\n\tstack.PushFloat(result)\n}\n\n\ntype IMUL struct{ base.NoOperandsInstruction }\n\nfunc (self *IMUL) Execute(frame *rtda.Frame) {\n\tstack := frame.OperandStack()\n\tv2 := stack.PopInt()\n\tv1 := stack.PopInt()\n\tresult := v1 * v2\n\tstack.PushInt(result)\n}\n\n\ntype LMUL struct{ base.NoOperandsInstruction }\n\nfunc (self *LMUL) Execute(frame *rtda.Frame) {\n\tstack := frame.OperandStack()\n\tv2 := stack.PopLong()\n\tv1 := stack.PopLong()\n\tresult := v1 * v2\n\tstack.PushLong(result)\n}\n\nfunc (self *DMUL) Execute(frame *rtda.Frame) ", "output": "{\n\tstack := frame.OperandStack()\n\tv2 := stack.PopDouble()\n\tv1 := stack.PopDouble()\n\tresult := v1 * v2\n\tstack.PushDouble(result)\n}"}
{"input": "package main\n\nimport (\n\t\"time\"\n\t\"os\"\n\t\"io/ioutil\"\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"runtime/debug\"\n\t\"net/http\"\n\n\t\"github.com/devhq-io/ax\"\n\t)\n\n\n\nfunc startGcLoop(period time.Duration) {\n\tgo func(period time.Duration) {\n\t\tfor {\n\t\t\tlog.Printf(\"gc\\n\")\n\t\t\tdebug.FreeOSMemory()\n\t\t\ttime.Sleep(period * time.Second)\n\t\t}\n\t} (period)\n}\n\nfunc indexFileHandler(w http.ResponseWriter, r *http.Request) {\n\thttp.ServeFile(w, r, \"./www/index.html\")\n}\n\nfunc setupRoutes(r *ax.Router) {\n\tr.StrictSlash(true)\n\tr.HandleFunc(\"/\", indexFileHandler)\n\n\thttp.Handle(\"/\", r)\n}\n\nfunc start(port int) {\n\tlog.Printf(\"Serving %d\\n\", port)\n\tlog.Fatal(http.ListenAndServe(fmt.Sprintf(\":%d\", port), nil))\n}\n\nvar value int\n\nfunc setMessageHandlers() {\n\tax.OnJson(\"request\",\n\t\tfunc (c *ax.Client, data interface{}) {\n\t\t\ttype answerArgs struct {\n\t\t\t\tValue int `json:\"value\"`\n\t\t\t}\n\t\t\tvalue += 1\n\t\t\tlog.Printf(\"request message: '%+v'\\n\", data)\n\t\t\tc.JsonSend(\"answer\", &answerArgs{Value: value})\n\t\t})\n}\n\nfunc main() {\n\tport := 2000\n\tsetupLogger(\"stdout\")\n\tstartGcLoop(1000)\n\tc := &ax.Config{UseTls:false, ConnectionTimeout: 300}\n\tr := ax.Setup(c)\n\tsetupRoutes(r)\n\tsetMessageHandlers()\n\tstart(port)\n}\n\nfunc setupLogger(which string) ", "output": "{\n\tswitch which {\n\tcase \"null\":\n\t\tlog.SetOutput(ioutil.Discard)\n\tcase \"stdout\":\n\t\tlog.SetOutput(os.Stdout)\n\tcase \"file\":\n\t\tf, err := os.Open(\"log.txt\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer func() {\n\t\t\tf.Close()\n\t\t} ()\n\t\tlog.SetOutput(bufio.NewWriter(f))\n\t}\n}"}
{"input": "package runtime\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc Test_LatchAcquireBasic(t *testing.T) {\n\tvar x Latch\n\tif !x.Acquire() {\n\t\tt.Fatalf(\"expected first acquire to succeed\")\n\t}\n\tif x.Acquire() {\n\t\tt.Fatalf(\"expected second acquire to fail\")\n\t}\n\tif x.Acquire() {\n\t\tt.Fatalf(\"expected third acquire to fail\")\n\t}\n}\n\n\n\nfunc Test_LatchAcquireConcurrent(t *testing.T) ", "output": "{\n\tvar x Latch\n\tconst NUM = 10\n\tch := make(chan struct{})\n\tvar success int32\n\tvar wg sync.WaitGroup\n\twg.Add(NUM)\n\tfor i := 0; i < NUM; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t<-ch\n\t\t\tif x.Acquire() {\n\t\t\t\tatomic.AddInt32(&success, 1)\n\t\t\t}\n\t\t}()\n\t}\n\ttime.Sleep(200 * time.Millisecond)\n\tclose(ch)\n\twg.Wait()\n\tif success != 1 {\n\t\tt.Fatalf(\"expected single acquire to succeed instead of %d\", success)\n\t}\n}"}
{"input": "package main\nimport (\n\"testing\"\n\"unicode\"\n\"math/rand\"\n\"time\"\n\"log\"\n\n)\n\n\nfunc IsPalindromeV2_3(s string) bool{\n\tvar letters []rune\n\tfor _ , r:=range s{\n\t\tif unicode.IsLetter(r){\n\t\t\tletters=append(letters,unicode.ToLower(r))\n\t\t}\n\t}\n\tfor i:=range letters{\n\t\tif letters[i]!=letters[len(letters)-i-1]{\n\t\t\treturn false\n\t\t}\n\t}\n\t\treturn true\n}\n\n\nfunc randomPalindrome(rng *rand.Rand)string{\n\tn:=rng.Intn(25)\n\trunes:=make([]rune,n)\n\tfor i := 0; i < (n+1)/2; i++ {\n    r := rune(rng.Intn(0x1000)) \n    runes[i] = r\n    runes[n-1-i] = r\n\t}\n\t\treturn string(runes)\n}\n\n\n\n\nfunc TestRandomPalindromes(t *testing.T)", "output": "{\n\tseed:=time.Now().UTC().UnixNano()\n\tlog.Print(\"Random seed: %d\",seed)\n\trng:=rand.New(rand.NewSource(seed))\n\n\tfor i:=0;i <1000;i++{\n\t\tp:=randomPalindrome(rng)\n\t\tif!IsPalindromeV2_3(p){\n\t\t\tt.Errorf(\"IsPalindromeV2_3(%q)=false\",p)\n\t\t}\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\ntype MainTests struct {\n\tBaseTests\n}\n\nvar _ = Suite(&MainTests{})\n\nfunc (t *MainTests) TestPrompt(c *C) {\n\tt.in.WriteString(\"test\\n\")\n\tres, err := t.d.promptPassword(\"Foo: \")\n\tc.Assert(t.out.Bytes(), DeepEquals, []byte(\"Foo: \"))\n\tc.Assert(err, IsNil)\n\tc.Assert(res, DeepEquals, []byte(\"test\"))\n}\n\n\n\nfunc (t *MainTests) TestArgHandling(c *C) {\n\tc.Assert(t.d.run([]string{\"help\", \"sync\"}), Equals, 0)\n\tfmt.Println(t.out.String())\n\tc.Assert(strings.Index(t.out.String(), \"sync\"), Not(Equals), -1)\n}\n\nfunc (t *MainTests) TestNoArg(c *C) {\n\tc.Assert(t.d.run([]string{}), Equals, 1)\n}\n\nfunc (t *MainTests) TestHelpOnUnknownCommand(c *C) {\n\tc.Assert(t.d.run([]string{\"help\", \"non-existant-command\"}), Equals, 1)\n}\n\nfunc (t *MainTests) TestNonExistentCommand(c *C) {\n\tc.Assert(t.d.run([]string{\"non-existant-command\"}), Equals, 1)\n}\n\nfunc (t *MainTests) TestPromptTwice(c *C) ", "output": "{\n\tt.in.WriteString(\"test\\nfoo\\n\")\n\tres, err := t.d.promptPassword(\"Foo: \")\n\tc.Assert(t.out.Bytes(), DeepEquals, []byte(\"Foo: \"))\n\tc.Assert(err, IsNil)\n\tc.Assert(res, DeepEquals, []byte(\"test\"))\n\n\tres, err = t.d.promptPassword(\"Bar: \")\n\tc.Assert(t.out.Bytes(), DeepEquals, []byte(\"Foo: Bar: \"))\n\tc.Assert(err, IsNil)\n\tc.Assert(res, DeepEquals, []byte(\"foo\"))\n}"}
{"input": "package golib\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nconst gopathPluginDir = \"bin\"\n\n\n\n\n\nfunc PluginSearchPath() ([]string, error) {\n\tpaths := strings.Split(os.Getenv(\"PATH\"), string(os.PathListSeparator))\n\n\tfor _, gopath := range strings.Split(os.Getenv(\"GOPATH\"), string(os.PathListSeparator)) {\n\t\tpaths = append(paths, path.Join(gopath, gopathPluginDir))\n\t}\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpaths = append(paths, wd)\n\n\texecutableDir, err := filepath.Abs(filepath.Dir(os.Args[0]))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpaths = append(paths, executableDir)\n\n\treturn RemoveDuplicates(paths), nil\n}\n\n\n\n\n\n\nfunc FindMatchingFiles(regex *regexp.Regexp, directories []string) (result []string, errs []error) ", "output": "{\n\tfor _, dir := range directories {\n\t\tfiles, readErr := ioutil.ReadDir(dir)\n\t\tif readErr != nil {\n\t\t\terrs = append(errs, readErr)\n\t\t\tcontinue\n\t\t}\n\t\tfor _, file := range files {\n\t\t\tif file.IsDir() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbaseName := file.Name()\n\t\t\tif regex.MatchString(baseName) {\n\t\t\t\tresult = append(result, path.Join(dir, baseName))\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}"}
{"input": "package v3public\n\nimport (\n\t\"github.com/rancher/norman/lifecycle\"\n\t\"github.com/rancher/norman/resource\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n)\n\ntype AuthProviderLifecycle interface {\n\tCreate(obj *AuthProvider) (runtime.Object, error)\n\tRemove(obj *AuthProvider) (runtime.Object, error)\n\tUpdated(obj *AuthProvider) (runtime.Object, error)\n}\n\ntype authProviderLifecycleAdapter struct {\n\tlifecycle AuthProviderLifecycle\n}\n\nfunc (w *authProviderLifecycleAdapter) HasCreate() bool {\n\to, ok := w.lifecycle.(lifecycle.ObjectLifecycleCondition)\n\treturn !ok || o.HasCreate()\n}\n\nfunc (w *authProviderLifecycleAdapter) HasFinalize() bool {\n\to, ok := w.lifecycle.(lifecycle.ObjectLifecycleCondition)\n\treturn !ok || o.HasFinalize()\n}\n\nfunc (w *authProviderLifecycleAdapter) Create(obj runtime.Object) (runtime.Object, error) {\n\to, err := w.lifecycle.Create(obj.(*AuthProvider))\n\tif o == nil {\n\t\treturn nil, err\n\t}\n\treturn o, err\n}\n\nfunc (w *authProviderLifecycleAdapter) Finalize(obj runtime.Object) (runtime.Object, error) {\n\to, err := w.lifecycle.Remove(obj.(*AuthProvider))\n\tif o == nil {\n\t\treturn nil, err\n\t}\n\treturn o, err\n}\n\nfunc (w *authProviderLifecycleAdapter) Updated(obj runtime.Object) (runtime.Object, error) {\n\to, err := w.lifecycle.Updated(obj.(*AuthProvider))\n\tif o == nil {\n\t\treturn nil, err\n\t}\n\treturn o, err\n}\n\n\n\nfunc NewAuthProviderLifecycleAdapter(name string, clusterScoped bool, client AuthProviderInterface, l AuthProviderLifecycle) AuthProviderHandlerFunc ", "output": "{\n\tif clusterScoped {\n\t\tresource.PutClusterScoped(AuthProviderGroupVersionResource)\n\t}\n\tadapter := &authProviderLifecycleAdapter{lifecycle: l}\n\tsyncFn := lifecycle.NewObjectLifecycleAdapter(name, clusterScoped, adapter, client.ObjectClient())\n\treturn func(key string, obj *AuthProvider) (runtime.Object, error) {\n\t\tnewObj, err := syncFn(key, obj)\n\t\tif o, ok := newObj.(runtime.Object); ok {\n\t\t\treturn o, err\n\t\t}\n\t\treturn nil, err\n\t}\n}"}
{"input": "package windows\n\nimport (\n\t\"github.com/docker/libnetwork/driverapi\"\n\t\"github.com/docker/libnetwork/types\"\n)\n\nconst networkType = \"windows\"\n\n\n\ntype driver struct{}\n\n\nfunc Init(dc driverapi.DriverCallback) error {\n\tc := driverapi.Capability{\n\t\tScope: driverapi.LocalScope,\n\t}\n\treturn dc.RegisterDriver(networkType, &driver{}, c)\n}\n\nfunc (d *driver) Config(option map[string]interface{}) error {\n\treturn nil\n}\n\nfunc (d *driver) CreateNetwork(id types.UUID, option map[string]interface{}) error {\n\treturn nil\n}\n\nfunc (d *driver) DeleteNetwork(nid types.UUID) error {\n\treturn nil\n}\n\nfunc (d *driver) CreateEndpoint(nid, eid types.UUID, epInfo driverapi.EndpointInfo, epOptions map[string]interface{}) error {\n\treturn nil\n}\n\nfunc (d *driver) DeleteEndpoint(nid, eid types.UUID) error {\n\treturn nil\n}\n\nfunc (d *driver) EndpointOperInfo(nid, eid types.UUID) (map[string]interface{}, error) {\n\treturn make(map[string]interface{}, 0), nil\n}\n\n\n\n\n\nfunc (d *driver) Leave(nid, eid types.UUID) error {\n\treturn nil\n}\n\nfunc (d *driver) Type() string {\n\treturn networkType\n}\n\nfunc (d *driver) Join(nid, eid types.UUID, sboxKey string, jinfo driverapi.JoinInfo, options map[string]interface{}) error ", "output": "{\n\treturn nil\n}"}
{"input": "package common\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\n\nfunc Test_Pad_PKCS7(t *testing.T) ", "output": "{\n\tinput := []byte(\"YELLOW SUBMARINE\")\n\n\treceived := Pad_PKCS7(input, 4)\n\texpected := []byte(\"YELLOW SUBMARINE\\x04\\x04\\x04\\x04\")\n\n\tassert.Equal(t, expected, received)\n}"}
{"input": "package rocksdb\n\nimport (\n\t\"github.com/tecbot/gorocksdb\"\n)\n\ntype Iterator struct {\n\tstore    *Store\n\titerator *gorocksdb.Iterator\n}\n\nfunc newIterator(store *Store) *Iterator {\n\tropts := defaultReadOptions()\n\trv := Iterator{\n\t\tstore:    store,\n\t\titerator: store.db.NewIterator(ropts),\n\t}\n\treturn &rv\n}\n\nfunc newIteratorWithSnapshot(store *Store, snapshot *gorocksdb.Snapshot) *Iterator {\n\toptions := defaultReadOptions()\n\toptions.SetSnapshot(snapshot)\n\trv := Iterator{\n\t\tstore:    store,\n\t\titerator: store.db.NewIterator(options),\n\t}\n\treturn &rv\n}\n\nfunc (ldi *Iterator) SeekFirst() {\n\tldi.iterator.SeekToFirst()\n}\n\nfunc (ldi *Iterator) Seek(key []byte) {\n\tldi.iterator.Seek(key)\n}\n\nfunc (ldi *Iterator) Next() {\n\tldi.iterator.Next()\n}\n\nfunc (ldi *Iterator) Current() ([]byte, []byte, bool) {\n\tif ldi.Valid() {\n\t\treturn ldi.Key(), ldi.Value(), true\n\t}\n\treturn nil, nil, false\n}\n\n\n\nfunc (ldi *Iterator) Value() []byte {\n\treturn ldi.iterator.Value().Data()\n}\n\nfunc (ldi *Iterator) Valid() bool {\n\treturn ldi.iterator.Valid()\n}\n\nfunc (ldi *Iterator) Close() error {\n\tldi.iterator.Close()\n\treturn nil\n}\n\nfunc (ldi *Iterator) Key() []byte ", "output": "{\n\treturn ldi.iterator.Key().Data()\n}"}
{"input": "package fsm\n\nimport (\n\t\"log\"\n\t\"testing\"\n)\n\nconst (\n\tRUNNING = iota\n\tSTOPPED\n)\n\ntype RunningState int\n\nfunc (s *RunningState) Enter() {\n\tlog.Println(\"enter running state\")\n}\n\nfunc (s *RunningState) Exit() {\n\tlog.Println(\"out of running\")\n}\n\nfunc (s *RunningState) CheckTransition(ev int) bool {\n\treturn ev == RUNNING\n}\n\ntype StoppedState int\n\nfunc (s *StoppedState) Enter() {\n\tlog.Println(\"Stopped enter\")\n}\n\nfunc (s *StoppedState) Exit() {\n\tlog.Println(\"Stopped exit\")\n}\n\nfunc (s *StoppedState) CheckTransition(ev int) bool {\n\treturn ev == STOPPED\n}\n\n\n\nfunc TestFSM(t *testing.T) ", "output": "{\n\tt.Log(\"Hello\")\n\trstate := new(RunningState)\n\tsstate := new(StoppedState)\n\n\tfsm := new(FSM)\n\tfsm.AddState(\"running\", rstate)\n\tfsm.AddState(\"stopped\", sstate)\n\tfsm.Init()\n\tfsm.InputData(RUNNING)\n\tfsm.InputData(STOPPED)\n\tfsm.InputData(RUNNING)\n}"}
{"input": "package cmd\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/fatih/color\"\n\tout \"github.com/plouc/go-gitlab-client/cli/output\"\n\t\"github.com/plouc/go-gitlab-client/gitlab\"\n\t\"github.com/spf13/cobra\"\n)\n\nfunc init() {\n\tlistCmd.AddCommand(listSshKeysCmd)\n}\n\n\n\nvar listSshKeysCmd = &cobra.Command{\n\tUse:     \"ssh-keys\",\n\tAliases: []string{\"sk\"},\n\tShort:   \"List current user ssh keys\",\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tfetchSshKeys()\n\t},\n}\n\nfunc fetchSshKeys() ", "output": "{\n\tcolor.Yellow(\"Fetching current user ssh keys…\")\n\n\to := &gitlab.PaginationOptions{}\n\to.Page = page\n\to.PerPage = perPage\n\n\tloader.Start()\n\tcollection, meta, err := client.CurrentUserSshKeys(o)\n\tloader.Stop()\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\n\tif len(collection.Items) == 0 {\n\t\tcolor.Red(\"No ssh key found\")\n\t} else {\n\t\tout.SshKeys(output, outputFormat, collection)\n\t}\n\n\tprintMeta(meta, true)\n\n\thandlePaginatedResult(meta, fetchSshKeys)\n}"}
{"input": "package cat\n\nimport(\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/ProhtMeyhet/libgosimpleton/iotool\"\n\t\"github.com/ProhtMeyhet/libgosimpleton/parallel\"\n\n\t\"github.com/ProhtMeyhet/gonixutils/library/abstract\"\n)\n\n\nfunc Cat(input *Input) (exitCode uint8) {\n\toutput := abstract.NewOutput(input.Stdout, input.Stderr)\n\tif input.Verbose { output.TogglePrintSubBufferNames() }\n\thelper := prepareFileHelper(input, output, &exitCode)\n\n\te := CopyFilesTo(output, helper, input.Paths...); if e != nil && exitCode == 0 {\n\t\texitCode = abstract.ERROR_UNHANDLED\n\t}\n\n\toutput.Done(); output.Wait(); return\n}\n\n\n\nfunc CopyFilesFilteredTo(mainOutput abstract.OutputInterface, helper *iotool.FileHelper,\n\t\tfilter func(io.Reader) io.Reader, paths ...string) (e error) {\n\toutput := mainOutput\n\tparallel.ReadFilesSequential(helper, paths, func(buffered *iotool.NamedBuffer) {\n\t\tvar filtered io.Reader\n\t\tif output.PrintSubBufferNames() {\n\t\t\toutput = mainOutput.NewSubBuffer(fmt.Sprintf(\"==>%v<==\\n\", buffered.Name()), 0)\n\t\t}\n\n\t\tif filter != nil { filtered = filter(buffered) }\n\t\tif filtered == nil { filtered = buffered }\n\n\t\t_, e = io.Copy(output, filtered)\n\t\tif output.PrintSubBufferNames() { output.Done() }\n\t}).Wait(); return\n}\n\nfunc CopyFilesTo(mainOutput abstract.OutputInterface, helper *iotool.FileHelper, paths ...string) (e error) ", "output": "{\n\treturn CopyFilesFilteredTo(mainOutput, helper, nil, paths...)\n}"}
{"input": "package etcd\n\nimport (\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apiserver/pkg/registry/generic\"\n\t\"k8s.io/apiserver/pkg/registry/generic/registry\"\n\tkapi \"k8s.io/kubernetes/pkg/api\"\n\n\t\"github.com/openshift/origin/pkg/sdn/api\"\n\t\"github.com/openshift/origin/pkg/sdn/registry/clusternetwork\"\n\t\"github.com/openshift/origin/pkg/user/registry/user\"\n\t\"github.com/openshift/origin/pkg/util/restoptions\"\n)\n\n\ntype REST struct {\n\t*registry.Store\n}\n\n\n\n\nfunc NewREST(optsGetter restoptions.Getter) (*REST, error) ", "output": "{\n\tstore := &registry.Store{\n\t\tCopier:            kapi.Scheme,\n\t\tNewFunc:           func() runtime.Object { return &api.ClusterNetwork{} },\n\t\tNewListFunc:       func() runtime.Object { return &api.ClusterNetworkList{} },\n\t\tPredicateFunc:     clusternetwork.Matcher,\n\t\tQualifiedResource: api.Resource(\"clusternetworks\"),\n\n\t\tCreateStrategy: clusternetwork.Strategy,\n\t\tUpdateStrategy: clusternetwork.Strategy,\n\t\tDeleteStrategy: clusternetwork.Strategy,\n\t}\n\n\toptions := &generic.StoreOptions{RESTOptions: optsGetter, AttrFunc: user.GetAttrs}\n\tif err := store.CompleteWithOptions(options); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &REST{store}, nil\n}"}
{"input": "package pipedrive\n\nimport \"time\"\n\ntype Time struct {\n\ttime.Time\n}\n\nfunc NewTime(t time.Time) Time {\n\treturn Time{t}\n}\n\nfunc (t *Time) UnmarshalJSON(buf []byte) error {\n\ttt, err := time.Parse(\"2006-01-02 15:04:05\", string(buf[1:len(buf)-1]))\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.Time = tt\n\treturn nil\n}\n\nfunc (t *Time) String() string {\n\tif t == nil {\n\t\treturn \"\"\n\t}\n\treturn t.Time.Local().Format(\"2006-01-02 15:04:05\")\n}\n\ntype Date struct {\n\ttime.Time\n}\n\nfunc NewDate(t time.Time) Date {\n\treturn Date{t}\n}\n\nfunc (t *Date) UnmarshalJSON(buf []byte) error {\n\ttt, err := time.Parse(\"2006-01-02\", string(buf[1:len(buf)-1]))\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.Time = tt\n\treturn nil\n}\n\n\n\nfunc (t *Date) String() string ", "output": "{\n\tif t == nil {\n\t\treturn \"\"\n\t}\n\treturn t.Time.Local().Format(\"2006-01-02\")\n}"}
{"input": "package tlf\n\nimport (\n\t\"testing\"\n\n\t\"github.com/keybase/client/go/protocol/keybase1\"\n\t\"github.com/keybase/kbfs/kbfscodec\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n\n\nfunc TestMakeIDFromTeam(t *testing.T) {\n\tprivateTID := keybase1.MakeTestTeamID(1, false)\n\tpublicTID := keybase1.MakeTestTeamID(2, true)\n\n\tepochIndex := idByteLen - 2\n\tcheck := func(ty Type, tid keybase1.TeamID, epoch byte) {\n\t\tid, err := MakeIDFromTeam(ty, tid, epoch)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, id.Type(), ty)\n\t\trequire.Equal(t, tid.ToBytes()[:epochIndex], id.Bytes()[:epochIndex])\n\t\trequire.Equal(t, epoch, id.Bytes()[epochIndex])\n\t}\n\tcheck(Private, privateTID, 0)\n\tcheck(Public, publicTID, 0)\n\tcheck(SingleTeam, privateTID, 0)\n\tcheck(Private, privateTID, 15)\n\n\t_, err := MakeIDFromTeam(Public, privateTID, 0)\n\trequire.NotNil(t, err)\n\t_, err = MakeIDFromTeam(Private, publicTID, 0)\n\trequire.NotNil(t, err)\n\t_, err = MakeIDFromTeam(SingleTeam, publicTID, 0)\n\trequire.NotNil(t, err)\n\t_, err = MakeIDFromTeam(\n\t\tPrivate, keybase1.TeamID(\"extra\"+privateTID.String()), 0)\n\trequire.NotNil(t, err)\n}\n\nfunc TestIDEncodeDecode(t *testing.T) ", "output": "{\n\tcodec := kbfscodec.NewMsgpack()\n\tid := FakeID(1, Public)\n\n\tencodedID, err := codec.Encode(id)\n\trequire.NoError(t, err)\n\n\tconst overhead = 2\n\trequire.Equal(t, idByteLen+overhead, len(encodedID))\n\n\tvar id2 ID\n\terr = codec.Decode(encodedID, &id2)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, id, id2)\n}"}
{"input": "package main\n\nimport \"go.opentelemetry.io/collector/service\"\n\n\n\nfunc run(params service.CollectorSettings) error ", "output": "{\n\treturn runInteractive(params)\n}"}
{"input": "package buildinfo\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t. \"src.elv.sh/pkg/prog/progtest\"\n)\n\n\n\nfunc TestProgram(t *testing.T) ", "output": "{\n\tTest(t, &Program{},\n\t\tThatElvish(\"-version\").WritesStdout(Value.Version+\"\\n\"),\n\t\tThatElvish(\"-version\", \"-json\").WritesStdout(mustToJSON(Value.Version)+\"\\n\"),\n\n\t\tThatElvish(\"-buildinfo\").WritesStdout(\n\t\t\tfmt.Sprintf(\n\t\t\t\t\"Version: %v\\nGo version: %v\\nReproducible build: %v\\n\",\n\t\t\t\tValue.Version, Value.GoVersion, Value.Reproducible)),\n\t\tThatElvish(\"-buildinfo\", \"-json\").WritesStdout(mustToJSON(Value)+\"\\n\"),\n\n\t\tThatElvish().ExitsWith(2).WritesStderr(\"internal error: no suitable subprogram\\n\"),\n\t)\n}"}
{"input": "package shellutils\n\nimport (\n\t\"context\"\n\t\"sync\"\n\n\t\"github.com/aos-dev/go-storage/v2\"\n\t\"github.com/qingstor/log\"\n\t\"github.com/qingstor/noah/task\"\n\n\t\"github.com/qingstor/qsctl/v2/cmd/qsctl/taskutils\"\n\t\"github.com/qingstor/qsctl/v2/utils\"\n)\n\nvar mu = new(sync.Mutex)\n\nvar bucketList = make([]string, 0, 10)\n\n\nfunc InitBucketList(ctx context.Context) {\n\tlogger := log.FromContext(ctx)\n\n\trootTask := taskutils.NewAtServiceTask(10)\n\terr := utils.ParseAtServiceInput(rootTask)\n\tif err != nil {\n\t\tlogger.Error(\n\t\t\tlog.String(\"action\", \"get service\"),\n\t\t\tlog.String(\"err\", err.Error()),\n\t\t)\n\t\treturn\n\t}\n\n\tt := task.NewListStorage(rootTask)\n\tt.SetZone(\"\")\n\tt.SetStoragerFunc(func(stor storage.Storager) {\n\t\tsm, _ := stor.Metadata()\n\t\tAddBucketIntoList(sm.Name)\n\t})\n\tt.Run(ctx)\n\treturn\n}\n\n\nfunc GetBucketList() []string {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\tres := make([]string, len(bucketList))\n\tcopy(res, bucketList)\n\treturn res\n}\n\n\n\n\n\nfunc AddBucketIntoList(bucket string) {\n\tmu.Lock()\n\tbucketList = append(bucketList, bucket)\n\tmu.Unlock()\n}\n\nfunc RemoveBucketFromList(bucket string) ", "output": "{\n\tif len(bucketList) == 0 {\n\t\treturn\n\t}\n\tfor i, b := range bucketList {\n\t\tif b == bucket {\n\t\t\tmu.Lock()\n\t\t\tbucketList = append(bucketList[:i], bucketList[i+1:]...)\n\t\t\tmu.Unlock()\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}"}
{"input": "package cache\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/garyburd/redigo/redis\"\n)\n\ntype Cache interface {\n\tSet(string, string) error\n\tGet(string) ([]byte, error)\n\tSubscribe(string, func()) error\n}\n\n\ntype RedisCache struct {\n\tpool *redis.Pool\n}\n\n\nfunc (c *RedisCache) Set(key, value string) error {\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\n\tconn.Send(\"PUBLISH\", \"ingress-router\", \"updated\")\n\tif _, err := conn.Do(\"SET\", key, value); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc (c *RedisCache) Get(key string) ([]byte, error) {\n\tvar s []byte\n\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\n\tresult, err := conn.Do(\"GET\", key)\n\tif err != nil {\n\t\treturn s, err\n\t}\n\n\tb, ok := result.([]byte)\n\tif !ok {\n\t\treturn s, errors.New(\"Failed to parse value as a string\")\n\t}\n\n\treturn b, nil\n}\n\n\nfunc NewCache(address string) Cache {\n\tpool := &redis.Pool{\n\t\tMaxIdle:     2,\n\t\tIdleTimeout: 300 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\treturn redis.Dial(\"tcp\", address)\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\t_, err := c.Do(\"PING\")\n\t\t\treturn err\n\t\t},\n\t}\n\n\treturn Cache(&RedisCache{pool: pool})\n}\n\nfunc (c *RedisCache) Subscribe(channel string, action func()) error ", "output": "{\n\tconn := c.pool.Get()\n\tdefer conn.Close()\n\n\tif _, err := conn.Do(\"SUBSCRIBE\", \"ingress-router\"); err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tif _, err := conn.Receive(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\taction()\n\t}\n}"}
{"input": "package goparser\n\nimport (\n\t\"go/ast\"\n\t\"testing\"\n)\n\n\n\n\nfunc TestCmtToStr1(t *testing.T) {\n\ttestCmtAgainstExpt(t,\n\t\t\"//\\n\"+\n\t\t\t\" // testing line 1\\n\"+\n\t\t\t\"//testing line 2\\n\"+\n\t\t\t\"// testing line 3\",\n\t\t\"testing line 1\\n\"+\n\t\t\t\"testing line 2\\n\"+\n\t\t\t\"testing line 3\\n\")\n}\n\n\nfunc TestCmtToStr2(t *testing.T) {\n\ttestCmtAgainstExpt(t,\n\t\t\"/**\\n\"+\n\t\t\t\" * testing line 1\\n\"+\n\t\t\t\"* testing line 2\\n\"+\n\t\t\t\" * testing line 3\\n\"+\n\t\t\t\" */\",\n\t\t\" testing line 1\\n\"+\n\t\t\t\" testing line 2\\n\"+\n\t\t\t\" testing line 3\\n\")\n}\n\n\nfunc TestCmtToStr3(t *testing.T) {\n\ttestCmtAgainstExpt(t,\n\t\t\"/*\\n\"+\n\t\t\t\" testing line 1\\n\"+\n\t\t\t\" testing line 2\\n\"+\n\t\t\t\"  testing line 3\\n\"+\n\t\t\t\"*/\",\n\t\t\" testing line 1\\n\"+\n\t\t\t\" testing line 2\\n\"+\n\t\t\t\"  testing line 3\\n\")\n}\n\nfunc testCmtAgainstExpt(t *testing.T, text, expected string) ", "output": "{\n\tcmt := ast.Comment{\n\t\tText: text,\n\t}\n\n\tresult := CmtToStr(&cmt)\n\n\tif expected != result {\n\t\tt.Errorf(\"Result doesn't match expectation\")\n\t\tt.Errorf(\"Expected:\\n%s\", expected)\n\t\tt.Errorf(\"Get:\\n%s\", result)\n\t}\n}"}
{"input": "package mssql\n\nimport (\n\t\"context\"\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"errors\"\n)\n\ntype copyin struct {\n\tcn       *Conn\n\tbulkcopy *Bulk\n\tclosed   bool\n}\n\ntype serializableBulkConfig struct {\n\tTableName   string\n\tColumnsName []string\n\tOptions     BulkOptions\n}\n\nfunc (d *Driver) OpenConnection(dsn string) (*Conn, error) {\n\treturn d.open(context.Background(), dsn)\n}\n\nfunc (c *Conn) prepareCopyIn(ctx context.Context, query string) (_ driver.Stmt, err error) {\n\tconfig_json := query[11:]\n\n\tbulkconfig := serializableBulkConfig{}\n\terr = json.Unmarshal([]byte(config_json), &bulkconfig)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tbulkcopy := c.CreateBulkContext(ctx, bulkconfig.TableName, bulkconfig.ColumnsName)\n\tbulkcopy.Options = bulkconfig.Options\n\n\tci := &copyin{\n\t\tcn:       c,\n\t\tbulkcopy: bulkcopy,\n\t}\n\n\treturn ci, nil\n}\n\nfunc CopyIn(table string, options BulkOptions, columns ...string) string {\n\tbulkconfig := &serializableBulkConfig{TableName: table, Options: options, ColumnsName: columns}\n\n\tconfig_json, err := json.Marshal(bulkconfig)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tstmt := \"INSERTBULK \" + string(config_json)\n\n\treturn stmt\n}\n\nfunc (ci *copyin) NumInput() int {\n\treturn -1\n}\n\nfunc (ci *copyin) Query(v []driver.Value) (r driver.Rows, err error) {\n\tpanic(\"should never be called\")\n}\n\n\n\nfunc (ci *copyin) Close() (err error) {\n\treturn nil\n}\n\nfunc (ci *copyin) Exec(v []driver.Value) (r driver.Result, err error) ", "output": "{\n\tif ci.closed {\n\t\treturn nil, errors.New(\"errCopyInClosed\")\n\t}\n\n\tif len(v) == 0 {\n\t\trowCount, err := ci.bulkcopy.Done()\n\t\tci.closed = true\n\t\treturn driver.RowsAffected(rowCount), err\n\t}\n\n\tt := make([]interface{}, len(v))\n\tfor i, val := range v {\n\t\tt[i] = val\n\t}\n\n\terr = ci.bulkcopy.AddRow(t)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn driver.RowsAffected(0), nil\n}"}
{"input": "package spi\n\nimport (\n\t\"image/color\"\n\t\"testing\"\n\n\t\"gobot.io/x/gobot\"\n\t\"gobot.io/x/gobot/gobottest\"\n)\n\nvar _ gobot.Driver = (*APA102Driver)(nil)\n\nfunc initTestDriver() *APA102Driver {\n\td := NewAPA102Driver(&TestConnector{}, 10, 31)\n\treturn d\n}\n\nfunc TestDriverStart(t *testing.T) {\n\td := initTestDriver()\n\tgobottest.Assert(t, d.Start(), nil)\n}\n\n\n\nfunc TestDriverLEDs(t *testing.T) {\n\td := initTestDriver()\n\td.Start()\n\n\td.SetRGBA(0, color.RGBA{255, 255, 255, 15})\n\td.SetRGBA(1, color.RGBA{255, 255, 255, 15})\n\td.SetRGBA(2, color.RGBA{255, 255, 255, 15})\n\td.SetRGBA(3, color.RGBA{255, 255, 255, 15})\n\n\tgobottest.Assert(t, d.Draw(), nil)\n}\n\nfunc TestDriverHalt(t *testing.T) ", "output": "{\n\td := initTestDriver()\n\td.Start()\n\tgobottest.Assert(t, d.Halt(), nil)\n}"}
{"input": "package patch\n\ntype Ops []Op\n\ntype Op interface {\n\tApply(interface{}) (interface{}, error)\n}\n\n\nvar _ Op = Ops{}\nvar _ Op = ReplaceOp{}\nvar _ Op = RemoveOp{}\nvar _ Op = FindOp{}\nvar _ Op = DescriptiveOp{}\nvar _ Op = ErrOp{}\n\n\n\nfunc (ops Ops) Apply(doc interface{}) (interface{}, error) ", "output": "{\n\tvar err error\n\n\tfor _, op := range ops {\n\t\tdoc, err = op.Apply(doc)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn doc, nil\n}"}
{"input": "package configv3_test\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n)\n\nfunc TestConfig(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Config Suite\")\n}\n\n\n\nfunc teardown(homeDir string) {\n\tif homeDir != \"\" {\n\t\terr := os.RemoveAll(homeDir)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\terr = os.Unsetenv(\"CF_HOME\")\n\t\tExpect(err).ToNot(HaveOccurred())\n\t}\n}\n\nfunc setConfig(homeDir string, rawConfig string) {\n\terr := os.MkdirAll(filepath.Join(homeDir, \".cf\"), 0777)\n\tExpect(err).ToNot(HaveOccurred())\n\terr = ioutil.WriteFile(filepath.Join(homeDir, \".cf\", \"config.json\"), []byte(rawConfig), 0644)\n\tExpect(err).ToNot(HaveOccurred())\n}\n\nfunc setPluginConfig(pluginDir string, rawConfig string) {\n\terr := os.MkdirAll(filepath.Join(pluginDir), 0777)\n\tExpect(err).ToNot(HaveOccurred())\n\terr = ioutil.WriteFile(filepath.Join(pluginDir, \"config.json\"), []byte(rawConfig), 0644)\n\tExpect(err).ToNot(HaveOccurred())\n}\n\nfunc setup() string ", "output": "{\n\thomeDir, err := ioutil.TempDir(\"\", \"cli-config-tests\")\n\tExpect(err).NotTo(HaveOccurred())\n\terr = os.Setenv(\"CF_HOME\", homeDir)\n\tExpect(err).NotTo(HaveOccurred())\n\treturn homeDir\n}"}
{"input": "package crash\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\n\ntype ErrorFailedToReadCrashDir struct {\n\tCrashDir string \n\tNext     error  \n}\n\n\n\n\n\ntype ErrorFailedToParseCrashReport struct {\n\tName string \n\tNext error  \n}\n\n\nfunc (self ErrorFailedToParseCrashReport) Error() string {\n\treturn fmt.Sprintf(\"Failed to parse crash report %s [%s]\", self.Name, self.Next)\n}\n\n\ntype ReportVisitor interface {\n\tNewReport(name string, report Report)\n\tNewError(err error)\n}\n\n\n\nfunc ForEachReportInDir(dir string, visitor ReportVisitor) {\n\tentries, err := ioutil.ReadDir(dir)\n\n\tif err != nil {\n\t\tvisitor.NewError(ErrorFailedToReadCrashDir{dir, err})\n\t\treturn\n\t}\n\n\tfor _, entry := range entries {\n\t\tfn := filepath.Join(dir, entry.Name())\n\n\t\tif matched, _ := filepath.Match(\"*.crash\", entry.Name()); !matched {\n\t\t\tcontinue\n\t\t}\n\n\t\tf, err := os.Open(fn)\n\t\tif err != nil {\n\t\t\tvisitor.NewError(ErrorFailedToParseCrashReport{entry.Name(), err})\n\t\t\tcontinue\n\t\t}\n\n\t\tdefer f.Close()\n\t\treport, err := ParseReport(NewLineReader{f})\n\n\t\tif err != nil {\n\t\t\tvisitor.NewError(ErrorFailedToParseCrashReport{entry.Name(), err})\n\t\t\tcontinue\n\t\t}\n\n\t\tvisitor.NewReport(entry.Name(), report)\n\t}\n}\n\nfunc (self ErrorFailedToReadCrashDir) Error() string ", "output": "{\n\treturn fmt.Sprintf(\"Failed to read crash dir %s [%s]\", self.CrashDir, self.Next)\n}"}
{"input": "package observiqexporter \n\nimport (\n\t\"errors\"\n\n\t\"go.opentelemetry.io/collector/component\"\n\t\"go.opentelemetry.io/collector/exporter/exporterhelper\"\n)\n\n\n\nfunc newObservIQLogExporter(config *Config, set component.ExporterCreateSettings) (component.LogsExporter, error) ", "output": "{\n\tif config == nil {\n\t\treturn nil, errors.New(\"config must not be nil\")\n\t}\n\n\tif err := config.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient, err := buildClient(config, set.Logger, set.BuildInfo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\texporter, err := exporterhelper.NewLogsExporter(\n\t\tconfig,\n\t\tset,\n\t\tclient.sendLogs,\n\t\texporterhelper.WithTimeout(exporterhelper.TimeoutSettings{Timeout: 0}),\n\t\texporterhelper.WithRetry(config.RetrySettings),\n\t\texporterhelper.WithQueue(config.QueueSettings),\n\t\texporterhelper.WithShutdown(client.stop),\n\t)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn exporter, nil\n}"}
{"input": "package main\n\nimport (\n\t\"time\"\n)\n\n\ntype TimeTeller interface {\n\tNow() time.Time\n\tAfter(time.Duration) <-chan time.Time\n}\n\ntype RealTime struct{}\n\n\n\nfunc (r *RealTime) After(d time.Duration) <-chan time.Time {\n\treturn time.After(d)\n}\n\nfunc (r *RealTime) Now() time.Time ", "output": "{\n\treturn time.Now()\n}"}
{"input": "package tracing\n\nimport (\n\t\"bufio\"\n\t\"net\"\n\t\"net/http\"\n)\n\ntype statusCodeRecoder interface {\n\thttp.ResponseWriter\n\tStatus() int\n}\n\ntype statusCodeWithoutCloseNotify struct {\n\thttp.ResponseWriter\n\tstatus int\n}\n\n\nfunc (s *statusCodeWithoutCloseNotify) WriteHeader(status int) {\n\ts.status = status\n\ts.ResponseWriter.WriteHeader(status)\n}\n\n\n\n\n\nfunc (s *statusCodeWithoutCloseNotify) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\treturn s.ResponseWriter.(http.Hijacker).Hijack()\n}\n\n\nfunc (s *statusCodeWithoutCloseNotify) Flush() {\n\tif flusher, ok := s.ResponseWriter.(http.Flusher); ok {\n\t\tflusher.Flush()\n\t}\n}\n\ntype statusCodeWithCloseNotify struct {\n\t*statusCodeWithoutCloseNotify\n}\n\nfunc (s *statusCodeWithCloseNotify) CloseNotify() <-chan bool {\n\treturn s.ResponseWriter.(http.CloseNotifier).CloseNotify()\n}\n\n\nfunc newStatusCodeRecoder(rw http.ResponseWriter, status int) statusCodeRecoder {\n\trecorder := &statusCodeWithoutCloseNotify{rw, status}\n\tif _, ok := rw.(http.CloseNotifier); ok {\n\t\treturn &statusCodeWithCloseNotify{recorder}\n\t}\n\treturn recorder\n}\n\nfunc (s *statusCodeWithoutCloseNotify) Status() int ", "output": "{\n\treturn s.status\n}"}
{"input": "package serverService\n\nimport (\n\t\"github.com/coreos/go-systemd/activation\"\n\t\"log\"\n\t\"net/http\"\n)\n\n\n\nfunc startService(server *http.Server) ", "output": "{\n\tlisteners, err := activation.Listeners(true)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\tlog.Println(\"Web server is starting.\")\n\tif len(listeners) == 0 {\n\t\tif err := server.ListenAndServe(); err != nil {\n\t\t\tlog.Fatal(\"Error on startup: \", err)\n\t\t}\n\t} else {\n\t\tlog.Println(\"Listening to sockets.\")\n\t\tif len(listeners) != 1 {\n\t\t\tlog.Fatal(\"Unexpected number of socket activation fds. Number: \", len(listeners))\n\t\t}\n\t\tif err := server.Serve(listeners[0]); err != nil {\n\t\t\tlog.Fatal(\"Error starting socket activated web server: \", err)\n\t\t}\n\t}\n}"}
{"input": "package html_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\n\t\"github.com/appc/spec/Godeps/_workspace/src/golang.org/x/net/html\"\n)\n\n\n\nfunc ExampleParse() ", "output": "{\n\ts := `<p>Links:</p><ul><li><a href=\"foo\">Foo</a><li><a href=\"/bar/baz\">BarBaz</a></ul>`\n\tdoc, err := html.Parse(strings.NewReader(s))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tvar f func(*html.Node)\n\tf = func(n *html.Node) {\n\t\tif n.Type == html.ElementNode && n.Data == \"a\" {\n\t\t\tfor _, a := range n.Attr {\n\t\t\t\tif a.Key == \"href\" {\n\t\t\t\t\tfmt.Println(a.Val)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\tf(c)\n\t\t}\n\t}\n\tf(doc)\n}"}
{"input": "package v3\n\nimport (\n\t\"github.com/rancher/norman/lifecycle\"\n\t\"github.com/rancher/norman/resource\"\n\t\"github.com/rancher/rancher/pkg/apis/management.cattle.io/v3\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n)\n\ntype TemplateLifecycle interface {\n\tCreate(obj *v3.Template) (runtime.Object, error)\n\tRemove(obj *v3.Template) (runtime.Object, error)\n\tUpdated(obj *v3.Template) (runtime.Object, error)\n}\n\ntype templateLifecycleAdapter struct {\n\tlifecycle TemplateLifecycle\n}\n\nfunc (w *templateLifecycleAdapter) HasCreate() bool {\n\to, ok := w.lifecycle.(lifecycle.ObjectLifecycleCondition)\n\treturn !ok || o.HasCreate()\n}\n\nfunc (w *templateLifecycleAdapter) HasFinalize() bool {\n\to, ok := w.lifecycle.(lifecycle.ObjectLifecycleCondition)\n\treturn !ok || o.HasFinalize()\n}\n\nfunc (w *templateLifecycleAdapter) Create(obj runtime.Object) (runtime.Object, error) {\n\to, err := w.lifecycle.Create(obj.(*v3.Template))\n\tif o == nil {\n\t\treturn nil, err\n\t}\n\treturn o, err\n}\n\nfunc (w *templateLifecycleAdapter) Finalize(obj runtime.Object) (runtime.Object, error) {\n\to, err := w.lifecycle.Remove(obj.(*v3.Template))\n\tif o == nil {\n\t\treturn nil, err\n\t}\n\treturn o, err\n}\n\nfunc (w *templateLifecycleAdapter) Updated(obj runtime.Object) (runtime.Object, error) {\n\to, err := w.lifecycle.Updated(obj.(*v3.Template))\n\tif o == nil {\n\t\treturn nil, err\n\t}\n\treturn o, err\n}\n\n\n\nfunc NewTemplateLifecycleAdapter(name string, clusterScoped bool, client TemplateInterface, l TemplateLifecycle) TemplateHandlerFunc ", "output": "{\n\tif clusterScoped {\n\t\tresource.PutClusterScoped(TemplateGroupVersionResource)\n\t}\n\tadapter := &templateLifecycleAdapter{lifecycle: l}\n\tsyncFn := lifecycle.NewObjectLifecycleAdapter(name, clusterScoped, adapter, client.ObjectClient())\n\treturn func(key string, obj *v3.Template) (runtime.Object, error) {\n\t\tnewObj, err := syncFn(key, obj)\n\t\tif o, ok := newObj.(runtime.Object); ok {\n\t\t\treturn o, err\n\t\t}\n\t\treturn nil, err\n\t}\n}"}
{"input": "package u32\n\nimport \"sort\"\n\n\ntype Count struct {\n\tNum uint32\n\tSum uint8\n}\n\n\ntype SetCount map[uint32]*Count\n\n\nfunc (m SetCount) Add(sets ...*Set) {\n\tfor _, set := range sets {\n\t\tfor k := range *set {\n\t\t\tif mv, ok := m[k]; ok {\n\t\t\t\tmv.Sum++\n\t\t\t} else {\n\t\t\t\tm[k] = &Count{Num: k, Sum: 1}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nfunc (m SetCount) Count(removeSets ...*Set) []Count ", "output": "{\n\tret := make([]Count, 0)\n\tset := NewSet()\n\tset.Union(removeSets...)\n\tfor _, v := range m {\n\t\tif !set.Has(v.Num) {\n\t\t\tret = append(ret, *v)\n\t\t}\n\t}\n\tsort.Slice(ret, func(i, j int) bool {\n\t\tif ret[i].Sum == ret[j].Sum {\n\t\t\treturn ret[i].Num < ret[j].Num\n\t\t}\n\t\treturn ret[j].Sum < ret[i].Sum\n\t})\n\treturn ret\n}"}
{"input": "package msgraph\n\nimport \"context\"\n\n\ntype WorkbookFunctionsVar_PRequestBuilder struct{ BaseRequestBuilder }\n\n\nfunc (b *WorkbookFunctionsRequestBuilder) Var_P(reqObj *WorkbookFunctionsVar_PRequestParameter) *WorkbookFunctionsVar_PRequestBuilder {\n\tbb := &WorkbookFunctionsVar_PRequestBuilder{BaseRequestBuilder: b.BaseRequestBuilder}\n\tbb.BaseRequestBuilder.baseURL += \"/var_P\"\n\tbb.BaseRequestBuilder.requestObject = reqObj\n\treturn bb\n}\n\n\ntype WorkbookFunctionsVar_PRequest struct{ BaseRequest }\n\n\nfunc (b *WorkbookFunctionsVar_PRequestBuilder) Request() *WorkbookFunctionsVar_PRequest {\n\treturn &WorkbookFunctionsVar_PRequest{\n\t\tBaseRequest: BaseRequest{baseURL: b.baseURL, client: b.client, requestObject: b.requestObject},\n\t}\n}\n\n\nfunc (r *WorkbookFunctionsVar_PRequest) Post(ctx context.Context) (resObj *WorkbookFunctionResult, err error) {\n\terr = r.JSONRequest(ctx, \"POST\", \"\", r.requestObject, &resObj)\n\treturn\n}\n\n\ntype WorkbookFunctionsVar_SRequestBuilder struct{ BaseRequestBuilder }\n\n\n\n\n\ntype WorkbookFunctionsVar_SRequest struct{ BaseRequest }\n\n\nfunc (b *WorkbookFunctionsVar_SRequestBuilder) Request() *WorkbookFunctionsVar_SRequest {\n\treturn &WorkbookFunctionsVar_SRequest{\n\t\tBaseRequest: BaseRequest{baseURL: b.baseURL, client: b.client, requestObject: b.requestObject},\n\t}\n}\n\n\nfunc (r *WorkbookFunctionsVar_SRequest) Post(ctx context.Context) (resObj *WorkbookFunctionResult, err error) {\n\terr = r.JSONRequest(ctx, \"POST\", \"\", r.requestObject, &resObj)\n\treturn\n}\n\nfunc (b *WorkbookFunctionsRequestBuilder) Var_S(reqObj *WorkbookFunctionsVar_SRequestParameter) *WorkbookFunctionsVar_SRequestBuilder ", "output": "{\n\tbb := &WorkbookFunctionsVar_SRequestBuilder{BaseRequestBuilder: b.BaseRequestBuilder}\n\tbb.BaseRequestBuilder.baseURL += \"/var_S\"\n\tbb.BaseRequestBuilder.requestObject = reqObj\n\treturn bb\n}"}
{"input": "package gopcapreader\n\n\n\ntype MaybeStreamHandler interface {\n\tMaybeHandleStream(stream *Stream) bool\n}\n\n\n\ntype MaybeStreamHandlerFunction func(stream *Stream) bool\n\n\nfunc (m MaybeStreamHandlerFunction) MaybeHandleStream(stream *Stream) bool {\n\treturn m(stream)\n}\n\n\n\n\ntype StreamHandlerSlice []MaybeStreamHandler\n\n\n\n\nfunc (set StreamHandlerSlice) HandleStream(stream *Stream) ", "output": "{\n\tfor _, handler := range set {\n\t\tif handler.MaybeHandleStream(stream) {\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"input": "package library\n\nimport (\n\t\"github.com/hyperledger/fabric/core/handlers/auth\"\n\t\"github.com/hyperledger/fabric/core/handlers/auth/filter\"\n\t\"github.com/hyperledger/fabric/core/handlers/decoration\"\n\t\"github.com/hyperledger/fabric/core/handlers/decoration/decorator\"\n\tendorsement \"github.com/hyperledger/fabric/core/handlers/endorsement/api\"\n\t\"github.com/hyperledger/fabric/core/handlers/endorsement/builtin\"\n\tvalidation \"github.com/hyperledger/fabric/core/handlers/validation/api\"\n\t. \"github.com/hyperledger/fabric/core/handlers/validation/builtin\"\n)\n\n\n\ntype HandlerLibrary struct {\n}\n\n\n\n\n\n\nfunc (r *HandlerLibrary) DefaultAuth() auth.Filter {\n\treturn filter.NewFilter()\n}\n\n\n\nfunc (r *HandlerLibrary) ExpirationCheck() auth.Filter {\n\treturn filter.NewExpirationCheckFilter()\n}\n\n\n\n\n\n\nfunc (r *HandlerLibrary) DefaultEndorsement() endorsement.PluginFactory {\n\treturn &builtin.DefaultEndorsementFactory{}\n}\n\nfunc (r *HandlerLibrary) DefaultValidation() validation.PluginFactory {\n\treturn &DefaultValidationFactory{}\n}\n\nfunc (r *HandlerLibrary) DefaultDecorator() decoration.Decorator ", "output": "{\n\treturn decorator.NewDecorator()\n}"}
{"input": "package sync2\n\nimport (\n\t\"sync\"\n)\n\n\nconst (\n\tSERVICE_STOPPED = iota\n\tSERVICE_RUNNING\n\tSERVICE_SHUTTING_DOWN\n)\n\nvar stateNames = []string{\n\t\"Stopped\",\n\t\"Running\",\n\t\"ShuttingDown\",\n}\n\n\n\n\n\n\n\ntype ServiceManager struct {\n\tmu    sync.Mutex\n\twg    sync.WaitGroup\n\terr   error \n\tstate AtomicInt64\n\tshutdown chan struct{}\n}\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (svm *ServiceManager) Go(service func(svc *ServiceContext) error) bool {\n\tsvm.mu.Lock()\n\tdefer svm.mu.Unlock()\n\tif !svm.state.CompareAndSwap(SERVICE_STOPPED, SERVICE_RUNNING) {\n\t\treturn false\n\t}\n\tsvm.wg.Add(1)\n\tsvm.err = nil\n\tsvm.shutdown = make(chan struct{})\n\tgo func(shutdown chan struct{}) {\n\t\tsvm.err = service(&ServiceContext{ShuttingDown: shutdown})\n\t\tsvm.state.Set(SERVICE_STOPPED)\n\t\tsvm.wg.Done()\n\t}(svm.shutdown)\n\treturn true\n}\n\n\n\n\n\n\n\n\n\nfunc (svm *ServiceManager) Join() error {\n\tsvm.wg.Wait()\n\treturn svm.err\n}\n\n\n\nfunc (svm *ServiceManager) State() int64 {\n\treturn svm.state.Get()\n}\n\n\nfunc (svm *ServiceManager) StateName() string {\n\treturn stateNames[svm.State()]\n}\n\n\n\n\ntype ServiceContext struct {\n\tShuttingDown chan struct{}\n}\n\n\n\nfunc (svc *ServiceContext) IsRunning() bool {\n\tselect {\n\tcase <-svc.ShuttingDown:\n\t\treturn false\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc (svm *ServiceManager) Stop() bool ", "output": "{\n\tsvm.mu.Lock()\n\tdefer svm.mu.Unlock()\n\tif !svm.state.CompareAndSwap(SERVICE_RUNNING, SERVICE_SHUTTING_DOWN) {\n\t\treturn false\n\t}\n\tclose(svm.shutdown)\n\tsvm.shutdown = nil\n\tsvm.wg.Wait()\n\treturn true\n}"}
{"input": "package client\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest/adal\"\n\t\"github.com/Azure/go-autorest/autorest/azure\"\n)\n\n\ntype msiOAuthTokenProvider struct {\n\tenv azure.Environment\n}\n\n\n\nfunc (tp *msiOAuthTokenProvider) getServicePrincipalToken() (*adal.ServicePrincipalToken, error) {\n\treturn tp.getServicePrincipalTokenWithResource(tp.env.ResourceManagerEndpoint)\n}\n\nfunc (tp *msiOAuthTokenProvider) getServicePrincipalTokenWithResource(resource string) (*adal.ServicePrincipalToken, error) {\n\treturn adal.NewServicePrincipalTokenFromMSI(\"http://169.254.169.254/metadata/identity/oauth2/token\", resource)\n}\n\nfunc NewMSIOAuthTokenProvider(env azure.Environment) oAuthTokenProvider ", "output": "{\n\treturn &msiOAuthTokenProvider{env}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\n\t\"github.com/docker/docker/pkg/signal\"\n\t\"github.com/docker/docker/pkg/system\"\n\t\"github.com/sirupsen/logrus\"\n)\n\n\n\n\nfunc setupDumpStackTrap() ", "output": "{\n\tgo func() {\n\t\tsa := syscall.SecurityAttributes{\n\t\t\tLength: 0,\n\t\t}\n\t\tev := \"Global\\\\docker-daemon-\" + fmt.Sprint(os.Getpid())\n\t\tif h, _ := system.CreateEvent(&sa, false, false, ev); h != 0 {\n\t\t\tlogrus.Debugf(\"Stackdump - waiting signal at %s\", ev)\n\t\t\tfor {\n\t\t\t\tsyscall.WaitForSingleObject(h, syscall.INFINITE)\n\t\t\t\tsignal.DumpStacks(\"\")\n\t\t\t}\n\t\t}\n\t}()\n}"}
{"input": "package gofaker\n\nimport \"fmt\"\n\nfunc ExampleCat_Name() {\n\tf, _ := NewFaker(\"en\")\n\tf.Reset()\n\tfmt.Println(f.Cat.Name())\n}\n\nfunc ExampleCat_Breed() {\n\tf, _ := NewFaker(\"en\")\n\tf.Reset()\n\tfmt.Println(f.Cat.Breed())\n}\n\n\n\nfunc ExampleCat_Registry() ", "output": "{\n\tf, _ := NewFaker(\"en\")\n\tf.Reset()\n\tfmt.Println(f.Cat.Registry())\n}"}
{"input": "package labassistant\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc good_func(i int) int {\n\treturn i\n}\n\nfunc panic_func(i int) int {\n\tpanic(\"panic\")\n}\n\nfunc bad_func(i int) int {\n\treturn i + 1\n}\n\nfunc TestObservationRunIsOK(t *testing.T) {\n\ta := assert.New(t)\n\tout := make_ob().run(good_func, 1)\n\ta.Equal([]interface{}{1}, out)\n\n\tout = make_ob().run(good_func, 0)\n\ta.NotEqual([]interface{}{1}, out)\n\n\ta.Panics(func() {\n\t\tmake_ob().run(good_func)\n\t})\n\n\ta.Panics(func() {\n\t\tmake_ob().run(good_func, 1, 1)\n\t})\n\n\ta.Panics(func() {\n\t\tmake_ob().run(good_func, \"string\")\n\t})\n}\n\nfunc TestObservationRunSetsValues(t *testing.T) {\n\ta := assert.New(t)\n\tgood := make_ob()\n\tgood.run(good_func, 1)\n\ta.Equal(\"github.com/lmas/labassistant.good_func\", good.Name)\n\ta.Empty(good.Panic)\n\ta.Equal([]interface{}{1}, good.Outputs)\n\ta.NotEmpty(good.Start)\n\ta.NotZero(good.Duration)\n\n\tbad := make_ob()\n\tbad.can_panic = true\n\ta.NotPanics(func() {\n\t\tbad.run(panic_func, 1)\n\t})\n\ta.Equal(\"panic\", bad.Panic)\n\ta.Empty(bad.Outputs)\n\ta.NotEmpty(bad.Start)\n\ta.Zero(bad.Duration)\n}\n\nfunc make_ob() *Observation ", "output": "{\n\treturn &Observation{}\n}"}
{"input": "\n\nfunc maxProfit(prices []int) int ", "output": "{\n    n := len(prices)\n    if n < 2 {\n        return 0\n    }\n    \n    maxProfit := 0\n    minBuyPrice := prices[0]\n    for i := 1; i < n; i++ {\n        if prices[i] - minBuyPrice > maxProfit {\n            maxProfit = prices[i] - minBuyPrice\n        }\n        if prices[i] < minBuyPrice {\n            minBuyPrice = prices[i]\n        }\n    }\n    \n    return maxProfit\n}"}
{"input": "package http\n\nimport (\n\t\"fmt\"\n\t\"github.com/denniscollective/dragonfly.go/dragonfly\"\n\t\"github.com/gorilla/handlers\"\n\t\"github.com/gorilla/mux\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\n\n\ntype benchmarkHandler struct {\n\thandler http.Handler\n}\n\nfunc (h benchmarkHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tt := time.Now()\n\th.handler.ServeHTTP(w, req)\n\tfmt.Println(time.Now().Sub(t))\n}\n\nfunc handle(h http.Handler) http.Handler {\n\n\treturn benchmarkHandler{handlers.CombinedLoggingHandler(os.Stdout, h)}\n\n}\n\nfunc hollar(response http.ResponseWriter, r *http.Request) {\n\tfmt.Println(\"hollar\")\n}\n\nfunc serveFile(response http.ResponseWriter, request *http.Request) {\n\tresponse.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\n\tvars := mux.Vars(request)\n\tjobStr := vars[\"b64JobString\"]\n\tfile, err := dragonfly.ImageFor(jobStr)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\tdata, _ := ioutil.ReadAll(file)\n\tresponse.Write(data)\n}\n\nfunc StartServer() error ", "output": "{\n\tr := mux.NewRouter()\n\tr.HandleFunc(\"/favicon.ico\", hollar)\n\tr.HandleFunc(\"/{b64JobString}\", serveFile)\n\n\terr := http.ListenAndServe(\":2345\", handle(r))\n\treturn err\n}"}
{"input": "package main\n\ntype Fasta interface {\n\tSetId(string)\n\tGetId() string\n\n\tSetDescription(string)\n\tGetDescription() string\n\n\tSetSequence(string)\n\tGetSequence() string\n}\n\ntype FastaImp struct {\n\tid          string\n\tdescription string\n\tsequence    string\n}\n\nfunc (fa *FastaImp) SetId(id string) {\n\tfa.id = id\n}\n\nfunc (fa *FastaImp) GetId() string {\n\treturn fa.id\n}\n\nfunc (fa *FastaImp) SetDescription(description string) {\n\tfa.description = description\n}\n\nfunc (fa *FastaImp) GetDescription() string {\n\treturn fa.description\n}\n\nfunc (fa *FastaImp) SetSequence(sequence string) {\n\tfa.sequence = sequence\n}\n\n\n\nfunc (fa *FastaImp) GetSequence() string ", "output": "{\n\treturn fa.sequence\n}"}
{"input": "package assert\n\nimport (\n\t\"testing\"\n)\n\nfunc IntEquals(t *testing.T, actual int, expected int) {\n\tif actual != expected {\n\t\tt.Fatalf(\"%#v != %#v\", actual, expected)\n\t}\n}\n\nfunc Float32Equals(t *testing.T, actual float32, expected float32) {\n\tif actual != expected {\n\t\tt.Fatalf(\"%#v != %#v\", actual, expected)\n\t}\n}\n\nfunc StringEquals(t *testing.T, actual string, expected string) {\n\tif actual != expected {\n\t\tt.Fatalf(\"%#v != %#v\", actual, expected)\n\t}\n}\n\n\n\nfunc IntListListEquals(t *testing.T, actualList [][]int, expectedList [][]int) {\n\tif len(actualList) != len(expectedList) {\n\t\tt.Fatalf(\"%#v != %#v\", actualList, expectedList)\n\t}\n\tfor i, expected := range expectedList {\n\t\tIntListEquals(t, actualList[i], expected)\n\t}\n}\n\nfunc IntListEquals(t *testing.T, actualList []int, expectedList []int) ", "output": "{\n\tIntEquals(t, len(actualList), len(expectedList))\n\tfor i, expected := range expectedList {\n\t\tIntEquals(t, actualList[i], expected)\n\t}\n}"}
{"input": "package gopnsconfig\n\nimport (\n\t\"log\"\n)\n\ntype BaseConfigStruct struct {\n\tPortValue          string\n\tMetricsServerValue string\n\tMetricsAPIKeyValue string\n\tMetricsPrefixValue string\n}\n\n\n\nfunc (this *BaseConfigStruct) MetricsAPIKey() string {\n\treturn this.MetricsAPIKeyValue\n}\n\nfunc (this *BaseConfigStruct) MetricsServer() string {\n\treturn this.MetricsServerValue\n}\n\nfunc (this *BaseConfigStruct) MetricsPrefix() string {\n\treturn this.MetricsPrefixValue\n}\n\ntype BaseConfig interface {\n\tPort() string\n\tMetricsServer() string\n\tMetricsAPIKey() string\n\tMetricsPrefix() string\n}\n\nfunc parseBaseConfig(baseConfig *ConfigFile) BaseConfig {\n\tport, err := baseConfig.GetString(\"default\", \"port\")\n\tcheckError(\"Unable to find Server Port\", err)\n\n\tmetricsServer, err := baseConfig.GetString(\"default\", \"metrics-server\")\n\tcheckError(\"Unable to find metrics server\", err)\n\n\tmetricsKey, err := baseConfig.GetString(\"default\", \"metrics-api-key\")\n\tif err != nil {\n\t\tlog.Println(\"Unable to find metrics-api-key using empty string\")\n\t\tmetricsKey = \"\"\n\t}\n\n\tmetricsPrefix, err := baseConfig.GetString(\"default\", \"metrics-prefix\")\n\tif err != nil {\n\t\tlog.Println(\"Unable to find metrics prefix using empty string\")\n\t\tmetricsPrefix = \"\"\n\t}\n\n\tbaseConfigInstance := &BaseConfigStruct{port, metricsServer, metricsKey, metricsPrefix}\n\treturn baseConfigInstance\n\n}\n\nfunc (this *BaseConfigStruct) Port() string ", "output": "{\n\treturn this.PortValue\n}"}
{"input": "package common\n\nimport (\n\t\"bytes\"\n\t\"io\"\n)\n\nfunc StreamToByte(stream io.Reader) []byte {\n\tbuf := new(bytes.Buffer)\n\tbuf.ReadFrom(stream)\n\treturn buf.Bytes()\n}\n\n\n\nfunc StreamToString(stream io.Reader) string ", "output": "{\n\tbuf := new(bytes.Buffer)\n\tbuf.ReadFrom(stream)\n\treturn buf.String()\n}"}
{"input": "package mutate\n\nimport \"github.com/sigstore/cosign/pkg/oci\"\n\n\ntype DupeDetector interface {\n\tFind(oci.Signatures, oci.Signature) (oci.Signature, error)\n}\n\ntype ReplaceOp interface {\n\tReplace(oci.Signatures, oci.Signature) (oci.Signatures, error)\n}\n\ntype SignOption func(*signOpts)\n\ntype signOpts struct {\n\tdd DupeDetector\n\tro ReplaceOp\n}\n\nfunc makeSignOpts(opts ...SignOption) *signOpts {\n\tso := &signOpts{}\n\tfor _, opt := range opts {\n\t\topt(so)\n\t}\n\treturn so\n}\n\n\n\nfunc WithDupeDetector(dd DupeDetector) SignOption {\n\treturn func(so *signOpts) {\n\t\tso.dd = dd\n\t}\n}\n\n\n\nfunc WithReplaceOp(ro ReplaceOp) SignOption ", "output": "{\n\treturn func(so *signOpts) {\n\t\tso.ro = ro\n\t}\n}"}
{"input": "package poet\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\ntype MethodSuite struct{}\n\nvar _ = Suite(&MethodSuite{})\n\n\n\nfunc (s *TemplateSuite) TestMethodWithStatement(c *C) {\n\texpected := \"\" +\n\t\t\"func (b *bytes.Buffer) foo() {\\n\" +\n\t\t\"\\tfmt.Println()\\n\" +\n\t\t\"}\\n\"\n\n\tm := NewMethodSpec(\"foo\", \"b\", TypeReferenceFromInstance(&bytes.Buffer{}))\n\tm.Statement(\"$T()\", TypeReferenceFromInstance(fmt.Println))\n\n\tactual := m.String()\n\tc.Assert(actual, Equals, expected)\n}\n\nfunc (s *TemplateSuite) TestMethodValueReceiver(c *C) {\n\texpected := \"\" +\n\t\t\"func (b bytes.Buffer) foo() {\\n\" +\n\t\t\"}\\n\"\n\n\tm := NewMethodSpec(\"foo\", \"b\", TypeReferenceFromInstance(bytes.Buffer{}))\n\n\tactual := m.String()\n\tc.Assert(actual, Equals, expected)\n}\n\nfunc (s *TemplateSuite) TestMethod(c *C) ", "output": "{\n\texpected := \"\" +\n\t\t\"func (b *bytes.Buffer) foo() {\\n\" +\n\t\t\"}\\n\"\n\n\tm := NewMethodSpec(\"foo\", \"b\", TypeReferenceFromInstance(&bytes.Buffer{}))\n\n\tactual := m.String()\n\tc.Assert(actual, Equals, expected)\n}"}
{"input": "package api\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/aws/aws-sdk-go/private/protocol\"\n)\n\ntype examplesBuilder interface {\n\tBuildShape(*ShapeRef, map[string]interface{}, bool) string\n\tBuildList(string, string, *ShapeRef, []interface{}) string\n\tBuildComplex(string, string, *ShapeRef, *Shape, map[string]interface{}) string\n\tGoType(*ShapeRef, bool) string\n\tImports(*API) string\n}\n\ntype defaultExamplesBuilder struct {\n\tShapeValueBuilder\n}\n\n\n\nfunc NewExamplesBuilder() defaultExamplesBuilder {\n\tb := defaultExamplesBuilder{\n\t\tShapeValueBuilder: NewShapeValueBuilder(),\n\t}\n\tb.ParseTimeString = parseExampleTimeString\n\treturn b\n}\n\nfunc (builder defaultExamplesBuilder) Imports(a *API) string {\n\treturn `\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"` + SDKImportRoot + `/aws\"\n\t\"` + SDKImportRoot + `/aws/awserr\"\n\t\"` + SDKImportRoot + `/aws/session\"\n\t\"` + a.ImportPath() + `\"\n\t`\n}\n\n\n\n\n\nfunc parseExampleTimeString(ref *ShapeRef, memName, v string) string ", "output": "{\n\tif ref.Location == \"header\" {\n\t\treturn fmt.Sprintf(\"%s: parseTime(%q, %q),\\n\", memName, protocol.RFC822TimeFormat, v)\n\t}\n\n\tswitch ref.API.Metadata.Protocol {\n\tcase \"json\", \"rest-json\", \"rest-xml\", \"ec2\", \"query\":\n\t\treturn fmt.Sprintf(\"%s: parseTime(%q, %q),\\n\", memName, protocol.ISO8601TimeFormat, v)\n\tdefault:\n\t\tpanic(\"Unsupported time type: \" + ref.API.Metadata.Protocol)\n\t}\n}"}
{"input": "package ui\n\nimport (\n\t\"github.com/Bredgren/geo\"\n\t\"github.com/hajimehoshi/ebiten\"\n)\n\n\n\n\ntype VerticalContainer struct {\n\tElements []WeightedDrawer\n\tWt       float64\n}\n\n\nfunc (v *VerticalContainer) Draw(dst *ebiten.Image, bounds geo.Rect) {\n\ttotalWeight := 0.0\n\tfor _, e := range v.Elements {\n\t\ttotalWeight += e.Weight()\n\t}\n\theights := make([]float64, len(v.Elements))\n\tfor i, e := range v.Elements {\n\t\theights[i] = e.Weight() / totalWeight * bounds.H\n\t}\n\tsubBounds := bounds\n\tfor i, h := range heights {\n\t\tsubBounds.H = h\n\t\tv.Elements[i].Draw(dst, subBounds)\n\t\tsubBounds.Y += h\n\t}\n}\n\n\nfunc (v *VerticalContainer) Weight() float64 {\n\treturn v.Wt\n}\n\n\n\n\ntype HorizontalContainer struct {\n\tElements []WeightedDrawer\n\tWt       float64\n}\n\n\n\n\n\nfunc (h *HorizontalContainer) Weight() float64 {\n\treturn h.Wt\n}\n\nfunc (h *HorizontalContainer) Draw(dst *ebiten.Image, bounds geo.Rect) ", "output": "{\n\ttotalWeight := 0.0\n\tfor _, e := range h.Elements {\n\t\ttotalWeight += e.Weight()\n\t}\n\twidths := make([]float64, len(h.Elements))\n\tfor i, e := range h.Elements {\n\t\twidths[i] = e.Weight() / totalWeight * bounds.W\n\t}\n\tsubBounds := bounds\n\tfor i, w := range widths {\n\t\tsubBounds.W = w\n\t\th.Elements[i].Draw(dst, subBounds)\n\t\tsubBounds.X += w\n\t}\n}"}
{"input": "package telemetry\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\n\t\"github.com/pingcap/errors\"\n\tclientv3 \"go.etcd.io/etcd/client/v3\"\n)\n\nconst (\n\tstatusKey = \"/tidb/telemetry/status\"\n)\n\ntype status struct {\n\tCheckAt       string `json:\"check_at\"`\n\tIsError       bool   `json:\"is_error\"`\n\tErrorMessage  string `json:\"error_msg\"`\n\tIsRequestSent bool   `json:\"is_request_sent\"`\n}\n\n\nfunc updateTelemetryStatus(s status, etcdClient *clientv3.Client) error {\n\tif etcdClient == nil {\n\t\treturn nil\n\t}\n\tj, err := json.MarshalIndent(s, \"\", \"  \")\n\tif err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), etcdOpTimeout)\n\tdefer cancel()\n\t_, err = etcdClient.Put(ctx, statusKey, string(j))\n\tif err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\treturn nil\n}\n\n\n\n\nfunc GetTelemetryStatus(etcdClient *clientv3.Client) (string, error) ", "output": "{\n\tif etcdClient == nil {\n\t\treturn \"\", nil\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), etcdOpTimeout)\n\tdefer cancel()\n\tresp, err := etcdClient.Get(ctx, statusKey)\n\tif err != nil {\n\t\treturn \"\", errors.Trace(err)\n\t}\n\tif len(resp.Kvs) == 0 {\n\t\treturn \"\", nil\n\t}\n\treturn string(resp.Kvs[0].Value), nil\n}"}
{"input": "package swagger\n\n\n\n\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n)\n\n\ntype NamedModelProperty struct {\n\tName     string\n\tProperty ModelProperty\n}\n\n\ntype ModelPropertyList struct {\n\tList []NamedModelProperty\n}\n\n\nfunc (l *ModelPropertyList) At(name string) (p ModelProperty, ok bool) {\n\tfor _, each := range l.List {\n\t\tif each.Name == name {\n\t\t\treturn each.Property, true\n\t\t}\n\t}\n\treturn p, false\n}\n\n\nfunc (l *ModelPropertyList) Put(name string, prop ModelProperty) {\n\tfor i, each := range l.List {\n\t\tif each.Name == name {\n\t\t\tl.List[i] = NamedModelProperty{Name: name, Property: prop}\n\t\t\treturn\n\t\t}\n\t}\n\tl.List = append(l.List, NamedModelProperty{Name: name, Property: prop})\n}\n\n\nfunc (l *ModelPropertyList) Do(block func(name string, value ModelProperty)) {\n\tfor _, each := range l.List {\n\t\tblock(each.Name, each.Property)\n\t}\n}\n\n\n\n\n\nfunc (l *ModelPropertyList) UnmarshalJSON(data []byte) error {\n\traw := map[string]interface{}{}\n\tjson.NewDecoder(bytes.NewReader(data)).Decode(&raw)\n\tfor k, v := range raw {\n\t\tdata, err := json.Marshal(v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar m ModelProperty\n\t\tjson.NewDecoder(bytes.NewReader(data)).Decode(&m)\n\t\tl.Put(k, m)\n\t}\n\treturn nil\n}\n\nfunc (l ModelPropertyList) MarshalJSON() ([]byte, error) ", "output": "{\n\tvar buf bytes.Buffer\n\tencoder := json.NewEncoder(&buf)\n\tbuf.WriteString(\"{\\n\")\n\tfor i, each := range l.List {\n\t\tbuf.WriteString(\"\\\"\")\n\t\tbuf.WriteString(each.Name)\n\t\tbuf.WriteString(\"\\\": \")\n\t\tencoder.Encode(each.Property)\n\t\tif i < len(l.List)-1 {\n\t\t\tbuf.WriteString(\",\\n\")\n\t\t}\n\t}\n\tbuf.WriteString(\"}\")\n\treturn buf.Bytes(), nil\n}"}
{"input": "package utils\n\ntype Color [3]float64\n\n\n\nfunc (c Color) ToRGB() (uint8, uint8, uint8) {\n\tc[0] = between01(c[0])\n\tc[1] = between01(c[1])\n\tc[2] = between01(c[2])\n\treturn uint8(c[0] * 255), uint8(c[1] * 255), uint8(c[2] * 255)\n}\n\nfunc (c *Color) Multiply(mult float64) {\n\t*c = ColorFloatMulti(*c, mult)\n}\n\nfunc (c *Color) Devide(divider float64) {\n\t*c = ColorFloatDevide(*c, divider)\n}\n\nfunc ColorAddition(left, right Color) Color {\n\treturn Color{left[0] + right[0], left[1] + right[1], left[2] + right[2]}\n}\n\nfunc ColorMultiplication(left, right Color) Color {\n\treturn Color{left[0] * right[0], left[1] * right[1], left[2] * right[2]}\n}\n\nfunc ColorFloatMulti(c Color, mult float64) Color {\n\treturn Color{c[0] * mult, c[1] * mult, c[2] * mult}\n}\n\nfunc ColorFloatDevide(c Color, divider float64) Color {\n\treturn Color{c[0] / divider, c[1] / divider, c[2] / divider}\n}\n\nfunc between01(Color float64) float64 {\n\tif Color < 0 {\n\t\tColor = 0\n\t}\n\tif Color > 1 {\n\t\tColor = 1\n\t}\n\treturn Color\n}\n\nfunc NewColor(r, g, b uint8) Color ", "output": "{\n\treturn Color{float64(r) / 255, float64(g) / 255, float64(b) / 255}\n}"}
{"input": "package playground \n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\nconst baseURL = \"https://play.golang.org\"\n\nfunc init() {\n\thttp.HandleFunc(\"/compile\", bounce)\n\thttp.HandleFunc(\"/share\", bounce)\n}\n\nfunc bounce(w http.ResponseWriter, r *http.Request) {\n\tb := new(bytes.Buffer)\n\tif err := passThru(b, r); err != nil {\n\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\treport(r, err)\n\t\treturn\n\t}\n\tio.Copy(w, b)\n}\n\n\n\nvar onAppengine = false \n\nfunc allowShare(r *http.Request) bool {\n\tif !onAppengine {\n\t\treturn true\n\t}\n\tswitch r.Header.Get(\"X-AppEngine-Country\") {\n\tcase \"\", \"ZZ\", \"CN\":\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc passThru(w io.Writer, req *http.Request) error ", "output": "{\n\tif req.URL.Path == \"/share\" && !allowShare(req) {\n\t\treturn errors.New(\"Forbidden\")\n\t}\n\tdefer req.Body.Close()\n\turl := baseURL + req.URL.Path\n\tctx, cancel := context.WithTimeout(contextFunc(req), 60*time.Second)\n\tdefer cancel()\n\tr, err := post(ctx, url, req.Header.Get(\"Content-type\"), req.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"making POST request: %v\", err)\n\t}\n\tdefer r.Body.Close()\n\tif _, err := io.Copy(w, r.Body); err != nil {\n\t\treturn fmt.Errorf(\"copying response Body: %v\", err)\n\t}\n\treturn nil\n}"}
{"input": "package redistest\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/zhgo/redis/redis\"\n)\n\ntype testConn struct {\n\tredis.Conn\n}\n\n\n\n\n\n\nfunc Dial() (redis.Conn, error) {\n\tc, err := redis.DialTimeout(\"tcp\", \":6379\", 0, 1*time.Second, 1*time.Second)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = c.Do(\"SELECT\", \"9\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tn, err := redis.Int(c.Do(\"DBSIZE\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif n != 0 {\n\t\treturn nil, errors.New(\"database #9 is not empty, test can not continue\")\n\t}\n\n\treturn testConn{c}, nil\n}\n\nfunc (t testConn) Close() error ", "output": "{\n\t_, err := t.Conn.Do(\"SELECT\", \"9\")\n\tif err != nil {\n\t\treturn nil\n\t}\n\t_, err = t.Conn.Do(\"FLUSHDB\")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn t.Conn.Close()\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"strings\"\n\n\t\"github.com/kr/pty\"\n\t\"github.com/urfave/cli\"\n)\n\n\n\nfunc bazelAction(c *cli.Context) error {\n\tpwd, err := os.Getwd()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tindex := strings.Index(pwd, \"go-common\")\n\tif index == -1 {\n\t\tfmt.Println(\"not in go-common\")\n\t\tos.Exit(1)\n\t}\n\tresult := strings.Split(pwd[index:], \"/\")\n\trunPath := strings.Join(result[1:], \"/\")\n\tif c.NArg() > 0 {\n\t\tparam := []string{}\n\t\tfor index := 0; index < c.NArg(); index++ {\n\t\t\tname := path.Join(runPath, path.Clean(c.Args().Get(index)))\n\t\t\tif name == \".\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif strings.HasSuffix(name, \"/...\") {\n\t\t\t\tparam = append(param, \"//\"+name)\n\t\t\t} else {\n\t\t\t\tparam = append(param, \"//\"+name+\"/...\")\n\t\t\t}\n\n\t\t}\n\t\trunbazel(param...)\n\t} else {\n\t\tif len(runPath) == 0 {\n\t\t\trunbazel(\"//app/...\", \"//library/...\", \"//vendor/...\")\n\t\t} else {\n\t\t\trunbazel(\"//\" + strings.Join(result[1:], \"/\") + \"/...\")\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc runbazel(param ...string) ", "output": "{\n\tcommand := append([]string{\"build\", \"--watchfs\"}, param...)\n\tfmt.Println(command)\n\tcmd := exec.Command(\"bazel\", command...)\n\tf, err := pty.Start(cmd)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tio.Copy(os.Stdout, f)\n}"}
{"input": "package symptom\n\nimport (\n\t\"github.com/mefellows/muxy/muxy\"\n\t\"log\"\n)\n\ntype MockSymptom struct {\n\tConfigureError error\n\tConfigureCount int\n\tMuckCount      int\n\tTeardownCount  int\n\tSetupCount     int\n}\n\nfunc (m MockSymptom) Setup() {\n\tlog.Println(\"Mock Setup()\")\n\tm.SetupCount = m.SetupCount + 1\n}\n\nfunc (m MockSymptom) HandleEvent(e muxy.ProxyEvent, ctx *muxy.Context) {\n\tlog.Println(\"Mock HandleEvent()\")\n}\n\nfunc (m MockSymptom) Muck() {\n\tlog.Println(\"Mock Muck()\")\n\tm.MuckCount = m.MuckCount + 1\n}\n\n\n\nfunc (m MockSymptom) Teardown() ", "output": "{\n\tlog.Println(\"Mock Teardown()\")\n\tm.TeardownCount = m.TeardownCount + 1\n}"}
{"input": "package storagebackend\n\nimport (\n\t\"time\"\n\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apiserver/pkg/storage/value\"\n)\n\nconst (\n\tStorageTypeUnset = \"\"\n\tStorageTypeETCD2 = \"etcd2\"\n\tStorageTypeETCD3 = \"etcd3\"\n\n\tDefaultCompactInterval = 5 * time.Minute\n)\n\n\ntype Config struct {\n\tType string\n\tPrefix string\n\tServerList []string\n\tKeyFile  string\n\tCertFile string\n\tCAFile   string\n\tQuorum bool\n\tPaging bool\n\tDeserializationCacheSize int\n\n\tCodec runtime.Codec\n\tTransformer value.Transformer\n\n\tCompactionInterval time.Duration\n}\n\n\n\nfunc NewDefaultConfig(prefix string, codec runtime.Codec) *Config ", "output": "{\n\treturn &Config{\n\t\tPrefix: prefix,\n\t\tDeserializationCacheSize: 0,\n\t\tCodec:              codec,\n\t\tCompactionInterval: DefaultCompactInterval,\n\t\tQuorum:             true,\n\t}\n}"}
{"input": "package coreconfig\n\nimport (\n\t\"encoding/json\"\n\n\t\"code.cloudfoundry.org/cli/cf/models\"\n)\n\ntype AuthPromptType string\n\nconst (\n\tAuthPromptTypeText     AuthPromptType = \"TEXT\"\n\tAuthPromptTypePassword AuthPromptType = \"PASSWORD\"\n)\n\ntype AuthPrompt struct {\n\tType        AuthPromptType\n\tDisplayName string\n}\n\ntype Data struct {\n\tConfigVersion            int\n\tTarget                   string\n\tAPIVersion               string\n\tAuthorizationEndpoint    string\n\tLoggregatorEndPoint      string\n\tDopplerEndPoint          string\n\tUaaEndpoint              string\n\tRoutingAPIEndpoint       string\n\tAccessToken              string\n\tSSHOAuthClient           string\n\tRefreshToken             string\n\tOrganizationFields       models.OrganizationFields\n\tSpaceFields              models.SpaceFields\n\tSSLDisabled              bool\n\tAsyncTimeout             uint\n\tTrace                    string\n\tColorEnabled             string\n\tLocale                   string\n\tPluginRepos              []models.PluginRepo\n\tMinCLIVersion            string\n\tMinRecommendedCLIVersion string\n}\n\n\n\nfunc (d *Data) JSONMarshalV3() ([]byte, error) {\n\td.ConfigVersion = 3\n\treturn json.MarshalIndent(d, \"\", \"  \")\n}\n\nfunc (d *Data) JSONUnmarshalV3(input []byte) error {\n\terr := json.Unmarshal(input, d)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.ConfigVersion != 3 {\n\t\t*d = Data{}\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\nfunc NewData() *Data ", "output": "{\n\treturn new(Data)\n}"}
{"input": "package client\n\nimport (\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/watch\"\n\n\tsdnapi \"github.com/projectatomic/atomic-enterprise/pkg/sdn/api\"\n)\n\n\ntype HostSubnetsInterface interface {\n\tHostSubnets() HostSubnetInterface\n}\n\n\ntype HostSubnetInterface interface {\n\tList() (*sdnapi.HostSubnetList, error)\n\tGet(name string) (*sdnapi.HostSubnet, error)\n\tCreate(sub *sdnapi.HostSubnet) (*sdnapi.HostSubnet, error)\n\tDelete(name string) error\n\tWatch(resourceVersion string) (watch.Interface, error)\n}\n\n\ntype hostSubnet struct {\n\tr *Client\n}\n\n\nfunc newHostSubnet(c *Client) *hostSubnet {\n\treturn &hostSubnet{\n\t\tr: c,\n\t}\n}\n\n\nfunc (c *hostSubnet) List() (result *sdnapi.HostSubnetList, err error) {\n\tresult = &sdnapi.HostSubnetList{}\n\terr = c.r.Get().\n\t\tResource(\"hostSubnets\").\n\t\tDo().\n\t\tInto(result)\n\treturn\n}\n\n\nfunc (c *hostSubnet) Get(hostName string) (result *sdnapi.HostSubnet, err error) {\n\tresult = &sdnapi.HostSubnet{}\n\terr = c.r.Get().Resource(\"hostSubnets\").Name(hostName).Do().Into(result)\n\treturn\n}\n\n\n\n\n\nfunc (c *hostSubnet) Delete(name string) error {\n\treturn c.r.Delete().Resource(\"hostSubnets\").Name(name).Do().Error()\n}\n\n\nfunc (c *hostSubnet) Watch(resourceVersion string) (watch.Interface, error) {\n\treturn c.r.Get().\n\t\tPrefix(\"watch\").\n\t\tResource(\"hostSubnets\").\n\t\tParam(\"resourceVersion\", resourceVersion).\n\t\tWatch()\n}\n\nfunc (c *hostSubnet) Create(hostSubnet *sdnapi.HostSubnet) (result *sdnapi.HostSubnet, err error) ", "output": "{\n\tresult = &sdnapi.HostSubnet{}\n\terr = c.r.Post().Resource(\"hostSubnets\").Body(hostSubnet).Do().Into(result)\n\treturn\n}"}
{"input": "package policy\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\n\nfunc TestValidChecks(t *testing.T) ", "output": "{\n\tallChecks := append(DefaultChecks(), ExperimentalChecks()...)\n\n\tassert.NoError(t, validateChecks(allChecks))\n\n\tallIDs := map[CheckID]bool{}\n\tfor _, check := range allChecks {\n\t\tallIDs[check.ID] = true\n\t}\n\tfor _, check := range allChecks {\n\t\tfor _, c := range check.Versions {\n\t\t\tfor _, override := range c.OverrideCheckIDs {\n\t\t\t\tassert.Contains(t, allIDs, override, \"check %s overrides non-existent check %s\", check.ID, override)\n\t\t\t}\n\t\t}\n\t}\n}"}
{"input": "package lnwire\n\nimport (\n\t\"github.com/roasbeef/btcd/btcec\"\n\t\"github.com/roasbeef/btcd/wire\"\n\n\t\"io\"\n)\n\n\n\n\n\n\n\n\n\n\n\ntype CloseComplete struct {\n\tChannelPoint *wire.OutPoint\n\n\tResponderCloseSig *btcec.Signature\n}\n\n\n\nfunc NewCloseComplete() *CloseComplete {\n\treturn &CloseComplete{}\n}\n\n\n\nvar _ Message = (*CloseComplete)(nil)\n\n\n\n\n\nfunc (c *CloseComplete) Decode(r io.Reader, pver uint32) error {\n\terr := readElements(r,\n\t\t&c.ChannelPoint,\n\t\t&c.ResponderCloseSig)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\n\n\nfunc (c *CloseComplete) Encode(w io.Writer, pver uint32) error {\n\terr := writeElements(w,\n\t\tc.ChannelPoint,\n\t\tc.ResponderCloseSig)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\n\n\nfunc (c *CloseComplete) Command() uint32 {\n\treturn CmdCloseComplete\n}\n\n\n\n\n\nfunc (c *CloseComplete) MaxPayloadLength(uint32) uint32 {\n\treturn 141\n}\n\n\n\n\n\n\n\nfunc (c *CloseComplete) Validate() error ", "output": "{\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype Statistics struct {\n\tfilesToScan  int\n\tfilesScanned int\n\tlinesScanned int\n\tmatchesFound int\n\tstartTime    time.Time\n\tmux          sync.Mutex\n}\n\nfunc NewStatistics() *Statistics {\n\treturn &Statistics{\n\t\tfilesScanned: 0,\n\t\tlinesScanned: 0,\n\t\tmatchesFound: 0,\n\t\tstartTime:    time.Now(),\n\t}\n}\n\nfunc (s *Statistics) IncrFilesToScan() {\n\ts.mux.Lock()\n\ts.filesToScan++\n\ts.mux.Unlock()\n}\n\nfunc (s *Statistics) IncrLineCount() {\n\ts.mux.Lock()\n\ts.linesScanned++\n\ts.mux.Unlock()\n}\n\nfunc (s *Statistics) IncrFileCount() {\n\ts.mux.Lock()\n\ts.filesScanned++\n\ts.mux.Unlock()\n}\n\nfunc (s *Statistics) IncrMatchCount() {\n\ts.mux.Lock()\n\ts.matchesFound++\n\ts.mux.Unlock()\n}\n\nfunc (s *Statistics) LineCount() int {\n\ts.mux.Lock()\n\tdefer s.mux.Unlock()\n\treturn s.linesScanned\n}\n\nfunc (s *Statistics) FilesToScanCount() int {\n\ts.mux.Lock()\n\tdefer s.mux.Unlock()\n\treturn s.filesToScan\n}\n\n\n\nfunc (s *Statistics) MatchCount() int {\n\ts.mux.Lock()\n\tdefer s.mux.Unlock()\n\treturn s.matchesFound\n}\n\nfunc (s *Statistics) ElapsedTime() time.Duration {\n\treturn time.Now().Sub(s.startTime)\n}\n\nfunc (s *Statistics) FileCount() int ", "output": "{\n\ts.mux.Lock()\n\tdefer s.mux.Unlock()\n\treturn s.filesScanned\n}"}
{"input": "package commands\n\nimport (\n\t\"code.cloudfoundry.org/routing-api\"\n\t\"code.cloudfoundry.org/routing-api/models\"\n)\n\n\n\nfunc UnRegister(client routing_api.Client, routes []models.Route) error ", "output": "{\n\treturn client.DeleteRoutes(routes)\n}"}
{"input": "package config\n\nimport (\n\t\"sync\"\n)\n\n\n\n\n\n\ntype delayedEnvironment struct {\n\tenv      Environment\n\tloading  sync.Mutex\n\tcallback func() Environment\n}\n\n\n\nfunc (e *delayedEnvironment) Get(key string) (string, bool) {\n\te.Load()\n\treturn e.env.Get(key)\n}\n\n\n\nfunc (e *delayedEnvironment) GetAll(key string) []string {\n\te.Load()\n\treturn e.env.GetAll(key)\n}\n\n\n\n\n\n\n\nfunc (e *delayedEnvironment) Int(key string, def int) int {\n\te.Load()\n\treturn e.env.Int(key, def)\n}\n\n\nfunc (e *delayedEnvironment) All() map[string][]string {\n\te.Load()\n\treturn e.env.All()\n}\n\n\n\n\n\n\n\n\nfunc (e *delayedEnvironment) Load() {\n\te.loading.Lock()\n\tdefer e.loading.Unlock()\n\n\tif e.env != nil {\n\t\treturn\n\t}\n\n\te.env = e.callback()\n}\n\nfunc (e *delayedEnvironment) Bool(key string, def bool) bool ", "output": "{\n\te.Load()\n\treturn e.env.Bool(key, def)\n}"}
{"input": "package build\n\nimport (\n\t\"os\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"testing\"\n)\n\n\n\nfunc TestGetShell(t *testing.T) {\n\tbuild := &Build{\n\t\tShell: map[string][]string{\n\t\t\truntime.GOOS: {\"foo\"},\n\t\t\t\"other\":      {\"bar\"},\n\t\t},\n\t}\n\tshell, err := build.GetShell()\n\tif err != nil {\n\t\tt.Fail()\n\t}\n\tAssert(shell, []string{\"foo\"}, t)\n}\n\nfunc TestNewBuild(t *testing.T) ", "output": "{\n\tbuildFile := `doc: Test build file\n\nproperties:\n    FOO: 'foo'\n\ntargets:\n\n    test:\n        doc: Test target\n        steps:\n        - test: 'This is a test'`\n\tWriteFile(\"/tmp\", \"build.yml\", buildFile)\n\tdefer os.Remove(\"/tmp/build.yml\")\n\tTaskMap = make(map[string]TaskDesc)\n\ttype testArgs struct {\n\t\tTest string\n\t}\n\tAddTask(TaskDesc{\n\t\tName: \"test\",\n\t\tFunc: testFunc,\n\t\tArgs: reflect.TypeOf(testArgs{}),\n\t\tHelp: `Task documentation.`,\n\t})\n\tbuild, err := NewBuild(\"/tmp/build.yml\", \"/tmp\", \"\", false)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing build file: %v\", err)\n\t}\n\tif build.Dir != \"/tmp\" {\n\t\tt.Errorf(\"Bad build dir: %s\", build.Dir)\n\t}\n}"}
{"input": "package pipelinerun\n\nimport (\n\t\"sort\"\n\n\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"\n)\n\n\n\ntype byNamespace []v1beta1.PipelineRun\n\nfunc (prs byNamespace) compareNamespace(ins, jns string) (lt, eq bool) {\n\tlt, eq = ins < jns, ins == jns\n\treturn lt, eq\n}\n\nfunc (prs byNamespace) Len() int      { return len(prs) }\nfunc (prs byNamespace) Swap(i, j int) { prs[i], prs[j] = prs[j], prs[i] }\nfunc (prs byNamespace) Less(i, j int) bool {\n\tvar lt, eq bool\n\tif lt, eq = prs.compareNamespace(prs[i].Namespace, prs[j].Namespace); eq {\n\t\tif prs[j].Status.StartTime == nil {\n\t\t\treturn false\n\t\t}\n\t\tif prs[i].Status.StartTime == nil {\n\t\t\treturn true\n\t\t}\n\t\treturn prs[j].Status.StartTime.Before(prs[i].Status.StartTime)\n\t}\n\treturn lt\n}\n\nfunc SortByNamespace(prs []v1beta1.PipelineRun) ", "output": "{\n\tsort.Sort(byNamespace(prs))\n}"}
{"input": "package hidraw\n\nimport (\n    \"os\"\n)\n\ntype Device struct {\n    file        *os.File\n}\n\nfunc Open(info DeviceInfo) (*Device, error) {\n    device := &Device{}\n\n    if file, err := os.OpenFile(info.DevNode, os.O_RDWR, 0); err != nil {\n        return nil, err\n    } else {\n        device.file = file\n    }\n\n    return device, nil\n}\n\nfunc (self *Device) String() string {\n    return self.file.Name()\n}\n\n\n\n\n\n\n\n\n\n\nfunc (self *Device) ReportDescriptor() ([]byte, error) {\n    return self.ioctlGetReportDescriptor()\n}\n\nfunc (self *Device) Read(buf []byte) (int, error) {\n    return self.file.Read(buf)\n}\n\nfunc (self *Device) Close() {\n    self.file.Close()\n}\n\nfunc (self *Device) DevInfo() (devInfo DevInfo, err error) ", "output": "{\n    return self.ioctlGetDevInfo()\n}"}
{"input": "package matchers\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/kellyp/lowprofile/Godeps/_workspace/src/github.com/onsi/gomega/format\"\n)\n\ntype BeAnExistingFileMatcher struct {\n\texpected interface{}\n}\n\n\n\nfunc (matcher *BeAnExistingFileMatcher) FailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, fmt.Sprintf(\"to exist\"))\n}\n\nfunc (matcher *BeAnExistingFileMatcher) NegatedFailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, fmt.Sprintf(\"not to exist\"))\n}\n\nfunc (matcher *BeAnExistingFileMatcher) Match(actual interface{}) (success bool, err error) ", "output": "{\n\tactualFilename, ok := actual.(string)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"BeAnExistingFileMatcher matcher expects a file path\")\n\t}\n\n\tif _, err = os.Stat(actualFilename); err != nil {\n\t\tswitch {\n\t\tcase os.IsNotExist(err):\n\t\t\treturn false, nil\n\t\tdefault:\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\treturn true, nil\n}"}
{"input": "package use_case_api\n\nimport (\n\tagraph \"github.com/midnight-vivian/go-data-structures/algorithms/graph\"\n\tdgraph \"github.com/midnight-vivian/go-data-structures/data-structures/graph\"\n\t\"github.com/midnight-vivian/go-data-structures/data-structures/stack\"\n)\n\n\n\ntype Path struct {\n\tmark   []bool\n\trecord []int\n\tsID    int\n}\n\nfunc NewPath(udg *dgraph.UdGraph, sID int) *Path {\n\tpath := &Path{\n\t\tmark:   make([]bool, udg.GetV()),\n\t\trecord: make([]int, udg.GetV()),\n\t\tsID:    sID,\n\t}\n\tagraph.UndirectedDfsRecursion(udg, sID, -1, path.processed, path.process)\n\treturn path\n}\n\nfunc (p *Path) HasPath(v int) bool {\n\treturn p.mark[v]\n}\n\nfunc (p *Path) Path(v int) *stack.StackLinkedList {\n\ts := stack.NewStackLinkedList()\n\tfor i := v; i != p.sID; i = p.record[i] {\n\t\ts.Push(i)\n\t}\n\ts.Push(p.sID)\n\treturn s\n}\n\nfunc (p *Path) processed(vertex int) bool {\n\treturn p.mark[vertex]\n}\n\n\n\nfunc (p *Path) process(vertex, pvertex int) ", "output": "{\n\tp.mark[vertex] = true\n\tp.record[vertex] = pvertex\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc pinger(c chan string) {\n\tfor i := 0; ; i++ {\n\t\tc <- \"ping\"\n\t}\n}\n\n\n\nfunc printer(c chan string) {\n\tfor {\n\t\tmsg := <-c\n\t\tfmt.Println(msg)\n\t\ttime.Sleep(time.Second * 1)\n\t}\n}\n\nfunc main() {\n\tvar c chan string = make(chan string)\n\n\tgo pinger(c)\n\tgo ponger(c)\n\tgo printer(c)\n\n\tvar input string\n\tfmt.Scanln(&input)\n}\n\nfunc ponger(c chan string) ", "output": "{\n\tfor i := 0; ; i++ {\n\t\tc <- \"pong\"\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"errors\"\n\t\"gopkg.in/yaml.v2\"\n\t\"strings\"\n)\n\ntype Circle struct {\n\tFilename string\n\tTest     struct{ Override []string }\n}\n\n\n\nfunc (c *Circle) runTests() error {\n\terr := errors.New(\"\")\n\n\tif !doesFileExist(c.filename()) {\n\t\ts := []string{c.filename(), \"file does not exist\"}\n\t\terr = errors.New(strings.Join(s, \" \"))\n\t\treturn err\n\t}\n\n\traw := readFile(c.filename())\n\n\terr = c.getCommandsFromYAML([]byte(raw))\n\n\tfor _, cmd := range c.Test.Override {\n\t\terr = executeCommands(cmd)\n\t}\n\n\treturn err\n}\n\nfunc (c *Circle) getCommandsFromYAML(raw []byte) error {\n\terr := yaml.Unmarshal(raw, &c)\n\treturn err\n}\n\nfunc (c *Circle) filename() string ", "output": "{\n\tif c.Filename == \"\" {\n\t\tc.Filename = \"circle.yml\"\n\t}\n\treturn c.Filename\n}"}
{"input": "package jimbot\n\n\n\nimport (\n\t\"log\"\n\t\"time\"\n)\n\n\ntype Reminder struct {\n\tnotifyTime time.Time\n\tevent      string\n}\n\n\nfunc NewReminder(notifyTime time.Time, event string) Reminder {\n\tvar reminder Reminder\n\treminder.notifyTime = notifyTime\n\treminder.event = event\n\tlog.Print(\"[+++] REMINDER \", notifyTime.UTC(), event)\n\treturn reminder\n}\n\n\n\n\nfunc Notifier(reminder Reminder) string ", "output": "{\n\tfor {\n\t\tif time.Now().UTC() == reminder.notifyTime.UTC() {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(1 * time.Minute)\n\t}\n\tnotification := reminder.event\n\treturn notification\n}"}
{"input": "package peco\n\nimport \"github.com/nsf/termbox-go\"\n\n\n\nfunc (t Termbox) PostInit() error ", "output": "{\n\ttermbox.SetInputMode(termbox.InputEsc | termbox.InputAlt)\n\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/token\"\n)\n\ntype decl struct {\n\tname       string\n\tsuggestion string\n\tpos        token.Position\n\tkind       ast.ObjKind\n\tfreq       int32\n}\n\nfunc (d decl) String() string {\n\treturn fmt.Sprintf(\"%s:#%d,%s,%s,%s\", d.pos.Filename, d.pos.Offset, d.kind.String(), d.name, d.suggestion)\n}\n\n\n\nfunc print(decls []decl) ", "output": "{\n\tfmt.Printf(\"#offset position in file, kind, identifier, suggested\\n\")\n\tfor _, s := range decls {\n\t\tcomment := \"\"\n\t\tif s.name == s.suggestion {\n\t\t\tcomment = \"#\"\n\t\t}\n\t\tfmt.Printf(\"%s %s\\n\", comment, s.String())\n\t}\n}"}
{"input": "package main\n\nconst currTab = \".meat-tab.visible \"\n\n\n\nfunc navigationFlow(r *runner) ", "output": "{\n\tmust(r.waitForVisible(\".user-menu\"))\n\n\tr.logf(\"navigating to dashboard\")\n\tmust(r.click(\"#sidebar a[href='itch://dashboard']\"))\n\n\tconst firstTitleSelector = currTab + \".gamedesc--title\"\n\n\tr.logf(\"sorting by title, A-Z\")\n\tmust(r.click(currTab + \".sortby--title--default\"))\n\tr.logf(\"ensuring the A-Z sorting is correct\")\n\tmust(r.waitUntilTextExists(firstTitleSelector, \"111 first\"))\n\n\tr.logf(\"sorting by title, Z-A\")\n\tmust(r.click(currTab + \".sortby--title--reverse\"))\n\tr.logf(\"ensuring the Z-A sorting is correct\")\n\tmust(r.waitUntilTextExists(firstTitleSelector, \"zzz last\"))\n}"}
{"input": "package egoscale\n\nimport \"fmt\"\n\n\nfunc (ListAntiAffinityGroups) Response() interface{} {\n\treturn new(ListAntiAffinityGroupsResponse)\n}\n\n\nfunc (ls *ListAntiAffinityGroups) ListRequest() (ListCommand, error) {\n\tif ls == nil {\n\t\treturn nil, fmt.Errorf(\"%T cannot be nil\", ls)\n\t}\n\treturn ls, nil\n}\n\n\nfunc (ls *ListAntiAffinityGroups) SetPage(page int) {\n\tls.Page = page\n}\n\n\n\n\n\nfunc (ListAntiAffinityGroups) Each(resp interface{}, callback IterateItemFunc) {\n\titems, ok := resp.(*ListAntiAffinityGroupsResponse)\n\tif !ok {\n\t\tcallback(nil, fmt.Errorf(\"wrong type, ListAntiAffinityGroupsResponse was expected, got %T\", resp))\n\t\treturn\n\t}\n\n\tfor i := range items.AntiAffinityGroup {\n\t\tif !callback(&items.AntiAffinityGroup[i], nil) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (ls *ListAntiAffinityGroups) SetPageSize(pageSize int) ", "output": "{\n\tls.PageSize = pageSize\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\n\t\"gopkg.in/yaml.v1\"\n)\n\nconst (\n\tCONFIG_SUBDIR            = \"mcmd\"\n\tDEFAULT_KNOWN_HOSTS_FILE = \"$HOME/.ssh/known_hosts\"\n)\n\ntype HostConfig struct {\n\tUser       string\n\tPrivatekey string\n\tHosts      []string\n}\n\nfunc loadConfig() HostConfig {\n\trawYaml := readHostfile()\n\tvar result HostConfig\n\terr := yaml.Unmarshal(rawYaml, &result)\n\tif err != nil {\n\t\terrLogger.Fatalln(\"Error parsing hostfile:\", err)\n\t}\n\treturn result\n}\n\n\n\nfunc getConfigLocationCandidates(configFileParam string) []string {\n\tconfigRoot, err := os.UserConfigDir()\n\tif err != nil {\n\t\terrLogger.Fatalf(\"no user config dir found\")\n\t}\n\tconfigDir := path.Join(configRoot, CONFIG_SUBDIR)\n\treturn []string{configFileParam,\n\t\tpath.Join(configDir, configFileParam+\".yml\"),\n\t\tpath.Join(configDir, configFileParam+\".yaml\")}\n}\n\nfunc exists(filename string) bool {\n\t_, err := os.Stat(filename)\n\treturn !os.IsNotExist(err)\n}\n\nfunc getContents(filename string) []byte {\n\tfileContents, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\terrLogger.Fatalln(err)\n\t}\n\treturn fileContents\n}\n\nfunc readHostfile() []byte ", "output": "{\n\tconfigFileParam := flag.Arg(0)\n\tfor _, file := range getConfigLocationCandidates(configFileParam) {\n\t\tif exists(file) {\n\t\t\treturn getContents(file)\n\t\t}\n\t}\n\terrLogger.Fatalf(\"hostfile %s not found\", configFileParam)\n\treturn nil\n}"}
{"input": "package policy\n\n\n\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/go-openapi/runtime\"\n\t\"github.com/go-openapi/strfmt\"\n\n\t\"github.com/cilium/cilium/api/v1/models\"\n)\n\n\ntype DeleteFqdnCacheReader struct {\n\tformats strfmt.Registry\n}\n\n\n\n\n\nfunc NewDeleteFqdnCacheOK() *DeleteFqdnCacheOK {\n\treturn &DeleteFqdnCacheOK{}\n}\n\n\ntype DeleteFqdnCacheOK struct {\n}\n\nfunc (o *DeleteFqdnCacheOK) Error() string {\n\treturn fmt.Sprintf(\"[DELETE /fqdn/cache][%d] deleteFqdnCacheOK \", 200)\n}\n\nfunc (o *DeleteFqdnCacheOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {\n\n\treturn nil\n}\n\n\nfunc NewDeleteFqdnCacheBadRequest() *DeleteFqdnCacheBadRequest {\n\treturn &DeleteFqdnCacheBadRequest{}\n}\n\n\ntype DeleteFqdnCacheBadRequest struct {\n\tPayload models.Error\n}\n\nfunc (o *DeleteFqdnCacheBadRequest) Error() string {\n\treturn fmt.Sprintf(\"[DELETE /fqdn/cache][%d] deleteFqdnCacheBadRequest  %+v\", 400, o.Payload)\n}\n\nfunc (o *DeleteFqdnCacheBadRequest) GetPayload() models.Error {\n\treturn o.Payload\n}\n\nfunc (o *DeleteFqdnCacheBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {\n\n\tif err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (o *DeleteFqdnCacheReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) ", "output": "{\n\tswitch response.Code() {\n\tcase 200:\n\t\tresult := NewDeleteFqdnCacheOK()\n\t\tif err := result.readResponse(response, consumer, o.formats); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn result, nil\n\tcase 400:\n\t\tresult := NewDeleteFqdnCacheBadRequest()\n\t\tif err := result.readResponse(response, consumer, o.formats); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, result\n\n\tdefault:\n\t\treturn nil, runtime.NewAPIError(\"response status code does not match any response statuses defined for this endpoint in the swagger spec\", response, response.Code())\n\t}\n}"}
{"input": "package runtime\n\nimport (\n\t\"unsafe\"\n)\n\n\n\n\nfunc sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer {\n\tv, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)\n\tif err != 0 {\n\t\treturn nil\n\t}\n\tmSysStatInc(sysStat, n)\n\treturn v\n}\n\nfunc sysUnused(v unsafe.Pointer, n uintptr) {\n\tmadvise(v, n, _MADV_FREE)\n}\n\nfunc sysUsed(v unsafe.Pointer, n uintptr) {\n}\n\n\n\n\nfunc sysFree(v unsafe.Pointer, n uintptr, sysStat *uint64) {\n\tmSysStatDec(sysStat, n)\n\tmunmap(v, n)\n}\n\nfunc sysFault(v unsafe.Pointer, n uintptr) {\n\tmmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE|_MAP_FIXED, -1, 0)\n}\n\n\n\nconst _sunosEAGAIN = 11\nconst _ENOMEM = 12\n\nfunc sysMap(v unsafe.Pointer, n uintptr, sysStat *uint64) {\n\tmSysStatInc(sysStat, n)\n\n\tp, err := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, -1, 0)\n\tif err == _ENOMEM || (GOOS == \"solaris\" && err == _sunosEAGAIN) {\n\t\tthrow(\"runtime: out of memory\")\n\t}\n\tif p != v || err != 0 {\n\t\tthrow(\"runtime: cannot map pages in arena address space\")\n\t}\n}\n\nfunc sysReserve(v unsafe.Pointer, n uintptr) unsafe.Pointer ", "output": "{\n\tp, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)\n\tif err != 0 {\n\t\treturn nil\n\t}\n\treturn p\n}"}
{"input": "package v1\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/sirupsen/logrus\"\n)\n\ntype staticAsset struct {\n\tasset  string\n\tlogger logrus.FieldLogger\n}\n\nvar _ http.Handler = staticAsset{}\n\nfunc NewStaticAsset(logger logrus.FieldLogger, asset string) http.Handler {\n\treturn staticAsset{\n\t\tasset:  asset,\n\t\tlogger: logger,\n\t}\n}\n\n\n\nfunc (h staticAsset) ServeHTTP(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tlogger := h.logger.WithFields(logrus.Fields{\n\t\t\"request.remote_addr\": r.RemoteAddr,\n\t\t\"request.method\":      r.Method,\n\t\t\"request.uri\":         r.RequestURI,\n\t})\n\n\tif r.Method != \"GET\" {\n\t\tw.WriteHeader(405)\n\t\tw.Write([]byte(\"method not allowed\"))\n\n\t\tlogger.WithField(\"response.status\", 405).Warn(\"method not allowed\")\n\n\t\treturn\n\t}\n\n\thttp.ServeFile(w, r, h.asset)\n\n\tlogger.WithField(\"response.status\", 200).Info(\"served static asset\")\n}"}
{"input": "package agent\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/juju/juju/state/api/params\"\n)\n\nfunc Password(config Config) string {\n\tc := config.(*configInternal)\n\tif c.stateDetails == nil {\n\t\treturn c.apiDetails.password\n\t} else {\n\t\treturn c.stateDetails.password\n\t}\n\treturn \"\"\n}\n\nfunc PatchConfig(config Config, fieldName string, value interface{}) error {\n\tconf := config.(*configInternal)\n\tswitch fieldName {\n\tcase \"DataDir\":\n\t\tconf.dataDir = value.(string)\n\tcase \"LogDir\":\n\t\tconf.logDir = value.(string)\n\tcase \"Jobs\":\n\t\tconf.jobs = value.([]params.MachineJob)[:]\n\tcase \"DeleteValues\":\n\t\tfor _, key := range value.([]string) {\n\t\t\tdelete(conf.values, key)\n\t\t}\n\tcase \"Values\":\n\t\tfor key, val := range value.(map[string]string) {\n\t\t\tif conf.values == nil {\n\t\t\t\tconf.values = make(map[string]string)\n\t\t\t}\n\t\t\tconf.values[key] = val\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown field %q\", fieldName)\n\t}\n\tconf.configFilePath = ConfigPath(conf.dataDir, conf.tag)\n\treturn nil\n}\n\n\n\nfunc ConfigFileExists(config Config) bool ", "output": "{\n\tconf := config.(*configInternal)\n\t_, err := os.Lstat(conf.configFilePath)\n\treturn err == nil\n}"}
{"input": "package main\n\nimport (\n\t\"crypto/md5\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc main() {\n\tvar res string\n\tif os.Getenv(\"PART\") == \"1\" {\n\t\tres = part1(\"ffykfhsq\")\n\t} else {\n\t\tres = part2(\"ffykfhsq\")\n\t}\n\tfmt.Println(res)\n}\n\nfunc part1(prefix string) string {\n\tres := []string{}\n\tfor i := 0; len(res) < 8; i++ {\n\t\th := hash(prefix, strconv.Itoa(i))\n\t\tif strings.HasPrefix(h, \"00000\") {\n\t\t\tfmt.Println(h)\n\t\t\tres = append(res, string(h[5]))\n\t\t}\n\t}\n\treturn strings.Join(res, \"\")\n}\n\n\n\nfunc hash(prefix, guess string) string {\n\tdata := []byte(prefix + guess)\n\treturn fmt.Sprintf(\"%x\", md5.Sum(data))\n}\n\nfunc part2(prefix string) string ", "output": "{\n\tpos := [8]string{}\n\tset := 0\n\tfor i := 0; set < 8; i++ {\n\t\th := hash(prefix, strconv.Itoa(i))\n\t\tif strings.HasPrefix(h, \"00000\") {\n\t\t\tp, err := strconv.Atoi(string(h[5]))\n\t\t\tif err == nil && p < 8 && pos[p] == \"\" {\n\t\t\t\tfmt.Printf(\"%v: %v (==%v) -> %v\\n\", h, p, h[5], string(h[6]))\n\t\t\t\tpos[p] = string(h[6])\n\t\t\t\tset++\n\t\t\t}\n\t\t}\n\t}\n\treturn strings.Join(pos[:], \"\")\n}"}
{"input": "package cdrom\n\nimport (\n\t\"github.com/sacloud/libsacloud/v2/helper/validate\"\n\t\"github.com/sacloud/libsacloud/v2/sacloud/types\"\n)\n\ntype CloseFTPRequest struct {\n\tZone string   `request:\"-\" validate:\"required\"`\n\tID   types.ID `request:\"-\" validate:\"required\"`\n}\n\n\n\nfunc (req *CloseFTPRequest) Validate() error ", "output": "{\n\treturn validate.Struct(req)\n}"}
{"input": "package component \n\nimport (\n\t\"context\"\n\n\t\"go.opentelemetry.io/collector/config\"\n)\n\n\n\n\ntype Extension interface {\n\tComponent\n}\n\n\n\n\n\ntype PipelineWatcher interface {\n\tReady() error\n\n\tNotReady() error\n}\n\n\ntype ExtensionCreateSettings struct {\n\tTelemetrySettings\n\n\tBuildInfo BuildInfo\n}\n\n\ntype ExtensionDefaultConfigFunc func() config.Extension\n\n\nfunc (f ExtensionDefaultConfigFunc) CreateDefaultConfig() config.Extension {\n\treturn f()\n}\n\n\ntype CreateExtensionFunc func(context.Context, ExtensionCreateSettings, config.Extension) (Extension, error)\n\n\n\n\n\ntype ExtensionFactory interface {\n\tFactory\n\n\tCreateDefaultConfig() config.Extension\n\n\tCreateExtension(ctx context.Context, set ExtensionCreateSettings, cfg config.Extension) (Extension, error)\n}\n\ntype extensionFactory struct {\n\tbaseFactory\n\tExtensionDefaultConfigFunc\n\tCreateExtensionFunc\n}\n\nfunc NewExtensionFactory(\n\tcfgType config.Type,\n\tcreateDefaultConfig ExtensionDefaultConfigFunc,\n\tcreateServiceExtension CreateExtensionFunc) ExtensionFactory {\n\treturn &extensionFactory{\n\t\tbaseFactory:                baseFactory{cfgType: cfgType},\n\t\tExtensionDefaultConfigFunc: createDefaultConfig,\n\t\tCreateExtensionFunc:        createServiceExtension,\n\t}\n}\n\nfunc (f CreateExtensionFunc) CreateExtension(ctx context.Context, set ExtensionCreateSettings, cfg config.Extension) (Extension, error) ", "output": "{\n\treturn f(ctx, set, cfg)\n}"}
{"input": "package scheduler\n\nimport (\n\t\"github.com/scootdev/scoot/saga/sagalogs\"\n\t\"github.com/scootdev/scoot/sched\"\n\t\"github.com/scootdev/scoot/tests/testhelpers\"\n\t\"math\"\n\t\"testing\"\n)\n\n\n\nfunc Test_TaskAssignment_NoTasks(t *testing.T) {\n\ttestCluster := makeTestCluster(\"node1\", \"node2\", \"node3\", \"node4\", \"node5\")\n\tcs := newClusterState(testCluster.nodes, testCluster.ch)\n\tassignments := getTaskAssignments(cs, []*taskState{})\n\n\tif len(assignments) != 0 {\n\t\tt.Errorf(\"Assignments on a cluster with no nodes should not return any assignments\")\n\t}\n}\n\n\n\nfunc Test_TaskAssignments_TasksScheduled(t *testing.T) {\n\tjob := sched.GenJob(testhelpers.GenJobId(testhelpers.NewRand()), 10)\n\tjobAsBytes, _ := job.Serialize()\n\n\tsaga, _ := sagalogs.MakeInMemorySagaCoordinator().MakeSaga(job.Id, jobAsBytes)\n\tjobState := newJobState(&job, saga)\n\n\ttestCluster := makeTestCluster(\"node1\", \"node2\", \"node3\", \"node4\", \"node5\")\n\tcs := newClusterState(testCluster.nodes, testCluster.ch)\n\tunScheduledTasks := jobState.getUnScheduledTasks()\n\tassignments := getTaskAssignments(cs, unScheduledTasks)\n\n\tif float64(len(assignments)) != math.Min(float64(len(unScheduledTasks)), float64(len(testCluster.nodes))) {\n\t\tt.Errorf(`Expected as many tasks as possible to be scheduled: NumScheduled %v, \n      Number Of Available Nodes %v, Number of Unscheduled Tasks %v`,\n\t\t\tlen(assignments),\n\t\t\tlen(testCluster.nodes),\n\t\t\tlen(unScheduledTasks))\n\t}\n}\n\nfunc Test_TaskAssignment_NoNodesAvailable(t *testing.T) ", "output": "{\n\tjob := sched.GenJob(testhelpers.GenJobId(testhelpers.NewRand()), 10)\n\tjobAsBytes, _ := job.Serialize()\n\n\tsaga, _ := sagalogs.MakeInMemorySagaCoordinator().MakeSaga(job.Id, jobAsBytes)\n\tjobState := newJobState(&job, saga)\n\n\ttestCluster := makeTestCluster()\n\tcs := newClusterState(testCluster.nodes, testCluster.ch)\n\tassignments := getTaskAssignments(cs, jobState.getUnScheduledTasks())\n\n\tif len(assignments) != 0 {\n\t\tt.Errorf(\"Assignments on a cluster with no nodes should not return any assignments\")\n\t}\n}"}
{"input": "package backoff\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\n\n\ntype Operation func() error\n\n\n\n\n\n\ntype Notify func(error, time.Duration)\n\n\n\n\n\n\n\n\n\nfunc Retry(o Operation, b BackOff) error {\n\treturn RetryNotify(o, b, nil)\n}\n\n\n\nfunc RetryNotify(operation Operation, b BackOff, notify Notify) error {\n\treturn RetryNotifyWithTimer(operation, b, notify, nil)\n}\n\n\n\n\nfunc RetryNotifyWithTimer(operation Operation, b BackOff, notify Notify, t Timer) error {\n\tvar err error\n\tvar next time.Duration\n\tif t == nil {\n\t\tt = &defaultTimer{}\n\t}\n\n\tdefer func() {\n\t\tt.Stop()\n\t}()\n\n\tctx := getContext(b)\n\n\tb.Reset()\n\tfor {\n\t\tif err = operation(); err == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tvar permanent *PermanentError\n\t\tif errors.As(err, &permanent) {\n\t\t\treturn permanent.Err\n\t\t}\n\n\t\tif next = b.NextBackOff(); next == Stop {\n\t\t\treturn err\n\t\t}\n\n\t\tif notify != nil {\n\t\t\tnotify(err, next)\n\t\t}\n\n\t\tt.Start(next)\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tcase <-t.C():\n\t\t}\n\t}\n}\n\n\ntype PermanentError struct {\n\tErr error\n}\n\n\n\nfunc (e *PermanentError) Unwrap() error {\n\treturn e.Err\n}\n\nfunc (e *PermanentError) Is(target error) bool {\n\t_, ok := target.(*PermanentError)\n\treturn ok\n}\n\n\nfunc Permanent(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\treturn &PermanentError{\n\t\tErr: err,\n\t}\n}\n\nfunc (e *PermanentError) Error() string ", "output": "{\n\treturn e.Err.Error()\n}"}
{"input": "package logic\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"github.com/github/orchestrator/go/db\"\n\t\"github.com/openark/golib/log\"\n\t\"github.com/openark/golib/sqlutils\"\n)\n\n\nfunc IsRecoveryDisabled() (disabled bool, err error) {\n\tquery := `\n\t\tSELECT\n\t\t\tCOUNT(*) as mycount\n\t\tFROM\n\t\t\tglobal_recovery_disable\n\t\tWHERE\n\t\t\tdisable_recovery=?\n\t\t`\n\terr = db.QueryOrchestrator(query, sqlutils.Args(1), func(m sqlutils.RowMap) error {\n\t\tmycount := m.GetInt(\"mycount\")\n\t\tdisabled = (mycount > 0)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\terr = log.Errorf(\"recovery.IsRecoveryDisabled(): %v\", err)\n\t}\n\treturn disabled, err\n}\n\n\nfunc DisableRecovery() error {\n\t_, err := db.ExecOrchestrator(`\n\t\tINSERT IGNORE INTO global_recovery_disable\n\t\t\t(disable_recovery)\n\t\tVALUES  (1)\n\t`,\n\t)\n\treturn err\n}\n\n\nfunc EnableRecovery() error {\n\t_, err := db.ExecOrchestrator(`\n\t\tDELETE FROM global_recovery_disable WHERE disable_recovery >= 0\n\t`,\n\t)\n\treturn err\n}\n\n\n\nfunc SetRecoveryDisabled(disabled bool) error ", "output": "{\n\tif disabled {\n\t\treturn DisableRecovery()\n\t}\n\treturn EnableRecovery()\n}"}
{"input": "package deny\n\nimport (\n\t\"testing\"\n\n\t\"k8s.io/apiserver/pkg/admission\"\n\t\"k8s.io/kubernetes/pkg/api\"\n)\n\n\n\nfunc TestAdmission(t *testing.T) ", "output": "{\n\thandler := NewAlwaysDeny()\n\terr := handler.Admit(admission.NewAttributesRecord(nil, nil, api.Kind(\"kind\").WithVersion(\"version\"), \"namespace\", \"name\", api.Resource(\"resource\").WithVersion(\"version\"), \"subresource\", admission.Create, nil))\n\tif err == nil {\n\t\tt.Errorf(\"Expected error returned from admission handler\")\n\t}\n}"}
{"input": "package yundun\n\nimport (\n\t. \"aliyun-openapi-go-sdk/core\"\n)\n\ntype WafInfoRequest struct {\n\tRpcRequest\n\tInstanceId   string\n\tInstanceType string\n}\n\nfunc (r *WafInfoRequest) SetInstanceId(value string) {\n\tr.InstanceId = value\n\tr.QueryParams.Set(\"InstanceId\", value)\n}\nfunc (r *WafInfoRequest) GetInstanceId() string {\n\treturn r.InstanceId\n}\nfunc (r *WafInfoRequest) SetInstanceType(value string) {\n\tr.InstanceType = value\n\tr.QueryParams.Set(\"InstanceType\", value)\n}\n\n\nfunc (r *WafInfoRequest) Init() {\n\tr.RpcRequest.Init()\n\tr.SetVersion(Version)\n\tr.SetAction(\"WafInfo\")\n\tr.SetProduct(Product)\n}\n\ntype WafInfoResponse struct {\n\tWafDomainNum int `xml:\"WafDomainNum\" json:\"WafDomainNum\"`\n\tWafInfos     struct {\n\t\tWafInfo []struct {\n\t\t\tId     int    `xml:\"Id\" json:\"Id\"`\n\t\t\tDomain string `xml:\"Domain\" json:\"Domain\"`\n\t\t\tCname  string `xml:\"Cname\" json:\"Cname\"`\n\t\t\tStatus int    `xml:\"Status\" json:\"Status\"`\n\t\t} `xml:\"WafInfo\" json:\"WafInfo\"`\n\t} `xml:\"WafInfos\" json:\"WafInfos\"`\n}\n\nfunc WafInfo(req *WafInfoRequest, accessId, accessSecret string) (*WafInfoResponse, error) {\n\tvar pResponse WafInfoResponse\n\tbody, err := ApiHttpRequest(accessId, accessSecret, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tApiUnmarshalResponse(req.GetFormat(), body, &pResponse)\n\treturn &pResponse, err\n}\n\nfunc (r *WafInfoRequest) GetInstanceType() string ", "output": "{\n\treturn r.InstanceType\n}"}
{"input": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/aws/aws-lambda-go/events\"\n\t\"github.com/aws/aws-lambda-go/lambda\"\n)\n\n\n\nfunc main() {\n\tlambda.Start(handler)\n}\n\nfunc handler(ctx context.Context, sqsEvent events.SQSEvent) error ", "output": "{\n\tfor _, message := range sqsEvent.Records {\n\t\tfmt.Printf(\"The message %s for event source %s = %s \\n\", message.MessageId, message.EventSource, message.Body)\n\t}\n\n\treturn nil\n}"}
{"input": "package input\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\n\t\"github.com/elastic/beats/libbeat/logp\"\n)\n\ntype FileStateOS struct {\n\tInode  uint64 `json:\"inode,omitempty\"`\n\tDevice uint64 `json:\"device,omitempty\"`\n}\n\n\n\n\n\nfunc (fs *FileStateOS) IsSame(state *FileStateOS) bool {\n\treturn fs.Inode == state.Inode && fs.Device == state.Device\n}\n\n\nfunc SafeFileRotate(path, tempfile string) error {\n\tif e := os.Rename(tempfile, path); e != nil {\n\t\tlogp.Err(\"Rotate error: %s\", e)\n\t\treturn e\n\t}\n\treturn nil\n}\n\n\nfunc ReadOpen(path string) (*os.File, error) {\n\n\tflag := os.O_RDONLY\n\tvar perm os.FileMode = 0\n\n\treturn os.OpenFile(path, flag, perm)\n}\n\nfunc GetOSFileState(info *os.FileInfo) *FileStateOS ", "output": "{\n\n\tstat := (*(info)).Sys().(*syscall.Stat_t)\n\n\tfileState := &FileStateOS{\n\t\tInode:  uint64(stat.Ino),\n\t\tDevice: uint64(stat.Dev),\n\t}\n\n\treturn fileState\n}"}
{"input": "package shortening\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nvar testCoder32 = &testCoder{Encode32, Decode32}\n\nfunc TestEncode32(t *testing.T) {\n\tpropEncCounting(t, CharSet32, testCoder32)\n\n\tpropRollover(t, CharSet32, minTable32[1:], testCoder32)\n\n\tmaxEncoded := \"O666666666667\"\n\tif e := string(testCoder32.Encode(math.MaxUint64)); e != maxEncoded {\n\t\tt.Errorf(\"got: %q - expected: %q\", e, maxEncoded)\n\t}\n}\n\nfunc TestDecode32(t *testing.T) {\n\tpropDecCounting(t, CharSet32, testCoder32)\n\n\tn, err := testCoder32.Decode([]byte(\"O666666666667\"))\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif max := uint64(math.MaxUint64); n != max {\n\t\tt.Errorf(\"got: %q - expected: %q\", n, max)\n\t}\n}\n\n\n\nfunc TestEncDec32Parity(t *testing.T) { propParity(t, testCoder32) }\n\nfunc BenchmarkEncode32(b *testing.B) { benchEncode(b, testCoder32) }\nfunc BenchmarkDecode32(b *testing.B) { benchDecode(b, testCoder32) }\n\nfunc TestDecode32Errors(t *testing.T) ", "output": "{\n\ttests := []struct {\n\t\tID  []byte\n\t\tErr error\n\t}{\n\t\t{nil, InvalidDecodeLen},\n\t\t{[]byte(\"\"), InvalidDecodeLen},\n\t\t{[]byte(\"O66666666667A\"), Overflow},\n\t\t{[]byte(\"AAAAAAAAAAAAAA\"), InvalidDecodeLen},\n\t\t{[]byte(\"*\"), InvalidCharacter},\n\t\t{[]byte(\"\\xFF\"), InvalidCharacter},\n\t}\n\n\tfor _, test := range tests {\n\t\t_, err := testCoder32.Decode(test.ID)\n\t\tif err == nil {\n\t\t\tt.Logf(\"%q\", test.ID)\n\t\t\tt.Error(\"error expected. got nil\")\n\t\t} else if err != test.Err {\n\t\t\tt.Logf(\"%q\", test)\n\t\t\tt.Fatalf(\"got: %q - expected: %q\", err, test.Err)\n\t\t}\n\t}\n}"}
{"input": "package buffer\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\n\ntype Buffer interface {\n\tLen() int64 \n\tCap() int64 \n\tio.Reader   \n\tio.Writer   \n\tReset()     \n}\n\n\ntype BufferAt interface {\n\tBuffer\n\tio.ReaderAt\n\tio.WriterAt\n}\n\nfunc len64(p []byte) int64 {\n\treturn int64(len(p))\n}\n\n\nfunc Gap(buf Buffer) int64 {\n\treturn buf.Cap() - buf.Len()\n}\n\n\nfunc Full(buf Buffer) bool {\n\treturn buf.Len() == buf.Cap()\n}\n\n\n\n\n\n\nfunc NewUnboundedBuffer(mem, file int64) Buffer {\n\treturn NewMulti(New(mem), NewPartition(NewFilePool(file, os.TempDir())))\n}\n\nfunc Empty(buf Buffer) bool ", "output": "{\n\treturn buf.Len() == 0\n}"}
{"input": "package log\n\nimport (\n\t\"fmt\"\n)\n\nvar (\n\tVerbose bool\n)\n\nfunc Init(verbose bool) error {\n\tVerbose = verbose\n\treturn nil\n}\n\nfunc Debug(format string, v ...interface{}) {\n\tif Verbose {\n\t\tfmt.Println(fmt.Sprintf(format, v...))\n\t}\n}\n\n\n\nfunc Println(format string, v ...interface{}) ", "output": "{\n\tfmt.Println(fmt.Sprintf(format, v...))\n}"}
{"input": "package portgroup\n\nimport (\n\t\"context\"\n\t\"flag\"\n\n\t\"github.com/vmware/govmomi/govc/cli\"\n\t\"github.com/vmware/govmomi/govc/flags\"\n)\n\ntype remove struct {\n\t*flags.HostSystemFlag\n}\n\nfunc init() {\n\tcli.Register(\"host.portgroup.remove\", &remove{})\n}\n\n\n\nfunc (cmd *remove) Process(ctx context.Context) error {\n\tif err := cmd.HostSystemFlag.Process(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (cmd *remove) Usage() string {\n\treturn \"NAME\"\n}\n\nfunc (cmd *remove) Run(ctx context.Context, f *flag.FlagSet) error {\n\tns, err := cmd.HostNetworkSystem()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ns.RemovePortGroup(ctx, f.Arg(0))\n}\n\nfunc (cmd *remove) Register(ctx context.Context, f *flag.FlagSet) ", "output": "{\n\tcmd.HostSystemFlag, ctx = flags.NewHostSystemFlag(ctx)\n\tcmd.HostSystemFlag.Register(ctx, f)\n}"}
{"input": "package helpers\n\nimport \"testing\"\n\nfunc TestPointerToBool(t *testing.T) {\n\tboolVar := true\n\tret := PointerToBool(boolVar)\n\tif *ret != boolVar {\n\t\tt.Fatalf(\"expected PointerToBool(true) to return *true, instead returned %#v\", ret)\n\t}\n}\n\n\n\nfunc TestIsRegionNormalized(t *testing.T) ", "output": "{\n\tcases := []struct {\n\t\tinput          string\n\t\texpectedResult string\n\t}{\n\t\t{\n\t\t\tinput:          \"westus\",\n\t\t\texpectedResult: \"westus\",\n\t\t},\n\t\t{\n\t\t\tinput:          \"West US\",\n\t\t\texpectedResult: \"westus\",\n\t\t},\n\t\t{\n\t\t\tinput:          \"Eastern Africa\",\n\t\t\texpectedResult: \"easternafrica\",\n\t\t},\n\t\t{\n\t\t\tinput:          \"\",\n\t\t\texpectedResult: \"\",\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tresult := NormalizeAzureRegion(c.input)\n\t\tif c.expectedResult != result {\n\t\t\tt.Fatalf(\"NormalizeAzureRegion returned unexpected result: expected %s but got %s\", c.expectedResult, result)\n\t\t}\n\t}\n}"}
{"input": "package kubelet\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/golang/glog\"\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/types\"\n\t\"k8s.io/kubernetes/pkg/volume\"\n\tvolumetypes \"k8s.io/kubernetes/pkg/volume/util/types\"\n)\n\n\n\n\n\n\n\nfunc (kl *Kubelet) podVolumesExist(podUID types.UID) bool {\n\tif mountedVolumes :=\n\t\tkl.volumeManager.GetMountedVolumesForPod(\n\t\t\tvolumetypes.UniquePodName(podUID)); len(mountedVolumes) > 0 {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n\n\n\nfunc (kl *Kubelet) newVolumeMounterFromPlugins(spec *volume.Spec, pod *api.Pod, opts volume.VolumeOptions) (volume.Mounter, error) {\n\tplugin, err := kl.volumePluginMgr.FindPluginBySpec(spec)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't use volume plugins for %s: %v\", spec.Name(), err)\n\t}\n\tphysicalMounter, err := plugin.NewMounter(spec, pod, opts)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to instantiate mounter for volume: %s using plugin: %s with a root cause: %v\", spec.Name(), plugin.GetPluginName(), err)\n\t}\n\tglog.V(10).Infof(\"Using volume plugin %q to mount %s\", plugin.GetPluginName(), spec.Name())\n\treturn physicalMounter, nil\n}\n\nfunc (kl *Kubelet) ListVolumesForPod(podUID types.UID) (map[string]volume.Volume, bool) ", "output": "{\n\tvolumesToReturn := make(map[string]volume.Volume)\n\tpodVolumes := kl.volumeManager.GetMountedVolumesForPod(\n\t\tvolumetypes.UniquePodName(podUID))\n\tfor outerVolumeSpecName, volume := range podVolumes {\n\t\tvolumesToReturn[outerVolumeSpecName] = volume.Mounter\n\t}\n\n\treturn volumesToReturn, len(volumesToReturn) > 0\n}"}
{"input": "package rd2wgs84\n\nimport (\n\t\"testing\"\n)\n\nvar parseTests = []struct {\n\tin  RD\n\tout *WGS84\n}{\n\t{RD{163835.370083, 446830.763585}, &WGS84{52.00977421758342, 5.515894213047998}},\n}\n\n\n\nfunc TestConvert(t *testing.T) ", "output": "{\n\tfor i, tt := range parseTests {\n\t\twgs := Convert(tt.in.X, tt.in.Y)\n\t\tif wgs.Latitude != tt.out.Latitude || wgs.Longitude != tt.out.Longitude {\n\t\t\tt.Errorf(\"%d. Convert(%f, %f) => %+v returned, expected %+v\", i, tt.in.X, tt.in.Y, wgs, tt.out)\n\t\t}\n\t}\n}"}
{"input": "package cluster\n\nimport \"sort\"\n\n\ntype Strategy string\n\nconst (\n\tStrategyRange Strategy = \"range\"\n\n\tStrategyRoundRobin Strategy = \"roundrobin\"\n)\n\n\n\ntype Error struct {\n\tCtx string\n\terror\n}\n\n\n\ntype none struct{}\n\ntype topicPartition struct {\n\tTopic     string\n\tPartition int32\n}\n\ntype offsetInfo struct {\n\tOffset   int64\n\tMetadata string\n}\n\n\n\ntype int32Slice []int32\n\nfunc (p int32Slice) Len() int           { return len(p) }\nfunc (p int32Slice) Less(i, j int) bool { return p[i] < p[j] }\nfunc (p int32Slice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n\nfunc (p int32Slice) Diff(o int32Slice) (res []int32) {\n\ton := len(o)\n\tfor _, x := range p {\n\t\tn := sort.Search(on, func(i int) bool { return o[i] >= x })\n\t\tif n < on && o[n] == x {\n\t\t\tcontinue\n\t\t}\n\t\tres = append(res, x)\n\t}\n\treturn\n}\n\nfunc (i offsetInfo) NextOffset(fallback int64) int64 ", "output": "{\n\tif i.Offset > -1 {\n\t\treturn i.Offset\n\t}\n\treturn fallback\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/astaxie/beego\"\n)\n\ntype ErrorController struct {\n    beego.Controller\n}\n\n\n\n\n\n\nfunc (c *ErrorController) Error401() {\n    c.Data[\"Content\"] = \"Unauthorized\"\n    c.TplName = \"error_page.tpl\"\n}\n\n\nfunc (c *ErrorController) Error403() {\n    c.Data[\"Content\"] = \"Forbidden\"\n    c.TplName = \"error_page.tpl\"\n}\n\n\nfunc (c *ErrorController) Error404() {\n    c.Data[\"Content\"] = \"My super cool 404 page\"\n    c.TplName = \"error_page.tpl\"\n}\n\n\nfunc (c *ErrorController) Error500() {\n    c.Data[\"Content\"] = \"Oops something whent wrong\"\n    c.TplName = \"error_page.tpl\"\n}\n\n\n\n\nfunc (c *ErrorController) Error503() ", "output": "{\n    c.Data[\"Content\"] = \"Service Unavailable\"\n    c.TplName = \"error_page.tpl\"\n}"}
{"input": "package protocol\n\n\n\nimport \"golang.org/x/text/unicode/norm\"\n\ntype nativeModel struct {\n\tModel\n}\n\nfunc (m nativeModel) Index(deviceID DeviceID, folder string, files []FileInfo, flags uint32, options []Option) {\n\tfor i := range files {\n\t\tfiles[i].Name = norm.NFD.String(files[i].Name)\n\t}\n\tm.Model.Index(deviceID, folder, files, flags, options)\n}\n\nfunc (m nativeModel) IndexUpdate(deviceID DeviceID, folder string, files []FileInfo, flags uint32, options []Option) {\n\tfor i := range files {\n\t\tfiles[i].Name = norm.NFD.String(files[i].Name)\n\t}\n\tm.Model.IndexUpdate(deviceID, folder, files, flags, options)\n}\n\n\n\nfunc (m nativeModel) Request(deviceID DeviceID, folder string, name string, offset int64, hash []byte, flags uint32, options []Option, buf []byte) error ", "output": "{\n\tname = norm.NFD.String(name)\n\treturn m.Model.Request(deviceID, folder, name, offset, hash, flags, options, buf)\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSECSService_DeploymentConfiguration struct {\n\n\tMaximumPercent int `json:\"MaximumPercent,omitempty\"`\n\n\tMinimumHealthyPercent int `json:\"MinimumHealthyPercent,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSECSService_DeploymentConfiguration) AWSCloudFormationType() string {\n\treturn \"AWS::ECS::Service.DeploymentConfiguration\"\n}\n\n\n\nfunc (r *AWSECSService_DeploymentConfiguration) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSECSService_DeploymentConfiguration) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSECSService_DeploymentConfiguration) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSECSService_DeploymentConfiguration) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\n\n\nfunc (r *AWSECSService_DeploymentConfiguration) SetDeletionPolicy(policy policies.DeletionPolicy) ", "output": "{\n\tr._deletionPolicy = policy\n}"}
{"input": "package dt\n\nimport (\n\t\"strings\"\n\n\t\"github.com/dchest/stemmer/porter2\"\n)\n\n\n\ntype Keywords struct {\n\tDict map[string]KeywordFn\n}\n\n\n\n\ntype KeywordHandler struct {\n\tFn      KeywordFn\n\tTrigger *StructuredInput\n}\n\n\n\n\ntype KeywordFn func(in *Msg) (response string)\n\n\n\n\nfunc (k *Keywords) handle(m *Msg) string ", "output": "{\n\tif k == nil {\n\t\treturn \"\"\n\t}\n\tfor _, intent := range m.StructuredInput.Intents {\n\t\tfn, ok := k.Dict[\"I_\"+intent]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn fn(m)\n\t}\n\n\teng := porter2.Stemmer\n\tfor _, cmd := range m.StructuredInput.Commands {\n\t\tcmd = strings.ToLower(eng.Stem(cmd))\n\t\tfor _, obj := range m.StructuredInput.Objects {\n\t\t\tobj = strings.ToLower(eng.Stem(obj))\n\t\t\tfn, ok := k.Dict[\"CO_\"+cmd+\"_\"+obj]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn fn(m)\n\t\t}\n\t}\n\treturn \"\"\n}"}
{"input": "package main\n\nimport (\n\t\"labix.org/v2/mgo\"\n)\n\n\nfunc DB(cfg *Config) *mgo.Database {\n\treturn cfg.Mongo.session.DB(cfg.Mongo.Database)\n}\n\n\n\n\nfunc C(cfg *Config) *mgo.Collection ", "output": "{\n\treturn cfg.Mongo.session.DB(cfg.Mongo.Database).C(cfg.Mongo.Collection)\n}"}
{"input": "package http\n\nimport (\n\t\"github.com/dlutxx/goblin/utils\"\n)\n\ntype Context struct {\n\tRes   *Response\n\tReq   *Request\n\tApp   *App \n\tExtra utils.Dict\n\terr   interface{} \n}\n\n\n\nfunc (ctx *Context) Err() interface{} ", "output": "{\n\treturn ctx.err\n}"}
{"input": "package command\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/xeb/etcdrepl/third_party/github.com/codegangsta/cli\"\n\t\"github.com/xeb/etcdrepl/third_party/github.com/coreos/go-etcd/etcd\"\n)\n\nfunc NewLsCommand() cli.Command {\n\treturn cli.Command{\n\t\tName:\t\"ls\",\n\t\tUsage:\t\"retrieve a directory\",\n\t\tFlags: []cli.Flag{\n\t\t\tcli.BoolFlag{\"recursive\", \"returns all values for key and child keys\"},\n\t\t},\n\t\tAction: func(c *cli.Context) {\n\t\t\thandleLs(c, lsCommandFunc)\n\t\t},\n\t}\n}\n\n\nfunc handleLs(c *cli.Context, fn handlerFunc) {\n\thandlePrint(c, fn, printLs)\n}\n\n\n\nfunc printLs(resp *etcd.Response, format string) {\n\tif !resp.Node.Dir {\n\t\tfmt.Println(resp.Node.Key)\n\t}\n\tfor _, node := range resp.Node.Nodes {\n\t\trPrint(&node)\n\t}\n}\n\n\nfunc lsCommandFunc(c *cli.Context, client *etcd.Client) (*etcd.Response, error) {\n\tkey := \"/\"\n\tif len(c.Args()) != 0 {\n\t\tkey = c.Args()[0]\n\t}\n\trecursive := c.Bool(\"recursive\")\n\n\treturn client.Get(key, false, recursive)\n}\n\n\n\n\nfunc rPrint(n *etcd.Node) ", "output": "{\n\tfmt.Println(n.Key)\n\tfor _, node := range n.Nodes {\n\t\trPrint(&node)\n\t}\n}"}
{"input": "package cognitiveservices\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n)\n\nconst (\n\tmajor           = \"8\"\n\tminor           = \"0\"\n\tpatch           = \"0\"\n\ttag             = \"beta\"\n\tuserAgentFormat = \"Azure-SDK-For-Go/%s arm-%s/%s\"\n)\n\n\nvar (\n\tuserAgent string\n\tversion   string\n)\n\n\nfunc UserAgent() string {\n\tif userAgent == \"\" {\n\t\tuserAgent = fmt.Sprintf(userAgentFormat, Version(), \"cognitiveservices\", \"2016-02-01-preview\")\n\t}\n\treturn userAgent\n}\n\n\n\n\nfunc Version() string ", "output": "{\n\tif version == \"\" {\n\t\tversionBuilder := bytes.NewBufferString(fmt.Sprintf(\"%s.%s.%s\", major, minor, patch))\n\t\tif tag != \"\" {\n\t\t\tversionBuilder.WriteRune('-')\n\t\t\tversionBuilder.WriteString(strings.TrimPrefix(tag, \"-\"))\n\t\t}\n\t\tversion = string(versionBuilder.Bytes())\n\t}\n\treturn version\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n)\n\n\n\n\n\n\n\n\n\n\n\ntype Tags map[string]string\n\n\n\n\nfunc (m Tags) Validate(formats strfmt.Registry) error ", "output": "{\n\treturn nil\n}"}
{"input": "package main\n\nimport \"go/types\"\n\n\n\ntype sourceImporter struct{}\n\nfunc (sourceImporter) Import(path string) (*types.Package, error) {\n\tpanic(\"unimplemented\")\n}\n\nfunc init() ", "output": "{\n\tregister(\"source\", sourceImporter{})\n}"}
{"input": "package plAuth\n\nimport (\n\t\"fmt\"\n)\n\n\n\ntype UnsetPassword struct {\n\tuser *User\n}\n\n\n\n\ntype WrongPassword int\n\nfunc (e WrongPassword) Error() string {\n\treturn fmt.Sprintf(\"Invalid Password\")\n}\n\n\ntype ValidationError struct {\n\tReason string\n}\n\nfunc (e ValidationError) Error() string {\n\treturn e.Reason\n}\n\ntype InterfaceConversionError struct {\n\tFailed interface{}\n}\n\nfunc (e InterfaceConversionError) Error() string {\n\treturn fmt.Sprintf(\"Conversition failed %#v\", e.Failed)\n}\n\ntype UserAllreadyExists struct {\n\texistingUser *User\n}\n\nfunc (e UserAllreadyExists) Error() string {\n\treturn fmt.Sprintf(\"A user with this data allreay exists: %v\", e.existingUser)\n}\n\nfunc (e UnsetPassword) Error() string ", "output": "{\n\treturn fmt.Sprintf(\"%s has no password set. Call SetPass() first!\", e.user)\n}"}
{"input": "package unit\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"encoding/json\"\n\t\"github.com/quickscript/unit/exstring\"\n)\n\nfunc PathExists(path string) (bool, error) {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n\n\n\nfunc ReadTextLine(path string, handler func(string)) error {\n\texist, _ := PathExists(path)\n\tif !exist {\n\t\treturn nil\n\t}\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf := bufio.NewReader(file)\n\tfor {\n\t\tline, err := buf.ReadString('\\n')\n\t\tline = strings.TrimSpace(line)\n\t\thandler(line)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc GetParentDirectory(directory string) string {\n\treturn exstring.Substr(directory, 0, strings.LastIndex(directory, \"/\"))\n}\n\nfunc GetCurrentDirectory() string {\n\tdir, err := filepath.Abs(filepath.Dir(os.Args[0]))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn strings.Replace(dir, \"\\\\\", \"/\", -1)\n}\n\nfunc Json2map(jsonStr string) (s map[string]interface{}, err error) {\n\tvar result map[string]interface{}\n\tif err := json.Unmarshal([]byte(jsonStr), &result); err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\nfunc IsDir(path string) (bool, error) ", "output": "{\n\tfile, err := os.Stat(path)\n\tif err == nil {\n\t\treturn file.IsDir(), nil\n\t}\n\treturn false, err\n}"}
{"input": "package fstest\n\nimport (\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"github.com/containerd/continuity/sysx\"\n\t\"golang.org/x/sys/unix\"\n)\n\n\nfunc SetXAttr(name, key, value string) Applier {\n\treturn applyFn(func(root string) error {\n\t\treturn sysx.LSetxattr(name, key, []byte(value), 0)\n\t})\n}\n\n\nfunc Lchtimes(name string, atime, mtime time.Time) Applier {\n\treturn applyFn(func(root string) error {\n\t\tpath := filepath.Join(root, name)\n\t\tat := unix.NsecToTimespec(atime.UnixNano())\n\t\tmt := unix.NsecToTimespec(mtime.UnixNano())\n\t\tutimes := [2]unix.Timespec{at, mt}\n\t\treturn unix.UtimesNanoAt(unix.AT_FDCWD, path, utimes[0:], unix.AT_SYMLINK_NOFOLLOW)\n\t})\n}\n\n\n\nfunc Base() Applier ", "output": "{\n\treturn applyFn(func(root string) error {\n\t\treturn nil\n\t})\n}"}
{"input": "package iterfloat32\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype Slice struct {\n\tSlice []float32\n\terr error\n\tindex int\n\tmutex sync.RWMutex\n\tclosed bool\n\tdatum float32\n}\n\nfunc (receiver *Slice) Close() error {\n\tif nil == receiver {\n\t\treturn errNilReceiver\n\t}\n\n\treceiver.mutex.Lock()\n\tdefer receiver.mutex.Unlock()\n\n\treceiver.closed = true\n\n\treturn nil\n}\n\n\n\n\nfunc (receiver *Slice) Decode(x interface{}) error {\n\tif nil == receiver {\n\t\treturn errNilReceiver\n\t}\n\n\treceiver.mutex.RLock()\n\tdefer receiver.mutex.RUnlock()\n\n\tswitch p := x.(type) {\n\tcase *float32:\n\t\tif nil == p {\n\t\t\treturn nil\n\t\t}\n\n\t\t*p = receiver.datum\n\tcase *interface{}:\n\t\tif nil == p {\n\t\t\treturn nil\n\t\t}\n\n\t\t*p = receiver.datum\n\tcase sql.Scanner:\n\t\treturn p.Scan( float64(receiver.datum) )\n\tdefault:\n\t\treturn &internalBadTypeComplainer{fmt.Sprintf(\"%T\", p)}\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (receiver *Slice) Err() error {\n\tif nil == receiver {\n\t\treturn errNilReceiver\n\t}\n\n\treceiver.mutex.RLock()\n\tdefer receiver.mutex.RUnlock()\n\n\treturn receiver.err\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (receiver *Slice) Next() bool ", "output": "{\n\tif nil == receiver {\n\t\treturn false\n\t}\n\n\treceiver.mutex.Lock()\n\tdefer receiver.mutex.Unlock()\n\n\tif nil != receiver.err {\n\t\treturn false\n\t}\n\n\tif receiver.closed {\n\t\treturn false\n\t}\n\n\tslice := receiver.Slice\n\tif nil == slice  {\n\t\treturn false\n\t}\n\n\tindex := receiver.index\n\tif len(slice) <= index {\n\t\treturn false\n\t}\n\n\treceiver.datum = slice[index]\n\treceiver.index++\n\n\treturn true\n}"}
{"input": "package mediaservices\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tAPIVersion = \"2015-10-01\"\n\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype ManagementClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tAPIVersion     string\n\tSubscriptionID string\n}\n\n\nfunc New(subscriptionID string) ManagementClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) ManagementClient ", "output": "{\n\treturn ManagementClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tAPIVersion:     APIVersion,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}"}
{"input": "package process\n\nimport (\n\t\"context\"\n\n\t\"github.com/containerd/console\"\n\t\"github.com/containerd/containerd/errdefs\"\n\tgoogle_protobuf \"github.com/gogo/protobuf/types\"\n\t\"github.com/pkg/errors\"\n)\n\ntype deletedState struct {\n}\n\nfunc (s *deletedState) Pause(ctx context.Context) error {\n\treturn errors.Errorf(\"cannot pause a deleted process\")\n}\n\nfunc (s *deletedState) Resume(ctx context.Context) error {\n\treturn errors.Errorf(\"cannot resume a deleted process\")\n}\n\nfunc (s *deletedState) Update(context context.Context, r *google_protobuf.Any) error {\n\treturn errors.Errorf(\"cannot update a deleted process\")\n}\n\nfunc (s *deletedState) Checkpoint(ctx context.Context, r *CheckpointConfig) error {\n\treturn errors.Errorf(\"cannot checkpoint a deleted process\")\n}\n\nfunc (s *deletedState) Resize(ws console.WinSize) error {\n\treturn errors.Errorf(\"cannot resize a deleted process\")\n}\n\nfunc (s *deletedState) Start(ctx context.Context) error {\n\treturn errors.Errorf(\"cannot start a deleted process\")\n}\n\n\n\nfunc (s *deletedState) Kill(ctx context.Context, sig uint32, all bool) error {\n\treturn errors.Wrap(errdefs.ErrNotFound, \"cannot kill a deleted process\")\n}\n\nfunc (s *deletedState) SetExited(status int) {\n}\n\nfunc (s *deletedState) Exec(ctx context.Context, path string, r *ExecConfig) (Process, error) {\n\treturn nil, errors.Errorf(\"cannot exec in a deleted state\")\n}\n\nfunc (s *deletedState) Delete(ctx context.Context) error ", "output": "{\n\treturn errors.Wrap(errdefs.ErrNotFound, \"cannot delete a deleted process\")\n}"}
{"input": "package controller\n\nimport \"github.com/atongen/gosaic/environment\"\n\n\n\nfunc CoverList(env environment.Environment) ", "output": "{\n\tcoverService := env.ServiceFactory().MustCoverService()\n\n\tcovers, err := coverService.FindAll(\"covers.name ASC\")\n\tif err != nil {\n\t\tenv.Printf(\"Error finding covers: %s\\n\", err.Error())\n\t\treturn\n\t}\n\tif len(covers) == 0 {\n\t\treturn\n\t}\n\n\tfor _, cover := range covers {\n\t\tenv.Println(cover)\n\t}\n}"}
{"input": "package containerd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/containerd/containerd/containers\"\n)\n\ntype containerdClientMock struct {\n\tcntrs     map[string]*containers.Container\n\treturnErr error\n}\n\nfunc (c *containerdClientMock) LoadContainer(ctx context.Context, id string) (*containers.Container, error) {\n\tif c.returnErr != nil {\n\t\treturn nil, c.returnErr\n\t}\n\tcntr, ok := c.cntrs[id]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"unable to find container %q\", id)\n\t}\n\treturn cntr, nil\n}\n\nfunc (c *containerdClientMock) Version(ctx context.Context) (string, error) {\n\treturn \"test-v0.0.0\", nil\n}\n\n\n\nfunc mockcontainerdClient(cntrs map[string]*containers.Container, returnErr error) containerdClient {\n\treturn &containerdClientMock{\n\t\tcntrs:     cntrs,\n\t\treturnErr: returnErr,\n\t}\n}\n\nfunc (c *containerdClientMock) TaskPid(ctx context.Context, id string) (uint32, error) ", "output": "{\n\treturn 2389, nil\n}"}
{"input": "package v1beta1\n\nimport (\n\tv1beta1 \"k8s.io/api/certificates/v1beta1\"\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"github.com/hyperhq/client-go/tools/cache\"\n)\n\n\ntype CertificateSigningRequestLister interface {\n\tList(selector labels.Selector) (ret []*v1beta1.CertificateSigningRequest, err error)\n\tGet(name string) (*v1beta1.CertificateSigningRequest, error)\n\tCertificateSigningRequestListerExpansion\n}\n\n\ntype certificateSigningRequestLister struct {\n\tindexer cache.Indexer\n}\n\n\n\n\n\nfunc (s *certificateSigningRequestLister) List(selector labels.Selector) (ret []*v1beta1.CertificateSigningRequest, err error) {\n\terr = cache.ListAll(s.indexer, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*v1beta1.CertificateSigningRequest))\n\t})\n\treturn ret, err\n}\n\n\nfunc (s *certificateSigningRequestLister) Get(name string) (*v1beta1.CertificateSigningRequest, error) {\n\tobj, exists, err := s.indexer.GetByKey(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn nil, errors.NewNotFound(v1beta1.Resource(\"certificatesigningrequest\"), name)\n\t}\n\treturn obj.(*v1beta1.CertificateSigningRequest), nil\n}\n\nfunc NewCertificateSigningRequestLister(indexer cache.Indexer) CertificateSigningRequestLister ", "output": "{\n\treturn &certificateSigningRequestLister{indexer: indexer}\n}"}
{"input": "package rest\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/tliron/kutil/js\"\n\t\"github.com/tliron/kutil/util\"\n)\n\n\n\n\n\ntype HandleFunc func(context *Context) bool\n\n\nfunc Handled(context *Context) bool {\n\treturn true\n}\n\n\n\n\n\ntype Handler interface {\n\tHandle(context *Context) bool\n}\n\n\n\n\n\n\n\nvar DefaultNotFound defaultNotFound\n\ntype defaultNotFound struct{}\n\n\n\nfunc (self defaultNotFound) Handle(context *Context) bool {\n\tcontext.Response.Buffer = bytes.NewBuffer(util.StringToBytes(\"404 Not Found\\n\"))\n\tcontext.Response.Status = http.StatusNotFound\n\treturn true\n}\n\nfunc GetHandleFunc(value interface{}, jsContext *js.Context) (HandleFunc, error) ", "output": "{\n\tif bind, ok := value.(js.Bind); ok {\n\t\tvar err error\n\t\tif value, jsContext, err = bind.Unbind(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif handler, ok := value.(Handler); ok {\n\t\treturn handler.Handle, nil\n\t} else if function, ok := value.(js.JavaScriptFunc); ok {\n\t\treturn func(context *Context) bool {\n\t\t\thandled := jsContext.Environment.Call(function, context)\n\t\t\tif handled_, ok := handled.(bool); ok {\n\t\t\t\treturn handled_\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}, nil\n\t} else {\n\t\treturn nil, fmt.Errorf(\"not a handler or a function: %T\", value)\n\t}\n}"}
{"input": "package fake\n\nimport (\n\tv1 \"k8s.io/client-go/kubernetes/typed/apps/v1\"\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n)\n\ntype FakeAppsV1 struct {\n\t*testing.Fake\n}\n\nfunc (c *FakeAppsV1) ControllerRevisions(namespace string) v1.ControllerRevisionInterface {\n\treturn &FakeControllerRevisions{c, namespace}\n}\n\nfunc (c *FakeAppsV1) DaemonSets(namespace string) v1.DaemonSetInterface {\n\treturn &FakeDaemonSets{c, namespace}\n}\n\nfunc (c *FakeAppsV1) Deployments(namespace string) v1.DeploymentInterface {\n\treturn &FakeDeployments{c, namespace}\n}\n\nfunc (c *FakeAppsV1) ReplicaSets(namespace string) v1.ReplicaSetInterface {\n\treturn &FakeReplicaSets{c, namespace}\n}\n\nfunc (c *FakeAppsV1) StatefulSets(namespace string) v1.StatefulSetInterface {\n\treturn &FakeStatefulSets{c, namespace}\n}\n\n\n\n\n\nfunc (c *FakeAppsV1) RESTClient() rest.Interface ", "output": "{\n\tvar ret *rest.RESTClient\n\treturn ret\n}"}
{"input": "package gopmod\n\nimport (\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/token\"\n)\n\n\n\ntype none = struct{}\n\nfunc (p *Module) parseGoImport(errs *ErrorList, getImports getImportsFunc, gopfile string) {\n\tf, err := parser.ParseFile(p.fset, gopfile, nil, parser.ImportsOnly)\n\tif err != nil {\n\t\t*errs = append(*errs, err)\n\t\treturn\n\t}\n\timports := getImports(f.Name.Name)\n\tfor _, imp := range f.Imports {\n\t\tp.importGo(imports, imp)\n\t}\n}\n\nfunc (p *Module) importGo(imports map[string]none, spec *ast.ImportSpec) {\n\tpkgPath := p.canonicalGo(goToString(spec.Path))\n\timports[pkgPath] = none{}\n}\n\n\n\nfunc goToString(l *ast.BasicLit) string {\n\tif l.Kind == token.STRING {\n\t\ts, err := strconv.Unquote(l.Value)\n\t\tif err == nil {\n\t\t\treturn s\n\t\t}\n\t}\n\tpanic(\"TODO: toString - convert ast.BasicLit to string failed\")\n}\n\nfunc (p *Module) canonicalGo(pkgPath string) string ", "output": "{\n\tif strings.HasPrefix(pkgPath, \".\") {\n\t\treturn path.Join(p.Path(), pkgPath)\n\t}\n\treturn pkgPath\n}"}
{"input": "package main\n\nimport \"time\"\n\n\n\nfunc microseconds(n int) time.Duration {\n\treturn time.Duration(n) * time.Microsecond\n}\n\nfunc milliseconds(n int) time.Duration {\n\treturn time.Duration(n) * time.Millisecond\n}\n\nfunc seconds(n int) time.Duration {\n\treturn time.Duration(n) * time.Second\n}\n\nfunc minutes(n int) time.Duration {\n\treturn time.Duration(n) * time.Minute\n}\n\nfunc hours(n int) time.Duration {\n\treturn time.Duration(n) * time.Hour\n}\n\nfunc nanoseconds(n int) time.Duration ", "output": "{\n\treturn time.Duration(n) * time.Nanosecond\n}"}
{"input": "package metadata\n\nimport (\n\t\"time\"\n)\n\n\n\n\ntype AttemptStrategy struct {\n\tTotal time.Duration \n\tDelay time.Duration \n\tMin   int           \n}\n\n\ntype Attempt struct {\n\tstrategy AttemptStrategy\n\tlast     time.Time\n\tend      time.Time\n\tforce    bool\n\tcount    int\n}\n\n\nfunc (s AttemptStrategy) Start() *Attempt {\n\tnow := time.Now()\n\treturn &Attempt{\n\t\tstrategy: s,\n\t\tlast:     now,\n\t\tend:      now.Add(s.Total),\n\t\tforce:    true,\n\t}\n}\n\n\n\n\n\nfunc (a *Attempt) nextSleep(now time.Time) time.Duration {\n\tsleep := a.strategy.Delay - now.Sub(a.last)\n\tif sleep < 0 {\n\t\treturn 0\n\t}\n\treturn sleep\n}\n\n\n\n\nfunc (a *Attempt) HasNext() bool {\n\tif a.force || a.strategy.Min > a.count {\n\t\treturn true\n\t}\n\tnow := time.Now()\n\tif now.Add(a.nextSleep(now)).Before(a.end) {\n\t\ta.force = true\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (a *Attempt) Next() bool ", "output": "{\n\tnow := time.Now()\n\tsleep := a.nextSleep(now)\n\tif !a.force && !now.Add(sleep).Before(a.end) && a.strategy.Min <= a.count {\n\t\treturn false\n\t}\n\ta.force = false\n\tif sleep > 0 && a.count > 0 {\n\t\ttime.Sleep(sleep)\n\t\tnow = time.Now()\n\t}\n\ta.count++\n\ta.last = now\n\treturn true\n}"}
{"input": "package client\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/docker/engine-api/types\"\n)\n\n\n\n\n\nfunc (cli *Client) ContainerExecStart(execID string, config types.ExecStartCheck) error {\n\tresp, err := cli.post(\"/exec/\"+execID+\"/start\", nil, config, nil)\n\tensureReaderClosed(resp)\n\treturn err\n}\n\n\n\n\n\nfunc (cli *Client) ContainerExecAttach(execID string, config types.ExecConfig) (types.HijackedResponse, error) {\n\theaders := map[string][]string{\"Content-Type\": {\"application/json\"}}\n\treturn cli.postHijacked(\"/exec/\"+execID+\"/start\", nil, config, headers)\n}\n\n\nfunc (cli *Client) ContainerExecInspect(execID string) (types.ContainerExecInspect, error) {\n\tvar response types.ContainerExecInspect\n\tresp, err := cli.get(\"/exec/\"+execID+\"/json\", nil, nil)\n\tif err != nil {\n\t\treturn response, err\n\t}\n\tdefer ensureReaderClosed(resp)\n\n\terr = json.NewDecoder(resp.body).Decode(&response)\n\treturn response, err\n}\n\nfunc (cli *Client) ContainerExecCreate(config types.ExecConfig) (types.ContainerExecCreateResponse, error) ", "output": "{\n\tvar response types.ContainerExecCreateResponse\n\tresp, err := cli.post(\"/containers/\"+config.Container+\"/exec\", nil, config, nil)\n\tif err != nil {\n\t\treturn response, err\n\t}\n\tdefer ensureReaderClosed(resp)\n\terr = json.NewDecoder(resp.body).Decode(&response)\n\treturn response, err\n}"}
{"input": "package setting\n\nvar (\n\tAttachment = struct {\n\t\tStorage\n\t\tAllowedTypes string\n\t\tMaxSize      int64\n\t\tMaxFiles     int\n\t\tEnabled      bool\n\t}{\n\t\tStorage: Storage{\n\t\t\tServeDirect: false,\n\t\t},\n\t\tAllowedTypes: \"image/jpeg,image/png,application/zip,application/gzip\",\n\t\tMaxSize:      4,\n\t\tMaxFiles:     5,\n\t\tEnabled:      true,\n\t}\n)\n\n\n\nfunc newAttachmentService() ", "output": "{\n\tsec := Cfg.Section(\"attachment\")\n\tstorageType := sec.Key(\"STORAGE_TYPE\").MustString(\"\")\n\n\tAttachment.Storage = getStorage(\"attachments\", storageType, sec)\n\n\tAttachment.AllowedTypes = sec.Key(\"ALLOWED_TYPES\").MustString(\".docx,.gif,.gz,.jpeg,.jpg,.log,.pdf,.png,.pptx,.txt,.xlsx,.zip\")\n\tAttachment.MaxSize = sec.Key(\"MAX_SIZE\").MustInt64(4)\n\tAttachment.MaxFiles = sec.Key(\"MAX_FILES\").MustInt(5)\n\tAttachment.Enabled = sec.Key(\"ENABLED\").MustBool(true)\n}"}
{"input": "package userSystem\n\nimport (\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"github.com/oxfeeefeee/appgo\"\n)\n\ntype defaultKvStore map[string]string\n\nfunc (kv defaultKvStore) Set(k, v string, timeout int) error {\n\tkv[k] = v\n\treturn nil\n}\n\nfunc (kv defaultKvStore) Get(k string) (string, error) {\n\tv := kv[k]\n\treturn v, nil\n}\n\ntype defaultSender struct{}\n\nfunc (s defaultSender) SendMobileCode(mobile string, template appgo.SmsTemplate, code string) error {\n\tlog.Infoln(\"SendMobileCode: \", mobile, \", \", template, \", \", code)\n\treturn nil\n}\n\ntype defaultPusher struct{}\n\nfunc (s defaultPusher) Name() string {\n\treturn \"default\"\n}\n\n\n\nfunc (s defaultPusher) PushNotif(pushInfo map[appgo.Id]*appgo.PushInfo, content *appgo.PushData) ", "output": "{\n\tlog.Infoln(\"PushNotif: \", pushInfo, \", \", content)\n}"}
{"input": "package debugtools\n\nimport (\n\t\"github.com/oakmound/oak/v3/render\"\n\t\"golang.org/x/sync/syncmap\"\n)\n\nvar (\n\tdebugMap syncmap.Map\n)\n\n\n\n\n\n\n\nfunc GetDebugRenderable(rName string) (render.Renderable, bool) {\n\tr, ok := debugMap.Load(rName)\n\tif r == nil {\n\t\treturn nil, false\n\t}\n\treturn r.(render.Renderable), ok\n}\n\n\n\nfunc EnumerateDebugRenderableKeys() []string {\n\tkeys := []string{}\n\tdebugMap.Range(func(k, v interface{}) bool {\n\t\tkey, ok := k.(string)\n\t\tif ok {\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t\treturn true\n\t})\n\treturn keys\n}\n\nfunc SetDebugRenderable(rName string, r render.Renderable) ", "output": "{\n\tdebugMap.Store(rName, r)\n}"}
{"input": "package bleve\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n)\n\nfunc lookupPropertyPath(data interface{}, path string) interface{} {\n\tpathParts := decodePath(path)\n\n\tcurrent := data\n\tfor _, part := range pathParts {\n\t\tcurrent = lookupProptyPathPart(current, part)\n\t\tif current == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn current\n}\n\nfunc lookupProptyPathPart(data interface{}, part string) interface{} {\n\tval := reflect.ValueOf(data)\n\ttyp := val.Type()\n\tswitch typ.Kind() {\n\tcase reflect.Map:\n\t\tif typ.Key().Kind() == reflect.String {\n\t\t\tkey := reflect.ValueOf(part)\n\t\t\tentry := val.MapIndex(key)\n\t\t\tif entry.IsValid() {\n\t\t\t\treturn entry.Interface()\n\t\t\t}\n\t\t}\n\tcase reflect.Struct:\n\t\tfield := val.FieldByName(part)\n\t\tif field.IsValid() && field.CanInterface() {\n\t\t\treturn field.Interface()\n\t\t}\n\t}\n\treturn nil\n}\n\nconst pathSeparator = \".\"\n\nfunc decodePath(path string) []string {\n\treturn strings.Split(path, pathSeparator)\n}\n\nfunc encodePath(pathElements []string) string {\n\treturn strings.Join(pathElements, pathSeparator)\n}\n\nfunc mustString(data interface{}) (string, bool) {\n\tif data != nil {\n\t\tstr, ok := data.(string)\n\t\tif ok {\n\t\t\treturn str, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n\n\n\nfunc parseJSONTagName(tag string) string ", "output": "{\n\tif idx := strings.Index(tag, \",\"); idx != -1 {\n\t\treturn tag[:idx]\n\t}\n\treturn tag\n}"}
{"input": "package syscallx\n\n\n\n\nimport (\n\t\"syscall\"\n)\n\nfunc Getxattr(path string, attr string, dest []byte) (sz int, err error) {\n\treturn syscall.Getxattr(path, attr, dest)\n}\n\nfunc Listxattr(path string, dest []byte) (sz int, err error) {\n\treturn syscall.Listxattr(path, dest)\n}\n\n\n\nfunc Removexattr(path string, attr string) (err error) {\n\treturn syscall.Removexattr(path, attr)\n}\n\nfunc Setxattr(path string, attr string, data []byte, flags int) (err error) ", "output": "{\n\treturn syscall.Setxattr(path, attr, data, flags)\n}"}
{"input": "package testutils\n\nimport (\n\t\"os\"\n\t\"stretchr/testify/assert\"\n\t\"testing\"\n)\n\nvar (\n\tdir TempDir\n)\n\nfunc TestMain(m *testing.M) {\n\tdir = NewTempDir()\n\n\tresult := m.Run()\n\n\tdir.Destroy()\n\n\tos.Exit(result)\n}\n\nfunc TestNewTempDir(t *testing.T) {\n\tassert := assert.New(t)\n\n\tt.Log(dir.GetPath())\n\n\tassert.IsType(TempDir{}, dir, \"Expected value to be of type TempDir\")\n\n\tif _, err := os.Stat(dir.GetPath()); os.IsNotExist(err) {\n\t\tassert.Fail(\"Expected temp directory to exist\", dir.GetPath())\n\t}\n}\n\n\n\nfunc TestDestroy(t *testing.T) {\n\tassert := assert.New(t)\n\n\tdir.Destroy()\n\n\tif _, err := os.Stat(dir.GetPath()); !os.IsNotExist(err) {\n\t\tassert.Fail(\"Expected temp directory to be removed\", dir.GetPath())\n\t}\n}\n\nfunc TestGetPath(t *testing.T) ", "output": "{\n\tassert.Equal(t, dir.GetPath(), dir.GetPath(), \"Expected multiple calls to TempDir.GetPath to be equal\")\n}"}
{"input": "package assets\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n)\n\n\n\nfunc JavascriptTag(url string) template.HTML {\n\treturn template.HTML(\n\t\tfmt.Sprintf(`<script src=\"%s\" type=\"text/javascript\"></script>`, template.HTMLEscaper(url)))\n}\n\nfunc StylesheetTag(url string) template.HTML ", "output": "{\n\treturn template.HTML(\n\t\tfmt.Sprintf(`<link href=\"%s\" rel=\"stylesheet\" type=\"text/css\">`, template.HTMLEscaper(url)))\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype Minutes int\ntype Hours int\ntype Weight float64\ntype Title string\ntype Answer bool\n\nfunc main() {\n\tminutes := Minutes(1)\n\thours := Hours(2)\n\tweight := Weight(145.5)\n\tname := Title(\"the matrix\")\n\tanswer := Answer(true)\n\tfmt.Println(minutes, hours, weight, name, answer)\n\n\tfmt.Println(name.FixCase())\n\n\tfor i := 1; i <= 3; i++ {\n\t\tminutes.Increment()\n\t\tfmt.Println(minutes)\n\t}\n}\n\n\n\nfunc (m *Minutes) Increment() {\n\t*m = (*m + 1) % 60\n}\n\nfunc (t Title) FixCase() string ", "output": "{\n\treturn strings.Title(string(t))\n}"}
{"input": "package twilio\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestTimestamp_IsZero(t *testing.T) {\n\tm := &Timestamp{}\n\tif !m.IsZero() {\n\t\tt.Error(\"Timestamp.IsZero() should be true\")\n\t}\n\n\tp := &Timestamp{Time: time.Date(2013, 4, 87, 21, 10, 56, 0, time.UTC)}\n\tif p.IsZero() {\n\t\tt.Error(\"Timestamp.IsZero() should be false\")\n\t}\n}\n\n\n\nfunc TestTimestamp_UnmarshalJSON_badString(t *testing.T) {\n\tm := &Timestamp{}\n\terr := m.UnmarshalJSON([]byte(\"foo/02/03\"))\n\tif err != nil {\n\t\tt.Error(\"Price.UnmarshalJSON returned an error %q\", err)\n\t}\n\n\twant := Timestamp{}\n\tif !m.Equal(want) {\n\t\tt.Errorf(\"Time.UnmarshalJSON returned %+v, want %+v\", m, want)\n\t}\n}\n\nfunc TestTimestamp_UnmarshalJSON_string(t *testing.T) ", "output": "{\n\tm := &Timestamp{}\n\terr := m.UnmarshalJSON([]byte(\"Wed, 18 Aug 2010 20:01:40 +0000\"))\n\tif err != nil {\n\t\tt.Error(\"Price.UnmarshalJSON returned an error %q\", err)\n\t}\n\n\twant := parseTimestamp(\"Wed, 18 Aug 2010 20:01:40 +0000\")\n\tif !m.Equal(want) {\n\t\tt.Errorf(\"Time.UnmarshalJSON returned %+v, want %+v\", m, want)\n\t}\n}"}
{"input": "package flock\n\nimport (\n\t\"syscall\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (f *Flock) Unlock() error {\n\tf.m.Lock()\n\tdefer f.m.Unlock()\n\n\tif !f.l || f.fh == nil {\n\t\treturn nil\n\t}\n\n\tif err := syscall.Flock(int(f.fh.Fd()), syscall.LOCK_UN); err != nil {\n\t\treturn err\n\t}\n\n\tf.fh.Close()\n\n\tf.l = false\n\tf.fh = nil\n\n\treturn nil\n}\n\n\n\n\n\n\n\n\n\nfunc (f *Flock) TryLock() (bool, error) {\n\tf.m.Lock()\n\tdefer f.m.Unlock()\n\n\tif f.l {\n\t\treturn true, nil\n\t}\n\n\tif f.fh == nil {\n\t\tif err := f.setFh(); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\terr := syscall.Flock(int(f.fh.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)\n\n\tswitch err {\n\tcase syscall.EWOULDBLOCK:\n\t\treturn false, nil\n\tcase nil:\n\t\tf.l = true\n\t\treturn true, nil\n\t}\n\n\treturn false, err\n}\n\nfunc (f *Flock) Lock() error ", "output": "{\n\tf.m.Lock()\n\tdefer f.m.Unlock()\n\n\tif f.l {\n\t\treturn nil\n\t}\n\n\tif f.fh == nil {\n\t\tif err := f.setFh(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := syscall.Flock(int(f.fh.Fd()), syscall.LOCK_EX); err != nil {\n\t\treturn err\n\t}\n\n\tf.l = true\n\treturn nil\n}"}
{"input": "package router\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/facebookgo/inject\"\n\t\"github.com/facebookgo/structtag\"\n)\n\n\n\ntype HandlerInjector struct {\n\tServiceGraph    *inject.Graph\n\tPreprocessorMap *PreprocessorRegistry\n}\n\n\n\nfunc (i *HandlerInjector) InjectProcessors(h Handler) Handler {\n\tt := reflect.TypeOf(h)\n\treflectValue := reflect.ValueOf(h)\n\tfor c := 0; c < t.Elem().NumField(); c++ {\n\t\tfieldTag := t.Elem().Field(c).Tag\n\t\tfound, value, err := structtag.Extract(\"preprocessor\", string(fieldTag))\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"Unable to set up handler: %v\", err))\n\t\t}\n\t\tif found {\n\t\t\tprocessorField := reflectValue.Elem().Field(c)\n\t\t\tprocessor := reflect.ValueOf((*i.PreprocessorMap)[value])\n\t\t\tprocessorField.Set(processor)\n\t\t}\n\t}\n\th.Setup()\n\treturn h\n}\n\nfunc (i *HandlerInjector) Inject(h Handler) Handler {\n\ti.InjectServices(h)\n\ti.InjectProcessors(h)\n\treturn h\n}\n\nfunc (i *HandlerInjector) InjectServices(h Handler) Handler ", "output": "{\n\terr := i.ServiceGraph.Provide(&inject.Object{Value: h})\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Unable to set up handler: %v\", err))\n\t}\n\n\terr = i.ServiceGraph.Populate()\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Unable to set up handler: %v\", err))\n\t}\n\treturn h\n}"}
{"input": "package main\n\nimport (\n  \"os\"\n  \"os/exec\"\n  \"log\"\n)\n\n\n\nfunc mvim(files []string) {\n  for i := 0 ; i < len(files) ; i++ {\n    cmd := exec.Command(\"mvim\", files[i])\n    err := cmd.Run()\n    if err != nil {\n      log.Fatal(err)\n    }\n  }\n}\n\nfunc vim(files []string) ", "output": "{\n  for i := 0 ; i < len(files) ; i++ {\n    cmd := exec.Command(\"vim\", files[i])\n    cmd.Stdin = os.Stdin\n    cmd.Stdout = os.Stdout\n    cmd.Stderr = os.Stderr\n    err := cmd.Run()\n    if err != nil {\n      log.Fatal(err)\n    }\n    if i != len(files) - 1 {\n      check_if_continue()\n    }\n  }\n}"}
{"input": "package stats\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\n\tmultierror \"github.com/hashicorp/go-multierror\"\n\t\"github.com/shirou/gopsutil/cpu\"\n)\n\nvar (\n\tcpuMhzPerCore float64\n\tcpuModelName  string\n\tcpuNumCores   int\n\tcpuTotalTicks float64\n\n\tinitErr error\n\tonceLer sync.Once\n)\n\nfunc Init() error {\n\tonceLer.Do(func() {\n\t\tvar merrs *multierror.Error\n\t\tvar err error\n\t\tif cpuNumCores, err = cpu.Counts(true); err != nil {\n\t\t\tmerrs = multierror.Append(merrs, fmt.Errorf(\"Unable to determine the number of CPU cores available: %v\", err))\n\t\t}\n\n\t\tvar cpuInfo []cpu.InfoStat\n\t\tif cpuInfo, err = cpu.Info(); err != nil {\n\t\t\tmerrs = multierror.Append(merrs, fmt.Errorf(\"Unable to obtain CPU information: %v\", initErr))\n\t\t}\n\n\t\tfor _, cpu := range cpuInfo {\n\t\t\tcpuModelName = cpu.ModelName\n\t\t\tcpuMhzPerCore = cpu.Mhz\n\t\t\tbreak\n\t\t}\n\n\t\tcpuMhzPerCore = math.Floor(cpuMhzPerCore)\n\t\tcpuTotalTicks = math.Floor(float64(cpuNumCores) * cpuMhzPerCore)\n\n\t\tinitErr = merrs.ErrorOrNil()\n\t})\n\treturn initErr\n}\n\n\nfunc CPUNumCores() int {\n\treturn cpuNumCores\n}\n\n\nfunc CPUMHzPerCore() float64 {\n\treturn cpuMhzPerCore\n}\n\n\nfunc CPUModelName() string {\n\treturn cpuModelName\n}\n\n\n\n\nfunc TotalTicksAvailable() float64 ", "output": "{\n\treturn cpuTotalTicks\n}"}
{"input": "package rafthttp\n\nimport (\n\t\"github.com/absolute8511/ZanRedisDB/pkg/types\"\n\t\"github.com/absolute8511/ZanRedisDB/raft/raftpb\"\n)\n\ntype remote struct {\n\tid       types.ID\n\tstatus   *peerStatus\n\tpipeline *pipeline\n}\n\nfunc startRemote(tr *Transport, urls types.URLs, id types.ID) *remote {\n\tpicker := newURLPicker(urls)\n\tstatus := newPeerStatus(id)\n\tpipeline := &pipeline{\n\t\tpeerID: id,\n\t\ttr:     tr,\n\t\tpicker: picker,\n\t\tstatus: status,\n\t\traft:   tr.Raft,\n\t\terrorc: tr.ErrorC,\n\t}\n\tpipeline.start()\n\n\treturn &remote{\n\t\tid:       id,\n\t\tstatus:   status,\n\t\tpipeline: pipeline,\n\t}\n}\n\nfunc (g *remote) send(m raftpb.Message) {\n\tselect {\n\tcase g.pipeline.msgc <- m:\n\tdefault:\n\t\tif g.status.isActive() {\n\t\t\tplog.MergeWarningf(\"dropped internal raft message to %s since sending buffer is full (bad/overloaded network)\", g.id)\n\t\t}\n\t\tplog.Debugf(\"dropped %s to %s since sending buffer is full\", m.Type, g.id)\n\t}\n}\n\nfunc (g *remote) stop() {\n\tg.pipeline.stop()\n}\n\n\n\nfunc (g *remote) Resume() {\n\tg.pipeline.start()\n}\n\nfunc (g *remote) Pause() ", "output": "{\n\tg.stop()\n}"}
{"input": "package internal\n\nimport (\n\t\"encoding/json\"\n\t\"regexp\"\n)\n\ntype Pattern struct {\n\t*regexp.Regexp\n}\n\ntype CallBack func(g []string) error\n\n\n\nfunc (p *Pattern) UnmarshalJSON(text []byte) error {\n\tvar pattern string\n\tif err := json.Unmarshal(text, &pattern); err != nil {\n\t\treturn err\n\t}\n\n\tq, err := regexp.Compile(pattern)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.Regexp = q\n\treturn nil\n}\n\nfunc (p Pattern) IfMatches(s string, callback CallBack) error ", "output": "{\n\tif g := p.FindStringSubmatch(s); g != nil {\n\t\treturn callback(g)\n\t}\n\treturn nil\n}"}
{"input": "package github\n\nimport \"fmt\"\n\n\ntype Blob struct {\n\tContent  *string `json:\"content,omitempty\"`\n\tEncoding *string `json:\"encoding,omitempty\"`\n\tSHA      *string `json:\"sha,omitempty\"`\n\tSize     *int    `json:\"size,omitempty\"`\n\tURL      *string `json:\"url,omitempty\"`\n}\n\n\n\n\n\n\n\n\n\nfunc (s *GitService) CreateBlob(owner string, repo string, blob *Blob) (*Blob, *Response, error) {\n\tu := fmt.Sprintf(\"repos/%v/%v/git/blobs\", owner, repo)\n\treq, err := s.client.NewRequest(\"POST\", u, blob)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(Blob)\n\tresp, err := s.client.Do(req, t)\n\treturn t, resp, err\n}\n\nfunc (s *GitService) GetBlob(owner string, repo string, sha string) (*Blob, *Response, error) ", "output": "{\n\tu := fmt.Sprintf(\"repos/%v/%v/git/blobs/%v\", owner, repo, sha)\n\treq, err := s.client.NewRequest(\"GET\", u, nil)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tblob := new(Blob)\n\tresp, err := s.client.Do(req, blob)\n\treturn blob, resp, err\n}"}
{"input": "package data\n\nimport (\n\t\"context\"\n\t. \"github.com/smartystreets/goconvey/convey\"\n\t\"testing\"\n)\n\n\n\nfunc TestDao_MonitorNotify(t *testing.T) ", "output": "{\n\tConvey(\"MonitorNotify\", t, func() {\n\t\t_, err := d.MonitorNotify(context.TODO())\n\t\tSo(err, ShouldBeNil)\n\t})\n}"}
{"input": "package fuse\n\n\n\n\nfunc Unmount(dir string) error ", "output": "{\n\treturn unmount(dir)\n}"}
{"input": "package readline\n\n\nimport \"C\"\n\nimport (\n\t\"unsafe\"\n)\n\n\nfunc goCompletionEntryFunction(text *C.char, state C.int) *C.char {\n\tmatch := completionEntryFunction(C.GoString(text), int(state))\n\tif match == \"\" {\n\t\treturn nil\n\t}\n\treturn C.CString(match) \n}\n\n\n\n\n\n\n\n\n\n\n\ntype CompletionEntryFunction func(text string, state int) string\n\nvar completionEntryFunction CompletionEntryFunction\n\n\n\n\n\n\n\n\n\nfunc SetAttemptedCompletionOver(b bool) {\n\tif b {\n\t\tC.rl_attempted_completion_over = 1\n\t} else {\n\t\tC.rl_attempted_completion_over = 0\n\t}\n}\n\n\n\nfunc SetCompleterWordBreakChars(s string) {\n\tcs := C.CString(s)\n\tC.free(unsafe.Pointer(C.rl_completer_word_break_characters))\n\tC.rl_completer_word_break_characters = cs\n}\n\n\n\n\nfunc CompleterWordBreakChars() string {\n\treturn C.GoString(C.rl_completer_word_break_characters)\n}\n\nfunc SetCompletionEntryFunction(f CompletionEntryFunction) ", "output": "{\n\tif f == nil {\n\t\tif completionEntryFunction != nil {\n\t\t\tC.rl_attempted_completion_function = nil\n\t\t}\n\t} else if completionEntryFunction == nil {\n\t\tC.register_attempted_completion_function()\n\t}\n\tcompletionEntryFunction = f\n}"}
{"input": "package math\n\n\n\n\n\nfunc IntMax(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc IntMin(a, b int) int ", "output": "{\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/DeKugelschieber/go-game\"\n)\n\nconst (\n\tassets_dir = \"src/github.com/DeKugelschieber/go-game/demo/model/assets\"\n)\n\ntype Game struct {\n\tmodel *goga.Model\n}\n\nfunc (g *Game) Setup() {\n\terr := goga.LoadResFromFolder(assets_dir)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ttex, err := goga.GetTex(\"cube.png\")\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tply, err := goga.GetPly(\"cube.ply\")\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tmesh := goga.NewMesh(ply.IndexBuffer, ply.VertexBuffer, ply.TexCoordBuffer)\n\n\tmodel := goga.NewModel(mesh, tex)\n\trenderer := goga.GetModelRenderer()\n\trenderer.Prepare(model)\n\trenderer.Add(model.Actor, model.Pos3D, model.Tex, model.Mesh)\n\tg.model = model\n\n\tgoga.EnableDepthTest(true)\n\tgoga.ClearDepthBuffer(true)\n}\n\n\n\nfunc main() {\n\tgame := Game{}\n\toptions := goga.RunOptions{ClearColor: goga.Vec4{1, 1, 1, 0},\n\t\tResizable:           true,\n\t\tSetViewportOnResize: true,\n\t\tExitOnClose:         true}\n\tgoga.Run(&game, &options)\n}\n\nfunc (g *Game) Update(delta float64) ", "output": "{\n\tg.model.Rot.Z += delta * 45\n}"}
{"input": "package jujuclienttesting\n\nimport (\n\t\"github.com/juju/juju/core/model\"\n\tjc \"github.com/juju/testing/checkers\"\n\tgc \"gopkg.in/check.v1\"\n\n\t\"github.com/juju/juju/jujuclient\"\n)\n\n\n\nfunc MinimalStore() *jujuclient.MemStore {\n\tstore := jujuclient.NewMemStore()\n\tstore.CurrentControllerName = \"arthur\"\n\tstore.Controllers[\"arthur\"] = jujuclient.ControllerDetails{}\n\tstore.Models[\"arthur\"] = &jujuclient.ControllerModels{\n\t\tCurrentModel: \"king/sword\",\n\t\tModels: map[string]jujuclient.ModelDetails{\"king/sword\": {\n\t\t\tModelType:    model.IAAS,\n\t\t\tActiveBranch: model.GenerationMaster,\n\t\t}},\n\t}\n\tstore.Accounts[\"arthur\"] = jujuclient.AccountDetails{\n\t\tUser: \"king\",\n\t}\n\treturn store\n}\n\n\n\n\n\nfunc SetupMinimalFileStore(c *gc.C) ", "output": "{\n\tstore := MinimalStore()\n\terr := jujuclient.WriteControllersFile(&jujuclient.Controllers{\n\t\tControllers:       store.Controllers,\n\t\tCurrentController: store.CurrentControllerName,\n\t})\n\tc.Assert(err, jc.ErrorIsNil)\n\terr = jujuclient.WriteModelsFile(store.Models)\n\tc.Assert(err, jc.ErrorIsNil)\n\terr = jujuclient.WriteAccountsFile(store.Accounts)\n\tc.Assert(err, jc.ErrorIsNil)\n}"}
{"input": "package pubsub\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/libp2p/go-libp2p-core/peer\"\n\t\"github.com/whyrusleeping/timecache\"\n)\n\n\ntype Blacklist interface {\n\tAdd(peer.ID) bool\n\tContains(peer.ID) bool\n}\n\n\ntype MapBlacklist map[peer.ID]struct{}\n\n\nfunc NewMapBlacklist() Blacklist {\n\treturn MapBlacklist(make(map[peer.ID]struct{}))\n}\n\nfunc (b MapBlacklist) Add(p peer.ID) bool {\n\tb[p] = struct{}{}\n\treturn true\n}\n\nfunc (b MapBlacklist) Contains(p peer.ID) bool {\n\t_, ok := b[p]\n\treturn ok\n}\n\n\ntype TimeCachedBlacklist struct {\n\tsync.RWMutex\n\ttc *timecache.TimeCache\n}\n\n\nfunc NewTimeCachedBlacklist(expiry time.Duration) (Blacklist, error) {\n\tb := &TimeCachedBlacklist{tc: timecache.NewTimeCache(expiry)}\n\treturn b, nil\n}\n\n\nfunc (b *TimeCachedBlacklist) Add(p peer.ID) bool {\n\tb.Lock()\n\tdefer b.Unlock()\n\ts := p.String()\n\tif b.tc.Has(s) {\n\t\treturn false\n\t}\n\tb.tc.Add(s)\n\treturn true\n}\n\n\n\nfunc (b *TimeCachedBlacklist) Contains(p peer.ID) bool ", "output": "{\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\treturn b.tc.Has(p.String())\n}"}
{"input": "package refuseany\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/coredns/coredns/plugin\"\n\tclog \"github.com/coredns/coredns/plugin/pkg/log\"\n\t\"github.com/coredns/coredns/request\"\n\t\"github.com/miekg/dns\"\n\t\"golang.org/x/net/context\"\n)\n\n\n\n\nfunc (p *plug) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.Msg) (int, error) ", "output": "{\n\tif len(r.Question) != 1 {\n\t\treturn dns.RcodeFormatError, fmt.Errorf(\"got DNS request with != 1 questions\")\n\t}\n\n\tq := r.Question[0]\n\tif q.Qtype == dns.TypeANY {\n\t\trefusedAnyTotal.Inc()\n\n\t\tstate := request.Request{W: w, Req: r}\n\t\trcode := dns.RcodeNotImplemented\n\n\t\tm := new(dns.Msg)\n\t\tm.SetRcode(r, rcode)\n\t\tstate.SizeAndDo(m)\n\t\terr := state.W.WriteMsg(m)\n\t\tif err != nil {\n\t\t\tclog.Infof(\"Got error %s\\n\", err)\n\t\t\treturn dns.RcodeServerFailure, err\n\t\t}\n\t\treturn rcode, nil\n\t}\n\n\treturn plugin.NextOrFailure(p.Name(), p.Next, ctx, w, r)\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\t\"net\"\n\n\t\"aicode.cc/2016/socket/protocol\"\n)\n\nfunc reader(readerChan chan []byte) {\n\tfor {\n\t\tselect {\n\t\tcase data := <-readerChan:\n\t\t\tlog.Print(string(data))\n\t\t}\n\t}\n}\n\n\n\nfunc main() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tlog.Fatalf(\"Error: %v\", err)\n\t\t}\n\t}()\n\n\tnetListen, err := net.Listen(\"tcp\", \"localhost:10240\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer netListen.Close()\n\n\tlog.Print(\"Waiting for client...\")\n\tfor {\n\t\tconn, err := netListen.Accept()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Printf(\"%s tcp connect success\", conn.RemoteAddr().String())\n\t\thandleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) ", "output": "{\n\ttmpBuffer := make([]byte, 0)\n\treaderChan := make(chan []byte, 16)\n\n\tgo reader(readerChan)\n\n\tbuffer := make([]byte, 2048)\n\tfor {\n\t\tn, err := conn.Read(buffer)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"%s connection error: %v\", conn.RemoteAddr().String(), err)\n\t\t\treturn\n\t\t}\n\n\t\ttmpBuffer = protocol.Unpack(append(tmpBuffer, buffer[:n]...), readerChan)\n\t}\n}"}
{"input": "package wrappers\n\nimport (\n\t\"github.com/johanbrandhorst/protobuf/test/shared\"\n\t\"google.golang.org/grpc/metadata\"\n\n\ttestproto \"github.com/johanbrandhorst/protobuf/test/client/proto/test\"\n)\n\ntype pingBidiStreamWrapper struct {\n\tc testproto.TestService_PingBidiStreamClient\n}\n\nfunc (pcsw pingBidiStreamWrapper) Send(req *shared.Request) error {\n\treturn pcsw.c.Send(sharedToProtoReq(req))\n}\n\nfunc (pcsw pingBidiStreamWrapper) Recv() (*shared.Response, error) {\n\tresp, err := pcsw.c.Recv()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn (*shared.Response)(resp), nil\n}\n\nfunc (pcsw pingBidiStreamWrapper) Header() (metadata.MD, error) {\n\treturn pcsw.c.Header(), nil\n}\n\nfunc (pcsw pingBidiStreamWrapper) Trailer() metadata.MD {\n\treturn pcsw.c.Trailer()\n}\n\nfunc (pcsw pingBidiStreamWrapper) CloseSend() error {\n\treturn pcsw.c.CloseSend()\n}\n\ntype pingBidiStreamErrorWrapper struct {\n\tc testproto.TestService_PingBidiStreamErrorClient\n}\n\n\n\nfunc (pbsew pingBidiStreamErrorWrapper) Recv() (*shared.Response, error) {\n\tresp, err := pbsew.c.Recv()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn (*shared.Response)(resp), nil\n}\n\nfunc (pbsew pingBidiStreamErrorWrapper) CloseSend() error {\n\treturn pbsew.c.CloseSend()\n}\n\nfunc (pbsew pingBidiStreamErrorWrapper) Send(req *shared.Request) error ", "output": "{\n\treturn pbsew.c.Send(sharedToProtoReq(req))\n}"}
{"input": "package main\n\nimport (\n\t\"crypto/sha1\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar todo = make(chan string)\n\tgo produce(todo)\n\twork(todo)\n}\n\n\n\n\n\n\nfunc produce(todo chan string) {\n\tfor {\n\t\th := sha1.New()\n\t\tbuf := make([]byte, 8)\n\t\tcrand.Read(buf)\n\t\ttodo <- fmt.Sprintf(\"http://tyba.com/%x.png\", h.Sum(buf)[:2])\n\t}\n}\n\nfunc use(item string) {\n\n}\n\nfunc (f *Foo) work() ", "output": "{\n\tvar paused bool\n\tfor {\n\t\tvar todo chan string \n\t\tif !paused {         \n\t\t\ttodo = f.todo \n\t\t} \n\t\tselect {\n\t\tcase item := <-todo: \n\t\t\tgo use(item) \n\t\tcase <-pause:\n\t\t\tpaused = true\n\t\tcase <-resume:\n\t\t\tpaused = false\n\t\tcase <-time.After(5 * time.Second):\n\t\t}\n\t}\n}"}
{"input": "package v1beta1\n\nimport (\n\tv1beta1 \"k8s.io/api/scheduling/v1beta1\"\n\tserializer \"k8s.io/apimachinery/pkg/runtime/serializer\"\n\t\"k8s.io/client-go/kubernetes/scheme\"\n\trest \"k8s.io/client-go/rest\"\n)\n\ntype SchedulingV1beta1Interface interface {\n\tRESTClient() rest.Interface\n\tPriorityClassesGetter\n}\n\n\ntype SchedulingV1beta1Client struct {\n\trestClient rest.Interface\n}\n\nfunc (c *SchedulingV1beta1Client) PriorityClasses() PriorityClassInterface {\n\treturn newPriorityClasses(c)\n}\n\n\n\n\n\n\nfunc NewForConfigOrDie(c *rest.Config) *SchedulingV1beta1Client {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n\n\nfunc New(c rest.Interface) *SchedulingV1beta1Client {\n\treturn &SchedulingV1beta1Client{c}\n}\n\nfunc setConfigDefaults(config *rest.Config) error {\n\tgv := v1beta1.SchemeGroupVersion\n\tconfig.GroupVersion = &gv\n\tconfig.APIPath = \"/apis\"\n\tconfig.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: scheme.Codecs}\n\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = rest.DefaultKubernetesUserAgent()\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (c *SchedulingV1beta1Client) RESTClient() rest.Interface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.restClient\n}\n\nfunc NewForConfig(c *rest.Config) (*SchedulingV1beta1Client, error) ", "output": "{\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := rest.RESTClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &SchedulingV1beta1Client{client}, nil\n}"}
{"input": "package compute\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\nfunc New(subscriptionID string) BaseClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient ", "output": "{\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}"}
{"input": "package jchash\n\nimport (\n\t\"errors\"\n\t\"github.com/spaolacci/murmur3\"\n)\n\nfunc JumpConsistentHashStr(key string, num_buckets uint64) (uint64, error) {\n\treturn JumpConsistentHash(murmur3.Sum64([]byte(key)), num_buckets)\n}\n\nfunc JumpConsistentHashInt(key, num_buckets uint64) (uint64, error) {\n\tvar b, j uint64 = 0, 0\n\terr := errors.New(\"error invalid bucket size specified\")\n\tfor j < num_buckets {\n\t\tb = j\n\t\tkey = key*2862933555777941757 + 1\n\t\tj = (b + 1) * uint64(float64(1<<31)/float64((key>>33)+1))\n\t\terr = nil\n\t}\n\treturn b, err\n}\n\n\n\nfunc JumpConsistentHash(key interface{}, num_buckets uint64) (uint64, error) ", "output": "{\n\tswitch k := key.(type) {\n\tcase string:\n\t\treturn JumpConsistentHashStr(k, num_buckets)\n\tcase uint64:\n\t\treturn JumpConsistentHashInt(k, num_buckets)\n\t}\n\treturn 0, errors.New(\"Invalid Type Specified\")\n}"}
{"input": "package repository\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n\t\"path\"\n\n\t\"github.com/tsuru/config\"\n\t\"github.com/tsuru/gandalf/fs\"\n)\n\nvar bare string\n\nfunc bareLocation() string {\n\tif bare != \"\" {\n\t\treturn bare\n\t}\n\tvar err error\n\tbare, err = config.GetString(\"git:bare:location\")\n\tif err != nil {\n\t\tpanic(\"You should configure a git:bare:location for gandalf.\")\n\t}\n\treturn bare\n}\n\nfunc barePath(name string) string {\n\treturn path.Join(bareLocation(), name+\".git\")\n}\n\nfunc newBare(name string) error {\n\targs := []string{\"init\", barePath(name), \"--bare\"}\n\tif bareTempl, err := config.GetString(\"git:bare:template\"); err == nil {\n\t\targs = append(args, \"--template=\"+bareTempl)\n\t}\n\tcmd := exec.Command(\"git\", args...)\n\tout, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Could not create git bare repository: %s. %s\", err, string(out))\n\t}\n\treturn nil\n}\n\n\n\nfunc removeBare(name string) error ", "output": "{\n\terr := fs.Filesystem().RemoveAll(barePath(name))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Could not remove git bare repository: %s\", err)\n\t}\n\treturn nil\n}"}
{"input": "package v1alpha1\n\nimport (\n\t\"context\"\n\n\t\"k8s.io/apimachinery/pkg/api/equality\"\n\t\"knative.dev/pkg/apis\"\n\t\"knative.dev/serving/pkg/apis/serving\"\n)\n\n\n\n\n\nfunc (spec *ServerlessServiceSpec) Validate(ctx context.Context) *apis.FieldError {\n\tif equality.Semantic.DeepEqual(spec, &ServerlessServiceSpec{}) {\n\t\treturn apis.ErrMissingField(apis.CurrentField)\n\t}\n\tvar all *apis.FieldError\n\tswitch spec.Mode {\n\tcase SKSOperationModeProxy, SKSOperationModeServe:\n\t\tbreak\n\tcase \"\":\n\t\tall = all.Also(apis.ErrMissingField(\"mode\"))\n\tdefault:\n\t\tall = all.Also(apis.ErrInvalidValue(spec.Mode, \"mode\"))\n\t}\n\n\tif spec.NumActivators < 0 {\n\t\tall = all.Also(apis.ErrInvalidValue(spec.NumActivators, \"numActivators\"))\n\t}\n\n\tall = all.Also(serving.ValidateNamespacedObjectReference(&spec.ObjectRef).ViaField(\"objectRef\"))\n\n\treturn all.Also(spec.ProtocolType.Validate(ctx).ViaField(\"protocolType\"))\n}\n\nfunc (ci *ServerlessService) Validate(ctx context.Context) *apis.FieldError ", "output": "{\n\treturn ci.Spec.Validate(apis.WithinSpec(ctx)).ViaField(\"spec\")\n}"}
{"input": "package sys\n\nimport \"github.com/e-XpertSolutions/f5-rest-client/f5\"\n\n\ntype SFlowConfigList struct {\n\tItems    []SFlowConfig `json:\"items\"`\n\tKind     string        `json:\"kind\"`\n\tSelfLink string        `json:\"selflink\"`\n}\n\n\ntype SFlowConfig struct {\n\tReference struct {\n\t\tLink string `json:\"link\"`\n\t} `json:\"reference\"`\n}\n\n\nconst SFlowEndpoint = \"/sflow\"\n\n\ntype SFlowResource struct {\n\tc *f5.Client\n}\n\n\nfunc (r *SFlowResource) ListAll() (*SFlowConfigList, error) {\n\tvar list SFlowConfigList\n\tif err := r.c.ReadQuery(BasePath+SFlowEndpoint, &list); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &list, nil\n}\n\n\n\n\n\nfunc (r *SFlowResource) Create(item SFlowConfig) error {\n\tif err := r.c.ModQuery(\"POST\", BasePath+SFlowEndpoint, item); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\nfunc (r *SFlowResource) Edit(id string, item SFlowConfig) error {\n\tif err := r.c.ModQuery(\"PUT\", BasePath+SFlowEndpoint+\"/\"+id, item); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\nfunc (r *SFlowResource) Delete(id string) error {\n\tif err := r.c.ModQuery(\"DELETE\", BasePath+SFlowEndpoint+\"/\"+id, nil); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (r *SFlowResource) Get(id string) (*SFlowConfig, error) ", "output": "{\n\tvar item SFlowConfig\n\tif err := r.c.ReadQuery(BasePath+SFlowEndpoint, &item); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &item, nil\n}"}
{"input": "package pipedrive\n\nimport \"time\"\n\ntype Time struct {\n\ttime.Time\n}\n\nfunc NewTime(t time.Time) Time {\n\treturn Time{t}\n}\n\n\n\nfunc (t *Time) String() string {\n\tif t == nil {\n\t\treturn \"\"\n\t}\n\treturn t.Time.Local().Format(\"2006-01-02 15:04:05\")\n}\n\ntype Date struct {\n\ttime.Time\n}\n\nfunc NewDate(t time.Time) Date {\n\treturn Date{t}\n}\n\nfunc (t *Date) UnmarshalJSON(buf []byte) error {\n\ttt, err := time.Parse(\"2006-01-02\", string(buf[1:len(buf)-1]))\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.Time = tt\n\treturn nil\n}\n\nfunc (t *Date) String() string {\n\tif t == nil {\n\t\treturn \"\"\n\t}\n\treturn t.Time.Local().Format(\"2006-01-02\")\n}\n\nfunc (t *Time) UnmarshalJSON(buf []byte) error ", "output": "{\n\ttt, err := time.Parse(\"2006-01-02 15:04:05\", string(buf[1:len(buf)-1]))\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.Time = tt\n\treturn nil\n}"}
{"input": "package indexing\n\nimport (\n\t\"bytes\"\n\t\"net/mail\"\n\t\"os\"\n)\n\ntype Document struct {\n\tPath    string\n\tContent string\n}\n\n\n\nfunc LoadFromMail(path string) (*Document, error) {\n\treturn LoadFromFile(path, func(file *os.File) (string, error) {\n\t\tmsg, err := mail.ReadMessage(file)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tbuf := new(bytes.Buffer)\n\t\tbuf.ReadFrom(msg.Body)\n\n\t\treturn string(buf.Bytes()), nil\n\t})\n}\n\nfunc LoadFromFile(path string, transform func(*os.File) (string, error)) (*Document, error) ", "output": "{\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tcontent, err := transform(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Document{path, content}, nil\n}"}
{"input": "package etchosts\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestBuildHostnameDomainname(t *testing.T) {\n\tfile, err := ioutil.TempFile(\"\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(file.Name())\n\n\terr = Build(file.Name(), \"10.11.12.13\", \"testhostname\", \"testdomainname\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcontent, err := ioutil.ReadFile(file.Name())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif expected := \"10.11.12.13\\ttesthostname.testdomainname testhostname\\n\"; !bytes.Contains(content, []byte(expected)) {\n\t\tt.Fatalf(\"Expected to find '%s' got '%s'\", expected, content)\n\t}\n}\n\n\n\nfunc TestBuildNoIP(t *testing.T) {\n\tfile, err := ioutil.TempFile(\"\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(file.Name())\n\n\terr = Build(file.Name(), \"\", \"testhostname\", \"\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcontent, err := ioutil.ReadFile(file.Name())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif expected := \"\"; !bytes.Contains(content, []byte(expected)) {\n\t\tt.Fatalf(\"Expected to find '%s' got '%s'\", expected, content)\n\t}\n}\n\nfunc TestBuildHostname(t *testing.T) ", "output": "{\n\tfile, err := ioutil.TempFile(\"\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(file.Name())\n\n\terr = Build(file.Name(), \"10.11.12.13\", \"testhostname\", \"\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcontent, err := ioutil.ReadFile(file.Name())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif expected := \"10.11.12.13\\ttesthostname\\n\"; !bytes.Contains(content, []byte(expected)) {\n\t\tt.Fatalf(\"Expected to find '%s' got '%s'\", expected, content)\n\t}\n}"}
{"input": "package messages\n\nimport \"time\"\n\nconst nanosPerSecond = 1000000000\n\nfunc DurationToGoDuration(duration Duration) time.Duration {\n\tsecondNanos := duration.Seconds * nanosPerSecond\n\treturn time.Duration(secondNanos + int64(duration.Nanos))\n}\n\nfunc GoDurationToDuration(goDuration time.Duration) Duration {\n\tseconds := int64(goDuration / nanosPerSecond)\n\tnanos := int64(goDuration % nanosPerSecond)\n\treturn Duration{\n\t\tSeconds: seconds,\n\t\tNanos:   nanos,\n\t}\n}\n\n\n\nfunc GoTimeToTimestamp(t time.Time) Timestamp {\n\tunixNanos := t.UnixNano()\n\tseconds := unixNanos / nanosPerSecond\n\tnanos := unixNanos % nanosPerSecond\n\n\treturn Timestamp{\n\t\tSeconds: seconds,\n\t\tNanos:   nanos,\n\t}\n}\n\nfunc TimestampToGoTime(timestamp Timestamp) time.Time ", "output": "{\n\treturn time.Unix(timestamp.Seconds, timestamp.Nanos)\n}"}
{"input": "package main\n\nimport (\n\t. \"github.com/conclave/pcduino/core\"\n)\n\nfunc init() {\n\tInit()\n\tsetup()\n}\n\nfunc main() {\n\tfor {\n\t\tloop()\n\t}\n}\n\nvar touchPin byte = 1\nvar ledPin byte = 0\n\n\n\nfunc loop() {\n\tval := DigitalRead(touchPin)\n\tDigitalWrite(ledPin, val)\n}\n\nfunc setup() ", "output": "{\n\tprintln(\"Touch sensor test code!\")\n\tprintln(\"Using I/O_0=Drive LED, I/O_1=Sensor output.\")\n\tPinMode(touchPin, INPUT)\n\tPinMode(ledPin, OUTPUT)\n}"}
{"input": "package console\n\nimport (\n\t\"github.com/cgrates/cgrates/config\"\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\n\n\n\ntype CmdGetJSONConfig struct {\n\tname      string\n\trpcMethod string\n\trpcParams *config.StringWithArgDispatcher\n\t*CommandExecuter\n}\n\nfunc (self *CmdGetJSONConfig) Name() string {\n\treturn self.name\n}\n\nfunc (self *CmdGetJSONConfig) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\nfunc (self *CmdGetJSONConfig) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &config.StringWithArgDispatcher{ArgDispatcher: new(utils.ArgDispatcher)}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *CmdGetJSONConfig) PostprocessRpcParams() error {\n\treturn nil\n}\n\nfunc (self *CmdGetJSONConfig) RpcResult() interface{} {\n\tvar s map[string]interface{}\n\treturn &s\n}\n\nfunc init() ", "output": "{\n\tc := &CmdGetJSONConfig{\n\t\tname:      \"get_json_section\",\n\t\trpcMethod: utils.ConfigSv1GetJSONSection,\n\t\trpcParams: &config.StringWithArgDispatcher{},\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}"}
{"input": "package logger\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\ntype SysLogger struct {\n\twriter *log.Logger\n\tdebug  bool\n\ttrace  bool\n}\n\n\n\nfunc NewRemoteSysLogger(fqn string, debug, trace bool) *SysLogger {\n\treturn NewSysLogger(debug, trace)\n}\n\nfunc (l *SysLogger) Noticef(format string, v ...interface{}) {\n\tl.writer.Println(\"NOTICE\", fmt.Sprintf(format, v...))\n}\n\nfunc (l *SysLogger) Fatalf(format string, v ...interface{}) {\n\tl.writer.Println(\"CRITICAL\", fmt.Sprintf(format, v...))\n}\n\nfunc (l *SysLogger) Errorf(format string, v ...interface{}) {\n\tl.writer.Println(\"ERROR\", fmt.Sprintf(format, v...))\n}\n\nfunc (l *SysLogger) Debugf(format string, v ...interface{}) {\n\tif l.debug {\n\t\tl.writer.Println(\"DEBUG\", fmt.Sprintf(format, v...))\n\t}\n}\n\nfunc (l *SysLogger) Tracef(format string, v ...interface{}) {\n\tif l.trace {\n\t\tl.writer.Println(\"NOTICE\", fmt.Sprintf(format, v...))\n\t}\n}\n\nfunc NewSysLogger(debug, trace bool) *SysLogger ", "output": "{\n\tw := log.New(os.Stdout, \"gnatsd\", log.LstdFlags)\n\n\treturn &SysLogger{\n\t\twriter: w,\n\t\tdebug:  debug,\n\t\ttrace:  trace,\n\t}\n}"}
{"input": "package gphoto2go\n\nimport \"testing\"\n\n\n\nfunc TestCapturePreviewSanity(t *testing.T) ", "output": "{\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tt.Fatal(\"Expected capture to work\")\n\t\t}\n\t}()\n\tcam := &Camera{}\n\tcam.Init()\n\t_, i := cam.CapturePreview()\n\tif i != 0 {\n\t\tt.Fatalf(\"Expected 0, got %d. Camera must be on\", i)\n\t}\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/npiganeau/yep/yep/server\"\n\t\"github.com/npiganeau/yep/yep/tools/logging\"\n)\n\nvar log *logging.Logger\n\n\n\n\n\nfunc init() {\n\tlog = logging.GetLogger(\"controllers\")\n\tRegistry = newGroup(\"/\")\n}\n\nfunc BootStrap() ", "output": "{\n\tRegistry.createRoutes(server.GetServer().Group(\"/\"))\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"sync\"\n)\n\nvar a int = 1\n\nfunc main() {\n\truntime.GOMAXPROCS(runtime.NumCPU())\n\n\twg := sync.WaitGroup{}\n\n\twg.Add(10)\n\n\tfor i := 0; i < 10; i++ {\n\t\tgo GO(&wg, i)\n\t}\n\twg.Wait()\n}\n\n\n\nfunc GO(wg *sync.WaitGroup, index int) ", "output": "{\n\tfor i := 0; i < 100000000; i++ {\n\t\ta += i\n\t}\n\tfmt.Println(index, a)\n\twg.Done()\n}"}
{"input": "package v1\n\nimport (\n\t\"k8s.io/apimachinery/pkg/runtime\"\n)\n\n\n\nfunc addDefaultingFuncs(scheme *runtime.Scheme) error ", "output": "{\n\treturn nil\n}"}
{"input": "package common\n\nimport (\n\t\"fmt\"\n\n\tv1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/client-go/tools/cache\"\n\t\"k8s.io/component-helpers/storage/ephemeral\"\n)\n\nconst (\n\tPodPVCIndex = \"pod-pvc-index\"\n)\n\n\n\n\nfunc PodPVCIndexFunc() func(obj interface{}) ([]string, error) {\n\treturn func(obj interface{}) ([]string, error) {\n\t\tpod, ok := obj.(*v1.Pod)\n\t\tif !ok {\n\t\t\treturn []string{}, nil\n\t\t}\n\t\tkeys := []string{}\n\t\tfor _, podVolume := range pod.Spec.Volumes {\n\t\t\tclaimName := \"\"\n\t\t\tif pvcSource := podVolume.VolumeSource.PersistentVolumeClaim; pvcSource != nil {\n\t\t\t\tclaimName = pvcSource.ClaimName\n\t\t\t} else if podVolume.VolumeSource.Ephemeral != nil {\n\t\t\t\tclaimName = ephemeral.VolumeClaimName(pod, &podVolume)\n\t\t\t}\n\t\t\tif claimName != \"\" {\n\t\t\t\tkeys = append(keys, fmt.Sprintf(\"%s/%s\", pod.Namespace, claimName))\n\t\t\t}\n\t\t}\n\t\treturn keys, nil\n\t}\n}\n\n\nfunc AddPodPVCIndexerIfNotPresent(indexer cache.Indexer) error {\n\treturn AddIndexerIfNotPresent(indexer, PodPVCIndex, PodPVCIndexFunc())\n}\n\n\n\n\nfunc AddIndexerIfNotPresent(indexer cache.Indexer, indexName string, indexFunc cache.IndexFunc) error ", "output": "{\n\tindexers := indexer.GetIndexers()\n\tif _, ok := indexers[indexName]; ok {\n\t\treturn nil\n\t}\n\treturn indexer.AddIndexers(cache.Indexers{indexName: indexFunc})\n}"}
{"input": "package securitykey\n\nvar Key []byte \n\n\n\nfunc init() ", "output": "{\n\tvar err error\n\n\tKey, err = getKey()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"input": "package log\n\nimport (\n\t\"io/ioutil\"\n\t\"testing\"\n\n\t\"github.com/go-kit/kit/log\"\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\n\n\nfunc TestToGokit(t *testing.T) {\n\tConvey(\"golib logger\", t, func() {\n\t\tgkit := Discard\n\t\tConvey(\"should be able to convert\", func() {\n\t\t\tgk := ToGokit(gkit)\n\t\t\tSo(gk.Log(), ShouldBeNil)\n\t\t})\n\t})\n}\n\nfunc TestFromGokit(t *testing.T) ", "output": "{\n\tConvey(\"Gokit logger\", t, func() {\n\t\tlkit := log.NewJSONLogger(ioutil.Discard)\n\t\tConvey(\"should be able to convert\", func() {\n\t\t\tlgolib := FromGokit(lkit)\n\t\t\tlgolib.Log(\"a\", \"b\")\n\t\t\tSo(lkit.Log(\"a\", \"b\"), ShouldBeNil)\n\t\t\tConvey(\"and back\", func() {\n\t\t\t\tbacklog := ToGokit(lgolib)\n\t\t\t\tSo(backlog, ShouldEqual, lkit)\n\t\t\t\tSo(backlog.Log(\"a\", \"b\"), ShouldBeNil)\n\t\t\t})\n\t\t})\n\t})\n}"}
{"input": "package io\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc Info(args ...interface{}) {\n\tfmt.Print(\"\\033[1m-----> \")\n\targs = append(args, \"\\033[0m\")\n\tfmt.Println(args...)\n}\n\nfunc Infof(format string, args ...interface{}) {\n\tfmt.Print(\"\\033[1m-----> \")\n\tfmt.Printf(format+\"\\033[0m\", args...)\n}\n\nfunc Print(args ...interface{}) {\n\tfmt.Print(\"       \")\n\tfmt.Println(args...)\n}\n\n\n\nfunc Warnf(format string, args ...interface{}) {\n\tfmt.Print(\" !     \")\n\tfmt.Printf(format, args...)\n}\n\nfunc Error(args ...interface{}) {\n\tfmt.Print(\" !     \")\n\tfmt.Println(args...)\n\tos.Exit(1)\n}\n\nfunc Printf(format string, args ...interface{}) ", "output": "{\n\tfmt.Print(\"       \")\n\tfmt.Printf(format, args...)\n}"}
{"input": "package item\n\nimport \"testing\"\n\n\n\nfunc TestGetItemById(t *testing.T) {\n\tvar memItemRepo MemItemRepository\n\tnewItem, err := memItemRepo.NewItem(\"test\", \"item\")\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t}\n\tgotItem, err := memItemRepo.GetById(newItem.Id())\n\tif gotItem.Name() != \"test\" {\n\t\tt.Errorf(\"Item retrieved by Id had the incorrect name\")\n\t}\n}\n\nfunc TestNewItem(t *testing.T) ", "output": "{\n\tvar memItemRepo MemItemRepository\n\tnewItem, err := memItemRepo.NewItem(\"test\", \"item\")\n\tif err != nil {\n\t\tt.Errorf(err.Error())\n\t}\n\tif newItem.Name() != \"test\" {\n\t\tt.Errorf(\"Created Item did not set the name properly\")\n\t}\n}"}
{"input": "package writer\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\n\trnode \"a4.io/blobstash/pkg/filetree/filetreeutil/node\"\n)\n\n\n\nfunc setMtime(m *rnode.RawNode, fstat os.FileInfo) ", "output": "{\n\tif stat, ok := fstat.Sys().(*syscall.Stat_t); ok {\n\t\tm.ChangeTime = int64(stat.Ctim.Sec)\n\t}\n}"}
{"input": "package awstasks\n\nimport (\n\t\"encoding/json\"\n\n\t\"k8s.io/kops/upup/pkg/fi\"\n)\n\n\n\n\ntype realInternetGateway InternetGateway\n\n\nfunc (o *InternetGateway) UnmarshalJSON(data []byte) error {\n\tvar jsonName string\n\tif err := json.Unmarshal(data, &jsonName); err == nil {\n\t\to.Name = &jsonName\n\t\treturn nil\n\t}\n\n\tvar r realInternetGateway\n\tif err := json.Unmarshal(data, &r); err != nil {\n\t\treturn err\n\t}\n\t*o = InternetGateway(r)\n\treturn nil\n}\n\nvar _ fi.HasLifecycle = &InternetGateway{}\n\n\nfunc (o *InternetGateway) GetLifecycle() *fi.Lifecycle {\n\treturn o.Lifecycle\n}\n\n\nfunc (o *InternetGateway) SetLifecycle(lifecycle fi.Lifecycle) {\n\to.Lifecycle = &lifecycle\n}\n\nvar _ fi.HasName = &InternetGateway{}\n\n\nfunc (o *InternetGateway) GetName() *string {\n\treturn o.Name\n}\n\n\nfunc (o *InternetGateway) SetName(name string) {\n\to.Name = &name\n}\n\n\n\n\nfunc (o *InternetGateway) String() string ", "output": "{\n\treturn fi.TaskAsString(o)\n}"}
{"input": "package logger\n\nimport (\n\t\"time\"\n)\n\n\ntype TermColors struct{}\n\nfunc (TermColors) Reset() string     { return \"\\x1b[0m\" }\nfunc (TermColors) Bold() string      { return \"\\x1b[1m\" }\nfunc (TermColors) Underline() string { return \"\\x1b[4m\" }\n\nfunc (TermColors) Red() string       { return \"\\x1b[31m\" }\nfunc (TermColors) Green() string     { return \"\\x1b[32m\" }\nfunc (TermColors) Yellow() string    { return \"\\x1b[33m\" }\nfunc (TermColors) Blue() string      { return \"\\x1b[34m\" }\nfunc (TermColors) Magenta() string   { return \"\\x1b[35m\" }\nfunc (TermColors) Cyan() string      { return \"\\x1b[36m\" }\nfunc (TermColors) White() string     { return \"\\x1b[37m\" }\n\ntype Extras map[string]interface{}\n\ntype LogEvent struct {\n\tLevel       LogLevel\n\tHost        string\n\tMessage     string\n\tLongMessage string\n\tTimestamp   time.Time\n\tExtras      Extras\n\tTermColors\n}\n\nfunc (event *LogEvent) LevelColor() string {\n\tswitch event.Level {\n\tcase Emergency, Alert, Critical, Error:\n\t\treturn event.Red() + event.Bold()\n\tcase Warning, Notice:\n\t\treturn event.Red()\n\tcase Info, Debug:\n\t\treturn event.Blue()\n\t}\n\treturn \"\"\n}\n\nfunc (event *LogEvent) TimeRFC3339() string {\n\treturn event.Timestamp.Format(time.RFC3339)\n}\n\nfunc (TermColors) Black() string     ", "output": "{ return \"\\x1b[30m\" }"}
{"input": "package main\n\nimport (\n  \"fmt\"\n  _ \"github.com/lib/pq\"\n)\n\n\n\nfunc updateReferralTable(referral_id string) string{\n  var count int8\n  db.QueryRow(\"SELECT referral_count FROM referral WHERE referral_id=$1\",referral_id).Scan(&count)\n  count++\n  db.QueryRow(\"UPDATE referral SET referral_count=$1 where referral_id=$2\", count, referral_id)\n  var wallet_id string\n  db.QueryRow(\"SELECT wallet_id FROM referral WHERE referral_id=$1\",referral_id).Scan(&wallet_id)\n  return wallet_id\n}\n\nfunc createReferralID(referral_id, wallet_id string)  bool{\n  fmt.Println(\"Creating ReferralID\",referral_id, wallet_id)\n  db.QueryRow(\"INSERT INTO referral(referral_id, referral_count, wallet_id) VALUES($1,$2,$3);\",referral_id, 0, wallet_id)\n  return true\n}\n\nfunc checkReferralID(referral_id string) bool ", "output": "{\n  fmt.Println(\"Checking for valid referral_id:\", referral_id)\n  var count int8\n  if referral_id == \"\"{\n    return true\n  }\n  db.QueryRow(\"SELECT COUNT(*) FROM referral WHERE referral_id=$1\",referral_id).Scan(&count)\n  if count == 0 {\n    return false\n  }else{\n    return true\n  }\n}"}
{"input": "package main\n\nimport (\n    \"os\"\n    \"fmt\"\n    \"net\"\n    \"time\"\n)\n\nfunc main() {\n    service := \":1201\"\n    tcpAddr, err := net.ResolveTCPAddr(\"tcp4\", service)\n    checkError(err)\n\n    listener, err := net.ListenTCP(\"tcp\", tcpAddr)\n    checkError(err)\n\n    for {\n        conn, err := listener.Accept()\n        if err != nil {\n            continue\n        }\n        \n        go handleClient(conn)\n    }\n}\n\nfunc handleClient(conn net.Conn) {\n    \n    defer conn.Close()\n\n    var buf [512]byte\n    for {\n        conn.SetDeadline(time.Now().Add(10 * time.Second))\n\n        \n        n, err := conn.Read(buf[0:])\n        if err != nil {\n            return\n        }\n\n        \n        _, err2 := conn.Write(buf[0:n])\n        if err2 != nil {\n            return\n        }\n    }\n}\n\n\n\nfunc checkError(err error) ", "output": "{\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Fatal error: %s\", err.Error())\n        os.Exit(1)\n    }\n}"}
{"input": "package api\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"net/url\"\n)\n\n\n\nfunc decodeUrlEncodedJSON(data string, out interface{}) error {\n\tdecoded, err := url.QueryUnescape(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := json.Unmarshal([]byte(decoded), &out); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc decodeData(data string, out interface{}) error ", "output": "{\n\tdecoded, err := base64.StdEncoding.DecodeString(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := json.Unmarshal(decoded, &out); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package armcosmos_test\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azcore/to\"\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azidentity\"\n\t\"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/cosmos/armcosmos\"\n)\n\n\nfunc ExampleCollectionPartitionClient_ListMetrics() {\n\tcred, err := azidentity.NewDefaultAzureCredential(nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to obtain a credential: %v\", err)\n\t}\n\tctx := context.Background()\n\tclient := armcosmos.NewCollectionPartitionClient(\"<subscription-id>\", cred, nil)\n\tres, err := client.ListMetrics(ctx,\n\t\t\"<resource-group-name>\",\n\t\t\"<account-name>\",\n\t\t\"<database-rid>\",\n\t\t\"<collection-rid>\",\n\t\t\"<filter>\",\n\t\tnil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"Response result: %#v\\n\", res.CollectionPartitionClientListMetricsResult)\n}\n\n\n\n\nfunc ExampleCollectionPartitionClient_ListUsages() ", "output": "{\n\tcred, err := azidentity.NewDefaultAzureCredential(nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to obtain a credential: %v\", err)\n\t}\n\tctx := context.Background()\n\tclient := armcosmos.NewCollectionPartitionClient(\"<subscription-id>\", cred, nil)\n\tres, err := client.ListUsages(ctx,\n\t\t\"<resource-group-name>\",\n\t\t\"<account-name>\",\n\t\t\"<database-rid>\",\n\t\t\"<collection-rid>\",\n\t\t&armcosmos.CollectionPartitionClientListUsagesOptions{Filter: to.StringPtr(\"<filter>\")})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"Response result: %#v\\n\", res.CollectionPartitionClientListUsagesResult)\n}"}
{"input": "package compute\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/genevieve/leftovers/common\"\n\tgcpcompute \"google.golang.org/api/compute/v1\"\n)\n\ntype disksClient interface {\n\tListDisks(zone string) ([]*gcpcompute.Disk, error)\n\tDeleteDisk(zone, disk string) error\n}\n\ntype Disks struct {\n\tclient disksClient\n\tlogger logger\n\tzones  map[string]string\n}\n\nfunc NewDisks(client disksClient, logger logger, zones map[string]string) Disks {\n\treturn Disks{\n\t\tclient: client,\n\t\tlogger: logger,\n\t\tzones:  zones,\n\t}\n}\n\nfunc (d Disks) List(filter string) ([]common.Deletable, error) {\n\tdisks := []*gcpcompute.Disk{}\n\tfor _, zone := range d.zones {\n\t\tl, err := d.client.ListDisks(zone)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"List Disks for zone %s: %s\", zone, err)\n\t\t}\n\n\t\tdisks = append(disks, l...)\n\t}\n\n\tvar resources []common.Deletable\n\tfor _, disk := range disks {\n\t\tresource := NewDisk(d.client, disk.Name, d.zones[disk.Zone])\n\n\t\tif !strings.Contains(resource.Name(), filter) {\n\t\t\tcontinue\n\t\t}\n\n\t\tproceed := d.logger.PromptWithDetails(resource.Type(), resource.Name())\n\t\tif !proceed {\n\t\t\tcontinue\n\t\t}\n\n\t\tresources = append(resources, resource)\n\t}\n\n\treturn resources, nil\n}\n\n\n\nfunc (d Disks) Type() string ", "output": "{\n\treturn \"disk\"\n}"}
{"input": "package sarif\n\nimport \"time\"\n\ntype subscription struct {\n\tAction  string        `json:\"action,omitempty\"`\n\tDevice  string        `json:\"device,omitempty\"`\n\tHandler func(Message) `json:\"-\"`\n}\n\nfunc (s subscription) Matches(msg Message) bool {\n\tif msg.Destination != s.Device {\n\t\treturn false\n\t}\n\tif !msg.IsAction(s.Action) {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc Subscribe(action, device string) Message {\n\treturn CreateMessage(\"proto/sub\", subscription{action, device, nil})\n}\n\nfunc BadRequest(reason error) Message {\n\tstr := \"Bad Request\"\n\tif reason != nil {\n\t\tstr += \" - \" + reason.Error()\n\t}\n\treturn Message{\n\t\tAction: \"err/badrequest\",\n\t\tText:   str,\n\t}\n}\n\n\n\ntype ClientInfo struct {\n\tName         string    `json:\"name,omitempty\"`\n\tAuth         string    `json:\"auth,omitempty\"`\n\tCapabilities []string  `json:\"capabilities,omitempty\"`\n\tLastSeen     time.Time `json:\"last_seen,omitempty\"`\n}\n\nfunc InternalError(reason error) Message ", "output": "{\n\tstr := \"Internal Error\"\n\tif reason != nil {\n\t\tstr += \" - \" + reason.Error()\n\t}\n\treturn Message{\n\t\tAction: \"err/internal\",\n\t\tText:   str,\n\t}\n}"}
{"input": "package godspeed\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\ntype bodyWrapperFactory func(http.ResponseWriter) io.Writer\n\ntype bodyWrapper struct {\n\trespw http.ResponseWriter\n\tw     io.Writer\n\tposthandler bodyWrapperFactory\n}\n\n\n\nfunc (w *bodyWrapper) Write(data []byte) (int, error) {\n\tif w.w == nil {\n\t\tw.w = w.posthandler(w.respw)\n\t}\n\treturn w.w.Write(data)\n}\n\nfunc (w *bodyWrapper) WriteHeader(s int) {\n\tw.respw.WriteHeader(s)\n}\n\nfunc (w *bodyWrapper) Close() error {\n\tvar err error\n\tif c, ok := w.w.(io.Closer); ok {\n\t\terr = c.Close()\n\t}\n\treturn err\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc wrapBody(respw http.ResponseWriter, writerGen bodyWrapperFactory) *bodyWrapper {\n\treturn &bodyWrapper{\n\t\trespw:       respw,\n\t\tposthandler: writerGen,\n\t}\n}\n\nfunc (w *bodyWrapper) Header() http.Header ", "output": "{\n\treturn w.respw.Header()\n}"}
{"input": "package budget\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype DeleteBudgetRequest struct {\n\n\tBudgetId *string `mandatory:\"true\" contributesTo:\"path\" name:\"budgetId\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request DeleteBudgetRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request DeleteBudgetRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request DeleteBudgetRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request DeleteBudgetRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype DeleteBudgetResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\n\n\n\nfunc (response DeleteBudgetResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response DeleteBudgetResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/go-gl/gl/v3.3-core/gl\"\n)\n\ntype Buffer interface {\n}\n\ntype GLBuffer struct {\n\tid          uint32\n\tbufferBytes int\n\ttarget      uint32\n}\n\nfunc NewGLBuffer(target uint32) (b *GLBuffer) {\n\tb = &GLBuffer{\n\t\ttarget: target,\n\t}\n\tgl.GenBuffers(1, &b.id)\n\tb.Bind()\n\treturn\n}\n\nfunc (b *GLBuffer) BufferID() uint32 {\n\treturn b.id\n}\n\n\n\nfunc (b *GLBuffer) Delete() {\n\tgl.DeleteBuffers(1, &b.id)\n}\n\nfunc (b *GLBuffer) Upload(data interface{}, size int) {\n\tb.Bind()\n\tif size > b.bufferBytes {\n\t\tb.bufferBytes = size\n\t\tgl.BufferData(b.target, size, gl.Ptr(data), gl.STREAM_DRAW)\n\t} else {\n\t\tgl.BufferSubData(b.target, 0, size, gl.Ptr(data))\n\t}\n}\n\nfunc (b *GLBuffer) Size() int {\n\treturn b.bufferBytes\n}\n\ntype UniformBuffer struct {\n\t*GLBuffer\n}\n\nfunc NewUniformBuffer() (b *UniformBuffer) {\n\tb = &UniformBuffer{\n\t\tGLBuffer: NewGLBuffer(gl.UNIFORM_BUFFER),\n\t}\n\treturn\n}\n\ntype ArrayBuffer struct {\n\t*GLBuffer\n}\n\nfunc NewArrayBuffer() (b *ArrayBuffer) {\n\tb = &ArrayBuffer{\n\t\tGLBuffer: NewGLBuffer(gl.ARRAY_BUFFER),\n\t}\n\treturn\n}\n\nfunc (b *GLBuffer) Bind() ", "output": "{\n\tgl.BindBuffer(b.target, b.id)\n}"}
{"input": "package client\n\nimport (\n\t\"os\"\n\t\"path\"\n\t\"fmt\"\n\t\"log\"\n)\n\ntype FS struct {\n\tPath string\n}\n\nfunc NewFS(path string) *FS{\n\treturn &FS{\n\t\tPath: path,\n\t}\n}\n\n\nfunc (f *FS) CreateFile(name string) (*os.File, error) {\n\tfile, err := os.Create(path.Join(f.Path, name))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn file, nil\n}\n\nfunc (f *FS) OpenFile(name string) (*os.File, error) {\n\tfile, err := os.Open(path.Join(f.Path, name))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn file, nil\n}\n\n\n\nfunc GetFileSize(fullPath string) int64 {\n\tfile, err := os.Open(fullPath)\n\tdefer file.Close()\n\tfstat, err := file.Stat()\n\tif err != nil {\n\t\tlog.Println(\"Cannot do stat on file, returning 0\")\n\t\treturn 0\n\t}\n\treturn fstat.Size()\n}\n\nfunc CheckIfFileExists(fullFilePath string) bool ", "output": "{\n\tif _, err := os.Stat(fullFilePath); err != nil {\n\t\tfmt.Print(err)\n\t\tif os.IsNotExist(err) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"input": "package cmd\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc GetErrorMessage(err error) string {\n\tif err != nil {\n\t\treturn err.Error()\n\t}\n\treturn \"\"\n}\n\n\n\nfunc TestExecuteClienAddCmd(t *testing.T) ", "output": "{\n\tassert.Nil(t, nil)\n}"}
{"input": "package vulnerabilityscanning\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype DeleteHostScanTargetRequest struct {\n\n\tHostScanTargetId *string `mandatory:\"true\" contributesTo:\"path\" name:\"hostScanTargetId\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request DeleteHostScanTargetRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request DeleteHostScanTargetRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request DeleteHostScanTargetRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request DeleteHostScanTargetRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype DeleteHostScanTargetResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\n\n\n\nfunc (response DeleteHostScanTargetResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response DeleteHostScanTargetResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package types\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\n\n\nfunc TestExtractCommentTags(t *testing.T) ", "output": "{\n\tcommentLines := `\nHuman comment that is ignored.\n+foo=value1,bar\n+foo=value2,baz=frobber\n`\n\ta := ExtractCommentTags(\"+\", commentLines)\n\te := map[string]string{\"foo\": \"value2\", \"bar\": \"true\", \"baz\": \"frobber\"}\n\tif !reflect.DeepEqual(e, a) {\n\t\tt.Errorf(\"Wanted %#v, got %#v\", e, a)\n\t}\n}"}
{"input": "package api\n\nimport (\n\t\"log\"\n)\n\n\n\nfunc checkStkPushRequirements(client *Client) bool {\n\n\tif client.Key == \"\" ||\n\t\tclient.PassKey == \"\" ||\n\t\tclient.TransactionCallback == \"\" ||\n\t\tclient.ShortCode == 0 ||\n\t\tclient.MSISDN == \"\" {\n\t\tlog.Println(`Please make sure you have instantiated the client with the following properties\\n\n\t\t\t\t\t\t 1. Key (Consumer Key)\\n\n\t\t\t\t\t\t 2. TransactionCallback (Callback URL for STK push)\\n\n\t\t\t\t\t\t 3. ShortCode (Lipa Na M-Pesa ShortCode)\\n\n\t\t\t\t\t\t 4. MSISDN (MSISDN - phone number provided for initiating transactions)`)\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc check(reqs string, client *Client) bool ", "output": "{\n\n\tvar res bool\n\tswitch reqs {\n\n\tcase \"stkpush\":\n\t\tres = checkStkPushRequirements(client)\n\tdefault:\n\t\tres = false\n\t}\n\n\treturn res\n\n}"}
{"input": "package plugin\n\nimport (\n\t\"github.com/pkg/errors\"\n\t\"github.com/xeipuuv/gojsonschema\"\n)\n\ntype Container struct {\n\tPlugin Plugin\n\tschema *gojsonschema.Schema\n}\n\ntype ValidationResult struct {\n\tErrors []error\n}\n\nfunc NewContainer(newPlugin NewFunc) (Container, error) {\n\tplugin, err := newPlugin()\n\tif err != nil {\n\t\treturn Container{}, errors.Wrap(err, \"failed to instantiate plugin\")\n\t}\n\tdescription := plugin.Describe()\n\tvar schema *gojsonschema.Schema\n\tif description.SpecSchema != nil {\n\t\tschema, err = gojsonschema.NewSchema(gojsonschema.NewBytesLoader(description.SpecSchema))\n\t\tif err != nil {\n\t\t\treturn Container{}, errors.Wrapf(err, \"can't use plugin %q due to invalid schema\", description.Name)\n\t\t}\n\t}\n\n\treturn Container{\n\t\tPlugin: plugin,\n\t\tschema: schema,\n\t}, nil\n}\n\n\n\nfunc (pc *Container) ValidateSpec(pluginSpec map[string]interface{}) (ValidationResult, error) ", "output": "{\n\tif pc.schema == nil {\n\t\treturn ValidationResult{}, nil\n\t}\n\n\tresult, err := pc.schema.Validate(gojsonschema.NewGoLoader(pluginSpec))\n\tif err != nil {\n\t\treturn ValidationResult{}, errors.Wrap(err, \"error validating plugin spec\")\n\t}\n\n\tif !result.Valid() {\n\t\tvalidationErrors := result.Errors()\n\t\terrs := make([]error, 0, len(validationErrors))\n\n\t\tfor _, validationErr := range validationErrors {\n\t\t\terrs = append(errs, errors.New(validationErr.String()))\n\t\t}\n\n\t\treturn ValidationResult{errs}, nil\n\t}\n\n\treturn ValidationResult{}, nil\n}"}
{"input": "package gofaker\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"unicode\"\n)\n\n\ntype Bank struct {\n\tfaker *Faker\n}\n\n\nfunc (b *Bank) Name() string {\n\treturn b.faker.MustFetch(\"bank.name\")\n}\n\n\n\n\nfunc (b *Bank) IBAN() string {\n\tiban, err := b.NationalIBAN(\"DE\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn iban\n}\n\nfunc getIBANInfo(ibanDetails []map[string]string, countryCode string) map[string]string {\n\tfor _, m := range ibanDetails {\n\t\tif m[\"bank_country_code\"] == countryCode {\n\t\t\treturn m\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (b *Bank) NationalIBAN(countryCode string) (string, error) {\n\tdetails := b.faker.data.GetStringMapList(\"bank.iban_details\")\n\tm := getIBANInfo(details, countryCode)\n\tif m == nil {\n\t\treturn \"\", fmt.Errorf(\"invalid country code for iban '%s'\", countryCode)\n\t}\n\ts := bytes.NewBufferString(countryCode)\n\tnumLetters, err := strconv.Atoi(m[\"iban_letter_code\"])\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor i := 0; i < numLetters; i++ {\n\t\ts.WriteRune(unicode.ToUpper(b.faker.RandomLetter()))\n\t}\n\tnumDigits, err := strconv.Atoi(m[\"iban_digits\"])\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor i := 0; i < numDigits; i++ {\n\t\ts.WriteRune(b.faker.RandomDigit())\n\t}\n\treturn s.String(), nil\n}\n\nfunc (b *Bank) BIC() string ", "output": "{\n\treturn b.faker.MustFetch(\"bank.swift_bic\")\n}"}
{"input": "package term \n\nimport \"io\"\n\ntype Db []Term\n\nfunc NewDb(args []Term) Db {\n\treturn Db(args)\n}\n\n\n\n\ntype Query struct {\n\tdb    Db\n\tname  string\n\tarity int\n}\n\n\n\n\nfunc (db Db) NewQuery(t Term) *Query {\n\treturn &Query{\n\t\tdb:    db,\n\t\tname:  Name(t),\n\t\tarity: Arity(t),\n\t}\n}\n\n\n\nfunc (q *Query) Run() *Cursor {\n\treturn &Cursor{\n\t\tq: q,\n\t\ti: 0,\n\t}\n}\n\n\ntype Cursor struct {\n\tq *Query\n\ti int\n}\n\nfunc (c *Cursor) Next() (Term, bool) {\n\tfor ; c.i < len(c.q.db); c.i++ {\n\t\tcandidate := c.q.db[c.i]\n\t\tif Arity(candidate) == c.q.arity && Name(candidate) == c.q.name {\n\t\t\tc.i++\n\t\t\treturn candidate, c.i < len(c.q.db)\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc (s Db) Format(w io.Writer, style Style) ", "output": "{\n\tisRoot := style.IsRoot\n\tstyle.IsRoot = false \n\n\tprevName := \"#\" \n\tfor _, t := range s {\n\t\tif isRoot {\n\t\t\tname := Name(t)\n\t\t\tif prevName != \"#\" && prevName != name {\n\t\t\t\tio.WriteString(w, \"\\n\")\n\t\t\t}\n\t\t\tprevName = name\n\t\t}\n\n\t\tstyle.WriteIndent(w)\n\t\tt.Format(w, style)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n)\n\nvar (\n\tcfg     Config\n\tcfgfile string = \"config.json\"\n)\n\ntype Config struct {\n\tF5config  Device           `json:\"f5\"`\n\tWebconfig WebService       `json:\"webservice\"`\n\tGroups    map[string]Group `json:\"groups\"`\n}\n\ntype Device struct {\n\tHostname string `json:\"hostname\"`\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"passwd\"`\n}\n\ntype WebService struct {\n\tBindAddress string `json:\"address\"`\n\tBindPort    int    `json:\"port\"`\n}\n\ntype Pool struct {\n\tBlue  []string `json:\"blue\"`\n\tGreen []string `json:\"green\"`\n\tState string   `json:\"state\"`\n\tError string   `json:\"error\"`\n}\n\nfunc (t Pool) SetState(s string) Pool {\n\tt.State = s\n\treturn t\n}\n\n\n\ntype Group struct {\n\tPools map[string]Pool `json:\"pools\"`\n\tState string          `json:\"state\"`\n}\n\nfunc (t Group) SetState(s string) Group {\n\tt.State = s\n\treturn t\n}\n\ntype GroupPutData struct {\n\tName  string `json:\"name\"`\n\tState string `json:\"state\"`\n}\n\nfunc InitialiseConfig(c string) (err error) {\n\n\tdat, err := ioutil.ReadFile(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = json.Unmarshal(dat, &cfg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (t Pool) SetError(s string) Pool ", "output": "{\n\tt.Error = s\n\treturn t\n}"}
{"input": "package converter\n\nimport (\n\tlog \"github.com/sirupsen/logrus\"\n\n\tapi \"github.com/projectcalico/calico/libcalico-go/lib/apis/v1\"\n\t\"github.com/projectcalico/calico/libcalico-go/lib/apis/v1/unversioned\"\n\t\"github.com/projectcalico/calico/libcalico-go/lib/backend/model\"\n)\n\n\n\ntype ProfileConverter struct{}\n\n\nfunc (p ProfileConverter) ConvertMetadataToKey(m unversioned.ResourceMetadata) (model.Key, error) {\n\thm := m.(api.ProfileMetadata)\n\tk := model.ProfileKey{\n\t\tName: hm.Name,\n\t}\n\treturn k, nil\n}\n\n\n\nfunc (c ProfileConverter) ConvertAPIToKVPair(a unversioned.Resource) (*model.KVPair, error) {\n\tap := a.(api.Profile)\n\tk, err := c.ConvertMetadataToKey(ap.Metadata)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttags := ap.Metadata.Tags\n\tif tags == nil {\n\t\tlog.Debug(\"Tags is nil - convert to empty map for backend\")\n\t\ttags = []string{}\n\t}\n\tlabels := ap.Metadata.Labels\n\tif labels == nil {\n\t\tlog.Debug(\"Labels is nil - convert to empty map for backend\")\n\t\tlabels = map[string]string{}\n\t}\n\n\td := model.KVPair{\n\t\tKey: k,\n\t\tValue: &model.Profile{\n\t\t\tRules: model.ProfileRules{\n\t\t\t\tInboundRules:  RulesAPIToBackend(ap.Spec.IngressRules),\n\t\t\t\tOutboundRules: RulesAPIToBackend(ap.Spec.EgressRules),\n\t\t\t},\n\t\t\tTags:   tags,\n\t\t\tLabels: labels,\n\t\t},\n\t}\n\n\treturn &d, nil\n}\n\n\n\n\n\nfunc (c ProfileConverter) ConvertKVPairToAPI(d *model.KVPair) (unversioned.Resource, error) ", "output": "{\n\tbp := d.Value.(*model.Profile)\n\tbk := d.Key.(model.ProfileKey)\n\n\tap := api.NewProfile()\n\tap.Metadata.Name = bk.Name\n\tap.Metadata.Labels = bp.Labels\n\tif len(bp.Tags) == 0 {\n\t\tap.Metadata.Tags = nil\n\t} else {\n\t\tap.Metadata.Tags = bp.Tags\n\t}\n\tap.Spec.IngressRules = RulesBackendToAPI(bp.Rules.InboundRules)\n\tap.Spec.EgressRules = RulesBackendToAPI(bp.Rules.OutboundRules)\n\n\treturn ap, nil\n}"}
{"input": "package trace\n\nimport (\n\t\"github.com/golang/groupcache/lru\"\n)\n\n\n\ntype lruMap struct {\n\tcacheKeys    map[lru.Key]bool\n\tcache        *lru.Cache\n\tdroppedCount int\n}\n\nfunc newLruMap(size int) *lruMap {\n\tlm := &lruMap{\n\t\tcacheKeys:    make(map[lru.Key]bool),\n\t\tcache:        lru.New(size),\n\t\tdroppedCount: 0,\n\t}\n\tlm.cache.OnEvicted = func(key lru.Key, value interface{}) {\n\t\tdelete(lm.cacheKeys, key)\n\t\tlm.droppedCount++\n\t}\n\treturn lm\n}\n\nfunc (lm lruMap) len() int {\n\treturn lm.cache.Len()\n}\n\nfunc (lm lruMap) keys() []interface{} {\n\tkeys := []interface{}{}\n\tfor k := range lm.cacheKeys {\n\t\tkeys = append(keys, k)\n\t}\n\treturn keys\n}\n\nfunc (lm *lruMap) add(key, value interface{}) {\n\tlm.cacheKeys[lru.Key(key)] = true\n\tlm.cache.Add(lru.Key(key), value)\n}\n\n\n\nfunc (lm *lruMap) get(key interface{}) (interface{}, bool) ", "output": "{\n\treturn lm.cache.Get(key)\n}"}
{"input": "package userService\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gin-gonic/gin/binding\"\n)\n\n\n\n\nfunc CreateUserAuthentication(c *gin.Context) (int, error) ", "output": "{\n\tvar form LoginForm\n\tc.BindWith(&form, binding.Form)\n\temail := form.Email\n\tpass := form.Password\n\tstatus, err := SetCookieHandler(c, email, pass)\n\treturn status, err\n}"}
{"input": "package csrf\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/projectatomic/atomic-enterprise/pkg/auth/server/session\"\n\n\t\"code.google.com/p/go-uuid/uuid\"\n)\n\nconst CSRFKey = \"csrf\"\n\ntype sessionCsrf struct {\n\tstore session.Store\n\tname  string\n}\n\n\n\n\n\n\nfunc (c *sessionCsrf) Generate(w http.ResponseWriter, req *http.Request) (string, error) {\n\tsession, err := c.store.Get(req, c.name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvalues := session.Values()\n\tcsrfString, ok := values[CSRFKey].(string)\n\tif ok && csrfString != \"\" {\n\t\treturn csrfString, nil\n\t}\n\n\tcsrfString = uuid.NewUUID().String()\n\tvalues[CSRFKey] = csrfString\n\n\tif err = c.store.Save(w, req); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn csrfString, nil\n}\n\n\nfunc (c *sessionCsrf) Check(req *http.Request, value string) (bool, error) {\n\tif len(value) == 0 {\n\t\treturn false, nil\n\t}\n\n\tsession, err := c.store.Get(req, c.name)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tvalues := session.Values()\n\tcsrfString, ok := values[CSRFKey].(string)\n\tif ok && csrfString == value {\n\t\treturn true, nil\n\t}\n\n\treturn false, nil\n}\n\nfunc NewSessionCSRF(store session.Store, name string) CSRF ", "output": "{\n\treturn &sessionCsrf{\n\t\tstore: store,\n\t\tname:  name,\n\t}\n}"}
{"input": "package gonfler\n\nimport (\n\t\"archive/tar\"\n\t\"os\"\n)\n\ntype TarArchive struct {\n\thandle *tar.Reader\n\tfile   *os.File\n}\n\nfunc (archive TarArchive) Close() error {\n\treturn archive.file.Close()\n}\n\n\n\nfunc openTar(name string) (Archive, error) {\n\tfile, e := os.Open(name)\n\tif file != nil {\n\t\treturn TarArchive{tar.NewReader(file), file}, nil\n\t} else {\n\t\treturn nil, e\n\t}\n}\n\nfunc (archive TarArchive) Volumes() VolumeIterator ", "output": "{\n\tvar next func() VolumeIterator\n\tnext = func() VolumeIterator {\n\t\theader, err := archive.handle.Next()\n\t\tif err != nil {\n\t\t\treturn VolumeIterator{nil, nil}\n\t\t} else {\n\t\t\treturn VolumeIterator{\n\t\t\t\tvolume: &Volume{archive.handle, header.Name},\n\t\t\t\tnext:   next,\n\t\t\t}\n\t\t}\n\t}\n\treturn next()\n}"}
{"input": "package v1\n\nimport (\n\tv1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/client-go/tools/cache\"\n)\n\n\ntype ComponentStatusLister interface {\n\tList(selector labels.Selector) (ret []*v1.ComponentStatus, err error)\n\tGet(name string) (*v1.ComponentStatus, error)\n\tComponentStatusListerExpansion\n}\n\n\ntype componentStatusLister struct {\n\tindexer cache.Indexer\n}\n\n\n\n\n\nfunc (s *componentStatusLister) List(selector labels.Selector) (ret []*v1.ComponentStatus, err error) {\n\terr = cache.ListAll(s.indexer, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*v1.ComponentStatus))\n\t})\n\treturn ret, err\n}\n\n\nfunc (s *componentStatusLister) Get(name string) (*v1.ComponentStatus, error) {\n\tobj, exists, err := s.indexer.GetByKey(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn nil, errors.NewNotFound(v1.Resource(\"componentstatus\"), name)\n\t}\n\treturn obj.(*v1.ComponentStatus), nil\n}\n\nfunc NewComponentStatusLister(indexer cache.Indexer) ComponentStatusLister ", "output": "{\n\treturn &componentStatusLister{indexer: indexer}\n}"}
{"input": "package emperror\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n\n\n\nfunc Recover(r interface{}) (err error) ", "output": "{\n\tif r != nil {\n\t\tswitch x := r.(type) {\n\t\tcase string:\n\t\t\terr = errors.New(x)\n\t\tcase error:\n\t\t\terr = x\n\t\tdefault:\n\t\t\terr = fmt.Errorf(\"unknown panic, received: %v\", r)\n\t\t}\n\n\t\tif _, ok := StackTrace(err); !ok {\n\t\t\terr = &wrappedError{\n\t\t\t\terr:   err,\n\t\t\t\tstack: callers()[2:], \n\t\t\t}\n\t\t}\n\t}\n\n\treturn err\n}"}
{"input": "package drainer\n\nimport (\n\t. \"github.com/h8liu/reactsim/react/sim/config\"\n\t. \"github.com/h8liu/reactsim/react/sim/structs\"\n)\n\nfunc RowLimits(limits []*Limit, bound uint64) []*Limit {\n\tfor i := 0; i < Nhost; i++ {\n\t\tlimits = append(limits, RowLimit(i, bound))\n\t}\n\treturn limits\n}\n\nfunc ColLimits(limits []*Limit, bound uint64) []*Limit {\n\tfor i := 0; i < Nhost; i++ {\n\t\tlimits = append(limits, ColLimit(i, bound))\n\t}\n\treturn limits\n}\n\n\n\nfunc RowVarLimits(limits []*Limit, bounds Vector) []*Limit {\n\tfor i := 0; i < Nhost; i++ {\n\t\tlimits = append(limits, RowLimit(i, bounds[i]))\n\t}\n\treturn limits\n}\n\nfunc ColVarLimits(limits []*Limit, bounds Vector) []*Limit {\n\tfor i := 0; i < Nhost; i++ {\n\t\tlimits = append(limits, ColLimit(i, bounds[i]))\n\t}\n\treturn limits\n}\n\nfunc RowAvailable(limits []*Limit, used Matrix, bandw uint64) []*Limit {\n\tv := NewVector()\n\tused.RowSum(v)\n\tv.Reach(bandw)\n\treturn RowVarLimits(limits, v)\n}\n\nfunc ColAvailable(limits []*Limit, used Matrix, bandw uint64) []*Limit {\n\tv := NewVector()\n\tused.ColSum(v)\n\tv.Reach(bandw)\n\treturn ColVarLimits(limits, v)\n}\n\nfunc Available(limits []*Limit, used Matrix, bandw uint64) []*Limit {\n\tlimits = RowAvailable(limits, used, bandw)\n\tlimits = ColAvailable(limits, used, bandw)\n\treturn limits\n}\n\nfunc BandwLimits(limits []*Limit, bandw uint64) []*Limit ", "output": "{\n\tlimits = RowLimits(limits, bandw)\n\tlimits = ColLimits(limits, bandw)\n\treturn limits\n}"}
{"input": "package context\n\nimport (\n\t\"context\"\n)\n\n\ntype subscriptionKey struct{}\n\n\nfunc WithSubscriptionKey(ctx context.Context, key string) context.Context {\n\treturn context.WithValue(ctx, subscriptionKey{}, key)\n}\n\n\n\n\nfunc GetSubscriptionKey(ctx context.Context) (string, error) ", "output": "{\n\tuntyped := ctx.Value(subscriptionKey{})\n\tif untyped == nil {\n\t\treturn \"\", ErrSubscriptionKeyNotPresent\n\t}\n\treturn untyped.(string), nil\n}"}
{"input": "package config\n\nimport (\n\t\"encoding/xml\"\n)\n\ntype defXMLReader struct {\n\topts ReaderOptions\n}\n\n\nfunc NewXMLReader(opts ...ReaderOptionFunc) Reader {\n\tr := &defXMLReader{}\n\tfor _, o := range opts {\n\t\to(&r.opts)\n\t}\n\treturn r\n}\n\n\n\nfunc (*defXMLReader) Dump(v interface{}) ([]byte, error) {\n\treturn xml.Marshal(v)\n}\n\nfunc (*defXMLReader) ParseData(data []byte, model interface{}) error {\n\treturn ParseXMLConfig(data, model)\n}\n\n\nfunc ReadXMLFile(name string) ([]byte, error) {\n\tdata, _, err := filesRepo.Read(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n\n\nfunc ParseXMLConfig(data []byte, model interface{}) error {\n\treturn xml.Unmarshal(data, model)\n}\n\nfunc (p *defXMLReader) Read(model interface{}) error ", "output": "{\n\tdata, err := ReadXMLFile(p.opts.filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ParseXMLConfig(data, model)\n}"}
{"input": "package ubsms\n\nimport (\n\t. \"aliyun-openapi-go-sdk/core\"\n)\n\ntype DescribeBusinessStatusRequest struct {\n\tRpcRequest\n\tcallerBid string\n\tPassword  string\n}\n\nfunc (r *DescribeBusinessStatusRequest) SetcallerBid(value string) {\n\tr.callerBid = value\n\tr.QueryParams.Set(\"callerBid\", value)\n}\n\nfunc (r *DescribeBusinessStatusRequest) SetPassword(value string) {\n\tr.Password = value\n\tr.QueryParams.Set(\"Password\", value)\n}\nfunc (r *DescribeBusinessStatusRequest) GetPassword() string {\n\treturn r.Password\n}\n\nfunc (r *DescribeBusinessStatusRequest) Init() {\n\tr.RpcRequest.Init()\n\tr.SetVersion(Version)\n\tr.SetAction(\"DescribeBusinessStatus\")\n\tr.SetProduct(Product)\n}\n\ntype DescribeBusinessStatusResponse struct {\n\tSuccess                bool `xml:\"Success\" json:\"Success\"`\n\tUserBusinessStatusList struct {\n\t\tUserBusinessStatus []struct {\n\t\t\tUid         string `xml:\"Uid\" json:\"Uid\"`\n\t\t\tServiceCode string `xml:\"ServiceCode\" json:\"ServiceCode\"`\n\t\t\tStatuses    struct {\n\t\t\t\tStatus []struct {\n\t\t\t\t\tStatusKey   string `xml:\"StatusKey\" json:\"StatusKey\"`\n\t\t\t\t\tStatusValue string `xml:\"StatusValue\" json:\"StatusValue\"`\n\t\t\t\t} `xml:\"Status\" json:\"Status\"`\n\t\t\t} `xml:\"Statuses\" json:\"Statuses\"`\n\t\t} `xml:\"UserBusinessStatus\" json:\"UserBusinessStatus\"`\n\t} `xml:\"UserBusinessStatusList\" json:\"UserBusinessStatusList\"`\n}\n\nfunc DescribeBusinessStatus(req *DescribeBusinessStatusRequest, accessId, accessSecret string) (*DescribeBusinessStatusResponse, error) {\n\tvar pResponse DescribeBusinessStatusResponse\n\tbody, err := ApiHttpRequest(accessId, accessSecret, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tApiUnmarshalResponse(req.GetFormat(), body, &pResponse)\n\treturn &pResponse, err\n}\n\nfunc (r *DescribeBusinessStatusRequest) GetcallerBid() string ", "output": "{\n\treturn r.callerBid\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/fsnotify/fsnotify\"\n)\n\n\ntype BuildRestarter interface {\n\tName() string\n\tBuild() error\n\tRestart()\n}\n\n\ntype FileWatcher struct {\n\tRestarters []BuildRestarter\n}\n\n\nfunc (w *FileWatcher) Add(r ...BuildRestarter) {\n\tw.Restarters = append(w.Restarters, r...)\n}\n\n\nfunc (w *FileWatcher) Watch() {\n\tfiles, err := w.findGoFiles()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\tdefer watcher.Close()\n\n\tfor _, file := range files {\n\t\tif err := watcher.Add(filepath.Join(\".\", file)); err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase event := <-watcher.Events:\n\t\t\tif event.Op != fsnotify.Chmod && event.Name != \"\" {\n\t\t\t\tfor _, restarter := range w.Restarters {\n\t\t\t\t\tcolor.HiYellow(\"rebuilding %s\\n\", restarter.Name())\n\t\t\t\t\tif err := restarter.Build(); err == nil { \n\t\t\t\t\t\tcolor.HiYellow(\"restarting %s\", restarter.Name())\n\t\t\t\t\t\trestarter.Restart()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twatcher.Remove(event.Name)\n\t\t\t\twatcher.Add(event.Name)\n\t\t\t}\n\t\tcase err := <-watcher.Errors:\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n}\n\n\n\nfunc (w *FileWatcher) findGoFiles() ([]string, error) ", "output": "{\n\tvar files []string\n\terr := filepath.Walk(\".\", func(path string, info os.FileInfo, err error) error {\n\t\tif strings.HasPrefix(path, \"cmd/sourcepods-dev\") { \n\t\t\treturn nil\n\t\t}\n\t\tif strings.HasPrefix(path, \"vendor\") {\n\t\t\treturn nil\n\t\t}\n\t\tif strings.HasSuffix(path, \".go\") {\n\t\t\tfiles = append(files, path)\n\t\t}\n\t\treturn nil\n\t})\n\treturn files, err\n}"}
{"input": "package graph\n\nimport \"github.com/cayleygraph/cayley/quad\"\n\n\ntype Transaction struct {\n\tDeltas []Delta\n\tdeltas map[Delta]struct{}\n}\n\n\nfunc NewTransaction() *Transaction {\n\treturn &Transaction{Deltas: make([]Delta, 0, 10), deltas: make(map[Delta]struct{}, 10)}\n}\n\n\n\n\nfunc (t *Transaction) AddQuad(q quad.Quad) {\n\tad, rd := createDeltas(q)\n\n\tif _, adExists := t.deltas[ad]; !adExists {\n\t\tif _, rdExists := t.deltas[rd]; rdExists {\n\t\t\tt.deleteDelta(rd)\n\t\t} else {\n\t\t\tt.addDelta(ad)\n\t\t}\n\t}\n}\n\n\n\n\nfunc (t *Transaction) RemoveQuad(q quad.Quad) {\n\tad, rd := createDeltas(q)\n\n\tif _, adExists := t.deltas[ad]; adExists {\n\t\tt.deleteDelta(ad)\n\t} else {\n\t\tif _, rdExists := t.deltas[rd]; !rdExists {\n\t\t\tt.addDelta(rd)\n\t\t}\n\t}\n}\n\nfunc createDeltas(q quad.Quad) (ad, rd Delta) {\n\tad = Delta{\n\t\tQuad:   q,\n\t\tAction: Add,\n\t}\n\trd = Delta{\n\t\tQuad:   q,\n\t\tAction: Delete,\n\t}\n\treturn\n}\n\n\n\nfunc (t *Transaction) deleteDelta(d Delta) {\n\tdelete(t.deltas, d)\n\n\tfor i, id := range t.Deltas {\n\t\tif id == d {\n\t\t\tt.Deltas = append(t.Deltas[:i], t.Deltas[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (t *Transaction) addDelta(d Delta) ", "output": "{\n\tt.Deltas = append(t.Deltas, d)\n\tt.deltas[d] = struct{}{}\n}"}
{"input": "package api\n\n\n\ntype AgentsService struct {\n\tclient *Client\n}\n\n\ntype Agent struct {\n\tName              string   `json:\"name\"`\n\tAccessToken       string   `json:\"access_token\"`\n\tHostname          string   `json:\"hostname\"`\n\tEndpoint          string   `json:\"endpoint\"`\n\tPingInterval      int      `json:\"ping_interval\"`\n\tHearbeatInterval  int      `json:\"heartbeat_interval\"`\n\tOS                string   `json:\"os\"`\n\tArch              string   `json:\"arch\"`\n\tScriptEvalEnabled bool     `json:\"script_eval_enabled\"`\n\tPriority          string   `json:\"priority,omitempty\"`\n\tVersion           string   `json:\"version\"`\n\tBuild             string   `json:\"build\"`\n\tMetaData          []string `json:\"meta_data\"`\n\tPID               int      `json:\"pid,omitempty\"`\n}\n\n\n\nfunc (as *AgentsService) Register(agent *Agent) (*Agent, *Response, error) {\n\treq, err := as.client.NewRequest(\"POST\", \"register\", agent)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(Agent)\n\tresp, err := as.client.Do(req, a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, err\n}\n\n\n\n\n\nfunc (as *AgentsService) Disconnect() (*Response, error) {\n\treq, err := as.client.NewRequest(\"POST\", \"disconnect\", nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn as.client.Do(req, nil)\n}\n\nfunc (as *AgentsService) Connect() (*Response, error) ", "output": "{\n\treq, err := as.client.NewRequest(\"POST\", \"connect\", nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn as.client.Do(req, nil)\n}"}
{"input": "package lol\n\nimport (\n\t\"fmt\"\n)\n\nvar w = &Writer{Output: stdout, ColorMode: ColorMode256}\n\n\n\nfunc Printf(format string, a ...interface{}) (n int, err error) {\n\treturn fmt.Fprintf(w, format, a...)\n}\n\nfunc Println(a ...interface{}) (n int, err error) ", "output": "{\n\treturn fmt.Fprintln(w, a...)\n}"}
{"input": "package hpa\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"os/exec\"\n\t\"time\"\n\n\t\"github.com/Azure/acs-engine/test/e2e/kubernetes/util\"\n)\n\n\ntype HPA struct {\n\tMetadata Metadata `json:\"metadata\"`\n\tSpec     Spec     `json:\"spec\"`\n\tStatus   Status   `json:\"status\"`\n}\n\n\ntype Metadata struct {\n\tCreatedAt time.Time `json:\"creationTimestamp\"`\n\tName      string    `json:\"name\"`\n\tNamespace string    `json:\"namespace\"`\n}\n\n\ntype Spec struct {\n\tMinReplicas                    int `json:\"minReplicas\"`\n\tMaxReplicas                    int `json:\"maxReplicas\"`\n\tTargetCPUUtilizationPercentage int `json:\"targetCPUUtilizationPercentage\"`\n}\n\n\ntype Status struct {\n\tLoadBalancer LoadBalancer `json:\"loadBalancer\"`\n}\n\n\ntype LoadBalancer struct {\n\tCurrentCPUUtilizationPercentage int `json:\"currentCPUUtilizationPercentage\"`\n\tCurrentReplicas                 int `json:\"currentReplicas\"`\n\tDesiredReplicas                 int `json:\"desiredReplicas\"`\n}\n\n\nfunc Get(name, namespace string) (*HPA, error) {\n\tcmd := exec.Command(\"kubectl\", \"get\", \"hpa\", \"-o\", \"json\", \"-n\", namespace, name)\n\tutil.PrintCommand(cmd)\n\tout, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\tlog.Printf(\"Error trying to run 'kubectl get hpa':%s\\n\", string(out))\n\t\treturn nil, err\n\t}\n\th := HPA{}\n\terr = json.Unmarshal(out, &h)\n\tif err != nil {\n\t\tlog.Printf(\"Error unmarshalling service json:%s\\n\", err)\n\t\treturn nil, err\n\t}\n\treturn &h, nil\n}\n\n\n\n\nfunc (h *HPA) Delete(retries int) error ", "output": "{\n\tvar kubectlOutput []byte\n\tvar kubectlError error\n\tfor i := 0; i < retries; i++ {\n\t\tcmd := exec.Command(\"kubectl\", \"delete\", \"hpa\", \"-n\", h.Metadata.Namespace, h.Metadata.Name)\n\t\tkubectlOutput, kubectlError = util.RunAndLogCommand(cmd)\n\t\tif kubectlError != nil {\n\t\t\tlog.Printf(\"Error while trying to delete service %s in namespace %s:%s\\n\", h.Metadata.Namespace, h.Metadata.Name, string(kubectlOutput))\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\n\treturn kubectlError\n}"}
{"input": "package fake\n\nimport (\n\tv1beta1 \"github.com/nuclio/nuclio/pkg/platform/kube/client/clientset/versioned/typed/nuclio.io/v1beta1\"\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n)\n\ntype FakeNuclioV1beta1 struct {\n\t*testing.Fake\n}\n\n\n\nfunc (c *FakeNuclioV1beta1) NuclioFunctions(namespace string) v1beta1.NuclioFunctionInterface {\n\treturn &FakeNuclioFunctions{c, namespace}\n}\n\nfunc (c *FakeNuclioV1beta1) NuclioFunctionEvents(namespace string) v1beta1.NuclioFunctionEventInterface {\n\treturn &FakeNuclioFunctionEvents{c, namespace}\n}\n\nfunc (c *FakeNuclioV1beta1) NuclioProjects(namespace string) v1beta1.NuclioProjectInterface {\n\treturn &FakeNuclioProjects{c, namespace}\n}\n\n\n\nfunc (c *FakeNuclioV1beta1) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakeNuclioV1beta1) NuclioAPIGateways(namespace string) v1beta1.NuclioAPIGatewayInterface ", "output": "{\n\treturn &FakeNuclioAPIGateways{c, namespace}\n}"}
{"input": "package logging\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype terribadLogMessage struct{}\n\nfunc (msg terribadLogMessage) Message() string {\n\tpanic(\"never panic while logging; it's not worth crashing the app!\")\n}\nfunc (msg terribadLogMessage) DefaultLevel() Level {\n\tpanic(\"never panic while logging; it's not worth crashing the app!\")\n}\nfunc (msg terribadLogMessage) EachField(fn FieldReportFn) {\n\tpanic(\"never panic while logging; it's not worth crashing the app!\")\n}\n\n\n\nfunc TestLogMessagePanicking(t *testing.T) ", "output": "{\n\tlog, ctrl := NewLogSinkSpy(true)\n\n\tassert.NotPanics(t, func() {\n\t\tDeliver(log, terribadLogMessage{})\n\t})\n\n\tcalls := ctrl.CallsTo(\"Fields\")\n\tif assert.Len(t, calls, 2) {\n\t\tfields := calls[1].PassedArgs().Get(0).([]EachFielder)\n\t\tassert.IsType(t, &silentMessageError{}, fields[2])\n\t}\n}"}
{"input": "package collector\n\nimport (\n\t\"github.com/lowstz/mongodb_exporter/shared\"\n)\n\n\ntype NetworkStats struct {\n\tBytesIn     float64 `bson:\"bytesIn\"`\n\tBytesOut    float64 `bson:\"bytesOut\"`\n\tNumRequests float64 `bson:\"numRequests\"`\n}\n\n\n\nfunc (networkStats *NetworkStats) Export(groupName string) ", "output": "{\n\tgroup := shared.FindOrCreateGroup(groupName + \"_bytes_total\")\n\tgroup.Export(\"in_bytes\", networkStats.BytesIn)\n\tgroup.Export(\"out_bytes\", networkStats.BytesOut)\n\n\tgroup = shared.FindOrCreateGroup(groupName + \"_metrics\")\n\tgroup.Export(\"num_requests_total\", networkStats.NumRequests)\n}"}
{"input": "package iso20022\n\n\ntype Tax13 struct {\n\n\tType *TaxType9Code `xml:\"Tp\"`\n\n\tOtherTaxType *Max35Text `xml:\"OthrTaxTp\"`\n\n\tAmount *CurrencyAndAmount `xml:\"Amt\"`\n\n\tRate *PercentageRate `xml:\"Rate\"`\n}\n\nfunc (t *Tax13) SetType(value string) {\n\tt.Type = (*TaxType9Code)(&value)\n}\n\n\n\nfunc (t *Tax13) SetAmount(value, currency string) {\n\tt.Amount = NewCurrencyAndAmount(value, currency)\n}\n\nfunc (t *Tax13) SetRate(value string) {\n\tt.Rate = (*PercentageRate)(&value)\n}\n\nfunc (t *Tax13) SetOtherTaxType(value string) ", "output": "{\n\tt.OtherTaxType = (*Max35Text)(&value)\n}"}
{"input": "package widgets\n\nimport (\n\t\"strings\"\n\n\t\"github.com/ambientsound/pms/songlist\"\n\t\"github.com/ambientsound/pms/style\"\n\t\"github.com/gdamore/tcell\"\n\t\"github.com/gdamore/tcell/views\"\n)\n\ntype ColumnheadersWidget struct {\n\tcolumns songlist.Columns\n\tview    views.View\n\n\tstyle.Styled\n\tviews.WidgetWatchers\n}\n\nfunc NewColumnheadersWidget() (c *ColumnheadersWidget) {\n\tc = &ColumnheadersWidget{}\n\tc.columns = make(songlist.Columns, 0)\n\treturn\n}\n\nfunc (c *ColumnheadersWidget) SetColumns(cols songlist.Columns) {\n\tc.columns = cols\n}\n\nfunc (c *ColumnheadersWidget) Draw() {\n\tx := 0\n\ty := 0\n\tfor i := range c.columns {\n\t\tcol := c.columns[i]\n\t\ttitle := []rune(strings.Title(col.Tag()))\n\t\tp := 0\n\t\tfor _, r := range title {\n\t\t\tc.view.SetContent(x+p, y, r, nil, c.Style(\"header\"))\n\t\t\tp++\n\t\t}\n\t\tx += col.Width()\n\t}\n}\n\nfunc (c *ColumnheadersWidget) SetView(v views.View) {\n\tc.view = v\n}\n\n\n\nfunc (w *ColumnheadersWidget) Resize() {\n}\n\nfunc (w *ColumnheadersWidget) HandleEvent(ev tcell.Event) bool {\n\treturn false\n}\n\nfunc (c *ColumnheadersWidget) Size() (int, int) ", "output": "{\n\tx, y := c.view.Size()\n\ty = 1\n\treturn x, y\n}"}
{"input": "package main\n\n\n\n\n\ntype Scope struct {\n\tparent   *Scope \n\tentities map[string]*Decl\n}\n\nfunc NewScope(outer *Scope) *Scope {\n\ts := new(Scope)\n\ts.parent = outer\n\ts.entities = make(map[string]*Decl)\n\treturn s\n}\n\n\nfunc AdvanceScope(s *Scope) (*Scope, *Scope) {\n\tif len(s.entities) == 0 {\n\t\treturn s, s.parent\n\t}\n\treturn NewScope(s), s\n}\n\n\nfunc (s *Scope) addNamedDecl(d *Decl) *Decl {\n\treturn s.addDecl(d.Name, d)\n}\n\nfunc (s *Scope) addDecl(name string, d *Decl) *Decl {\n\tdecl, ok := s.entities[name]\n\tif !ok {\n\t\ts.entities[name] = d\n\t\treturn d\n\t}\n\treturn decl\n}\n\n\n\nfunc (s *Scope) mergeDecl(d *Decl) {\n\tdecl, ok := s.entities[d.Name]\n\tif !ok {\n\t\ts.entities[d.Name] = d\n\t} else {\n\t\tdecl := decl.DeepCopy()\n\t\tdecl.ExpandOrReplace(d)\n\t\ts.entities[d.Name] = decl\n\t}\n}\n\nfunc (s *Scope) lookup(name string) *Decl {\n\tdecl, ok := s.entities[name]\n\tif !ok {\n\t\tif s.parent != nil {\n\t\t\treturn s.parent.lookup(name)\n\t\t} else {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn decl\n}\n\nfunc (s *Scope) replaceDecl(name string, d *Decl) ", "output": "{\n\ts.entities[name] = d\n}"}
{"input": "package executor\n\nimport (\n\tdstructs \"github.com/hashicorp/nomad/client/driver/structs\"\n)\n\n\n\ntype resourceContainerContext struct {\n}\n\nfunc clientCleanup(ic *dstructs.IsolationConfig, pid int) error {\n\treturn nil\n}\n\nfunc (rc *resourceContainerContext) executorCleanup() error {\n\treturn nil\n}\n\n\n\nfunc (rc *resourceContainerContext) getIsolationConfig() *dstructs.IsolationConfig ", "output": "{\n\treturn nil\n}"}
{"input": "package stats\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/go-webpack/webpack/util\"\n\t\"github.com/pkg/errors\"\n)\n\ntype assetList map[string][]string\n\n\nfunc Read(isDev bool, host, fsPath, webPath string) (assetList, error) {\n\tvar data []byte\n\tvar err error\n\n\tif isDev {\n\t\tdata, err = devManifest(host, webPath)\n\t} else {\n\t\tdata, err = prodManifest(fsPath)\n\t}\n\n\tif err != nil {\n\t\treturn assetList{}, errors.Wrap(err, \"go-webpack: Error reading manifest\")\n\t}\n\n\treturn parseManifest(data)\n}\n\n\n\n\nfunc parseManifest(data []byte) (assetList, error) {\n\tvar err error\n\n\tresp := statsResponse{}\n\terr = json.Unmarshal(data, &resp)\n\tif err != nil {\n\t\treturn assetList{}, errors.Wrap(err, \"go-webpack: Error parsing manifest - json decode\")\n\t}\n\twebpackBase := resp.PublicPath\n\n\tassets := make(assetList, len(resp.AssetsByChunkName))\n\n\tfor akey, aval := range resp.AssetsByChunkName {\n\t\tvar d []string\n\t\terr = json.Unmarshal(*aval, &d)\n\t\tif err != nil {\n\t\t\treturn assets, errors.Wrap(err, fmt.Sprintf(\"go-webpack: Error when parsing manifest for %s: %s %s\", akey, err, string(*aval)))\n\t\t}\n\t\tfor i, v := range d {\n\t\t\td[i] = webpackBase + v\n\t\t}\n\n\t\tparseChunk(d, akey, &assets)\n\t}\n\treturn assets, nil\n}\n\nfunc parseChunk(d []string, akey string, assets *assetList) ", "output": "{\n\t(*assets)[akey+\".js\"] = util.Filter(d, func(v string) bool {\n\t\treturn strings.HasSuffix(v, \".js\")\n\t})\n\n\t(*assets)[akey+\".css\"] = util.Filter(d, func(v string) bool {\n\t\treturn strings.HasSuffix(v, \".css\")\n\t})\n}"}
{"input": "package threatconnect\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"io\"\n\t\"io/ioutil\"\n)\n\n\n\nfunc ResourceError(msg string, response *http.Response, rerr error) error {\n\tif rerr != nil {\n\t\treturn rerr\n\n\t}\n\tif msg != \"\" {\n\t\treturn errors.New(msg)\n\t}\n\treturn nil\n}\n\nfunc PrettyPrintJson(data io.ReadCloser) ", "output": "{\n\n\tbody, err := ioutil.ReadAll(data)\n\tif err != nil {\n\t\tlog.Fatalf(\"ERROR: %s\", err)\n\t}\n\n\tfmt.Printf(\"%s\", body)\n\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype App struct {\n\tservice *Service\n}\n\n\nfunc NewApp() (*App, error) {\n\trawAccessTokenExpiration := DefaultEnv(\"ACCESS_TOKEN_EXPIRATION\", \"15000\")\n\taccessTokenExpiration, err := strconv.Atoi(rawAccessTokenExpiration)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tauthenticator := NewUserServiceAuthenticator(\n\t\tRequireEnv(\"SERVICE_MODEL_USER\"),\n\t\tDefaultEnv(\"ISSUER\", \"service.api.auth\"),\n\t\taccessTokenExpiration,\n\t\t[]byte(RequireEnv(\"SIGNING_KEY\")),\n\t)\n\n\tservice := NewService(authenticator)\n\tservice.getParams = func(r *http.Request) map[string]string {\n\t\treturn mux.Vars(r)\n\t}\n\n\treturn &App{\n\t\tservice: service,\n\t}, nil\n}\n\nfunc (app *App) Shutdown() {\n}\n\n\n\nfunc (app *App) CreateHandler() http.Handler {\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(\"/authenticate\", app.service.Authenticate).Methods(\"POST\")\n\n\treturn router\n}\n\nfunc RequireEnv(key string) string {\n\tvalue, ok := os.LookupEnv(key)\n\tif !ok {\n\t\tpanic(fmt.Sprintf(\"Environment variable %s is mandatory\", key))\n\t}\n\n\treturn value\n}\n\nfunc DefaultEnv(key string, def string) string {\n\tvalue, ok := os.LookupEnv(key)\n\tif !ok {\n\t\treturn def\n\t}\n\n\treturn value\n}\n\nfunc (app *App) Listen() error ", "output": "{\n\thandler := app.CreateHandler()\n\n\treturn http.ListenAndServe(\":80\", handler)\n}"}
{"input": "package detector\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/thoughtworks/talisman/git_repo\"\n)\n\nconst (\n\tCommentPattern string = \"#\"\n\n\tDefaultIgnoreFileName string = \".talismanignore\"\n)\n\n\n\ntype Ignores struct {\n\tpatterns []string\n}\n\n\n\n\nfunc ReadIgnoresFromFile(repoFileRead func(string) ([]byte, error)) Ignores {\n\tcontents, err := repoFileRead(DefaultIgnoreFileName)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar trimmedLines []string\n\tfor _, line := range strings.Split(string(contents), \"\\n\") {\n\t\ttrimmedLines = append(trimmedLines, strings.TrimSpace(line))\n\t}\n\treturn NewIgnores(trimmedLines...)\n}\n\n\n\n\n\n\nfunc (i Ignores) AcceptsAll() bool {\n\treturn len(i.effectiveRules()) == 0\n}\n\n\nfunc (i Ignores) Accept(addition git_repo.Addition) bool {\n\treturn !i.Deny(addition)\n}\n\n\nfunc (i Ignores) Deny(addition git_repo.Addition) bool {\n\tresult := false\n\tfor _, pattern := range i.effectiveRules() {\n\t\tresult = result || addition.Matches(pattern)\n\t}\n\treturn result\n}\n\nfunc (i Ignores) effectiveRules() []string {\n\tvar result []string\n\tfor _, pattern := range i.patterns {\n\t\tif !isEmptyOrComment(pattern) {\n\t\t\tresult = append(result, pattern)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc isEmptyOrComment(pattern string) bool {\n\treturn isEmptyString(pattern) || strings.HasPrefix(pattern, CommentPattern)\n}\n\nfunc isEmptyString(str string) bool {\n\tvar emptyStringPattern = regexp.MustCompile(\"^\\\\s*$\")\n\treturn emptyStringPattern.MatchString(str)\n}\n\nfunc NewIgnores(ignoreSpecs ...string) Ignores ", "output": "{\n\treturn Ignores{ignoreSpecs}\n}"}
{"input": "package deviceorientation\n\nimport (\n\t\"github.com/neelance/cdp-go/rpc\"\n)\n\n\ntype Client struct {\n\t*rpc.Client\n}\n\ntype SetDeviceOrientationOverrideRequest struct {\n\tclient *rpc.Client\n\topts   map[string]interface{}\n}\n\n\nfunc (d *Client) SetDeviceOrientationOverride() *SetDeviceOrientationOverrideRequest {\n\treturn &SetDeviceOrientationOverrideRequest{opts: make(map[string]interface{}), client: d.Client}\n}\n\n\nfunc (r *SetDeviceOrientationOverrideRequest) Alpha(v float64) *SetDeviceOrientationOverrideRequest {\n\tr.opts[\"alpha\"] = v\n\treturn r\n}\n\n\nfunc (r *SetDeviceOrientationOverrideRequest) Beta(v float64) *SetDeviceOrientationOverrideRequest {\n\tr.opts[\"beta\"] = v\n\treturn r\n}\n\n\n\n\nfunc (r *SetDeviceOrientationOverrideRequest) Do() error {\n\treturn r.client.Call(\"DeviceOrientation.setDeviceOrientationOverride\", r.opts, nil)\n}\n\ntype ClearDeviceOrientationOverrideRequest struct {\n\tclient *rpc.Client\n\topts   map[string]interface{}\n}\n\n\nfunc (d *Client) ClearDeviceOrientationOverride() *ClearDeviceOrientationOverrideRequest {\n\treturn &ClearDeviceOrientationOverrideRequest{opts: make(map[string]interface{}), client: d.Client}\n}\n\nfunc (r *ClearDeviceOrientationOverrideRequest) Do() error {\n\treturn r.client.Call(\"DeviceOrientation.clearDeviceOrientationOverride\", r.opts, nil)\n}\n\nfunc init() {\n}\n\nfunc (r *SetDeviceOrientationOverrideRequest) Gamma(v float64) *SetDeviceOrientationOverrideRequest ", "output": "{\n\tr.opts[\"gamma\"] = v\n\treturn r\n}"}
{"input": "package common\n\nimport (\n\t\"github.com/golang/protobuf/proto\"\n\t\"github.com/hyperledger/fabric/core/util\"\n)\n\nfunc (b *BlockHeader) Hash() []byte {\n\tdata, err := proto.Marshal(b) \n\tif err != nil {\n\t\tpanic(\"This should never fail and is generally irrecoverable\")\n\t}\n\n\treturn util.ComputeCryptoHash(data)\n}\n\n\n\nfunc (b *BlockData) Hash() []byte ", "output": "{\n\tdata, err := proto.Marshal(b) \n\tif err != nil {\n\t\tpanic(\"This should never fail and is generally irrecoverable\")\n\t}\n\n\treturn util.ComputeCryptoHash(data)\n}"}
{"input": "package grpc\n\nimport (\n\t\"github.com/micro/go-micro/v3/client\"\n)\n\ntype grpcEvent struct {\n\ttopic       string\n\tcontentType string\n\tpayload     interface{}\n}\n\nfunc newGRPCEvent(topic string, payload interface{}, contentType string, opts ...client.MessageOption) client.Message {\n\tvar options client.MessageOptions\n\tfor _, o := range opts {\n\t\to(&options)\n\t}\n\n\tif len(options.ContentType) > 0 {\n\t\tcontentType = options.ContentType\n\t}\n\n\treturn &grpcEvent{\n\t\tpayload:     payload,\n\t\ttopic:       topic,\n\t\tcontentType: contentType,\n\t}\n}\n\nfunc (g *grpcEvent) ContentType() string {\n\treturn g.contentType\n}\n\n\n\nfunc (g *grpcEvent) Payload() interface{} {\n\treturn g.payload\n}\n\nfunc (g *grpcEvent) Topic() string ", "output": "{\n\treturn g.topic\n}"}
{"input": "package walk\n\nimport (\n\t\"time\"\n)\n\nimport (\n\t\"github.com/lxn/win\"\n)\n\ntype Settings interface {\n\tGet(key string) (string, bool)\n\tTimestamp(key string) (time.Time, bool)\n\tPut(key, value string) error\n\tPutExpiring(key, value string) error\n\tRemove(key string) error\n\tExpireDuration() time.Duration\n\tSetExpireDuration(expireDuration time.Duration)\n\tLoad() error\n\tSave() error\n}\n\ntype Persistable interface {\n\tPersistent() bool\n\tSetPersistent(value bool)\n\tSaveState() error\n\tRestoreState() error\n}\n\ntype Application struct {\n\torganizationName   string\n\tproductName        string\n\tsettings           Settings\n\texiting            bool\n\texitCode           int\n\tpanickingPublisher ErrorEventPublisher\n}\n\nvar appSingleton *Application = new(Application)\n\nfunc App() *Application {\n\treturn appSingleton\n}\n\nfunc (app *Application) OrganizationName() string {\n\treturn app.organizationName\n}\n\n\n\nfunc (app *Application) ProductName() string {\n\treturn app.productName\n}\n\nfunc (app *Application) SetProductName(value string) {\n\tapp.productName = value\n}\n\nfunc (app *Application) Settings() Settings {\n\treturn app.settings\n}\n\nfunc (app *Application) SetSettings(value Settings) {\n\tapp.settings = value\n}\n\nfunc (app *Application) Exit(exitCode int) {\n\tapp.exiting = true\n\tapp.exitCode = exitCode\n\twin.PostQuitMessage(int32(exitCode))\n}\n\nfunc (app *Application) ExitCode() int {\n\treturn app.exitCode\n}\n\nfunc (app *Application) Panicking() *ErrorEvent {\n\treturn app.panickingPublisher.Event()\n}\n\nfunc (app *Application) SetOrganizationName(value string) ", "output": "{\n\tapp.organizationName = value\n}"}
{"input": "package arg\n\nimport (\n\t\"strings\"\n\n\t\"github.com/dtan4/paus-frontend/store\"\n)\n\n\n\nfunc Delete(etcd *store.Etcd, username, appName, key string) error {\n\tif err := etcd.Delete(\"/paus/users/\" + username + \"/apps/\" + appName + \"/build-args/\" + key); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc List(etcd *store.Etcd, username, appName string) (*map[string]string, error) {\n\tenvs, err := etcd.ListWithValues(\"/paus/users/\"+username+\"/apps/\"+appName+\"/build-args/\", true)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult := map[string]string{}\n\n\tfor key, value := range *envs {\n\t\tenvKey := strings.Replace(key, \"/paus/users/\"+username+\"/apps/\"+appName+\"/build-args/\", \"\", 1)\n\t\tresult[envKey] = value\n\t}\n\n\treturn &result, nil\n}\n\nfunc Create(etcd *store.Etcd, username, appName, key, value string) error ", "output": "{\n\tif err := etcd.Set(\"/paus/users/\"+username+\"/apps/\"+appName+\"/build-args/\"+key, value); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package uaa\n\n\nconst MFAProvidersEndpoint string = \"/mfa-providers\"\n\n\ntype MFAProviderConfig struct {\n\tIssuer              string `json:\"issuer,omitempty\"`\n\tProviderDescription string `json:\"providerDescription,omitempty\"`\n}\n\n\n\ntype MFAProvider struct {\n\tID             string            `json:\"id,omitempty\"`\n\tName           string            `json:\"name\"`\n\tIdentityZoneID string            `json:\"identityZoneId,omitempty\"`\n\tConfig         MFAProviderConfig `json:\"config\"`\n\tType           string            `json:\"type\"`\n\tCreated        int               `json:\"created,omitempty\"`\n\tLastModified   int               `json:\"last_modified,omitempty\"`\n}\n\n\n\n\nfunc (m MFAProvider) Identifier() string ", "output": "{\n\treturn m.ID\n}"}
{"input": "package client\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype SystemSettings struct {\n\tuserStreamAcl   *StreamAcl\n\tsystemStreamAcl *StreamAcl\n}\n\nfunc NewSystemSettings(\n\tuserStreamAcl *StreamAcl,\n\tsystemStreamAcl *StreamAcl,\n) *SystemSettings {\n\treturn &SystemSettings{userStreamAcl, systemStreamAcl}\n}\n\n\n\nfunc (s *SystemSettings) SystemStreamAcl() *StreamAcl { return s.systemStreamAcl }\n\nfunc (s *SystemSettings) String() string {\n\treturn fmt.Sprintf(\"&{userStreamAcl:%+v systemStreamAcl:%+v}\", s.userStreamAcl, s.systemStreamAcl)\n}\n\ntype systemSettingsJson struct {\n\tUserStreamAcl   *StreamAcl `json:\"$userStreamAcl,omitempty\"`\n\tSystemStreamAcl *StreamAcl `json:\"$systemStreamAcl,omitempty\"`\n}\n\nfunc (s *SystemSettings) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(systemSettingsJson{\n\t\tUserStreamAcl:   s.userStreamAcl,\n\t\tSystemStreamAcl: s.systemStreamAcl,\n\t})\n}\n\nfunc (s *SystemSettings) UnmarshalJSON(data []byte) error {\n\tss := systemSettingsJson{}\n\tif err := json.Unmarshal(data, &ss); err != nil {\n\t\treturn err\n\t}\n\ts.userStreamAcl = ss.UserStreamAcl\n\ts.systemStreamAcl = ss.SystemStreamAcl\n\treturn nil\n}\n\nfunc SystemSettingsFromJsonBytes(data []byte) (*SystemSettings, error) {\n\tsystemSettings := &SystemSettings{}\n\treturn systemSettings, json.Unmarshal(data, systemSettings)\n}\n\nfunc (s *SystemSettings) UserStreamAcl() *StreamAcl ", "output": "{ return s.userStreamAcl }"}
{"input": "package fields\n\nimport (\n\t\"regexp\"\n\t\"time\"\n)\n\nfunc UseDefaultKeyIfCustomKeyIsEmpty(defaultKey, customKey string) string {\n\tif \"\" != customKey {\n\t\treturn customKey\n\t}\n\treturn defaultKey\n}\n\n\n\nfunc getMessageFromError(err error) string {\n\tif nil == err {\n\t\treturn \"\"\n\t}\n\treturn err.Error()\n}\n\nfunc getPatternFromRegExp(re *regexp.Regexp) string {\n\tif nil == re {\n\t\treturn \"\"\n\t}\n\treturn re.String()\n}\n\nfunc execFnIfNotNil(fn func()) {\n\tif nil != fn {\n\t\tfn()\n\t}\n}\n\nfunc addSuffix(name string, suffix *string) string {\n\tif nil != suffix {\n\t\treturn name + \"-\" + *suffix\n\t}\n\treturn name\n}\n\nfunc _useDefaultIfNotUserDefinedOrCouldntFindIt(defaultLoc *time.Location, locationByString *string) (*time.Location, int) {\n\tif nil == locationByString || \"\" == *locationByString {\n\t\treturn defaultLoc, 1\n\t}\n\n\tif loc, err := time.LoadLocation(*locationByString); nil == err {\n\t\treturn loc, 2\n\t}\n\n\treturn defaultLoc, 0\n}\n\n\nfunc useDefaultIfNotUserDefinedOrCouldntFindIt(defaultLoc *time.Location, locationByString *string) *time.Location {\n\tloc, _ := _useDefaultIfNotUserDefinedOrCouldntFindIt(defaultLoc, locationByString)\n\treturn loc\n}\n\nfunc ExecFuncIfErrIsNotNil(err error, fn func()) (b bool) ", "output": "{\n\tif nil != err {\n\t\tfn()\n\t\tb = true\n\t}\n\treturn\n}"}
{"input": "package ble\n\nimport (\n\t\"bytes\"\n\n\t\"gobot.io/x/gobot\"\n)\n\n\ntype BatteryDriver struct {\n\tname       string\n\tconnection gobot.Connection\n\tgobot.Eventer\n}\n\n\nfunc NewBatteryDriver(a *ClientAdaptor) *BatteryDriver {\n\tn := &BatteryDriver{\n\t\tname:       gobot.DefaultName(\"Battery\"),\n\t\tconnection: a,\n\t\tEventer:    gobot.NewEventer(),\n\t}\n\n\treturn n\n}\n\n\nfunc (b *BatteryDriver) Connection() gobot.Connection { return b.connection }\n\n\nfunc (b *BatteryDriver) Name() string { return b.name }\n\n\nfunc (b *BatteryDriver) SetName(n string) { b.name = n }\n\n\nfunc (b *BatteryDriver) adaptor() *ClientAdaptor {\n\treturn b.Connection().(*ClientAdaptor)\n}\n\n\nfunc (b *BatteryDriver) Start() (err error) {\n\treturn\n}\n\n\n\n\n\nfunc (b *BatteryDriver) GetBatteryLevel() (level uint8) {\n\tvar l uint8\n\tc, _ := b.adaptor().ReadCharacteristic(\"2a19\")\n\tbuf := bytes.NewBuffer(c)\n\tval, _ := buf.ReadByte()\n\tl = uint8(val)\n\treturn l\n}\n\nfunc (b *BatteryDriver) Halt() (err error) ", "output": "{ return }"}
{"input": "package builtin\n\nconst screenInhibitControlSummary = `allows inhibiting the screen saver`\n\nconst screenInhibitControlConnectedPlugAppArmor = `\n# Description: Can inhibit and uninhibit screen savers in desktop sessions.\n#include <abstractions/dbus-session-strict>\n#include <abstractions/dbus-strict>\n\n# gnome-session\ndbus (send)\n    bus=session\n    path=/org/gnome/SessionManager\n    interface=org.gnome.SessionManager\n    member={Inhibit,Uninhibit}\n    peer=(label=unconfined),\n\n# unity screen API\ndbus (send)\n    bus=system\n    interface=\"org.freedesktop.DBus.Introspectable\"\n    path=\"/com/canonical/Unity/Screen\"\n    member=\"Introspect\"\n    peer=(label=unconfined),\ndbus (send)\n    bus=system\n    interface=\"com.canonical.Unity.Screen\"\n    path=\"/com/canonical/Unity/Screen\"\n    member={keepDisplayOn,removeDisplayOnRequest}\n    peer=(label=unconfined),\n\n# freedesktop.org ScreenSaver\ndbus (send)\n    bus=session\n    path=/Screensaver\n    interface=org.freedesktop.ScreenSaver\n    member=org.freedesktop.ScreenSaver.{Inhibit,UnInhibit,SimulateUserActivity}\n    peer=(label=unconfined),\n\n# gnome, kde and cinnamon screensaver\ndbus (send)\n    bus=session\n    path=/{,ScreenSaver}\n    interface=org.{gnome.ScreenSaver,kde.screensaver,cinnamon.ScreenSaver}\n    member=SimulateUserActivity\n    peer=(label=unconfined),\n`\n\n\n\nfunc init() ", "output": "{\n\tregisterIface(&commonInterface{\n\t\tname:                  \"screen-inhibit-control\",\n\t\tsummary:               screenInhibitControlSummary,\n\t\timplicitOnClassic:     true,\n\t\tconnectedPlugAppArmor: screenInhibitControlConnectedPlugAppArmor,\n\t\treservedForOS:         true,\n\t})\n}"}
{"input": "package ledclient\n\nimport (\n\tcolorful \"github.com/lucasb-eyer/go-colorful\"\n)\n\n\ntype Canvas struct {\n\tpixels []colorful.Color\n\twidth  int\n\theight int\n}\n\nfunc NewCanvas(width, height int) *Canvas {\n\treturn &Canvas{\n\t\tpixels: make([]colorful.Color, width*height),\n\t\twidth:  width,\n\t\theight: height,\n\t}\n}\n\nfunc (c *Canvas) PixelIndex(x, y int) int {\n\treturn c.width*y + x\n}\n\n\n\nfunc (c *Canvas) At(x, y int) colorful.Color {\n\treturn c.pixels[c.PixelIndex(x, y)]\n}\n\nfunc (c *Canvas) Size() (int, int) {\n\treturn c.width, c.height\n}\n\nfunc (c *Canvas) Set(x, y int, col colorful.Color) ", "output": "{\n\tc.pixels[c.PixelIndex(x, y)] = col\n}"}
{"input": "package tfexec\n\nimport (\n\t\"context\"\n\t\"os/exec\"\n\n\ttfjson \"github.com/hashicorp/terraform-json\"\n)\n\n\nfunc (tf *Terraform) ProvidersSchema(ctx context.Context) (*tfjson.ProviderSchemas, error) {\n\tschemaCmd := tf.providersSchemaCmd(ctx)\n\n\tvar ret tfjson.ProviderSchemas\n\terr := tf.runTerraformCmdJSON(schemaCmd, &ret)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = ret.Validate()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ret, nil\n}\n\n\n\nfunc (tf *Terraform) providersSchemaCmd(ctx context.Context, args ...string) *exec.Cmd ", "output": "{\n\tallArgs := []string{\"providers\", \"schema\", \"-json\", \"-no-color\"}\n\tallArgs = append(allArgs, args...)\n\n\treturn tf.buildTerraformCmd(ctx, nil, allArgs...)\n}"}
{"input": "package util\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\n\n\nfunc HRBserive(SetRun bool) ", "output": "{\n\tvar cmd *exec.Cmd\n\n\tif SetRun {\n\t\tcmd = exec.Command(\"net\", \"start\", \"HitRobotBase\")\n\t} else {\n\t\tcmd = exec.Command(\"net\", \"stop\", \"HitRobotBase\")\n\n\t}\n\n\terr := cmd.Run()\n\tif err !=nil{\n\t\tfmt.Printf(\"%+v\",err)\n\t}\n\n\tcmd.Wait()\n\n\n}"}
{"input": "package zookeeper\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/magneticio/vamp-router/haproxy\"\n\tgologger \"github.com/op/go-logging\"\n\t\"github.com/samuel/go-zookeeper/zk\"\n\t\"strings\"\n\t\"time\"\n)\n\n\ntype ZkClient struct {\n\tconn     *zk.Conn\n\thaConfig *haproxy.Config\n\tlog      *gologger.Logger\n}\n\n\n\n\nfunc (z *ZkClient) connect(conString string) error {\n\tzks := strings.Split(conString, \",\")\n\tconn, _, err := zk.Connect(zks, (60 * time.Second))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tz.conn = conn\n\treturn nil\n}\n\n\nfunc (z *ZkClient) Watch(path string) {\n\n\tgo z.watcher(path)\n\n}\n\nfunc (z *ZkClient) watcher(path string) error {\n\n\tfor {\n\t\tpayload, _, watch, err := z.conn.GetW(path)\n\n\t\tif err != nil {\n\t\t\tz.log.Error(\"Error from Zookeeper: \" + err.Error())\n\t\t}\n\n\t\terr = json.Unmarshal(payload, &z.haConfig)\n\t\tif err != nil {\n\t\t\tz.log.Error(\"Error parsing config from Zookeeper: \" + err.Error())\n\t\t}\n\n\t\tevent := <-watch\n\n\t\tz.log.Notice(\"Received Zookeeper event: \" + event.Type.String())\n\n\t\terr = json.Unmarshal(payload, &z.haConfig)\n\t\tif err != nil {\n\t\t\tz.log.Error(\"Error parsing config from Zookeeper: \" + err.Error())\n\t\t}\n\n\t}\n\n}\n\nfunc (z *ZkClient) Init(conString string, conf *haproxy.Config, log *gologger.Logger) error ", "output": "{\n\n\tz.log = log\n\tz.haConfig = conf\n\terr := z.connect(conString)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package bunny\n\nimport (\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Bunny interface {\n\tHealthy() bool\n}\n\ntype HttpBunny struct {\n\turl string\n}\n\ntype BunnyStatus struct {\n\tName   string `json:\"name\"`\n\tStatus string `json:\"status\"`\n\tProcessTime int `json:\"timeToEvaluate\"`\n}\n\n\n\n\nfunc(bunny HttpBunny) Update() (bunnyStatus BunnyStatus) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\tclient := &http.Client{Transport: tr}\n\n\n\tres, err := client.Get(bunny.url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tbunnyStatus.Status = \"ERROR\"\n\t}\n\tbody, err := ioutil.ReadAll(res.Body)\n\tres.Body.Close()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tbunnyStatus.Status = \"ERROR\"\n\t}else{\n\t\tjson.Unmarshal(body, &bunnyStatus)\n\t}\n\treturn\n}\n\nfunc NewBunny(url string) (bunny HttpBunny) ", "output": "{\n\tbunny.url = url\n\treturn\n}"}
{"input": "package visa\n\nimport (\n\t\"fmt\"\n\t\"log\"\n)\n\n\nvar drivers = make(map[InterfaceType]Driver)\n\n\n\ntype Driver interface {\n\tOpen(address string) (Resource, error)\n}\n\n\nfunc Register(interfaceType InterfaceType, driver Driver) {\n\tif _, exists := drivers[interfaceType]; exists {\n\t\tlog.Fatalln(interfaceType, \"Driver already registered\")\n\t}\n\tdrivers[interfaceType] = driver\n}\n\n\ntype Resource interface {\n\tClose() error\n\tRead(p []byte) (n int, err error)\n\tWrite(p []byte) (n int, err error)\n\tWriteString(s string) (n int, err error)\n\tQuery(s string) (value string, err error)\n}\n\n\n\n\nfunc NewResource(address string) (Resource, error) ", "output": "{\n\tinterfaceType, err := determineInterfaceType(address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdriver, exists := drivers[interfaceType]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"unregistered interface: %s\", interfaceType)\n\t}\n\treturn driver.Open(address)\n}"}
{"input": "package internalversion\n\nimport (\n\t\"fmt\"\n\tschema \"k8s.io/apimachinery/pkg/runtime/schema\"\n\tcache \"github.com/hyperhq/client-go/tools/cache\"\n\texample \"k8s.io/code-generator/_examples/apiserver/apis/example\"\n\texample2 \"k8s.io/code-generator/_examples/apiserver/apis/example2\"\n)\n\n\n\ntype GenericInformer interface {\n\tInformer() cache.SharedIndexInformer\n\tLister() cache.GenericLister\n}\n\ntype genericInformer struct {\n\tinformer cache.SharedIndexInformer\n\tresource schema.GroupResource\n}\n\n\n\n\n\nfunc (f *genericInformer) Lister() cache.GenericLister {\n\treturn cache.NewGenericLister(f.Informer().GetIndexer(), f.resource)\n}\n\n\n\nfunc (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) {\n\tswitch resource {\n\tcase example.SchemeGroupVersion.WithResource(\"testtypes\"):\n\t\treturn &genericInformer{resource: resource.GroupResource(), informer: f.Example().InternalVersion().TestTypes().Informer()}, nil\n\n\tcase example2.SchemeGroupVersion.WithResource(\"testtypes\"):\n\t\treturn &genericInformer{resource: resource.GroupResource(), informer: f.SecondExample().InternalVersion().TestTypes().Informer()}, nil\n\n\t}\n\n\treturn nil, fmt.Errorf(\"no informer found for %v\", resource)\n}\n\nfunc (f *genericInformer) Informer() cache.SharedIndexInformer ", "output": "{\n\treturn f.informer\n}"}
{"input": "package syncernotify\n\nimport (\n\t\"sync\"\n\n\tpb \"github.com/apache/servicecomb-service-center/pkg/dump\"\n\t\"github.com/apache/servicecomb-service-center/pkg/log\"\n)\n\nvar syncerNotifyService *Service\n\nfunc init() {\n\tsyncerNotifyService = NewSyncerNotifyService()\n}\n\nfunc GetSyncerNotifyCenter() *Service {\n\treturn syncerNotifyService\n}\n\ntype Service struct {\n\tinstEventCh chan *pb.WatchInstanceChangedEvent\n\tmux         sync.RWMutex\n\tisClose     bool\n}\n\nfunc NewSyncerNotifyService() *Service {\n\treturn &Service{\n\t\tinstEventCh: make(chan *pb.WatchInstanceChangedEvent, InstanceEventQueueSize),\n\t\tisClose:     true,\n\t}\n}\n\nfunc (s *Service) AddEvent(event *pb.WatchInstanceChangedEvent) {\n\ts.instEventCh <- event\n\tlog.Debugf(\"add instance event to instance event channel, instEventCh len is:%s\", len(s.instEventCh))\n}\n\nfunc (s *Service) Start() {\n\tif !s.Closed() {\n\t\tlog.Warnf(\"syncer notify service is already running\")\n\t\treturn\n\t}\n\n\ts.mux.Lock()\n\ts.isClose = false\n\ts.mux.Unlock()\n\n\tlog.Debugf(\"syncer notify service is started\")\n}\n\n\n\nfunc (s *Service) Stop() {\n\tif s.Closed() {\n\t\treturn\n\t}\n\ts.mux.Lock()\n\ts.isClose = true\n\ts.mux.Unlock()\n\n\tlog.Debug(\"syncer notify service stopped\")\n}\n\nfunc (s *Service) Closed() (b bool) ", "output": "{\n\ts.mux.RLock()\n\tb = s.isClose\n\ts.mux.RUnlock()\n\treturn b\n}"}
{"input": "package arn\n\n\ntype PersonName struct {\n\tEnglish  Name `json:\"english\" editable:\"true\"`\n\tJapanese Name `json:\"japanese\" editable:\"true\"`\n}\n\n\n\n\n\nfunc (name *PersonName) ByUser(user *User) string {\n\tif user == nil {\n\t\treturn name.English.String()\n\t}\n\n\tswitch user.Settings().TitleLanguage {\n\tcase \"japanese\":\n\t\tif name.Japanese.String() == \"\" {\n\t\t\treturn name.English.String()\n\t\t}\n\n\t\treturn name.Japanese.String()\n\n\tdefault:\n\t\treturn name.English.String()\n\t}\n}\n\nfunc (name *PersonName) String() string ", "output": "{\n\treturn name.ByUser(nil)\n}"}
{"input": "package unicodes\n\nimport (\n\t\"unicode\"\n)\n\n\n\n\nfunc IsGraphic(r rune) bool {\n\treturn unicode.IsGraphic(r)\n}\n\n\n\n\n\n\nfunc IsPrint(r rune) bool {\n\treturn unicode.IsPrint(r)\n}\n\n\n\n\n\n\nfunc In(r rune, ranges ...*unicode.RangeTable) bool {\n\treturn unicode.In(r, ranges...)\n}\n\n\n\n\nfunc IsControl(r rune) bool {\n\treturn unicode.IsControl(r)\n}\n\n\nfunc IsLetter(r rune) bool {\n\treturn unicode.IsLetter(r)\n}\n\n\nfunc IsMark(r rune) bool {\n\treturn unicode.IsMark(r)\n}\n\n\nfunc IsNumber(r rune) bool {\n\treturn unicode.IsNumber(r)\n}\n\n\n\nfunc IsPunct(r rune) bool {\n\treturn unicode.IsPunct(r)\n}\n\n\n\n\n\n\n\nfunc IsSpace(r rune) bool {\n\treturn unicode.IsSpace(r)\n}\n\n\nfunc IsSymbol(r rune) bool {\n\treturn unicode.IsSymbol(r)\n}\n\nfunc IsOneOf(ranges []*unicode.RangeTable, r rune) bool ", "output": "{\n\treturn unicode.IsOneOf(ranges, r)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/julienschmidt/httprouter\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestHealthzHandler(t *testing.T) {\n\trouter := httprouter.New()\n\trouter.GET(\"/healthz\", HealthzHandler)\n\n\tsrv := httptest.NewServer(router)\n\tdefer srv.Close()\n\n\tresponse := doHTTPRequest(\"GET\", fmt.Sprintf(\"%s/healthz\", srv.URL))\n\tassert.Exactly(t, http.StatusOK, response.StatusCode)\n}\n\nfunc doHTTPRequest(method, url string) *http.Response ", "output": "{\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDisableKeepAlives: true,\n\t\t},\n\t}\n\n\trequest, _ := http.NewRequest(method, url, nil)\n\tresponse, _ := client.Do(request)\n\treturn response\n}"}
{"input": "package leetcode\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestFindPoisonedDuration(t *testing.T) ", "output": "{\n\tassert.EqualValues(t, 4, findPoisonedDuration([]int{1, 4}, 2))\n\tassert.EqualValues(t, 3, findPoisonedDuration([]int{1, 2}, 2))\n\tassert.EqualValues(t, 12, findPoisonedDuration([]int{1, 3, 5}, 8))\n}"}
{"input": "package processor\n\nimport (\n\t\"math\"\n\n\t\"github.com/guzzlerio/corcel/core\"\n)\n\n\ntype JobIterationStream struct {\n\tjobCount   int\n\titerations int\n\tcount      int\n\tposition   int\n\tstream     JobRevolvingStream\n}\n\n\nfunc CreateJobIterationStream(stream JobRevolvingStream, jobCount int, iterations int) *JobIterationStream {\n\treturn &JobIterationStream{\n\t\tjobCount:   jobCount,\n\t\titerations: iterations,\n\t\tcount:      0,\n\t\tstream:     stream,\n\t}\n}\n\n\nfunc (instance *JobIterationStream) HasNext() bool {\n\treturn instance.count < instance.iterations\n}\n\n\nfunc (instance *JobIterationStream) Next() core.Job {\n\tif instance.position == instance.jobCount-1 {\n\t\tinstance.position = 0\n\t\tinstance.count++\n\t} else {\n\t\tinstance.position++\n\t}\n\telement := instance.stream.Next()\n\treturn element\n}\n\n\nfunc (instance *JobIterationStream) Reset() {\n\tinstance.count = 0\n\tinstance.position = 0\n}\n\n\n\n\n\nfunc (instance *JobIterationStream) Size() int {\n\treturn instance.iterations\n}\n\nfunc (instance *JobIterationStream) Progress() int ", "output": "{\n\tcurrent := float64(instance.count) / float64(instance.iterations)\n\treturn int(math.Floor(current * 100))\n}"}
{"input": "package eventgrid\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\nfunc UserAgent() string {\n\treturn \"Azure-SDK-For-Go/\" + Version() + \" eventgrid/2019-02-01-preview\"\n}\n\n\n\n\nfunc Version() string ", "output": "{\n\treturn version.Number\n}"}
{"input": "package mysql\n\nimport (\n\t\"database/sql\"\n\n\t\"github.com/davygeek/vmworld/vm-api/model\"\n)\n\ntype VMImageDBIMPL struct {\n\tconn *sql.DB\n}\n\nconst (\n\tGET_VMIMAGE_BY_UUID = \"SELECT uuid, vmimage_name, storage_name, size, type, description, deleted, create_time FROM \" +\n\t\t\" vmimage WHERE uuid = ? AND deleted = 0 ORDER BY create_time desc\"\n\n\tGET_VMIMAGES = \"SELECT uuid, vmimage_name, storage_name, size, type, description, deleted, create_time FROM \" +\n\t\t\" vmimage WHERE deleted = 0 ORDER BY create_time desc\"\n)\n\nfunc (vmImageDB *VMImageDBIMPL) GetVMImageByUUID(uuid string) (*model.VMImage, error) {\n\tstmt, err := vmImageDB.conn.Prepare(GET_VMIMAGE_BY_UUID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\n\trow := stmt.QueryRow(uuid)\n\tvmImage := new(model.VMImage)\n\tif err = row.Scan(&vmImage.UUID, &vmImage.VMImageName, &vmImage.StorageName, &vmImage.Size, &vmImage.Type,\n\t\t&vmImage.Description, &vmImage.Deleted, &vmImage.CreateTime); err != nil {\n\t\treturn nil, err\n\t}\n\treturn vmImage, nil\n}\n\n\n\nfunc (vmImageDB *VMImageDBIMPL) GetVMImages() ([]*model.VMImage, error) ", "output": "{\n\tstmt, err := vmImageDB.conn.Prepare(GET_VMIMAGES)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer stmt.Close()\n\n\trows, err := stmt.Query()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvmImages := make([]*model.VMImage, 0)\n\tfor rows.Next() {\n\t\tvmImage := new(model.VMImage)\n\t\tif err = rows.Scan(&vmImage.UUID, &vmImage.VMImageName, &vmImage.StorageName, &vmImage.Size, &vmImage.Type,\n\t\t\t&vmImage.Description, &vmImage.Deleted, &vmImage.CreateTime); err != nil {\n\t\t\treturn vmImages, err\n\t\t}\n\t\tvmImages = append(vmImages, vmImage)\n\t}\n\treturn vmImages, nil\n}"}
{"input": "package main\n\nimport (\n\t\"bazil.org/fuse\"\n\t\"bazil.org/fuse/fs\"\n\t\"github.com/boltdb/bolt\"\n)\n\n\n\nfunc mount(dbpath, mountpoint string) error ", "output": "{\n\tdb, err := bolt.Open(dbpath, 0600, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc, err := fuse.Mount(mountpoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer c.Close()\n\n\tfilesys := &FS{\n\t\tdb: db,\n\t}\n\tif err := fs.Serve(c, filesys); err != nil {\n\t\treturn err\n\t}\n\n\t<-c.Ready\n\tif err := c.MountError; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package app\n\nimport (\n\tlog \"code.google.com/p/log4go\"\n\t\"github.com/sf100/go-uuid/uuid\"\n\t\"time\"\n)\n\n\n\n\nfunc genToken(user *User) (string, error) ", "output": "{\n\n\tconn := rs.getConn(\"token\")\n\tif conn == nil {\n\t\treturn \"\", RedisNoConnErr\n\t}\n\n\tdefer conn.Close()\n\n\tconfExpire := int64(Conf.TokenExpire)\n\texpire := confExpire + time.Now().Unix()\n\ttoken := user.Id + \"_\" + uuid.New()\n\n\tif err := conn.Send(\"HSET\", token, \"expire\", expire); err != nil {\n\t\tlog.Error(err)\n\t\treturn \"\", err\n\t}\n\n\tif err := conn.Send(\"EXPIRE\", token, confExpire); err != nil {\n\t\tlog.Error(err)\n\t\treturn \"\", err\n\t}\n\n\tif err := conn.Flush(); err != nil {\n\t\tlog.Error(err)\n\t\treturn \"\", err\n\t}\n\n\t_, err := conn.Receive()\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn \"\", err\n\t}\n\n\treturn token, nil\n}"}
{"input": "package test\n\nimport (\n\t\"database/sql\"\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\n\n\nfunc ConnectMySQL(dsn string) (*sql.DB, error) ", "output": "{\n\tdb, err := sql.Open(\"mysql\", dsn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := db.Ping(); err != nil {\n\t\tdb.Close()\n\t\treturn nil, err\n\t}\n\treturn db, nil\n}"}
{"input": "package plugin_server\n\nimport (\n\t\"github.com/pivotal-golang/lager\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/rpc\"\n)\n\ntype PluginServer interface {\n\tStart() error\n\tTest(string, *StringResponse) error\n}\n\ntype pluginServer struct {\n\tlogger lager.Logger\n}\n\ntype StringResponse struct {\n\tStringResponse string\n}\n\nfunc NewPluginServer(logger lager.Logger) PluginServer {\n\treturn &pluginServer{\n\t\tlogger: logger,\n\t}\n}\n\nfunc (p *pluginServer) Start() error {\n\tp.logger.Debug(\"Starting plugin server...\")\n\n\trpc.Register(p)\n\trpc.HandleHTTP()\n\tlistener, err := net.Listen(\"tcp\", \":4249\")\n\tif err != nil {\n\t\tp.logger.Error(\"Error starting RPC client\", err)\n\t\treturn err\n\t}\n\n\tgo http.Serve(listener, nil)\n\n\tp.logger.Debug(\"Plugin server started\")\n\treturn nil\n}\n\n\n\nfunc (p *pluginServer) Test(request string, response *StringResponse) error ", "output": "{\n\tp.logger.Debug(\"Plugin server received Test call: \" + request)\n\n\tresponse.StringResponse = \"Hello from GoHome!\"\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gabriel-comeau/SimpleChatCommon\"\n\t\"github.com/gabriel-comeau/tbuikit\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n\n\nfunc createMessageForBroadCast(text string, sender *ChatClient) *tbuikit.ColorizedString {\n\tformatted := formatBroadCastMessage(text, sender)\n\tmsg := SimpleChatCommon.Create(formatted, sender.color)\n\treturn msg\n}\n\n\n\n\n\nfunc formatWhisperMessage(message string, sender *ChatClient) string {\n\tmessage = strings.Trim(message, \" \\n\")\n\tvar output string\n\tif sender.nick != \"\" {\n\t\toutput = fmt.Sprintf(\"<PRIVATE MESSSAGE> %v: %v\", sender.nick, message)\n\t} else {\n\t\toutput = fmt.Sprintf(\"<PRIVATE MESSSAGE> %v: %v\", sender.id, message)\n\t}\n\n\treturn output\n}\n\n\nfunc nickTaken(n string, holder *ClientHolder) bool {\n\tfor _, c := range clientHolder.getClients() {\n\t\tif c.nick == n {\n\t\t\treturn true\n\t\t} else if n == strconv.FormatUint(c.id, 10) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc formatBroadCastMessage(message string, sender *ChatClient) string ", "output": "{\n\tmessage = strings.Trim(message, \" \\n\")\n\tvar output string\n\tif sender.nick != \"\" {\n\t\toutput = fmt.Sprintf(\"%v: %v\", sender.nick, message)\n\t} else {\n\t\toutput = fmt.Sprintf(\"%v: %v\", sender.id, message)\n\t}\n\n\treturn output\n}"}
{"input": "package policy\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/rightscale/rsc/rsapi\"\n)\n\nconst (\n\tAPIName = \"RightScale Policy API 1.0\"\n)\n\n\nvar commandValues rsapi.ActionCommands\n\n\nfunc RegisterCommands(registrar rsapi.APICommandRegistrar) {\n\tcommandValues = rsapi.ActionCommands{}\n\tregistrar.RegisterActionCommands(APIName, GenMetadata, commandValues)\n}\n\n\nfunc (a *API) RunCommand(cmd string) (*http.Response, error) {\n\tc, err := a.ParseCommand(cmd, \"/api\", commandValues)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq, err := a.BuildHTTPRequest(c.HTTPMethod, c.URI, \"1.0\", c.QueryParams, c.PayloadParams)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn a.PerformRequest(req)\n}\n\n\n\n\n\nfunc (a *API) ShowAPIActions(cmd string) error {\n\treturn a.ShowActions(cmd, \"/api\", commandValues)\n}\n\nfunc (a *API) ShowCommandHelp(cmd string) error ", "output": "{\n\treturn a.ShowHelp(cmd, \"/api\", commandValues)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\n\n\n\n\nfunc logError(err error) {\n\tfmt.Fprintln(os.Stderr, fmt.Sprintf(\"Error: %s\\n\", err))\n}\n\n\nfunc logFatalErrorAndExit(err error, exitCode int) {\n\tcmdline := fmt.Sprintf(\"%s %s\", argparser.Command.Name, strings.Join(os.Args[1:], \" \"))\n\n\tfmt.Fprintln(os.Stderr, fmt.Sprintf(\"Error: %s\", err))\n\tfmt.Fprintln(os.Stderr, fmt.Sprintf(\"Command: %s\", cmdline))\n\n\tos.Exit(exitCode)\n}\n\nfunc logMessage(message string) ", "output": "{\n\tif opts.Verbose {\n\t\tfmt.Fprintln(os.Stderr, message)\n\t}\n}"}
{"input": "package store\n\nimport (\n\t\"github.com/allegro/bigcache\"\n)\n\ntype bigcacheStore struct {\n\tcache *bigcache.BigCache\n}\n\n\n\nfunc (b *bigcacheStore) Get(key string) ([]byte, error) {\n\tentry, err := b.cache.Get(key)\n\tif len(entry) == 7 {\n\t\tif \"DELETED\" == string(entry) {\n\t\t\treturn nil, bigcache.ErrEntryNotFound\n\t\t}\n\t}\n\treturn entry, err\n}\n\nfunc (b *bigcacheStore) Delete(key string) error {\n\treturn b.Set(key, []byte(\"DELETED\"))\n}\n\nfunc (b *bigcacheStore) Set(key string, entry []byte) error ", "output": "{\n\treturn b.cache.Set(key, entry)\n}"}
{"input": "package topoproto\n\nimport (\n\t\"testing\"\n\n\ttopodatapb \"github.com/youtube/vitess/go/vt/proto/topodata\"\n)\n\nfunc TestParseKeyspaceShard(t *testing.T) {\n\tzkPath := \"/zk/global/ks/sh\"\n\tkeyspace := \"key01\"\n\tshard := \"shard0\"\n\tkeyspaceShard := keyspace + \"/\" + shard\n\n\tif _, _, err := ParseKeyspaceShard(zkPath); err == nil {\n\t\tt.Errorf(\"zk path: %s should cause error.\", zkPath)\n\t}\n\tk, s, err := ParseKeyspaceShard(keyspaceShard)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse valid keyspace/shard pair: %s\", keyspaceShard)\n\t}\n\tif k != keyspace {\n\t\tt.Errorf(\"keyspace parsed from keyspace/shard pair %s is %s, but expect %s\", keyspaceShard, k, keyspace)\n\t}\n\tif s != shard {\n\t\tt.Errorf(\"shard parsed from keyspace/shard pair %s is %s, but expect %s\", keyspaceShard, s, shard)\n\t}\n}\n\n\n\nfunc TestSourceShardAsHTML(t *testing.T) ", "output": "{\n\ts := &topodatapb.Shard_SourceShard{\n\t\tUid:      123,\n\t\tKeyspace: \"source_keyspace\",\n\t\tShard:    \"source_shard\",\n\t\tKeyRange: &topodatapb.KeyRange{\n\t\t\tStart: []byte{0x80},\n\t\t},\n\t\tTables: []string{\"table1\", \"table2\"},\n\t}\n\tgot := string(SourceShardAsHTML(s))\n\texpected := \"<b>Uid</b>: 123</br>\\n\" +\n\t\t\"<b>Source</b>: source_keyspace/source_shard</br>\\n\" +\n\t\t\"<b>KeyRange</b>: 80-</br>\\n\" +\n\t\t\"<b>Tables</b>: table1 table2</br>\\n\"\n\tif got != expected {\n\t\tt.Errorf(\"got wrong SourceShardAsHTML output, got:\\n%vexpected:\\n%v\", got, expected)\n\t}\n}"}
{"input": "package vault\n\nimport \"github.com/fatih/structs\"\n\n\n\nfunc ConvertMapStringInterface(data interface{}) map[string]interface{} ", "output": "{\n\tf := structs.Fields(data)\n\tdatamap := make(map[string]interface{})\n\tfor _, v := range f {\n\t\tif v.Tag(\"mapstructure\") != \"\" {\n\t\t\tif !v.IsZero() {\n\t\t\t\tdatamap[v.Tag(\"mapstructure\")] = v.Value()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn datamap\n}"}
{"input": "package v1beta1\n\nimport (\n\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\twatch \"k8s.io/apimachinery/pkg/watch\"\n\trest \"k8s.io/client-go/rest\"\n\tv1beta1 \"k8s.io/metrics/pkg/apis/metrics/v1beta1\"\n\tscheme \"k8s.io/metrics/pkg/client/clientset_generated/clientset/scheme\"\n)\n\n\n\ntype NodeMetricsesGetter interface {\n\tNodeMetricses() NodeMetricsInterface\n}\n\n\ntype NodeMetricsInterface interface {\n\tGet(name string, options v1.GetOptions) (*v1beta1.NodeMetrics, error)\n\tList(opts v1.ListOptions) (*v1beta1.NodeMetricsList, error)\n\tWatch(opts v1.ListOptions) (watch.Interface, error)\n\tNodeMetricsExpansion\n}\n\n\ntype nodeMetricses struct {\n\tclient rest.Interface\n}\n\n\nfunc newNodeMetricses(c *MetricsV1beta1Client) *nodeMetricses {\n\treturn &nodeMetricses{\n\t\tclient: c.RESTClient(),\n\t}\n}\n\n\n\n\n\nfunc (c *nodeMetricses) List(opts v1.ListOptions) (result *v1beta1.NodeMetricsList, err error) {\n\tresult = &v1beta1.NodeMetricsList{}\n\terr = c.client.Get().\n\t\tResource(\"nodes\").\n\t\tVersionedParams(&opts, scheme.ParameterCodec).\n\t\tDo().\n\t\tInto(result)\n\treturn\n}\n\n\nfunc (c *nodeMetricses) Watch(opts v1.ListOptions) (watch.Interface, error) {\n\topts.Watch = true\n\treturn c.client.Get().\n\t\tResource(\"nodes\").\n\t\tVersionedParams(&opts, scheme.ParameterCodec).\n\t\tWatch()\n}\n\nfunc (c *nodeMetricses) Get(name string, options v1.GetOptions) (result *v1beta1.NodeMetrics, err error) ", "output": "{\n\tresult = &v1beta1.NodeMetrics{}\n\terr = c.client.Get().\n\t\tResource(\"nodes\").\n\t\tName(name).\n\t\tVersionedParams(&options, scheme.ParameterCodec).\n\t\tDo().\n\t\tInto(result)\n\treturn\n}"}
{"input": "package get\n\n\n\n\nimport (\n\t\"time\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/runtime\"\n\tcr \"github.com/go-openapi/runtime/client\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n)\n\n\n\n\n\n\n\nfunc NewGetPollersIdentifierDataParamsWithTimeout(timeout time.Duration) *GetPollersIdentifierDataParams {\n\tvar ()\n\treturn &GetPollersIdentifierDataParams{\n\n\t\ttimeout: timeout,\n\t}\n}\n\n\ntype GetPollersIdentifierDataParams struct {\n\n\tIdentifier string\n\n\ttimeout time.Duration\n}\n\n\nfunc (o *GetPollersIdentifierDataParams) WithIdentifier(identifier string) *GetPollersIdentifierDataParams {\n\to.Identifier = identifier\n\treturn o\n}\n\n\nfunc (o *GetPollersIdentifierDataParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {\n\n\tr.SetTimeout(o.timeout)\n\tvar res []error\n\n\tif err := r.SetPathParam(\"identifier\", o.Identifier); err != nil {\n\t\treturn err\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc NewGetPollersIdentifierDataParams() *GetPollersIdentifierDataParams ", "output": "{\n\tvar ()\n\treturn &GetPollersIdentifierDataParams{\n\n\t\ttimeout: cr.DefaultTimeout,\n\t}\n}"}
{"input": "package connect\n\nimport \"io\"\nimport \"github.com/LilyPad/GoLilyPad/packet\"\n\ntype RequestAuthenticate struct {\n\tUsername string\n\tPassword string\n}\n\nfunc NewRequestAuthenticate(username string, password string) (this *RequestAuthenticate) {\n\tthis = new(RequestAuthenticate)\n\tthis.Username = username\n\tthis.Password = password\n\treturn\n}\n\n\n\ntype requestAuthenticateCodec struct {\n\n}\n\nfunc (this *requestAuthenticateCodec) Decode(reader io.Reader) (request Request, err error) {\n\trequestAuthenticate := new(RequestAuthenticate)\n\trequestAuthenticate.Username, err = packet.ReadString(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\trequestAuthenticate.Password, err = packet.ReadString(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\trequest = requestAuthenticate\n\treturn\n}\n\nfunc (this *requestAuthenticateCodec) Encode(writer io.Writer, request Request) (err error) {\n\trequestAuthenticate := request.(*RequestAuthenticate)\n\terr = packet.WriteString(writer, requestAuthenticate.Username)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = packet.WriteString(writer, requestAuthenticate.Password)\n\treturn\n}\n\ntype ResultAuthenticate struct {\n\n}\n\nfunc NewResultAuthenticate() (this *ResultAuthenticate) {\n\tthis = new(ResultAuthenticate)\n\treturn\n}\n\nfunc (this *ResultAuthenticate) Id() int {\n\treturn REQUEST_AUTHENTICATE\n}\n\ntype resultAuthenticateCodec struct {\n\n}\n\nfunc (this *resultAuthenticateCodec) Decode(reader io.Reader) (result Result, err error) {\n\tresult = new(ResultAuthenticate)\n\treturn\n}\n\nfunc (this *resultAuthenticateCodec) Encode(writer io.Writer, result Result) (err error) {\n\treturn\n}\n\nfunc (this *RequestAuthenticate) Id() int ", "output": "{\n\treturn REQUEST_AUTHENTICATE\n}"}
{"input": "package iterbyte\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype Slice struct {\n\tSlice []byte\n\terr error\n\tindex int\n\tmutex sync.RWMutex\n\tclosed bool\n\tdatum byte\n}\n\nfunc (receiver *Slice) Close() error {\n\tif nil == receiver {\n\t\treturn errNilReceiver\n\t}\n\n\treceiver.mutex.Lock()\n\tdefer receiver.mutex.Unlock()\n\n\treceiver.closed = true\n\n\treturn nil\n}\n\n\n\n\nfunc (receiver *Slice) Decode(x interface{}) error {\n\tif nil == receiver {\n\t\treturn errNilReceiver\n\t}\n\n\treceiver.mutex.RLock()\n\tdefer receiver.mutex.RUnlock()\n\n\tswitch p := x.(type) {\n\tcase *byte:\n\t\tif nil == p {\n\t\t\treturn nil\n\t\t}\n\n\t\t*p = receiver.datum\n\tcase *interface{}:\n\t\tif nil == p {\n\t\t\treturn nil\n\t\t}\n\n\t\t*p = receiver.datum\n\tcase sql.Scanner:\n\t\treturn p.Scan( int64(receiver.datum) )\n\tdefault:\n\t\treturn &internalBadTypeComplainer{fmt.Sprintf(\"%T\", p)}\n\t}\n\n\treturn nil\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (receiver *Slice) Next() bool {\n\tif nil == receiver {\n\t\treturn false\n\t}\n\n\treceiver.mutex.Lock()\n\tdefer receiver.mutex.Unlock()\n\n\tif nil != receiver.err {\n\t\treturn false\n\t}\n\n\tif receiver.closed {\n\t\treturn false\n\t}\n\n\tslice := receiver.Slice\n\tif nil == slice  {\n\t\treturn false\n\t}\n\n\tindex := receiver.index\n\tif len(slice) <= index {\n\t\treturn false\n\t}\n\n\treceiver.datum = slice[index]\n\treceiver.index++\n\n\treturn true\n}\n\nfunc (receiver *Slice) Err() error ", "output": "{\n\tif nil == receiver {\n\t\treturn errNilReceiver\n\t}\n\n\treceiver.mutex.RLock()\n\tdefer receiver.mutex.RUnlock()\n\n\treturn receiver.err\n}"}
{"input": "package query\n\nfunc Parse(query string) (Expression, error) {\n\tscanner := NewScanner(query)\n\tparser := NewParser(scanner)\n\n\treturn parser.Parse()\n}\n\n\nfunc HasAll(tagNames []string) Expression {\n\tif len(tagNames) == 0 {\n\t\treturn EmptyExpression{}\n\t}\n\n\tvar expression Expression = TagExpression{tagNames[0]}\n\n\tfor _, tagName := range tagNames[1:] {\n\t\texpression = AndExpression{expression, TagExpression{tagName}}\n\t}\n\n\treturn expression\n}\n\n\nfunc TagNames(expression Expression) []string {\n\tnames := make([]string, 0, 10)\n\tnames = tagNames(expression, names)\n\n\treturn names\n}\n\n\nfunc ValueNames(expression Expression) []string {\n\tnames := make([]string, 0, 10)\n\tnames = valueNames(expression, names)\n\n\treturn names\n}\n\n\n\n\n\nfunc valueNames(expression Expression, names []string) []string {\n\tswitch exp := expression.(type) {\n\tcase TagExpression:\n\tcase NotExpression:\n\t\tnames = valueNames(exp.Operand, names)\n\tcase AndExpression:\n\t\tnames = valueNames(exp.LeftOperand, names)\n\t\tnames = valueNames(exp.RightOperand, names)\n\tcase OrExpression:\n\t\tnames = valueNames(exp.LeftOperand, names)\n\t\tnames = valueNames(exp.RightOperand, names)\n\tcase ComparisonExpression:\n\t\tnames = append(names, exp.Value.Name)\n\tdefault:\n\t\tpanic(\"unsupported token type\")\n\t}\n\n\treturn names\n}\n\nfunc tagNames(expression Expression, names []string) []string ", "output": "{\n\tswitch exp := expression.(type) {\n\tcase TagExpression:\n\t\tnames = append(names, exp.Name)\n\tcase NotExpression:\n\t\tnames = tagNames(exp.Operand, names)\n\tcase AndExpression:\n\t\tnames = tagNames(exp.LeftOperand, names)\n\t\tnames = tagNames(exp.RightOperand, names)\n\tcase OrExpression:\n\t\tnames = tagNames(exp.LeftOperand, names)\n\t\tnames = tagNames(exp.RightOperand, names)\n\tcase ComparisonExpression:\n\t\tnames = append(names, exp.Tag.Name)\n\tdefault:\n\t\tpanic(\"unsupported token type\")\n\t}\n\n\treturn names\n}"}
{"input": "package contentutil\n\nimport (\n\t\"context\"\n\n\t\"github.com/containerd/containerd/content\"\n\t\"github.com/containerd/containerd/errdefs\"\n\t\"github.com/containerd/containerd/remotes\"\n\t\"github.com/pkg/errors\"\n)\n\n\n\ntype pushingIngester struct {\n\tp remotes.Pusher\n}\n\n\nfunc (i *pushingIngester) Writer(ctx context.Context, opts ...content.WriterOpt) (content.Writer, error) {\n\tvar wOpts content.WriterOpts\n\tfor _, opt := range opts {\n\t\tif err := opt(&wOpts); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif wOpts.Ref == \"\" {\n\t\treturn nil, errors.Wrap(errdefs.ErrInvalidArgument, \"ref must not be empty\")\n\t}\n\tcontentWriter, err := i.p.Push(ctx, wOpts.Desc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &writer{\n\t\tWriter:           contentWriter,\n\t\tcontentWriterRef: wOpts.Ref,\n\t}, nil\n}\n\ntype writer struct {\n\tcontent.Writer          \n\tcontentWriterRef string \n}\n\nfunc (w *writer) Status() (content.Status, error) {\n\tst, err := w.Writer.Status()\n\tif err != nil {\n\t\treturn st, err\n\t}\n\tif w.contentWriterRef != \"\" {\n\t\tst.Ref = w.contentWriterRef\n\t}\n\treturn st, nil\n}\n\nfunc FromPusher(p remotes.Pusher) content.Ingester ", "output": "{\n\treturn &pushingIngester{\n\t\tp: p,\n\t}\n}"}
{"input": "package kubernetes\n\nimport (\n\t\"github.com/docker/infrakit/pkg/run/scope\"\n\t\"github.com/docker/infrakit/pkg/spi/group\"\n\t\"github.com/docker/infrakit/pkg/spi/instance\"\n\t\"github.com/docker/infrakit/pkg/types\"\n)\n\n\nfunc NewWorkerFlavor(scope scope.Scope, options Options, stop <-chan struct{}) (*WorkerFlavor, error) {\n\n\twt, err := getTemplate(options.DefaultWorkerInitScriptTemplate,\n\t\tDefaultWorkerInitScriptTemplate, DefaultTemplateOptions)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbase := &baseFlavor{initScript: wt, scope: scope, options: options}\n\treturn &WorkerFlavor{baseFlavor: base}, nil\n}\n\n\ntype WorkerFlavor struct {\n\t*baseFlavor\n}\n\n\n\n\n\nfunc (s *WorkerFlavor) Prepare(flavorProperties *types.Any,\n\tinstanceSpec instance.Spec, allocation group.AllocationMethod,\n\tindex group.Index) (instance.Spec, error) {\n\treturn s.baseFlavor.prepare(\"worker\", flavorProperties, instanceSpec, allocation, index)\n}\n\nfunc (s *WorkerFlavor) Validate(flavorProperties *types.Any, allocation group.AllocationMethod) error ", "output": "{\n\n\tif err := s.baseFlavor.Validate(flavorProperties, allocation); err != nil {\n\t\treturn err\n\t}\n\n\tspec := Spec{}\n\terr := flavorProperties.Decode(&spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package files\n\nimport (\n\t\"../../proto\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype File struct {\n\tRootdir string\n}\n\nfunc (f *File) SendFile(args *proto.FileRequest, resp *proto.File) error {\n\tfull_path := filepath.Join(f.Rootdir, args.Filename)\n\n\tdata, err := ioutil.ReadFile(full_path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfi, err := os.Stat(full_path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp.Filename = args.Filename\n\tresp.Content = data\n\tresp.Mode = fi.Mode()\n\treturn nil\n}\n\n\n\nfunc (f *File) RecvFile(args *proto.File, resp *proto.FileResponse) error ", "output": "{\n\tfull_path := filepath.Join(f.Rootdir, args.Filename)\n\tfull_dir := filepath.Dir(full_path)\n\n\tvar mode os.FileMode = os.ModeDir + 0755\n\terr := os.MkdirAll(full_dir, mode)\n\tif err != nil {\n\t\treturn errors.New(\"Creating directory: \" + err.Error())\n\t}\n\n\t_, err = os.Stat(full_path)\n\n\tresp.Overwritten = (err != nil)\n\n\terr = ioutil.WriteFile(full_path, args.Content, args.Mode)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp.Filename = args.Filename\n\tresp.Checksum = proto.GetDataChecksum(args.Content)\n\treturn nil\n}"}
{"input": "package main\n\nimport \"net/http\"\n\ntype Middleware func(http.HandlerFunc) http.HandlerFunc\n\ntype Chain struct {\n\tmiddlewares []Middleware\n}\n\n\n\n\n\n\n\nfunc (p Chain) ThenFunc(h http.HandlerFunc) http.HandlerFunc {\n\tfor i := range p.middlewares {\n\t\th = p.middlewares[len(p.middlewares)-1-i](h)\n\t}\n\treturn h\n}\n\nfunc NewChain(ms ...Middleware) Chain ", "output": "{\n\treturn Chain{ms}\n}"}
{"input": "package components\n\nimport (\n\t\"github.com/fangxm/goadmin/modules/menu\"\n\t\"github.com/fangxm/goadmin/template/types\"\n\t\"html/template\"\n)\n\ntype TreeAttribute struct {\n\tName      string\n\tTree      []menu.Item\n\tEditUrl   string\n\tDeleteUrl string\n\tUrlPrefix string\n\tOrderUrl  string\n\ttypes.Attribute\n}\n\nfunc (compo *TreeAttribute) SetTree(value []menu.Item) types.TreeAttribute {\n\tcompo.Tree = value\n\treturn compo\n}\n\n\n\nfunc (compo *TreeAttribute) SetUrlPrefix(value string) types.TreeAttribute {\n\tcompo.UrlPrefix = value\n\treturn compo\n}\n\nfunc (compo *TreeAttribute) SetDeleteUrl(value string) types.TreeAttribute {\n\tcompo.DeleteUrl = value\n\treturn compo\n}\n\nfunc (compo *TreeAttribute) SetOrderUrl(value string) types.TreeAttribute {\n\tcompo.OrderUrl = value\n\treturn compo\n}\n\nfunc (compo *TreeAttribute) GetContent() template.HTML {\n\treturn ComposeHtml(compo.TemplateList, *compo, \"tree\")\n}\n\nfunc (compo *TreeAttribute) GetTreeHeader() template.HTML {\n\treturn ComposeHtml(compo.TemplateList, *compo, \"tree-header\")\n}\n\nfunc (compo *TreeAttribute) SetEditUrl(value string) types.TreeAttribute ", "output": "{\n\tcompo.EditUrl = value\n\treturn compo\n}"}
{"input": "package configo\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc TestSome(t *testing.T) {\n\tp := make(Property, 10)\n\tp[\"hhh\"] = \"hahaha\"\n\tfmt.Println(p)\n}\n\nfunc TestConfig_Get(t *testing.T) {\n\tt.Log(Get(\"some\"))\n}\n\nfunc TestConfig_Load(t *testing.T) {\n\tif err := config.Load(); err != nil {\n\t\tt.Log(\"load error\", err)\n\t}\n}\n\nfunc TestNewConfig(t *testing.T) ", "output": "{\n\tt.Log(NewConfig(\"/\", TYPE_DEFAULT) != nil)\n\tt.Log(NewConfig(\"/\") != nil)\n}"}
{"input": "package api\n\n\ntype ProductPrivateHostAPI struct {\n\t*baseAPI\n}\n\n\n\n\nfunc NewProductPrivateHostAPI(client *Client) *ProductPrivateHostAPI ", "output": "{\n\treturn &ProductPrivateHostAPI{\n\t\t&baseAPI{\n\t\t\tclient: client,\n\t\t\tFuncGetResourceURL: func() string {\n\t\t\t\treturn \"product/privatehost\"\n\t\t\t},\n\t\t},\n\t}\n}"}
{"input": "package yaormfilter\n\n\ntype NilFilter struct {\n\tvaluefilterimpl\n}\n\n\nfunc NewNilFilter() ValueFilter {\n\treturn &NilFilter{}\n}\n\n\n\n\n\nfunc (f *NilFilter) NotEquals(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Like(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) ILike(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Nil(v bool) ValueFilter {\n\tf.nil(v)\n\treturn f\n\n}\n\n\nfunc (f *NilFilter) In(values ...interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) NotIn(values ...interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Lt(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Lte(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Gt(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Gte(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Raw(s RawFilterFunc) ValueFilter {\n\tf.raw(s)\n\treturn f\n}\n\nfunc (f *NilFilter) Equals(v interface{}) ValueFilter ", "output": "{\n\treturn f\n}"}
{"input": "package s3pp\n\nimport \"encoding/json\"\n\ntype Condition interface {\n\tName() string\n\tValue() string\n}\n\n\n\nfunc Match(field, value string) Condition {\n\treturn matchCondition{field, value}\n}\n\n\n\nfunc StartsWith(field, value string) Condition {\n\treturn startsWithCondition{field, value}\n}\n\n\n\nfunc Any(field string) Condition {\n\treturn startsWithCondition{field, \"\"}\n}\n\n\n\n\n\ntype startsWithCondition struct {\n\tname, value string\n}\n\nfunc (c startsWithCondition) Name() string {\n\treturn c.name\n}\n\nfunc (c startsWithCondition) Value() string {\n\treturn c.value\n}\n\nfunc (c startsWithCondition) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal([]string{\"starts-with\", \"$\" + c.name, c.value})\n}\n\ntype matchCondition struct {\n\tname, value string\n}\n\nfunc (c matchCondition) Name() string {\n\treturn c.name\n}\n\nfunc (c matchCondition) Value() string {\n\treturn c.value\n}\n\nfunc (c matchCondition) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(map[string]string{c.name: c.value})\n}\n\ntype contentLengthRangeCondition struct {\n\tmin int64\n\tmax int64\n}\n\nfunc (c contentLengthRangeCondition) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal([]interface{}{c.Name(), c.min, c.max})\n}\n\nfunc (c contentLengthRangeCondition) Name() string {\n\treturn \"content-length-range\"\n}\n\nfunc (c contentLengthRangeCondition) Value() string {\n\treturn \"\"\n}\n\nfunc ContentLengthRange(min, max int64) Condition ", "output": "{\n\treturn contentLengthRangeCondition{min, max}\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/swag\"\n)\n\n\n\ntype OpenpitrixRepoEvent struct {\n\n\tCreateTime strfmt.DateTime `json:\"create_time,omitempty\"`\n\n\tOwner string `json:\"owner,omitempty\"`\n\n\tOwnerPath string `json:\"owner_path,omitempty\"`\n\n\tRepoEventID string `json:\"repo_event_id,omitempty\"`\n\n\tRepoID string `json:\"repo_id,omitempty\"`\n\n\tResult string `json:\"result,omitempty\"`\n\n\tStatus string `json:\"status,omitempty\"`\n\n\tStatusTime strfmt.DateTime `json:\"status_time,omitempty\"`\n}\n\n\n\n\n\nfunc (m *OpenpitrixRepoEvent) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\nfunc (m *OpenpitrixRepoEvent) UnmarshalBinary(b []byte) error {\n\tvar res OpenpitrixRepoEvent\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *OpenpitrixRepoEvent) Validate(formats strfmt.Registry) error ", "output": "{\n\tvar res []error\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package configcore\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/snapcore/snapd/dirs\"\n\t\"github.com/snapcore/snapd/overlord/configstate/config\"\n\t\"github.com/snapcore/snapd/systemd\"\n)\n\nfunc init() {\n\tsupportedConfigurations[\"core.system.disable-backlight-service\"] = true\n}\n\nfunc validateBacklightServiceSettings(tr config.ConfGetter) error {\n\treturn validateBoolFlag(tr, \"system.disable-backlight-service\")\n}\n\ntype backlightSysdLogger struct{}\n\n\n\n\n\n\nfunc handleBacklightServiceConfiguration(tr config.ConfGetter, opts *fsOnlyContext) error {\n\tvar sysd systemd.Systemd\n\tconst serviceName = \"systemd-backlight@.service\"\n\tif opts != nil {\n\t\tsysd = systemd.NewEmulationMode(opts.RootDir)\n\t} else {\n\t\tsysd = systemd.NewUnderRoot(dirs.GlobalRootDir, systemd.SystemMode, &backlightSysdLogger{})\n\t}\n\toutput, err := coreCfg(tr, \"system.disable-backlight-service\")\n\tif err != nil {\n\t\treturn nil\n\t}\n\tif output != \"\" {\n\t\tswitch output {\n\t\tcase \"true\":\n\t\t\treturn sysd.Mask(serviceName)\n\t\tcase \"false\":\n\t\t\treturn sysd.Unmask(serviceName)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unsupported disable-backlight-service option: %q\", output)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (l *backlightSysdLogger) Notify(status string) ", "output": "{\n\tfmt.Fprintf(Stderr, \"sysd: %s\\n\", status)\n}"}
{"input": "package syscall\n\n\n\n\nfunc forkExecPipe(p []int) error ", "output": "{\n\terr := Pipe(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fcntl(p[0], F_SETFD, FD_CLOEXEC)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fcntl(p[1], F_SETFD, FD_CLOEXEC)\n\treturn err\n}"}
{"input": "package image\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n\t\"os\"\n\n\t\"github.com/coreos/rkt/store/imagestore\"\n\t\"github.com/hashicorp/errwrap\"\n)\n\n\n\ntype ascFetcher interface {\n\tGet(location string) (readSeekCloser, error)\n}\n\n\n\ntype localAscFetcher struct{}\n\nfunc (*localAscFetcher) Get(location string) (readSeekCloser, error) {\n\treturn os.Open(location)\n}\n\n\n\ntype remoteAscFetcher struct {\n\tF func(*url.URL, *os.File) error\n\tS *imagestore.Store\n}\n\nfunc (f *remoteAscFetcher) Get(location string) (readSeekCloser, error) {\n\troc, err := getTmpROC(f.S, location)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { maybeClose(roc) }()\n\n\tu, err := url.Parse(location)\n\tif err != nil {\n\t\treturn nil, errwrap.Wrap(errors.New(\"invalid signature location\"), err)\n\t}\n\tif err := f.F(u, roc.File); err != nil {\n\t\treturn nil, err\n\t}\n\tretRoc := roc\n\troc = nil\n\treturn retRoc, nil\n}\n\n\ntype asc struct {\n\tLocation string\n\tFetcher ascFetcher\n}\n\n\n\n\n\nfunc (a *asc) Get() (readSeekCloser, error) ", "output": "{\n\tif a.Fetcher != nil {\n\t\treturn a.Fetcher.Get(a.Location)\n\t}\n\treturn nil, nil\n}"}
{"input": "package storage\n\nimport (\n\t\"fmt\"\n)\n\ntype Account struct {\n\tId       string\n\tUsername string\n}\n\n\n\nfunc FindAccount(username string) *Account ", "output": "{\n\tdb := Connect()\n\tdefer db.Close()\n\n\trow := db.QueryRow(\"SELECT id, username FROM accounts WHERE username = ($1)\", username)\n\taccount := new(Account)\n\terr := row.Scan(&account.Id, &account.Username)\n\tif err != nil {\n\t\tfmt.Printf(\"Account Err: %s \\n\", err)\n\t}\n\n\treturn account\n}"}
{"input": "package p\n\nconst (\n\tzero = iota\n\tone\n\ttwo\n\tthree\n)\n\nconst iii int = 0x3\n\n\n\nconst b = \"b\"\n\nvar _ = map[string]int{\n\t\"a\": 0,\n\tb:   1,\n\t\"a\": 2, \n\t\"b\": 3, \n\t\"b\": 4, \n}\n\nfunc f(v int) ", "output": "{\n\tswitch v {\n\tcase zero, one:\n\tcase two, one: \n\n\tcase three:\n\tcase 3: \n\tcase iii: \n\t}\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype PublicIpPoolSummary struct {\n\n\tCompartmentId *string `mandatory:\"false\" json:\"compartmentId\"`\n\n\tDefinedTags map[string]map[string]interface{} `mandatory:\"false\" json:\"definedTags\"`\n\n\tDisplayName *string `mandatory:\"false\" json:\"displayName\"`\n\n\tFreeformTags map[string]string `mandatory:\"false\" json:\"freeformTags\"`\n\n\tId *string `mandatory:\"false\" json:\"id\"`\n\n\tLifecycleState PublicIpPoolLifecycleStateEnum `mandatory:\"false\" json:\"lifecycleState,omitempty\"`\n\n\tTimeCreated *common.SDKTime `mandatory:\"false\" json:\"timeCreated\"`\n}\n\n\n\nfunc (m PublicIpPoolSummary) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package iso20022\n\n\ntype ConfirmationPartyDetails4 struct {\n\n\tIdentification *PartyIdentification32Choice `xml:\"Id\"`\n\n\tSafekeepingAccount *SecuritiesAccount3 `xml:\"SfkpgAcct,omitempty\"`\n\n\tCashDetails *AccountIdentification3Choice `xml:\"CshDtls,omitempty\"`\n\n\tAlternateIdentification *AlternatePartyIdentification5 `xml:\"AltrnId,omitempty\"`\n\n\tProcessingIdentification *Max35Text `xml:\"PrcgId,omitempty\"`\n\n\tAdditionalInformation *PartyTextInformation5 `xml:\"AddtlInf,omitempty\"`\n}\n\nfunc (c *ConfirmationPartyDetails4) AddIdentification() *PartyIdentification32Choice {\n\tc.Identification = new(PartyIdentification32Choice)\n\treturn c.Identification\n}\n\nfunc (c *ConfirmationPartyDetails4) AddSafekeepingAccount() *SecuritiesAccount3 {\n\tc.SafekeepingAccount = new(SecuritiesAccount3)\n\treturn c.SafekeepingAccount\n}\n\nfunc (c *ConfirmationPartyDetails4) AddCashDetails() *AccountIdentification3Choice {\n\tc.CashDetails = new(AccountIdentification3Choice)\n\treturn c.CashDetails\n}\n\n\n\nfunc (c *ConfirmationPartyDetails4) SetProcessingIdentification(value string) {\n\tc.ProcessingIdentification = (*Max35Text)(&value)\n}\n\nfunc (c *ConfirmationPartyDetails4) AddAdditionalInformation() *PartyTextInformation5 {\n\tc.AdditionalInformation = new(PartyTextInformation5)\n\treturn c.AdditionalInformation\n}\n\nfunc (c *ConfirmationPartyDetails4) AddAlternateIdentification() *AlternatePartyIdentification5 ", "output": "{\n\tc.AlternateIdentification = new(AlternatePartyIdentification5)\n\treturn c.AlternateIdentification\n}"}
{"input": "package errors\n\nimport \"reflect\"\n\n\n\n\nfunc unwrap(err error) error {\n\tu, ok := err.(interface {\n\t\tUnwrap() error\n\t})\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn u.Unwrap()\n}\n\nfunc Is(err, target error) bool ", "output": "{\n\tif target == nil {\n\t\treturn err == target\n\t}\n\n\tisComparable := reflect.TypeOf(target).Comparable()\n\tfor {\n\t\tif isComparable && err == target {\n\t\t\treturn true\n\t\t}\n\t\tif x, ok := err.(interface{ Is(error) bool }); ok && x.Is(target) {\n\t\t\treturn true\n\t\t}\n\t\tif err = unwrap(err); err == nil {\n\t\t\treturn false\n\t\t}\n\t}\n}"}
{"input": "package sync\n\nimport (\n\t\"context\"\n\t\"strings\"\n\n\t\"github.com/fluxcd/flux/pkg/git\"\n)\n\n\ntype GitTagSyncProvider struct {\n\trepo       *git.Repo\n\tsyncTag    string\n\tsigningKey string\n\tverifyTag  bool\n\tconfig     git.Config\n}\n\n\nfunc NewGitTagSyncProvider(\n\trepo *git.Repo,\n\tsyncTag string,\n\tsigningKey string,\n\tverifyTag bool,\n\tconfig git.Config,\n) (GitTagSyncProvider, error) {\n\treturn GitTagSyncProvider{\n\t\trepo:       repo,\n\t\tsyncTag:    syncTag,\n\t\tsigningKey: signingKey,\n\t\tverifyTag:  verifyTag,\n\t\tconfig:     config,\n\t}, nil\n}\n\nfunc (p GitTagSyncProvider) String() string {\n\treturn \"tag \" + p.syncTag\n}\n\n\nfunc (p GitTagSyncProvider) GetRevision(ctx context.Context) (string, error) {\n\trev, err := p.repo.Revision(ctx, p.syncTag)\n\tif isUnknownRevision(err) {\n\t\treturn \"\", nil\n\t}\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif p.verifyTag {\n\t\tif _, err := p.repo.VerifyTag(ctx, p.syncTag); err != nil {\n\t\t\tif strings.Contains(err.Error(), \"not found.\") {\n\t\t\t\treturn \"\", nil\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn rev, nil\n}\n\n\n\n\n\nfunc (p GitTagSyncProvider) DeleteMarker(ctx context.Context) error {\n\treturn p.repo.DeleteTag(ctx, p.syncTag)\n}\n\nfunc isUnknownRevision(err error) bool {\n\treturn err != nil &&\n\t\t(strings.Contains(err.Error(), \"unknown revision or path not in the working tree.\") ||\n\t\t\tstrings.Contains(err.Error(), \"bad revision\"))\n}\n\nfunc (p GitTagSyncProvider) UpdateMarker(ctx context.Context, revision string) error ", "output": "{\n\tcheckout, err := p.repo.Clone(ctx, p.config)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn checkout.MoveTagAndPush(ctx, git.TagAction{\n\t\tTag:        p.syncTag,\n\t\tRevision:   revision,\n\t\tMessage:    \"Sync pointer\",\n\t\tSigningKey: p.signingKey,\n\t})\n}"}
{"input": "package v2alpha1\n\nimport (\n\tv2alpha1 \"k8s.io/api/batch/v2alpha1\"\n\tserializer \"k8s.io/apimachinery/pkg/runtime/serializer\"\n\t\"github.com/hyperhq/client-go/kubernetes/scheme\"\n\trest \"github.com/hyperhq/client-go/rest\"\n)\n\ntype BatchV2alpha1Interface interface {\n\tRESTClient() rest.Interface\n\tCronJobsGetter\n}\n\n\ntype BatchV2alpha1Client struct {\n\trestClient rest.Interface\n}\n\nfunc (c *BatchV2alpha1Client) CronJobs(namespace string) CronJobInterface {\n\treturn newCronJobs(c, namespace)\n}\n\n\nfunc NewForConfig(c *rest.Config) (*BatchV2alpha1Client, error) {\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := rest.RESTClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &BatchV2alpha1Client{client}, nil\n}\n\n\n\n\n\n\nfunc New(c rest.Interface) *BatchV2alpha1Client {\n\treturn &BatchV2alpha1Client{c}\n}\n\nfunc setConfigDefaults(config *rest.Config) error {\n\tgv := v2alpha1.SchemeGroupVersion\n\tconfig.GroupVersion = &gv\n\tconfig.APIPath = \"/apis\"\n\tconfig.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: scheme.Codecs}\n\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = rest.DefaultKubernetesUserAgent()\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (c *BatchV2alpha1Client) RESTClient() rest.Interface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.restClient\n}\n\nfunc NewForConfigOrDie(c *rest.Config) *BatchV2alpha1Client ", "output": "{\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}"}
{"input": "package error\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\nvar errors map[int]string\n\nconst ()\n\nfunc init() {\n\terrors = make(map[int]string)\n\n\terrors[100] = \"Key Not Found\"\n\terrors[101] = \"The given PrevValue is not equal to the value of the key\"\n\terrors[102] = \"Not A File\"\n\terrors[103] = \"Reached the max number of machines in the cluster\"\n\n\terrors[200] = \"Value is Required in POST form\"\n\terrors[201] = \"PrevValue is Required in POST form\"\n\terrors[202] = \"The given TTL in POST form is not a number\"\n\terrors[203] = \"The given index in POST form is not a number\"\n\n\terrors[300] = \"Raft Internal Error\"\n\terrors[301] = \"During Leader Election\"\n\n\terrors[400] = \"The prefix of the given key is a keyword in etcd\"\n\n\terrors[500] = \"watcher is cleared due to etcd recovery\"\n\n}\n\ntype Error struct {\n\tErrorCode int    `json:\"errorCode\"`\n\tMessage   string `json:\"message\"`\n\tCause     string `json:\"cause,omitempty\"`\n}\n\nfunc NewError(errorCode int, cause string) Error {\n\treturn Error{\n\t\tErrorCode: errorCode,\n\t\tMessage:   errors[errorCode],\n\t\tCause:     cause,\n\t}\n}\n\n\n\n\nfunc (e Error) Error() string {\n\treturn e.Message\n}\n\nfunc (e Error) toJsonString() string {\n\tb, _ := json.Marshal(e)\n\treturn string(b)\n}\n\nfunc (e Error) Write(w http.ResponseWriter) {\n\tif e.ErrorCode/100 == 3 {\n\t\thttp.Error(w, e.toJsonString(), http.StatusInternalServerError)\n\t} else {\n\t\thttp.Error(w, e.toJsonString(), http.StatusBadRequest)\n\t}\n}\n\nfunc Message(code int) string ", "output": "{\n\treturn errors[code]\n}"}
{"input": "package graph\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/gonum/graph\"\n\t\"github.com/gonum/graph/concrete\"\n\t\"github.com/gonum/graph/encoding/dot\"\n)\n\ntype Node struct {\n\tId         int\n\tUniqueName string\n\tLabelName  string\n\tColor      string\n}\n\nfunc (n Node) ID() int {\n\treturn n.Id\n}\n\n\nfunc (n Node) DOTAttributes() []dot.Attribute {\n\tcolor := n.Color\n\tif len(color) == 0 {\n\t\tcolor = \"black\"\n\t}\n\n\treturn []dot.Attribute{\n\t\t{Key: \"label\", Value: fmt.Sprintf(\"%q\", n.LabelName)},\n\t\t{Key: \"color\", Value: color},\n\t}\n}\n\n\n\ntype MutableDirectedGraph struct {\n\t*concrete.DirectedGraph\n\n\tnodesByName map[string]graph.Node\n}\n\nfunc (g *MutableDirectedGraph) AddNode(n *Node) error {\n\tif _, exists := g.nodesByName[n.UniqueName]; exists {\n\t\treturn fmt.Errorf(\"node .UniqueName collision: %s\", n.UniqueName)\n\t}\n\n\tg.nodesByName[n.UniqueName] = n\n\tg.DirectedGraph.AddNode(n)\n\treturn nil\n}\n\nfunc (g *MutableDirectedGraph) NodeByName(name string) (graph.Node, bool) {\n\tn, exists := g.nodesByName[name]\n\treturn n, exists && g.DirectedGraph.Has(n)\n}\n\nfunc NewMutableDirectedGraph(g *concrete.DirectedGraph) *MutableDirectedGraph ", "output": "{\n\treturn &MutableDirectedGraph{\n\t\tDirectedGraph: concrete.NewDirectedGraph(),\n\t\tnodesByName:   make(map[string]graph.Node),\n\t}\n}"}
{"input": "package luddite\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"sync\"\n\t\"syscall\"\n)\n\nvar dumpOnce sync.Once\n\n\n\nfunc dumpGoroutineStacks() ", "output": "{\n\tdumpOnce.Do(func() {\n\t\tsigs := make(chan os.Signal, 1)\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t<-sigs\n\t\t\t\tos.Stderr.Write(goroutineStack(true))\n\t\t\t\tos.Stderr.Write([]byte(\"\\n\"))\n\t\t\t}\n\t\t}()\n\t\tsignal.Notify(sigs, syscall.SIGUSR1)\n\t})\n}"}
{"input": "package actor\n\nimport (\n\t\"time\"\n)\n\n\ntype RestartStatistics struct {\n\tfailureTimes []time.Time\n}\n\n\nfunc NewRestartStatistics() *RestartStatistics {\n\treturn &RestartStatistics{[]time.Time{}}\n}\n\n\nfunc (rs *RestartStatistics) FailureCount() int {\n\treturn len(rs.failureTimes)\n}\n\n\n\n\n\nfunc (rs *RestartStatistics) Reset() {\n\trs.failureTimes = []time.Time{}\n}\n\n\nfunc (rs *RestartStatistics) NumberOfFailures(withinDuration time.Duration) int {\n\tif withinDuration == 0 {\n\t\treturn len(rs.failureTimes)\n\t}\n\n\tnum := 0\n\tcurrTime := time.Now()\n\tfor _, t := range rs.failureTimes {\n\t\tif currTime.Sub(t) < withinDuration {\n\t\t\tnum++\n\t\t}\n\t}\n\treturn num\n}\n\nfunc (rs *RestartStatistics) Fail() ", "output": "{\n\trs.failureTimes = append(rs.failureTimes, time.Now())\n}"}
{"input": "package darwin\n\nimport (\n\t\"github.com/elliotchance/c2go/noarch\"\n\t\"unsafe\"\n)\n\n\n\nfunc BuiltinStrcpy(dest, src *byte, size int32) *byte {\n\treturn noarch.Strcpy(dest, src)\n}\n\n\n\n\n\n\n\nfunc BuiltinStrncpy(dest, src *byte, len, size int32) *byte {\n\treturn noarch.Strncpy(dest, src, len)\n}\n\n\n\nfunc BuiltinStrcat(dest, src *byte, _ int32) *byte {\n\treturn noarch.Strcat(dest, src)\n}\n\n\n\nfunc Memset(dst unsafe.Pointer, val int32, size int32, _ int32) unsafe.Pointer {\n\treturn noarch.Memset(dst, val, size)\n}\n\n\n\nfunc Memcpy(dst, src unsafe.Pointer, size int32, _ int32) unsafe.Pointer {\n\treturn noarch.Memcpy(dst, src, size)\n}\n\nfunc BuiltinObjectSize(ptr *byte, theType int32) int32 ", "output": "{\n\treturn 5\n}"}
{"input": "package git\n\nimport \"strings\"\n\n\ntype Reference struct {\n\tName   string\n\trepo   *Repository\n\tObject SHA1 \n\tType   string\n}\n\n\n\n\n\nfunc (ref *Reference) ShortName() string {\n\tif ref == nil {\n\t\treturn \"\"\n\t}\n\tif strings.HasPrefix(ref.Name, \"refs/heads/\") {\n\t\treturn ref.Name[11:]\n\t}\n\tif strings.HasPrefix(ref.Name, \"refs/tags/\") {\n\t\treturn ref.Name[10:]\n\t}\n\tif strings.HasPrefix(ref.Name, \"refs/remotes/\") {\n\t\treturn ref.Name[13:]\n\t}\n\tif strings.HasPrefix(ref.Name, \"refs/pull/\") && strings.IndexByte(ref.Name[10:], '/') > -1 {\n\t\treturn ref.Name[10 : strings.IndexByte(ref.Name[10:], '/')+10]\n\t}\n\n\treturn ref.Name\n}\n\n\nfunc (ref *Reference) RefGroup() string {\n\tif ref == nil {\n\t\treturn \"\"\n\t}\n\tif strings.HasPrefix(ref.Name, \"refs/heads/\") {\n\t\treturn \"heads\"\n\t}\n\tif strings.HasPrefix(ref.Name, \"refs/tags/\") {\n\t\treturn \"tags\"\n\t}\n\tif strings.HasPrefix(ref.Name, \"refs/remotes/\") {\n\t\treturn \"remotes\"\n\t}\n\tif strings.HasPrefix(ref.Name, \"refs/pull/\") && strings.IndexByte(ref.Name[10:], '/') > -1 {\n\t\treturn \"pull\"\n\t}\n\treturn \"\"\n}\n\nfunc (ref *Reference) Commit() (*Commit, error) ", "output": "{\n\treturn ref.repo.getCommit(ref.Object)\n}"}
{"input": "package resttk\n\ntype ResourceInterface interface {\n\tFindAllResources(v interface{}) interface{}\n\tFindResource(key string, value string, v interface{}) interface{}\n\tSaveResource(key string, value string, v interface{}) interface{}\n\tUpdateResource(key string, value string, v interface{}) interface{}\n\tDeleteResource(key string, value string) bool\n}\n\ntype BaseResource struct {\n\tparent ResourceInterface\n}\n\n\n\nfunc (r *BaseResource) FindAllResources(v interface{}) interface{} {\n\tresources := r.parent.FindAllResources(v)\n\tif resources != nil {\n\t\treturn resources\n\t}\n\n\treturn nil\n}\n\nfunc (r *BaseResource) FindResource(key string, value string, v interface{}) interface{} {\n\tresource := r.parent.FindResource(key, value, v)\n\tif resource != nil {\n\t\treturn resource\n\t}\n\n\treturn nil\n}\n\nfunc (r *BaseResource) SaveResource(key string, value string, v interface{}) interface{} {\n\tresource := r.parent.FindResource(key, value, v)\n\tif resource != nil {\n\t\treturn resource\n\t}\n\n\treturn nil\n}\n\nfunc (r *BaseResource) UpdateResource(key string, value string, v interface{}) interface{} {\n\tresource := r.parent.UpdateResource(key, value, v)\n\tif resource != nil {\n\t\treturn resource\n\t}\n\n\treturn nil\n}\n\nfunc (r *BaseResource) DeleteResource(key string, value string) bool {\n\treturn r.parent.DeleteResource(key, value)\n}\n\nfunc (r *BaseResource) Init(p ResourceInterface) ", "output": "{\n\tr.parent = p\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/veandco/go-sdl2/sdl\"\n\t\"lsystem/turt\"\n)\n\ntype SiriTriangle struct {\n\tcur []Symbol\n\tpen *turt.Turtle\n}\n\nfunc NewSiriTriangle() *SiriTriangle {\n\treturn &SiriTriangle{\n\t\tcur: []Symbol{F, Minus, G, Minus, G},\n\t\tpen: turt.NewTurtle(300, 200, 10),\n\t}\n}\n\nfunc (s *SiriTriangle) currentSymbolSet() []Symbol {\n\treturn s.cur\n}\n\nfunc (st *SiriTriangle) setCurrentSymbolSet(s []Symbol) {\n\tst.cur = s\n}\n\n\n\n\n\nfunc (st *SiriTriangle) applyRule(s Symbol) []Symbol {\n\tswitch s {\n\tcase F:\n\t\treturn []Symbol{F, Minus, G, Plus, F, Plus, G, Minus, F}\n\tcase G:\n\t\treturn []Symbol{G, G}\n\tcase Minus:\n\t\treturn []Symbol{Minus}\n\tcase Plus:\n\t\treturn []Symbol{Plus}\n\tdefault:\n\t\treturn []Symbol{s}\n\t}\n}\n\n\n\n\n\nfunc (st *SiriTriangle) String() string {\n\tvar s string\n\tbod := st.currentSymbolSet()\n\tlbod := len(bod)\n\tfor i := 0; i < lbod; i++ {\n\t\tsym := bod[i]\n\t\tswitch sym {\n\t\tcase F:\n\t\t\ts += \"F \"\n\t\tcase G:\n\t\t\ts += \"G \"\n\t\tcase Minus:\n\t\t\ts += \"Minus \"\n\t\tcase Plus:\n\t\t\ts += \"Plus \"\n\t\t}\n\t}\n\treturn s\n}\n\nfunc (st *SiriTriangle) applyDrawRule(s Symbol, surf *sdl.Surface) ", "output": "{\n\tswitch s {\n\tcase F, G:\n\t\tst.pen.Forward()\n\t\trect := sdl.Rect{int32(st.pen.Location.X), int32(st.pen.Location.Y), 1, 1}\n\t\tsurf.FillRect(&rect, 0xffff0000)\n\tcase Minus:\n\t\tst.pen.Turn(turt.RIGHT, 120)\n\tcase Plus:\n\t\tst.pen.Turn(turt.LEFT, 120)\n\tdefault:\n\t\treturn\n\t}\n}"}
{"input": "package web\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n)\n\n\n\ntype ResponseWriter struct {\n\tafterHeaders []func(*ResponseWriter)\n\tclosers []io.Closer\n\tonce sync.Once\n\thttp.ResponseWriter\n\tstatus int\n\tBodyWriter io.Writer\n}\n\nfunc (w *ResponseWriter) triggerAfterHeaders() {\n\tw.once.Do(func() {\n\t\tfor _, f := range w.afterHeaders {\n\t\t\tf(w)\n\t\t}\n\t})\n}\n\nfunc (w *ResponseWriter) Write(data []byte) (int, error) {\n\tw.triggerAfterHeaders()\n\treturn w.BodyWriter.Write(data)\n}\n\nfunc (w *ResponseWriter) WriteHeader(status int) {\n\tw.status = status\n\tw.triggerAfterHeaders()\n\tw.ResponseWriter.WriteHeader(status)\n}\n\n\n\nfunc (w *ResponseWriter) WrapBodyWriter(f func(w io.Writer) io.Writer) {\n\tw.BodyWriter = f(w.BodyWriter)\n\tif c, ok := w.BodyWriter.(io.Closer); ok {\n\t\tw.closers = append(w.closers, c)\n\t}\n}\n\nfunc (w *ResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\treturn w.ResponseWriter.(http.Hijacker).Hijack()\n}\n\n\n\nfunc (w *ResponseWriter) AddAfterHeaderFunc(f func(*ResponseWriter)) {\n\tw.afterHeaders = append(w.afterHeaders, f)\n}\n\n\n\nfunc httpSuccess(status int) bool {\n\treturn status >= 100 && status <= 399\n}\n\n\nfunc (w *ResponseWriter) Success() bool {\n\treturn httpSuccess(w.status)\n}\n\nfunc (w *ResponseWriter) Close() error ", "output": "{\n\tvar err error\n\tfor i := range w.closers {\n\t\tc := w.closers[len(w.closers)-i-1]\n\t\terr2 := c.Close()\n\t\tif err == nil && err2 != nil {\n\t\t\terr = err2\n\t\t}\n\t}\n\treturn err\n}"}
{"input": "package iso20022\n\n\ntype IndividualPerson8 struct {\n\n\tName *Max35Text `xml:\"Nm\"`\n\n\tGivenName *Max35Text `xml:\"GvnNm\"`\n\n\tNamePrefix *NamePrefix1Code `xml:\"NmPrfx,omitempty\"`\n\n\tNameSuffix *Max35Text `xml:\"NmSfx,omitempty\"`\n\n\tGender *GenderCode `xml:\"Gndr,omitempty\"`\n\n\tBirthDate *ISODate `xml:\"BirthDt,omitempty\"`\n\n\tSocialSecurityNumber *Max35Text `xml:\"SclSctyNb,omitempty\"`\n\n\tIndividualInvestorAddress *PostalAddress1 `xml:\"IndvInvstrAdr\"`\n}\n\nfunc (i *IndividualPerson8) SetName(value string) {\n\ti.Name = (*Max35Text)(&value)\n}\n\nfunc (i *IndividualPerson8) SetGivenName(value string) {\n\ti.GivenName = (*Max35Text)(&value)\n}\n\nfunc (i *IndividualPerson8) SetNamePrefix(value string) {\n\ti.NamePrefix = (*NamePrefix1Code)(&value)\n}\n\nfunc (i *IndividualPerson8) SetNameSuffix(value string) {\n\ti.NameSuffix = (*Max35Text)(&value)\n}\n\n\n\nfunc (i *IndividualPerson8) SetBirthDate(value string) {\n\ti.BirthDate = (*ISODate)(&value)\n}\n\nfunc (i *IndividualPerson8) SetSocialSecurityNumber(value string) {\n\ti.SocialSecurityNumber = (*Max35Text)(&value)\n}\n\nfunc (i *IndividualPerson8) AddIndividualInvestorAddress() *PostalAddress1 {\n\ti.IndividualInvestorAddress = new(PostalAddress1)\n\treturn i.IndividualInvestorAddress\n}\n\nfunc (i *IndividualPerson8) SetGender(value string) ", "output": "{\n\ti.Gender = (*GenderCode)(&value)\n}"}
{"input": "package unit\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"encoding/json\"\n\t\"github.com/quickscript/unit/exstring\"\n)\n\nfunc PathExists(path string) (bool, error) {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n\nfunc IsDir(path string) (bool, error) {\n\tfile, err := os.Stat(path)\n\tif err == nil {\n\t\treturn file.IsDir(), nil\n\t}\n\treturn false, err\n}\n\nfunc ReadTextLine(path string, handler func(string)) error {\n\texist, _ := PathExists(path)\n\tif !exist {\n\t\treturn nil\n\t}\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf := bufio.NewReader(file)\n\tfor {\n\t\tline, err := buf.ReadString('\\n')\n\t\tline = strings.TrimSpace(line)\n\t\thandler(line)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc GetParentDirectory(directory string) string {\n\treturn exstring.Substr(directory, 0, strings.LastIndex(directory, \"/\"))\n}\n\n\n\nfunc Json2map(jsonStr string) (s map[string]interface{}, err error) {\n\tvar result map[string]interface{}\n\tif err := json.Unmarshal([]byte(jsonStr), &result); err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\nfunc GetCurrentDirectory() string ", "output": "{\n\tdir, err := filepath.Abs(filepath.Dir(os.Args[0]))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn strings.Replace(dir, \"\\\\\", \"/\", -1)\n}"}
{"input": "package logger\n\n\n\n\n\nimport (\n\t\"log\"\n\t\"log/syslog\"\n)\n\n\n\n\n\n\n\ntype SysLogger struct {\n\twriter *syslog.Writer\n}\n\n\n\n\n\n\nfunc (sl *SysLogger) Debug(info, msg string) {\n\tsl.writer.Debug(info + \" \" + msg)\n}\n\n\nfunc (sl *SysLogger) Info(info, msg string) {\n\tsl.writer.Info(info + \" \" + msg)\n}\n\n\nfunc (sl *SysLogger) Warning(info, msg string) {\n\tsl.writer.Warning(info + \" \" + msg)\n}\n\n\nfunc (sl *SysLogger) Error(info, msg string) {\n\tsl.writer.Err(info + \" \" + msg)\n}\n\n\nfunc (sl *SysLogger) Critical(info, msg string) {\n\tsl.writer.Crit(info + \" \" + msg)\n}\n\n\nfunc (sl *SysLogger) Fatal(info, msg string) {\n\tsl.writer.Emerg(info + \" \" + msg)\n}\n\nfunc NewSysLogger(tag string) (Logger, error) ", "output": "{\n\twriter, err := syslog.New(syslog.LOG_DEBUG|syslog.LOG_LOCAL0, tag)\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot init syslog: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn &SysLogger{writer}, nil\n}"}
{"input": "package check\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestCheckErrorForExit(t *testing.T) ", "output": "{\n\tErrorForExit(\"name\", nil)\n\tassert.True(t, true)\n}"}
{"input": "package diffsquares\n\n\n\n\n\nfunc SumOfSquares(n int) int {\n\treturn n * (n + 1) * (2*n + 1) / 6\n}\n\n\nfunc Difference(n int) int {\n\treturn SquareOfSums(n) - SumOfSquares(n)\n}\n\nfunc SquareOfSums(n int) int ", "output": "{\n\treturn n * (n + 1) * n * (n + 1) / 4\n}"}
{"input": "package iso20022\n\n\ntype PlainCardData4 struct {\n\n\tPAN *Min8Max28NumericText `xml:\"PAN\"`\n\n\tCardSequenceNumber *Min2Max3NumericText `xml:\"CardSeqNb,omitempty\"`\n\n\tEffectiveDate *Max10Text `xml:\"FctvDt,omitempty\"`\n\n\tExpiryDate *Max10Text `xml:\"XpryDt\"`\n\n\tServiceCode *Exact3NumericText `xml:\"SvcCd,omitempty\"`\n\n\tTrackData []*TrackData1 `xml:\"TrckData,omitempty\"`\n\n\tCardSecurityCode *CardSecurityInformation1 `xml:\"CardSctyCd,omitempty\"`\n}\n\nfunc (p *PlainCardData4) SetPAN(value string) {\n\tp.PAN = (*Min8Max28NumericText)(&value)\n}\n\nfunc (p *PlainCardData4) SetCardSequenceNumber(value string) {\n\tp.CardSequenceNumber = (*Min2Max3NumericText)(&value)\n}\n\n\n\nfunc (p *PlainCardData4) SetExpiryDate(value string) {\n\tp.ExpiryDate = (*Max10Text)(&value)\n}\n\nfunc (p *PlainCardData4) SetServiceCode(value string) {\n\tp.ServiceCode = (*Exact3NumericText)(&value)\n}\n\nfunc (p *PlainCardData4) AddTrackData() *TrackData1 {\n\tnewValue := new(TrackData1)\n\tp.TrackData = append(p.TrackData, newValue)\n\treturn newValue\n}\n\nfunc (p *PlainCardData4) AddCardSecurityCode() *CardSecurityInformation1 {\n\tp.CardSecurityCode = new(CardSecurityInformation1)\n\treturn p.CardSecurityCode\n}\n\nfunc (p *PlainCardData4) SetEffectiveDate(value string) ", "output": "{\n\tp.EffectiveDate = (*Max10Text)(&value)\n}"}
{"input": "package classfile\n\nimport \"encoding/binary\"\n\ntype ClassReader struct {\n\tdata []byte \n}\n\nfunc (self *ClassReader) readUint8() uint8 {\n\tval := self.data[0]\n\tself.data = self.data[1:]\n\treturn val\n}\n\nfunc (self *ClassReader) readUint16() uint16 {\n\tval := binary.BigEndian.Uint16(self.data)\n\tself.data = self.data[2:]\n\treturn val\n}\n\nfunc (self *ClassReader) readUint32() uint32 {\n\tval := binary.BigEndian.Uint32(self.data)\n\tself.data = self.data[4:]\n\treturn val\n}\n\nfunc (self *ClassReader) readUint64() uint64 {\n\tval := binary.BigEndian.Uint64(self.data)\n\tself.data = self.data[8:]\n\treturn val\n}\n\n\n\nfunc (self *ClassReader) readBytes(n uint32) []byte {\n\tbytes := self.data[:n]\n\tself.data = self.data[n:]\n\treturn bytes\n}\n\nfunc (self *ClassReader) readUint16s() []uint16 ", "output": "{\n\tn := self.readUint16()\n\ts := make([]uint16, n)\n\tfor i := range s {\n\t\ts[i] = self.readUint16()\n\t}\n\treturn s\n}"}
{"input": "package test_helpers\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\tdatatypes \"github.com/maximilien/softlayer-go/data_types\"\n)\n\ntype MockProductPackageService struct{}\n\nfunc (mock *MockProductPackageService) GetName() string {\n\treturn \"Mock_Product_Package_Service\"\n}\n\n\n\nfunc (mock *MockProductPackageService) GetItemPrices(packageId int) ([]datatypes.SoftLayer_Product_Item_Price, error) {\n\treturn []datatypes.SoftLayer_Product_Item_Price{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetItemPricesBySize(packageId int, size int) ([]datatypes.SoftLayer_Product_Item_Price, error) {\n\treturn []datatypes.SoftLayer_Product_Item_Price{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetItems(packageId int) ([]datatypes.SoftLayer_Product_Item, error) {\n\treturn []datatypes.SoftLayer_Product_Item{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetPackagesByType(packageType string) ([]datatypes.Softlayer_Product_Package, error) {\n\treturn []datatypes.Softlayer_Product_Package{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetOnePackageByType(packageType string) (datatypes.Softlayer_Product_Package, error) {\n\treturn datatypes.Softlayer_Product_Package{}, errors.New(\"Not supported\")\n}\n\nfunc (mock *MockProductPackageService) GetItemsByType(packageType string) ([]datatypes.SoftLayer_Product_Item, error) ", "output": "{\n\tresponse, _ := ReadJsonTestFixtures(\"services\", \"SoftLayer_Product_Package_getItemsByType_virtual_server.json\")\n\n\tproductItems := []datatypes.SoftLayer_Product_Item{}\n\tjson.Unmarshal(response, &productItems)\n\n\treturn productItems, nil\n}"}
{"input": "package ordering\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/coreos/etcd/clientv3\"\n\n\t\"github.com/coreos/pkg/capnslog\"\n\t\"google.golang.org/grpc/grpclog\"\n)\n\n\n\nfunc init() ", "output": "{\n\tcapnslog.SetGlobalLogLevel(capnslog.CRITICAL)\n\tclientv3.SetLogger(grpclog.NewLoggerV2(ioutil.Discard, ioutil.Discard, ioutil.Discard))\n}"}
{"input": "package sse\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype Broker struct {\n\tNotifier       chan []byte\n\tclients        map[chan []byte]bool\n\tclosingClients chan chan []byte\n\tnewClients     chan chan []byte\n}\n\nfunc NewBrokerServer() (broker *Broker) {\n\tbroker = &Broker{\n\t\tNotifier:       make(chan []byte, 1),\n\t\tclients:        make(map[chan []byte]bool),\n\t\tclosingClients: make(chan chan []byte),\n\t\tnewClients:     make(chan chan []byte),\n\t}\n\n\tgo broker.Listen()\n\n\treturn\n}\n\n\n\nfunc (b *Broker) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tflusher, ok := w.(http.Flusher)\n\n\tif !ok {\n\t\thttp.Error(w, \"Streaming unsupported\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n\tw.Header().Set(\"Cache-Control\", \"no-cache\")\n\tw.Header().Set(\"Connection\", \"keep-alive\")\n\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\n\tmessageChannel := make(chan []byte)\n\tb.newClients <- messageChannel\n\n\tdefer func() {\n\t\tb.closingClients <- messageChannel\n\t}()\n\n\tnotify := w.(http.CloseNotifier).CloseNotify()\n\n\tfor {\n\t\tselect {\n\t\tcase <-notify:\n\t\t\treturn\n\t\tdefault:\n\t\t\tdata := <-messageChannel\n\t\t\tfmt.Fprintf(w, \"data: %s\\n\\n\", data)\n\t\t\tflusher.Flush()\n\t\t}\n\t}\n\n}\n\nfunc (b *Broker) Listen() ", "output": "{\n\tfor {\n\t\tselect {\n\n\t\tcase newClient := <-b.newClients:\n\t\t\tb.clients[newClient] = true\n\n\t\tcase closedClient := <-b.closingClients:\n\t\t\tdelete(b.clients, closedClient)\n\n\t\tcase event := <-b.Notifier:\n\t\t\tfor client, _ := range b.clients {\n\t\t\t\tclient <- event\n\t\t\t}\n\n\t\t}\n\t}\n}"}
{"input": "package reeky\n\nimport (\n\t\"fmt\"\n\n\t. \"github.com/konjoot/reeky/interfaces\"\n)\n\ntype App struct {\n\troutes  bool\n\tmidware bool\n\tEngine  EngineIface\n}\n\nfunc (app *App) RunOn(port string) {\n\tapp.Setup()\n\tapp.Engine.Run(\":\" + port)\n}\n\nfunc (app *App) Setup() {\n\tapp.midware = app.SetMiddleWare()\n\tapp.routes = app.SetRoutes()\n}\n\nfunc (app *App) Ok() bool {\n\treturn app.midware && app.routes\n}\n\n\n\nfunc (app *App) String() string ", "output": "{\n\treturn fmt.Sprintf(\"App{Ok: \\\"%t\\\"}\", app.Ok())\n}"}
{"input": "package sealmigration\n\nimport (\n\t\"testing\"\n)\n\n\n\n\n\n\n\n\n\nfunc TestSealMigration_ShamirToTransit_Pre14(t *testing.T) {\n\tt.Parallel()\n\ttestVariousBackends(t, ParamTestSealMigrationShamirToTransit_Pre14, BasePort_ShamirToTransit_Pre14, false)\n}\n\nfunc TestSealMigration_TransitToShamir_Pre14(t *testing.T) ", "output": "{\n\tt.Parallel()\n\ttestVariousBackends(t, ParamTestSealMigrationTransitToShamir_Pre14, BasePort_TransitToShamir_Pre14, false)\n}"}
{"input": "package popcount\n\n\nvar pc [256]byte\n\nfunc init() {\n\tfor i := range pc {\n\t\tpc[i] = pc[i/2] + byte(i&1)\n\t}\n}\n\n\nfunc PopCount(x uint64) int {\n\treturn int(pc[byte(x>>(0*8))] +\n\t\tpc[byte(x>>(1*8))] +\n\t\tpc[byte(x>>(2*8))] +\n\t\tpc[byte(x>>(3*8))] +\n\t\tpc[byte(x>>(4*8))] +\n\t\tpc[byte(x>>(5*8))] +\n\t\tpc[byte(x>>(6*8))] +\n\t\tpc[byte(x>>(7*8))])\n}\n\n\n\nfunc PopCount2(x uint64) int ", "output": "{\n\tvar sum byte\n\tfor i := uint(0); i < 8; i++ {\n\t\tsum += pc[byte(x>>(i*8))]\n\t}\n\treturn int(sum)\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\n\t\"camlistore.org/pkg/blobref\"\n\t\"camlistore.org/pkg/cmdmain\"\n)\n\ntype removeCmd struct{}\n\nfunc init() {\n\tcmdmain.RegisterCommand(\"remove\", func(flags *flag.FlagSet) cmdmain.CommandRunner {\n\t\tcmd := new(removeCmd)\n\t\treturn cmd\n\t})\n}\n\nfunc (c *removeCmd) Usage() {\n\tfmt.Fprintf(cmdmain.Stderr, `Usage: camput remove <blobref(s)>\n\nThis command is for debugging only.  You're not expected to use it in practice.\n`)\n}\n\n\n\nfunc (c *removeCmd) RunCommand(args []string) error ", "output": "{\n\tif len(args) == 0 {\n\t\treturn cmdmain.ErrUsage\n\t}\n\treturn getUploader().RemoveBlobs(blobref.ParseMulti(args))\n}"}
{"input": "package kafka\n\nimport (\n\t\"github.com/hyperledger/fabric/orderer/localconfig\"\n\tab \"github.com/hyperledger/fabric/protos/orderer\"\n)\n\n\ntype Orderer interface {\n\tBroadcast(stream ab.AtomicBroadcast_BroadcastServer) error\n\tDeliver(stream ab.AtomicBroadcast_DeliverServer) error\n\tTeardown() error\n}\n\n\ntype Closeable interface {\n\tClose() error\n}\n\ntype serverImpl struct {\n\tbroadcaster Broadcaster\n\tdeliverer   Deliverer\n}\n\n\nfunc New(conf *config.TopLevel) Orderer {\n\treturn &serverImpl{\n\t\tbroadcaster: newBroadcaster(conf),\n\t\tdeliverer:   newDeliverer(conf),\n\t}\n}\n\n\nfunc (s *serverImpl) Broadcast(stream ab.AtomicBroadcast_BroadcastServer) error {\n\treturn s.broadcaster.Broadcast(stream)\n}\n\n\nfunc (s *serverImpl) Deliver(stream ab.AtomicBroadcast_DeliverServer) error {\n\treturn s.deliverer.Deliver(stream)\n}\n\n\n\n\nfunc (s *serverImpl) Teardown() error ", "output": "{\n\ts.deliverer.Close()\n\treturn s.broadcaster.Close()\n}"}
{"input": "package weavedns\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc assertNoErr(t *testing.T, err error) {\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc assertStatus(t *testing.T, got int, wanted int, desc string) {\n\tif got != wanted {\n\t\tt.Fatalf(\"Expected %s %d but got %d\", desc, wanted, got)\n\t}\n}\n\nfunc assertErrorInterface(t *testing.T, got interface{}, wanted interface{}, desc string) {\n\tgotT, wantedT := reflect.TypeOf(got), reflect.TypeOf(wanted).Elem()\n\tif !gotT.Implements(wantedT) {\n\t\tt.Fatalf(\"Expected %s but got %s (%s)\", wantedT.String(), gotT.String(), desc)\n\t}\n}\n\n\n\nfunc assertErrorType(t *testing.T, got interface{}, wanted interface{}, desc string) ", "output": "{\n\tgotT, wantedT := reflect.TypeOf(got), reflect.TypeOf(wanted).Elem()\n\tif gotT != wantedT {\n\t\tt.Fatalf(\"Expected %s but got %s (%s)\", wantedT.String(), gotT.String(), desc)\n\t}\n}"}
{"input": "package cloudflow\n\nimport (\n\t\"sync\"\n\n\tmultierror \"github.com/hashicorp/go-multierror\"\n)\n\n\ntype Task interface {\n\tExecute() error\n}\n\ntype namedTask struct {\n\tname string\n\ttask Task\n}\n\n\ntype ParallelTask struct {\n\ttasks []*namedTask\n}\n\n\nfunc NewParallelTask() *ParallelTask {\n\treturn &ParallelTask{tasks: make([]*namedTask, 0)}\n}\n\n\n\n\n\nfunc (pt *ParallelTask) Summary() string {\n\treturn buildTaskSummary(pt.tasks, \", \", false)\n}\n\n\nfunc (pt *ParallelTask) Execute() error {\n\terrChan := make(chan error)\n\tvar wg sync.WaitGroup\n\n\tfor _, nt := range pt.tasks {\n\t\twg.Add(1)\n\t\tgo func(t Task) {\n\t\t\tif err := t.Execute(); err != nil {\n\t\t\t\terrChan <- err\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(nt.task)\n\t}\n\n\tresultChan := make(chan error)\n\tgo func() {\n\t\tvar result *multierror.Error\n\t\tfor err := range errChan {\n\t\t\tresult = multierror.Append(result, err)\n\t\t}\n\t\tresultChan <- result.ErrorOrNil()\n\t}()\n\n\twg.Wait()\n\tclose(errChan)\n\n\treturn <-resultChan\n}\n\nfunc (pt *ParallelTask) AddTask(name string, task Task) ", "output": "{\n\tpt.tasks = append(pt.tasks, &namedTask{name: name, task: task})\n}"}
{"input": "package testclient\n\nimport (\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\tclientgotesting \"k8s.io/client-go/testing\"\n\n\tuserapi \"github.com/openshift/origin/pkg/user/apis/user\"\n)\n\n\n\ntype FakeIdentities struct {\n\tFake *Fake\n}\n\nvar identitiesResource = schema.GroupVersionResource{Group: \"\", Version: \"\", Resource: \"identities\"}\n\nfunc (c *FakeIdentities) Get(name string, options metav1.GetOptions) (*userapi.Identity, error) {\n\tobj, err := c.Fake.Invokes(clientgotesting.NewRootGetAction(identitiesResource, name), &userapi.Identity{})\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*userapi.Identity), err\n}\n\n\n\nfunc (c *FakeIdentities) Create(inObj *userapi.Identity) (*userapi.Identity, error) {\n\tobj, err := c.Fake.Invokes(clientgotesting.NewRootCreateAction(identitiesResource, inObj), inObj)\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*userapi.Identity), err\n}\n\nfunc (c *FakeIdentities) Update(inObj *userapi.Identity) (*userapi.Identity, error) {\n\tobj, err := c.Fake.Invokes(clientgotesting.NewRootUpdateAction(identitiesResource, inObj), inObj)\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*userapi.Identity), err\n}\n\nfunc (c *FakeIdentities) Delete(name string) error {\n\t_, err := c.Fake.Invokes(clientgotesting.NewRootDeleteAction(identitiesResource, name), nil)\n\treturn err\n}\n\nfunc (c *FakeIdentities) List(opts metav1.ListOptions) (*userapi.IdentityList, error) ", "output": "{\n\tobj, err := c.Fake.Invokes(clientgotesting.NewRootListAction(identitiesResource, opts), &userapi.IdentityList{})\n\tif obj == nil {\n\t\treturn nil, err\n\t}\n\n\treturn obj.(*userapi.IdentityList), err\n}"}
{"input": "package future\n\nimport (\n\t\"time\"\n)\n\n\nconst FuelRechargeRate = float32(1.0 / 3.0) \n\n\nfunc Fuel(initial float32, elap time.Duration) float32 {\n\tfuel := initial + FuelRechargeRate*float32(elap)/float32(time.Second)\n\tif fuel > 10 {\n\t\tfuel = 10\n\t}\n\treturn fuel\n}\n\n\n\n\n\nfunc MissileY(initial float32, rate float32, elap time.Duration) float32 {\n\ty := initial + rate*float32(elap)/float32(time.Second)\n\tif y > 1 {\n\t\ty = 1\n\t}\n\treturn y\n}\n\nfunc CannonX(initial float32, rate float32, elap time.Duration) (float32, float32) ", "output": "{\n\tx := initial + rate*float32(elap)/float32(time.Second)\n\tswitch {\n\tcase x < 0:\n\t\tx = -x\n\t\trate = -rate\n\tcase x > 1:\n\t\tx = 2 - x\n\t\trate = -rate\n\t}\n\treturn x, rate\n}"}
{"input": "package admin\nimport (\n\t\"os\"\n\t\"runtime\"\n\t\"github.com/caliven/go-space/models\"\n\t\"github.com/caliven/go-space/controllers/common\"\n)\n\n\ntype HomeController struct {\n\tcommon.CommonController\n}\n\n\n\nfunc (this *HomeController) Get() ", "output": "{\n\tthis.Data[\"hostname\"], _ = os.Hostname()\n\tthis.Data[\"goos\"] = runtime.GOOS\n\tthis.Data[\"goarch\"] = runtime.GOARCH\n\tthis.Data[\"numcpu\"] = runtime.NumCPU()\n\tthis.Data[\"version\"] = runtime.Version()\n\n\tthis.Data[\"articleCount\"] = new(models.Article).QueryCount()\n\tthis.Data[\"tagCount\"] = new(models.Tag).QueryCount()\n\tthis.Data[\"userCount\"], _ = new(models.User).Query().Count()\n\tthis.Data[\"commentCount\"] = 100\n\tlist, _ := models.QueryArticleList(1)\n\tthis.Data[\"articleList\"] = list\n\tthis.Data[\"layoutTitle\"] = \"控制台\"\n\n\tthis.LoadTplNames(\"home.tpl\")\n}"}
{"input": "package common\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/juju/core/state\"\n\t\"github.com/juju/core/state/api/params\"\n)\n\n\ntype Remover struct {\n\tst             state.EntityFinder\n\tcallEnsureDead bool\n\tgetCanModify   GetAuthFunc\n}\n\n\n\n\n\n\n\nfunc (r *Remover) removeEntity(tag string) error {\n\tentity, err := r.st.FindEntity(tag)\n\tif err != nil {\n\t\treturn err\n\t}\n\tremover, ok := entity.(interface {\n\t\tstate.Lifer\n\t\tstate.Remover\n\t\tstate.EnsureDeader\n\t})\n\tif !ok {\n\t\treturn NotSupportedError(tag, \"removal\")\n\t}\n\tif life := remover.Life(); life == state.Alive {\n\t\treturn fmt.Errorf(\"cannot remove entity %q: still alive\", tag)\n\t}\n\tif r.callEnsureDead {\n\t\tif err := remover.EnsureDead(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn remover.Remove()\n}\n\n\n\nfunc (r *Remover) Remove(args params.Entities) (params.ErrorResults, error) {\n\tresult := params.ErrorResults{\n\t\tResults: make([]params.ErrorResult, len(args.Entities)),\n\t}\n\tif len(args.Entities) == 0 {\n\t\treturn result, nil\n\t}\n\tcanModify, err := r.getCanModify()\n\tif err != nil {\n\t\treturn params.ErrorResults{}, err\n\t}\n\tfor i, entity := range args.Entities {\n\t\terr := ErrPerm\n\t\tif canModify(entity.Tag) {\n\t\t\terr = r.removeEntity(entity.Tag)\n\t\t}\n\t\tresult.Results[i].Error = ServerError(err)\n\t}\n\treturn result, nil\n}\n\nfunc NewRemover(st state.EntityFinder, callEnsureDead bool, getCanModify GetAuthFunc) *Remover ", "output": "{\n\treturn &Remover{\n\t\tst:             st,\n\t\tcallEnsureDead: callEnsureDead,\n\t\tgetCanModify:   getCanModify,\n\t}\n}"}
{"input": "package main\n\nimport \"os\"\n\nvar (\n\tqcapDomain      string\n\tqcapBaseUrl     string\n\tqcapDb          string\n\tqcapListen      string\n\tqcapAlertSender string\n\tqcapTest        bool\n)\n\n\n\nfunc getenv(varName, def string) string {\n\tif newVar := os.Getenv(varName); newVar != \"\" {\n\t\treturn newVar\n\t}\n\treturn def\n}\n\n\n\nfunc init() ", "output": "{\n\tqcapDomain = getenv(\"QCAP_DOMAIN\", \"\")\n\tqcapDb = getenv(\"QCAP_DBNAME\", \"\")\n\tqcapListen = getenv(\"QCAP_HOST\", \"0.0.0.0:80\")\n\tqcapAlertSender = getenv(\"QCAP_ALERT_SENDER\", \"alertsender@example.com\")\n\n\tif qcapDomain != \"\" {\n\t\tqcapBaseUrl = \"http://\" + qcapDomain\n\t}\n\n\tif os.Getenv(\"QCAP_ENV\") != \"production\" {\n\t\tqcapTest = true\n\t}\n}"}
{"input": "package cloudscheduler\n\nimport (\n\t\"github.com/GoogleCloudPlatform/declarative-resource-client-library/dcl\"\n)\n\n\n\ntype Client struct {\n\tConfig *dcl.Config\n}\n\n\n\n\nfunc NewClient(c *dcl.Config) *Client ", "output": "{\n\treturn &Client{\n\t\tConfig: c,\n\t}\n}"}
{"input": "package golog\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/mndrix/golog/term\"\n\t\"github.com/mndrix/ps\"\n)\n\n\n\n\n\n\ntype clauses struct {\n\tn         int64 \n\tlowestId  int64\n\thighestId int64\n\tterms     ps.Map \n}\n\n\nfunc newClauses() *clauses {\n\tvar cs clauses\n\tcs.terms = ps.NewMap()\n\treturn &cs\n}\n\n\nfunc (self *clauses) count() int64 {\n\treturn self.n\n}\n\n\nfunc (self *clauses) cons(t term.Term) *clauses {\n\tcs := self.clone()\n\tcs.n++\n\tcs.lowestId--\n\tkey := strconv.FormatInt(cs.lowestId, 10)\n\tcs.terms = self.terms.Set(key, t)\n\treturn cs\n}\n\n\nfunc (self *clauses) snoc(t term.Term) *clauses {\n\tcs := self.clone()\n\tcs.n++\n\tcs.highestId++\n\tkey := strconv.FormatInt(cs.highestId, 10)\n\tcs.terms = self.terms.Set(key, t)\n\treturn cs\n}\n\n\nfunc (self *clauses) all() []term.Term {\n\tterms := make([]term.Term, 0)\n\tif self.count() == 0 {\n\t\treturn terms\n\t}\n\n\tfor i := self.lowestId; i <= self.highestId; i++ {\n\t\tkey := strconv.FormatInt(i, 10)\n\t\tt, ok := self.terms.Lookup(key)\n\t\tif ok {\n\t\t\tterms = append(terms, t.(term.Term))\n\t\t}\n\t}\n\treturn terms\n}\n\n\n\n\n\nfunc (self *clauses) clone() *clauses {\n\tcs := *self\n\treturn &cs\n}\n\nfunc (self *clauses) forEach(f func(term.Term)) ", "output": "{\n\tfor _, t := range self.all() {\n\t\tf(t)\n\t}\n}"}
{"input": "package control\n\nimport (\n\tyaml \"github.com/cloudfoundry-incubator/candiedyaml\"\n\t\"github.com/dansteen/controlled-compose/types\"\n\t\"github.com/docker/libcompose/config\"\n\t\"github.com/docker/libcompose/utils\"\n\t\"github.com/imdario/mergo.git\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n)\n\n\n\n\nfunc processRequires(file string, configFiles []string) ([]string, error) {\n\tcontent, err := ioutil.ReadFile(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar requires types.Requires\n\terr = yaml.Unmarshal(content, &requires)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnewFiles := append(configFiles, file)\n\n\tfor _, require := range requires.Require {\n\t\trequire = filepath.Join(filepath.Dir(file), require)\n\n\t\tif !utils.Contains(configFiles, require) {\n\t\t\tnewFiles, err = processRequires(require, newFiles)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\treturn newFiles, nil\n}\n\n\n\n\nfunc consumeConfigs(files []string) ([]byte, error) ", "output": "{\n\n\tvar configContent config.Config\n\tvar mergedConfig config.Config\n\tfor _, file := range files {\n\t\tcontent, err := ioutil.ReadFile(file)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\terr = yaml.Unmarshal(content, &configContent)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\terr = mergo.Merge(&mergedConfig, configContent)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tyamlConfig, err := yaml.Marshal(mergedConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn []byte(yamlConfig), nil\n}"}
{"input": "package ode\n\nfunc fweuler_accept(o *ODE, y []float64) {\n}\n\n\n\n\nfunc fweuler_step(o *ODE, y []float64, x float64, args ...interface{}) (rerr float64, err error) ", "output": "{\n\to.nfeval += 1\n\terr = o.fcn(o.f[0], x, y, args...)\n\tif err != nil {\n\t\treturn\n\t}\n\tfor i := 0; i < o.ndim; i++ {\n\t\ty[i] += o.h * o.f[0][i]\n\t}\n\treturn 1e+20, err \n}"}
{"input": "package models\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\n\n\nfunc TestSetServiceStateByDays(t *testing.T) {\n\terr := SetServiceStateByDays(\"testStateDays\", 0, 1)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc TestGetServiceState(t *testing.T) {\n\t_, i, err := GetServiceState(\"testState\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tif i != 1 {\n\t\tt.Error(\"testState incorrect\")\n\t\treturn\n\t}\n\n\t_, i, err = GetServiceState(\"testStateDays\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tif i != 1 {\n\t\tt.Error(\"testStateDays incorrect\")\n\t\treturn\n\t}\n}\n\nfunc TestSetServiceState(t *testing.T) ", "output": "{\n\terr := SetServiceState(\"testState\", time.Now().UTC(), 1)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}"}
{"input": "package wrappers\n\nimport (\n\t\"github.com/johanbrandhorst/protobuf/test/shared\"\n\t\"google.golang.org/grpc/metadata\"\n\n\ttestproto \"github.com/johanbrandhorst/protobuf/test/client/proto/test\"\n)\n\ntype pingBidiStreamWrapper struct {\n\tc testproto.TestService_PingBidiStreamClient\n}\n\n\n\nfunc (pcsw pingBidiStreamWrapper) Recv() (*shared.Response, error) {\n\tresp, err := pcsw.c.Recv()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn (*shared.Response)(resp), nil\n}\n\nfunc (pcsw pingBidiStreamWrapper) Header() (metadata.MD, error) {\n\treturn pcsw.c.Header(), nil\n}\n\nfunc (pcsw pingBidiStreamWrapper) Trailer() metadata.MD {\n\treturn pcsw.c.Trailer()\n}\n\nfunc (pcsw pingBidiStreamWrapper) CloseSend() error {\n\treturn pcsw.c.CloseSend()\n}\n\ntype pingBidiStreamErrorWrapper struct {\n\tc testproto.TestService_PingBidiStreamErrorClient\n}\n\nfunc (pbsew pingBidiStreamErrorWrapper) Send(req *shared.Request) error {\n\treturn pbsew.c.Send(sharedToProtoReq(req))\n}\n\nfunc (pbsew pingBidiStreamErrorWrapper) Recv() (*shared.Response, error) {\n\tresp, err := pbsew.c.Recv()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn (*shared.Response)(resp), nil\n}\n\nfunc (pbsew pingBidiStreamErrorWrapper) CloseSend() error {\n\treturn pbsew.c.CloseSend()\n}\n\nfunc (pcsw pingBidiStreamWrapper) Send(req *shared.Request) error ", "output": "{\n\treturn pcsw.c.Send(sharedToProtoReq(req))\n}"}
{"input": "package version\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n\ntype Command struct {\n\tName       string\n\tW          io.Writer\n\tWErr       io.Writer\n\tAppName    string\n\tAppVersion string\n\tGitCommit  string\n}\n\n\nfunc (c *Command) Run(args []string) (int, error) {\n\tfmt.Fprintln(c.W, c.AppName, c.AppVersion, c.GitCommit)\n\treturn 0, nil\n}\n\n\nfunc (c *Command) Key() string {\n\treturn c.Name\n}\n\n\n\n\n\n\nfunc (c *Command) Description() string {\n\treturn \"Print the version.\"\n}\n\nfunc (c *Command) Aliases() map[string]struct{} ", "output": "{\n\treturn map[string]struct{}{\n\t\t\"version\": struct{}{},\n\t}\n}"}
{"input": "package models\n\n\n\n\nimport (\n\t\"github.com/go-swagger/go-swagger/errors\"\n\t\"github.com/go-swagger/go-swagger/strfmt\"\n\t\"github.com/go-swagger/go-swagger/swag\"\n)\n\n\ntype EmployeePageableResult struct {\n\n\tContent []Employee `json:\"content,omitempty\"`\n\n\tFirst bool `json:\"first,omitempty\"`\n\n\tLast bool `json:\"last,omitempty\"`\n\n\tNumber int32 `json:\"number,omitempty\"`\n\n\tNumberOfElements int32 `json:\"numberOfElements,omitempty\"`\n\n\tServerTime int64 `json:\"serverTime,omitempty\"`\n\n\tSize int32 `json:\"size,omitempty\"`\n\n\tTotalElements int32 `json:\"totalElements,omitempty\"`\n\n\tTotalPages int32 `json:\"totalPages,omitempty\"`\n}\n\n\nfunc (m *EmployeePageableResult) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateContent(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n\n\nfunc (m *EmployeePageableResult) validateContent(formats strfmt.Registry) error ", "output": "{\n\n\tif swag.IsZero(m.Content) { \n\t\treturn nil\n\t}\n\n\tfor i := 0; i < len(m.Content); i++ {\n\n\t\tif err := m.Content[i].Validate(formats); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t}\n\n\treturn nil\n}"}
{"input": "package models\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/matematik7/gongo/authorization\"\n\t\"github.com/matematik7/gongo/files\"\n)\n\nvar location *time.Location\n\nfunc init() {\n\tvar err error\n\tlocation, err = time.LoadLocation(\"Europe/Ljubljana\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\ntype DiaryEntry struct {\n\tgorm.Model\n\tTitle      string             `valid:\"required\"`\n\tText       string             `gorm:\"type:text\" valid:\"required\"`\n\tAuthor     authorization.User `valid:\"-\"`\n\tAuthorID   uint               `valid:\"required\"`\n\tComments   []Comment          `valid:\"-\"`\n\tMapEntry   MapEntry           `valid:\"-\"`\n\tMapEntryID uint\n\tImages     []files.Image `gorm:\"many2many:diary_image\"`\n\tPublished  bool\n\n\tNumComments uint `gorm:\"-\"`\n\tViewed      bool `gorm:\"-\"`\n\tNewComments bool `gorm:\"-\"`\n}\n\n\nfunc (de *DiaryEntry) AfterFind() error {\n\tde.CreatedAt = de.CreatedAt.In(location)\n\tde.UpdatedAt = de.UpdatedAt.In(location)\n\n\treturn nil\n}\n\ntype Comment struct {\n\tgorm.Model\n\tDiaryEntryID uint\n\tComment      string             `gorm:\"type:text\" valid:\"required\"`\n\tAuthor       authorization.User `valid:\"-\"`\n\tAuthorID     uint\n}\n\n\n\ntype EntryUserRead struct {\n\tgorm.Model\n\tDiaryEntryID uint\n\tUserID       uint\n}\n\ntype Workout struct {\n\tID          string\n\tDescription string\n}\n\nfunc (c *Comment) AfterFind() error ", "output": "{\n\tc.CreatedAt = c.CreatedAt.In(location)\n\n\treturn nil\n}"}
{"input": "package imports\n\nimport (\n\t. \"reflect\"\n\tecdsa \"crypto/ecdsa\"\n)\n\n\n\n\nfunc init() ", "output": "{\n\tPackages[\"crypto/ecdsa\"] = Package{\n\tName: \"ecdsa\",\n\tBinds: map[string]Value{\n\t\t\"GenerateKey\":\tValueOf(ecdsa.GenerateKey),\n\t\t\"Sign\":\tValueOf(ecdsa.Sign),\n\t\t\"Verify\":\tValueOf(ecdsa.Verify),\n\t}, Types: map[string]Type{\n\t\t\"PrivateKey\":\tTypeOf((*ecdsa.PrivateKey)(nil)).Elem(),\n\t\t\"PublicKey\":\tTypeOf((*ecdsa.PublicKey)(nil)).Elem(),\n\t}, \n\t}\n}"}
{"input": "package http\n\nimport (\n\t\"testing\"\n)\n\nfunc isChar(c rune) bool { return c <= 127 }\n\nfunc isCtl(c rune) bool { return c <= 31 || c == 127 }\n\nfunc isSeparator(c rune) bool {\n\tswitch c {\n\tcase '(', ')', '<', '>', '@', ',', ';', ':', '\\\\', '\"', '/', '[', ']', '?', '=', '{', '}', ' ', '\\t':\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n\nfunc TestIsToken(t *testing.T) ", "output": "{\n\tfor i := 0; i <= 130; i++ {\n\t\tr := rune(i)\n\t\texpected := isChar(r) && !isCtl(r) && !isSeparator(r)\n\t\tif isToken(r) != expected {\n\t\t\tt.Errorf(\"isToken(0x%x) = %v\", r, !expected)\n\t\t}\n\t}\n}"}
{"input": "package azurerm\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/r3labs/terraform/helper/acctest\"\n\t\"github.com/r3labs/terraform/helper/resource\"\n)\n\n\n\nfunc TestAccAzureRMSqlServer_importBasic(t *testing.T) ", "output": "{\n\tresourceName := \"azurerm_sql_server.test\"\n\n\tri := acctest.RandInt()\n\tconfig := fmt.Sprintf(testAccAzureRMSqlServer_basic, ri, ri)\n\n\tresource.Test(t, resource.TestCase{\n\t\tPreCheck:     func() { testAccPreCheck(t) },\n\t\tProviders:    testAccProviders,\n\t\tCheckDestroy: testCheckAzureRMSqlServerDestroy,\n\t\tSteps: []resource.TestStep{\n\t\t\tresource.TestStep{\n\t\t\t\tConfig: config,\n\t\t\t},\n\n\t\t\tresource.TestStep{\n\t\t\t\tResourceName:            resourceName,\n\t\t\t\tImportState:             true,\n\t\t\t\tImportStateVerify:       true,\n\t\t\t\tImportStateVerifyIgnore: []string{\"administrator_login_password\"},\n\t\t\t},\n\t\t},\n\t})\n}"}
{"input": "package pool\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/hashicorp/consul/lib/freeport\"\n\t\"github.com/hashicorp/nomad/helper/testlog\"\n\t\"github.com/hashicorp/nomad/nomad/structs\"\n\t\"github.com/hashicorp/yamux\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n\n\nfunc TestConnPool_ConnListener(t *testing.T) {\n\trequire := require.New(t)\n\n\tports := freeport.GetT(t, 1)\n\taddrStr := fmt.Sprintf(\"127.0.0.1:%d\", ports[0])\n\taddr, err := net.ResolveTCPAddr(\"tcp\", addrStr)\n\trequire.Nil(err)\n\n\texitCh := make(chan struct{})\n\tdefer close(exitCh)\n\tgo func() {\n\t\tln, err := net.Listen(\"tcp\", addrStr)\n\t\trequire.Nil(err)\n\t\tdefer ln.Close()\n\t\tconn, _ := ln.Accept()\n\t\tdefer conn.Close()\n\n\t\t<-exitCh\n\t}()\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tpool := newTestPool(t)\n\n\tc := make(chan *yamux.Session, 1)\n\tpool.SetConnListener(c)\n\n\t_, err = pool.acquire(\"test\", addr, structs.ApiMajorVersion)\n\trequire.Nil(err)\n\n\tselect {\n\tcase <-c:\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatalf(\"timeout\")\n\t}\n\n\trequire.Nil(pool.Shutdown())\n\t_, ok := <-c\n\trequire.False(ok)\n}\n\nfunc newTestPool(t *testing.T) *ConnPool ", "output": "{\n\tl := testlog.HCLogger(t)\n\tp := NewPool(l, 1*time.Minute, 10, nil)\n\treturn p\n}"}
{"input": "package test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pilosa/pilosa\"\n)\n\n\nfunc NewCluster(n int) *pilosa.Cluster {\n\tc := pilosa.NewCluster()\n\tc.ReplicaN = 1\n\tc.Hasher = NewModHasher()\n\n\tfor i := 0; i < n; i++ {\n\t\tc.Nodes = append(c.Nodes, &pilosa.Node{\n\t\t\tScheme: \"http\",\n\t\t\tHost: fmt.Sprintf(\"host%d\", i),\n\t\t})\n\t}\n\n\treturn c\n}\n\n\ntype ModHasher struct{}\n\n\n\n\nfunc (*ModHasher) Hash(key uint64, n int) int { return int(key) % n }\n\n\ntype ConstHasher struct {\n\ti int\n}\n\n\nfunc NewConstHasher(i int) *ConstHasher { return &ConstHasher{i: i} }\n\nfunc (h *ConstHasher) Hash(key uint64, n int) int { return h.i }\n\nfunc NewModHasher() *ModHasher ", "output": "{ return &ModHasher{} }"}
{"input": "package selinux\n\n\nfunc SELinuxEnabled() bool {\n\treturn false\n}\n\n\ntype realSELinuxRunner struct{}\n\nvar _ SELinuxRunner = &realSELinuxRunner{}\n\nfunc (_ *realSELinuxRunner) Getfilecon(path string) (string, error) {\n\treturn \"\", nil\n}\n\n\n\n\nfunc SetFileLabel(path string, label string) error ", "output": "{\n\treturn nil\n}"}
{"input": "package sacloud\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n)\n\n\n\n\n\ntype ID int64\n\n\nfunc (i *ID) UnmarshalJSON(b []byte) error {\n\ts := string(b)\n\tif s == \"\" || s == \"null\" {\n\t\treturn nil\n\t}\n\tvar n json.Number\n\tif err := json.Unmarshal(b, &n); err != nil {\n\t\treturn err\n\t}\n\tid, err := n.Int64()\n\tif err != nil {\n\t\treturn err\n\t}\n\t*i = ID(id)\n\treturn nil\n}\n\n\n\n\n\nfunc (i ID) String() string {\n\tif i.IsEmpty() {\n\t\treturn \"\"\n\t}\n\treturn fmt.Sprintf(\"%d\", i)\n}\n\n\nfunc (i ID) Int64() int64 {\n\treturn int64(i)\n}\n\n\nfunc Int64ID(id int64) ID {\n\treturn ID(id)\n}\n\n\nfunc StringID(id string) ID {\n\tintID, _ := strconv.ParseInt(id, 10, 64)\n\treturn ID(intID)\n}\n\nfunc (i ID) IsEmpty() bool ", "output": "{\n\treturn i.Int64() == 0\n}"}
{"input": "package portmapper\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/golang/glog\"\n)\n\ntype PortMap struct {\n\tcontainerIP   string\n\tcontainerPort int\n}\n\n\n\ntype PortSet map[int]*PortMap\n\ntype PortMapper struct {\n\ttcpMap PortSet\n\tudpMap PortSet\n\tmutex  sync.Mutex\n}\n\nfunc New() *PortMapper {\n\treturn &PortMapper{PortSet{}, PortSet{}, sync.Mutex{}}\n}\n\nfunc (p *PortMapper) AllocateMap(protocol string, hostPort int,\n\tcontainerIP string, ContainerPort int) error {\n\tp.mutex.Lock()\n\tdefer p.mutex.Unlock()\n\n\tvar pset PortSet\n\n\tif strings.EqualFold(protocol, \"udp\") {\n\t\tpset = p.udpMap\n\t} else {\n\t\tpset = p.tcpMap\n\t}\n\n\te, ok := pset[hostPort]\n\tif ok {\n\t\treturn fmt.Errorf(\"Host port %d had already been used, %s %d\",\n\t\t\thostPort, e.containerIP, e.containerPort)\n\t}\n\n\tallocated := newPortMap(containerIP, ContainerPort)\n\tpset[hostPort] = allocated\n\n\treturn nil\n}\n\nfunc (p *PortMapper) ReleaseMap(protocol string, hostPort int) error {\n\tp.mutex.Lock()\n\tdefer p.mutex.Unlock()\n\n\tvar pset PortSet\n\n\tif strings.EqualFold(protocol, \"udp\") {\n\t\tpset = p.udpMap\n\t} else {\n\t\tpset = p.tcpMap\n\t}\n\n\t_, ok := pset[hostPort]\n\tif !ok {\n\t\tglog.Errorf(\"Host port %d has not been used\", hostPort)\n\t}\n\n\tdelete(pset, hostPort)\n\treturn nil\n}\n\nfunc newPortMap(containerip string, containerport int) *PortMap ", "output": "{\n\treturn &PortMap{\n\t\tcontainerIP:   containerip,\n\t\tcontainerPort: containerport,\n\t}\n}"}
{"input": "package bagua\n\n\n\n\nfunc (p Type) Unicode() string ", "output": "{\n\tswitch p {\n\tcase Qian:\n\t\treturn \"☰\"\n\tcase Dui:\n\t\treturn \"☱\"\n\tcase Li:\n\t\treturn \"☲\"\n\tcase Zhen:\n\t\treturn \"☳\"\n\tcase Xun:\n\t\treturn \"☴\"\n\tcase Kan:\n\t\treturn \"☵\"\n\tcase Gen:\n\t\treturn \"☶\"\n\tcase Kun:\n\t\treturn \"☷\"\n\tdefault:\n\t\treturn \"\"\n\t}\n}"}
{"input": "package data\n\nimport (\n\t\"testing\"\n)\n\n\nvar album = Album{\n\tArtist:   \"TestArtist\",\n\tArtistID: 1,\n\tTitle:    \"TestAlbum\",\n\tYear:     2014,\n}\n\n\n\n\nfunc TestAlbumDatabase(t *testing.T) ", "output": "{\n\tDB = new(SqliteBackend)\n\tDB.DSN(\"~/.config/wavepipe/wavepipe.db\")\n\tif err := DB.Open(); err != nil {\n\t\tt.Fatalf(\"Could not open database connection: %s\", err.Error())\n\t}\n\tdefer DB.Close()\n\n\tif err := album.Save(); err != nil {\n\t\tt.Fatalf(\"Could not save album: %s\", err.Error())\n\t}\n\n\tif err := album.Load(); err != nil {\n\t\tt.Fatalf(\"Could not load album: %s\", err.Error())\n\t}\n\n\tif err := album.Delete(); err != nil {\n\t\tt.Fatalf(\"Could not delete album: %s\", err.Error())\n\t}\n}"}
{"input": "package handlers\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/byuoitav/device-monitoring/actions/gpio\"\n\t\"github.com/labstack/echo\"\n)\n\n\n\n\n\nfunc PresetForHostname(ctx echo.Context) error {\n\thostname := ctx.Param(\"hostname\")\n\n\tv := gpio.GetPins()\n\n\tif len(v) == 0 || len(v) > 1 {\n\t\treturn ctx.String(http.StatusBadRequest, fmt.Sprintf(\"not supported in this room\"))\n\t}\n\n\treturn ctx.String(http.StatusOK, v[0].CurrentPreset(hostname))\n}\n\nfunc GetDividerState(ctx echo.Context) error ", "output": "{\n\tv := gpio.GetPins()\n\n\tresp := make(map[string][]string)\n\tfor i := range v {\n\t\tif v[i].Connected {\n\t\t\tresp[\"connected\"] = append(resp[\"connected\"], v[i].BlueberryPresets)\n\t\t} else {\n\t\t\tresp[\"disconnected\"] = append(resp[\"disconnected\"], v[i].BlueberryPresets)\n\t\t}\n\t}\n\n\treturn ctx.JSON(http.StatusOK, resp)\n}"}
{"input": "package route\n\nimport (\n\t\"app/controller\"\n\t\"net/http\"\n)\n\n\n\ntype apiHandler struct {\n\tc *controller.Context\n}\n\nfunc (h apiHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tswitch {\n\tcase r.Method == http.MethodPost && r.URL.Path == \"/org/get\":\n\t\th.c.OrgGetApi(w, r)\n\tcase r.Method == http.MethodPost && r.URL.Path == \"/org/create\":\n\t\th.c.OrgCreateApi(w, r)\n\tcase r.Method == http.MethodPost && r.URL.Path == \"/session/get\":\n\t\th.c.SessionGetApi(w, r)\n\tcase r.Method == http.MethodPost && r.URL.Path == \"/session/create\":\n\t\th.c.SessionCreateApi(w, r)\n\tdefault:\n\t\th.c.NotFoundApi(w, r)\n\t}\n}\n\nfunc Api(c *controller.Context) http.Handler ", "output": "{\n\treturn &apiHandler{c: c}\n}"}
{"input": "package entity\n\nimport (\n\t\"errors\"\n\t\"github.com/index0h/go-tracker/share/types\"\n)\n\ntype Flash struct {\n\tflashID     types.UUID\n\tvisitID     types.UUID\n\teventID     types.UUID\n\ttimestamp   int64\n\tvisitFields types.Hash\n\teventFields types.Hash\n}\n\nfunc NewFlash(\n\tflashID types.UUID,\n\tvisitID types.UUID,\n\teventID types.UUID,\n\ttimestamp int64,\n\tvisitFields types.Hash,\n\teventFields types.Hash,\n) (*Flash, error) {\n\tif flashID.IsEmpty() {\n\t\treturn nil, errors.New(\"Empty flashID is not allowed\")\n\t}\n\n\tif visitID.IsEmpty() {\n\t\treturn nil, errors.New(\"Param visitID must be not nil\")\n\t}\n\n\tif visitFields == nil {\n\t\treturn nil, errors.New(\"Param visitData must be not nil\")\n\t}\n\n\tif eventFields == nil {\n\t\treturn nil, errors.New(\"Param eventsData must be not nil\")\n\t}\n\n\treturn &Flash{\n\t\tflashID:     flashID,\n\t\tvisitID:     visitID,\n\t\teventID:     eventID,\n\t\ttimestamp:   timestamp,\n\t\tvisitFields: visitFields.Copy(),\n\t\teventFields: eventFields.Copy(),\n\t}, nil\n}\n\nfunc (flash *Flash) FlashID() types.UUID {\n\treturn flash.flashID\n}\n\nfunc (flash *Flash) Timestamp() int64 {\n\treturn flash.timestamp\n}\n\nfunc (flash *Flash) VisitID() types.UUID {\n\treturn flash.visitID\n}\n\nfunc (flash *Flash) EventID() types.UUID {\n\treturn flash.eventID\n}\n\nfunc (flash *Flash) VisitFields() types.Hash {\n\treturn flash.visitFields.Copy()\n}\n\n\n\nfunc (flash *Flash) EventFields() types.Hash ", "output": "{\n\treturn flash.eventFields.Copy()\n}"}
{"input": "package consul\n\nimport (\n\t\"time\"\n\n\t\"github.com/hashicorp/consul/agent/router\"\n\t\"github.com/hashicorp/serf/serf\"\n)\n\n\n\n\n\n\n\n\nfunc (s *Server) Flood(portFn router.FloodPortFn, global *serf.Serf) {\n\ts.floodLock.Lock()\n\tfloodCh := make(chan struct{})\n\ts.floodCh = append(s.floodCh, floodCh)\n\ts.floodLock.Unlock()\n\n\tticker := time.NewTicker(s.config.SerfFloodInterval)\n\tdefer ticker.Stop()\n\tdefer func() {\n\t\ts.floodLock.Lock()\n\t\tdefer s.floodLock.Unlock()\n\n\t\tfor i, ch := range s.floodCh {\n\t\t\tif ch == floodCh {\n\t\t\t\ts.floodCh = append(s.floodCh[:i], s.floodCh[i+1:]...)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tpanic(\"flood channels out of sync\")\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-s.serfLAN.ShutdownCh():\n\t\t\treturn\n\n\t\tcase <-global.ShutdownCh():\n\t\t\treturn\n\n\t\tcase <-ticker.C:\n\t\t\tgoto FLOOD\n\n\t\tcase <-floodCh:\n\t\t\tgoto FLOOD\n\t\t}\n\n\tFLOOD:\n\t\trouter.FloodJoins(s.logger, portFn, s.config.Datacenter, s.serfLAN, global)\n\t}\n}\n\nfunc (s *Server) FloodNotify() ", "output": "{\n\ts.floodLock.RLock()\n\tdefer s.floodLock.RUnlock()\n\n\tfor _, ch := range s.floodCh {\n\t\tselect {\n\t\tcase ch <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t}\n}"}
{"input": "package readers\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n)\n\n\n\nfunc NewIOStat() IReader {\n\tios := &IOStat{}\n\tios.Data = make(map[string]interface{})\n\treturn ios\n}\n\ntype IOStat struct {\n\tData map[string]interface{}\n}\n\n\nfunc (ios *IOStat) Run() error {\n\treturn errors.New(\"iostat -x is only available on Linux.\")\n}\n\n\nfunc (ios *IOStat) ToJson() ([]byte, error) {\n\treturn json.Marshal(ios.Data)\n}\n\nfunc init() ", "output": "{\n\tRegister(\"IOStat\", NewIOStat)\n}"}
{"input": "package i18n\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/gohugoio/hugo/deps\"\n\t\"github.com/gohugoio/hugo/source\"\n\t\"github.com/nicksnyder/go-i18n/i18n/bundle\"\n)\n\n\n\ntype TranslationProvider struct {\n\tt Translator\n}\n\n\nfunc NewTranslationProvider() *TranslationProvider {\n\treturn &TranslationProvider{}\n}\n\n\nfunc (tp *TranslationProvider) Update(d *deps.Deps) error {\n\tdir := d.PathSpec.AbsPathify(d.Cfg.GetString(\"i18nDir\"))\n\tsp := source.NewSourceSpec(d.Cfg, d.Fs)\n\tsources := []source.Input{sp.NewFilesystem(dir)}\n\n\tthemeI18nDir, err := d.PathSpec.GetThemeI18nDirPath()\n\n\tif err == nil {\n\t\tsources = []source.Input{sp.NewFilesystem(themeI18nDir), sources[0]}\n\t}\n\n\td.Log.DEBUG.Printf(\"Load I18n from %q\", sources)\n\n\ti18nBundle := bundle.New()\n\n\tfor _, currentSource := range sources {\n\t\tfor _, r := range currentSource.Files() {\n\t\t\terr := i18nBundle.ParseTranslationFileBytes(r.LogicalName(), r.Bytes())\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"Failed to load translations in file %q: %s\", r.LogicalName(), err)\n\t\t\t}\n\t\t}\n\t}\n\n\ttp.t = NewTranslator(i18nBundle, d.Cfg, d.Log)\n\n\td.Translate = tp.t.Func(d.Language.Lang)\n\n\treturn nil\n\n}\n\n\n\n\nfunc (tp *TranslationProvider) Clone(d *deps.Deps) error ", "output": "{\n\td.Translate = tp.t.Func(d.Language.Lang)\n\n\treturn nil\n}"}
{"input": "package model\n\ntype Face struct{ *Entry }\n\nfunc NewFace(clock Clock, author, title string, standup Standup) interface{} {\n\treturn Face{NewEntry(clock, author, title, standup, \"New face\")}\n}\n\n\n\nfunc (face Face) MakeUpdateRequest() (request WhiteboardRequest) {\n\trequest = face.Entry.MakeUpdateRequest()\n\trequest.Commit = \"Update New Face\"\n\treturn\n}\n\nfunc (face Face) GetEntry() *Entry {\n\treturn face.Entry\n}\n\nfunc (face Face) MakeCreateRequest() (request WhiteboardRequest) ", "output": "{\n\trequest = face.Entry.MakeCreateRequest()\n\trequest.Commit = \"Create New Face\"\n\treturn\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"regexp\"\n\n\tasp \"golang.org/x/exp/aspectgo/aspect\"\n)\n\n\ntype ExampleAspect struct {\n}\n\n\nfunc (a *ExampleAspect) Pointcut() asp.Pointcut {\n\tpkg := regexp.QuoteMeta(\"golang.org/x/exp/aspectgo/example/hello2\")\n\ts := pkg + \".*\"\n\treturn asp.NewCallPointcutFromRegexp(s)\n}\n\n\nfunc (a *ExampleAspect) Advice(ctx asp.Context) []interface{} {\n\targs := ctx.Args()\n\tfmt.Println(\"BEFORE hello\")\n\tres := ctx.Call(args)\n\tfmt.Println(\"AFTER hello\")\n\treturn res\n}\n\n\ntype FmtPrintlnAspect struct {\n}\n\nfunc (a *FmtPrintlnAspect) Pointcut() asp.Pointcut {\n\ts := regexp.QuoteMeta(\"fmt.Println\")\n\treturn asp.NewCallPointcutFromRegexp(s)\n}\n\n\n\nfunc (a *FmtPrintlnAspect) Advice(ctx asp.Context) []interface{} ", "output": "{\n\targs := ctx.Args()\n\tfmt.Fprintf(os.Stderr, \"directing to stderr: %s\\n\", args...)\n\treturn []interface{}{0, nil}\n}"}
{"input": "package index\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/golang/mock/gomock\"\n)\n\n\ntype BatchMatcher interface {\n\tgomock.Matcher\n}\n\n\nfunc NewBatchMatcher(b Batch) BatchMatcher {\n\treturn batchMatcher{b}\n}\n\ntype batchMatcher struct {\n\tb Batch\n}\n\nfunc (bm batchMatcher) Matches(x interface{}) bool {\n\treturn reflect.DeepEqual(bm.b, x)\n}\n\n\n\nfunc (bm batchMatcher) String() string ", "output": "{\n\treturn fmt.Sprintf(\"BatchMatcher: %v\", bm.b)\n}"}
{"input": "package querying\n\nimport (\n\t. \"github.com/herald-it/goncord/models\"\n\t\"gopkg.in/mgo.v2\"\n)\n\n\n\nfunc IsExistDumpToken(obj *DumpToken, c *mgo.Collection) (bool, error) {\n\tdumpToken, err := FindDumpToken(obj, c)\n\treturn dumpToken != nil && err == nil, err\n}\n\n\n\n\n\nfunc IsExistUser(obj *User, c *mgo.Collection) bool ", "output": "{\n\treturn IsExistUserByLoginOrEmail(obj.Login, obj.Email, c)\n}"}
{"input": "package da_griddata\n\nimport (\n\t\"github.com/watermint/toolbox/essentials/io/es_stdout\"\n\t\"github.com/watermint/toolbox/infra/control/app_control\"\n\t\"sync\"\n)\n\nfunc NewConsoleWriter(formatter GridDataFormatter, pw PlainGridDataWriter) GridDataWriter {\n\treturn &consoleWriter{\n\t\tformatter: formatter,\n\t\tpw:        pw,\n\t}\n}\n\ntype consoleWriter struct {\n\tctl       app_control.Control\n\tname      string\n\tformatter GridDataFormatter\n\tpw        PlainGridDataWriter\n\trow       int\n\tmutex     sync.Mutex\n}\n\nfunc (z *consoleWriter) Name() string {\n\treturn z.name\n}\n\nfunc (z *consoleWriter) Row(column []interface{}) {\n\tz.mutex.Lock()\n\tdefer z.mutex.Unlock()\n\tout := es_stdout.NewDefaultOut(z.ctl.Feature())\n\n\t_ = z.pw.WriteRow(z.ctl.Log(), out, z.formatter, z.row, column)\n\tz.row++\n}\n\n\n\nfunc (z *consoleWriter) Close() {\n}\n\nfunc (z *consoleWriter) Open(c app_control.Control) error ", "output": "{\n\tz.ctl = c\n\treturn nil\n}"}
{"input": "package consul\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/abronan/valkeyrie/store\"\n\t\"github.com/abronan/valkeyrie/store/consul\"\n\t\"github.com/containous/traefik/old/provider\"\n\t\"github.com/containous/traefik/old/provider/kv\"\n\t\"github.com/containous/traefik/old/types\"\n\t\"github.com/containous/traefik/safe\"\n)\n\nvar _ provider.Provider = (*Provider)(nil)\n\n\ntype Provider struct {\n\tkv.Provider `mapstructure:\",squash\" export:\"true\"`\n}\n\n\n\n\n\n\nfunc (p *Provider) Provide(configurationChan chan<- types.ConfigMessage, pool *safe.Pool) error {\n\treturn p.Provider.Provide(configurationChan, pool)\n}\n\n\nfunc (p *Provider) CreateStore() (store.Store, error) {\n\tp.SetStoreType(store.CONSUL)\n\tconsul.Register()\n\treturn p.Provider.CreateStore()\n}\n\nfunc (p *Provider) Init(constraints types.Constraints) error ", "output": "{\n\terr := p.Provider.Init(constraints)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstore, err := p.CreateStore()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to Connect to KV store: %v\", err)\n\t}\n\n\tp.SetKVClient(store)\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/openshift/go-systemd/activation\"\n)\n\n\n\nfunc main() {\n\tfixListenPid()\n\n\tlisteners, _ := activation.Listeners(false)\n\n\tif len(listeners) == 0 {\n\t\tpanic(\"No listeners\")\n\t}\n\n\tif os.Getenv(\"LISTEN_PID\") == \"\" || os.Getenv(\"LISTEN_FDS\") == \"\" {\n\t\tpanic(\"Should not unset envs\")\n\t}\n\n\tlisteners, err := activation.Listeners(true)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif os.Getenv(\"LISTEN_PID\") != \"\" || os.Getenv(\"LISTEN_FDS\") != \"\" {\n\t\tpanic(\"Can not unset envs\")\n\t}\n\n\tc0, _ := listeners[0].Accept()\n\tc1, _ := listeners[1].Accept()\n\n\tc0.Write([]byte(\"Hello world\"))\n\tc1.Write([]byte(\"Goodbye world\"))\n\n\treturn\n}\n\nfunc fixListenPid() ", "output": "{\n\tif os.Getenv(\"FIX_LISTEN_PID\") != \"\" {\n\t\tos.Setenv(\"LISTEN_PID\", fmt.Sprintf(\"%d\", os.Getpid()))\n\t}\n}"}
{"input": "package machine\n\nimport \"time\"\n\n\ntype Machine struct {\n\tID          string    `json:\"id\"`\n\tTeam        string    `json:\"team\"`\n\tStack       string    `json:\"stack\"`\n\tProvider    string    `json:\"provider\"`\n\tLabel       string    `json:\"label\"`\n\tIP          string    `json:\"ip\"`\n\tQueryString string    `json:\"queryString\"`\n\tRegisterURL string    `json:\"registerUrl\"`\n\tCreatedAt   time.Time `json:\"createdAt\"`\n\tStatus      Status    `json:\"status\"`\n\tUsers       []User    `json:\"users\"`\n}\n\n\ntype Status struct {\n\tState      string    `json:\"state\"`\n\tReason     string    `json:\"reason\"`\n\tModifiedAt time.Time `json:\"modifiedAt\"`\n}\n\n\ntype User struct {\n\tSudo      bool   `json:\"sudo\"`\n\tOwner     bool   `json:\"owner\"`\n\tPermanent bool   `json:\"permanent\"`\n\tApproved  bool   `json:\"approved\"`\n\tUsername  string `json:\"username\"`\n}\n\n\ntype Filter struct {\n\tID           string \n\tUsername     string \n\tOwners       bool   \n\tOnlyApproved bool   \n}\n\n\ntype Database interface {\n\tMachines(*Filter) ([]*Machine, error)\n}\n\n\ntype Client struct {\n\tdb Database\n}\n\n\n\n\n\nfunc (c *Client) Machines(f *Filter) ([]*Machine, error) {\n\treturn c.db.Machines(f)\n}\n\nfunc NewClient(db Database) *Client ", "output": "{\n\treturn &Client{\n\t\tdb: db,\n\t}\n}"}
{"input": "package rest\n\n\ntype BaseAPI struct {\n\tmethod         string\n\tendpoint       string\n\trequestObject  interface{}\n\tresponseObject interface{}\n\terrorObject    interface{}\n\tstatusCode     int\n\trawResponse    []byte\n\terr            error\n}\n\n\nfunc NewBaseAPI(\n\tmethod string,\n\tendpoint string,\n\trequestObject interface{},\n\tresponseObject interface{},\n\terrorObject interface{},\n) *BaseAPI {\n\treturn &BaseAPI{method, endpoint, requestObject, responseObject, errorObject, 0, nil, nil}\n}\n\n\nfunc (b *BaseAPI) RequestObject() interface{} {\n\treturn b.requestObject\n}\n\n\nfunc (b *BaseAPI) ResponseObject() interface{} {\n\treturn b.responseObject\n}\n\n\nfunc (b *BaseAPI) ErrorObject() interface{} {\n\treturn b.errorObject\n}\n\n\nfunc (b *BaseAPI) Method() string {\n\treturn b.method\n}\n\n\nfunc (b *BaseAPI) Endpoint() string {\n\treturn b.endpoint\n}\n\n\n\n\n\nfunc (b *BaseAPI) RawResponse() []byte {\n\treturn b.rawResponse\n}\n\n\nfunc (b *BaseAPI) Error() error {\n\treturn b.err\n}\n\n\nfunc (b *BaseAPI) SetStatusCode(statusCode int) {\n\tb.statusCode = statusCode\n}\n\n\nfunc (b *BaseAPI) SetRawResponse(rawResponse []byte) {\n\tb.rawResponse = rawResponse\n}\n\n\nfunc (b *BaseAPI) SetError(err error) {\n\tb.err = err\n}\n\n\nfunc (b *BaseAPI) SetResponseObject(res interface{}) {\n\tb.responseObject = res\n}\n\n\nfunc (b *BaseAPI) SetErrorObject(res interface{}) {\n\tb.errorObject = res\n}\n\nfunc (b *BaseAPI) StatusCode() int ", "output": "{\n\treturn b.statusCode\n}"}
{"input": "package pipelinerun\n\nimport (\n\t\"sort\"\n\n\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"\n)\n\nfunc SortByNamespace(prs []v1beta1.PipelineRun) {\n\tsort.Sort(byNamespace(prs))\n}\n\ntype byNamespace []v1beta1.PipelineRun\n\n\n\nfunc (prs byNamespace) Len() int      { return len(prs) }\nfunc (prs byNamespace) Swap(i, j int) { prs[i], prs[j] = prs[j], prs[i] }\nfunc (prs byNamespace) Less(i, j int) bool {\n\tvar lt, eq bool\n\tif lt, eq = prs.compareNamespace(prs[i].Namespace, prs[j].Namespace); eq {\n\t\tif prs[j].Status.StartTime == nil {\n\t\t\treturn false\n\t\t}\n\t\tif prs[i].Status.StartTime == nil {\n\t\t\treturn true\n\t\t}\n\t\treturn prs[j].Status.StartTime.Before(prs[i].Status.StartTime)\n\t}\n\treturn lt\n}\n\nfunc (prs byNamespace) compareNamespace(ins, jns string) (lt, eq bool) ", "output": "{\n\tlt, eq = ins < jns, ins == jns\n\treturn lt, eq\n}"}
{"input": "package v1beta1\n\nimport (\n\t\"context\"\n\n\t\"github.com/google/uuid\"\n)\n\nconst (\n\tuuidPrefix = \"knative-kafka-source-\"\n)\n\n\n\n\nfunc (k *KafkaSource) SetDefaults(ctx context.Context) ", "output": "{\n\tif k != nil && k.Spec.ConsumerGroup == \"\" {\n\t\tk.Spec.ConsumerGroup = uuidPrefix + uuid.New().String()\n\t}\n}"}
{"input": "package testing\n\nimport (\n\tgc \"launchpad.net/gocheck\"\n\n\t\"github.com/juju/core/instance\"\n\t\"github.com/juju/core/state\"\n)\n\n\n\n\n\n\n\n\n\n\nfunc AddStateServerMachine(c *gc.C, st *state.State) *state.Machine ", "output": "{\n\tmachine, err := st.AddMachine(\"quantal\", state.JobManageEnviron)\n\tc.Assert(err, gc.IsNil)\n\terr = machine.SetAddresses(instance.NewAddress(\"0.1.2.3\", instance.NetworkUnknown))\n\tc.Assert(err, gc.IsNil)\n\n\thostPorts := [][]instance.HostPort{{{\n\t\tAddress: instance.NewAddress(\"0.1.2.3\", instance.NetworkUnknown),\n\t\tPort:    1234,\n\t}}}\n\terr = st.SetAPIHostPorts(hostPorts)\n\tc.Assert(err, gc.IsNil)\n\n\treturn machine\n}"}
{"input": "package mock\n\nimport \"bytes\"\n\n\ntype Job struct {\n\tPayload, Name, GearmanHandle, ID string\n\tGearmanErr                       error\n\tGearmanWarnings                  [][]byte\n\tDataBuffer                       bytes.Buffer\n\tNumerator, Denominator           int\n}\n\n\nfunc CreateMockJob(payload string) *Job {\n\treturn &Job{Payload: payload}\n}\n\n\nfunc (m Job) Data() []byte {\n\treturn []byte(m.Payload)\n}\n\n\n\n\n\nfunc (m Job) Fn() string {\n\treturn m.Name\n}\n\n\nfunc (m Job) Err() error {\n\treturn m.GearmanErr\n}\n\n\nfunc (m Job) Handle() string {\n\treturn m.GearmanHandle\n}\n\n\nfunc (m Job) UniqueId() string {\n\treturn m.ID\n}\n\n\nfunc (m *Job) Warnings() [][]byte {\n\treturn m.GearmanWarnings\n}\n\n\nfunc (m *Job) SendWarning(warning []byte) {\n\tm.GearmanWarnings = append(m.GearmanWarnings, warning)\n}\n\n\nfunc (m *Job) SendData(data []byte) {\n\tm.DataBuffer.Write(data)\n}\n\n\nfunc (m *Job) UpdateStatus(numerator, denominator int) {\n\tm.Numerator = numerator\n\tm.Denominator = denominator\n}\n\nfunc (m Job) OutData() []byte ", "output": "{\n\treturn m.DataBuffer.Bytes()\n}"}
{"input": "package mocks\n\nimport \"github.com/aws/aws-sdk-go/service/iam\"\n\ntype IAMClient struct {\n\tDeleteUserCall struct {\n\t\tReceives struct {\n\t\t\tInput *iam.DeleteUserInput\n\t\t}\n\t\tReturns struct {\n\t\t\tOutput *iam.DeleteUserOutput\n\t\t\tError  error\n\t\t}\n\t}\n\n\tCreateAccessKeyCall struct {\n\t\tReceives struct {\n\t\t\tInput *iam.CreateAccessKeyInput\n\t\t}\n\t\tReturns struct {\n\t\t\tOutput *iam.CreateAccessKeyOutput\n\t\t\tError  error\n\t\t}\n\t}\n\n\tDeleteAccessKeyCall struct {\n\t\tReceives struct {\n\t\t\tInput *iam.DeleteAccessKeyInput\n\t\t}\n\t\tReturns struct {\n\t\t\tOutput *iam.DeleteAccessKeyOutput\n\t\t\tError  error\n\t\t}\n\t}\n\n\tListAccessKeysCall struct {\n\t\tReceives struct {\n\t\t\tInput *iam.ListAccessKeysInput\n\t\t}\n\t\tReturns struct {\n\t\t\tOutput *iam.ListAccessKeysOutput\n\t\t\tError  error\n\t\t}\n\t}\n}\n\nfunc (c *IAMClient) DeleteUser(input *iam.DeleteUserInput) (*iam.DeleteUserOutput, error) {\n\tc.DeleteUserCall.Receives.Input = input\n\treturn c.DeleteUserCall.Returns.Output, c.DeleteUserCall.Returns.Error\n}\n\n\n\nfunc (c *IAMClient) DeleteAccessKey(input *iam.DeleteAccessKeyInput) (*iam.DeleteAccessKeyOutput, error) {\n\tc.DeleteAccessKeyCall.Receives.Input = input\n\treturn c.DeleteAccessKeyCall.Returns.Output, c.DeleteAccessKeyCall.Returns.Error\n}\n\nfunc (c *IAMClient) ListAccessKeys(input *iam.ListAccessKeysInput) (*iam.ListAccessKeysOutput, error) {\n\tc.ListAccessKeysCall.Receives.Input = input\n\treturn c.ListAccessKeysCall.Returns.Output, c.ListAccessKeysCall.Returns.Error\n}\n\nfunc (c *IAMClient) CreateAccessKey(input *iam.CreateAccessKeyInput) (*iam.CreateAccessKeyOutput, error) ", "output": "{\n\tc.CreateAccessKeyCall.Receives.Input = input\n\treturn c.CreateAccessKeyCall.Returns.Output, c.CreateAccessKeyCall.Returns.Error\n}"}
{"input": "package common\n\ntype mockUploader struct {\n}\n\nfunc (uploader *mockUploader) Upload(destination string, path string) error {\n\treturn nil\n}\n\n\n\nfunc newMockUploader() Uploader {\n\treturn new(mockUploader)\n}\n\nfunc (uploader *mockUploader) Url(sourceAssetId, templateId, placeholderSize string, page int32) string ", "output": "{\n\treturn \"mock://\" + sourceAssetId\n}"}
{"input": "package scheduler\n\nimport (\n\t\"testing\"\n\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/api\"\n)\n\n\n\ntype schedulerTester struct {\n\tt            *testing.T\n\tscheduler    Scheduler\n\tminionLister MinionLister\n}\n\n\n\n\n\nfunc (st *schedulerTester) expectSuccess(pod *api.Pod) {\n\t_, err := st.scheduler.Schedule(pod, st.minionLister)\n\tif err != nil {\n\t\tst.t.Errorf(\"Unexpected error %v\\nTried to scheduler: %#v\", err, pod)\n\t\treturn\n\t}\n}\n\n\nfunc (st *schedulerTester) expectFailure(pod *api.Pod) {\n\t_, err := st.scheduler.Schedule(pod, st.minionLister)\n\tif err == nil {\n\t\tst.t.Error(\"Unexpected non-error\")\n\t}\n}\n\nfunc newPod(host string, hostPorts ...int) *api.Pod {\n\tnetworkPorts := []api.ContainerPort{}\n\tfor _, port := range hostPorts {\n\t\tnetworkPorts = append(networkPorts, api.ContainerPort{HostPort: port})\n\t}\n\treturn &api.Pod{\n\t\tSpec: api.PodSpec{\n\t\t\tHost: host,\n\t\t\tContainers: []api.Container{\n\t\t\t\t{\n\t\t\t\t\tPorts: networkPorts,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc (st *schedulerTester) expectSchedule(pod *api.Pod, expected string) ", "output": "{\n\tactual, err := st.scheduler.Schedule(pod, st.minionLister)\n\tif err != nil {\n\t\tst.t.Errorf(\"Unexpected error %v\\nTried to scheduler: %#v\", err, pod)\n\t\treturn\n\t}\n\tif actual != expected {\n\t\tst.t.Errorf(\"Unexpected scheduling value: %v, expected %v\", actual, expected)\n\t}\n}"}
{"input": "package reverse_cache\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aschepis/netfilter/ip\"\n)\n\nfunc TestReverseCache(t *testing.T) {\n\tc := New(16)\n\n\tip := ip.NewAddr4(1)\n\texpected := []string{\"www.google.com\", \"gmail.com\"}\n\tc.Add(ip, &DomainList{Domains: expected}, 100)\n\n\tdlist, ok := c.Get(ip)\n\tif !ok {\n\t\tt.Errorf(\"failed to lookup domains\")\n\t}\n\n\tif dlist.Domains[0] != \"www.google.com\" || dlist.Domains[1] != \"gmail.com\" {\n\t\tt.Errorf(\"failed to lookup domains. expected: %v, got: %v\", expected, dlist)\n\t}\n}\n\n\n\nfunc TestExpire(t *testing.T) {\n\tc := New(16)\n\n\tip := ip.NewAddr4(1)\n\tc.Add(ip, &DomainList{Domains: []string{\"www.google.com\"}}, 1)\n\n\ttime.Sleep(2 * time.Second)\n\t_, ok := c.Get(ip)\n\tif ok {\n\t\tt.Errorf(\"successfully looked up domain that should have expired\")\n\t}\n}\n\nfunc TestNoCache(t *testing.T) ", "output": "{\n\tc := New(16)\n\n\tip := ip.NewAddr4(1)\n\tc.Add(ip, &DomainList{Domains: []string{\"www.google.com\"}}, 0)\n\n\t_, ok := c.Get(ip)\n\tif ok {\n\t\tt.Errorf(\"successfully looked up domain that should not have been cached\")\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\n\t\"gopkg.in/yaml.v2\"\n)\n\nvar configFileOptions map[string]interface{}\n\nfunc LoadConfigFile(file string) error {\n\tconfigFileOptions = nil\n\tif _, err := os.Stat(file); err != nil {\n\t\treturn nil\n\t}\n\tif s, err := ioutil.ReadFile(file); err != nil {\n\t\treturn err\n\t} else if err := yaml.Unmarshal(s, &configFileOptions); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\n\nfunc IsKeyInConfig(key string) bool {\n\t_, ok := configFileOptions[key]\n\treturn ok\n}\n\nfunc getConfigFileValueWithDefault(key string, defaultValue interface{}) interface{} {\n\tif v := getConfigFileValue(key); v != nil {\n\t\treturn v\n\t} else {\n\t\treturn defaultValue\n\t}\n}\n\n\n\nfunc GetConfigFileSlice(key string) []string {\n\tif v, ok := configFileOptions[key].([]interface{}); ok {\n\t\tretVal := []string{}\n\t\tfor _, e := range v {\n\t\t\tif strV, ok := e.(string); ok {\n\t\t\t\tretVal = append(retVal, strV)\n\t\t\t}\n\t\t}\n\t\treturn retVal\n\t} else {\n\t\treturn []string{}\n\t}\n}\n\nfunc GetConfigFileString(key string) string {\n\tv, _ := getConfigFileValue(key).(string)\n\treturn v\n}\n\nfunc GetConfigFileStringWithDefault(key string, defaultValue interface{}) string {\n\tv, _ := getConfigFileValueWithDefault(key, defaultValue).(string)\n\treturn v\n}\n\nfunc getConfigFileValue(key string) interface{} ", "output": "{\n\tif v, ok := configFileOptions[key]; ok {\n\t\treturn v\n\t} else {\n\t\treturn nil\n\t}\n}"}
{"input": "package serverplan\n\nimport (\n\t\"github.com/sacloud/libsacloud/v2/helper/validate\"\n\t\"github.com/sacloud/libsacloud/v2/sacloud/types\"\n)\n\ntype ReadRequest struct {\n\tZone string   `request:\"-\" validate:\"required\"`\n\tID   types.ID `request:\"-\" validate:\"required\"`\n}\n\n\n\nfunc (req *ReadRequest) Validate() error ", "output": "{\n\treturn validate.Struct(req)\n}"}
{"input": "package lints\n\n\n\nimport (\n\t\"github.com/zmap/zcrypto/x509\"\n\t\"github.com/zmap/zlint/util\"\n)\n\n\n\ntype basicConstCrit struct{}\n\n\n\nfunc (l *basicConstCrit) CheckApplies(c *x509.Certificate) bool {\n\treturn c.IsCA && util.IsExtInCert(c, util.BasicConstOID)\n}\n\nfunc (l *basicConstCrit) Execute(c *x509.Certificate) *LintResult {\n\tif e := util.GetExtFromCert(c, util.BasicConstOID); e != nil {\n\t\tif e.Critical {\n\t\t\treturn &LintResult{Status: Pass}\n\t\t} else {\n\t\t\treturn &LintResult{Status: Error}\n\t\t}\n\t} else {\n\t\treturn &LintResult{Status: NA}\n\t}\n}\n\nfunc init() {\n\tRegisterLint(&Lint{\n\t\tName:          \"e_basic_constraints_not_critical\",\n\t\tDescription:   \"basicConstraints MUST appear as a critical extension\",\n\t\tCitation:      \"RFC 5280: 4.2.1.9\",\n\t\tSource:        RFC5280,\n\t\tEffectiveDate: util.RFC2459Date,\n\t\tLint:          &basicConstCrit{},\n\t})\n}\n\nfunc (l *basicConstCrit) Initialize() error ", "output": "{\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\n\tcommon \"github.com/alexgarzao/ms-gen/poc/SERVICE_NAME_common\"\n)\n\ntype TestBehaviour1 struct {\n}\n\nfunc NewTestBehaviour1() *TestBehaviour1 {\n\treturn &TestBehaviour1{}\n}\n\nfunc (t *TestBehaviour1) RunAllTests() {\n\tlog.Println(\"Checking behaviour 1\")\n\n\tt.test1() \n\tt.test2()\n}\n\n\n\nfunc (T *TestBehaviour1) test2() {\n\trequest := common.ServiceRequest1{\n\t\tFieldName1: \"invalid\",\n\t\tFieldName2: \"yyy\",\n\t}\n\n\tSendTestInvalidRequest1(\"Request XXX with invalid infos\", \"parameter_value\", request, \"Expected message error\")\n}\n\nfunc (t *TestBehaviour1) test1() ", "output": "{\n\n\trequest := common.ServiceRequest1{\n\t\tFieldName1: \"xxx\",\n\t\tFieldName2: \"yyy\",\n\t}\n\n\tSendTestValidRequest1(\"Request XXX with valid infos\", \"parameter_value\", request)\n}"}
{"input": "package koda\n\nimport (\n\t\"net/url\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n\n\t\"gopkg.in/redis.v3\"\n)\n\n\n\n\n\nfunc Configure(opts *Options) {\n\tDefaultClient = NewClient(opts)\n}\n\n\nfunc Submit(queue string, priority int, payload interface{}) (Job, error) {\n\treturn DefaultClient.Submit(Queue{Name: queue}, priority, payload)\n}\n\n\nfunc SubmitDelayed(queue string, d time.Duration, payload interface{}) (Job, error) {\n\treturn DefaultClient.SubmitDelayed(Queue{Name: queue}, d, payload)\n}\n\n\nfunc Register(queue string, numWorkers int, f HandlerFunc) {\n\tq := Queue{\n\t\tName:       queue,\n\t\tNumWorkers: numWorkers,\n\t}\n\tDefaultClient.Register(q, f)\n}\n\n\n\nfunc Work() Canceller {\n\treturn DefaultClient.Work()\n}\n\n\n\nfunc WorkForever() {\n\tDefaultClient.WorkForever()\n}\n\nfunc NewClient(opts *Options) *Client ", "output": "{\n\tif opts == nil {\n\t\topts = &Options{}\n\t}\n\n\tif opts.URL == \"\" {\n\t\topts.URL = \"redis://localhost:6379\"\n\t}\n\n\tif opts.Prefix == \"\" {\n\t\topts.Prefix = \"koda\"\n\t}\n\n\tif opts.ConnFactory == nil {\n\t\turl, err := url.Parse(opts.URL)\n\t\tdb, _ := strconv.Atoi(url.Path)\n\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\topts.ConnFactory = func() Conn {\n\t\t\tr := redis.NewClient(&redis.Options{\n\t\t\t\tAddr: url.Host,\n\t\t\t\tDB:   int64(db),\n\t\t\t})\n\t\t\treturn &redisAdapter{R: r}\n\t\t}\n\t}\n\n\treturn &Client{\n\t\topts: opts,\n\t\tconnPool: sync.Pool{New: func() interface{} {\n\t\t\treturn opts.ConnFactory()\n\t\t}},\n\t}\n}"}
{"input": "package testing\n\nimport \"k8s.io/kubernetes/pkg/util/iptables\"\n\n\ntype fake struct{}\n\nfunc NewFake() *fake {\n\treturn &fake{}\n}\n\nfunc (*fake) EnsureChain(table iptables.Table, chain iptables.Chain) (bool, error) {\n\treturn true, nil\n}\n\n\n\nfunc (*fake) DeleteChain(table iptables.Table, chain iptables.Chain) error {\n\treturn nil\n}\n\nfunc (*fake) EnsureRule(position iptables.RulePosition, table iptables.Table, chain iptables.Chain, args ...string) (bool, error) {\n\treturn true, nil\n}\n\nfunc (*fake) DeleteRule(table iptables.Table, chain iptables.Chain, args ...string) error {\n\treturn nil\n}\n\nfunc (*fake) IsIpv6() bool {\n\treturn false\n}\n\nfunc (*fake) Save(table iptables.Table) ([]byte, error) {\n\treturn make([]byte, 0), nil\n}\n\nfunc (*fake) SaveAll() ([]byte, error) {\n\treturn make([]byte, 0), nil\n}\n\nfunc (*fake) Restore(table iptables.Table, data []byte, flush iptables.FlushFlag, counters iptables.RestoreCountersFlag) error {\n\treturn nil\n}\n\nfunc (*fake) RestoreAll(data []byte, flush iptables.FlushFlag, counters iptables.RestoreCountersFlag) error {\n\treturn nil\n}\nfunc (*fake) AddReloadFunc(reloadFunc func()) {}\n\nfunc (*fake) Destroy() {}\n\nvar _ = iptables.Interface(&fake{})\n\nfunc (*fake) FlushChain(table iptables.Table, chain iptables.Chain) error ", "output": "{\n\treturn nil\n}"}
{"input": "package swarm\n\nimport (\n\tma \"gx/ipfs/QmTZBfrPJmjWsCvHEtX5FE6KimVJhsJg5sBbqEFYf4UZtL/go-multiaddr\"\n\taddrutil \"gx/ipfs/QmZomXpA4HrYKRV2ftnE5odWMT2JNnhAXTvEyQrzXrnyEX/go-addr-util\"\n)\n\n\n\n\n\n\n\nfunc (s *Swarm) InterfaceListenAddresses() ([]ma.Multiaddr, error) {\n\treturn addrutil.ResolveUnspecifiedAddresses(s.ListenAddresses(), nil)\n}\n\nfunc (s *Swarm) ListenAddresses() []ma.Multiaddr ", "output": "{\n\ts.listeners.RLock()\n\tdefer s.listeners.RUnlock()\n\taddrs := make([]ma.Multiaddr, 0, len(s.listeners.m))\n\tfor l := range s.listeners.m {\n\t\taddrs = append(addrs, l.Multiaddr())\n\t}\n\treturn addrs\n}"}
{"input": "package all\n\nimport \"github.com/catorpilor/leetcode/utils\"\n\nfunc allElements(root1, root2 *utils.TreeNode) []int {\n\treturn useMorris(root1, root2)\n}\n\n\n\n\nfunc useMorris(root1, root2 *utils.TreeNode) []int ", "output": "{\n\tu1, u2 := utils.InorderTraversal(root1), utils.InorderTraversal(root2)\n\tn1, n2 := len(u1), len(u2)\n\tans := make([]int, 0, n1+n2)\n\tvar i, j int\n\tfor i != n1 && j != n2 {\n\t\tif u1[i] <= u2[j] {\n\t\t\tans = append(ans, u1[i])\n\t\t\ti++\n\t\t} else {\n\t\t\tans = append(ans, u2[j])\n\t\t\tj++\n\t\t}\n\t}\n\tif i != n1 {\n\t\tans = append(ans, u1[i:]...)\n\t}\n\tif j != n2 {\n\t\tans = append(ans, u2[j:]...)\n\t}\n\treturn ans\n}"}
{"input": "package viewmodel\n\nimport \"github.com/airlingo/airlingo/model\"\n\ntype Settings struct {\n\tCurrentUser          *model.User\n\tName                 string\n\tTranslationLanguage  *model.Language\n\tTranslationLanguages []*model.Language\n}\n\n\n\nfunc (c *Settings) GetTranslationLanguageID() string {\n\tif c.TranslationLanguage == nil {\n\t\treturn \"\"\n\t}\n\n\treturn c.TranslationLanguage.ID\n}\n\nfunc NewSettings(currentUser *model.User, name string, translationLanguageID *string, translationLanguages []*model.Language) *Settings ", "output": "{\n\tsettings := &Settings{\n\t\tCurrentUser:          currentUser,\n\t\tName:                 name,\n\t\tTranslationLanguages: translationLanguages,\n\t}\n\n\tif translationLanguageID != nil {\n\t\tfor _, language := range translationLanguages {\n\t\t\tif language.ID == *translationLanguageID {\n\t\t\t\tsettings.TranslationLanguage = language\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn settings\n}"}
{"input": "package testing\n\n\n\n\nimport (\n\t\"k8s.io/kubernetes/pkg/api/v1\"\n\tclientset \"k8s.io/kubernetes/pkg/client/clientset_generated/clientset\"\n\tkubecontainer \"k8s.io/kubernetes/pkg/kubelet/container\"\n\tcontainertest \"k8s.io/kubernetes/pkg/kubelet/container/testing\"\n)\n\ntype fakeNetworkHost struct {\n\tfakeNamespaceGetter\n\tkubeClient clientset.Interface\n\tLegacy     bool\n\tRuntime    *containertest.FakeRuntime\n}\n\nfunc NewFakeHost(kubeClient clientset.Interface) *fakeNetworkHost {\n\thost := &fakeNetworkHost{kubeClient: kubeClient, Legacy: true, Runtime: &containertest.FakeRuntime{}}\n\treturn host\n}\n\nfunc (fnh *fakeNetworkHost) GetPodByName(name, namespace string) (*v1.Pod, bool) {\n\treturn nil, false\n}\n\nfunc (fnh *fakeNetworkHost) GetKubeClient() clientset.Interface {\n\treturn nil\n}\n\nfunc (nh *fakeNetworkHost) GetRuntime() kubecontainer.Runtime {\n\treturn nh.Runtime\n}\n\n\n\ntype fakeNamespaceGetter struct {\n\tns string\n}\n\nfunc (nh *fakeNamespaceGetter) GetNetNS(containerID string) (string, error) {\n\treturn nh.ns, nil\n}\n\nfunc (nh *fakeNetworkHost) SupportsLegacyFeatures() bool ", "output": "{\n\treturn nh.Legacy\n}"}
{"input": "package gobizfly\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\nvar _ ServiceInterface = (*service)(nil)\n\nconst serviceUrl = \"/api/auth/service\"\n\ntype Service struct {\n\tName          string `json:\"name\"`\n\tCode          string `json:\"code\"`\n\tCanonicalName string `json:\"canonical_name\"`\n\tId            int    `json:\"id\"`\n\tRegion        string `json:\"region\"`\n\tIcon          string `json:\"icon\"`\n\tDescription   string `json:\"description\"`\n\tEnabled       bool   `json:\"enabled\"`\n\tServiceUrl    string `json:\"service_url\"`\n}\n\ntype ServiceList struct {\n\tServices []*Service `json:\"services\"`\n}\n\ntype service struct {\n\tclient *Client\n}\n\ntype ServiceInterface interface {\n\tList(ctx context.Context) ([]*Service, error)\n}\n\n\n\nfunc (s *service) List(ctx context.Context) ([]*Service, error) ", "output": "{\n\tu, err := s.client.apiURL.Parse(serviceUrl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuf := new(bytes.Buffer)\n\n\treq, err := http.NewRequest(\"GET\", u.String(), buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := s.client.Do(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tvar services ServiceList\n\n\tif err := json.NewDecoder(resp.Body).Decode(&services); err != nil {\n\t\treturn nil, err\n\t}\n\treturn services.Services, nil\n}"}
{"input": "package packets\n\nimport (\n\t\"fmt\"\n\t\"github.com/google/uuid\"\n\t\"io\"\n)\n\n\n\ntype PubcompPacket struct {\n\tFixedHeader\n\tMessageID uint16\n\tuuid      uuid.UUID\n}\n\nfunc (pc *PubcompPacket) String() string {\n\tstr := fmt.Sprintf(\"%s\\n\", pc.FixedHeader)\n\tstr += fmt.Sprintf(\"MessageID: %d\", pc.MessageID)\n\treturn str\n}\n\nfunc (pc *PubcompPacket) Write(w io.Writer) error {\n\tvar err error\n\tpc.FixedHeader.RemainingLength = 2\n\tpacket := pc.FixedHeader.pack()\n\tpacket.Write(encodeUint16(pc.MessageID))\n\t_, err = packet.WriteTo(w)\n\n\treturn err\n}\n\n\n\nfunc (pc *PubcompPacket) Details() Details {\n\treturn Details{Qos: pc.Qos, MessageID: pc.MessageID}\n}\n\nfunc (pc *PubcompPacket) UUID() uuid.UUID {\n\treturn pc.uuid\n}\n\nfunc (pc *PubcompPacket) Unpack(b io.Reader) ", "output": "{\n\tpc.MessageID = decodeUint16(b)\n}"}
{"input": "package datastructures\n\n\ntype Comparable interface {\n\tCompare(Comparable) int\n}\n\n\ntype Comparables []Comparable\n\n\n\n\n\nfunc (cs Comparables) Less(i, j int) bool {\n\tif cs[i].Compare(cs[j]) < 0 {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n\nfunc (cs *Comparables) Shift() Comparable {\n\tif len(*cs) == 0 {\n\t\treturn nil\n\t}\n\n\tf := (*cs)[0]\n\t*cs = (*cs)[1:]\n\treturn f\n}\n\n\nfunc (cs Comparables) Swap(i, j int) {\n\tcs[i], cs[j] = cs[j], cs[i]\n}\n\n\ntype IntComparable int\n\n\nfunc (ic IntComparable) Compare(i Comparable) int {\n\tother, ok := i.(IntComparable)\n\n\tif !ok {\n\t\tpanic(\"param should be an intComparable\")\n\t}\n\n\tif int(ic) == int(other) {\n\t\treturn 0\n\t} else if int(ic) < int(other) {\n\t\treturn -1\n\t} else {\n\t\treturn 1\n\t}\n}\n\nfunc (cs Comparables) Len() int ", "output": "{\n\treturn len(cs)\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\n\t\"golang.org/x/mobile/app\"\n\n\t\"mojo/public/go/application\"\n\t\"mojo/public/go/bindings\"\n\t\"mojo/public/go/system\"\n\n\t\"examples/echo/echo\"\n)\n\n\nimport \"C\"\n\ntype EchoImpl struct{}\n\nfunc (echo *EchoImpl) EchoString(inValue *string) (outValue *string, err error) {\n\tlog.Printf(\"server: %s\\n\", *inValue)\n\treturn inValue, nil\n}\n\ntype EchoServerDelegate struct {\n\tstubs []*bindings.Stub\n}\n\nfunc (delegate *EchoServerDelegate) Initialize(context application.Context) {}\n\nfunc (delegate *EchoServerDelegate) Create(request echo.EchoRequest) {\n\tstub := echo.NewEchoStub(request, &EchoImpl{}, bindings.GetAsyncWaiter())\n\tdelegate.stubs = append(delegate.stubs, stub)\n\tgo func() {\n\t\tfor {\n\t\t\tif err := stub.ServeRequest(); err != nil {\n\t\t\t\tconnectionError, ok := err.(*bindings.ConnectionError)\n\t\t\t\tif !ok || !connectionError.Closed() {\n\t\t\t\t\tlog.Println(err)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()\n}\n\n\n\nfunc (delegate *EchoServerDelegate) Quit() {\n\tfor _, stub := range delegate.stubs {\n\t\tstub.Close()\n\t}\n}\n\n\nfunc MojoMain(handle C.MojoHandle) C.MojoResult {\n\tapplication.Run(&EchoServerDelegate{}, system.MojoHandle(handle))\n\treturn C.MOJO_RESULT_OK\n}\n\nfunc main() {\n\tapp.Run(app.Callbacks{})\n}\n\nfunc (delegate *EchoServerDelegate) AcceptConnection(connection *application.Connection) ", "output": "{\n\tconnection.ProvideServices(&echo.EchoServiceFactory{delegate})\n}"}
{"input": "package sync2\n\n\n\n\n\nimport (\n\t\"time\"\n)\n\n\n\ntype Semaphore struct {\n\tslots   chan struct{}\n\ttimeout time.Duration\n}\n\n\n\nfunc NewSemaphore(count int, timeout time.Duration) *Semaphore {\n\tsem := &Semaphore{\n\t\tslots:   make(chan struct{}, count),\n\t\ttimeout: timeout,\n\t}\n\tfor i := 0; i < count; i++ {\n\t\tsem.slots <- struct{}{}\n\t}\n\treturn sem\n}\n\n\n\nfunc (sem *Semaphore) Acquire() bool {\n\tif sem.timeout == 0 {\n\t\t<-sem.slots\n\t\treturn true\n\t}\n\ttm := time.NewTimer(sem.timeout)\n\tdefer tm.Stop()\n\tselect {\n\tcase <-sem.slots:\n\t\treturn true\n\tcase <-tm.C:\n\t\treturn false\n\t}\n}\n\n\n\n\n\n\nfunc (sem *Semaphore) Release() ", "output": "{\n\tsem.slots <- struct{}{}\n}"}
{"input": "package rss\n\nimport \"testing\"\n\n\n\nfunc TestCheckBoardExist(t *testing.T) ", "output": "{\n\ttype args struct {\n\t\tboard string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\"exist\", args{\"movie\"}, true},\n\t\t{\"exist\", args{\"movies\"}, false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := CheckBoardExist(tt.args.board); got != tt.want {\n\t\t\t\tt.Errorf(\"CheckBoardExist() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"}
{"input": "package memcache\n\nimport (\n\t\"net\"\n)\n\ntype Addr struct {\n\tnet.Addr\n\ts string\n\tn string\n}\n\nfunc (a *Addr) String() string {\n\treturn a.s\n}\n\n\n\nfunc NewAddr(addr net.Addr) *Addr ", "output": "{\n\treturn &Addr{\n\t\tAddr: addr,\n\t\ts:    addr.String(),\n\t\tn:    addr.Network(),\n\t}\n}"}
{"input": "package clier\n\nimport (\n\t\"log\"\n\t\"math\"\n\t\"regexp\"\n)\n\n\ntype HelpFormatter struct {\n\tprog              string\n\tindentIncrement   int\n\tmaxHelpPosition   int\n\twidth             int\n\tcurrentIndent     int\n\tlevel             int\n\tactionMaxLength   int\n\trootSection       *section\n\tcurrentSection    *section\n\twhitespaceMatcher *regexp.Regexp\n\tlongBreakMatcher  *regexp.Regexp\n}\n\n\nfunc NewHelpFormatter(prog string, indentIncrement, maxHelpPosition, width int) *HelpFormatter {\n\thf := &HelpFormatter{}\n\thf.prog = prog\n\thf.indentIncrement = indentIncrement\n\thf.maxHelpPosition = int(math.Min(float64(maxHelpPosition), math.Max(float64(width-20), float64(indentIncrement*2))))\n\thf.width = width\n\thf.currentIndent = 0\n\thf.level = 0\n\thf.actionMaxLength = 0\n\thf.rootSection = &section{}\n\thf.currentSection = hf.rootSection\n\thf.whitespaceMatcher = regexp.MustCompile(`\\s+`)\n\thf.longBreakMatcher = regexp.MustCompile(`\\n\\n\\n+`)\n\n\treturn hf\n}\n\nfunc (h *HelpFormatter) indent() {\n\th.currentIndent += h.indentIncrement\n\th.level++\n}\n\n\n\ntype section struct {\n\tformatter string\n\tparent    string\n\theading   string\n\titems     []item\n}\n\ntype item struct {\n\tfunction func(s string) string\n\targs     []string\n}\n\nfunc newSection(formatter string, parent string, heading string) *section {\n\tvar items []item\n\treturn &section{\n\t\tformatter,\n\t\tparent,\n\t\theading,\n\t\titems,\n\t}\n}\n\nfunc (h *HelpFormatter) dedent() ", "output": "{\n\th.currentIndent -= h.indentIncrement\n\tif h.currentIndent < 0 {\n\t\tlog.Println(\"Indent decreased below 0.\")\n\t}\n\th.level--\n}"}
{"input": "package platform\n\nimport (\n\t\"time\"\n\n\tgopi \"github.com/djthorpe/gopi/v3\"\n\tdarwin \"github.com/djthorpe/gopi/v3/pkg/sys/darwin\"\n)\n\n\n\n\ntype Implementation struct{}\n\n\n\n\nconst (\n\tCPU_TYPE_VAX     = 1\n\tCPU_TYPE_MC680x0 = 6\n\tCPU_TYPE_X86     = 7\n\tCPU_TYPE_MIPS    = 8\n\tCPU_TYPE_MC98000 = 10\n\tCPU_TYPE_HPPA    = 11\n\tCPU_TYPE_ARM     = 12\n\tCPU_TYPE_SPARC   = 14\n\tCPU_TYPE_I860    = 15\n\tCPU_TYPE_ALPHA   = 16\n\tCPU_TYPE_POWERPC = 18\n)\n\n\n\n\nfunc (this *Platform) Type() gopi.PlatformType {\n\tplatform := gopi.PLATFORM_DARWIN\n\tcputype := darwin.CPUType()\n\tcpu64 := darwin.CPU64Bit()\n\tswitch {\n\tcase cputype == CPU_TYPE_X86 && cpu64 == false:\n\t\tplatform = platform | gopi.PLATFORM_X86_32\n\tcase cputype == CPU_TYPE_X86 && cpu64 == true:\n\t\tplatform = platform | gopi.PLATFORM_X86_64\n\t}\n\treturn platform\n}\n\n\n\n\n\nfunc (this *Platform) Uptime() time.Duration {\n\treturn darwin.Uptime()\n}\n\n\nfunc (this *Platform) LoadAverages() (float64, float64, float64) {\n\treturn darwin.LoadAverage()\n}\n\n\nfunc (this *Platform) Product() string {\n\treturn darwin.Product()\n}\n\n\nfunc (this *Platform) TemperatureZones() map[string]float32 {\n\treturn nil\n}\n\nfunc (this *Platform) SerialNumber() string ", "output": "{\n\treturn darwin.SerialNumber()\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n)\n\n\ntype BitbucketNotification struct {\n\tCanonURL   string `json:\"Canon_url\"`\n\tUser       string\n\tRepository BitbucketRepository\n\tTruncated  bool\n\tCommits    []BitbucketCommit\n}\n\ntype BitbucketRepository struct {\n\tAbsoluteURL string `json:\"Absolute_url\"`\n\tFork        bool\n\tIsPrivate   bool `json:\"Is_private\"`\n\tName        string\n\tOwner       string\n\tScm         string\n\tSlug        string\n\tWebsite     string\n}\n\ntype BitbucketCommit struct {\n\tAuthor       string\n\tBranches     []string\n\tBranch       string\n\tFiles        []BitbucketFile\n\tMessage      string\n\tNode         string\n\tParents      []string\n\tRawAuthor    string `json:\"Raw_author\"`\n\tRawNode      string `json:\"Raw_node\"`\n\tRevision     int\n\tSize         int\n\tTimestamp    string\n\tUTCTimestamp string\n}\n\ntype BitbucketFile struct {\n\tFile string\n\tType string\n}\n\nfunc BitbucketParse(r *http.Request) (n Notification, err error) {\n\tr.ParseForm()\n\tpayload := r.Form.Get(\"payload\")\n\n\tlog.Printf(\"Received payload %s\", payload)\n\n\tbytes := []byte(payload)\n\n\treturn bitbucketParseBytes(bytes)\n}\n\nfunc bitbucketParseBytes(bytes []byte) (n BitbucketNotification, err error) {\n\terr = json.Unmarshal(bytes, &n)\n\treturn\n}\n\n\n\nfunc (n BitbucketNotification) Branches() (branches map[string]bool) {\n\tbranches = make(map[string]bool)\n\tfor _, commit := range n.Commits {\n\t\tif commit.Branch != \"\" {\n\t\t\tbranches[commit.Branch] = true\n\t\t}\n\t\tfor _, branch := range commit.Branches {\n\t\t\tbranches[branch] = true\n\t\t}\n\t}\n\treturn\n}\n\nfunc (n BitbucketNotification) RepositoryURL() (repositoryURL string) ", "output": "{\n\trepositoryURL = n.CanonURL + n.Repository.AbsoluteURL\n\tif repositoryURL[len(repositoryURL)-1] == '/' {\n\t\trepositoryURL = repositoryURL[:len(repositoryURL)-1]\n\t}\n\treturn\n}"}
{"input": "package common\n\nimport (\n\t\"time\"\n\n\t\"github.com/hashicorp/packer/helper/communicator\"\n\t\"github.com/hashicorp/packer/template/interpolate\"\n)\n\ntype SSHConfig struct {\n\tComm communicator.Config `mapstructure:\",squash\"`\n\n\tSSHSkipRequestPty bool          `mapstructure:\"ssh_skip_request_pty\"`\n\tSSHWaitTimeout    time.Duration `mapstructure:\"ssh_wait_timeout\"`\n}\n\n\n\nfunc (c *SSHConfig) Prepare(ctx *interpolate.Context) []error ", "output": "{\n\tif c.SSHWaitTimeout != 0 {\n\t\tc.Comm.SSHTimeout = c.SSHWaitTimeout\n\t}\n\tif c.SSHSkipRequestPty {\n\t\tc.Comm.SSHPty = false\n\t}\n\n\treturn c.Comm.Prepare(ctx)\n}"}
{"input": "package main\n\n\ntype HelpBarView struct {\n\thelpRenderer HelpRenderer\n}\n\n\ntype ActionMessage struct {\n\taction  ActionType\n\tmessage string\n}\n\n\nfunc NewHelpBarView(helpRenderer HelpRenderer) *HelpBarView {\n\treturn &HelpBarView{\n\t\thelpRenderer: helpRenderer,\n\t}\n}\n\n\nfunc (helpBarView *HelpBarView) Initialise() (err error) {\n\treturn\n}\n\n\nfunc (helpBarView *HelpBarView) Dispose() {\n\n}\n\n\nfunc (helpBarView *HelpBarView) HandleEvent(event Event) (err error) {\n\treturn\n}\n\n\n\n\n\nfunc (helpBarView *HelpBarView) OnStateChange(viewState ViewState) {\n\n}\n\n\nfunc (helpBarView *HelpBarView) ViewID() ViewID {\n\treturn ViewHelpBar\n}\n\n\nfunc (helpBarView *HelpBarView) Render(win RenderWindow) (err error) {\n\tlineBuilder, err := win.LineBuilder(0, 1)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlineBuilder.Append(\" \")\n\n\treturn helpBarView.helpRenderer.RenderHelpBar(lineBuilder)\n}\n\n\nfunc (helpBarView *HelpBarView) RenderHelpBar(lineBuilder *LineBuilder) (err error) {\n\treturn\n}\n\n\nfunc RenderKeyBindingHelp(viewID ViewID, lineBuilder *LineBuilder, config Config, actionMessages []ActionMessage) {\n\tviewHierarchy := ViewHierarchy{viewID, ViewAll}\n\n\tfor _, actionMessage := range actionMessages {\n\t\tkeystrings := config.KeyStrings(actionMessage.action, viewHierarchy)\n\n\t\tif len(keystrings) > 0 {\n\t\t\tlineBuilder.\n\t\t\t\tAppendWithStyle(CmpHelpbarviewSpecial, \"%v \", keystrings[len(keystrings)-1].keystring).\n\t\t\t\tAppendWithStyle(CmpHelpbarviewNormal, \"%v   \", actionMessage.message)\n\t\t}\n\t}\n}\n\nfunc (helpBarView *HelpBarView) HandleAction(Action) (err error) ", "output": "{\n\treturn\n}"}
{"input": "package controller\n\nimport (\n\t\"github.com/tmacychen/UFG/framework\"\n\t\"github.com/tmacychen/UFG/framework/outer\"\n)\n\ntype AttachableOuter interface {\n\touter.Relayouter\n}\n\ntype Attachable struct {\n\touter    AttachableOuter\n\tonAttach framework.Event\n\tonDetach framework.Event\n\tattached bool\n}\n\n\n\nfunc (a *Attachable) Attached() bool {\n\treturn a.attached\n}\n\nfunc (a *Attachable) Attach() {\n\tif a.attached {\n\t\tpanic(\"Control already attached\")\n\t}\n\ta.attached = true\n\tif a.onAttach != nil {\n\t\ta.onAttach.Fire()\n\t}\n}\n\nfunc (a *Attachable) Detach() {\n\tif !a.attached {\n\t\tpanic(\"Control already detached\")\n\t}\n\ta.attached = false\n\tif a.onDetach != nil {\n\t\ta.onDetach.Fire()\n\t}\n}\n\nfunc (a *Attachable) OnAttach(f func()) framework.EventSubscription {\n\tif a.onAttach == nil {\n\t\ta.onAttach = CreateEvent(func() {})\n\t}\n\treturn a.onAttach.Listen(f)\n}\n\nfunc (a *Attachable) OnDetach(f func()) framework.EventSubscription {\n\tif a.onDetach == nil {\n\t\ta.onDetach = CreateEvent(func() {})\n\t}\n\treturn a.onDetach.Listen(f)\n}\n\nfunc (a *Attachable) Init(outer AttachableOuter) ", "output": "{\n\ta.outer = outer\n}"}
{"input": "package main\n\nimport (\n\t\"C\"\n\n\t\"srcd.works/go-git.v4\"\n)\n\n\nfunc c_Blame_get_Path(b uint64) *C.char {\n\tobj, ok := GetObject(Handle(b))\n\tif !ok {\n\t\treturn nil\n\t}\n\tblame := obj.(*git.BlameResult)\n\treturn C.CString(blame.Path)\n}\n\n\nfunc c_Blame_get_Rev(b uint64) *C.char {\n\tobj, ok := GetObject(Handle(b))\n\tif !ok {\n\t\treturn nil\n\t}\n\tblame := obj.(*git.BlameResult)\n\treturn CBytes(blame.Rev[:])\n}\n\n\n\n\n\nfunc c_Blame_get_Lines_item(b uint64, i int) {\n\tobj, ok := GetObject(Handle(b))\n\tif !ok {\n\t\treturn\n\t}\n\tblame := obj.(*git.BlameResult)\n\tline := blame.Lines[i]\n\t_ = line\n}\n\nfunc c_Blame_get_Lines_len(b uint64) int ", "output": "{\n\tobj, ok := GetObject(Handle(b))\n\tif !ok {\n\t\treturn 0\n\t}\n\tblame := obj.(*git.BlameResult)\n\treturn len(blame.Lines)\n}"}
{"input": "package v1beta3\n\nimport (\n\t\"testing\"\n\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/conversion\"\n)\n\nfunc TestAPItoV1Beta3VolumeSourceConversion(t *testing.T) {\n\tc := conversion.NewConverter()\n\tc.Debug = t\n\n\tif err := c.RegisterConversionFunc(convert_api_VolumeSource_To_v1beta3_VolumeSource); err != nil {\n\t\tt.Fatalf(\"unexpected error %v\", err)\n\t}\n\n\tin := api.VolumeSource{\n\t\tDownwardAPI: &api.DownwardAPIVolumeSource{\n\t\t\tItems: []api.DownwardAPIVolumeFile{\n\t\t\t\t{\n\t\t\t\t\tPath: \"./test/api-to-v1beta3/conversion\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tout := VolumeSource{}\n\n\tif err := c.Convert(&in, &out, 0, nil); err != nil {\n\t\tt.Fatalf(\"unexpected error %v\", err)\n\t}\n\tif e, a := in.DownwardAPI.Items[0].Path, out.Metadata.Items[0].Name; e != a {\n\t\tt.Errorf(\"expected %v, got %v\", e, a)\n\t}\n}\n\n\n\nfunc TestV1Beta3toAPIVolumeSourceConversion(t *testing.T) ", "output": "{\n\tc := conversion.NewConverter()\n\tc.Debug = t\n\n\tif err := c.RegisterConversionFunc(convert_v1beta3_VolumeSource_To_api_VolumeSource); err != nil {\n\t\tt.Fatalf(\"unexpected error %v\", err)\n\t}\n\n\tin := VolumeSource{\n\t\tMetadata: &MetadataVolumeSource{\n\t\t\tItems: []MetadataFile{\n\t\t\t\t{\n\t\t\t\t\tName: \"./test/v1beta3-to-api/conversion\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tout := api.VolumeSource{}\n\n\tif err := c.Convert(&in, &out, 0, nil); err != nil {\n\t\tt.Fatalf(\"unexpected error %v\", err)\n\t}\n\tif e, a := in.Metadata.Items[0].Name, out.DownwardAPI.Items[0].Path; e != a {\n\t\tt.Errorf(\"expected %v, got %v\", e, a)\n\t}\n}"}
{"input": "package service\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\n\t\"gopkg.in/check.v1\"\n)\n\nfunc (s *S) TestPlan(c *check.C) {\n\tplan := Plan{\n\t\tName:        \"Ignite\",\n\t\tDescription: \"A simple plan\",\n\t}\n\tc.Assert(\"Ignite\", check.Equals, plan.Name)\n\tc.Assert(\"A simple plan\", check.Equals, plan.Description)\n}\n\nfunc (s *S) TestGetPlansByServiceName(c *check.C) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tcontent := `[{\"name\": \"ignite\", \"description\": \"some value\"}, {\"name\": \"small\", \"description\": \"not space left for you\"}]`\n\t\tw.Write([]byte(content))\n\t}))\n\tdefer ts.Close()\n\tsrvc := Service{Name: \"mysql\", Endpoint: map[string]string{\"production\": ts.URL}}\n\terr := s.conn.Services().Insert(&srvc)\n\tc.Assert(err, check.IsNil)\n\tdefer s.conn.Services().RemoveId(srvc.Name)\n\tplans, err := GetPlansByServiceName(\"mysql\")\n\tc.Assert(err, check.IsNil)\n\texpected := []Plan{\n\t\t{Name: \"ignite\", Description: \"some value\"},\n\t\t{Name: \"small\", Description: \"not space left for you\"},\n\t}\n\tc.Assert(plans, check.DeepEquals, expected)\n}\n\n\n\nfunc (s *S) TestGetPlansByServiceNameWithoutEndpoint(c *check.C) ", "output": "{\n\tsrvc := Service{Name: \"mysql\"}\n\terr := s.conn.Services().Insert(&srvc)\n\tc.Assert(err, check.IsNil)\n\tdefer s.conn.Services().RemoveId(srvc.Name)\n\tplans, err := GetPlansByServiceName(\"mysql\")\n\tc.Assert(err, check.IsNil)\n\texpected := []Plan{}\n\tc.Assert(plans, check.DeepEquals, expected)\n}"}
{"input": "package commands\n\nimport (\n\t\"gate/core/errors\"\n)\n\nimport (\n\t\"fmt\"\n)\n\ntype cmd_save cmd\n\nvar _ Command = &cmd_save{}\n\nfunc (self *cmd_save) Name() string {\n\treturn \"save\"\n}\n\nfunc (self *cmd_save) Run(line []string) (err error) {\n\tvar remoteName string\n\tif len(line) > 1 {\n\t\tremoteName = line[1]\n\t} else {\n\t\tremoteName = \"\"\n\t}\n\n\tremote, err := self.remoter.Remote(remoteName)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tvault_path, err := self.config.VaultPath()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tvar saved bool\n\terr = self.server.Save(true, &saved)\n\tif err != nil {\n\t\treturn\n\t}\n\tif !saved {\n\t\terr = errors.Newf(\"Could not save vault\")\n\t\treturn\n\t}\n\n\terr = remote.SaveVault(vault_path)\n\n\treturn\n}\n\nfunc (self *cmd_save) Complete(line []string) (result []string, err error) {\n\treturn\n}\n\n\n\nfunc (self *cmd_save) Help(line []string) (result string, err error) ", "output": "{\n\tvar remote_note string\n\tif len(line) == 1 {\n\t\tremote_note = \"the \u001b[1mremote note\u001b[0m above\"\n\t} else {\n\t\tremote_note = \"note perusing \u001b[1mhelp remote\u001b[0m\"\n\t}\n\n\tresult = fmt.Sprintf(`\n\u001b[33msave [remote]\u001b[0m      Save the password vault upto the server.\n\t\t   \u001b[33m[remote]\u001b[0m: see %s\n`,\n\t\tremote_note,\n\t)\n\n\treturn\n}"}
{"input": "package rpc\n\nimport (\n\t\"github.com/Cepave/open-falcon-backend/common/model\"\n\t\"github.com/Cepave/open-falcon-backend/modules/judge/g\"\n\t\"github.com/Cepave/open-falcon-backend/modules/judge/store\"\n\t\"time\"\n)\n\ntype Judge int\n\nfunc (this *Judge) Ping(req model.NullRpcRequest, resp *model.SimpleRpcResponse) error {\n\treturn nil\n}\n\n\n\nfunc (this *Judge) Send(items []*model.JudgeItem, resp *model.SimpleRpcResponse) error ", "output": "{\n\tremain := g.Config().Remain\n\tnow := time.Now().Unix()\n\tfor _, item := range items {\n\t\tpk := item.PrimaryKey()\n\t\tstore.HistoryBigMap[pk[0:2]].PushFrontAndMaintain(pk, item, remain, now)\n\t}\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{} \nfunc Echo(w http.ResponseWriter, r *http.Request) {\n\tws, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Print(\"upgrade:\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"start websocket!\")\n\tsession := NewSession(ws)\n\tdefer func() {\n\t\tDelSession(session)\n\t\tfmt.Println(\"close websocket!\")\n\t}()\n\tgo session.Send()\n\tsession.handler()\n}\n\n\n\nfunc main() {\n\thttp.HandleFunc(\"/\", index)\n\thttp.HandleFunc(\"/echo\", Echo)\n\tgo NotifyClient()\n\tif err := http.ListenAndServe(\":1234\", nil); err != nil {\n\t\tlog.Fatal(\"ListenAndServe:\", err)\n\t}\n}\n\nfunc index(w http.ResponseWriter, res *http.Request) ", "output": "{\n\tt, _ := template.ParseFiles(\"index.html\")\n\tt.Execute(w, nil)\n}"}
{"input": "package main\n\nimport (\n\t\"os\"\n\n\tadapter \"istio.io/mixer/adapter\"\n\t\"istio.io/mixer/cmd/server/cmd\"\n\t\"istio.io/mixer/cmd/shared\"\n\tadptr \"istio.io/mixer/pkg/adapter\"\n\t\"istio.io/mixer/pkg/template\"\n\tgeneratedTmplRepo \"istio.io/mixer/template\"\n)\n\n\n\nfunc supportedAdapters() []adptr.InfoFn {\n\treturn adapter.Inventory()\n}\n\nfunc supportedLegacyAdapters() []adptr.RegisterFn {\n\treturn adapter.InventoryLegacy()\n}\n\nfunc main() {\n\trootCmd := cmd.GetRootCmd(os.Args[1:], supportedTemplates(), supportedAdapters(), supportedLegacyAdapters(), shared.Printf, shared.Fatalf)\n\n\tif err := rootCmd.Execute(); err != nil {\n\t\tos.Exit(-1)\n\t}\n}\n\nfunc supportedTemplates() map[string]template.Info ", "output": "{\n\treturn generatedTmplRepo.SupportedTmplInfo\n}"}
{"input": "package docker\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/Sirupsen/logrus\"\n\t\"github.com/zendesk/hyperclair/docker/httpclient\"\n\t\"github.com/zendesk/hyperclair/xerrors\"\n)\n\n\n\n\nfunc Login(registry string) (bool, error) ", "output": "{\n\n\tlogrus.Info(\"log in: \", registry)\n\n\tclient := httpclient.Get()\n\trequest, err := http.NewRequest(\"GET\", registry, nil)\n\tresponse, err := client.Do(request)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"log in %v: %v\", registry, err)\n\t}\n\tauthorized := response.StatusCode != http.StatusUnauthorized\n\tif !authorized {\n\t\tlogrus.Info(\"Unauthorized access\")\n\t\terr := AuthenticateResponse(response, request)\n\n\t\tif err != nil {\n\t\t\tif err == xerrors.Unauthorized {\n\t\t\t\tauthorized = false\n\t\t\t}\n\t\t\treturn false, err\n\t\t} else {\n\t\t\tauthorized = true\n\t\t}\n\t}\n\n\treturn authorized, nil\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\t\"text/template\"\n)\n\nfunc init() {\n\thttp.Handle(\"/view\", appHandler(viewRecord))\n}\n\n\n\nfunc viewRecord(w http.ResponseWriter, r *http.Request) error {\n\tc := appengine.NewContext(r)\n\tkey := datastore.NewKey(c, \"Record\", r.FormValue(\"id\"), 0, nil)\n\trecord := new(Record)\n\tif err := datastore.Get(c, key, record); err != nil {\n\t\treturn err\n\t}\n\treturn viewTemplate.Execute(w, record)\n}\n\n\n\ntype appHandler func(http.ResponseWriter, *http.Request) error\n\nfunc (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif err := fn(w, r); err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t}\n}\n\n\n\ntype ap struct{}\n\nfunc (ap) NewContext(*http.Request) *ctx { return nil }\n\ntype ctx struct{}\n\nfunc (*ctx) Errorf(string, ...interface{}) {}\n\nvar appengine ap\n\ntype ds struct{}\n\n\nfunc (ds) Get(*ctx, string, *Record) error               { return nil }\n\nvar datastore ds\n\ntype Record struct{}\n\nvar viewTemplate *template.Template\n\nfunc main() {}\n\nfunc (ds) NewKey(*ctx, string, string, int, *int) string ", "output": "{ return \"\" }"}
{"input": "package golf\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestInt(t *testing.T) {\n\tf := Fore(\"hero\", 3)\n\tassertMapLen(t, f, 1)\n\tassertKeyEquals(t, f, \"hero\", 3)\n}\n\nfunc TestString(t *testing.T) {\n\tf := Fore(\"hero\", \"three\")\n\tassertMapLen(t, f, 1)\n\tassertKeyEquals(t, f, \"hero\", \"three\")\n}\n\nfunc TestStringThatGolfs(t *testing.T) {\n\ts := StringThatGolfs(\"three\")\n\tf := Fore(\"hero\", &s)\n\tt.Log(f)\n\tassertMapLen(t, f, 1)\n\tassertKeyEquals(t, f, \"hero.golfer\", \"three three\")\n}\n\nfunc TestNil(t *testing.T) {\n\tf := Fore(\"hero\", nil)\n\tif f != nil {\n\t\tt.Fatal(\"not nil\")\n\t}\n}\n\nfunc TestStructPointer(t *testing.T) {\n\tf := Fore(\"test\", &StructWithPointer{Foo: &FooStruct{Bar: \"value\"}})\n\tassertMapLen(t, f, 1)\n\tassertKeyEquals(t, f, \"test.foo.Bar\", \"value\")\n}\n\n\n\ntype StringThatGolfs string\n\nfunc (s *StringThatGolfs) GolfExportedFields() map[string]interface{} {\n\treturn map[string]interface{}{\"golfer\": fmt.Sprintf(\"%s %s\", *s, *s)}\n}\n\ntype FooStruct struct {\n\tBar string\n}\n\ntype StructWithPointer struct {\n\tFoo *FooStruct `golf:\"foo\"`\n}\n\ntype StructWithoutPointer struct {\n\tFoo FooStruct `golf:\"foo\"`\n}\n\nfunc TestStructNonPointer(t *testing.T) ", "output": "{\n\tf := Fore(\"test\", &StructWithoutPointer{Foo: FooStruct{Bar: \"value\"}})\n\tassertMapLen(t, f, 1)\n\tassertKeyEquals(t, f, \"test.foo.Bar\", \"value\")\n}"}
{"input": "package common\n\nimport \"math/big\"\n\ntype _N_ [_S_]byte\n\nfunc BytesTo_N_(b []byte) _N_ {\n\tvar h _N_\n\th.SetBytes(b)\n\treturn h\n}\nfunc StringTo_N_(s string) _N_ { return BytesTo_N_([]byte(s)) }\nfunc BigTo_N_(b *big.Int) _N_  { return BytesTo_N_(b.Bytes()) }\nfunc HexTo_N_(s string) _N_    { return BytesTo_N_(FromHex(s)) }\n\n\n\n\nfunc (h _N_) Str() string   { return string(h[:]) }\n\nfunc (h _N_) Big() *big.Int { return Bytes2Big(h[:]) }\nfunc (h _N_) Hex() string   { return \"0x\" + Bytes2Hex(h[:]) }\n\n\nfunc (h *_N_) SetBytes(b []byte) {\n\tif len(b) > len(h) {\n\t\tb = b[len(b)-_S_:]\n\t}\n\n\tfor i := len(b) - 1; i >= 0; i-- {\n\t\th[_S_-len(b)+i] = b[i]\n\t}\n}\n\n\nfunc (h *_N_) SetString(s string) { h.SetBytes([]byte(s)) }\n\n\nfunc (h *_N_) Set(other _N_) {\n\tfor i, v := range other {\n\t\th[i] = v\n\t}\n}\n\nfunc (h _N_) Bytes() []byte ", "output": "{ return h[:] }"}
{"input": "package markdown\n\nimport (\n\t\"bufio\"\n\t\"io\"\n)\n\ntype writer interface {\n\tWrite([]byte) (int, error)\n\tWriteByte(byte) error\n\tWriteString(string) (int, error)\n\tFlush() error\n}\n\ntype monadicWriter struct {\n\twriter\n\terr error\n}\n\nfunc newMonadicWriter(w io.Writer) *monadicWriter {\n\tif w, ok := w.(writer); ok {\n\t\treturn &monadicWriter{writer: w}\n\t}\n\treturn &monadicWriter{writer: bufio.NewWriter(w)}\n}\n\nfunc (w *monadicWriter) Write(p []byte) (n int, err error) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\n\tn, err = w.writer.Write(p)\n\tw.err = err\n\treturn\n}\n\nfunc (w *monadicWriter) WriteByte(b byte) (err error) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\n\terr = w.writer.WriteByte(b)\n\tw.err = err\n\treturn\n}\n\n\n\nfunc (w *monadicWriter) Flush() (err error) {\n\tif w.err != nil {\n\t\treturn\n\t}\n\n\terr = w.writer.Flush()\n\tw.err = err\n\treturn\n}\n\nfunc (w *monadicWriter) WriteString(s string) (n int, err error) ", "output": "{\n\tif w.err != nil {\n\t\treturn\n\t}\n\n\tn, err = w.writer.WriteString(s)\n\tw.err = err\n\treturn\n}"}
{"input": "package vfs \n\nimport \"github.com/docker/docker/quota\"\n\ntype driverQuota struct {\n}\n\nfunc setupDriverQuota(driver *Driver) error {\n\treturn nil\n}\n\nfunc (d *Driver) setQuotaOpt(size uint64) error {\n\treturn quota.ErrQuotaNotSupported\n}\n\n\n\nfunc (d *Driver) setupQuota(dir string, size uint64) error {\n\treturn quota.ErrQuotaNotSupported\n}\n\nfunc (d *Driver) quotaSupported() bool {\n\treturn false\n}\n\nfunc (d *Driver) getQuotaOpt() uint64 ", "output": "{\n\treturn 0\n}"}
{"input": "package cacheval\n\nimport (\n\t\"math/rand\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestInt32Stress(t *testing.T) {\n\tconst valid = 10 * time.Millisecond\n\tconst delay = 1 * time.Millisecond\n\tconst concurrency = 50\n\tconst N = 500\n\n\tcv := Int32{}\n\tcv.Init(valid)\n\n\twg := sync.WaitGroup{}\n\twg.Add(concurrency)\n\tpassive := func() {\n\t\tmax := int32(0)\n\t\tfor j := 1; j <= N; j++ {\n\t\t\tv, ok := cv.GetFresh()\n\t\t\tif v > max {\n\t\t\t\tmax = v\n\t\t\t} else if ok && v < max {\n\t\t\t\tt.Error(\"unexpected decrease\")\n\t\t\t}\n\t\t\ttime.Sleep(delay)\n\t\t}\n\t\twg.Done()\n\t}\n\tfor i := 1; i <= concurrency; i++ {\n\t\tgo passive()\n\t}\n\tfor j := 1; j <= N; j++ {\n\t\tprev := cv.Get()\n\t\tcv.GetOrUpdate(func() { cv.Set(prev + 1) })\n\t\ttime.Sleep(delay)\n\t}\n\twg.Wait()\n}\n\nfunc TestInt32Valid(t *testing.T) ", "output": "{\n\tt.Parallel()\n\n\trand := rand.New(rand.NewSource(time.Now().UnixNano()))\n\tconst valid = 100 * time.Millisecond\n\n\tcv := Int32{}\n\tcv.Init(valid)\n\n\tassert.Equal(t, int32(0), cv.Get())\n\tv, ok := cv.GetFresh()\n\tassert.Equal(t, int32(0), v)\n\tassert.Equal(t, false, ok)\n\n\texpect := int32(rand.Uint32())\n\tcv.Set(expect)\n\tv, ok = cv.GetFresh()\n\tassert.Equal(t, expect, v)\n\tassert.Equal(t, true, ok)\n\n\ttime.Sleep(valid)\n\tv = cv.GetOrUpdate(func() { cv.Set(expect + 1) })\n\tassert.Equal(t, expect+1, v)\n\tassert.Equal(t, expect+1, cv.Get())\n}"}
{"input": "package fake\n\nimport (\n\tv1 \"k8s.io/client-go/kubernetes/typed/apps/v1\"\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n)\n\ntype FakeAppsV1 struct {\n\t*testing.Fake\n}\n\n\n\nfunc (c *FakeAppsV1) DaemonSets(namespace string) v1.DaemonSetInterface {\n\treturn &FakeDaemonSets{c, namespace}\n}\n\nfunc (c *FakeAppsV1) Deployments(namespace string) v1.DeploymentInterface {\n\treturn &FakeDeployments{c, namespace}\n}\n\nfunc (c *FakeAppsV1) ReplicaSets(namespace string) v1.ReplicaSetInterface {\n\treturn &FakeReplicaSets{c, namespace}\n}\n\nfunc (c *FakeAppsV1) StatefulSets(namespace string) v1.StatefulSetInterface {\n\treturn &FakeStatefulSets{c, namespace}\n}\n\n\n\nfunc (c *FakeAppsV1) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakeAppsV1) ControllerRevisions(namespace string) v1.ControllerRevisionInterface ", "output": "{\n\treturn &FakeControllerRevisions{c, namespace}\n}"}
{"input": "package config\n\nimport (\n\tlog \"github.com/Sirupsen/logrus\"\n\t_ \"github.com/confur-me/confur-api/lib/logrus\"\n\tcfg \"github.com/olebedev/config\"\n)\n\nvar c *cfg.Config\n\nfunc init() {\n\tc = new(cfg.Config)\n}\n\nfunc Read(path string) error {\n\tlog.Info(\"Reading configuration from \", path)\n\tvar err error\n\tc, err = cfg.ParseYamlFile(path)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\treturn err\n}\n\n\n\nfunc Config() *cfg.Config ", "output": "{\n\treturn c\n}"}
{"input": "package fake\n\nimport (\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n\tv1beta1 \"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/apps/v1beta1\"\n)\n\ntype FakeAppsV1beta1 struct {\n\t*testing.Fake\n}\n\nfunc (c *FakeAppsV1beta1) ControllerRevisions(namespace string) v1beta1.ControllerRevisionInterface {\n\treturn &FakeControllerRevisions{c, namespace}\n}\n\n\n\nfunc (c *FakeAppsV1beta1) Scales(namespace string) v1beta1.ScaleInterface {\n\treturn &FakeScales{c, namespace}\n}\n\nfunc (c *FakeAppsV1beta1) StatefulSets(namespace string) v1beta1.StatefulSetInterface {\n\treturn &FakeStatefulSets{c, namespace}\n}\n\n\n\nfunc (c *FakeAppsV1beta1) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakeAppsV1beta1) Deployments(namespace string) v1beta1.DeploymentInterface ", "output": "{\n\treturn &FakeDeployments{c, namespace}\n}"}
{"input": "package devops\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype AutomatedDeployStageRollbackPolicy struct {\n}\n\n\n\n\nfunc (m AutomatedDeployStageRollbackPolicy) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeAutomatedDeployStageRollbackPolicy AutomatedDeployStageRollbackPolicy\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"policyType\"`\n\t\tMarshalTypeAutomatedDeployStageRollbackPolicy\n\t}{\n\t\t\"AUTOMATED_STAGE_ROLLBACK_POLICY\",\n\t\t(MarshalTypeAutomatedDeployStageRollbackPolicy)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\n\nfunc (m AutomatedDeployStageRollbackPolicy) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package main\n\ntype WireCollection map[string]*Wire\n\nvar cache = map[string]int{}\n\nfunc NewWireCollection() WireCollection {\n\treturn make(WireCollection)\n}\n\n\n\nfunc (collection WireCollection) EvaluateWireValue(wireName string) int ", "output": "{\n\tif value, ok := cache[wireName]; ok {\n\t\treturn value\n\t}\n\n\tresult := collection[wireName].Evaluate(collection)\n\tcache[wireName] = result\n\treturn result\n}"}
{"input": "package lang\n\nimport (\n\t. \"github.com/zxh0/jvm.go/jvmgo/any\"\n\t\"github.com/zxh0/jvm.go/jvmgo/jvm/rtda\"\n\trtc \"github.com/zxh0/jvm.go/jvmgo/jvm/rtda/class\"\n)\n\n\n\nfunc _string(method Any, name, desc string) {\n\trtc.RegisterNativeMethod(\"java/lang/String\", name, desc, method)\n}\n\n\n\nfunc intern(frame *rtda.Frame) {\n\tvars := frame.LocalVars()\n\tstr := vars.GetRef(0) \n\n\tchars := rtda.JStringChars(str)\n\tinternedStr := rtda.InternString(chars, str)\n\tstack := frame.OperandStack()\n\tstack.PushRef(internedStr)\n}\n\nfunc init() ", "output": "{\n\t_string(intern, \"intern\", \"()Ljava/lang/String;\")\n}"}
{"input": "package mathutil\n\n\nvar EPSILON float32 = 0.00000001\n\n\nfunc FloatEquals(a, b float32) bool {\n\tif (a-b) < EPSILON && (b-a) < EPSILON {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\nvar EPSILON64 = 0.00000001\n\n\nfunc Float64Equals(a, b float64) bool {\n\tif (a-b) < EPSILON64 && (b-a) < EPSILON64 {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\nfunc Min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\tif b < a {\n\t\treturn b\n\t}\n\treturn a\n}\n\n\n\n\n\nfunc IntersectInt64(as, bs []int64) []int64 {\n\ti := make([]int64, 0, Max(len(as), len(bs)))\n\tfor _, a := range as {\n\t\tfor _, b := range bs {\n\t\t\tif a == b {\n\t\t\t\ti = append(i, a)\n\t\t\t}\n\t\t}\n\t}\n\treturn i\n}\n\nfunc Max(a, b int) int ", "output": "{\n\tif a > b {\n\t\treturn a\n\t}\n\tif b > a {\n\t\treturn b\n\t}\n\treturn a\n}"}
{"input": "package set\n\nimport (\n\tR \"github.com/andreasstrack/util/reflect\"\n)\n\ntype Set struct {\n\tcontent map[interface{}]bool\n}\n\nfunc NewSet() (*Set, error) {\n\ts := &Set{}\n\ts.content = make(map[interface{}]bool)\n\treturn s, nil\n}\n\nfunc NewSetFromSlice(slice interface{}) (*Set, error) {\n\tvar err error\n\tvar sliceOfInterface *[]interface{}\n\tvar s *Set\n\n\tif sliceOfInterface, err = R.GetSlice(slice); err != nil {\n\t\treturn nil, err\n\t}\n\tif s, err = NewSet(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i := range *sliceOfInterface {\n\t\ts.Insert((*sliceOfInterface)[i])\n\t}\n\treturn s, nil\n}\n\nfunc (s *Set) Insert(v interface{}) {\n\ts.content[v] = true\n}\n\n\n\nfunc (s Set) Contains(v interface{}) bool {\n\t_, found := s.content[v]\n\treturn found\n}\n\nfunc (s Set) Size() int {\n\treturn len(s.content)\n}\n\nfunc (s Set) IsEmpty() bool {\n\treturn s.Size() == 0\n}\n\nfunc (s *Set) Remove(v interface{}) ", "output": "{\n\tdelete(s.content, v)\n}"}
{"input": "package shell\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/chrislusf/seaweedfs/weed/pb\"\n\t\"io\"\n\n\t\"github.com/chrislusf/seaweedfs/weed/storage/needle\"\n)\n\nfunc init() {\n\tCommands = append(Commands, &commandVolumeMark{})\n}\n\ntype commandVolumeMark struct {\n}\n\nfunc (c *commandVolumeMark) Name() string {\n\treturn \"volume.mark\"\n}\n\n\n\nfunc (c *commandVolumeMark) Do(args []string, commandEnv *CommandEnv, writer io.Writer) (err error) {\n\n\tvolMarkCommand := flag.NewFlagSet(c.Name(), flag.ContinueOnError)\n\tvolumeIdInt := volMarkCommand.Int(\"volumeId\", 0, \"the volume id\")\n\tnodeStr := volMarkCommand.String(\"node\", \"\", \"the volume server <host>:<port>\")\n\twritable := volMarkCommand.Bool(\"writable\", false, \"volume mark writable\")\n\treadonly := volMarkCommand.Bool(\"readonly\", false, \"volume mark readonly\")\n\tif err = volMarkCommand.Parse(args); err != nil {\n\t\treturn nil\n\t}\n\tmarkWritable := false\n\tif (*writable && *readonly) || (!*writable && !*readonly) {\n\t\treturn fmt.Errorf(\"use -readonly or -writable\")\n\t} else if *writable {\n\t\tmarkWritable = true\n\t}\n\n\tif err = commandEnv.confirmIsLocked(args); err != nil {\n\t\treturn\n\t}\n\n\tsourceVolumeServer := pb.ServerAddress(*nodeStr)\n\n\tvolumeId := needle.VolumeId(*volumeIdInt)\n\n\treturn markVolumeWritable(commandEnv.option.GrpcDialOption, volumeId, sourceVolumeServer, markWritable)\n}\n\nfunc (c *commandVolumeMark) Help() string ", "output": "{\n\treturn `Mark volume writable or readonly from one volume server\n\n\tvolume.mark -node <volume server host:port> -volumeId <volume id> -writable or -readonly\n`\n}"}
{"input": "package otlptracegrpc \n\nimport (\n\t\"context\"\n\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace\"\n)\n\n\nfunc New(ctx context.Context, opts ...Option) (*otlptrace.Exporter, error) {\n\treturn otlptrace.New(ctx, NewClient(opts...))\n}\n\n\n\n\nfunc NewUnstarted(opts ...Option) *otlptrace.Exporter ", "output": "{\n\treturn otlptrace.NewUnstarted(NewClient(opts...))\n}"}
{"input": "package dml_test\n\nimport (\n\t\"encoding/xml\"\n\t\"testing\"\n\n\t\"baliance.com/gooxml/schema/soo/dml\"\n)\n\nfunc TestCT_Scale2DConstructor(t *testing.T) {\n\tv := dml.NewCT_Scale2D()\n\tif v == nil {\n\t\tt.Errorf(\"dml.NewCT_Scale2D must return a non-nil value\")\n\t}\n\tif err := v.Validate(); err != nil {\n\t\tt.Errorf(\"newly constructed dml.CT_Scale2D should validate: %s\", err)\n\t}\n}\n\n\n\nfunc TestCT_Scale2DMarshalUnmarshal(t *testing.T) ", "output": "{\n\tv := dml.NewCT_Scale2D()\n\tbuf, _ := xml.Marshal(v)\n\tv2 := dml.NewCT_Scale2D()\n\txml.Unmarshal(buf, v2)\n}"}
{"input": "package base\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\n\t\"gopkg.in/mgo.v2\"\n)\n\nvar dbSessions = make(map[*http.Request]map[string]interface{})\nvar dbSessionsLock sync.RWMutex\n\nfunc SetVar(r *http.Request, key string, val interface{}) {\n\tdbSessionsLock.Lock()\n\tif dbSessions == nil {\n\t\tdbSessions = map[*http.Request]map[string]interface{}{}\n\t}\n\tif dbSessions[r] == nil {\n\t\tdbSessions[r] = make(map[string]interface{})\n\t}\n\tdbSessions[r][key] = val\n\tdbSessionsLock.Unlock()\n}\n\n\n\nfunc RemoveVars(r *http.Request) {\n\tdbSessionsLock.Lock()\n\tdelete(dbSessions, r)\n\tdbSessionsLock.Unlock()\n}\nfunc DbSession(db *mgo.Session, next http.HandlerFunc) http.HandlerFunc {\n\treturn func(rw http.ResponseWriter, r *http.Request) {\n\t\tthisDb := db.Copy()\n\t\tdefer thisDb.Close()\n\t\tSetVar(r, \"db\", thisDb)\n\t\tnext(rw, r)\n\n\t}\n}\n\nfunc GetVar(r *http.Request, key string) interface{} ", "output": "{\n\tdbSessionsLock.Lock()\n\tval := dbSessions[r][key]\n\tdbSessionsLock.Unlock()\n\treturn val\n}"}
{"input": "package experiments\n\n\n\ntype Experiment string\n\n\n\n\n\n\n\n\n\nconst (\n\tVariableValidation             = Experiment(\"variable_validation\")\n\tModuleVariableOptionalAttrs    = Experiment(\"module_variable_optional_attrs\")\n\tSuppressProviderSensitiveAttrs = Experiment(\"provider_sensitive_attrs\")\n\tConfigDrivenMove               = Experiment(\"config_driven_move\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc GetCurrent(name string) (Experiment, error) {\n\texp := Experiment(name)\n\tif currentExperiments.Has(exp) {\n\t\treturn exp, nil\n\t}\n\n\tif msg, concluded := concludedExperiments[exp]; concluded {\n\t\treturn Experiment(\"\"), ConcludedError{ExperimentName: name, Message: msg}\n\t}\n\n\treturn Experiment(\"\"), UnavailableError{ExperimentName: name}\n}\n\n\n\nfunc (e Experiment) Keyword() string {\n\treturn string(e)\n}\n\n\n\nfunc (e Experiment) IsCurrent() bool {\n\treturn currentExperiments.Has(e)\n}\n\n\nfunc (e Experiment) IsConcluded() bool {\n\t_, exists := concludedExperiments[e]\n\treturn exists\n}\n\n\n\n\n\nvar currentExperiments = make(Set)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar concludedExperiments = make(map[Experiment]string)\n\nfunc registerCurrentExperiment(exp Experiment) {\n\tcurrentExperiments.Add(exp)\n}\n\nfunc registerConcludedExperiment(exp Experiment, message string) {\n\tconcludedExperiments[exp] = message\n}\n\nfunc init() ", "output": "{\n\tregisterConcludedExperiment(VariableValidation, \"Custom variable validation can now be used by default, without enabling an experiment.\")\n\tregisterConcludedExperiment(SuppressProviderSensitiveAttrs, \"Provider-defined sensitive attributes are now redacted by default, without enabling an experiment.\")\n\tregisterCurrentExperiment(ModuleVariableOptionalAttrs)\n\tregisterCurrentExperiment(ConfigDrivenMove)\n}"}
{"input": "package minicon\n\nimport \"container/ring\"\n\n\n\n\ntype History struct {\n\tr *ring.Ring\n}\n\n\n\n\ntype HistoryMarker *ring.Ring\n\n\n\n\nfunc NewHistory(capacity int) *History {\n\treturn &History{ring.New(capacity)}\n}\n\n\n\n\n\n\nfunc (hs *History) Add(s string, mark HistoryMarker) HistoryMarker {\n\ths.Restore(mark)\n\tif s != \"\" && hs.r.Value != s {\n\t\ths.r.Value = s\n\t\ths.r = hs.r.Next()\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc (hs *History) Back() (string, bool) {\n\treturn hs._update(hs.r.Prev())\n}\n\n\n\n\n\nfunc (hs *History) Forward() (string, bool) {\n\treturn hs._update(hs.r.Next())\n}\n\n\n\n\n\n\n\n\n\nfunc (hs *History) Restore(mark HistoryMarker) {\n\tif mark != nil {\n\t\ths.r = mark\n\t}\n}\n\n\n\n\nfunc (hs *History) _update(r *ring.Ring) (ret string, okay bool) {\n\tif s, ok := r.Value.(string); ok && s != \"\" {\n\t\ths.r = r\n\t\tret, okay = s, ok\n\t}\n\treturn ret, okay\n}\n\nfunc (hs *History) Mark() HistoryMarker ", "output": "{\n\treturn hs.r\n}"}
{"input": "package file\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\ntype Reader interface {\n\tio.Reader\n\tio.ReaderAt\n\tio.Seeker\n}\n\ntype Writer interface {\n\tio.Writer\n\tio.Seeker\n\tTruncate(size int64) error\n\tSync() error\n}\n\ntype ReadCloser interface {\n\tReader\n\tio.Closer\n}\n\ntype WriteCloser interface {\n\tWriter\n\tio.Closer\n}\n\ntype File interface {\n\tio.Reader\n\tio.Writer\n\tio.Seeker\n\tio.Closer\n\tio.ReaderAt\n\tTruncate(size int64) error\n\tSync() error\n}\n\n\ntype FileSystem interface {\n\tOpen(name string, flag int) (File, error)\n\n\tLock(name string) (io.Closer, error)\n\n\tExists(name string) bool\n\n\tMkdirAll(path string) error\n\n\tList(dir string) ([]string, error)\n\n\tRemove(filename string) error\n\n\tRename(oldpath, newpath string) error\n}\n\ntype osFileSystem struct{}\n\nfunc (osFileSystem) Open(name string, flag int) (File, error) {\n\treturn os.OpenFile(name, flag, 0666)\n}\n\n\n\nfunc (osFileSystem) Exists(name string) bool {\n\t_, err := os.Stat(name)\n\treturn err == nil\n}\n\nfunc (osFileSystem) List(dir string) ([]string, error) {\n\tf, err := os.Open(dir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn f.Readdirnames(-1)\n}\n\nfunc (osFileSystem) Remove(name string) error {\n\treturn os.Remove(name)\n}\n\nfunc (osFileSystem) Rename(oldpath, newpath string) error {\n\treturn os.Rename(oldpath, newpath)\n}\n\nvar DefaultFileSystem FileSystem = osFileSystem{}\n\nfunc (osFileSystem) MkdirAll(path string) error ", "output": "{\n\treturn os.MkdirAll(path, 0740)\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/kataras/iris/v12/_examples/mvc/vuejs-todo-mvc/src/todo\"\n\n\t\"github.com/kataras/iris/v12\"\n\t\"github.com/kataras/iris/v12/mvc\"\n\t\"github.com/kataras/iris/v12/sessions\"\n\t\"github.com/kataras/iris/v12/websocket\"\n)\n\n\ntype TodoController struct {\n\tService todo.Service\n\n\tSession *sessions.Session\n\n\tNS *websocket.NSConn\n}\n\n\n\n\n\nfunc (c *TodoController) BeforeActivation(b mvc.BeforeActivation) {\n\tb.Dependencies().Register(func(ctx iris.Context) (items []todo.Item) {\n\t\tctx.ReadJSON(&items)\n\t\treturn\n\t}) \n}\n\n\n\n\n\n\ntype PostItemResponse struct {\n\tSuccess bool `json:\"success\"`\n}\n\nvar emptyResponse = PostItemResponse{Success: false}\n\n\nfunc (c *TodoController) Post(newItems []todo.Item) PostItemResponse {\n\tif err := c.Service.Save(c.Session.ID(), newItems); err != nil {\n\t\treturn emptyResponse\n\t}\n\n\treturn PostItemResponse{Success: true}\n}\n\nfunc (c *TodoController) Save(msg websocket.Message) error {\n\tid := c.Session.ID()\n\tc.NS.Conn.Server().Broadcast(nil, websocket.Message{\n\t\tNamespace: msg.Namespace,\n\t\tEvent:     \"saved\",\n\t\tTo:        id,\n\t\tBody:      websocket.Marshal(c.Service.Get(id)),\n\t})\n\n\treturn nil\n}\n\nfunc (c *TodoController) Get() []todo.Item ", "output": "{\n\treturn c.Service.Get(c.Session.ID())\n}"}
{"input": "package config\n\nimport (\n\tlog \"github.com/Sirupsen/logrus\"\n\t_ \"github.com/confur-me/confur-api/lib/logrus\"\n\tcfg \"github.com/olebedev/config\"\n)\n\nvar c *cfg.Config\n\n\n\nfunc Read(path string) error {\n\tlog.Info(\"Reading configuration from \", path)\n\tvar err error\n\tc, err = cfg.ParseYamlFile(path)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\treturn err\n}\n\nfunc Config() *cfg.Config {\n\treturn c\n}\n\nfunc init() ", "output": "{\n\tc = new(cfg.Config)\n}"}
{"input": "package helper\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n)\n\nimport (\n\t\"cfg\"\n)\n\nvar (\n\t_debug_open bool\n)\n\nfunc init() {\n\tconfig := cfg.Get()\n\tif config[\"debug\"] == \"true\" {\n\t\t_debug_open = true\n\t}\n}\n\n\nfunc ERR(v ...interface{}) {\n\tlog.Printf(\"\\033[1;4;31m[ERROR] %v \\033[0m\\n\", strings.TrimRight(fmt.Sprintln(v...), \"\\n\"))\n}\n\nfunc WARN(v ...interface{}) {\n\tlog.Printf(\"\\033[1;33m[WARN] %v \\033[0m\\n\", strings.TrimRight(fmt.Sprintln(v...), \"\\n\"))\n}\n\nfunc INFO(v ...interface{}) {\n\tlog.Printf(\"\\033[32m[INFO] %v \\033[0m\\n\", strings.TrimRight(fmt.Sprintln(v...), \"\\n\"))\n}\n\nfunc NOTICE(v ...interface{}) {\n\tlog.Printf(\"[NOTICE] %v\\n\", strings.TrimRight(fmt.Sprintln(v...), \"\\n\"))\n}\n\n\n\nfunc DEBUG(v ...interface{}) ", "output": "{\n\tif _debug_open {\n\t\tlog.Printf(\"\\033[1;35m[DEBUG] %v \\033[0m\\n\", strings.TrimRight(fmt.Sprintln(v...), \"\\n\"))\n\t}\n}"}
{"input": "package source\n\nimport (\n\t\"context\"\n\t\"sync\"\n\n\t\"github.com/moby/buildkit/cache\"\n\t\"github.com/pkg/errors\"\n)\n\ntype Source interface {\n\tID() string\n\tResolve(ctx context.Context, id Identifier) (SourceInstance, error)\n}\n\ntype SourceInstance interface {\n\tCacheKey(ctx context.Context, index int) (string, bool, error)\n\tSnapshot(ctx context.Context) (cache.ImmutableRef, error)\n}\n\ntype Manager struct {\n\tmu      sync.Mutex\n\tsources map[string]Source\n}\n\nfunc NewManager() (*Manager, error) {\n\treturn &Manager{\n\t\tsources: make(map[string]Source),\n\t}, nil\n}\n\nfunc (sm *Manager) Register(src Source) {\n\tsm.mu.Lock()\n\tsm.sources[src.ID()] = src\n\tsm.mu.Unlock()\n}\n\n\n\nfunc (sm *Manager) Resolve(ctx context.Context, id Identifier) (SourceInstance, error) ", "output": "{\n\tsm.mu.Lock()\n\tsrc, ok := sm.sources[id.ID()]\n\tsm.mu.Unlock()\n\n\tif !ok {\n\t\treturn nil, errors.Errorf(\"no handler for %s\", id.ID())\n\t}\n\n\treturn src.Resolve(ctx, id)\n}"}
{"input": "package example\n\nimport (\n\t\"net/http\"\n\n\t\"gopkg.in/gin-gonic/gin.v1\"\n)\n\n\n\n\nfunc GinEngine() *gin.Engine {\n\tgin.SetMode(gin.TestMode)\n\tr := gin.New()\n\n\tr.GET(\"/\", ginHelloHandler)\n\n\treturn r\n}\n\nfunc ginHelloHandler(c *gin.Context) ", "output": "{\n\tc.String(http.StatusOK, \"Hello World\")\n}"}
{"input": "package loader\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\n\n\nfunc TestAnchorMerger(t *testing.T) ", "output": "{\n\tin := []byte(`---\nvars: &v\n  env: qa\ndeploy:\n  env: live`)\n\texpect := `{\"deploy\":{\"env\":\"live\"},\"vars\":{\"env\":\"qa\"}}`\n\n\tif err := ioutil.WriteFile(\"/tmp/test\", in, 0644); err != nil {\n\t\tt.Error(\"Error file not create\")\n\t\tt.Fail()\n\t}\n\n\tdefer os.Remove(\"/tmp/test\")\n\n\tif g, err := LoadFile(\"/tmp/test\"); err != nil {\n\t\tt.Errorf(\"%v\\n\", err)\n\t\tt.Fail()\n\t} else {\n\t\tif g.String() != expect {\n\t\t\tt.Errorf(\"%s != %s\", g.String(), expect)\n\t\t\tt.Fail()\n\t\t}\n\t}\n}"}
{"input": "package service\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/BurntSushi/toml\"\n\t\"github.com/nebulaim/telegramd/baselib/grpc_util\"\n\t\"github.com/nebulaim/telegramd/baselib/mysql_client\"\n\t\"github.com/nebulaim/telegramd/baselib/redis_client\"\n)\n\nvar (\n\tconfPath string\n\tConf     *documentConfig\n)\n\ntype documentConfig struct {\n\tServerId  int32 \n\tDataPath  string\n\tRedis     []redis_client.RedisConfig\n\tMysql     []mysql_client.MySQLConfig\n\tRpcServer *grpc_util.RPCServerConfig\n}\n\nfunc (c *documentConfig) String() string {\n\treturn fmt.Sprintf(\"{server_id: %d, redis: %v. mysql: %v, server: %v}\",\n\t\tc.ServerId,\n\t\tc.Redis,\n\t\tc.Mysql,\n\t\tc.RpcServer)\n}\n\nfunc init() {\n\tflag.StringVar(&confPath, \"conf\", \"./document.toml\", \"config path\")\n}\n\n\n\nfunc InitializeConfig() (err error) ", "output": "{\n\t_, err = toml.DecodeFile(confPath, &Conf)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"decode file %s error: %v\", confPath, err)\n\t}\n\treturn\n}"}
{"input": "package memory\n\nimport (\n\t\"bytes\"\n\n\t\"github.com/aykevl/dtsync/tree\"\n)\n\n\ntype fileCopier struct {\n\tbytes.Buffer\n\tcallback func(*bytes.Buffer) (tree.FileInfo, tree.FileInfo, error)\n}\n\n\nfunc newFileCopier(callback func(*bytes.Buffer) (tree.FileInfo, tree.FileInfo, error)) *fileCopier {\n\treturn &fileCopier{\n\t\tcallback: callback,\n\t}\n}\n\n\n\nfunc (fc *fileCopier) Finish() (tree.FileInfo, tree.FileInfo, error) {\n\treturn fc.callback(&fc.Buffer)\n}\n\n\n\nfunc (fc *fileCopier) Cancel() error {\n\treturn nil\n}\n\n\n\ntype fileCloser struct {\n\t*bytes.Buffer\n\tcallback func(*bytes.Buffer)\n}\n\n\nfunc newFileCloser(callback func(*bytes.Buffer)) *fileCloser {\n\treturn &fileCloser{\n\t\tBuffer:   &bytes.Buffer{},\n\t\tcallback: callback,\n\t}\n}\n\n\n\nfunc (fc *fileCloser) Close() error {\n\tfc.callback(fc.Buffer)\n\treturn nil\n}\n\n\n\ntype readCloseBuffer struct {\n\tbuf *bytes.Reader\n}\n\nfunc newReadCloseBuffer(data []byte) *readCloseBuffer {\n\treturn &readCloseBuffer{bytes.NewReader(data)}\n}\n\n\nfunc (b *readCloseBuffer) Read(p []byte) (int, error) {\n\treturn b.buf.Read(p)\n}\n\n\n\n\n\n\nfunc (b *readCloseBuffer) Close() error {\n\treturn nil\n}\n\nfunc (b *readCloseBuffer) ReadAt(p []byte, off int64) (int, error) ", "output": "{\n\treturn b.buf.ReadAt(p, off)\n}"}
{"input": "package orm\n\nimport (\n\t\"time\"\n)\n\nfunc String(s string) *string {\n\treturn &s\n}\n\nfunc Int(i int) *int {\n\treturn &i\n}\n\nfunc Int8(i int8) *int8 {\n\treturn &i\n}\n\nfunc Int16(i int16) *int16 {\n\treturn &i\n}\n\nfunc Int32(i int32) *int32 {\n\treturn &i\n}\n\n\n\nfunc Bool(b bool) *bool {\n\treturn &b\n}\n\nfunc Byte(b byte) *byte {\n\treturn &b\n}\n\nfunc Float32(f float32) *float32 {\n\treturn &f\n}\n\nfunc Float64(f float64) *float64 {\n\treturn &f\n}\n\nfunc Rune(r rune) *rune {\n\treturn &r\n}\n\nfunc Uint(u uint) *uint {\n\treturn &u\n}\n\nfunc Uint8(u uint8) *uint8 {\n\treturn &u\n}\n\nfunc Uint16(u uint16) *uint16 {\n\treturn &u\n}\n\nfunc Uint32(u uint32) *uint32 {\n\treturn &u\n}\n\nfunc Uint64(u uint64) *uint64 {\n\treturn &u\n}\n\nfunc Is(b *bool) bool {\n\treturn b != nil && *b\n}\n\nfunc Time(t time.Time) *time.Time {\n\treturn &t\n}\n\nfunc Duration(d time.Duration) *time.Duration {\n\treturn &d\n}\n\nfunc Int64(i int64) *int64 ", "output": "{\n\treturn &i\n}"}
{"input": "package mapd\n\nimport (\n\t. \"common\"\n\t\"fmt\"\n\t\"net\"\n\t\"rpc\"\n)\n\ntype MapdConnection struct {\n\tBinaryConnection\n\trpcEncoder rpc.RPCEncoder\n\trpcDecoder rpc.RPCDecoder\n}\n\n\n\nfunc (self *MapdConnection) RecvCmd() (byte, error) {\n\tb, err := self.RecvByte()\n\treturn b, err\n}\n\nfunc (self *MapdConnection) SendCmd(cmd byte) error {\n\treturn self.SendByte(cmd)\n}\n\nfunc (self *MapdConnection) SendReplyOk() error {\n\treturn self.SendByte(REPLY_OK)\n}\n\nfunc (self *MapdConnection) RecvReplyOk() error {\n\tb, err := self.RecvByte()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif b != REPLY_OK {\n\t\treturn fmt.Errorf(\"expect REPLY_OK but received %v\", b)\n\t}\n\treturn nil\n}\n\nfunc (self *MapdConnection) SendRPC(eid Eid, method string, args []interface{}) error {\n\treturn self.rpcEncoder.Encode(string(eid), method, args)\n}\n\nfunc (self *MapdConnection) RecvRPC(eid *Eid, method *string, args *[]interface{}) error {\n\treturn self.rpcDecoder.Decode((*string)(eid), method, args)\n}\n\nfunc (self *MapdConnection) SendPid(pid int) error {\n\treturn self.SendUint16(uint16(pid))\n}\n\nfunc (self *MapdConnection) RecvPid() (int, error) {\n\tv, err := self.RecvUint16()\n\treturn int(v), err\n}\n\nfunc NewMapdConnection(conn net.Conn) MapdConnection ", "output": "{\n\tbinaryConn := NewBinaryConnection(conn)\n\tmapdCon := MapdConnection{BinaryConnection: binaryConn}\n\tmapdCon.rpcEncoder = rpc.NewCustomRPCEncoder(mapdCon)\n\tmapdCon.rpcDecoder = rpc.NewCustomRPCDecoder(mapdCon)\n\treturn mapdCon\n}"}
{"input": "package sensors\n\nimport (\n\t\"github.com/geoffholden/gowx/data\"\n)\n\nvar Sensors map[string]data.SensorParser\n\n\n\nfunc RegisterSensor(key string, sensor data.SensorParser) ", "output": "{\n\tif nil == Sensors {\n\t\tSensors = make(map[string]data.SensorParser)\n\t}\n\tSensors[key] = sensor\n}"}
{"input": "package fx\n\nimport (\n\t\"go.uber.org/fx/fxevent\"\n)\n\n\n\ntype logBuffer struct {\n\tevents []fxevent.Event\n\tlogger fxevent.Logger\n}\n\n\n\n\n\nfunc (l *logBuffer) Connect(logger fxevent.Logger) {\n\tl.logger = logger\n\tfor _, e := range l.events {\n\t\tlogger.LogEvent(e)\n\t}\n\tl.events = nil\n}\n\nfunc (l *logBuffer) LogEvent(event fxevent.Event) ", "output": "{\n\tif l.logger == nil {\n\t\tl.events = append(l.events, event)\n\t} else {\n\t\tl.logger.LogEvent(event)\n\t}\n}"}
{"input": "package common\n\nimport (\n\t\"testing\"\n\n\tchecker \"gopkg.in/check.v1\"\n)\n\n\n\nfunc Test(t *testing.T) ", "output": "{ checker.TestingT(t) }"}
{"input": "package multidict_test\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n\n\t\"github.com/onsi/ginkgo/reporters\"\n\n\t\"github.com/projectcalico/calico/libcalico-go/lib/testutils\"\n)\n\n\n\nfunc TestMultidict(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tjunitReporter := reporters.NewJUnitReporter(\"../report/multidict_suite.xml\")\n\tRunSpecsWithDefaultAndCustomReporters(t, \"Multidict Suite\", []Reporter{junitReporter})\n}\n\nfunc init() ", "output": "{\n\ttestutils.HookLogrusForGinkgo()\n}"}
{"input": "package alicloud\n\ntype PrimaryKeyTypeString string\n\nconst (\n\tIntegerType = PrimaryKeyTypeString(\"Integer\")\n\tStringType  = PrimaryKeyTypeString(\"String\")\n\tBinaryType  = PrimaryKeyTypeString(\"Binary\")\n)\n\ntype InstanceAccessedByType string\n\nconst (\n\tAnyNetwork   = InstanceAccessedByType(\"Any\")\n\tVpcOnly      = InstanceAccessedByType(\"Vpc\")\n\tVpcOrConsole = InstanceAccessedByType(\"ConsoleOrVpc\")\n)\n\ntype OtsInstanceType string\n\nconst (\n\tOtsCapacity        = OtsInstanceType(\"Capacity\")\n\tOtsHighPerformance = OtsInstanceType(\"HighPerformance\")\n)\n\nfunc convertInstanceAccessedBy(accessed InstanceAccessedByType) string {\n\tswitch accessed {\n\tcase VpcOnly:\n\t\treturn \"VPC\"\n\tcase VpcOrConsole:\n\t\treturn \"VPC_CONSOLE\"\n\tdefault:\n\t\treturn \"NORMAL\"\n\t}\n}\n\n\n\nfunc convertInstanceType(instanceType OtsInstanceType) string {\n\tswitch instanceType {\n\tcase OtsHighPerformance:\n\t\treturn \"SSD\"\n\tdefault:\n\t\treturn \"HYBRID\"\n\t}\n}\n\nfunc convertInstanceTypeRevert(instanceType string) OtsInstanceType {\n\tswitch instanceType {\n\tcase \"SSD\":\n\t\treturn OtsHighPerformance\n\tdefault:\n\t\treturn OtsCapacity\n\t}\n}\n\n\nfunc convertOtsInstanceStatus(status Status) int {\n\tswitch status {\n\tcase Running:\n\t\treturn 1\n\tcase DisabledStatus:\n\t\treturn 2\n\tcase Deleting:\n\t\treturn 3\n\tdefault:\n\t\treturn -1\n\t}\n}\n\nfunc convertInstanceAccessedByRevert(network string) InstanceAccessedByType ", "output": "{\n\tswitch network {\n\tcase \"VPC\":\n\t\treturn VpcOnly\n\tcase \"VPC_CONSOLE\":\n\t\treturn VpcOrConsole\n\tdefault:\n\t\treturn AnyNetwork\n\t}\n}"}
{"input": "package alicloud\n\ntype PrimaryKeyTypeString string\n\nconst (\n\tIntegerType = PrimaryKeyTypeString(\"Integer\")\n\tStringType  = PrimaryKeyTypeString(\"String\")\n\tBinaryType  = PrimaryKeyTypeString(\"Binary\")\n)\n\ntype InstanceAccessedByType string\n\nconst (\n\tAnyNetwork   = InstanceAccessedByType(\"Any\")\n\tVpcOnly      = InstanceAccessedByType(\"Vpc\")\n\tVpcOrConsole = InstanceAccessedByType(\"ConsoleOrVpc\")\n)\n\ntype OtsInstanceType string\n\nconst (\n\tOtsCapacity        = OtsInstanceType(\"Capacity\")\n\tOtsHighPerformance = OtsInstanceType(\"HighPerformance\")\n)\n\n\n\nfunc convertInstanceAccessedByRevert(network string) InstanceAccessedByType {\n\tswitch network {\n\tcase \"VPC\":\n\t\treturn VpcOnly\n\tcase \"VPC_CONSOLE\":\n\t\treturn VpcOrConsole\n\tdefault:\n\t\treturn AnyNetwork\n\t}\n}\n\nfunc convertInstanceType(instanceType OtsInstanceType) string {\n\tswitch instanceType {\n\tcase OtsHighPerformance:\n\t\treturn \"SSD\"\n\tdefault:\n\t\treturn \"HYBRID\"\n\t}\n}\n\nfunc convertInstanceTypeRevert(instanceType string) OtsInstanceType {\n\tswitch instanceType {\n\tcase \"SSD\":\n\t\treturn OtsHighPerformance\n\tdefault:\n\t\treturn OtsCapacity\n\t}\n}\n\n\nfunc convertOtsInstanceStatus(status Status) int {\n\tswitch status {\n\tcase Running:\n\t\treturn 1\n\tcase DisabledStatus:\n\t\treturn 2\n\tcase Deleting:\n\t\treturn 3\n\tdefault:\n\t\treturn -1\n\t}\n}\n\nfunc convertInstanceAccessedBy(accessed InstanceAccessedByType) string ", "output": "{\n\tswitch accessed {\n\tcase VpcOnly:\n\t\treturn \"VPC\"\n\tcase VpcOrConsole:\n\t\treturn \"VPC_CONSOLE\"\n\tdefault:\n\t\treturn \"NORMAL\"\n\t}\n}"}
{"input": "package utilmocks\n\nimport (\n\tcontext \"context\"\n\tgomock \"github.com/golang/mock/gomock\"\n\texec \"os/exec\"\n\treflect \"reflect\"\n)\n\n\ntype MockCommandRunner struct {\n\tctrl     *gomock.Controller\n\trecorder *MockCommandRunnerMockRecorder\n}\n\n\ntype MockCommandRunnerMockRecorder struct {\n\tmock *MockCommandRunner\n}\n\n\n\n\n\nfunc (m *MockCommandRunner) EXPECT() *MockCommandRunnerMockRecorder {\n\treturn m.recorder\n}\n\n\nfunc (m *MockCommandRunner) Run(ctx context.Context, command *exec.Cmd) ([]byte, []byte, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Run\", ctx, command)\n\tret0, _ := ret[0].([]byte)\n\tret1, _ := ret[1].([]byte)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n\nfunc (mr *MockCommandRunnerMockRecorder) Run(ctx, command interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Run\", reflect.TypeOf((*MockCommandRunner)(nil).Run), ctx, command)\n}\n\nfunc NewMockCommandRunner(ctrl *gomock.Controller) *MockCommandRunner ", "output": "{\n\tmock := &MockCommandRunner{ctrl: ctrl}\n\tmock.recorder = &MockCommandRunnerMockRecorder{mock}\n\treturn mock\n}"}
{"input": "package zipkin\n\nimport (\n\t\"github.com/jaegertracing/jaeger/thrift-gen/zipkincore\"\n)\n\n\nfunc IsServerCore(anno string) bool {\n\treturn anno == zipkincore.SERVER_SEND || anno == zipkincore.SERVER_RECV\n}\n\n\nfunc IsClientCore(anno string) bool {\n\treturn anno == zipkincore.CLIENT_SEND || anno == zipkincore.CLIENT_RECV\n}\n\n\n\n\n\nfunc FindServiceName(span *zipkincore.Span) string {\n\tfor _, anno := range span.Annotations {\n\t\tendpoint := anno.GetHost()\n\t\tif endpoint == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif IsCore(anno.Value) && endpoint.GetServiceName() != \"\" {\n\t\t\treturn endpoint.GetServiceName()\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc IsCore(anno string) bool ", "output": "{\n\treturn IsServerCore(anno) || IsClientCore(anno)\n}"}
{"input": "package v2\n\nimport context \"context\"\n\nimport proto \"github.com/golang/protobuf/proto\"\nimport \"go-common/library/net/rpc/liverpc\"\n\nvar _ proto.Message \n\n\n\n\n\n\ntype App interface {\n\tLiveHomePage(context.Context, *AppLiveHomePageReq) (*AppLiveHomePageResp, error)\n}\n\n\n\n\n\ntype appRpcClient struct {\n\tclient *liverpc.Client\n}\n\n\n\nfunc NewAppRpcClient(client *liverpc.Client) App {\n\treturn &appRpcClient{\n\t\tclient: client,\n\t}\n}\n\nfunc (c *appRpcClient) LiveHomePage(ctx context.Context, in *AppLiveHomePageReq) (*AppLiveHomePageResp, error) {\n\tout := new(AppLiveHomePageResp)\n\terr := doRpcRequest(ctx, c.client, 2, \"App.LiveHomePage\", in, out)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\n\n\n\n\n\n\nfunc doRpcRequest(ctx context.Context, client *liverpc.Client, version int, method string, in, out proto.Message) (err error) ", "output": "{\n\terr = client.Call(ctx, version, method, in, out)\n\treturn\n}"}
{"input": "package event\n\nimport (\n\t\"fmt\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n\ntype Increment struct {\n\tName  string\n\tValue int64\n}\n\n\n\n\nfunc (e *Increment) Update(e2 Event) error {\n\tif e.Type() != e2.Type() {\n\t\treturn fmt.Errorf(\"statsd event type conflict: %s vs %s \", e.String(), e2.String())\n\t}\n\tatomic.AddInt64(&e.Value, e2.Payload().(int64))\n\treturn nil\n}\n\n\nfunc (e *Increment) Reset() {\n\te.Value = 0\n}\n\n\nfunc (e Increment) Payload() interface{} {\n\treturn e.Value\n}\n\n\nfunc (e Increment) Stats(tick time.Duration) []string {\n\treturn []string{fmt.Sprintf(\"%s:%d|c\", e.Name, e.Value)}\n}\n\n\nfunc (e Increment) Key() string {\n\treturn e.Name\n}\n\n\nfunc (e *Increment) SetKey(key string) {\n\te.Name = key\n}\n\n\nfunc (e Increment) Type() int {\n\treturn EventIncr\n}\n\n\nfunc (e Increment) TypeString() string {\n\treturn \"Increment\"\n}\n\n\nfunc (e Increment) String() string {\n\treturn fmt.Sprintf(\"{Type: %s, Key: %s, Value: %d}\", e.TypeString(), e.Name, e.Value)\n}\n\nfunc (e *Increment) StatClass() string ", "output": "{\n\treturn \"counter\"\n}"}
{"input": "package gftest\n\nimport (\n  \"errors\"\n  \"reflect\"\n  \"encoding/json\"\n)\n\nfunc (req *Request) Debug(msg string) { req.t.Log(req.FullPath() + \": %v\", msg) }\n\nfunc (req *Request) NewError(msg string) error {\n\n\terr := errors.New(req.FullPath() + \": \" + msg)\n\treturn err\n}\n\nfunc (req *Request) Error(e error) { req.t.Log(e.Error()) }\n\nfunc (req *Request) Reflect(e interface{}) {\n\tmsg := \"REFLECT VALUE IS NIL\"\n\tif e != nil {\n\t\tmsg = \"REFLECT VALUE IS \"+reflect.TypeOf(e).String()\n\t}\n\treq.NewError(msg)\n}\n\n\n\nfunc (req *Request) DebugJSON(i interface{}) ", "output": "{\n\tb, err := json.Marshal(i); if err != nil { req.Error(err); return }\n\treq.Debug(string(b))\n}"}
{"input": "package golf\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestInt(t *testing.T) {\n\tf := Fore(\"hero\", 3)\n\tassertMapLen(t, f, 1)\n\tassertKeyEquals(t, f, \"hero\", 3)\n}\n\nfunc TestString(t *testing.T) {\n\tf := Fore(\"hero\", \"three\")\n\tassertMapLen(t, f, 1)\n\tassertKeyEquals(t, f, \"hero\", \"three\")\n}\n\nfunc TestStringThatGolfs(t *testing.T) {\n\ts := StringThatGolfs(\"three\")\n\tf := Fore(\"hero\", &s)\n\tt.Log(f)\n\tassertMapLen(t, f, 1)\n\tassertKeyEquals(t, f, \"hero.golfer\", \"three three\")\n}\n\nfunc TestNil(t *testing.T) {\n\tf := Fore(\"hero\", nil)\n\tif f != nil {\n\t\tt.Fatal(\"not nil\")\n\t}\n}\n\n\n\nfunc TestStructNonPointer(t *testing.T) {\n\tf := Fore(\"test\", &StructWithoutPointer{Foo: FooStruct{Bar: \"value\"}})\n\tassertMapLen(t, f, 1)\n\tassertKeyEquals(t, f, \"test.foo.Bar\", \"value\")\n}\n\ntype StringThatGolfs string\n\nfunc (s *StringThatGolfs) GolfExportedFields() map[string]interface{} {\n\treturn map[string]interface{}{\"golfer\": fmt.Sprintf(\"%s %s\", *s, *s)}\n}\n\ntype FooStruct struct {\n\tBar string\n}\n\ntype StructWithPointer struct {\n\tFoo *FooStruct `golf:\"foo\"`\n}\n\ntype StructWithoutPointer struct {\n\tFoo FooStruct `golf:\"foo\"`\n}\n\nfunc TestStructPointer(t *testing.T) ", "output": "{\n\tf := Fore(\"test\", &StructWithPointer{Foo: &FooStruct{Bar: \"value\"}})\n\tassertMapLen(t, f, 1)\n\tassertKeyEquals(t, f, \"test.foo.Bar\", \"value\")\n}"}
{"input": "package websocket\n\ntype data struct {\n\tIndex int\n\tBody  []byte\n\tError error\n}\n\n\n\nfunc parseHeader(header []byte) (index int, ok bool) {\n\tindex = int(header[0])<<24 | int(header[1])<<16 | int(header[2])<<8 | int(header[3])\n\tif ok = (header[0]&0x80 == 0); !ok {\n\t\tindex &= 0x7fffffff\n\t}\n\treturn\n}\n\nfunc makeHeader(index int) (header [4]byte) ", "output": "{\n\theader[0] = byte(index >> 24 & 0xff)\n\theader[1] = byte(index >> 16 & 0xff)\n\theader[2] = byte(index >> 8 & 0xff)\n\theader[3] = byte(index & 0xff)\n\treturn\n}"}
{"input": "package file\n\nimport (\n\t\"os\"\n\t\"time\"\n)\n\n\n\ntype ExFileInfo interface {\n\tos.FileInfo       \n\tPath() string     \n\tCTime() time.Time \n\tATime() time.Time \n\tFID() FID         \n}\n\n\nfunc ExStat(path string) (fileInfo ExFileInfo, err error) {\n\tfi, err := os.Stat(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\texfi := systemExFileInfo(fi, path)\n\treturn exfi, nil\n}\n\n\nfunc ExStatFromFileInfo(fi os.FileInfo, path string) (ExFileInfo, error) {\n\treturn systemExFileInfo(fi, path), nil\n}\n\n\n\ntype stdExFileInfo struct {\n\tos.FileInfo\n\tpath  string\n\tmtime time.Time\n\tctime time.Time\n\tatime time.Time\n\tfid   FID\n\tsize  int64\n}\n\nfunc ExInfoFrom(size int64, ctime, atime, mtime time.Time, fid FID) *stdExFileInfo {\n\tfinfo := &stdExFileInfo{\n\t\tpath:  \"\",\n\t\tctime: ctime,\n\t\tatime: atime,\n\t\tmtime: mtime,\n\t\tfid:   fid,\n\t\tsize:  size,\n\t}\n\treturn finfo\n}\n\nfunc (fi *stdExFileInfo) FID() FID {\n\treturn fi.fid\n}\n\nfunc (fi *stdExFileInfo) CTime() time.Time {\n\treturn fi.ctime\n}\n\nfunc (fi *stdExFileInfo) ModTime() time.Time {\n\treturn fi.mtime\n}\n\n\n\nfunc (fi *stdExFileInfo) Path() string {\n\treturn fi.path\n}\n\nfunc (fi *stdExFileInfo) Size() int64 {\n\treturn fi.size\n}\n\nfunc (fi *stdExFileInfo) ATime() time.Time ", "output": "{\n\treturn fi.atime\n}"}
{"input": "package iso20022\n\n\ntype ATMTransactionAmounts6 struct {\n\n\tCurrency *ActiveCurrencyCode `xml:\"Ccy,omitempty\"`\n\n\tMaximumPossibleAmount *ImpliedCurrencyAndAmount `xml:\"MaxPssblAmt,omitempty\"`\n\n\tMinimumPossibleAmount *ImpliedCurrencyAndAmount `xml:\"MinPssblAmt,omitempty\"`\n\n\tAdditionalAmount []*ATMTransactionAmounts7 `xml:\"AddtlAmt,omitempty\"`\n}\n\n\n\nfunc (a *ATMTransactionAmounts6) SetMaximumPossibleAmount(value, currency string) {\n\ta.MaximumPossibleAmount = NewImpliedCurrencyAndAmount(value, currency)\n}\n\nfunc (a *ATMTransactionAmounts6) SetMinimumPossibleAmount(value, currency string) {\n\ta.MinimumPossibleAmount = NewImpliedCurrencyAndAmount(value, currency)\n}\n\nfunc (a *ATMTransactionAmounts6) AddAdditionalAmount() *ATMTransactionAmounts7 {\n\tnewValue := new(ATMTransactionAmounts7)\n\ta.AdditionalAmount = append(a.AdditionalAmount, newValue)\n\treturn newValue\n}\n\nfunc (a *ATMTransactionAmounts6) SetCurrency(value string) ", "output": "{\n\ta.Currency = (*ActiveCurrencyCode)(&value)\n}"}
{"input": "package pubsub\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/libp2p/go-libp2p-core/peer\"\n\t\"github.com/whyrusleeping/timecache\"\n)\n\n\ntype Blacklist interface {\n\tAdd(peer.ID) bool\n\tContains(peer.ID) bool\n}\n\n\ntype MapBlacklist map[peer.ID]struct{}\n\n\nfunc NewMapBlacklist() Blacklist {\n\treturn MapBlacklist(make(map[peer.ID]struct{}))\n}\n\n\n\nfunc (b MapBlacklist) Contains(p peer.ID) bool {\n\t_, ok := b[p]\n\treturn ok\n}\n\n\ntype TimeCachedBlacklist struct {\n\tsync.RWMutex\n\ttc *timecache.TimeCache\n}\n\n\nfunc NewTimeCachedBlacklist(expiry time.Duration) (Blacklist, error) {\n\tb := &TimeCachedBlacklist{tc: timecache.NewTimeCache(expiry)}\n\treturn b, nil\n}\n\n\nfunc (b *TimeCachedBlacklist) Add(p peer.ID) bool {\n\tb.Lock()\n\tdefer b.Unlock()\n\ts := p.String()\n\tif b.tc.Has(s) {\n\t\treturn false\n\t}\n\tb.tc.Add(s)\n\treturn true\n}\n\nfunc (b *TimeCachedBlacklist) Contains(p peer.ID) bool {\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\treturn b.tc.Has(p.String())\n}\n\nfunc (b MapBlacklist) Add(p peer.ID) bool ", "output": "{\n\tb[p] = struct{}{}\n\treturn true\n}"}
{"input": "package goog_error\n\n\n\n\ntype ErrorReason struct {\n\tMessage string `json:\"message\"`\n\tDomain  string `json:\"domain\"`\n\tReason  string `json:\"reason\"`\n}\n\ntype ErrorInfo struct {\n\tCode    int           `json:\"code\"`\n\tMessage string        `json:\"message\"`\n\tStatus  string        `json:\"status\"`\n\tErrors  []ErrorReason `json:\"errors\"`\n}\n\ntype GoogleError struct {\n\tInfo ErrorInfo `json:\"error\"`\n}\n\n\n\nfunc (z GoogleError) Error() string ", "output": "{\n\treturn z.Info.Message\n}"}
{"input": "package fileutil\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\nconst hasPunchHole = false\n\n\n\n\nfunc PunchHole(f *os.File, off, len int64) error {\n\treturn nil\n}\n\n\n\n\n\nfunc IsEOF(err error) bool { return err == io.EOF }\n\nfunc Fadvise(f *os.File, off, len int64, advice FadviseAdvice) error ", "output": "{\n\treturn nil\n}"}
{"input": "package spi\n\nimport (\n\t\"image/color\"\n\t\"testing\"\n\n\t\"gobot.io/x/gobot\"\n\t\"gobot.io/x/gobot/gobottest\"\n)\n\nvar _ gobot.Driver = (*APA102Driver)(nil)\n\nfunc initTestDriver() *APA102Driver {\n\td := NewAPA102Driver(&TestConnector{}, 10, 31)\n\treturn d\n}\n\nfunc TestDriverStart(t *testing.T) {\n\td := initTestDriver()\n\tgobottest.Assert(t, d.Start(), nil)\n}\n\nfunc TestDriverHalt(t *testing.T) {\n\td := initTestDriver()\n\td.Start()\n\tgobottest.Assert(t, d.Halt(), nil)\n}\n\n\n\nfunc TestDriverLEDs(t *testing.T) ", "output": "{\n\td := initTestDriver()\n\td.Start()\n\n\td.SetRGBA(0, color.RGBA{255, 255, 255, 15})\n\td.SetRGBA(1, color.RGBA{255, 255, 255, 15})\n\td.SetRGBA(2, color.RGBA{255, 255, 255, 15})\n\td.SetRGBA(3, color.RGBA{255, 255, 255, 15})\n\n\tgobottest.Assert(t, d.Draw(), nil)\n}"}
{"input": "package stdlib\n\nimport (\n\t\"crypto/md5\"\n\t\"go/constant\"\n\t\"go/token\"\n\t\"reflect\"\n)\n\n\n\nfunc init() ", "output": "{\n\tSymbols[\"crypto/md5\"] = map[string]reflect.Value{\n\t\t\"BlockSize\": reflect.ValueOf(constant.MakeFromLiteral(\"64\", token.INT, 0)),\n\t\t\"New\":       reflect.ValueOf(md5.New),\n\t\t\"Size\":      reflect.ValueOf(constant.MakeFromLiteral(\"16\", token.INT, 0)),\n\t\t\"Sum\":       reflect.ValueOf(md5.Sum),\n\t}\n}"}
{"input": "package smux\n\nfunc _itimediff(later, earlier uint32) int32 {\n\treturn (int32)(later - earlier)\n}\n\ntype shaperHeap []writeRequest\n\nfunc (h shaperHeap) Len() int            { return len(h) }\n\nfunc (h shaperHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\nfunc (h *shaperHeap) Push(x interface{}) { *h = append(*h, x.(writeRequest)) }\n\nfunc (h *shaperHeap) Pop() interface{} {\n\told := *h\n\tn := len(old)\n\tx := old[n-1]\n\t*h = old[0 : n-1]\n\treturn x\n}\n\nfunc (h shaperHeap) Less(i, j int) bool  ", "output": "{ return _itimediff(h[j].prio, h[i].prio) > 0 }"}
{"input": "package idxfile\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\n\t\"github.com/src-d/go-git-fixtures\"\n\t\"gopkg.in/src-d/go-git.v4/plumbing\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\n\n\nfunc (s *IdxfileSuite) TestDecodeEncode(c *C) {\n\tfixtures.ByTag(\"packfile\").Test(c, func(f *fixtures.Fixture) {\n\t\texpected, err := ioutil.ReadAll(f.Idx())\n\t\tc.Assert(err, IsNil)\n\n\t\tidx := &Idxfile{}\n\t\td := NewDecoder(bytes.NewBuffer(expected))\n\t\terr = d.Decode(idx)\n\t\tc.Assert(err, IsNil)\n\n\t\tresult := bytes.NewBuffer(nil)\n\t\te := NewEncoder(result)\n\t\tsize, err := e.Encode(idx)\n\t\tc.Assert(err, IsNil)\n\n\t\tc.Assert(size, Equals, len(expected))\n\t\tc.Assert(result.Bytes(), DeepEquals, expected)\n\t})\n}\n\nfunc (s *IdxfileSuite) TestEncode(c *C) ", "output": "{\n\texpected := &Idxfile{}\n\texpected.Add(plumbing.NewHash(\"4bfc730165c370df4a012afbb45ba3f9c332c0d4\"), 82, 82)\n\texpected.Add(plumbing.NewHash(\"8fa2238efdae08d83c12ee176fae65ff7c99af46\"), 42, 42)\n\n\tbuf := bytes.NewBuffer(nil)\n\te := NewEncoder(buf)\n\t_, err := e.Encode(expected)\n\tc.Assert(err, IsNil)\n\n\tidx := &Idxfile{}\n\td := NewDecoder(buf)\n\terr = d.Decode(idx)\n\tc.Assert(err, IsNil)\n\n\tc.Assert(idx.Entries, DeepEquals, expected.Entries)\n}"}
{"input": "package coverage\n\nimport \"testing\"\n\n\n\nfunc TestCoverage(t *testing.T) ", "output": "{\n\tlive()\n}"}
{"input": "package vauth\n\nimport (\n\t\"crypto/subtle\"\n)\n\n\n\n\nfunc SecureCompare(x string, y string) bool ", "output": "{\n\tif len(x) != len(y) {\n\t\treturn false\n\t}\n\n\treturn subtle.ConstantTimeCompare([]byte(x), []byte(y)) == 1\n}"}
{"input": "package request\n\nimport (\n\t\"errors\"\n\t\"github.com/vx-labs/go-rest-api\"\n\t\"github.com/vx-labs/go-rest-api/opts\"\n)\n\ntype APIRequest struct {\n\taction   api.Verb\n\tpayload  interface{}\n\tresponse interface{}\n\tresource api.ClientResource\n\topts     opts.Values\n\theaders  map[string][]string\n}\n\nfunc (r *APIRequest) Payload() interface{} {\n\treturn r.payload\n}\n\nfunc (r *APIRequest) Action() api.Verb {\n\treturn r.action\n}\nfunc (r *APIRequest) Headers() map[string][]string {\n\treturn r.headers\n}\nfunc (r *APIRequest) Resource() api.ClientResource {\n\treturn r.resource\n}\n\nfunc (r *APIRequest) WithOptions(opts opts.Values) api.ClientRequest {\n\tr.opts = opts\n\treturn r\n}\nfunc (r *APIRequest) WithHeader(name, value string) api.ClientRequest {\n\tif _, found := r.headers[name]; !found {\n\t\tr.headers[name] = []string{value}\n\t\treturn r\n\t}\n\tr.headers[name] = append(r.headers[name], value)\n\treturn r\n}\n\nfunc (r *APIRequest) Options() opts.Values {\n\treturn r.opts\n}\n\nfunc (r *APIRequest) Validate() error {\n\tif r.action > 5 {\n\t\treturn errors.New(\"invalid API verb\")\n\t}\n\treturn nil\n}\n\nfunc New(action api.Verb, payload interface{}, response interface{}, resource api.ClientResource) api.ClientRequest {\n\treturn &APIRequest{\n\t\taction:   action,\n\t\tpayload:  payload,\n\t\tresponse: response,\n\t\tresource: resource,\n\t\topts:     opts.New(),\n\t}\n}\n\nfunc (r *APIRequest) Response() interface{} ", "output": "{\n\treturn r.response\n}"}
{"input": "package downloader\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/WhaleCoinOrg/WhaleCoin/core/types\"\n)\n\n\ntype peerDropFn func(id string)\n\n\ntype dataPack interface {\n\tPeerId() string\n\tItems() int\n\tStats() string\n}\n\n\ntype headerPack struct {\n\tpeerId  string\n\theaders []*types.Header\n}\n\nfunc (p *headerPack) PeerId() string { return p.peerId }\nfunc (p *headerPack) Items() int     { return len(p.headers) }\nfunc (p *headerPack) Stats() string  { return fmt.Sprintf(\"%d\", len(p.headers)) }\n\n\ntype bodyPack struct {\n\tpeerId       string\n\ttransactions [][]*types.Transaction\n\tuncles       [][]*types.Header\n}\n\nfunc (p *bodyPack) PeerId() string { return p.peerId }\nfunc (p *bodyPack) Items() int {\n\tif len(p.transactions) <= len(p.uncles) {\n\t\treturn len(p.transactions)\n\t}\n\treturn len(p.uncles)\n}\nfunc (p *bodyPack) Stats() string { return fmt.Sprintf(\"%d:%d\", len(p.transactions), len(p.uncles)) }\n\n\ntype receiptPack struct {\n\tpeerId   string\n\treceipts [][]*types.Receipt\n}\n\nfunc (p *receiptPack) PeerId() string { return p.peerId }\nfunc (p *receiptPack) Items() int     { return len(p.receipts) }\nfunc (p *receiptPack) Stats() string  { return fmt.Sprintf(\"%d\", len(p.receipts)) }\n\n\ntype statePack struct {\n\tpeerId string\n\tstates [][]byte\n}\n\nfunc (p *statePack) PeerId() string { return p.peerId }\n\nfunc (p *statePack) Stats() string  { return fmt.Sprintf(\"%d\", len(p.states)) }\n\nfunc (p *statePack) Items() int     ", "output": "{ return len(p.states) }"}
{"input": "package util\n\nimport (\n\t\"golang.org/x/net/context\"\n\t\"testing\"\n)\n\n\n\nfunc TestKeepAliveLease(t *testing.T) {\n\t_, err := KeepAliveLease(context.Background(), \"\", \"\", \"\", -1)\n\tif err == nil {\n\t\tt.Fatalf(\"KeepAliveLease -1 failed\")\n\t}\n\n\t_, err = KeepAliveLease(context.Background(), \"\", \"\", \"\", 0)\n\tif err != nil {\n\t\tt.Fatalf(\"KeepAliveLease failed\")\n\t}\n}\n\nfunc TestHeartbeatUtil(t *testing.T) ", "output": "{\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tt.Fatalf(\"TestHeartbeatUtil failed\")\n\t\t}\n\t}()\n\tHeartbeatUtil(context.Background(), \"\", \"\", \"\")\n}"}
{"input": "package editor\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n)\n\n\n\nfunc TestCommandFunc(t *testing.T) {\n\ted := NewEditor([]byte(\"aabcc\"))\n\terr := ed.Command(\"x\", []string{\"b.\"})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = ed.Command(\"x\", []string{\"c\"})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tEqual(t, len(ed.dot), 1)\n\tEqual(t, ed.dot[0][0], 3)\n\tEqual(t, ed.dot[0][1], 4)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc TestXCommand(t *testing.T) {\n\tre, err := regexp.Compile(\"h.\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ted := NewEditor([]byte(\"hh hack\"))\n\tscopes := ed.xCommand([]int{0, 7}, re)\n\tEqual(t, scopes[0][0], 0)\n\tEqual(t, scopes[0][1], 2)\n\tEqual(t, scopes[1][0], 3)\n\tEqual(t, scopes[1][1], 5)\n\tscopes = ed.xCommand([]int{1, 7}, re)\n\tEqual(t, scopes[0][0], 1)\n\tEqual(t, scopes[0][1], 3)\n\tEqual(t, scopes[1][0], 3)\n\tEqual(t, scopes[1][1], 5)\n}\n\nfunc Equal(t *testing.T, a interface{}, b interface{}) ", "output": "{\n\tif a != b {\n\t\tt.Error(a, \"!=\", b)\n\t}\n}"}
{"input": "package community\n\n\n\nimport (\n\t\"github.com/zmap/zcrypto/x509\"\n\t\"github.com/zmap/zlint/v3/lint\"\n\t\"github.com/zmap/zlint/v3/util\"\n)\n\ntype SANDNSNull struct{}\n\n\n\nfunc (l *SANDNSNull) Initialize() error {\n\treturn nil\n}\n\nfunc (l *SANDNSNull) CheckApplies(c *x509.Certificate) bool {\n\treturn util.IsExtInCert(c, util.SubjectAlternateNameOID)\n}\n\nfunc (l *SANDNSNull) Execute(c *x509.Certificate) *lint.LintResult {\n\tfor _, dns := range c.DNSNames {\n\t\tfor i := 0; i < len(dns); i++ {\n\t\t\tif dns[i] == 0 {\n\t\t\t\treturn &lint.LintResult{Status: lint.Error}\n\t\t\t}\n\t\t}\n\t}\n\treturn &lint.LintResult{Status: lint.Pass}\n}\n\nfunc init() ", "output": "{\n\tlint.RegisterLint(&lint.Lint{\n\t\tName:          \"e_san_dns_name_includes_null_char\",\n\t\tDescription:   \"DNSName MUST NOT include a null character\",\n\t\tCitation:      \"awslabs certlint\",\n\t\tSource:        lint.Community,\n\t\tEffectiveDate: util.ZeroDate,\n\t\tLint:          &SANDNSNull{},\n\t})\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\t\"net/url\"\n\n\t\"github.com/ChimeraCoder/anaconda\"\n\t\"github.com/go-ini/ini\"\n)\n\nvar Config *ini.File\n\nconst (\n\tconsumerKey    = \"your key here\"\n\tconsumerSecret = \"your secret here\"\n\taccessToken    = \"your token here\"\n\taccessSecret   = \"your secret here\"\n\tmacAddress     = \"mac address of the dash button here\"\n)\n\nfunc main() {\n\tDashMacs[macAddress] = Tweet\n\n\tSnifferStart()\n}\n\nfunc NoAction() {\n\tlog.Println(\"No action on click.\")\n}\n\n\n\nfunc PostTweet(tweet string) {\n\tanaconda.SetConsumerKey(consumerKey)\n\tanaconda.SetConsumerSecret(consumerSecret)\n\tapi := anaconda.NewTwitterApi(accessToken, accessSecret)\n\n\tv := url.Values{}\n\n\t_, err := api.PostTweet(tweet, v)\n\tif err != nil {\n\t\tlog.Println(\"We have an error now \", err)\n\t}\n\n}\n\nfunc Tweet() ", "output": "{\n\tPostTweet(\"Testing now\")\n}"}
{"input": "package muts\n\nimport \"testing\"\n\n\n\nfunc TestTos(t *testing.T) ", "output": "{\n\tfor _, each := range []struct {\n\t\tinput interface{}\n\t\twant  string\n\t}{\n\t\t{nil, \"<nil>\"},\n\t\t{\"s\", \"s\"},\n\t\t{42, \"42\"},\n\t} {\n\t\tif got := Tos(each.input); got != each.want {\n\t\t\tt.Errorf(\"got %q want %q\", got, each.want)\n\t\t}\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\n\ntype HandlerFunc func(http.ResponseWriter, *http.Request) (int, error)\n\n\n\n\n\nfunc (s *server) handlerWrapper(h HandlerFunc) http.HandlerFunc {\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\t\tstatus, err := h(w, r)\n\n\t\tvar errMsg string\n\n\t\tif err != nil {\n\t\t\tw.Write([]byte(\"{\\\"message\\\": \\\"An unknown error occurred\\\"}\"))\n\t\t\terrMsg = err.Error()\n\t\t}\n\n\t\tlog.Printf(\"%s %s %s %d %s\", r.RemoteAddr, r.Method, r.URL, status, errMsg)\n\n\t}\n\n}\n\nfunc (s *server) routes(mux *http.ServeMux) ", "output": "{\n\tmux.HandleFunc(\"/\", s.handlerWrapper(handleProcess))                                          \n\tmux.HandleFunc(fmt.Sprintf(\"/api/v%s/nodeInfo\", apiVersion), s.handlerWrapper(handleProcess)) \n}"}
{"input": "package apis\n\nimport (\n\t\"github.com/devbus/devbus/common\"\n\t\"github.com/devbus/devbus/models\"\n\t\"github.com/devbus/devbus/services\"\n\t\"github.com/gin-contrib/sessions\"\n\t\"github.com/gin-gonic/gin\"\n)\n\n\n\nfunc Register(context *gin.Context) {\n\tvar service services.UserService\n\tuser := &models.User{}\n\terr := context.BindJSON(user)\n\tif err != nil {\n\t\tlog.Debug(\"failed to parse request, error: %v\", err)\n\t\tgoto FAIL\n\t}\n\tservice = services.GetUserService()\n\tif err = service.Register(user); err != nil {\n\t\tgoto FAIL\n\t}\n\trenderData(context, nil)\n\treturn\nFAIL:\n\trenderError(context, err)\n}\n\nfunc Activate(context *gin.Context) {\n\n}\n\nfunc Login(context *gin.Context) ", "output": "{\n\tvar service services.UserService\n\tuser := &models.User{}\n\terr := context.BindJSON(user)\n\tif err != nil {\n\t\tlog.Debug(\"failed to parse request data, error: %+v\", err)\n\t\tgoto FAIL\n\t}\n\tservice = services.GetUserService()\n\tif service.Auth(user.Email, user.Password) {\n\t\tsession := sessions.Default(context)\n\t\tsession.Set(\"uid\", user.Email)\n\t\tif err := session.Save(); err != nil {\n\t\t\tlog.Errorf(\"failed to save session, error: %+v\", err)\n\t\t}\n\t\trenderData(context, nil)\n\t\tlog.Debugf(\"user login successfully, user: %s\", user.Email)\n\t\treturn\n\t}\nFAIL:\n\trenderErrorCode(context, common.ErrUserPasswrod)\n}"}
{"input": "package uploader\n\nimport (\n\t\"errors\"\n\t\"github.com/matthew-andrews/s3up/objects\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype stubS3Client struct{}\n\nfunc (stub stubS3Client) UploadFile(bucket string, object objects.File) error {\n\tif object.Key == \"error\" {\n\t\treturn errors.New(\"synthetic error\")\n\t}\n\ttime.Sleep(50 * time.Millisecond)\n\treturn nil\n}\n\n\n\nfunc TestOneAtATime(t *testing.T) {\n\tduration := uploadThreeFilesWithConcurrency(1)\n\tif duration < 100 {\n\t\tt.Fatalf(\"uploader was too quick.  3 times 50ms one at a time can't be less than 100ms.  but it was %v\", duration)\n\t}\n}\n\nfunc TestThreeAtATime(t *testing.T) {\n\tduration := uploadThreeFilesWithConcurrency(3)\n\tif duration > 100 {\n\t\tt.Fatalf(\"uploader was too slow.  3 times 50ms three at a time can't be more than 100ms.  but it was %v\", duration)\n\t}\n}\n\nfunc TestErrorsAreEscalated(t *testing.T) {\n\terrors := Upload(stubS3Client{}, \"\", []objects.File{\n\t\tobjects.File{Key: \"error\"},\n\t\tobjects.File{},\n\t\tobjects.File{Key: \"error\"},\n\t}, 2)\n\tif len(errors) != 2 {\n\t\tt.Fatal(\"Uploader should have returned 2 errors\")\n\t}\n}\n\nfunc TestNoFiles(t *testing.T) {\n\terrs := Upload(stubS3Client{}, \"\", make([]objects.File, 0), 1)\n\tif strings.Contains(errs[0].Error(), \"No files found\") == false {\n\t\tt.Fatal(\"The error that was expected was not thrown\")\n\t}\n}\n\nfunc uploadThreeFilesWithConcurrency(concurrency int) int64 ", "output": "{\n\tstartTime := time.Now()\n\tUpload(stubS3Client{}, \"\", make([]objects.File, 3), concurrency)\n\tduration := time.Since(startTime).Nanoseconds()\n\treturn int64(duration / int64(time.Millisecond))\n}"}
{"input": "package buckettree\n\nimport (\n\t\"testing\"\n\n\t\"github.com/openblockchain/obc-peer/openchain/ledger/testutil\"\n)\n\nfunc TestDataKey(t *testing.T) {\n\tconf = newConfig(26, 3, fnvHash)\n\tdataKey := newDataKey(\"chaincodeID\", \"key\")\n\tencodedBytes := dataKey.getEncodedBytes()\n\tdataKeyFromEncodedBytes := newDataKeyFromEncodedBytes(encodedBytes)\n\ttestutil.AssertEquals(t, dataKey, dataKeyFromEncodedBytes)\n}\n\n\n\nfunc TestDataKeyGetBucketKey(t *testing.T) ", "output": "{\n\tconf = newConfig(26, 3, fnvHash)\n\tnewDataKey(\"chaincodeID1\", \"key1\").getBucketKey()\n\tnewDataKey(\"chaincodeID1\", \"key2\").getBucketKey()\n\tnewDataKey(\"chaincodeID2\", \"key1\").getBucketKey()\n\tnewDataKey(\"chaincodeID2\", \"key2\").getBucketKey()\n}"}
{"input": "package event\n\nimport (\n\t\"github.com/hyperledger/fabric-protos-go/gateway\"\n\t\"github.com/hyperledger/fabric-protos-go/peer\"\n\t\"github.com/hyperledger/fabric/common/ledger\"\n)\n\ntype ChaincodeEventsIterator struct {\n\tblockIter *BlockIterator\n}\n\n\n\nfunc (iter *ChaincodeEventsIterator) Next() (*gateway.ChaincodeEventsResponse, error) {\n\tfor {\n\t\tresult, err := iter.nextBlock()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif len(result.Events) > 0 {\n\t\t\treturn result, nil\n\t\t}\n\t}\n}\n\nfunc (iter *ChaincodeEventsIterator) nextBlock() (*gateway.ChaincodeEventsResponse, error) {\n\tblock, err := iter.blockIter.Next()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tevents, err := chaincodeEventsFromBlock(block)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult := &gateway.ChaincodeEventsResponse{\n\t\tBlockNumber: block.Number(),\n\t\tEvents:      events,\n\t}\n\treturn result, nil\n}\n\nfunc chaincodeEventsFromBlock(block *Block) ([]*peer.ChaincodeEvent, error) {\n\ttransactions, err := block.Transactions()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar results []*peer.ChaincodeEvent\n\n\tfor _, transaction := range transactions {\n\t\tif !transaction.Valid() {\n\t\t\tcontinue\n\t\t}\n\n\t\tevents, err := transaction.ChaincodeEvents()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, event := range events {\n\t\t\tresults = append(results, event.ProtoMessage())\n\t\t}\n\t}\n\n\treturn results, nil\n}\n\nfunc (iter *ChaincodeEventsIterator) Close() {\n\titer.blockIter.Close()\n}\n\nfunc NewChaincodeEventsIterator(iterator ledger.ResultsIterator) *ChaincodeEventsIterator ", "output": "{\n\treturn &ChaincodeEventsIterator{\n\t\tblockIter: NewBlockIterator(iterator),\n\t}\n}"}
{"input": "package midi\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype TimeSignature struct {\n\tNumerator                   uint8\n\tDenominator                 uint8\n\tClocksPerTick               uint8\n\tThirtySecondNotesPerQuarter uint8\n}\n\n\n\n\nfunc (ts *TimeSignature) String() string {\n\treturn fmt.Sprintf(\"%d/%d - %d clocks per tick - %d\", ts.Numerator, ts.Denum(), ts.ClocksPerTick, ts.ThirtySecondNotesPerQuarter)\n}\n\nfunc (ts *TimeSignature) Denum() int ", "output": "{\n\treturn int(math.Exp2(float64(ts.Denominator)))\n}"}
{"input": "package hiveConfig\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\n\ntype HiveConfig struct {\n\tServerURL    string               `json:\"server\"`\n\tTokensPath   string               `json:\"token_file_path\"`\n\tDeviceCodes  string               `json:\"device_codes_file_path\"`\n\tSecondsDelay int64                `json:\"delay\"`\n\tEndpoints    map[string]Endpoints `json:\"endpoints\"`\n}\n\n\ntype Endpoints struct {\n\tURL   string `json:\"url\"`\n\tDelay int    `json:\"delay\"`\n}\n\n\ntype Authtokens struct {\n\tTokens []string `json:\"tokens\"`\n}\n\n\ntype SadirLogins struct {\n\tLogins []string `json:\"sadira_logins\"`\n}\n\n\n\n\n\nfunc GetLogins(loginsFile string) (logins SadirLogins, err error) {\n\tjsonDoc, err := ioutil.ReadFile(loginsFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not read config file: %s \", err)\n\t\treturn\n\t}\n\terr = json.Unmarshal(jsonDoc, &logins)\n\treturn\n}\n\nfunc GetConfigJSON(jsonFile string) (cfg HiveConfig, err error) ", "output": "{\n\tjsonDoc, err := ioutil.ReadFile(jsonFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not read config file: %s \", err)\n\t\treturn\n\t}\n\terr = json.Unmarshal(jsonDoc, &cfg)\n\treturn cfg, err\n}"}
{"input": "package console\n\nimport \"github.com/cgrates/cgrates/utils\"\n\nfunc init() {\n\tc := &ImportTpFromFolder{\n\t\tname:      \"import_tp_from_folder\",\n\t\trpcMethod: utils.APIerSv1ImportTariffPlanFromFolder,\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}\n\n\ntype ImportTpFromFolder struct {\n\tname      string\n\trpcMethod string\n\trpcParams *utils.AttrImportTPFromFolder\n\trpcResult string\n\t*CommandExecuter\n}\n\nfunc (self *ImportTpFromFolder) Name() string {\n\treturn self.name\n}\n\nfunc (self *ImportTpFromFolder) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\nfunc (self *ImportTpFromFolder) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &utils.AttrImportTPFromFolder{}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *ImportTpFromFolder) PostprocessRpcParams() error {\n\treturn nil\n}\n\n\n\nfunc (self *ImportTpFromFolder) RpcResult() interface{} ", "output": "{\n\tvar s string\n\treturn &s\n}"}
{"input": "package rel\n\nimport (\n\t\"reflect\"\n)\n\ntype CountNode FunctionNode\n\nfunc Count() *CountNode {\n\treturn &CountNode{Expressions: []Visitable{Sql(1)}}\n}\n\nfunc (node *CountNode) Desc() *DescendingNode {\n\treturn orderingDesc(node)\n}\n\n\n\nfunc (node *CountNode) As(literal SqlLiteralNode) *AsNode {\n\treturn aliasPredicationAs(node, literal)\n}\n\nfunc (node *CountNode) Over(visitable Visitable) *OverNode {\n\treturn windowPredicationOver(node, visitable)\n}\n\nfunc (node CountNode) Eq(other CountNode) bool {\n\treturn reflect.DeepEqual(node, other)\n}\n\nfunc (node *CountNode) Asc() *AscendingNode ", "output": "{\n\treturn orderingAsc(node)\n}"}
{"input": "package fsnoder\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"hash/fnv\"\n\n\t\"srcd.works/go-git.v4/utils/merkletrie/noder\"\n)\n\n\ntype file struct {\n\tname     string \n\tcontents string\n\thash     []byte \n}\n\n\nfunc newFile(name, contents string) (*file, error) {\n\tif name == \"\" {\n\t\treturn nil, fmt.Errorf(\"files cannot have empty names\")\n\t}\n\n\treturn &file{\n\t\tname:     name,\n\t\tcontents: contents,\n\t}, nil\n}\n\n\n\nfunc (f *file) Hash() []byte {\n\tif f.hash == nil {\n\t\th := fnv.New64a()\n\t\th.Write([]byte(f.contents)) \n\t\tf.hash = h.Sum(nil)\n\t}\n\n\treturn f.hash\n}\n\n\n\nfunc (f *file) IsDir() bool {\n\treturn false\n}\n\nfunc (f *file) Children() ([]noder.Noder, error) {\n\treturn noder.NoChildren, nil\n}\n\nfunc (f *file) NumChildren() (int, error) {\n\treturn 0, nil\n}\n\nconst (\n\tfileStartMark = '<'\n\tfileEndMark   = '>'\n)\n\n\nfunc (f *file) String() string {\n\tvar buf bytes.Buffer\n\tbuf.WriteString(f.name)\n\tbuf.WriteRune(fileStartMark)\n\tbuf.WriteString(f.contents)\n\tbuf.WriteRune(fileEndMark)\n\n\treturn buf.String()\n}\n\nfunc (f *file) Name() string ", "output": "{\n\treturn f.name\n}"}
{"input": "package portmapper\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/golang/glog\"\n)\n\ntype PortMap struct {\n\tcontainerIP   string\n\tcontainerPort int\n}\n\nfunc newPortMap(containerip string, containerport int) *PortMap {\n\treturn &PortMap{\n\t\tcontainerIP:   containerip,\n\t\tcontainerPort: containerport,\n\t}\n}\n\ntype PortSet map[int]*PortMap\n\ntype PortMapper struct {\n\ttcpMap PortSet\n\tudpMap PortSet\n\tmutex  sync.Mutex\n}\n\nfunc New() *PortMapper {\n\treturn &PortMapper{PortSet{}, PortSet{}, sync.Mutex{}}\n}\n\nfunc (p *PortMapper) AllocateMap(protocol string, hostPort int,\n\tcontainerIP string, ContainerPort int) error {\n\tp.mutex.Lock()\n\tdefer p.mutex.Unlock()\n\n\tvar pset PortSet\n\n\tif strings.EqualFold(protocol, \"udp\") {\n\t\tpset = p.udpMap\n\t} else {\n\t\tpset = p.tcpMap\n\t}\n\n\te, ok := pset[hostPort]\n\tif ok {\n\t\treturn fmt.Errorf(\"Host port %d had already been used, %s %d\",\n\t\t\thostPort, e.containerIP, e.containerPort)\n\t}\n\n\tallocated := newPortMap(containerIP, ContainerPort)\n\tpset[hostPort] = allocated\n\n\treturn nil\n}\n\n\n\nfunc (p *PortMapper) ReleaseMap(protocol string, hostPort int) error ", "output": "{\n\tp.mutex.Lock()\n\tdefer p.mutex.Unlock()\n\n\tvar pset PortSet\n\n\tif strings.EqualFold(protocol, \"udp\") {\n\t\tpset = p.udpMap\n\t} else {\n\t\tpset = p.tcpMap\n\t}\n\n\t_, ok := pset[hostPort]\n\tif !ok {\n\t\tglog.Errorf(\"Host port %d has not been used\", hostPort)\n\t}\n\n\tdelete(pset, hostPort)\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Future (chan int)\n\nfunc futureMult(x int, y int) Future {\n\tvar c chan int = make(chan int)\n\tgo func() {\n\t\ttime.Sleep(3 * 1e9) \n\t\tc <- x * y\n\t}()\n\treturn c\n}\n\n\n\nfunc main() {\n\tvar f = futureMult(2, 3)\n\tdoSomeStuffWhileWeWaitForOurLongTakingComputation()\n\tfmt.Println(<-f)\n}\n\nfunc doSomeStuffWhileWeWaitForOurLongTakingComputation() ", "output": "{\n\tisPrime := true\n\tcandidate := 27644437\n\tfor i := 2; i < candidate; i++ {\n\t\tif candidate%2 == 0 {\n\t\t\tisPrime = false\n\t\t}\n\t}\n\tif isPrime {\n\t\tfmt.Println(\"prime\")\n\t} else {\n\t\tfmt.Println(\"not prime\")\n\t}\n}"}
{"input": "package event\n\nimport \"github.com/stretchr/testify/mock\"\n\n\ntype NetworkMock struct {\n\tmock.Mock\n}\n\n\n\n\nfunc (nm *NetworkMock) Send(address string, msg interface{}) error ", "output": "{\n\targs := nm.Called(address, msg)\n\treturn args.Error(0)\n}"}
{"input": "package logging_test\n\nimport (\n\t\"cloud.google.com/go/logging/apiv2\"\n\t\"golang.org/x/net/context\"\n\tloggingpb \"google.golang.org/genproto/googleapis/logging/v2\"\n)\n\nfunc ExampleNewConfigClient() {\n\tctx := context.Background()\n\tc, err := logging.NewConfigClient(ctx)\n\tif err != nil {\n\t}\n\t_ = c\n}\n\nfunc ExampleConfigClient_ListSinks() {\n\tctx := context.Background()\n\tc, err := logging.NewConfigClient(ctx)\n\tif err != nil {\n\t}\n\n\treq := &loggingpb.ListSinksRequest{\n\t}\n\tit := c.ListSinks(ctx, req)\n\tfor {\n\t\tresp, err := it.Next()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\t_ = resp\n\t}\n}\n\nfunc ExampleConfigClient_GetSink() {\n\tctx := context.Background()\n\tc, err := logging.NewConfigClient(ctx)\n\tif err != nil {\n\t}\n\n\treq := &loggingpb.GetSinkRequest{\n\t}\n\tresp, err := c.GetSink(ctx, req)\n\tif err != nil {\n\t}\n\t_ = resp\n}\n\nfunc ExampleConfigClient_CreateSink() {\n\tctx := context.Background()\n\tc, err := logging.NewConfigClient(ctx)\n\tif err != nil {\n\t}\n\n\treq := &loggingpb.CreateSinkRequest{\n\t}\n\tresp, err := c.CreateSink(ctx, req)\n\tif err != nil {\n\t}\n\t_ = resp\n}\n\n\n\nfunc ExampleConfigClient_DeleteSink() {\n\tctx := context.Background()\n\tc, err := logging.NewConfigClient(ctx)\n\tif err != nil {\n\t}\n\n\treq := &loggingpb.DeleteSinkRequest{\n\t}\n\terr = c.DeleteSink(ctx, req)\n\tif err != nil {\n\t}\n}\n\nfunc ExampleConfigClient_UpdateSink() ", "output": "{\n\tctx := context.Background()\n\tc, err := logging.NewConfigClient(ctx)\n\tif err != nil {\n\t}\n\n\treq := &loggingpb.UpdateSinkRequest{\n\t}\n\tresp, err := c.UpdateSink(ctx, req)\n\tif err != nil {\n\t}\n\t_ = resp\n}"}
{"input": "package install\n\nimport (\n\t\"time\"\n\n\t\"github.com/snapcore/snapd/gadget\"\n)\n\nvar (\n\tMakeFilesystem  = makeFilesystem\n\tWriteContent    = writeContent\n\tMountFilesystem = mountFilesystem\n\n\tCreateMissingPartitions = createMissingPartitions\n\tBuildPartitionList      = buildPartitionList\n\tRemoveCreatedPartitions = removeCreatedPartitions\n\tEnsureNodesExist        = ensureNodesExist\n\n\tCreatedDuringInstall = createdDuringInstall\n)\n\n\n\nfunc MockSysMount(f func(source, target, fstype string, flags uintptr, data string) error) (restore func()) {\n\told := sysMount\n\tsysMount = f\n\treturn func() {\n\t\tsysMount = old\n\t}\n}\n\nfunc MockSysUnmount(f func(target string, flags int) error) (restore func()) {\n\told := sysUnmount\n\tsysUnmount = f\n\treturn func() {\n\t\tsysUnmount = old\n\t}\n}\n\nfunc MockEnsureNodesExist(f func(dss []gadget.OnDiskStructure, timeout time.Duration) error) (restore func()) {\n\told := ensureNodesExist\n\tensureNodesExist = f\n\treturn func() {\n\t\tensureNodesExist = old\n\t}\n}\n\nfunc MockContentMountpoint(new string) (restore func()) ", "output": "{\n\told := contentMountpoint\n\tcontentMountpoint = new\n\treturn func() {\n\t\tcontentMountpoint = old\n\t}\n}"}
{"input": "package ocvp\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ListWorkRequestsRequest struct {\n\n\tCompartmentId *string `mandatory:\"true\" contributesTo:\"query\" name:\"compartmentId\"`\n\n\tResourceId *string `mandatory:\"false\" contributesTo:\"query\" name:\"resourceId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tPage *string `mandatory:\"false\" contributesTo:\"query\" name:\"page\"`\n\n\tLimit *int `mandatory:\"false\" contributesTo:\"query\" name:\"limit\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request ListWorkRequestsRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request ListWorkRequestsRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request ListWorkRequestsRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request ListWorkRequestsRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ListWorkRequestsResponse struct {\n\n\tRawResponse *http.Response\n\n\tWorkRequestCollection `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n\n\tOpcNextPage *string `presentIn:\"header\" name:\"opc-next-page\"`\n}\n\nfunc (response ListWorkRequestsResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\n\n\nfunc (response ListWorkRequestsResponse) HTTPResponse() *http.Response ", "output": "{\n\treturn response.RawResponse\n}"}
{"input": "package main\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n\n\t\"launchpad.net/xmlpath\"\n)\n\ntype RegexpGetter struct {\n\tpattern string\n}\n\ntype RegexpSubmatchGetter struct {\n\tpattern string\n}\n\ntype XpathGetter struct {\n\txpath string\n}\n\ntype Searcher interface {\n\tFind(input string) ([]string, bool)\n}\n\nfunc (getter RegexpGetter) Find(input string) ([]string, bool) {\n\tregexpId := regexp.MustCompile(getter.pattern)\n\tif regexpId.MatchString(input) {\n\t\treturn regexpId.FindAllString(input, -1), true\n\t}\n\treturn nil, false\n}\n\nfunc (getter RegexpSubmatchGetter) Find(input string) ([]string, bool) {\n\tif regexpId := regexp.MustCompile(getter.pattern); regexpId.MatchString(input) {\n\t\tresponse := regexpId.FindAllStringSubmatch(input, -1)\n\t\tresult := make([]string, len(response))\n\t\tfor index := 0; index < len(response); index++ {\n\t\t\tresult[index] = response[index][1]\n\t\t}\n\t\treturn result, true\n\t}\n\treturn nil, false\n}\n\n\n\nfunc getFromIterator(iterator *xmlpath.Iter) []string {\n\tresponse := make([]string, 0)\n\tindex := 0\n\tfor iterator.Next() {\n\t\tresponse[index] = iterator.Node().String()\n\t\tindex++\n\t}\n\treturn response\n}\n\nfunc (getter XpathGetter) Find(input string) ([]string, bool) ", "output": "{\n\tpath := xmlpath.MustCompile(getter.xpath)\n\troot, err := xmlpath.Parse(strings.NewReader(input))\n\tif err != nil {\n\t\treturn nil, false\n\t}\n\treturn getFromIterator(path.Iter(root)), true\n}"}
{"input": "package client\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"google.golang.org/grpc/status\"\n\t\"google.golang.org/protobuf/encoding/prototext\"\n\t\"google.golang.org/protobuf/proto\"\n\n\t_ \"google.golang.org/genproto/googleapis/rpc/errdetails\" \n)\n\n\ntype StatusError struct {\n\tst      *status.Status\n\tdetails string\n}\n\n\n\n\nfunc (e *StatusError) Error() string {\n\tmsg := fmt.Sprintf(\"rpc error: code = %s desc = %s\", e.st.Code(), e.st.Message())\n\tif e.details != \"\" {\n\t\tmsg += \" details = \" + e.details\n\t}\n\treturn msg\n}\n\n\nfunc (e *StatusError) GRPCStatus() *status.Status {\n\treturn e.st\n}\n\n\n\nfunc (e *StatusError) Is(target error) bool {\n\tif tse, ok := target.(*StatusError); ok {\n\t\treturn proto.Equal(e.st.Proto(), tse.st.Proto())\n\t}\n\tif tst, ok := status.FromError(target); ok {\n\t\treturn proto.Equal(e.st.Proto(), tst.Proto())\n\t}\n\treturn false\n}\n\nfunc StatusDetailedError(st *status.Status) *StatusError ", "output": "{\n\tvar details []string\n\tfor _, d := range st.Details() {\n\t\ts := fmt.Sprintf(\"%+v\", d)\n\t\tif pb, ok := d.(proto.Message); ok {\n\t\t\ts = prototext.Format(pb)\n\t\t}\n\t\tdetails = append(details, s)\n\t}\n\treturn &StatusError{st, strings.Join(details, \"; \")}\n}"}
{"input": "package trustmanager\n\nimport (\n\t\"os\"\n\t\"sync\"\n)\n\n\n\ntype MemoryFileStore struct {\n\tsync.Mutex\n\n\tfiles map[string][]byte\n}\n\n\n\n\n\nfunc (f *MemoryFileStore) Add(name string, data []byte) error {\n\tf.Lock()\n\tdefer f.Unlock()\n\n\tf.files[name] = data\n\treturn nil\n}\n\n\nfunc (f *MemoryFileStore) Remove(name string) error {\n\tf.Lock()\n\tdefer f.Unlock()\n\n\tif _, present := f.files[name]; !present {\n\t\treturn os.ErrNotExist\n\t}\n\tdelete(f.files, name)\n\n\treturn nil\n}\n\n\nfunc (f *MemoryFileStore) Get(name string) ([]byte, error) {\n\tf.Lock()\n\tdefer f.Unlock()\n\n\tfileData, present := f.files[name]\n\tif !present {\n\t\treturn nil, os.ErrNotExist\n\t}\n\n\treturn fileData, nil\n}\n\n\nfunc (f *MemoryFileStore) ListFiles() []string {\n\tvar list []string\n\n\tfor name := range f.files {\n\t\tlist = append(list, name)\n\t}\n\n\treturn list\n}\n\nfunc NewMemoryFileStore() *MemoryFileStore ", "output": "{\n\treturn &MemoryFileStore{\n\t\tfiles: make(map[string][]byte),\n\t}\n}"}
{"input": "package goparsify\n\nimport (\n\t\"strconv\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\n\ntype State struct {\n\tInput string\n\tPos int\n\tCut int\n\tError Error\n\tWS VoidParser\n}\n\n\n\n\n\n\n\nfunc UnicodeWhitespace(s *State) {\n\tfor s.Pos < len(s.Input) {\n\t\tr, w := utf8.DecodeRuneInString(s.Get())\n\t\tif !unicode.IsSpace(r) {\n\t\t\treturn\n\t\t}\n\t\ts.Pos += w\n\t}\n}\n\n\nfunc NoWhitespace(s *State) {\n\n}\n\n\nfunc NewState(input string) *State {\n\treturn &State{\n\t\tInput: input,\n\t\tWS:    UnicodeWhitespace,\n\t}\n}\n\n\nfunc (s *State) Advance(i int) {\n\ts.Pos += i\n}\n\n\nfunc (s *State) Get() string {\n\tif s.Pos > len(s.Input) {\n\t\treturn \"\"\n\t}\n\treturn s.Input[s.Pos:]\n}\n\n\nfunc (s *State) Preview(x int) string {\n\tif s.Pos >= len(s.Input) {\n\t\treturn \"\"\n\t}\n\n\tquoted := strconv.Quote(s.Get())\n\tquoted = quoted[1 : len(quoted)-1]\n\tif len(quoted) >= x {\n\t\treturn quoted[0:x]\n\t}\n\n\treturn quoted\n}\n\n\nfunc (s *State) ErrorHere(expected string) {\n\ts.Error.pos = s.Pos\n\ts.Error.expected = expected\n}\n\n\n\nfunc (s *State) Recover() {\n\ts.Error.expected = \"\"\n}\n\n\nfunc (s *State) Errored() bool {\n\treturn s.Error.expected != \"\"\n}\n\nfunc ASCIIWhitespace(s *State) ", "output": "{\n\tfor s.Pos < len(s.Input) {\n\t\tswitch s.Input[s.Pos] {\n\t\tcase '\\t', '\\n', '\\v', '\\f', '\\r', ' ':\n\t\t\ts.Pos++\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"input": "package release_v1_4\n\nimport (\n\t\"github.com/golang/glog\"\n\tv1core \"github.com/openshift/origin/pkg/project/client/clientset_generated/release_v1_4/typed/core/v1\"\n\trestclient \"k8s.io/kubernetes/pkg/client/restclient\"\n\tdiscovery \"k8s.io/kubernetes/pkg/client/typed/discovery\"\n\t\"k8s.io/kubernetes/pkg/util/flowcontrol\"\n)\n\ntype Interface interface {\n\tDiscovery() discovery.DiscoveryInterface\n\tCore() v1core.CoreInterface\n}\n\n\n\ntype Clientset struct {\n\t*discovery.DiscoveryClient\n\t*v1core.CoreClient\n}\n\n\nfunc (c *Clientset) Core() v1core.CoreInterface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.CoreClient\n}\n\n\nfunc (c *Clientset) Discovery() discovery.DiscoveryInterface {\n\treturn c.DiscoveryClient\n}\n\n\n\n\n\n\nfunc NewForConfigOrDie(c *restclient.Config) *Clientset {\n\tvar clientset Clientset\n\tclientset.CoreClient = v1core.NewForConfigOrDie(c)\n\n\tclientset.DiscoveryClient = discovery.NewDiscoveryClientForConfigOrDie(c)\n\treturn &clientset\n}\n\n\nfunc New(c *restclient.RESTClient) *Clientset {\n\tvar clientset Clientset\n\tclientset.CoreClient = v1core.New(c)\n\n\tclientset.DiscoveryClient = discovery.NewDiscoveryClient(c)\n\treturn &clientset\n}\n\nfunc NewForConfig(c *restclient.Config) (*Clientset, error) ", "output": "{\n\tconfigShallowCopy := *c\n\tif configShallowCopy.RateLimiter == nil && configShallowCopy.QPS > 0 {\n\t\tconfigShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)\n\t}\n\tvar clientset Clientset\n\tvar err error\n\tclientset.CoreClient, err = v1core.NewForConfig(&configShallowCopy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclientset.DiscoveryClient, err = discovery.NewDiscoveryClientForConfig(&configShallowCopy)\n\tif err != nil {\n\t\tglog.Errorf(\"failed to create the DiscoveryClient: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn &clientset, nil\n}"}
{"input": "package rummy\n\nimport (\n\t\"github.com/timpalpant/rummy/deck\"\n\t\"github.com/timpalpant/rummy/meld\"\n\t\"github.com/timpalpant/rummy/scoring\"\n)\n\n\ntype player struct {\n\tname string\n\thand Hand\n\tmelds []meld.Meld\n\trummies []deck.Card\n}\n\n\n\n\nfunc (p player) Score() int {\n\ttotal := p.PublicScore()\n\tfor card := range p.hand {\n\t\ttotal -= scoring.Value(card)\n\t}\n\n\treturn total\n}\n\n\n\n\n\nfunc (p player) PublicScore() int ", "output": "{\n\ttotal := 0\n\tfor _, m := range p.melds {\n\t\ttotal += m.Value()\n\t}\n\tfor _, card := range p.rummies {\n\t\ttotal += scoring.Value(card)\n\t}\n\treturn total\n}"}
{"input": "package rsync\n\nimport (\n\t\"os\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseProgress(t *testing.T) {\n\ttestDir := \"testdata/download1.txt\"\n\tdownload1, err := os.Open(testDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to open test file, err:%s\", err)\n\t}\n\tdefer download1.Close()\n\n\tprogresses := []int{}\n\tfor p := range ParseProgress(download1) {\n\t\tprogresses = append(progresses, p)\n\t}\n\n\texpectedProgresses := []int{\n\t\t14647296,\n\t\t34242560,\n\t\t40984576,\n\t\t40986547,\n\t\t40988167,\n\t\t40989739,\n\t\t40999633,\n\t\t41001295,\n\t}\n\n\tif !reflect.DeepEqual(progresses, expectedProgresses) {\n\t\tt.Errorf(\n\t\t\t\"Progresses from download1.txt did not parse properly. expected:%q, got:%q\",\n\t\t\texpectedProgresses, progresses,\n\t\t)\n\t}\n}\n\n\n\nfunc TestParseProgressLine(t *testing.T) ", "output": "{\n\t_, err := ParseProgressLine(\"\")\n\tif err != NotProgressableErr {\n\t\tt.Errorf(\"Expected an empty input to be NotProgressableErr. got:%s\", err)\n\t}\n\n\tp, err := ParseProgressLine(\n\t\t\"    40984576 100%    2.44MB/s    0:00:15 (xfer#1, to-check=5/7)\",\n\t)\n\tif err != nil {\n\t\tt.Errorf(\"Encountered unexpected error. err:%s\", err)\n\t}\n\n\tif p != 40984576 {\n\t\tt.Errorf(\"Unexpected progress result. wanted:%d, got:%d\", 40984576, p)\n\t}\n\n\t_, err = ParseProgressLine(\"7 files to consider\")\n\tif err != NotProgressableErr {\n\t\tt.Errorf(\"Expected an empty input to be NotProgressableErr. got:%s\", err)\n\t}\n}"}
{"input": "package openstackmodel\n\nimport \"k8s.io/kops/upup/pkg/fi\"\n\n\nfunc s(v string) *string {\n\treturn fi.String(v)\n}\n\n\nfunc i64(v int64) *int64 {\n\treturn fi.Int64(v)\n}\n\n\nfunc i32(v int32) *int32 {\n\treturn fi.Int32(v)\n}\n\n\n\n\nfunc i(v int) *int ", "output": "{\n\treturn fi.Int(v)\n}"}
{"input": "package builder\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/skygeario/skygear-server/pkg/server/skydb\"\n)\n\n\n\n\nfunc funcOrderBySQL(alias string, fun skydb.Func) (string, error) {\n\tswitch f := fun.(type) {\n\tcase skydb.DistanceFunc:\n\t\tsql := fmt.Sprintf(\n\t\t\t\"ST_Distance_Sphere(%s, ST_MakePoint(%f, %f))\",\n\t\t\tfullQuoteIdentifier(alias, f.Field),\n\t\t\tf.Location.Lng(),\n\t\t\tf.Location.Lat(),\n\t\t)\n\t\treturn sql, nil\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"got unrecgonized skydb.Func = %T\", fun)\n\t}\n}\n\nfunc sortOrderOrderBySQL(order skydb.SortOrder) (string, error) {\n\tswitch order {\n\tcase skydb.Asc:\n\t\treturn \"ASC\", nil\n\tcase skydb.Desc:\n\t\treturn \"DESC\", nil\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unknown sort order = %v\", order)\n\t}\n}\n\nfunc SortOrderBySQL(alias string, sort skydb.Sort) (string, error) ", "output": "{\n\tvar expr string\n\n\tswitch sort.Expression.Type {\n\tcase skydb.KeyPath:\n\t\texpr = fullQuoteIdentifier(alias, sort.Expression.Value.(string))\n\tcase skydb.Function:\n\t\tvar err error\n\t\texpr, err = funcOrderBySQL(alias, sort.Expression.Value.(skydb.Func))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\tdefault:\n\t\treturn \"\", errors.New(\"invalid Sort: specify either KeyPath or Func\")\n\t}\n\n\torder, err := sortOrderOrderBySQL(sort.Order)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(expr + \" \" + order), nil\n}"}
{"input": "package vdlog\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\n\n\nfunc TestLog(t *testing.T) ", "output": "{\n\tSetConsoleVerbosity(LevelSilly)\n\n\tEmitSilly(\"testFacility\", H{\"testing\": \"test\"})\n\tEmitVerbose(\"testFacility\", H{\"testing\": \"test\"})\n\tEmitDebug(\"testFacility\", H{\"testing\": \"test\"})\n\tEmitInfo(\"testFacility\", H{\"testing\": \"test\"})\n\tEmitWarn(\"testFacility\", H{\"testing\": \"test\"})\n\tEmitError(\"testFacility\", fmt.Errorf(\"some test %s\", \"error\"), H{\"testing\": \"test\"})\n\n\ttime.Sleep(100 * time.Millisecond)\n}"}
{"input": "package configuration\n\n\n\n\n\ntype ConfigNotImplementedError struct {\n\tstr string\n}\n\n\nfunc NewConfigNotImplementedError(s string) *ConfigNotImplementedError {\n\treturn &ConfigNotImplementedError{str: s}\n}\n\n\nfunc (e *ConfigNotImplementedError) Error() string {\n\treturn e.str\n}\n\n\n\ntype ConfigNotConfiguredError struct {\n\tstr string\n}\n\n\nfunc NewConfigNotConfiguredError(s string) *ConfigNotConfiguredError {\n\treturn &ConfigNotConfiguredError{str: s}\n}\n\n\nfunc (e *ConfigNotConfiguredError) Error() string {\n\treturn e.str\n}\n\n\ntype HJSONConfigError struct {\n\tstr string\n}\n\n\nfunc NewHJSONConfigError(s string) *HJSONConfigError {\n\treturn &HJSONConfigError{str: s}\n}\n\n\nfunc (e *HJSONConfigError) Error() string {\n\treturn e.str\n}\n\n\ntype ConfigUsageError struct {\n\tstr string\n}\n\n\nfunc NewConfigUsageError(s string) *ConfigUsageError {\n\treturn &ConfigUsageError{str: s}\n}\n\n\nfunc (e *ConfigUsageError) Error() string {\n\treturn e.str\n}\n\n\ntype ConfigItemNotFound struct {\n\tstr string\n}\n\n\nfunc NewConfigItemNotFound(s string) *ConfigItemNotFound {\n\treturn &ConfigItemNotFound{str: s}\n}\n\n\n\n\n\ntype ConfigTypeMismatchError struct {\n\tstr string\n}\n\n\nfunc NewConfigTypeMismatchError(s string) *ConfigTypeMismatchError {\n\treturn &ConfigTypeMismatchError{str: s}\n}\n\n\nfunc (e *ConfigTypeMismatchError) Error() string {\n\treturn e.str\n}\n\nfunc (e *ConfigItemNotFound) Error() string ", "output": "{\n\treturn e.str\n}"}
{"input": "package net\n\nimport (\n\t\"net\"\n\t\"reflect\"\n\n\t\"github.com/segmentio/objconv\"\n)\n\nfunc init() {\n\tobjconv.Install(reflect.TypeOf(net.TCPAddr{}), TCPAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.UDPAddr{}), UDPAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.UnixAddr{}), UnixAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.IPAddr{}), IPAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.IP(nil)), IPAdapter())\n}\n\n\nfunc TCPAddrAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeTCPAddr,\n\t\tDecode: decodeTCPAddr,\n\t}\n}\n\n\nfunc UDPAddrAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeUDPAddr,\n\t\tDecode: decodeUDPAddr,\n\t}\n}\n\n\nfunc UnixAddrAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeUnixAddr,\n\t\tDecode: decodeUnixAddr,\n\t}\n}\n\n\n\n\n\nfunc IPAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeIP,\n\t\tDecode: decodeIP,\n\t}\n}\n\nfunc IPAddrAdapter() objconv.Adapter ", "output": "{\n\treturn objconv.Adapter{\n\t\tEncode: encodeIPAddr,\n\t\tDecode: decodeIPAddr,\n\t}\n}"}
{"input": "package golog\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/mndrix/golog/term\"\n\t\"github.com/mndrix/ps\"\n)\n\n\n\n\n\n\ntype clauses struct {\n\tn         int64 \n\tlowestId  int64\n\thighestId int64\n\tterms     ps.Map \n}\n\n\nfunc newClauses() *clauses {\n\tvar cs clauses\n\tcs.terms = ps.NewMap()\n\treturn &cs\n}\n\n\nfunc (self *clauses) count() int64 {\n\treturn self.n\n}\n\n\nfunc (self *clauses) cons(t term.Term) *clauses {\n\tcs := self.clone()\n\tcs.n++\n\tcs.lowestId--\n\tkey := strconv.FormatInt(cs.lowestId, 10)\n\tcs.terms = self.terms.Set(key, t)\n\treturn cs\n}\n\n\nfunc (self *clauses) snoc(t term.Term) *clauses {\n\tcs := self.clone()\n\tcs.n++\n\tcs.highestId++\n\tkey := strconv.FormatInt(cs.highestId, 10)\n\tcs.terms = self.terms.Set(key, t)\n\treturn cs\n}\n\n\n\n\n\nfunc (self *clauses) forEach(f func(term.Term)) {\n\tfor _, t := range self.all() {\n\t\tf(t)\n\t}\n}\n\n\nfunc (self *clauses) clone() *clauses {\n\tcs := *self\n\treturn &cs\n}\n\nfunc (self *clauses) all() []term.Term ", "output": "{\n\tterms := make([]term.Term, 0)\n\tif self.count() == 0 {\n\t\treturn terms\n\t}\n\n\tfor i := self.lowestId; i <= self.highestId; i++ {\n\t\tkey := strconv.FormatInt(i, 10)\n\t\tt, ok := self.terms.Lookup(key)\n\t\tif ok {\n\t\t\tterms = append(terms, t.(term.Term))\n\t\t}\n\t}\n\treturn terms\n}"}
{"input": "package dao\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc Test_LoadAllBangumi(t *testing.T) {\n\tConvey(\"LoadAllBangumi\", t, func() {\n\t\tetam, err := d.LoadAllBangumi(context.TODO())\n\t\tSo(err, ShouldBeNil)\n\t\tSo(etam, ShouldNotBeNil)\n\t\tfor epid, aid := range etam {\n\t\t\tPrintf(\"epid:%d,aid:%d\\n\", epid, aid)\n\t\t}\n\t})\n}\n\n\n\nfunc Test_IsLegal(t *testing.T) ", "output": "{\n\tConvey(\"IsLegal\", t, func() {\n\t\tisLegal, err := d.IsLegal(context.TODO(), 11696747, 157927, 1)\n\t\tSo(err, ShouldBeNil)\n\t\tPrintln(isLegal)\n\t})\n}"}
{"input": "package eval\n\nimport (\n\t\"reflect\"\n)\n\n\n\nfunc EvalIdent(ident *Ident, env Env) (reflect.Value, error) ", "output": "{\n\tif ident.IsConst() {\n\t\treturn ident.Const(), nil\n\t}\n\n\tname := ident.Name\n\tswitch ident.source {\n\tcase EnvVar:\n\t\tfor searchEnv := env; searchEnv != nil; searchEnv = searchEnv.PopScope() {\n\t\t\tif v := searchEnv.Var(name); v.IsValid() {\n\t\t\t\treturn v.Elem(), nil\n\t\t\t}\n\t\t}\n\tcase EnvFunc:\n\t\tfor searchEnv := env; searchEnv != nil; searchEnv = searchEnv.PopScope() {\n\t\t\tif v := searchEnv.Func(name); v.IsValid() {\n\t\t\t\treturn v, nil\n\t\t\t}\n\t\t}\n\t}\n\tpanic(dytc(\"missing identifier '\"+name+\"'\"))\n}"}
{"input": "package redux\n\nimport (\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n)\n\ntype Hash string\n\nfunc MakeHash(content interface{}) Hash {\n\n\thash := sha1.New()\n\n\tswitch c := content.(type) {\n\tcase []byte:\n\t\thash.Write(c)\n\tcase string:\n\t\thash.Write([]byte(c))\n\tdefault:\n\t\tpanic(fmt.Errorf(\"Unhandled argument: %+v\", content))\n\t}\n\n\treturn Hash(hex.EncodeToString(hash.Sum(nil)))\n}\n\n\n\nfunc ContentHash(path string) (hash Hash, err error) ", "output": "{\n\tb, err := ioutil.ReadFile(path)\n\tif err == nil {\n\t\thash = MakeHash(b)\n\t}\n\treturn\n}"}
{"input": "package models\n\n\n\n\nimport (\n\t\"context\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\n\ntype CompletedRequest struct {\n\n\tRedirectTo *string `json:\"redirect_to\"`\n}\n\n\n\n\nfunc (m *CompletedRequest) validateRedirectTo(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"redirect_to\", \"body\", m.RedirectTo); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc (m *CompletedRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\treturn nil\n}\n\n\nfunc (m *CompletedRequest) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\nfunc (m *CompletedRequest) UnmarshalBinary(b []byte) error {\n\tvar res CompletedRequest\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *CompletedRequest) Validate(formats strfmt.Registry) error ", "output": "{\n\tvar res []error\n\n\tif err := m.validateRedirectTo(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package storage\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"testing\"\n)\n\n\n\nfunc TestResumeUploadPutFile(t *testing.T) ", "output": "{\n\tvar putRet PutRet\n\tctx := context.TODO()\n\tputPolicy := PutPolicy{\n\t\tScope:           testBucket,\n\t\tDeleteAfterDays: 7,\n\t}\n\tupToken := putPolicy.UploadToken(mac)\n\ttestKey := fmt.Sprintf(\"testRPutFileKey_%d\", rand.Int())\n\n\terr := resumeUploader.PutFile(ctx, &putRet, upToken, testKey, testLocalFile, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"ResumeUploader#PutFile() error, %s\", err)\n\t}\n\tt.Logf(\"Key: %s, Hash:%s\", putRet.Key, putRet.Hash)\n}"}
{"input": "package service\n\nimport (\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\n\n\n\nfunc TestServiceBuyVipWithPoint(t *testing.T) {\n\tConvey(\" BuyVipWithPoint test \", t, func() {\n\t\terr := s.BuyVipWithPoint(c, int64(2), 1)\n\t\tSo(err, ShouldBeNil)\n\t})\n}\n\nfunc TestServicePointRule(t *testing.T) ", "output": "{\n\tConvey(\" PointRule test \", t, func() {\n\t\t_, err := s.PointRule(c)\n\t\tSo(err, ShouldBeNil)\n\t})\n}"}
{"input": "package util\n\nimport (\n\t\"path\"\n\t\"strings\"\n\n\t\"github.com/mholt/archiver/v3\"\n\t\"github.com/nuclio/errors\"\n\t\"github.com/nuclio/logger\"\n)\n\ntype Decompressor struct {\n\tlogger logger.Logger\n}\n\nfunc NewDecompressor(parentLogger logger.Logger) (*Decompressor, error) {\n\tnewDecompressor := &Decompressor{\n\t\tlogger: parentLogger,\n\t}\n\n\treturn newDecompressor, nil\n}\n\nfunc (d *Decompressor) Decompress(source string, target string) error {\n\tif err := archiver.Unarchive(source, target); err != nil {\n\t\treturn errors.Wrapf(err, \"Failed to decompress file %s\", source)\n\t}\n\n\treturn nil\n}\n\n\n\nfunc IsJar(source string) bool {\n\treturn strings.ToLower(path.Ext(source)) == \".jar\"\n}\n\nfunc IsCompressed(source string) bool ", "output": "{\n\n\tif IsJar(source) {\n\t\treturn false\n\t}\n\n\tunarchiver, err := archiver.ByExtension(source)\n\tif err != nil {\n\t\treturn false\n\t}\n\tu, ok := unarchiver.(archiver.Unarchiver)\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn u != nil\n}"}
{"input": "package vspk\n\nimport \"github.com/nuagenetworks/go-bambou/bambou\"\n\n\nvar OverlayManagementSubnetProfileIdentity = bambou.Identity{\n\tName:     \"overlaymanagementsubnetprofile\",\n\tCategory: \"overlaymanagementsubnetprofiles\",\n}\n\n\ntype OverlayManagementSubnetProfilesList []*OverlayManagementSubnetProfile\n\n\n\n\ntype OverlayManagementSubnetProfilesAncestor interface {\n\tOverlayManagementSubnetProfiles(*bambou.FetchingInfo) (OverlayManagementSubnetProfilesList, *bambou.Error)\n}\n\n\n\n\ntype OverlayManagementSubnetProfilesParent interface {\n\tOverlayManagementSubnetProfilesAncestor\n\tCreateOverlayManagementSubnetProfile(*OverlayManagementSubnetProfile) *bambou.Error\n}\n\n\ntype OverlayManagementSubnetProfile struct {\n\tID                    string        `json:\"ID,omitempty\"`\n\tParentID              string        `json:\"parentID,omitempty\"`\n\tParentType            string        `json:\"parentType,omitempty\"`\n\tOwner                 string        `json:\"owner,omitempty\"`\n\tName                  string        `json:\"name,omitempty\"`\n\tDescription           string        `json:\"description,omitempty\"`\n\tAssociatedDNASubnetID string        `json:\"associatedDNASubnetID,omitempty\"`\n\tSyslogDestinationIDs  []interface{} `json:\"syslogDestinationIDs,omitempty\"`\n}\n\n\n\n\n\nfunc (o *OverlayManagementSubnetProfile) Identity() bambou.Identity {\n\n\treturn OverlayManagementSubnetProfileIdentity\n}\n\n\nfunc (o *OverlayManagementSubnetProfile) Identifier() string {\n\n\treturn o.ID\n}\n\n\nfunc (o *OverlayManagementSubnetProfile) SetIdentifier(ID string) {\n\n\to.ID = ID\n}\n\n\nfunc (o *OverlayManagementSubnetProfile) Fetch() *bambou.Error {\n\n\treturn bambou.CurrentSession().FetchEntity(o)\n}\n\n\nfunc (o *OverlayManagementSubnetProfile) Save() *bambou.Error {\n\n\treturn bambou.CurrentSession().SaveEntity(o)\n}\n\n\nfunc (o *OverlayManagementSubnetProfile) Delete() *bambou.Error {\n\n\treturn bambou.CurrentSession().DeleteEntity(o)\n}\n\nfunc NewOverlayManagementSubnetProfile() *OverlayManagementSubnetProfile ", "output": "{\n\n\treturn &OverlayManagementSubnetProfile{}\n}"}
{"input": "package helpers\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"runtime\"\n)\n\n\n\nfunc BytesToUint16(field [2]byte) uint16 {\n\treturn uint16(field[0])<<8 | uint16(field[1])\n}\n\n\n\nfunc Uint16ToBytes(value uint16) [2]byte {\n\tbyte0 := byte(value >> 8)\n\tbyte1 := byte(0x00ff & value) \n\treturn [2]byte{byte0, byte1}\n}\n\n\n\n\n\n\n\n\n\nfunc GetBytes(b *bytes.Buffer, n int) []byte {\n\tslice := make([]byte, n)\n\tnread, err := b.Read(slice)\n\tif err != nil || nread != n {\n\t\tpanic(errors.New(\"Unexpected end of data.\"))\n\t}\n\treturn slice\n}\n\n\n\n\nfunc GetByte(b *bytes.Buffer) byte {\n\tbyte, err := b.ReadByte()\n\tif err != nil {\n\t\tpanic(errors.New(\"Unexpected end of data\"))\n\t}\n\treturn byte\n}\n\n\n\n\n\n\nfunc HandleErrorPanic(err *error, functionName string) ", "output": "{\n\tif r := recover(); r != nil {\n\t\tif _, ok := r.(runtime.Error); ok {\n\t\t\tpanic(r)\n\t\t}\n\t\tperr := r.(error)\n\t\t*err = errors.New(functionName + \": \" + perr.Error())\n\t}\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\ntype JProxyFilter struct {\n\n\tID string `json:\"_id,omitempty\"`\n\n\tCreatedAt strfmt.Date `json:\"createdAt,omitempty\"`\n\n\tModifiedAt strfmt.Date `json:\"modifiedAt,omitempty\"`\n\n\tName *string `json:\"name\"`\n\n\tOwner string `json:\"owner,omitempty\"`\n\n\tRules []interface{} `json:\"rules\"`\n}\n\n\n\n\nfunc (m *JProxyFilter) validateName(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"name\", \"body\", m.Name); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *JProxyFilter) validateRules(formats strfmt.Registry) error {\n\n\tif swag.IsZero(m.Rules) { \n\t\treturn nil\n\t}\n\n\tfor i := 0; i < len(m.Rules); i++ {\n\n\t}\n\n\treturn nil\n}\n\nfunc (m *JProxyFilter) Validate(formats strfmt.Registry) error ", "output": "{\n\tvar res []error\n\n\tif err := m.validateName(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validateRules(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSOpsWorksStack_ElasticIp struct {\n\n\tIp string `json:\"Ip,omitempty\"`\n\n\tName string `json:\"Name,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSOpsWorksStack_ElasticIp) AWSCloudFormationType() string {\n\treturn \"AWS::OpsWorks::Stack.ElasticIp\"\n}\n\n\n\nfunc (r *AWSOpsWorksStack_ElasticIp) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSOpsWorksStack_ElasticIp) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSOpsWorksStack_ElasticIp) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\n\n\n\n\nfunc (r *AWSOpsWorksStack_ElasticIp) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSOpsWorksStack_ElasticIp) SetMetadata(metadata map[string]interface{}) ", "output": "{\n\tr._metadata = metadata\n}"}
{"input": "package bosh\n\nimport (\n\t\"github.com/FidelityInternational/virgil/utility\"\n\t\"github.com/cloudfoundry-community/gogobosh\"\n\t\"regexp\"\n)\n\n\nfunc FindDeployment(deployments []gogobosh.Deployment, regex string) string {\n\tfor _, deployment := range deployments {\n\t\tmatched, _ := regexp.MatchString(regex, deployment.Name)\n\t\tif matched {\n\t\t\treturn deployment.Name\n\t\t}\n\t}\n\treturn \"\"\n}\n\n\nfunc FindVMs(deploymentVMs []gogobosh.VM, regex string) []gogobosh.VM {\n\tvar matchedVMs []gogobosh.VM\n\tfor _, deploymentVM := range deploymentVMs {\n\t\tmatched, _ := regexp.MatchString(regex, deploymentVM.JobName)\n\t\tif matched {\n\t\t\tmatchedVMs = append(matchedVMs, deploymentVM)\n\t\t}\n\t}\n\treturn matchedVMs\n}\n\n\n\n\nfunc GetAllIPs(deploymentVms []gogobosh.VM) []string ", "output": "{\n\tvar ips []string\n\tfor _, deployment := range deploymentVms {\n\t\tips = append(ips, deployment.IPs...)\n\t}\n\tutility.RemoveDuplicates(&ips)\n\treturn ips\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/alexandres/poormanscdn/client\"\n)\n\nvar path, cdnUrl, method, refererHost, userHost, secret string\nvar modified, expires int64\n\n\n\nfunc main() {\n\tflag.Parse()\n\tif cdnUrl == \"\" || secret == \"\" {\n\t\tlog.Fatal(\"cdnurl and secret are mandatory\")\n\t}\n\tlastModifiedAt := time.Unix(modified, 0)\n\texpiresAt := time.Unix(expires, 0)\n\tp := client.SigParams{\n\t\tMethod:      method,\n\t\tPath:        client.TrimPath(path),\n\t\tUserHost:    userHost,\n\t\tRefererHost: refererHost,\n\t\tModified:    lastModifiedAt,\n\t\tExpires:     expiresAt,\n\t}\n\turl, err := client.GetSignedUrl(secret, cdnUrl, p)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Print(url)\n}\n\nfunc init() ", "output": "{\n\tflag.StringVar(&cdnUrl, \"cdnurl\", \"\", \"cdnurl\")\n\tflag.StringVar(&method, \"method\", \"GET\", \"method\")\n\tflag.StringVar(&refererHost, \"refererhost\", \"\", \"restrict referer host\")\n\tflag.StringVar(&userHost, \"userhost\", \"\", \"restrict user host\")\n\tflag.Int64Var(&modified, \"modified\", 0, \"modified\")\n\tflag.Int64Var(&expires, \"expires\", 0, \"expires\")\n\tflag.StringVar(&path, \"path\", \"\", \"path\")\n\tflag.StringVar(&secret, \"secret\", \"\", \"secret\")\n}"}
{"input": "package iso20022\n\n\ntype TransactionTotals6 struct {\n\n\tAuthorisation *Number `xml:\"Authstn,omitempty\"`\n\n\tAuthorisationReversal *Number `xml:\"AuthstnRvsl,omitempty\"`\n\n\tInquiry *Number `xml:\"Nqry,omitempty\"`\n\n\tInquiryReversal *Number `xml:\"NqryRvsl,omitempty\"`\n\n\tPayments *Number `xml:\"Pmts,omitempty\"`\n\n\tPaymentReversal *Number `xml:\"PmtRvsl,omitempty\"`\n\n\tTransfer *Number `xml:\"Trf,omitempty\"`\n\n\tTransferReversal *Number `xml:\"TrfRvsl,omitempty\"`\n\n\tFeeCollection *Number `xml:\"FeeColltn,omitempty\"`\n}\n\nfunc (t *TransactionTotals6) SetAuthorisation(value string) {\n\tt.Authorisation = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetAuthorisationReversal(value string) {\n\tt.AuthorisationReversal = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetInquiry(value string) {\n\tt.Inquiry = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetInquiryReversal(value string) {\n\tt.InquiryReversal = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetPayments(value string) {\n\tt.Payments = (*Number)(&value)\n}\n\n\n\nfunc (t *TransactionTotals6) SetTransfer(value string) {\n\tt.Transfer = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetTransferReversal(value string) {\n\tt.TransferReversal = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetFeeCollection(value string) {\n\tt.FeeCollection = (*Number)(&value)\n}\n\nfunc (t *TransactionTotals6) SetPaymentReversal(value string) ", "output": "{\n\tt.PaymentReversal = (*Number)(&value)\n}"}
{"input": "package monit\n\nimport (\n\t\"errors\"\n\t\"github.com/ooyala/go-dogstatsd\"\n\t\"github.com/tolexo/aero/conf\"\n\t\"sync\"\n)\n\nvar agentObj *DataDogAgent\nvar once sync.Once\n\ntype DataDogAgent struct {\n\tClient *dogstatsd.Client\n}\n\nfunc (d *DataDogAgent) ClientExists() (exists bool) {\n\tif d.Client != nil {\n\t\texists = true\n\t}\n\treturn\n}\n\nfunc (d *DataDogAgent) Close() {\n\td.Client.Close()\n}\n\nfunc (d *DataDogAgent) Count(name string, value int64, tags []string, rate float64) (err error) {\n\texists := d.ClientExists()\n\tif exists {\n\t\terr = d.Client.Count(name, value, tags, rate)\n\t}\n\treturn\n}\n\nfunc (d *DataDogAgent) Histogram(name string, value float64, tags []string, rate float64) (err error) {\n\texists := d.ClientExists()\n\tif exists {\n\t\terr = d.Client.Histogram(name, value, tags, rate)\n\t}\n\treturn\n}\n\n\n\n\nfunc GetDataDogAgent() *DataDogAgent ", "output": "{\n\tonce.Do(func() {\n\t\tagentObj = new(DataDogAgent)\n\t\tvar errObj error\n\t\tenabled := conf.Bool(\"monitor.enabled\", false)\n\t\tif enabled && agentObj.ClientExists() == false {\n\t\t\thost := conf.String(\"monitor.host\", \"\")\n\t\t\tport := conf.String(\"monitor.port\", \"\")\n\t\t\tif host == \"\" || port == \"\" {\n\t\t\t\terrObj = errors.New(\"Datadog config host and port missing\")\n\t\t\t} else {\n\t\t\t\tclient, err := dogstatsd.New(host + \":\" + port)\n\t\t\t\tif err != nil {\n\t\t\t\t\terrObj = err\n\t\t\t\t} else {\n\t\t\t\t\tnamespace := conf.String(\"monitor.namespace\", \"\")\n\t\t\t\t\tif namespace != \"\" {\n\t\t\t\t\t\tclient.Namespace = namespace\n\t\t\t\t\t}\n\t\t\t\t\tagentObj.Client = client\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif errObj != nil {\n\t\t}\n\t})\n\treturn agentObj\n}"}
{"input": "package main\n\nimport \"log\"\nimport \"os\"\nimport \"sync\"\nimport \"encoding/json\"\n\n\ntype GNConfigSlot struct {\n\tLabel, Filename string\n}\n\n\n\ntype GNConfig struct {\n\tSlots        [10]GNConfigSlot\n\tLastRecalled int\n}\n\nvar conf GNConfig\nvar conflock sync.RWMutex\n\nfunc init() {\n\terr := conf.Read()\n\tif err != nil {\n\t\tlog.Println(\"Configuration file not found. Creating a blank file.\")\n\t\tconf.Write()\n\t}\n}\n\n\n\n\n\n\n\nfunc (c *GNConfig) Write() {\n\tFSRemountRW()\n\tfp, err := os.Create(\"/gn_config.json\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tjenc := json.NewEncoder(fp)\n\terr = jenc.Encode(&c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = fp.Close()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tFSRemountRO()\n\treturn\n}\n\nfunc (c *GNConfig) ReadStart() {\n\tconflock.RLock()\n}\n\nfunc (c *GNConfig) ReadDone() {\n\tconflock.RUnlock()\n}\n\nfunc (c *GNConfig) WriteStart() {\n\tconflock.Lock()\n}\n\nfunc (c *GNConfig) WriteDone() {\n\tc.Write()\n\tconflock.Unlock()\n}\n\nfunc (c *GNConfig) Read() error ", "output": "{\n\tfp, err := os.Open(\"/gn_config.json\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fp.Close()\n\n\tjdec := json.NewDecoder(fp)\n\terr = jdec.Decode(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn nil\n}"}
{"input": "package channelz\n\n\n\n\nfunc GetSocketOption(c interface{}) *SocketOptionData ", "output": "{\n\treturn nil\n}"}
{"input": "package lib\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Client struct {\n\tSubnet        *Subnet\n\tServer        *Server\n\tNick, Lnick   string\n\tIdent, Vident string\n\tHost, Vhost   string\n\tIp, Vip       string\n\tGecos         string\n\tTs            time.Time\n\tMember        map[*Channel]*Membership\n}\n\nfunc (c *Client) Id() SSClientId {\n\treturn SSClientId{c.Server.Name, c.Subnet.Name, c.Lnick}\n}\n\nfunc (c *Client) IsLocal() bool {\n\treturn c.Server.Hub == nil\n}\n\n\n\nfunc (c *Client) DebugString() string {\n\tsnName := \"*\"\n\tsvName := \"*\"\n\tif c.Subnet != nil {\n\t\tsnName = c.Subnet.Name\n\t}\n\tif c.Server != nil {\n\t\tsvName = c.Server.Name\n\t}\n\treturn fmt.Sprintf(\"client(server(%s) id(%s:%s!%s@%s) ip(%s) v(%s@%s) vip(%s) gecos(%s) ts(%v))\", svName, snName, c.Nick, c.Ident, c.Host, c.Ip, c.Vident, c.Vhost, c.Vip, c.Gecos, c.Ts)\n}\n\nfunc (c *Client) Serialize() *SSClient ", "output": "{\n\treturn &SSClient{\n\t\tSubnet: c.Subnet.Name,\n\t\tServer: c.Server.Name,\n\t\tNick:   c.Nick,\n\t\tIdent:  c.Ident,\n\t\tVident: c.Vident,\n\t\tHost:   c.Host,\n\t\tVhost:  c.Vhost,\n\t\tIp:     c.Ip,\n\t\tVip:    c.Vip,\n\t\tGecos:  c.Gecos,\n\t\tTs:     c.Ts,\n\t}\n}"}
{"input": "package vfs \n\nimport \"github.com/docker/docker/quota\"\n\ntype driverQuota struct {\n}\n\nfunc setupDriverQuota(driver *Driver) error {\n\treturn nil\n}\n\nfunc (d *Driver) setQuotaOpt(size uint64) error {\n\treturn quota.ErrQuotaNotSupported\n}\n\nfunc (d *Driver) getQuotaOpt() uint64 {\n\treturn 0\n}\n\n\n\nfunc (d *Driver) quotaSupported() bool {\n\treturn false\n}\n\nfunc (d *Driver) setupQuota(dir string, size uint64) error ", "output": "{\n\treturn quota.ErrQuotaNotSupported\n}"}
{"input": "package smpeer\n\nimport (\n\t\"testing\"\n\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/fiorix/go-diameter/diam/datatype\"\n\t\"github.com/fiorix/go-diameter/diam/sm/smparser\"\n)\n\n\n\nfunc TestFromCEA(t *testing.T) {\n\tcer := &smparser.CEA{\n\t\tOriginHost:  datatype.DiameterIdentity(\"foobar\"),\n\t\tOriginRealm: datatype.DiameterIdentity(\"test\"),\n\t}\n\tmeta := FromCEA(cer)\n\tif meta.OriginHost != cer.OriginHost {\n\t\tt.Fatalf(\"Unexpected OriginHost. Want %q, have %q\",\n\t\t\tcer.OriginHost, meta.OriginHost)\n\t}\n\tif meta.OriginRealm != cer.OriginRealm {\n\t\tt.Fatalf(\"Unexpected OriginRealm. Want %q, have %q\",\n\t\t\tcer.OriginRealm, meta.OriginRealm)\n\t}\n\tctx := NewContext(context.Background(), meta)\n\tdata, ok := FromContext(ctx)\n\tif !ok {\n\t\tt.Fatal(\"Metadata not present in this context\")\n\t}\n\tif data != meta {\n\t\tt.Fatalf(\"Unexpected Metadata. Want %#v, have %#v\", meta, data)\n\t}\n}\n\nfunc TestFromCER(t *testing.T) ", "output": "{\n\tcer := &smparser.CER{\n\t\tOriginHost:  datatype.DiameterIdentity(\"foobar\"),\n\t\tOriginRealm: datatype.DiameterIdentity(\"test\"),\n\t}\n\tmeta := FromCER(cer)\n\tif meta.OriginHost != cer.OriginHost {\n\t\tt.Fatalf(\"Unexpected OriginHost. Want %q, have %q\",\n\t\t\tcer.OriginHost, meta.OriginHost)\n\t}\n\tif meta.OriginRealm != cer.OriginRealm {\n\t\tt.Fatalf(\"Unexpected OriginRealm. Want %q, have %q\",\n\t\t\tcer.OriginRealm, meta.OriginRealm)\n\t}\n\tctx := NewContext(context.Background(), meta)\n\tdata, ok := FromContext(ctx)\n\tif !ok {\n\t\tt.Fatal(\"Metadata not present in this context\")\n\t}\n\tif data != meta {\n\t\tt.Fatalf(\"Unexpected Metadata. Want %#v, have %#v\", meta, data)\n\t}\n}"}
{"input": "package wordnet\n\nimport (\n\t. \"github.com/advancedlogic/go-freeling/models\"\n\t. \"github.com/advancedlogic/go-freeling/terminal\"\n\t. \"github.com/fluhus/gostuff/nlp/wordnet\"\n)\n\ntype WN struct {\n\twn *WordNet\n}\n\ntype partOfSpeech struct {\n\tshort string\n\tlong  string\n}\n\nfunc getPOS(p string) (pos *partOfSpeech) {\n\n\tpos = new(partOfSpeech)\n\n\tswitch p {\n\n\tcase \"JJ\", \"JJR\", \"JJS\":\n\t\tpos.short = \"a\" \n\t\tpos.long = \"adjective\"\n\t\tbreak\n\n\tcase \"NNS\", \"NN\", \"NNP\", \"NP00000\", \"NP\", \"NP00G00\", \"NP00O00\", \"NP00V00\", \"NP00SP0\", \"NNPS\":\n\t\tpos.short = \"n\" \n\t\tpos.long = \"noun\"\n\t\tbreak\n\n\tcase \"RB\", \"RBR\", \"RBS\", \"WRB\":\n\t\tpos.short = \"r\" \n\t\tpos.long = \"adverb\"\n\t\tbreak\n\n\tcase \"MD\", \"VBG\", \"VB\", \"VBN\", \"VBD\", \"VBP\", \"VBZ\":\n\t\tpos.short = \"v\" \n\t\tpos.long = \"verb\"\n\t\tbreak\n\n\tdefault:\n\t\treturn nil\n\t}\n\treturn pos\n}\n\nfunc NewWordNet() *WN {\n\twn, err := Parse(\"./data/dict\")\n\n\tinstance := new(WN)\n\n\tif err != nil {\n\t\tErrorln(err.Error())\n\t\tOutputln(\"There was an error during parsing WordNet database\")\n\t} else {\n\t\tinstance.wn = wn\n\t}\n\n\treturn instance\n\n}\n\n\n\nfunc (this *WN) Annotate(word string, pos string) []*Annotation ", "output": "{\n\tif this.wn == nil {\n\t\treturn nil\n\t}\n\n\twnPOS := getPOS(pos)\n\n\tif wnPOS == nil {\n\t\treturn nil\n\t}\n\n\tresult := this.wn.Search(word)[wnPOS.short]\n\n\tannotation := []*Annotation{}\n\n\tfor _, synset := range result {\n\t\tannotation = append(annotation, &Annotation{wnPOS.long, synset.Word, synset.Gloss})\n\t}\n\n\treturn annotation\n}"}
{"input": "package doit\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"gopkg.in/yaml.v2\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestConfigSetCreatesFileIfNotFound(t *testing.T) {\n\tdir, err := ioutil.TempDir(\"\", \"doit\")\n\tassert.NoError(t, err)\n\n\tthepath := filepath.Join(dir, configFile)\n\tassert.NoError(t, err)\n\n\tdefer func() {\n\t\tos.RemoveAll(dir)\n\t}()\n\n\tcf := &ConfigFile{\n\t\tlocation: thepath,\n\t}\n\n\terr = cf.Set(\"foo\", \"bar\")\n\tassert.NoError(t, err)\n\n\t_, err = os.Stat(thepath)\n\tassert.NoError(t, err)\n}\n\nfunc TestConfigSet(t *testing.T) {\n\tdir, err := ioutil.TempDir(\"\", \"doit\")\n\tassert.NoError(t, err)\n\n\tthepath := filepath.Join(dir, configFile)\n\tassert.NoError(t, err)\n\n\tdefer func() {\n\t\tos.RemoveAll(dir)\n\t}()\n\n\tcf := &ConfigFile{\n\t\tlocation: thepath,\n\t}\n\n\terr = cf.Set(\"foo\", \"bar\")\n\tassert.NoError(t, err)\n\n\tr, err := cf.Open()\n\tassert.NoError(t, err)\n\n\tb, err := ioutil.ReadAll(r)\n\tassert.NoError(t, err)\n\n\tvar config map[string]interface{}\n\terr = yaml.Unmarshal(b, &config)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, \"bar\", config[\"foo\"])\n}\n\n\n\nfunc TestNewConfigFile(t *testing.T) ", "output": "{\n\tcf, err := NewConfigFile()\n\tassert.NoError(t, err)\n\n\tassert.NotEmpty(t, cf.location)\n}"}
{"input": "package util\n\nimport (\n\t\"os\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGetEnvAsStringOrFallback(t *testing.T) {\n\tconst expected = \"foo\"\n\n\tassert := assert.New(t)\n\n\tkey := \"FLOCKER_SET_VAR\"\n\tos.Setenv(key, expected)\n\tassert.Equal(expected, GetEnvAsStringOrFallback(key, \"~\"+expected))\n\n\tkey = \"FLOCKER_UNSET_VAR\"\n\tassert.Equal(expected, GetEnvAsStringOrFallback(key, expected))\n}\n\n\n\nfunc TestGetEnvAsFloat64OrFallback(t *testing.T) {\n\tconst expected = 1.0\n\n\tassert := assert.New(t)\n\n\tkey := \"FLOCKER_SET_VAR\"\n\tos.Setenv(key, \"1.0\")\n\treturnVal, _ := GetEnvAsFloat64OrFallback(key, 2.0)\n\tassert.Equal(expected, returnVal)\n\n\tkey = \"FLOCKER_UNSET_VAR\"\n\treturnVal, _ = GetEnvAsFloat64OrFallback(key, 1.0)\n\tassert.Equal(expected, returnVal)\n}\n\nfunc TestGetEnvAsIntOrFallback(t *testing.T) ", "output": "{\n\tconst expected = 1\n\n\tassert := assert.New(t)\n\n\tkey := \"FLOCKER_SET_VAR\"\n\tos.Setenv(key, strconv.Itoa(expected))\n\treturnVal, _ := GetEnvAsIntOrFallback(key, 1)\n\tassert.Equal(expected, returnVal)\n\n\tkey = \"FLOCKER_UNSET_VAR\"\n\treturnVal, _ = GetEnvAsIntOrFallback(key, expected)\n\tassert.Equal(expected, returnVal)\n}"}
{"input": "package log\n\nimport (\n\tl \"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/metrics\"\n)\n\nconst (\n\tCallDepth = 1\n)\n\nvar (\n\tlogBaseAddr = false\n)\n\n\ntype Logger = l.Logger\n\n\nfunc NewBaseAddressLogger(baseAddr string, ctx ...interface{}) l.Logger {\n\tif logBaseAddr {\n\t\treturn l.New(append([]interface{}{\"base\", baseAddr}, ctx...)...)\n\t}\n\n\treturn l.New(ctx...)\n}\n\n\nfunc New(ctx ...interface{}) Logger {\n\treturn l.New(ctx)\n}\n\n\n\nfunc EnableBaseAddress() {\n\tlogBaseAddr = true\n}\n\n\nfunc Warn(msg string, ctx ...interface{}) {\n\tmetrics.GetOrRegisterCounter(\"warn\", nil).Inc(1)\n\tl.Output(msg, l.LvlWarn, CallDepth, ctx...)\n}\n\n\nfunc Error(msg string, ctx ...interface{}) {\n\tmetrics.GetOrRegisterCounter(\"error\", nil).Inc(1)\n\tl.Output(msg, l.LvlError, CallDepth, ctx...)\n}\n\n\nfunc Crit(msg string, ctx ...interface{}) {\n\tmetrics.GetOrRegisterCounter(\"crit\", nil).Inc(1)\n\tl.Output(msg, l.LvlCrit, CallDepth, ctx...)\n}\n\n\nfunc Info(msg string, ctx ...interface{}) {\n\tmetrics.GetOrRegisterCounter(\"info\", nil).Inc(1)\n\tl.Output(msg, l.LvlInfo, CallDepth, ctx...)\n}\n\n\n\n\n\nfunc Trace(msg string, ctx ...interface{}) {\n\tmetrics.GetOrRegisterCounter(\"trace\", nil).Inc(1)\n\tl.Output(msg, l.LvlTrace, CallDepth, ctx...)\n}\n\n\nfunc GetHandler() l.Handler {\n\treturn l.Root().GetHandler()\n}\n\nfunc Debug(msg string, ctx ...interface{}) ", "output": "{\n\tmetrics.GetOrRegisterCounter(\"debug\", nil).Inc(1)\n\tl.Output(msg, l.LvlDebug, CallDepth, ctx...)\n}"}
{"input": "package main\n\nimport \"testing\"\n\nfunc Test_container_key(t *testing.T) {\n\tcases := []struct {\n\t\tname   string\n\t\tlabels []string\n\t\texpect string\n\t}{\n\t\t{\n\t\t\tname:   \"foo\",\n\t\t\tlabels: []string{},\n\t\t\texpect: \"foo{}\",\n\t\t}, {\n\t\t\tname:   \"foo\",\n\t\t\tlabels: []string{\"value\"},\n\t\t\texpect: \"foo{value}\",\n\t\t}, {\n\t\t\tname:   \"foo\",\n\t\t\tlabels: []string{\"value\", \"color\"},\n\t\t\texpect: \"foo{color,value}\",\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tkey := containerKey(c.name, c.labels)\n\t\tif key != c.expect {\n\t\t\tt.Errorf(\"expected container key %s, got %s\", c.expect, key)\n\t\t}\n\t}\n}\n\n\n\nfunc Test_container_fetch_gauge(t *testing.T) {\n\tcontainer := NewGaugeContainer(\"marathon\")\n\t_, new := container.Fetch(\"foo\", \"\")\n\n\tif !new {\n\t\tt.Fatal(\"expected a new gauge\")\n\t}\n\tif len(container.gauges) != 1 {\n\t\tt.Fatalf(\"expected a gauge, got %d gauges\", len(container.gauges))\n\t}\n\n\t_, new = container.Fetch(\"foo\", \"\")\n\tif new {\n\t\tt.Fatal(\"expected an existing gauge\")\n\t}\n\tif len(container.gauges) != 1 {\n\t\tt.Fatalf(\"expected same gauge as before, go %d gauges\", len(container.gauges))\n\t}\n}\n\nfunc Test_container_fetch_counter(t *testing.T) ", "output": "{\n\tcontainer := NewCounterContainer(\"marathon\")\n\t_, new := container.Fetch(\"foo\", \"\")\n\n\tif !new {\n\t\tt.Fatal(\"expected a new counter\")\n\t}\n\tif len(container.counters) != 1 {\n\t\tt.Fatalf(\"expected a counter, got %d counters\", len(container.counters))\n\t}\n\n\t_, new = container.Fetch(\"foo\", \"\")\n\tif new {\n\t\tt.Fatal(\"expected an existing counter\")\n\t}\n\tif len(container.counters) != 1 {\n\t\tt.Fatalf(\"expected same counter as before, go %d counters\", len(container.counters))\n\t}\n}"}
{"input": "package sources\n\nimport (\n\t\"github.com/bsideup/configo/parsers\"\n\t\"io/ioutil\"\n)\n\ntype FileSource struct {\n\tPath   string `json:\"path\"`\n\tFormat string `json:\"format\"`\n}\n\n\n\nfunc (fileSource *FileSource) Get() (map[string]interface{}, error) ", "output": "{\n\n\tcontent, err := ioutil.ReadFile(fileSource.Path)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult := make(map[string]interface{})\n\tparsers.MustGetParser(fileSource.Format).Parse(content, result)\n\n\treturn result, nil\n}"}
{"input": "package wal\n\ntype MockServer struct {\n\tServer\n\tid uint32\n}\n\n\n\nfunc (s *MockServer) Id() uint32 ", "output": "{\n\treturn s.id\n}"}
{"input": "package service\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/BurntSushi/toml\"\n\t\"github.com/nebulaim/telegramd/baselib/grpc_util\"\n\t\"github.com/nebulaim/telegramd/baselib/mysql_client\"\n\t\"github.com/nebulaim/telegramd/baselib/redis_client\"\n)\n\nvar (\n\tconfPath string\n\tConf     *documentConfig\n)\n\ntype documentConfig struct {\n\tServerId  int32 \n\tDataPath  string\n\tRedis     []redis_client.RedisConfig\n\tMysql     []mysql_client.MySQLConfig\n\tRpcServer *grpc_util.RPCServerConfig\n}\n\n\n\nfunc init() {\n\tflag.StringVar(&confPath, \"conf\", \"./document.toml\", \"config path\")\n}\n\nfunc InitializeConfig() (err error) {\n\t_, err = toml.DecodeFile(confPath, &Conf)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"decode file %s error: %v\", confPath, err)\n\t}\n\treturn\n}\n\nfunc (c *documentConfig) String() string ", "output": "{\n\treturn fmt.Sprintf(\"{server_id: %d, redis: %v. mysql: %v, server: %v}\",\n\t\tc.ServerId,\n\t\tc.Redis,\n\t\tc.Mysql,\n\t\tc.RpcServer)\n}"}
{"input": "package core\n\nimport (\n\t\"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/client-go/informers\"\n\tclientset \"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/quota\"\n\t\"k8s.io/kubernetes/pkg/quota/generic\"\n)\n\n\n\n\n\n\nfunc NewConfigMapEvaluator(kubeClient clientset.Interface, f informers.SharedInformerFactory) quota.Evaluator {\n\tlistFuncByNamespace := listConfigMapsByNamespaceFuncUsingClient(kubeClient)\n\tif f != nil {\n\t\tlistFuncByNamespace = generic.ListResourceUsingInformerFunc(f, v1.SchemeGroupVersion.WithResource(\"configmaps\"))\n\t}\n\treturn &generic.ObjectCountEvaluator{\n\t\tAllowCreateOnUpdate: false,\n\t\tInternalGroupKind:   api.Kind(\"ConfigMap\"),\n\t\tResourceName:        api.ResourceConfigMaps,\n\t\tListFuncByNamespace: listFuncByNamespace,\n\t}\n}\n\nfunc listConfigMapsByNamespaceFuncUsingClient(kubeClient clientset.Interface) generic.ListFuncByNamespace ", "output": "{\n\treturn func(namespace string, options metav1.ListOptions) ([]runtime.Object, error) {\n\t\titemList, err := kubeClient.CoreV1().ConfigMaps(namespace).List(options)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresults := make([]runtime.Object, 0, len(itemList.Items))\n\t\tfor i := range itemList.Items {\n\t\t\tresults = append(results, &itemList.Items[i])\n\t\t}\n\t\treturn results, nil\n\t}\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/labstack/echo\"\n)\n\n\n\n\nfunc MakeControllers(e *echo.Echo) ", "output": "{\n\te.GET(\"/api\", homeController)\n}"}
{"input": "package utils\n\ntype Task struct {\n\thttpMethod string\n\texURL *ExURL\n}\n\nfunc NewTask(pMehtod string, pExURL *ExURL) Task{\n\tvar theElement Task\n\ttheElement.httpMethod = pMehtod\n\ttheElement.exURL = pExURL\n\n\treturn theElement\n}\n\nfunc (theElement *Task) GetMethod() string{\n\treturn theElement.httpMethod\n}\n\n\n\ntype TaskQueue struct {\n\ttheList []Task\n\ttheCurrentIndex int\n}\n\nfunc NewTaskQueue() *TaskQueue {\n\tvar theQueue *TaskQueue\n\ttheQueue = new(TaskQueue)\n\ttheQueue.theList = make([]Task, 0)\n\treturn theQueue\n}\n\nfunc (theQueue *TaskQueue) PushBack(pMethod string, pExURL *ExURL) bool {\n\tvar anElement Task\n\tanElement = NewTask(pMethod, pExURL)\n\ttheQueue.theList = append(theQueue.theList, anElement)\n\treturn true\n}\n\nfunc (theQueue *TaskQueue) PullFront() Task {\n\tvar theFrontTask Task\n\ttheFrontTask = theQueue.theList[theQueue.theCurrentIndex]\n\ttheQueue.theCurrentIndex++\n\treturn theFrontTask\n}\n\nfunc (theQueue *TaskQueue) GetLength() int {\n\treturn len(theQueue.theList)\n}\n\nfunc (theQueue *TaskQueue) GetCurrentIndex() int {\n\treturn theQueue.theCurrentIndex\n}\n\nfunc (theElement *Task) GetExURL() *ExURL ", "output": "{\n\treturn theElement.exURL\n}"}
{"input": "package flamingo\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/Sirupsen/logrus\"\n\t\"github.com/spf13/viper\"\n)\n\n\n\nfunc loggerSettings() {\n\tformat := viper.GetString(\"log.format\")\n\tlevel := viper.GetString(\"log.level\")\n\toutput := viper.GetString(\"log.output\")\n\n\tif format == \"json\" {\n\t\tlogrus.SetFormatter(&logrus.JSONFormatter{})\n\t} else {\n\t\tlogrus.SetFormatter(&logrus.TextFormatter{})\n\t}\n\n\tif output == \"stderr\" {\n\t\tlogrus.SetOutput(os.Stderr)\n\t} else {\n\t\tlogrus.SetOutput(os.Stdout)\n\t}\n\n\tif level == \"panic\" {\n\t\tlogrus.SetLevel(logrus.PanicLevel)\n\t} else if level == \"error\" {\n\t\tlogrus.SetLevel(logrus.ErrorLevel)\n\t} else if level == \"warning\" {\n\t\tlogrus.SetLevel(logrus.WarnLevel)\n\t} else if level == \"info\" {\n\t\tlogrus.SetLevel(logrus.InfoLevel)\n\t} else if level == \"debug\" {\n\t\tlogrus.SetLevel(logrus.DebugLevel)\n\t} else {\n\t\tlogrus.SetLevel(logrus.ErrorLevel)\n\t}\n\n\tfmt.Println(\"LogLevel:\", logrus.GetLevel())\n\tfmt.Println(\"LogOut:\", output)\n\tfmt.Println(\"LogFormat:\", format)\n}\n\nfunc loadConfig() ", "output": "{\n\tviper.SetConfigType(\"toml\")   \n\tviper.SetConfigName(\"config\") \n\n\tviper.AddConfigPath(\"./config/\") \n\terr := viper.ReadInConfig()      \n\n\tif err != nil { \n\t\tpanic(fmt.Errorf(\"Fatal error config file: %s \\n\", err))\n\t}\n\n\tloggerSettings()\n}"}
{"input": "package core\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/oci/oci-go-sdk/v43/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype DetachVolumeRequest struct {\n\n\tVolumeAttachmentId *string `mandatory:\"true\" contributesTo:\"path\" name:\"volumeAttachmentId\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request DetachVolumeRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request DetachVolumeRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request DetachVolumeRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request DetachVolumeRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype DetachVolumeResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\n\n\n\nfunc (response DetachVolumeResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response DetachVolumeResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package hawkular\n\nimport (\n\t\"net/url\"\n\t\"sync\"\n\n\t\"github.com/adfin/statster/metrics/core\"\n\thawkular \"github.com/hawkular/hawkular-client-go/metrics\"\n)\n\ntype Filter func(ms *core.MetricSet, metricName string) bool\ntype FilterType int\n\nconst (\n\tLabel FilterType = iota\n\tName\n\tUnknown\n)\n\nfunc (f FilterType) From(s string) FilterType {\n\tswitch s {\n\tcase \"label\":\n\t\treturn Label\n\tcase \"name\":\n\t\treturn Name\n\tdefault:\n\t\treturn Unknown\n\t}\n}\n\ntype hawkularSink struct {\n\tclient  *hawkular.Client\n\tmodels  map[string]*hawkular.MetricDefinition \n\tregLock sync.RWMutex\n\treg     map[string]*hawkular.MetricDefinition \n\n\turi *url.URL\n\n\tlabelTenant    string\n\tlabelNodeId    string\n\tlabelTagPrefix string\n\tmodifiers      []hawkular.Modifier\n\tfilters        []Filter\n\n\tdisablePreCaching bool\n\tbatchSize         int\n}\n\n\n\nfunc heapsterTypeToHawkularType(t core.MetricType) hawkular.MetricType ", "output": "{\n\tswitch t {\n\tcase core.MetricCumulative:\n\t\treturn hawkular.Counter\n\tcase core.MetricGauge:\n\t\treturn hawkular.Gauge\n\tdefault:\n\t\treturn hawkular.Gauge\n\t}\n}"}
{"input": "package gong\n\nimport (\n\t. \"gopkg.in/check.v1\"\n\t\"testing\"\n)\n\n\n\ntype PivotalClientSuit struct{}\n\nvar _ = Suite(&PivotalClientSuit{})\n\nfunc (p *PivotalClientSuit) TestBrowseWithCorrectBranchName(c *C) {\n\tpivotalClient := &PivotalClient{}\n\n\turl, err := pivotalClient.Browse(\"feature/124352-test-only\")\n\tc.Assert(err, Equals, nil)\n\tc.Assert(url, Equals, \"https://www.pivotaltracker.com/story/show/124352\")\n}\n\nfunc (p *PivotalClientSuit) TestBrowseWithIncorrectBranchName(c *C) {\n\tpivotalClient := &PivotalClient{}\n\n\turl, err := pivotalClient.Browse(\"feature/test-only\")\n\tc.Assert(err, Equals, nil)\n\tc.Assert(url, Equals, \"https://www.pivotaltracker.com/story/show/\")\n}\n\nfunc (p *PivotalClientSuit) TestGetPivotalIssueIDWithCorrectBranchName(c *C) {\n\tbranchName := \"feature/1234-test-only\"\n\tissueId := GetPivotalIssueID(branchName)\n\tc.Assert(issueId, Equals, \"1234\")\n}\n\nfunc (p *PivotalClientSuit) TestGetPivotalIssueIDWithInCorrectBranchName(c *C) {\n\tbranchName := \"feature/test-only\"\n\tissueId := GetPivotalIssueID(branchName)\n\tc.Assert(issueId, Equals, \"\")\n}\n\nfunc TestPivotalClient(t *testing.T) ", "output": "{ TestingT(t) }"}
{"input": "package api_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/remind101/empire/pkg/heroku\"\n)\n\n\n\nfunc mustFormationBatchUpdate(t testing.TB, c *heroku.Client, appName string, updates []heroku.FormationBatchUpdateOpts) []heroku.Formation {\n\tf, err := c.FormationBatchUpdate(appName, updates, \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn f\n}\n\nfunc TestFormationBatchUpdate(t *testing.T) ", "output": "{\n\tc, s := NewTestClient(t)\n\tdefer s.Close()\n\n\tmustDeploy(t, c, DefaultImage)\n\n\tq := 2\n\tf := mustFormationBatchUpdate(t, c, \"acme-inc\", []heroku.FormationBatchUpdateOpts{\n\t\t{\n\t\t\tProcess:  \"web\",\n\t\t\tQuantity: &q,\n\t\t},\n\t})\n\n\tif got, want := f[0].Quantity, 2; got != want {\n\t\tt.Fatalf(\"Quantity => %d; want %d\", got, want)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\t\"net/http\"\n)\n\nfunc main() {\n\n\thttp.HandleFunc(\"/main\", MainHandler)\n\n\tsrv := http.Server{\n\t\tHandler:      nil,\n\t\tAddr:         \":8080\",\n\t\tReadTimeout:  5 * time.Second,\n\t\tWriteTimeout: 5 * time.Second,\n\t}\n\terr := srv.ListenAndServe()\n\tif err != nil {\n\t\tfmt.Println(\"ListenAndServe Error: \", err.Error())\n\t}\n}\n\n\n\nfunc MainHandler(w http.ResponseWriter, r *http.Request) ", "output": "{\n    fmt.Println(\"handler function\")\n    w.Write([]byte(\"ok\"))\n  \treturn\n}"}
{"input": "package api\n\nimport (\n\t\"sort\"\n\t\"time\"\n)\n\n\ntype Evaluations struct {\n\tclient *Client\n}\n\n\nfunc (c *Client) Evaluations() *Evaluations {\n\treturn &Evaluations{client: c}\n}\n\n\nfunc (e *Evaluations) List(q *QueryOptions) ([]*Evaluation, *QueryMeta, error) {\n\tvar resp []*Evaluation\n\tqm, err := e.client.query(\"/v1/evaluations\", &resp, q)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tsort.Sort(EvalIndexSort(resp))\n\treturn resp, qm, nil\n}\n\n\nfunc (e *Evaluations) Info(evalID string, q *QueryOptions) (*Evaluation, *QueryMeta, error) {\n\tvar resp Evaluation\n\tqm, err := e.client.query(\"/v1/evaluation/\"+evalID, &resp, q)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn &resp, qm, nil\n}\n\n\n\n\n\n\ntype Evaluation struct {\n\tID                string\n\tPriority          int\n\tType              string\n\tTriggeredBy       string\n\tJobID             string\n\tJobModifyIndex    uint64\n\tNodeID            string\n\tNodeModifyIndex   uint64\n\tStatus            string\n\tStatusDescription string\n\tWait              time.Duration\n\tNextEval          string\n\tPreviousEval      string\n\tCreateIndex       uint64\n\tModifyIndex       uint64\n}\n\n\n\ntype EvalIndexSort []*Evaluation\n\nfunc (e EvalIndexSort) Len() int {\n\treturn len(e)\n}\n\nfunc (e EvalIndexSort) Less(i, j int) bool {\n\treturn e[i].CreateIndex > e[j].CreateIndex\n}\n\nfunc (e EvalIndexSort) Swap(i, j int) {\n\te[i], e[j] = e[j], e[i]\n}\n\nfunc (e *Evaluations) Allocations(evalID string, q *QueryOptions) ([]*AllocationListStub, *QueryMeta, error) ", "output": "{\n\tvar resp []*AllocationListStub\n\tqm, err := e.client.query(\"/v1/evaluation/\"+evalID+\"/allocations\", &resp, q)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tsort.Sort(AllocIndexSort(resp))\n\treturn resp, qm, nil\n}"}
{"input": "package externalversions\n\nimport (\n\t\"fmt\"\n\n\tschema \"k8s.io/apimachinery/pkg/runtime/schema\"\n\tcache \"k8s.io/client-go/tools/cache\"\n\tv1alpha1 \"knative.dev/eventing-kafka-broker/control-plane/pkg/apis/eventing/v1alpha1\"\n)\n\n\n\ntype GenericInformer interface {\n\tInformer() cache.SharedIndexInformer\n\tLister() cache.GenericLister\n}\n\ntype genericInformer struct {\n\tinformer cache.SharedIndexInformer\n\tresource schema.GroupResource\n}\n\n\n\n\n\nfunc (f *genericInformer) Lister() cache.GenericLister {\n\treturn cache.NewGenericLister(f.Informer().GetIndexer(), f.resource)\n}\n\n\n\nfunc (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) {\n\tswitch resource {\n\tcase v1alpha1.SchemeGroupVersion.WithResource(\"kafkasinks\"):\n\t\treturn &genericInformer{resource: resource.GroupResource(), informer: f.Eventing().V1alpha1().KafkaSinks().Informer()}, nil\n\n\t}\n\n\treturn nil, fmt.Errorf(\"no informer found for %v\", resource)\n}\n\nfunc (f *genericInformer) Informer() cache.SharedIndexInformer ", "output": "{\n\treturn f.informer\n}"}
{"input": "package engines\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"github.com/owulveryck/khoreia/choreography/event\"\n\t\"golang.org/x/net/context\"\n\t\"log\"\n\t\"os/exec\"\n)\n\ntype ShellEngine struct {\n\tArtifact string\n\tArgs     []string\n\toutputs  map[string]string\n}\n\nfunc NewShellEngine(i map[string]interface{}) (*ShellEngine, error) {\n\tvar artifact string\n\tfor k, v := range i {\n\t\tswitch k {\n\t\tcase \"artifact\":\n\t\t\tartifact = v.(string)\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"Unknown field %v (%v) for  engine ShellEngine\", k, v)\n\t\t}\n\t}\n\treturn &ShellEngine{Artifact: artifact}, nil\n}\n\n\n\nfunc (f *ShellEngine) Check(ctx context.Context, stop chan struct{}) chan *event.Event {\n\tc := make(chan *event.Event)\n\treturn c\n}\n\nfunc (e *ShellEngine) GetOutput(ctx context.Context) interface{} {\n\treturn nil\n}\n\nfunc (s *ShellEngine) Do(ctx context.Context) ", "output": "{\n\td := exec.Command(s.Artifact, s.Args...)\n\tstdinOfDotProcess, err := d.StdinPipe()\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer stdinOfDotProcess.Close() \n\treadCloser, err := d.StdoutPipe()\n\tif err != nil {\n\t\treturn\n\n\t}\n\n\tif err = d.Run(); err != nil { \n\t\tlog.Println(\"An error occured: \", err) \n\t\treturn\n\t}\n\tstdinOfDotProcess.Close()\n\n\tvar buf bytes.Buffer\n\tbuf.ReadFrom(readCloser)\n\n\treturn\n}"}
{"input": "package config\n\nimport (\n  \"io/ioutil\"\n\n  \"gopkg.in/yaml.v1\"\n)\n\ntype Config struct {\n  path     string\n  Commands map[string]*Command\n}\n\n\n\nfunc LoadConfig(path string) (config *Config, err error) {\n  config = &Config{\n    path: path,\n  }\n\n  config_buff, err := ioutil.ReadFile(path)\n\n  if err != nil {\n    return nil, err\n  }\n\n  if err = yaml.Unmarshal(config_buff, &config); err != nil {\n    return nil, err\n  }\n\n  for k, v := range config.Commands {\n    v.Name = k\n  }\n\n  return config, err\n}\n\nfunc (c Config) StoreSession() string ", "output": "{\n  return marshal(c)\n}"}
{"input": "package v1\n\nimport (\n\tv1 \"github.com/openebs/maya/pkg/apis/openebs.io/snapshot/v1\"\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/client-go/tools/cache\"\n)\n\n\n\ntype VolumeSnapshotDataLister interface {\n\tList(selector labels.Selector) (ret []*v1.VolumeSnapshotData, err error)\n\tGet(name string) (*v1.VolumeSnapshotData, error)\n\tVolumeSnapshotDataListerExpansion\n}\n\n\ntype volumeSnapshotDataLister struct {\n\tindexer cache.Indexer\n}\n\n\nfunc NewVolumeSnapshotDataLister(indexer cache.Indexer) VolumeSnapshotDataLister {\n\treturn &volumeSnapshotDataLister{indexer: indexer}\n}\n\n\nfunc (s *volumeSnapshotDataLister) List(selector labels.Selector) (ret []*v1.VolumeSnapshotData, err error) {\n\terr = cache.ListAll(s.indexer, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*v1.VolumeSnapshotData))\n\t})\n\treturn ret, err\n}\n\n\n\n\nfunc (s *volumeSnapshotDataLister) Get(name string) (*v1.VolumeSnapshotData, error) ", "output": "{\n\tobj, exists, err := s.indexer.GetByKey(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn nil, errors.NewNotFound(v1.Resource(\"volumesnapshotdata\"), name)\n\t}\n\treturn obj.(*v1.VolumeSnapshotData), nil\n}"}
{"input": "package smbios\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSMBIOSEFISMBIOS2(t *testing.T) {\n\tsystabPath = \"testdata/smbios2_systab\"\n\tbase, size, err := SMBIOSBaseEFI()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar want int64 = 0x12345678\n\n\tif base != want {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): 0x%x, want 0x%x\", base, want)\n\t}\n\tif size != smbios2HeaderSize {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): 0x%x, want 0x%x \", size, smbios2HeaderSize)\n\t}\n}\n\nfunc TestSMBIOSEFISMBIOS3(t *testing.T) {\n\tsystabPath = \"testdata/smbios3_systab\"\n\tbase, size, err := SMBIOSBaseEFI()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar want int64 = 0x12345678\n\n\tif base != want {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): 0x%x, want 0x%x\", base, want)\n\t}\n\tif size != smbios3HeaderSize {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): 0x%x, want 0x%x \", size, smbios3HeaderSize)\n\t}\n}\n\nfunc TestSMBIOSEFINotFound(t *testing.T) {\n\tsystabPath = \"testdata/systab_NOT_FOUND\"\n\t_, _, err := SMBIOSBaseEFI()\n\tif err == nil {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): nil , want error\")\n\t}\n}\n\n\n\nfunc TestSMBIOSEFIInvalid(t *testing.T) ", "output": "{\n\tsystabPath = \"testdata/invalid_systab\"\n\t_, _, err := SMBIOSBaseEFI()\n\tif err == nil {\n\t\tt.Errorf(\"SMBIOSBaseEFI(): nil , want error\")\n\t}\n}"}
{"input": "package link\n\nimport (\n\t\"net\"\n\t\"testing\"\n\n\t\"github.com/cilium/ebpf\"\n)\n\n\n\nfunc TestSocketFilterAttach(t *testing.T) ", "output": "{\n\tprog := mustLoadProgram(t, ebpf.SocketFilter, 0, \"\")\n\n\tdefer prog.Close()\n\n\tconn, err := net.ListenUDP(\"udp4\", &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1)})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\tif err := AttachSocketFilter(conn, prog); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := DetachSocketFilter(conn); err != nil {\n\t\tt.Fatal(err)\n\t}\n}"}
{"input": "package dataintegration\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype CreateExternalPublicationRequest struct {\n\n\tWorkspaceId *string `mandatory:\"true\" contributesTo:\"path\" name:\"workspaceId\"`\n\n\tTaskKey *string `mandatory:\"true\" contributesTo:\"path\" name:\"taskKey\"`\n\n\tCreateExternalPublicationDetails `contributesTo:\"body\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request CreateExternalPublicationRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request CreateExternalPublicationRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request CreateExternalPublicationRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request CreateExternalPublicationRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype CreateExternalPublicationResponse struct {\n\n\tRawResponse *http.Response\n\n\tExternalPublication `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\n\n\n\nfunc (response CreateExternalPublicationResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response CreateExternalPublicationResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package input\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\n\t\"github.com/elastic/beats/libbeat/logp\"\n)\n\ntype FileStateOS struct {\n\tInode  uint64 `json:\"inode,omitempty\"`\n\tDevice uint64 `json:\"device,omitempty\"`\n}\n\n\nfunc GetOSFileState(info *os.FileInfo) *FileStateOS {\n\n\tstat := (*(info)).Sys().(*syscall.Stat_t)\n\n\tfileState := &FileStateOS{\n\t\tInode:  uint64(stat.Ino),\n\t\tDevice: uint64(stat.Dev),\n\t}\n\n\treturn fileState\n}\n\n\n\n\n\nfunc SafeFileRotate(path, tempfile string) error {\n\tif e := os.Rename(tempfile, path); e != nil {\n\t\tlogp.Err(\"Rotate error: %s\", e)\n\t\treturn e\n\t}\n\treturn nil\n}\n\n\nfunc ReadOpen(path string) (*os.File, error) {\n\n\tflag := os.O_RDONLY\n\tvar perm os.FileMode = 0\n\n\treturn os.OpenFile(path, flag, perm)\n}\n\nfunc (fs *FileStateOS) IsSame(state *FileStateOS) bool ", "output": "{\n\treturn fs.Inode == state.Inode && fs.Device == state.Device\n}"}
{"input": "package taskmq\n\ntype Stub struct{}\n\nfunc (c Stub) Clone() *Stub {\n\treturn &Stub{}\n}\n\n\n\nfunc (c Stub) InitConsumer(queue string) []byte {\n\treturn nil\n}\n\nfunc (c Stub) Pop() []byte {\n\treturn []byte{}\n}\n\nfunc (c Stub) Ack() error {\n\treturn nil\n}\n\nfunc (c Stub) Nack() error {\n\treturn nil\n}\n\nfunc (c Stub) Push(name string, body []byte) error ", "output": "{\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\t\"log\"\n)\n\nfunc main() {\n\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tcookieJar, _ := cookiejar.New(nil)\n\n\tc := &http.Client{\n\t\tJar:       cookieJar,\n\t\tTransport: tr,\n\t}\n\n\tc.Get(\"https://baidu.com\")\n\n}\n\n\n\nfunc https0() ", "output": "{\n\tconf := &tls.Config{\n\t\tInsecureSkipVerify: true,\n\t}\n\tconn, err := tls.Dial(\"tcp\", \"220.181.57.216:443\", conf)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\tn, err := conn.Write([]byte(\"hello\\n\"))\n\tif err != nil {\n\t\tlog.Println(n, err)\n\t\treturn\n\t}\n\tbuf := make([]byte, 100)\n\tn, err = conn.Read(buf)\n\tif err != nil {\n\t\tlog.Println(n, err)\n\t\treturn\n\t}\n\tprintln(string(buf[:n]))\n}"}
{"input": "package cmd\n\nimport (\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/bpicode/fritzctl/man\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar docManCmd = &cobra.Command{\n\tUse:     \"man\",\n\tShort:   \"Man page for this application\",\n\tLong:    \"Generate the man page(s) for this application.\",\n\tExample: \"fritzctl doc man | man /dev/stdin\",\n\tRunE:    docMan,\n}\n\nfunc init() {\n\tdocCmd.AddCommand(docManCmd)\n}\n\n\n\nfunc docMan(_ *cobra.Command, _ []string) error ", "output": "{\n\terr := man.Generate(RootCmd, &man.Options{\n\t\tOrigin: man.Origin{\n\t\t\tSource: \"Auto-generated by bpicode/fritzctl\",\n\t\t\tDate:   time.Now(),\n\t\t},\n\t\tHeader: man.Header{\n\t\t\tTitle:   \"fritzctl\",\n\t\t\tSection: \"1\",\n\t\t\tManual:  \"fritzctl man page\",\n\t\t},\n\t\tSeeAlso: []string{\"kfritz(1)\", \"curl(1)\"},\n\t}, os.Stdout)\n\treturn err\n}"}
{"input": "package wml\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n)\n\ntype CT_MailMergeDocType struct {\n\tValAttr ST_MailMergeDocType\n}\n\nfunc NewCT_MailMergeDocType() *CT_MailMergeDocType {\n\tret := &CT_MailMergeDocType{}\n\tret.ValAttr = ST_MailMergeDocType(1)\n\treturn ret\n}\n\n\n\nfunc (m *CT_MailMergeDocType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n\tm.ValAttr = ST_MailMergeDocType(1)\n\tfor _, attr := range start.Attr {\n\t\tif attr.Name.Local == \"val\" {\n\t\t\tm.ValAttr.UnmarshalXMLAttr(attr)\n\t\t}\n\t}\n\tfor {\n\t\ttok, err := d.Token()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing CT_MailMergeDocType: %s\", err)\n\t\t}\n\t\tif el, ok := tok.(xml.EndElement); ok && el.Name == start.Name {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (m *CT_MailMergeDocType) Validate() error {\n\treturn m.ValidateWithPath(\"CT_MailMergeDocType\")\n}\n\n\nfunc (m *CT_MailMergeDocType) ValidateWithPath(path string) error {\n\tif m.ValAttr == ST_MailMergeDocTypeUnset {\n\t\treturn fmt.Errorf(\"%s/ValAttr is a mandatory field\", path)\n\t}\n\tif err := m.ValAttr.ValidateWithPath(path + \"/ValAttr\"); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (m *CT_MailMergeDocType) MarshalXML(e *xml.Encoder, start xml.StartElement) error ", "output": "{\n\tattr, err := m.ValAttr.MarshalXMLAttr(xml.Name{Local: \"w:val\"})\n\tif err != nil {\n\t\treturn err\n\t}\n\tstart.Attr = append(start.Attr, attr)\n\te.EncodeToken(start)\n\te.EncodeToken(xml.EndElement{Name: start.Name})\n\treturn nil\n}"}
{"input": "package dhcp\n\nimport (\n\t\"fmt\"\n\t\"github.com/adrianco/spigo/tooling/archaius\"\n\t\"github.com/adrianco/spigo/tooling/names\"\n)\n\nvar (\n\tallocated [][]int\n\tmapped    map[string]string\n)\n\nfunc init() {\n\tallocated = make([][]int, len(archaius.Conf.RegionNames))\n\tfor i := range allocated {\n\t\tallocated[i] = make([]int, len(archaius.Conf.ZoneNames))\n\t}\n\tmapped = make(map[string]string, archaius.Conf.Population)\n}\n\n\n\nfunc Lookup(name string) string ", "output": "{\n\tip := mapped[name]\n\tif ip != \"\" {\n\t\treturn ip\n\t}\n\tr := names.Region(name)\n\tri := 0\n\tz := names.Zone(name)\n\tzi := 0\n\tfor i, rr := range archaius.Conf.RegionNames {\n\t\tif rr == r {\n\t\t\tri = i\n\t\t\tbreak\n\t\t}\n\t}\n\tfor i, zr := range archaius.Conf.ZoneNames {\n\t\tif zr == z {\n\t\t\tzi = i\n\t\t\tbreak\n\t\t}\n\t}\n\tallocated[ri][zi]++\n\tnode := allocated[ri][zi]\n\taddr := fmt.Sprintf(\"%v%v.%v\", archaius.Conf.IPRanges[ri][zi], node/256, node%256)\n\tmapped[name] = addr\n\treturn addr\n}"}
{"input": "package search\n\nimport \"encoding/json\"\n\ntype RuleCondition struct {\n\tAnchoring    RulePatternAnchoring `json:\"anchoring,omitempty\"`\n\tPattern      string               `json:\"pattern,omitempty\"`\n\tContext      string               `json:\"context,omitempty\"`\n\tAlternatives *Alternatives        `json:\"alternatives,omitempty\"`\n}\n\ntype RulePatternAnchoring string\n\nconst (\n\tIs         RulePatternAnchoring = \"is\"\n\tStartsWith RulePatternAnchoring = \"startsWith\"\n\tEndsWith   RulePatternAnchoring = \"endsWith\"\n\tContains   RulePatternAnchoring = \"contains\"\n)\n\ntype Alternatives struct {\n\tenabled bool\n}\n\nfunc AlternativesEnabled() *Alternatives {\n\treturn &Alternatives{enabled: true}\n}\n\n\n\nfunc (a Alternatives) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(a.enabled)\n}\n\nfunc (a *Alternatives) UnmarshalJSON(data []byte) error {\n\treturn json.Unmarshal(data, &a.enabled)\n}\n\nfunc AlternativesDisabled() *Alternatives ", "output": "{\n\treturn &Alternatives{enabled: false}\n}"}
{"input": "package crank\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype TimeoutTracker struct {\n\ttimeouts            map[*Process]time.Time\n\tticker              *time.Ticker\n\ttimeoutNotification chan *Process\n\tstopAction          chan bool\n\tmutex               *sync.Mutex\n}\n\nfunc NewTimeoutTracker() *TimeoutTracker {\n\treturn &TimeoutTracker{\n\t\ttimeouts:            make(map[*Process]time.Time),\n\t\tticker:              time.NewTicker(100 * time.Millisecond),\n\t\ttimeoutNotification: make(chan *Process),\n\t\tstopAction:          make(chan bool),\n\t\tmutex:               &sync.Mutex{},\n\t}\n}\n\nfunc (self *TimeoutTracker) Add(p *Process, timeout time.Duration) {\n\tif timeout <= 0 {\n\t\treturn\n\t}\n\tself.mutex.Lock()\n\tself.timeouts[p] = time.Now().Add(timeout)\n\tself.mutex.Unlock()\n}\n\nfunc (self *TimeoutTracker) Remove(p *Process) {\n\tself.mutex.Lock()\n\tdelete(self.timeouts, p)\n\tself.mutex.Unlock()\n}\n\n\n\nfunc (self *TimeoutTracker) Stop() {\n\tself.stopAction <- true\n}\n\nfunc (self *TimeoutTracker) expireOld(now time.Time) {\n\tself.mutex.Lock()\n\tfor p, timeout := range self.timeouts {\n\t\tif timeout.Before(now) {\n\t\t\tdelete(self.timeouts, p)\n\t\t\tself.timeoutNotification <- p\n\t\t}\n\t}\n\tself.mutex.Unlock()\n}\n\nfunc (self *TimeoutTracker) Run() ", "output": "{\n\tfor {\n\t\tselect {\n\t\tcase t := <-self.ticker.C:\n\t\t\tself.expireOld(t)\n\t\tcase <-self.stopAction:\n\t\t\tself.ticker.Stop()\n\t\t\treturn\n\t\t}\n\t}\n}"}
{"input": "package color\n\nimport \"strings\"\n\ntype Color int\n\nconst (\n\tUnknown Color = iota\n\tEmpty\n\tWhite\n\tBlack\n)\n\nfunc (color Color) String() string {\n\tswitch color {\n\tcase Empty:\n\t\treturn \"Empty\"\n\tcase White:\n\t\treturn \"White\"\n\tcase Black:\n\t\treturn \"Black\"\n\tdefault:\n\t\treturn \"Unknown\"\n\t}\n}\n\nfunc (color Color) Enemy() Color {\n\tswitch color {\n\tcase White:\n\t\treturn Black\n\tcase Black:\n\t\treturn White\n\tdefault:\n\t\treturn color\n\t}\n}\n\n\n\nfunc ParseColor(s string) Color {\n\tswitch strings.ToLower(s) {\n\tcase \"white\":\n\t\treturn White\n\tcase \"black\":\n\t\treturn Black\n\tcase \"empty\":\n\t\treturn Empty\n\tdefault:\n\t\treturn Unknown\n\t}\n}\n\nfunc WhichColor(c byte) Color ", "output": "{\n\tif 'A' <= c && c <= 'Z' {\n\t\treturn White\n\t} else if 'a' <= c && c <= 'z' {\n\t\treturn Black\n\t} else if c == ' ' {\n\t\treturn Empty\n\t} else {\n\t\treturn Unknown\n\t}\n}"}
{"input": "package model\n\ntype Interface interface {\n\tVisitString(name string, resume func())\n\tVisitInt(name string, resume func())\n\tVisitFloat(name string, resume func())\n\tVisitBool(name string, resume func())\n\tVisitPtr(name string, resume func())\n\tVisitBytes(name string, resume func())\n\tVisitSlice(name string, resume func())\n\tVisitStruct(name string, fields []Field, resume func())\n\tVisitStructField(field Field, resume func())\n\tVisitMap(name string, resume func())\n\tVisitCustom(name string, resume func())\n\tVisitReference(name string, resume func())\n}\n\ntype Visitor struct{}\n\nfunc (self *Visitor) VisitString(name string, resume func()) {\n\tresume()\n}\n\nfunc (self *Visitor) VisitInt(name string, resume func()) {\n\tresume()\n}\n\nfunc (self *Visitor) VisitFloat(name string, resume func()) {\n\tresume()\n}\n\nfunc (self *Visitor) VisitBool(name string, resume func()) {\n\tresume()\n}\n\nfunc (self *Visitor) VisitPtr(name string, resume func()) {\n\tresume()\n}\n\nfunc (self *Visitor) VisitBytes(name string, resume func()) {\n\tresume()\n}\n\nfunc (self *Visitor) VisitSlice(name string, resume func()) {\n\tresume()\n}\n\nfunc (self *Visitor) VisitStruct(name string, fields []Field, resume func()) {\n\tresume()\n}\n\nfunc (self *Visitor) VisitStructField(field Field, resume func()) {\n\tresume()\n}\n\nfunc (self *Visitor) VisitMap(name string, resume func()) {\n\tresume()\n}\n\n\n\nfunc (self *Visitor) VisitReference(name string, resume func()) {\n\tresume()\n}\n\ntype EmbeddedStructVisitor struct {\n\tInterface\n}\n\nfunc (self *EmbeddedStructVisitor) VisitStruct(name string, fields []Field, resume func()) {\n\tresume()\n}\n\nfunc (self *Visitor) VisitCustom(name string, resume func()) ", "output": "{\n\tresume()\n}"}
{"input": "package timer\n\nimport (\n\t\"container/heap\"\n\t\"time\"\n\n\t\"github.com/idealeak/goserver/core\"\n\t\"github.com/idealeak/goserver/core/basic\"\n)\n\ntype startTimerCommand struct {\n\tsrc      *basic.Object\n\tta       TimerAction\n\tud       interface{}\n\tinterval time.Duration\n\ttimes    int\n\th        TimerHandle\n}\n\nfunc (stc *startTimerCommand) Done(o *basic.Object) error {\n\tdefer o.ProcessSeqnum()\n\n\tte := &TimerEntity{\n\t\tsink:     stc.src,\n\t\tud:       stc.ud,\n\t\tta:       stc.ta,\n\t\tinterval: stc.interval,\n\t\ttimes:    stc.times,\n\t\th:        stc.h,\n\t\tnext:     time.Now().Add(stc.interval),\n\t}\n\n\theap.Push(TimerModule.tq, te)\n\n\treturn nil\n}\n\n\n\nfunc AfterTimer(taw TimerActionWrapper, ud interface{}, interval time.Duration) (TimerHandle, bool) {\n\tvar tac = &TimerActionCommon{\n\t\tTaw: taw,\n\t}\n\treturn StartTimerByObject(core.CoreObject(), tac, ud, interval, 1)\n}\n\nfunc StartTimerByObject(src *basic.Object, ta TimerAction, ud interface{}, interval time.Duration, times int) (TimerHandle, bool) {\n\th := generateTimerHandle()\n\tret := TimerModule.SendCommand(\n\t\t&startTimerCommand{\n\t\t\tsrc:      src,\n\t\t\tta:       ta,\n\t\t\tud:       ud,\n\t\t\tinterval: interval,\n\t\t\ttimes:    times,\n\t\t\th:        h,\n\t\t},\n\t\ttrue)\n\treturn h, ret\n}\n\nfunc StartTimer(ta TimerAction, ud interface{}, interval time.Duration, times int) (TimerHandle, bool) ", "output": "{\n\treturn StartTimerByObject(core.CoreObject(), ta, ud, interval, times)\n}"}
{"input": "package controllers\n\nimport (\n\t\"net/http\"\n)\n\n\ntype SignUpController struct {\n\tBaseController\n}\n\n\n\n\nfunc (suc *SignUpController) Get() ", "output": "{\n\tif suc.AuthMode != \"db_auth\" || !suc.SelfRegistration {\n\t\tsuc.CustomAbort(http.StatusForbidden, \"\")\n\t}\n\tsuc.Data[\"AddNew\"] = false\n\tsuc.Forward(\"page_title_sign_up\", \"sign-up.htm\")\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"os\"\n)\n\ntype ScreenWriter struct {\n\tOut *csv.Writer\n}\n\n\n\nfunc (w ScreenWriter) Close() error {\n\treturn w.Flush()\n}\n\nfunc (w ScreenWriter) Flush() error {\n\tw.Out.Flush()\n\treturn w.Out.Error()\n}\n\nfunc newScreenWriter(out *os.File, delimiter rune) *ScreenWriter {\n\tw := csv.NewWriter(out)\n\tw.Comma = delimiter\n\treturn &ScreenWriter{w}\n}\n\nfunc newStdOutWriter(delimiter rune) *ScreenWriter {\n\treturn newScreenWriter(os.Stdout, delimiter)\n}\n\nfunc newStdErrWriter(delimiter rune) *ScreenWriter {\n\treturn newScreenWriter(os.Stderr, delimiter)\n}\n\nfunc (w ScreenWriter) Print(header []string, data map[string]interface{}) error ", "output": "{\n\tif err := w.Out.Write(convertToRecord(header, data)); err != nil {\n\t\treturn err\n\t}\n\treturn w.Flush()\n}"}
{"input": "package profile_test\n\nimport (\n\t\"flag\"\n\t\"os\"\n\n\t\"github.com/pkg/profile\"\n)\n\n\n\nfunc ExampleCPUProfile() {\n\tdefer profile.Start(profile.CPUProfile).Stop()\n}\n\nfunc ExampleMemProfile() {\n\tdefer profile.Start(profile.MemProfile).Stop()\n}\n\nfunc ExampleMemProfileRate() {\n\tdefer profile.Start(profile.MemProfileRate(2048)).Stop()\n}\n\nfunc ExampleProfilePath() {\n\tdefer profile.Start(profile.ProfilePath(os.Getenv(\"HOME\"))).Stop()\n}\n\nfunc ExampleNoShutdownHook() {\n\tdefer profile.Start(profile.NoShutdownHook).Stop()\n}\n\nfunc ExampleStart_withFlags() {\n\tmode := flag.String(\"profile.mode\", \"\", \"enable profiling mode, one of [cpu, mem, mutex, block]\")\n\tflag.Parse()\n\tswitch *mode {\n\tcase \"cpu\":\n\t\tdefer profile.Start(profile.CPUProfile).Stop()\n\tcase \"mem\":\n\t\tdefer profile.Start(profile.MemProfile).Stop()\n\tcase \"mutex\":\n\t\tdefer profile.Start(profile.MutexProfile).Stop()\n\tcase \"block\":\n\t\tdefer profile.Start(profile.BlockProfile).Stop()\n\tdefault:\n\t}\n}\n\nfunc ExampleStart() ", "output": "{\n\tdefer profile.Start().Stop()\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n\t\"net/http\"\n)\n\n\ntype UpdateDedicatedVmHostRequest struct {\n\n\tDedicatedVmHostId *string `mandatory:\"true\" contributesTo:\"path\" name:\"dedicatedVmHostId\"`\n\n\tUpdateDedicatedVmHostDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\n\n\n\nfunc (request UpdateDedicatedVmHostRequest) HTTPRequest(method, path string) (http.Request, error) {\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request UpdateDedicatedVmHostRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype UpdateDedicatedVmHostResponse struct {\n\n\tRawResponse *http.Response\n\n\tDedicatedVmHost `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response UpdateDedicatedVmHostResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response UpdateDedicatedVmHostResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request UpdateDedicatedVmHostRequest) String() string ", "output": "{\n\treturn common.PointerString(request)\n}"}
{"input": "package neo\n\nimport (\n\t\"net/http\"\n)\n\n\ntype Cookie map[string]*http.Cookie\n\nfunc (cookies Cookie) Get(key string) *http.Cookie {\n\treturn cookies[key]\n}\n\n\n\nfunc (cookies Cookie) Del(key string) {\n\tdelete(cookies, key)\n}\n\n\nfunc (cookies Cookie) SetCustom(cookie *http.Cookie) {\n\tcookies[cookie.Name] = cookie\n}\n\nfunc (cookies Cookie) Set(key string, value string) ", "output": "{\n\tcookies[key] = &http.Cookie{\n\t\tName:  key,\n\t\tValue: value,\n\t\tPath:  \"/\",\n\t}\n}"}
{"input": "package hclwrite\n\nimport (\n\t\"github.com/hashicorp/hcl2/hcl\"\n\t\"github.com/zclconf/go-cty/cty\"\n)\n\ntype Expression struct {\n\tinTree\n\n\tabsTraversals nodeSet\n}\n\nfunc newExpression() *Expression {\n\treturn &Expression{\n\t\tinTree:        newInTree(),\n\t\tabsTraversals: newNodeSet(),\n\t}\n}\n\n\n\nfunc NewExpressionLiteral(val cty.Value) *Expression {\n\tpanic(\"NewExpressionLiteral not yet implemented\")\n}\n\n\n\nfunc NewExpressionAbsTraversal(traversal hcl.Traversal) {\n\tpanic(\"NewExpressionAbsTraversal not yet implemented\")\n}\n\ntype Traversal struct {\n\tinTree\n\n\tsteps nodeSet\n}\n\nfunc newTraversal() *Traversal {\n\treturn &Traversal{\n\t\tinTree: newInTree(),\n\t\tsteps:  newNodeSet(),\n\t}\n}\n\ntype TraverseName struct {\n\tinTree\n\n\tname *node\n}\n\nfunc newTraverseName() *TraverseName {\n\treturn &TraverseName{\n\t\tinTree: newInTree(),\n\t}\n}\n\ntype TraverseIndex struct {\n\tinTree\n\n\tkey *node\n}\n\n\n\nfunc newTraverseIndex() *TraverseIndex ", "output": "{\n\treturn &TraverseIndex{\n\t\tinTree: newInTree(),\n\t}\n}"}
{"input": "package postgres\n\nimport \"github.com/aodin/sol\"\n\n\n\n\n\ntype TableElem struct {\n\t*sol.TableElem\n}\n\nvar _ sol.Tabular = &TableElem{}\n\n\n\n\nfunc (table TableElem) Column(name string) ColumnElem {\n\treturn ColumnElem{ColumnElem: table.TableElem.Column(name)}\n}\n\n\nfunc (table TableElem) C(name string) ColumnElem {\n\treturn table.Column(name)\n}\n\n\n\n\n\nfunc Table(name string, modifiers ...sol.Modifier) *TableElem {\n\treturn &TableElem{TableElem: sol.Table(name, modifiers...)}\n}\n\nfunc (table *TableElem) Insert() InsertStmt ", "output": "{\n\treturn Insert(table)\n}"}
{"input": "package main\n\nimport (\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/gorilla/websocket\"\n)\n\ntype Client struct {\n\thub        *Hub\n\tws         *websocket.Conn\n\totherSide  *Client\n\tchannelID  uuid.UUID\n\tremoteType string\n\tparams     map[string][]string\n\twmu        sync.Mutex\n\trmu        sync.Mutex\n}\n\nfunc (c *Client) WriteMessage(msgType int, message []byte) (err error) {\n\tc.wmu.Lock()\n\terr = c.ws.WriteMessage(msgType, message)\n\tc.wmu.Unlock()\n\treturn\n}\n\nfunc (c *Client) NextWriter(msgType int) (w io.WriteCloser, err error) {\n\tc.wmu.Lock()\n\tw, err = c.ws.NextWriter(msgType)\n\tc.wmu.Unlock()\n\treturn\n}\n\nfunc (c *Client) ReadMessage() (msgType int, message []byte, err error) {\n\tc.rmu.Lock()\n\tmsgType, message, err = c.ws.ReadMessage()\n\tc.rmu.Unlock()\n\treturn\n}\n\n\n\nfunc (c *Client) SetWriteDeadline(t time.Time) (err error) {\n\tc.wmu.Lock()\n\terr = c.ws.SetWriteDeadline(t)\n\tc.wmu.Unlock()\n\treturn\n}\n\nfunc (c *Client) SetReadDeadline(t time.Time) (err error) {\n\tc.rmu.Lock()\n\terr = c.ws.SetReadDeadline(t)\n\tc.rmu.Unlock()\n\treturn\n}\n\nfunc (c *Client) NextReader() (msgType int, r io.Reader, err error) ", "output": "{\n\tc.rmu.Lock()\n\tmsgType, r, err = c.ws.NextReader()\n\tc.rmu.Unlock()\n\treturn\n}"}
{"input": "package pse\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n)\n\nvar (\n\tprocStatFile string\n\tticks        int64\n\tlastTotal    int64\n\tlastSeconds  int64\n\tipcpu        int64\n)\n\nconst (\n\tutimePos = 13\n\tstimePos = 14\n\tstartPos = 21\n\tvssPos   = 22\n\trssPos   = 23\n)\n\nfunc init() {\n\tticks = 100 \n\tprocStatFile = fmt.Sprintf(\"/proc/%d/stat\", os.Getpid())\n\tperiodic()\n}\n\n\n\n\nfunc ProcUsage(pcpu *float64, rss, vss *int64) error {\n\tcontents, err := ioutil.ReadFile(procStatFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfields := bytes.Fields(contents)\n\n\t*rss = (parseInt64(fields[rssPos])) << 12\n\t*vss = parseInt64(fields[vssPos])\n\n\t*pcpu = float64(atomic.LoadInt64(&ipcpu)) / 10.0\n\n\treturn nil\n}\n\n\nconst (\n\tasciiZero = 48\n\tasciiNine = 57\n)\n\n\n\nfunc parseInt64(d []byte) (n int64) {\n\tif len(d) == 0 {\n\t\treturn -1\n\t}\n\tfor _, dec := range d {\n\t\tif dec < asciiZero || dec > asciiNine {\n\t\t\treturn -1\n\t\t}\n\t\tn = n*10 + (int64(dec) - asciiZero)\n\t}\n\treturn n\n}\n\nfunc periodic() ", "output": "{\n\tcontents, err := ioutil.ReadFile(procStatFile)\n\tif err != nil {\n\t\treturn\n\t}\n\tfields := bytes.Fields(contents)\n\n\tpstart := parseInt64(fields[startPos])\n\tutime := parseInt64(fields[utimePos])\n\tstime := parseInt64(fields[stimePos])\n\ttotal := utime + stime\n\n\tvar sysinfo syscall.Sysinfo_t\n\tif err := syscall.Sysinfo(&sysinfo); err != nil {\n\t\treturn\n\t}\n\n\tseconds := int64(sysinfo.Uptime) - (pstart / ticks)\n\n\tlt := lastTotal\n\tls := lastSeconds\n\n\tlastTotal = total\n\tlastSeconds = seconds\n\n\ttotal -= lt\n\tseconds -= ls\n\n\tif seconds > 0 {\n\t\tatomic.StoreInt64(&ipcpu, (total*1000/ticks)/seconds)\n\t}\n\n\ttime.AfterFunc(1*time.Second, periodic)\n}"}
{"input": "package command\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/hashicorp/vault/meta\"\n)\n\n\ntype SealCommand struct {\n\tmeta.Meta\n}\n\nfunc (c *SealCommand) Run(args []string) int {\n\tflags := c.Meta.FlagSet(\"seal\", meta.FlagSetDefault)\n\tflags.Usage = func() { c.Ui.Error(c.Help()) }\n\tif err := flags.Parse(args); err != nil {\n\t\treturn 1\n\t}\n\n\tclient, err := c.Client()\n\tif err != nil {\n\t\tc.Ui.Error(fmt.Sprintf(\n\t\t\t\"Error initializing client: %s\", err))\n\t\treturn 2\n\t}\n\n\tif err := client.Sys().Seal(); err != nil {\n\t\tc.Ui.Error(fmt.Sprintf(\"Error sealing: %s\", err))\n\t\treturn 1\n\t}\n\n\tc.Ui.Output(\"Vault is now sealed.\")\n\treturn 0\n}\n\nfunc (c *SealCommand) Synopsis() string {\n\treturn \"Seals the vault server\"\n}\n\n\n\nfunc (c *SealCommand) Help() string ", "output": "{\n\thelpText := `\nUsage: vault seal [options]\n\n  Seal the vault.\n\n  Sealing a vault tells the Vault server to stop responding to any\n  access operations until it is unsealed again. A sealed vault throws away\n  its master key to unlock the data, so it physically is blocked from\n  responding to operations again until the Vault is unsealed again with\n  the \"unseal\" command or via the API.\n\n  This command is idempotent, if the vault is already sealed it does nothing.\n\n  If an unseal has started, sealing the vault will reset the unsealing\n  process. You'll have to re-enter every portion of the master key again.\n  This is the same as running \"vault unseal -reset\".\n\nGeneral Options:\n` + meta.GeneralOptionsUsage()\n\treturn strings.TrimSpace(helpText)\n}"}
{"input": "package goblazer\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n\n\n\nfunc TimeCostStatistics(start time.Time, name string) ", "output": "{\n\tt := time.Since(start)\n\tfmt.Printf(\"[%-32s] costs %12d nanoseconds.\\n\", name, t)\n}"}
{"input": "package mock\n\nimport (\n\t\"github.com/akutz/goof\"\n\n\t\"github.com/emccode/rexray/core\"\n)\n\nconst mockVolDriverName = \"mockVolumeDriver\"\n\ntype mockVolDriver struct {\n\tname string\n}\n\ntype badMockVolDriver struct {\n\tmockVolDriver\n}\n\nfunc newVolDriver() core.Driver {\n\tvar d core.VolumeDriver = &mockVolDriver{mockVolDriverName}\n\treturn d\n}\n\nfunc newBadVolDriver() core.Driver {\n\tvar d core.VolumeDriver = &badMockVolDriver{\n\t\tmockVolDriver{BadMockVolDriverName}}\n\treturn d\n}\n\nfunc (m *mockVolDriver) Init(r *core.RexRay) error {\n\treturn nil\n}\n\nfunc (m *badMockVolDriver) Init(r *core.RexRay) error {\n\treturn goof.New(\"init error\")\n}\n\nfunc (m *mockVolDriver) Name() string {\n\treturn m.name\n}\n\n\n\nfunc (m *mockVolDriver) Unmount(volumeName, volumeID string) error {\n\treturn nil\n}\n\nfunc (m *mockVolDriver) Path(volumeName, volumeID string) (string, error) {\n\treturn \"\", nil\n}\n\nfunc (m *mockVolDriver) Create(volumeName string, opts core.VolumeOpts) error {\n\treturn nil\n}\n\nfunc (m *mockVolDriver) Remove(volumeName string) error {\n\treturn nil\n}\n\nfunc (m *mockVolDriver) Attach(volumeName, instanceID string, force bool) (string, error) {\n\treturn \"\", nil\n}\n\nfunc (m *mockVolDriver) Detach(volumeName, instanceID string, force bool) error {\n\treturn nil\n}\n\nfunc (m *mockVolDriver) NetworkName(\n\tvolumeName, instanceID string) (string, error) {\n\treturn \"\", nil\n}\n\nfunc (m *mockVolDriver) Mount(\n\tvolumeName, volumeID string,\n\toverwriteFs bool, newFsType string, preempt bool) (string, error) ", "output": "{\n\treturn \"\", nil\n}"}
{"input": "package main\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestCheckPhoneNumber(t *testing.T) ", "output": "{\n\tnumbers := []string{\n\t\t\"07700900390\",\n\t\t\"+447700900497\",\n\t\t\"202-555-0188\",\n\t\t\"+1-202-555-0188\",\n\t}\n\n\tfor _, number := range numbers {\n\t\tcheck := checkNumber(number)\n\t\tif check != true {\n\t\t\tt.Errorf(\"CheckNumber(\\\"%s\\\") == %t, want %t\", number, check, true)\n\t\t}\n\t}\n}"}
{"input": "package common\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/axgle/mahonia\"\n\t\"github.com/saintfish/chardet\"\n)\n\n\nfunc RequestURL(url string) (*http.Response, error) {\n\tclient := &http.Client{}\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"User-Agent\", GetUserAgent())\n\tresponse, err := client.Do(req)\n\treturn response, err\n}\n\n\n\n\n\nfunc DetectBody(body []byte) string {\n\tvar bodyString string\n\tdetector := chardet.NewTextDetector()\n\tresult, err := detector.DetectBest(body)\n\tif err != nil {\n\t\treturn string(body)\n\t}\n\tif strings.Contains(strings.ToLower(result.Charset), \"utf\") {\n\t\tbodyString = string(body)\n\t} else {\n\t\tbodyString = mahonia.NewDecoder(\"gbk\").ConvertString(string(body))\n\t}\n\treturn bodyString\n}\n\n\nfunc StringInSlice(domain string, list []string) bool {\n\tfor _, eachDomain := range list {\n\t\tif domain == eachDomain {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc ReturnDomain(currentURL string) string {\n\turlParse, _ := url.Parse(currentURL)\n\tdomain := urlParse.Host\n\treturn domain\n}\n\nfunc QuickestURL(index int, url string) int ", "output": "{\n\t_, err := http.Get(url)\n\tif err != nil {\n\t\treturn -1\n\t}\n\treturn index\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc bats(l, d, n int, s []string) (c int) {\n\tvar t int\n\ttx := 6 - d\n\tfor i := 6; i <= l-6; i += d {\n\t\tif i > tx-d {\n\t\t\ti = tx\n\t\t\tif t == n {\n\t\t\t\ttx = l - 6 + d\n\t\t\t} else {\n\t\t\t\tfmt.Sscanf(s[t], \"%d\", &tx)\n\t\t\t\tt++\n\t\t\t}\n\t\t} else {\n\t\t\tc++\n\t\t}\n\t}\n\treturn c\n}\n\nfunc TestBats(t *testing.T) ", "output": "{\n\tif r := bats(22, 2, 2, []string{\"9\", \"11\"}); r != 3 {\n\t\tt.Errorf(\"failed: bats 22 2 2 9 11 is 3, got %d\",\n\t\t\tr)\n\t}\n\tif r := bats(835, 125, 1, []string{\"113\"}); r != 5 {\n\t\tt.Errorf(\"failed: bats 835 125 1 113 is 5, got %d\",\n\t\t\tr)\n\t}\n\tif r := bats(47, 5, 0, []string{}); r != 8 {\n\t\tt.Errorf(\"failed: bats 475 5 0 is 8, got %d\",\n\t\t\tr)\n\t}\n}"}
{"input": "package ulule\n\nimport (\n\t\"crypto/tls\"\n\t\"net/http\"\n)\n\n\n\ntype Client struct {\n\tusername    string\n\tuserid      string\n\tapikey      string\n\taccessToken string\n\tpassword    string\n\n\thttpClient *http.Client\n}\n\n\n\n\n\n\nfunc ClientWithToken(accessToken string) *Client {\n\tclientAPI := &Client{\n\t\taccessToken: accessToken,\n\t}\n\tclientAPI.initHttpClient()\n\treturn clientAPI\n}\n\n\n\nfunc (c *Client) initHttpClient() {\n\ttransport := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\tc.httpClient = &http.Client{Transport: transport}\n}\n\nfunc ClientWithUsernameAndApiKey(username, apikey string) *Client ", "output": "{\n\tclientAPI := &Client{\n\t\tusername: username,\n\t\tapikey:   apikey,\n\t}\n\tclientAPI.initHttpClient()\n\treturn clientAPI\n}"}
{"input": "package auburnredis\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/garyburd/redigo/redis\"\n\t\"github.com/zerklabs/auburn/utils\"\n)\n\n\n\nfunc (c *Cluster) HasMoved(reply interface{}, err error) (bool, utils.DialEndpoint, interface{}, error) {\n\tvar slotHost string\n\tvar ep utils.DialEndpoint\n\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), \"MOVED\") {\n\t\t\tlastSpace := strings.LastIndex(err.Error(), \" \")\n\t\t\tslotHost = err.Error()[lastSpace+1:]\n\n\t\t\tep = c.Endpoints[slotHost]\n\n\t\t\treturn true, ep, reply, nil\n\t\t}\n\t}\n\n\treturn false, ep, reply, err\n}\n\nfunc (c *Cluster) SendHasMoved(err error) (bool, utils.DialEndpoint, error) {\n\tvar slotHost string\n\tvar ep utils.DialEndpoint\n\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), \"MOVED\") {\n\t\t\tlastSpace := strings.LastIndex(err.Error(), \" \")\n\t\t\tslotHost = err.Error()[lastSpace+1:]\n\n\t\t\tep = c.Endpoints[slotHost]\n\n\t\t\treturn true, ep, nil\n\t\t}\n\t}\n\n\treturn false, ep, err\n}\n\nfunc (c *Cluster) Do(cmd string, args ...interface{}) (interface{}, error) ", "output": "{\n\tfor k := range c.Endpoints {\n\t\tep := c.Endpoints[k]\n\n\t\tconn, err := redis.Dial(\"tcp\", ep.Address)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Failed to connect: %v\", err)\n\t\t}\n\n\t\tdefer conn.Close()\n\n\t\tmoved, newEndpoint, reply, err := c.HasMoved(conn.Do(cmd, args...))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Error executing command: %v\", err)\n\t\t}\n\t\tif !moved {\n\t\t\treturn reply, err\n\t\t}\n\n\t\tnconn, err := redis.Dial(\"tcp\", newEndpoint.Address)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Failed to connect: %v\", err)\n\t\t}\n\t\tdefer nconn.Close()\n\n\t\treturn nconn.Do(cmd, args...)\n\t}\n\n\treturn nil, fmt.Errorf(\"no endpoints\")\n}"}
{"input": "package armbilling_test\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azcore/to\"\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azidentity\"\n\t\"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/billing/armbilling\"\n)\n\n\n\n\nfunc ExampleAddressClient_Validate() ", "output": "{\n\tcred, err := azidentity.NewDefaultAzureCredential(nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to obtain a credential: %v\", err)\n\t}\n\tctx := context.Background()\n\tclient := armbilling.NewAddressClient(cred, nil)\n\tres, err := client.Validate(ctx,\n\t\tarmbilling.AddressDetails{\n\t\t\tAddressLine1: to.StringPtr(\"<address-line1>\"),\n\t\t\tCity:         to.StringPtr(\"<city>\"),\n\t\t\tCountry:      to.StringPtr(\"<country>\"),\n\t\t\tPostalCode:   to.StringPtr(\"<postal-code>\"),\n\t\t\tRegion:       to.StringPtr(\"<region>\"),\n\t\t},\n\t\tnil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"Response result: %#v\\n\", res.AddressClientValidateResult)\n}"}
{"input": "package tweetharvest\n\nimport (\n\t\"time\"\n\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/appengine/datastore\"\n\t\"google.golang.org/appengine/log\"\n)\n\nconst tweetKey string = \"Tweets\"\nconst tweetKeyID string = \"default_tweetstore\"\n\n\n\n\n\nfunc getNewestTweet(c context.Context) time.Time {\n\tvar latest LinkTweet\n\n\tq := datastore.NewQuery(linkTweetKind).Order(\"-CreatedTime\").Project(\"CreatedTime\").Limit(1)\n\tq.GetAll(c, latest)\n\ti := q.Run(c)\n\ti.Next(&latest)\n\ttime, _ := latest.CreatedAtTime()\n\treturn time\n}\n\n\nfunc getTweetKey(c context.Context) *datastore.Key {\n\treturn datastore.NewKey(c, tweetKey, tweetKeyID, 0, nil)\n}\n\n\nfunc LinkTweetFromDatastore(tweetID int64, c context.Context) *LinkTweet {\n\tq := datastore.NewQuery(linkTweetKind).\n\t\tFilter(\"TweetID =\", tweetID).\n\t\tLimit(1)\n\n\titerator := q.Run(c)\n\tlinkTweet := &LinkTweet{}\n\t_, err := iterator.Next(linkTweet)\n\tif err != nil {\n\t\treturn nil\n\t}\n\treturn linkTweet\n}\n\nfunc GetAllNewTweets(since time.Time, c context.Context) LinkTweets ", "output": "{\n\tlog.Infof(c, \"Getting all tweets newer than: %v\", since)\n\tq := datastore.NewQuery(linkTweetKind).Ancestor(getTweetKey(c)).Filter(\"CreatedTime >\", since)\n\tout := make(LinkTweets, 0, 15)\n\tq.GetAll(c, &out)\n\treturn out\n}"}
{"input": "package registrar\n\nimport (\n\t\"sync\"\n\n\t\"github.com/pkg/errors\"\n)\n\n\n\n\ntype Registrar struct {\n\tlock      sync.Mutex\n\tnameToKey map[string]string\n\tkeyToName map[string]string\n}\n\n\nfunc NewRegistrar() *Registrar {\n\treturn &Registrar{\n\t\tnameToKey: make(map[string]string),\n\t\tkeyToName: make(map[string]string),\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc (r *Registrar) ReleaseByName(name string) {\n\tr.lock.Lock()\n\tdefer r.lock.Unlock()\n\n\tkey, exists := r.nameToKey[name]\n\tif !exists {\n\t\treturn\n\t}\n\n\tdelete(r.nameToKey, name)\n\tdelete(r.keyToName, key)\n}\n\n\nfunc (r *Registrar) ReleaseByKey(key string) {\n\tr.lock.Lock()\n\tdefer r.lock.Unlock()\n\n\tname, exists := r.keyToName[key]\n\tif !exists {\n\t\treturn\n\t}\n\n\tdelete(r.nameToKey, name)\n\tdelete(r.keyToName, key)\n}\n\nfunc (r *Registrar) Reserve(name, key string) error ", "output": "{\n\tr.lock.Lock()\n\tdefer r.lock.Unlock()\n\n\tif name == \"\" || key == \"\" {\n\t\treturn errors.Errorf(\"invalid name %q or key %q\", name, key)\n\t}\n\n\tif k, exists := r.nameToKey[name]; exists {\n\t\tif k != key {\n\t\t\treturn errors.Errorf(\"name %q is reserved for %q\", name, k)\n\t\t}\n\t\treturn nil\n\t}\n\n\tif n, exists := r.keyToName[key]; exists {\n\t\tif n != name {\n\t\t\treturn errors.Errorf(\"key %q is reserved for %q\", key, n)\n\t\t}\n\t\treturn nil\n\t}\n\n\tr.nameToKey[name] = key\n\tr.keyToName[key] = name\n\treturn nil\n}"}
{"input": "package main\n\nimport \"fmt\"\nimport \"net\"\n\n\n\nfunc main() {\n\tfmt.Println(\"Start server.....\")\n\tlisten, err := net.Listen(\"tcp\", \"127.0.0.1:50000\")\n\tif err != nil {\n\t\tfmt.Println(\"Listen fail \", err)\n\t\treturn\n\t}\n\n\tfor {\n\t\tconn, err := listen.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Accept error \", err)\n\t\t\treturn\n\t\t}\n\n\t\tgo process(conn)\n\n\t}\n\n}\n\nfunc process(conn net.Conn) ", "output": "{\n\tdefer conn.Close()\n\n\tfor {\n\t\tbuf := make([]byte, 512)\n\t\t_, err := conn.Read(buf)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"read err\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(\"read:\", string(buf))\n\t}\n}"}
{"input": "package scheduler\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\n\nconst (\n\tdefaultWorkManagerQueueSize uint = 25\n\tdefaultWorkManagerPoolSize  uint = 4\n)\n\n\n\n\n\ntype Config struct {\n\tWorkManagerQueueSize uint `json:\"work_manager_queue_size\"yaml:\"work_manager_queue_size\"`\n\tWorkManagerPoolSize  uint `json:\"work_manager_pool_size\"yaml:\"work_manager_pool_size\"`\n}\n\nconst (\n\tCONFIG_CONSTRAINTS = `\n\t\t\t\"scheduler\": {\n\t\t\t\t\"type\": [\"object\", \"null\"],\n\t\t\t\t\"properties\" : {\n\t\t\t\t\t\"work_manager_queue_size\" : {\n\t\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\t\"minimum\": 1\n\t\t\t\t\t},\n\t\t\t\t\t\"work_manager_pool_size\" : {\n\t\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\t\"minimum\": 1\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false\n\t\t\t}\n\t`\n)\n\n\nfunc GetDefaultConfig() *Config {\n\treturn &Config{\n\t\tWorkManagerQueueSize: defaultWorkManagerQueueSize,\n\t\tWorkManagerPoolSize:  defaultWorkManagerPoolSize,\n\t}\n}\n\n\n\n\n\nfunc (c *Config) UnmarshalJSON(data []byte) error ", "output": "{\n\tt := make(map[string]json.RawMessage)\n\tif err := json.Unmarshal(data, &t); err != nil {\n\t\treturn err\n\t}\n\tfor k, v := range t {\n\t\tswitch k {\n\t\tcase \"work_manager_queue_size\":\n\t\t\tif err := json.Unmarshal(v, &(c.WorkManagerQueueSize)); err != nil {\n\t\t\t\treturn fmt.Errorf(\"%v (while parsing 'scheduler::work_manager_queue_size')\", err)\n\t\t\t}\n\t\tcase \"work_manager_pool_size\":\n\t\t\tif err := json.Unmarshal(v, &(c.WorkManagerPoolSize)); err != nil {\n\t\t\t\treturn fmt.Errorf(\"%v (while parsing 'scheduler::work_manager_pool_size')\", err)\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"Unrecognized key '%v' in global config file while parsing 'scheduler'\", k)\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package kubernetes\n\nimport (\n\t\"fmt\"\n\n\t\"$GITHUB_URI/report\"\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/labels\"\n)\n\n\ntype ReplicationController interface {\n\tMeta\n\tSelector() labels.Selector\n\tAddParent(topology, id string)\n\tGetNode(probeID string) report.Node\n}\n\ntype replicationController struct {\n\t*api.ReplicationController\n\tMeta\n\tparents report.Sets\n\tNode    *api.Node\n}\n\n\nfunc NewReplicationController(r *api.ReplicationController) ReplicationController {\n\treturn &replicationController{\n\t\tReplicationController: r,\n\t\tMeta:    meta{r.ObjectMeta},\n\t\tparents: report.MakeSets(),\n\t}\n}\n\n\n\nfunc (r *replicationController) AddParent(topology, id string) {\n\tr.parents = r.parents.Add(topology, report.MakeStringSet(id))\n}\n\nfunc (r *replicationController) GetNode(probeID string) report.Node {\n\treturn r.MetaNode(report.MakeReplicaSetNodeID(r.UID())).WithLatests(map[string]string{\n\t\tObservedGeneration:    fmt.Sprint(r.Status.ObservedGeneration),\n\t\tReplicas:              fmt.Sprint(r.Status.Replicas),\n\t\tDesiredReplicas:       fmt.Sprint(r.Spec.Replicas),\n\t\tFullyLabeledReplicas:  fmt.Sprint(r.Status.FullyLabeledReplicas),\n\t\treport.ControlProbeID: probeID,\n\t}).WithParents(r.parents).WithControls(ScaleUp, ScaleDown)\n}\n\nfunc (r *replicationController) Selector() labels.Selector ", "output": "{\n\tif r.Spec.Selector == nil {\n\t\treturn labels.Nothing()\n\t}\n\treturn labels.SelectorFromSet(labels.Set(r.Spec.Selector))\n}"}
{"input": "package speech_test\n\nimport (\n\t\"io\"\n\n\t\"cloud.google.com/go/speech/apiv1beta1\"\n\t\"github.com/golang/protobuf/ptypes\"\n\t\"golang.org/x/net/context\"\n\tspeechpb \"google.golang.org/genproto/googleapis/cloud/speech/v1beta1\"\n)\n\nfunc ExampleNewClient() {\n\tctx := context.Background()\n\tc, err := speech.NewClient(ctx)\n\tif err != nil {\n\t}\n\t_ = c\n}\n\nfunc ExampleClient_SyncRecognize() {\n\tctx := context.Background()\n\tc, err := speech.NewClient(ctx)\n\tif err != nil {\n\t}\n\n\treq := &speechpb.SyncRecognizeRequest{\n\t}\n\tresp, err := c.SyncRecognize(ctx, req)\n\tif err != nil {\n\t}\n\t_ = resp\n}\n\n\n\nfunc StreamingRecognize() {\n\tctx := context.Background()\n\tc, err := speech.NewClient(ctx)\n\tif err != nil {\n\t}\n\tstream, err := c.StreamingRecognize(ctx)\n\tif err != nil {\n\t}\n\tgo func() {\n\t\treqs := []*speechpb.StreamingRecognizeRequest{\n\t\t}\n\t\tfor _, req := range reqs {\n\t\t\tif err := stream.Send(req); err != nil {\n\t\t\t}\n\t\t}\n\t\tstream.CloseSend()\n\t}()\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t}\n\t\t_ = resp\n\t}\n}\n\nfunc ExampleClient_AsyncRecognize() ", "output": "{\n\tctx := context.Background()\n\tc, err := speech.NewClient(ctx)\n\tif err != nil {\n\t}\n\n\treq := &speechpb.AsyncRecognizeRequest{\n\t}\n\top, err := c.AsyncRecognize(ctx, req)\n\tif err != nil {\n\t}\n\n\tvar resp ptypes.DynamicAny \n\tif err := op.Wait(ctx, &resp); err != nil {\n\t}\n}"}
{"input": "package time\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"time\"\n)\n\n\nfunc Difference(t1, t2 time.Time) string {\n\tseconds := math.Abs(t1.Sub(t2).Seconds())\n\tif seconds < 1 {\n\t\treturn \"just now\"\n\t}\n\tvar end string\n\tif t1.After(t2) {\n\t\tend = \"ago\"\n\t} else {\n\t\tend = \"from now\"\n\t}\n\tminutes := seconds / 60\n\tif minutes < 1 {\n\t\treturn createString(seconds, \"second\", end)\n\t}\n\thours := minutes / 60\n\tif hours < 1 {\n\t\treturn createString(minutes, \"minute\", end)\n\t}\n\tdays := hours / 24\n\tif days < 1 {\n\t\treturn createString(hours, \"hour\", end)\n\t}\n\tweeks := days / 7\n\tif weeks < 1 {\n\t\treturn createString(days, \"day\", end)\n\t}\n\tmonths := weeks / 4\n\tif months < 1 {\n\t\treturn createString(weeks, \"week\", end)\n\t}\n\tyears := months / 12\n\tif years < 1 {\n\t\treturn createString(months, \"month\", end)\n\t}\n\treturn createString(years, \"year\", end)\n}\n\n\n\nfunc createString(n float64, precision string, end string) string ", "output": "{\n\tn = math.Floor(n + 0.5)\n\tif n > 1 {\n\t\treturn fmt.Sprintf(\"%d %ss %s\", int(n), precision, end)\n\t}\n\treturn fmt.Sprintf(\"%d %s %s\", int(n), precision, end)\n}"}
{"input": "package mock\n\nimport (\n\t\"github.com/tendermint/tendermint/rpc/client\"\n\tctypes \"github.com/tendermint/tendermint/rpc/core/types\"\n)\n\n\ntype StatusMock struct {\n\tCall\n}\n\nfunc (m *StatusMock) _assertStatusClient() client.StatusClient {\n\treturn m\n}\n\nfunc (m *StatusMock) Status() (*ctypes.ResultStatus, error) {\n\tres, err := m.GetResponse(nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn res.(*ctypes.ResultStatus), nil\n}\n\n\n\ntype StatusRecorder struct {\n\tClient client.StatusClient\n\tCalls  []Call\n}\n\nfunc NewStatusRecorder(client client.StatusClient) *StatusRecorder {\n\treturn &StatusRecorder{\n\t\tClient: client,\n\t\tCalls:  []Call{},\n\t}\n}\n\n\n\nfunc (r *StatusRecorder) addCall(call Call) {\n\tr.Calls = append(r.Calls, call)\n}\n\nfunc (r *StatusRecorder) Status() (*ctypes.ResultStatus, error) {\n\tres, err := r.Client.Status()\n\tr.addCall(Call{\n\t\tName:     \"status\",\n\t\tResponse: res,\n\t\tError:    err,\n\t})\n\treturn res, err\n}\n\nfunc (r *StatusRecorder) _assertStatusClient() client.StatusClient ", "output": "{\n\treturn r\n}"}
{"input": "package account\n\nimport (\n\t\"flag\"\n\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/vmware/govmomi/govc/cli\"\n)\n\ntype update struct {\n\t*AccountFlag\n}\n\n\n\nfunc (cmd *update) Register(ctx context.Context, f *flag.FlagSet) {\n\tcmd.AccountFlag, ctx = newAccountFlag(ctx)\n\tcmd.AccountFlag.Register(ctx, f)\n}\n\nfunc (cmd *update) Process(ctx context.Context) error {\n\tif err := cmd.AccountFlag.Process(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (cmd *update) Run(ctx context.Context, f *flag.FlagSet) error {\n\tm, err := cmd.AccountFlag.HostAccountManager(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn m.Update(ctx, &cmd.HostAccountSpec)\n}\n\nfunc init() ", "output": "{\n\tcli.Register(\"host.account.update\", &update{})\n}"}
{"input": "package yaormfilter\n\n\ntype NilFilter struct {\n\tvaluefilterimpl\n}\n\n\nfunc NewNilFilter() ValueFilter {\n\treturn &NilFilter{}\n}\n\n\nfunc (f *NilFilter) Equals(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) NotEquals(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Like(v interface{}) ValueFilter {\n\treturn f\n}\n\n\n\n\n\nfunc (f *NilFilter) Nil(v bool) ValueFilter {\n\tf.nil(v)\n\treturn f\n\n}\n\n\nfunc (f *NilFilter) In(values ...interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) NotIn(values ...interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Lt(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Lte(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Gt(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Gte(v interface{}) ValueFilter {\n\treturn f\n}\n\n\nfunc (f *NilFilter) Raw(s RawFilterFunc) ValueFilter {\n\tf.raw(s)\n\treturn f\n}\n\nfunc (f *NilFilter) ILike(v interface{}) ValueFilter ", "output": "{\n\treturn f\n}"}
{"input": "package util\n\nimport (\n\t\"k8s.io/kubernetes/pkg/api/registered\"\n\t\"k8s.io/kubernetes/pkg/client\"\n\t\"k8s.io/kubernetes/pkg/client/clientcmd\"\n)\n\nfunc NewClientCache(loader clientcmd.ClientConfig) *clientCache {\n\treturn &clientCache{\n\t\tclients: make(map[string]*client.Client),\n\t\tconfigs: make(map[string]*client.Config),\n\t\tloader:  loader,\n\t}\n}\n\n\n\ntype clientCache struct {\n\tloader        clientcmd.ClientConfig\n\tclients       map[string]*client.Client\n\tconfigs       map[string]*client.Config\n\tdefaultConfig *client.Config\n\tdefaultClient *client.Client\n\tmatchVersion  bool\n}\n\n\n\n\n\n\nfunc (c *clientCache) ClientForVersion(version string) (*client.Client, error) {\n\tif client, ok := c.clients[version]; ok {\n\t\treturn client, nil\n\t}\n\tconfig, err := c.ClientConfigForVersion(version)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := client.New(config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc.clients[config.Version] = client\n\treturn client, nil\n}\n\nfunc (c *clientCache) ClientConfigForVersion(version string) (*client.Config, error) ", "output": "{\n\tif c.defaultConfig == nil {\n\t\tconfig, err := c.loader.ClientConfig()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tc.defaultConfig = config\n\t\tif c.matchVersion {\n\t\t\tif err := client.MatchesServerVersion(c.defaultClient, config); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\tif config, ok := c.configs[version]; ok {\n\t\treturn config, nil\n\t}\n\tconfig := *c.defaultConfig\n\tnegotiatedVersion, err := client.NegotiateVersion(c.defaultClient, &config, version, registered.RegisteredVersions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.Version = negotiatedVersion\n\tclient.SetKubernetesDefaults(&config)\n\tc.configs[version] = &config\n\n\treturn &config, nil\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/julienschmidt/httprouter\"\n\t\"net/http\"\n)\n\ntype Logout struct {\n\t*Controller\n}\n\n\n\nfunc NewLogoutController(c *Controller, router *httprouter.Router) {\n\tlogout := &Logout{\n\t\tc,\n\t}\n\tlogout.Register(router)\n}\n\n\n\n\n\n\n\nfunc (l *Logout) Get(res http.ResponseWriter, req *http.Request, _ httprouter.Params) {\n\tl.Authentication.ClearSession(res)\n\thttp.Redirect(res, req, \"/login\", http.StatusFound)\n}\n\nfunc (l *Logout) Register(router *httprouter.Router) ", "output": "{\n\trouter.GET(\"/logout\", l.Get)\n}"}
{"input": "package commands\n\nimport (\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/spf13/cobra\"\n)\n\nfunc Execute() {\n\trootCmd := &cobra.Command{Use: \"htflood\"}\n\tsetupCommands(rootCmd)\n\trootCmd.Execute()\n}\n\n\n\nfunc checkedRun(run func(cmd *cobra.Command, args []string) error) func(cmd *cobra.Command, args []string) {\n\n\treturn func(cmd *cobra.Command, args []string) {\n\t\tif err := run(cmd, args); err != nil {\n\t\t\tlog.Fatalf(\"%v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n}\n\nfunc setupCommands(rootCmd *cobra.Command) ", "output": "{\n\trootCmd.AddCommand(botCommand)\n\trootCmd.AddCommand(statsCommand)\n\trootCmd.AddCommand(reqCommand)\n}"}
{"input": "package readline\n\nimport \"io\"\n\ntype Instance struct {\n\tt *Terminal\n\to *Operation\n}\n\ntype Config struct {\n\tPrompt      string\n\tHistoryFile string\n}\n\nfunc NewEx(cfg *Config) (*Instance, error) {\n\tt, err := NewTerminal(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trl := t.Readline()\n\treturn &Instance{\n\t\tt: t,\n\t\to: rl,\n\t}, nil\n}\n\n\n\nfunc (i *Instance) Stdout() io.Writer {\n\treturn i.o.Stdout()\n}\n\nfunc (i *Instance) Stderr() io.Writer {\n\treturn i.o.Stderr()\n}\n\nfunc (i *Instance) Readline() (string, error) {\n\treturn i.o.String()\n}\n\nfunc (i *Instance) ReadSlice() ([]byte, error) {\n\treturn i.o.Slice()\n}\n\nfunc (i *Instance) Close() error {\n\tif err := i.t.Close(); err != nil {\n\t\treturn err\n\t}\n\ti.o.Close()\n\treturn nil\n}\n\nfunc New(prompt string) (*Instance, error) ", "output": "{\n\treturn NewEx(&Config{Prompt: prompt})\n}"}
{"input": "package gogs\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nfunc (c *Client) AdminCreateOrg(user string, opt CreateOrgOption) (*Organization, error) {\n\tbody, err := json.Marshal(&opt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\torg := new(Organization)\n\treturn org, c.getParsedResponse(\"POST\", fmt.Sprintf(\"/admin/users/%s/orgs\", user),\n\t\tjsonHeader, bytes.NewReader(body), org)\n}\n\nfunc (c *Client) AdminCreateTeam(user string, opt CreateTeamOption) (*Team, error) {\n\tbody, err := json.Marshal(&opt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tteam := new(Team)\n\treturn team, c.getParsedResponse(\"POST\", fmt.Sprintf(\"/admin/orgs/%s/teams\", user),\n\t\tjsonHeader, bytes.NewReader(body), team)\n}\n\n\n\nfunc (c *Client) AdminAddTeamRepository(teamID int64, repo string) error {\n\t_, err := c.getResponse(\"PUT\", fmt.Sprintf(\"/admin/teams/%d/repos/%s\", teamID, repo),\n\t\tjsonHeader, nil)\n\treturn err\n}\n\nfunc (c *Client) AdminAddTeamMembership(teamID int64, user string) error ", "output": "{\n\t_, err := c.getResponse(\"PUT\", fmt.Sprintf(\"/admin/teams/%d/members/%s\", teamID, user),\n\t\tjsonHeader, nil)\n\treturn err\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n\n\nfunc main() {\n\toperation := \"\"\n\tif len(os.Args) > 1 {\n\t\toperation = os.Args[1]\n\t}\n\n\tswitch operation {\n\tcase \"new\":\n\t\targ := \"\"\n\t\tif len(os.Args) > 2 {\n\t\t\targ = os.Args[2]\n\t\t}\n\t\tNew(arg)\n\t\tos.Exit(0)\n\tcase \"squish\":\n\t\tSquish()\n\t\tos.Exit(0)\n\tcase \"rebase\":\n\t\tRebase()\n\t\tos.Exit(0)\n\tcase \"save\":\n\t\tSave()\n\t\tos.Exit(0)\n\tcase \"pull\":\n\tcase \"merge\":\n\t\tMerge(os.Args[2:])\n\t\tos.Exit(0)\n\tcase \"ptal\":\n\t\tPtal()\n\tcase \"help\":\n\t\tUsage()\n\t\tos.Exit(0)\n\tdefault:\n\t\tfmt.Printf(\"unknown operation: %s\", operation)\n\t\tUsage()\n\t\tos.Exit(1)\n\t}\n}\n\nfunc Usage() ", "output": "{\n\tfmt.Printf(`usage: %s <subcommand> <options>\n\nSubcommands:\n\n  help   - display this text\n  new    - create a new change and switch to it\n  squish - combine commits\n  rebase - combine commits using rebase\n  save   - commit all changes with a generic commit message\n  ptal   - mark a PR as ready for review\n  merge  - merge a PR into the master\n\n`, os.Args[0])\n}"}
{"input": "package kernel\n\nimport (\n\t\"bytes\"\n\n\t\"github.com/sirupsen/logrus\"\n)\n\n\nfunc GetKernelVersion() (*VersionInfo, error) {\n\tuts, err := uname()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trelease := make([]byte, len(uts.Release))\n\n\ti := 0\n\tfor _, c := range uts.Release {\n\t\trelease[i] = byte(c)\n\t\ti++\n\t}\n\n\trelease = release[:bytes.IndexByte(release, 0)]\n\n\treturn ParseRelease(string(release))\n}\n\n\n\n\n\nfunc CheckKernelVersion(k, major, minor int) bool ", "output": "{\n\tif v, err := GetKernelVersion(); err != nil {\n\t\tlogrus.Warnf(\"Error getting kernel version: %s\", err)\n\t} else {\n\t\tif CompareKernelVersion(*v, VersionInfo{Kernel: k, Major: major, Minor: minor}) < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"}
{"input": "package alpine\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestYAMLParsing(t *testing.T) ", "output": "{\n\t_, filename, _, _ := runtime.Caller(0)\n\tpath := filepath.Join(filepath.Dir(filename))\n\n\ttestData, _ := os.Open(path + \"/testdata/v34_main.yaml\")\n\tdefer testData.Close()\n\n\tvulns, err := parseYAML(testData)\n\tif err != nil {\n\t\tassert.Nil(t, err)\n\t}\n\tassert.Equal(t, 105, len(vulns))\n\tassert.Equal(t, \"CVE-2016-5387\", vulns[0].Name)\n\tassert.Equal(t, \"alpine:v3.4\", vulns[0].FixedIn[0].Feature.Namespace.Name)\n\tassert.Equal(t, \"apache2\", vulns[0].FixedIn[0].Feature.Name)\n\tassert.Equal(t, \"https:cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-5387\", vulns[0].Link)\n}"}
{"input": "package goiaf\n\nimport (\n\t\"net/url\"\n\t\"strconv\"\n\t\"time\"\n)\n\n\ntype BookRequest interface {\n\tParamConverter\n\n\tLimit(int) BookRequest\n\n\tName(string) BookRequest\n\n\tFromReleaseDate(time.Time) BookRequest\n\n\tToReleaseDate(time.Time) BookRequest\n}\n\n\nfunc NewBookRequest() BookRequest {\n\tb := bookRequest{}\n\tb.limit = 10\n\treturn b\n}\n\ntype bookRequest struct {\n\trequest\n\n\tname            *string\n\tfromReleaseDate *string\n\ttoReleaseDate   *string\n}\n\nfunc (request bookRequest) Limit(value int) BookRequest {\n\trequest.limit = value\n\treturn request\n}\n\n\n\nfunc (request bookRequest) FromReleaseDate(value time.Time) BookRequest {\n\tv := value.Format(time.RFC3339)\n\trequest.fromReleaseDate = &v\n\treturn request\n}\n\nfunc (request bookRequest) ToReleaseDate(value time.Time) BookRequest {\n\tv := value.Format(time.RFC3339)\n\trequest.toReleaseDate = &v\n\treturn request\n}\n\nfunc (request bookRequest) Convert() url.Values {\n\tparams := url.Values{}\n\tparams.Add(\"page\", strconv.Itoa(request.limit))\n\n\tif request.page != nil {\n\t\tparams.Set(\"pageSize\", strconv.Itoa(*request.page))\n\t}\n\tif request.name != nil {\n\t\tparams.Set(\"name\", *request.name)\n\t}\n\tif request.fromReleaseDate != nil {\n\t\tparams.Set(\"fromReleaseDate\", *request.fromReleaseDate)\n\t}\n\tif request.toReleaseDate != nil {\n\t\tparams.Set(\"toReleaseDate\", *request.toReleaseDate)\n\t}\n\n\treturn params\n}\n\nfunc (request bookRequest) Name(value string) BookRequest ", "output": "{\n\trequest.name = &value\n\treturn request\n}"}
{"input": "package cache\n\nimport \"github.com/lomik/go-carbon/points\"\n\n\ntype Query struct {\n\tMetric    string\n\tReplyChan chan *Reply\n}\n\n\nfunc NewQuery(metric string) *Query {\n\treturn &Query{\n\t\tMetric:    metric,\n\t\tReplyChan: make(chan *Reply, 1),\n\t}\n}\n\n\ntype Reply struct {\n\tPoints *points.Points\n}\n\n\n\n\nfunc NewReply() *Reply ", "output": "{\n\treturn &Reply{}\n}"}
{"input": "package cachestore\n\nimport (\n\t\"encoding/json\"\n\t\"sync\"\n)\n\n\n\ntype KVStore struct {\n\tstoreMap map[string]interface{}\n\tmutex sync.RWMutex\n}\n\n\nfunc (store *KVStore) Set(key string, value interface{}) {\n\tstore.mutex.Lock()\n\tstore.storeMap[key] = value\n\tstore.mutex.Unlock()\n}\n\n\nfunc (store *KVStore) Get(key string) interface{} {\n\tstore.mutex.RLock()\n\tval := store.storeMap[key]\n\tstore.mutex.RUnlock()\n\treturn val\n}\n\n\n\n\n\nfunc (store *KVStore) MarshalJSON() ([]byte, error) {\n\tstore.mutex.RLock()\n\tbytes, err := json.Marshal(store.storeMap)\n\tstore.mutex.RUnlock()\n\treturn bytes, err\n}\n\n\nfunc NewKVStore() *KVStore {\n\treturn &KVStore{map[string]interface{}{}, sync.RWMutex{}}\n}\n\nfunc (store *KVStore) Delete(key string) ", "output": "{\n\tstore.mutex.Lock()\n\tdelete(store.storeMap, key)\n\tstore.mutex.Unlock()\n}"}
{"input": "package wherez\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc DisabledTestFindPeers(t *testing.T) {\n\tc := FindAuthenticatedPeers(60000, 31337, 1, []byte(\"wherezexample\"))\n\tfor p := range c {\n\t\tt.Logf(\"Found %v\", p.String())\n\t\treturn\n\t}\n}\n\nfunc TestInfoHash(t *testing.T) ", "output": "{\n\tih, err := infoHash([]byte(\"aaaaa\"))\n\tif err != nil {\n\t\tt.Errorf(\"infoHash error: %v\", err)\n\t}\n\tif fmt.Sprintf(\"%x\", ih) != \"97207c9437e672af8e1731f6a7200a78623886ea\" {\n\t\tt.Errorf(\"Unexpected ih: %x\", ih)\n\t}\n}"}
{"input": "package tracker\n\nimport (\n\t\"github.com/majestrate/XD/lib/common\"\n\t\"github.com/majestrate/XD/lib/network\"\n\t\"net/url\"\n\t\"time\"\n)\n\ntype Event string\n\nconst Started = Event(\"started\")\nconst Stopped = Event(\"stopped\")\nconst Completed = Event(\"completed\")\nconst Nop = Event(\"\")\n\n\n\ntype Request struct {\n\tInfohash   common.Infohash\n\tPeerID     common.PeerID\n\tPort       int\n\tUploaded   uint64\n\tDownloaded uint64\n\tLeft       uint64\n\tEvent      Event\n\tNumWant    int\n\tCompact    bool\n\tGetNetwork func() network.Network\n}\n\ntype Response struct {\n\tInterval     int           `bencode:\"interval\"`\n\tPeers        []common.Peer `bencode:\"peers\"`\n\tError        string        `bencode:\"failure reason\"`\n\tNextAnnounce time.Time     `bencode:\"-\"`\n}\n\n\ntype Announcer interface {\n\tAnnounce(req *Request) (*Response, error)\n\tName() string\n}\n\n\n\nfunc FromURL(str string) Announcer {\n\tu, err := url.Parse(str)\n\tif err == nil {\n\t\tif u.Scheme == \"http\" {\n\t\t\treturn NewHttpTracker(u)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (ev Event) String() string ", "output": "{\n\treturn string(ev)\n}"}
{"input": "package repo\n\nimport (\n\t\"context\"\n\n\t\"code.gitea.io/gitea/models/db\"\n)\n\nfunc getRepositoriesByForkID(e db.Engine, forkID int64) ([]*Repository, error) {\n\trepos := make([]*Repository, 0, 10)\n\treturn repos, e.\n\t\tWhere(\"fork_id=?\", forkID).\n\t\tFind(&repos)\n}\n\n\nfunc GetRepositoriesByForkID(ctx context.Context, forkID int64) ([]*Repository, error) {\n\treturn getRepositoriesByForkID(db.GetEngine(ctx), forkID)\n}\n\n\nfunc GetForkedRepo(ownerID, repoID int64) *Repository {\n\trepo := new(Repository)\n\thas, _ := db.GetEngine(db.DefaultContext).\n\t\tWhere(\"owner_id=? AND fork_id=?\", ownerID, repoID).\n\t\tGet(repo)\n\tif has {\n\t\treturn repo\n\t}\n\treturn nil\n}\n\n\nfunc HasForkedRepo(ownerID, repoID int64) bool {\n\thas, _ := db.GetEngine(db.DefaultContext).\n\t\tTable(\"repository\").\n\t\tWhere(\"owner_id=? AND fork_id=?\", ownerID, repoID).\n\t\tExist()\n\treturn has\n}\n\n\n\n\n\nfunc GetForks(repo *Repository, listOptions db.ListOptions) ([]*Repository, error) {\n\tif listOptions.Page == 0 {\n\t\tforks := make([]*Repository, 0, repo.NumForks)\n\t\treturn forks, db.GetEngine(db.DefaultContext).Find(&forks, &Repository{ForkID: repo.ID})\n\t}\n\n\tsess := db.GetPaginatedSession(&listOptions)\n\tforks := make([]*Repository, 0, listOptions.PageSize)\n\treturn forks, sess.Find(&forks, &Repository{ForkID: repo.ID})\n}\n\nfunc GetUserFork(repoID, userID int64) (*Repository, error) ", "output": "{\n\tvar forkedRepo Repository\n\thas, err := db.GetEngine(db.DefaultContext).Where(\"fork_id = ?\", repoID).And(\"owner_id = ?\", userID).Get(&forkedRepo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !has {\n\t\treturn nil, nil\n\t}\n\treturn &forkedRepo, nil\n}"}
{"input": "package stats\n\nimport (\n\t\"time\"\n\n\t\"sync\"\n\n\t\"github.com/paulbellamy/ratecounter\"\n)\n\nvar lock = sync.RWMutex{}\n\ntype stat struct {\n\treadReq  *ratecounter.RateCounter\n\twriteReq *ratecounter.RateCounter\n}\n\nfunc newStat() stat {\n\treturn stat{\n\t\treadReq:  ratecounter.NewRateCounter(time.Hour),\n\t\twriteReq: ratecounter.NewRateCounter(time.Hour),\n\t}\n}\n\ntype namespaceStatMap map[string]stat\n\nvar golbalNamespaceStat namespaceStatMap\n\nfunc init() {\n\tgolbalNamespaceStat = namespaceStatMap{}\n}\n\n\n\n\n\nfunc IncrRead(label string) {\n\tlock.Lock()\n\tdefer lock.Unlock()\n\tstat, ok := golbalNamespaceStat[label]\n\tif !ok {\n\t\tAddNamespace(label)\n\t\tstat = golbalNamespaceStat[label]\n\t}\n\n\tstat.readReq.Incr(1)\n}\n\n\nfunc IncrWrite(label string) {\n\tlock.Lock()\n\tdefer lock.Unlock()\n\tstat, ok := golbalNamespaceStat[label]\n\tif !ok {\n\t\tAddNamespace(label)\n\t\tstat = golbalNamespaceStat[label]\n\t}\n\n\tstat.writeReq.Incr(1)\n}\n\n\nfunc Rate(label string) (read, write int64) {\n\tlock.RLock()\n\tdefer lock.RUnlock()\n\tstat, ok := golbalNamespaceStat[label]\n\tif !ok {\n\t\tAddNamespace(label)\n\t\tstat = golbalNamespaceStat[label]\n\t}\n\n\treturn stat.readReq.Rate(), stat.writeReq.Rate()\n}\n\nfunc AddNamespace(label string) ", "output": "{\n\t_, ok := golbalNamespaceStat[label]\n\tif ok {\n\t\treturn\n\t}\n\n\tgolbalNamespaceStat[label] = newStat()\n\treturn\n}"}
{"input": "package hyperdrive\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/caarlos0/env\"\n)\n\nvar conf Config\n\nfunc init() {\n\tvar err error\n\tconf, err = NewConfig()\n\tif err != nil {\n\t\tlog.Fatalf(\"Config could not be initalized: %v\", err)\n\t}\n}\n\n\n\n\ntype Config struct {\n\tPort            int    `env:\"PORT\" envDefault:\"5000\"`\n\tEnv             string `env:\"HYPERDRIVE_ENV\" envDefault:\"development\"`\n\tGzipLevel       int    `env:\"GZIP_LEVEL\" envDefault:\"-1\"`\n\tCorsEnabled     bool   `env:\"CORS_ENABLED\" envDefault:\"true\"`\n\tCorsOrigins     string `env:\"CORS_ORIGINS\" envDefault:\"*\"`\n\tCorsHeaders     string `env:\"CORS_HEADERS\" envDefault:\"\"`\n\tCorsCredentials bool   `env:\"CORS_CREDENTIALS\" envDefault:\"true\"`\n}\n\n\n\nfunc (c *Config) GetPort() string {\n\treturn fmt.Sprintf(\":%d\", c.Port)\n}\n\n\n\n\nfunc NewConfig() (Config, error) ", "output": "{\n\tc := Config{}\n\terr := env.Parse(&c)\n\treturn c, err\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/trivago/tgo/thealthcheck\"\n\t\"strings\"\n\t\"time\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype SimpleRouter struct {\n\tid        string\n\tProducers []Producer\n\tfilters   FilterArray     `config:\"Filters\"`\n\ttimeout   time.Duration   `config:\"TimeoutMs\" default:\"0\" metric:\"ms\"`\n\tstreamID  MessageStreamID `config:\"Stream\"`\n\tLogger    logrus.FieldLogger\n}\n\n\n\n\n\nfunc (router *SimpleRouter) GetLogger() logrus.FieldLogger {\n\treturn router.Logger\n}\n\n\nfunc (router *SimpleRouter) AddHealthCheck(callback thealthcheck.CallbackFunc) {\n\trouter.AddHealthCheckAt(\"\", callback)\n}\n\n\nfunc (router *SimpleRouter) AddHealthCheckAt(path string, callback thealthcheck.CallbackFunc) {\n\tthealthcheck.AddEndpoint(\"/\"+router.GetID()+path, callback)\n}\n\n\nfunc (router *SimpleRouter) GetID() string {\n\treturn router.id\n}\n\n\nfunc (router *SimpleRouter) GetStreamID() MessageStreamID {\n\treturn router.streamID\n}\n\n\nfunc (router *SimpleRouter) GetTimeout() time.Duration {\n\treturn router.timeout\n}\n\n\n\nfunc (router *SimpleRouter) AddProducer(producers ...Producer) {\n\tfor _, prod := range producers {\n\t\tfor _, inListProd := range router.Producers {\n\t\t\tif inListProd == prod {\n\t\t\t\treturn \n\t\t\t}\n\t\t}\n\t\trouter.Producers = append(router.Producers, prod)\n\t}\n}\n\n\nfunc (router *SimpleRouter) GetProducers() []Producer {\n\treturn router.Producers\n}\n\n\nfunc (router *SimpleRouter) Modulate(msg *Message) ModulateResult {\n\tmod := NewFilterModulator(router.filters)\n\treturn mod.Modulate(msg)\n}\n\nfunc (router *SimpleRouter) Configure(conf PluginConfigReader) ", "output": "{\n\trouter.id = conf.GetID()\n\trouter.Logger = conf.GetLogger()\n\n\tif router.streamID == WildcardStreamID && strings.Index(router.id, GeneratedRouterPrefix) != 0 {\n\t\trouter.Logger.Info(\"A wildcard stream configuration only affects the wildcard stream, not all routers\")\n\t}\n}"}
{"input": "package query\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\t\"github.com/m3db/m3/src/m3ninx/generated/proto/querypb\"\n\t\"github.com/m3db/m3/src/m3ninx/search\"\n\t\"github.com/m3db/m3/src/m3ninx/search/searcher\"\n)\n\n\ntype FieldQuery struct {\n\tfield []byte\n}\n\n\nfunc NewFieldQuery(field []byte) search.Query {\n\treturn &FieldQuery{\n\t\tfield: field,\n\t}\n}\n\n\nfunc (q *FieldQuery) Field() []byte {\n\treturn q.field\n}\n\n\nfunc (q *FieldQuery) Searcher() (search.Searcher, error) {\n\treturn searcher.NewFieldSearcher(q.field)\n}\n\n\nfunc (q *FieldQuery) Equal(o search.Query) bool {\n\to, ok := singular(o)\n\tif !ok {\n\t\treturn false\n\t}\n\n\tinner, ok := o.(*FieldQuery)\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn bytes.Equal(q.field, inner.field)\n}\n\n\n\n\nfunc (q *FieldQuery) String() string {\n\treturn fmt.Sprintf(\"field(%s)\", q.field)\n}\n\nfunc (q *FieldQuery) ToProto() *querypb.Query ", "output": "{\n\tterm := querypb.FieldQuery{\n\t\tField: q.field,\n\t}\n\n\treturn &querypb.Query{\n\t\tQuery: &querypb.Query_Field{Field: &term},\n\t}\n}"}
{"input": "package main\nimport (\n\t\"net/http\"\n\tmv \"github.com/delicb/mezvaro\"\n\t\"log\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc LoggingMiddleware(c *mv.Context) {\n\tlog.Println(\"Simluate real logging here\")\n\tc.Next()\n}\n\nfunc AuthMiddleware(c *mv.Context) {\n\tlog.Println(\"Simulate user authentication.\")\n\trand.Seed(time.Now().Unix())\n\tif rand.Int() % 2 == 0 {\n\t\tc.Response.Write([]byte(\"User authenticated.\\n\"))\n\t\tc.Next()\n\t} else {\n\t\tc.Response.WriteHeader(http.StatusUnauthorized)\n\t\tc.Response.Write([]byte(\"Use not authenticated.\\n\"))\n\t\tc.Abort()\n\t}\n}\n\n\n\nfunc PrivatelyAvailable(c *mv.Context) {\n\tc.Response.Write([]byte(\"This page is only for authorized users.\"))\n}\n\nfunc main() {\n\tm := mv.New(mv.HandlerFunc(LoggingMiddleware)) \n\tauthOnly := m.Fork(mv.HandlerFunc(AuthMiddleware))\n\thttp.Handle(\"/public\", m.HF(PubliclyAvailable))\n\thttp.Handle(\"/auth\", authOnly.HF(PrivatelyAvailable))\n\thttp.ListenAndServe(\":8000\", nil)\n}\n\nfunc PubliclyAvailable(c *mv.Context) ", "output": "{\n\tc.Response.Write([]byte(\"This page is available for all users.\"))\n}"}
{"input": "package log\n\ntype logLevel struct {\n\tLevel     int\n\tPrefix    string\n\tColorFunc func(...interface{}) string\n}\n\ntype logLevels []*logLevel\n\nfunc (l *logLevels) getFunc(Level int) func(...interface{}) string {\n\tlevel := l.getLevel(Level)\n\tif level != nil {\n\t\treturn level.ColorFunc\n\t}\n\treturn nil\n}\n\n\n\nfunc (l *logLevels) getLevel(Level int) *logLevel ", "output": "{\n\tfor _, item := range *l {\n\t\tif item.Level == Level {\n\t\t\treturn item\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package analyzer\n\nimport (\n    . \"github.com/levythu/gurgling\"\n    \"time\"\n    \"fmt\"\n    \"strconv\"\n)\n\n\n\ntype SimpleAnalyzer struct {\n    \n}\n\nfunc ASimpleAnalyzer() Sandwich {\n    return &SimpleAnalyzer{}\n}\n\nconst token_returncode=\"SimpleAnalyzer-Status-Code\"\nconst token_starttime=\"SimpleAnalyzer-Start-Time\"\n\nfunc logCode(res Response, c int) {\n    res.F()[token_returncode]=c\n}\n\n\nfunc (this *SimpleAnalyzer)Final(req Request, res Response) {\n    var timeStart, ok=res.F()[token_starttime].(int64)\n    var timeElpase string\n    if ok {\n        var t=time.Now().UnixNano()\n        timeElpase=strconv.FormatInt((t-timeStart)/1000000, 10)+\"ms\"\n    } else {\n        timeElpase=\"xxxx\"\n    }\n\n    var statusCode, ok2=res.F()[token_returncode].(int)\n    var codeStr string\n    if ok2 {\n        codeStr=strconv.Itoa(statusCode)\n    } else {\n        codeStr=\"---\"\n    }\n\n    var url=req.R().URL\n    fmt.Print(\"- \"+timeElpase+\"\\t\\t\"+codeStr+\"\\t\"+req.Method()+\"\\t\"+url.Path)\n    if url.RawQuery!=\"\" {\n        fmt.Println(\"?\"+url.RawQuery)\n    } else {\n        fmt.Println(\"\")\n    }\n}\n\nfunc (this *SimpleAnalyzer)Handler(req Request, res Response) (bool, Request, Response) ", "output": "{\n    var newRes=&logResponse {\n        o: res,\n        OnHeadSent: logCode,\n    }\n    newRes.F()[token_starttime]=time.Now().UnixNano()\n    return true, req, newRes\n}"}
{"input": "package mqtt\n\n\n\n\n\n\ntype PingreqMessage struct {\n\tfixedHeader\n}\n\nvar _ Message = (*PingreqMessage)(nil)\n\n\n\n\nfunc NewPingreqMessage() *PingreqMessage ", "output": "{\n\tmsg := &PingreqMessage{}\n\tmsg.SetType(PINGREQ)\n\n\treturn msg\n}"}
{"input": "package connect\n\nimport (\n\t\"github.com/LilyPad/GoLilyPad/packet\"\n\t\"io\"\n)\n\ntype PacketRedirectEvent struct {\n\tServer string\n\tPlayer string\n}\n\nfunc NewPacketRedirectEvent(server string, player string) (this *PacketRedirectEvent) {\n\tthis = new(PacketRedirectEvent)\n\tthis.Server = server\n\tthis.Player = player\n\treturn\n}\n\n\n\ntype packetRedirectEventCodec struct {\n}\n\nfunc (this *packetRedirectEventCodec) Decode(reader io.Reader) (decode packet.Packet, err error) {\n\tpacketRedirectEvent := new(PacketRedirectEvent)\n\tpacketRedirectEvent.Server, err = packet.ReadString(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\tpacketRedirectEvent.Player, err = packet.ReadString(reader)\n\tif err != nil {\n\t\treturn\n\t}\n\tdecode = packetRedirectEvent\n\treturn\n}\n\nfunc (this *packetRedirectEventCodec) Encode(writer io.Writer, encode packet.Packet) (err error) {\n\tpacketRedirectEvent := encode.(*PacketRedirectEvent)\n\terr = packet.WriteString(writer, packetRedirectEvent.Server)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = packet.WriteString(writer, packetRedirectEvent.Player)\n\treturn\n}\n\nfunc (this *PacketRedirectEvent) Id() int ", "output": "{\n\treturn PACKET_REDIRECT_EVENT\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jackytck/projecteuler/tools\"\n)\n\nfunc match(p, s string) bool {\n\tm := make(map[rune]bool)\n\tfor _, r := range s {\n\t\tm[r] = true\n\t}\n\tvar e string\n\tfor _, r := range p {\n\t\tif m[r] {\n\t\t\te += string(r)\n\t\t}\n\t}\n\treturn e == s\n}\n\nfunc check(p string, log []string) bool {\n\tfor _, s := range log {\n\t\tif !match(p, s) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\n\nfunc main() {\n\tfmt.Println(solve(\"./p079_keylog.txt\"))\n}\n\nfunc solve(path string) string ", "output": "{\n\tlogs, err := tools.ReadFile(path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\texist := make(map[string]bool)\n\tvar unique []string\n\tfor _, v := range logs {\n\t\tif !exist[v] {\n\t\t\tunique = append(unique, v)\n\t\t\texist[v] = true\n\t\t}\n\t}\n\n\tfor p := range tools.Perms([]int{0, 1, 2, 3, 6, 7, 8, 9}) {\n\t\tpsw := tools.JoinIntsString(p...)\n\t\tif check(psw, unique) {\n\t\t\treturn psw\n\t\t}\n\t}\n\n\treturn \"\"\n}"}
{"input": "package node\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/docker/docker/api/client\"\n\t\"github.com/docker/docker/cli\"\n\t\"github.com/docker/engine-api/types/swarm\"\n\t\"github.com/spf13/cobra\"\n)\n\nfunc newPromoteCommand(dockerCli *client.DockerCli) *cobra.Command {\n\treturn &cobra.Command{\n\t\tUse:   \"promote NODE [NODE...]\",\n\t\tShort: \"Promote one or more nodes to manager in the swarm\",\n\t\tArgs:  cli.RequiresMinArgs(1),\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn runPromote(dockerCli, args)\n\t\t},\n\t}\n}\n\n\n\nfunc runPromote(dockerCli *client.DockerCli, nodes []string) error ", "output": "{\n\tpromote := func(node *swarm.Node) error {\n\t\tnode.Spec.Role = swarm.NodeRoleManager\n\t\treturn nil\n\t}\n\tsuccess := func(nodeID string) {\n\t\tfmt.Fprintf(dockerCli.Out(), \"Node %s promoted to a manager in the swarm.\\n\", nodeID)\n\t}\n\treturn updateNodes(dockerCli, nodes, promote, success)\n}"}
{"input": "package tcp\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n)\n\ntype EchoPacket struct {\n\tbuff []byte\n}\n\nfunc (this *EchoPacket) Serialize() []byte {\n\treturn this.buff\n}\n\n\n\nfunc (this *EchoPacket) GetBody() []byte {\n\treturn this.buff[4:]\n}\n\nfunc NewEchoPacket(buff []byte, hasLengthField bool) *EchoPacket {\n\tp := &EchoPacket{}\n\n\tif hasLengthField {\n\t\tp.buff = buff\n\n\t} else {\n\t\tp.buff = make([]byte, 4+len(buff))\n\t\tbinary.BigEndian.PutUint32(p.buff[0:4], uint32(len(buff)))\n\t\tcopy(p.buff[4:], buff)\n\t}\n\n\treturn p\n}\n\ntype EchoProtocol struct {\n}\n\nfunc (this *EchoProtocol) ReadPacket(conn *net.TCPConn) (Packet, error) {\n\tvar (\n\t\tlongBuf []byte = make([]byte, 4)\n\t\tlength  uint32\n\t)\n\n\tif _, err := io.ReadFull(conn, longBuf); err != nil {\n\t\treturn nil, err\n\t}\n\tif length = binary.BigEndian.Uint32(longBuf); length > 1024*4 {\n\t\treturn nil, errors.New(\"the size of packet is larger than the limit\")\n\t}\n\n\tbuff := make([]byte, 4+length)\n\tcopy(buff[0:4], longBuf)\n\n\tif _, err := io.ReadFull(conn, buff[4:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn NewEchoPacket(buff, true), nil\n}\n\nfunc (this *EchoPacket) GetLength() uint32 ", "output": "{\n\treturn binary.BigEndian.Uint32(this.buff[0:4])\n}"}
{"input": "package github\n\nimport (\n  . \"github.com/ErintLabs/trellohub/genapi\"\n  \"log\"\n)\n\ntype Label struct {\n  Name      string    `json:\"name\"`\n}\n\ntype GitUser  struct {\n  Name      string  `json:\"login\"`\n}\n\nfunc (issue *Issue) SetLabels(lbls []Label) {\n  lst := make([]string, len(lbls))\n  for i, v := range lbls {\n    lst[i] = v.Name\n  }\n  issue.Labels.SetNameable(lst)\n}\n\nfunc (issue *Issue) SetMembers(mbmrs []GitUser) {\n  lst := make([]string, len(mbmrs))\n  for i, v := range mbmrs {\n    lst[i] = v.Name\n  }\n  issue.Members.SetNameable(lst)\n}\n\n\n\n\n\n\n\nfunc (issue *Issue) DelLabel(label string) {\n  log.Printf(\"Removing label %s from %s\", label, issue.String())\n  GenDEL(issue.github, issue.ApiURL() + \"/labels/\" + label) \n}\n\n\ntype userAssignRequest struct {\n  Assigs  []string `json:\"assignees\"`\n}\n\nfunc (issue *Issue) AddUser(user string) {\n  log.Printf(\"Adding user %s to %s\", user, issue.String())\n  payload := userAssignRequest{ []string{ user } }\n  GenPOSTJSON(issue.github, issue.ApiURL() + \"/assignees\", nil, &payload)\n}\n\n\nfunc (issue *Issue) DelUser(user string) {\n  log.Printf(\"Removing user %s from %s\", user, issue.String())\n  payload := userAssignRequest{ []string{ user } }\n  GenDELJSON(issue.github, issue.ApiURL() + \"/assignees\", &payload)\n}\n\nfunc (issue *Issue) AddLabel(label string) ", "output": "{\n  log.Printf(\"Adding label %s to %s\", label, issue.String())\n  lbls := [...]string { label }\n  GenPOSTJSON(issue.github, issue.ApiURL() + \"/labels\", nil, &lbls)\n}"}
{"input": "package statecmd\n\nimport (\n\t\"launchpad.net/juju-core/charm\"\n\t\"launchpad.net/juju-core/constraints\"\n\t\"launchpad.net/juju-core/state\"\n\t\"launchpad.net/juju-core/state/api/params\"\n)\n\n\nfunc ServiceGet(st *state.State, p params.ServiceGet) (params.ServiceGetResults, error) {\n\tservice, err := st.Service(p.ServiceName)\n\tif err != nil {\n\t\treturn params.ServiceGetResults{}, err\n\t}\n\tsettings, err := service.ConfigSettings()\n\tif err != nil {\n\t\treturn params.ServiceGetResults{}, err\n\t}\n\tcharm, _, err := service.Charm()\n\tif err != nil {\n\t\treturn params.ServiceGetResults{}, err\n\t}\n\tconfigInfo := describe(settings, charm.Config())\n\tvar constraints constraints.Value\n\tif service.IsPrincipal() {\n\t\tconstraints, err = service.Constraints()\n\t\tif err != nil {\n\t\t\treturn params.ServiceGetResults{}, err\n\t\t}\n\t}\n\treturn params.ServiceGetResults{\n\t\tService:     p.ServiceName,\n\t\tCharm:       charm.Meta().Name,\n\t\tConfig:      configInfo,\n\t\tConstraints: constraints,\n\t}, nil\n}\n\n\n\nfunc describe(settings charm.Settings, config *charm.Config) map[string]interface{} ", "output": "{\n\tresults := make(map[string]interface{})\n\tfor name, option := range config.Options {\n\t\tinfo := map[string]interface{}{\n\t\t\t\"description\": option.Description,\n\t\t\t\"type\":        option.Type,\n\t\t}\n\t\tif value := settings[name]; value != nil {\n\t\t\tinfo[\"value\"] = value\n\t\t} else {\n\t\t\tinfo[\"value\"] = option.Default\n\t\t\tinfo[\"default\"] = true\n\t\t}\n\t\tresults[name] = info\n\t}\n\treturn results\n}"}
{"input": "package plugins\n\nimport (\n\t\"errors\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\n\n\n\nfunc TestPluginWaitBadPlugin(t *testing.T) {\n\tp := &Plugin{activateWait: sync.NewCond(&sync.Mutex{})}\n\tp.activateErr = errors.New(\"some junk happened\")\n\ttestActive(t, p)\n}\n\nfunc testActive(t *testing.T, p *Plugin) {\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tp.waitActive()\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-time.After(100 * time.Millisecond):\n\t\t_, f, l, _ := runtime.Caller(1)\n\t\tt.Fatalf(\"%s:%d: deadlock in waitActive\", filepath.Base(f), l)\n\tcase <-done:\n\t}\n\n}\n\nfunc TestPluginAddHandler(t *testing.T) ", "output": "{\n\tp := &Plugin{activateWait: sync.NewCond(&sync.Mutex{})}\n\tp.Manifest = &Manifest{Implements: []string{\"bananas\"}}\n\tstorage.plugins[\"qwerty\"] = p\n\n\ttestActive(t, p)\n\tHandle(\"bananas\", func(_ string, _ *Client) {})\n\ttestActive(t, p)\n}"}
{"input": "package leetcode\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n\n\n\n\n\n\n\nfunc MergeSortedArray(nums1 []int, m int, nums2 []int, n int) ", "output": "{\n\tnums1 = nums1[:m]\n\tnums2 = nums2[:n]\n\tnums1 = append(nums1, nums2...)\n\tsort.Ints(nums1)\n\tfmt.Println(nums1)\n}"}
{"input": "package main\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\tpmx \"github.com/gnewton/pubmedstruct\"\n\t\"log\"\n)\n\nconst P_KW = \"insert into keywords (id, owner, major_topic, name) values (?,?,?,?)\"\n\nfunc (kw *Keyword) Save(s *sql.Stmt) {\n\t_, err := s.Exec(kw.ID, kw.Owner, kw.MajorTopic, kw.Name)\n\tif err != nil {\n\t\tlog.Fatal(kw.ID, kw.Owner, kw.MajorTopic, kw.Name)\n\t\tlog.Fatal(err)\n\t}\n}\n\n\n\nfunc ExtractKeywords(owner string, keywords []*pmx.Keyword) []*Keyword {\n\tnewKeywords := make([]*Keyword, len(keywords))\n\n\tfor i, _ := range keywords {\n\t\tkeyword := keywords[i]\n\t\tnewKeywords[i] = findKeyword(owner, keyword)\n\t}\n\n\treturn newKeywords\n}\n\nfunc (kw Keyword) MakePreparedStatement(tx *sql.Tx) (*sql.Stmt, error) ", "output": "{\n\tif tx == nil {\n\t\tlog.Println(errors.New(\"Database is nil\"))\n\t}\n\treturn tx.Prepare(P_KW)\n}"}
{"input": "package client\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n)\n\n\n\n\n\nfunc Upload(data io.Reader, url string) error ", "output": "{\n\tclient := &http.Client{\n\t\tTimeout: 1 * time.Minute,\n\t}\n\n\treq, err := http.NewRequest(http.MethodPut, url, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"upload request failed\")\n\t}\n\n\tif _, err = io.Copy(ioutil.Discard, res.Body); err != nil {\n\t\treturn err\n\t}\n\tif err := res.Body.Close(); err != nil {\n\t\treturn err\n\t}\n\n\tif res.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"received unexpected status %v\", res.StatusCode)\n\t}\n\n\treturn nil\n}"}
{"input": "package pet\n\n\n\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n\tgolangswaggerpaths \"path\"\n)\n\n\ntype UpdatePetURL struct {\n\t_basePath string\n}\n\n\n\n\nfunc (o *UpdatePetURL) WithBasePath(bp string) *UpdatePetURL {\n\to.SetBasePath(bp)\n\treturn o\n}\n\n\n\n\nfunc (o *UpdatePetURL) SetBasePath(bp string) {\n\to._basePath = bp\n}\n\n\nfunc (o *UpdatePetURL) Build() (*url.URL, error) {\n\tvar _result url.URL\n\n\tvar _path = \"/pets\"\n\n\t_basePath := o._basePath\n\tif _basePath == \"\" {\n\t\t_basePath = \"/v2\"\n\t}\n\t_result.Path = golangswaggerpaths.Join(_basePath, _path)\n\n\treturn &_result, nil\n}\n\n\nfunc (o *UpdatePetURL) Must(u *url.URL, err error) *url.URL {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif u == nil {\n\t\tpanic(\"url can't be nil\")\n\t}\n\treturn u\n}\n\n\n\n\n\nfunc (o *UpdatePetURL) BuildFull(scheme, host string) (*url.URL, error) {\n\tif scheme == \"\" {\n\t\treturn nil, errors.New(\"scheme is required for a full url on UpdatePetURL\")\n\t}\n\tif host == \"\" {\n\t\treturn nil, errors.New(\"host is required for a full url on UpdatePetURL\")\n\t}\n\n\tbase, err := o.Build()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbase.Scheme = scheme\n\tbase.Host = host\n\treturn base, nil\n}\n\n\nfunc (o *UpdatePetURL) StringFull(scheme, host string) string {\n\treturn o.Must(o.BuildFull(scheme, host)).String()\n}\n\nfunc (o *UpdatePetURL) String() string ", "output": "{\n\treturn o.Must(o.Build()).String()\n}"}
{"input": "package dockerfile\n\nimport (\n\t\"strings\"\n\n\td \"github.com/docker/docker/builder/dockerfile\"\n\t\"github.com/moby/buildkit/frontend/dockerfile/instructions\"\n)\n\ntype BuildArgs struct {\n\td.BuildArgs\n}\n\nfunc NewBuildArgs(args []string) *BuildArgs {\n\targsFromOptions := make(map[string]*string)\n\tfor _, a := range args {\n\t\ts := strings.SplitN(a, \"=\", 2)\n\t\tif len(s) == 1 {\n\t\t\targsFromOptions[s[0]] = nil\n\t\t} else {\n\t\t\targsFromOptions[s[0]] = &s[1]\n\t\t}\n\t}\n\treturn &BuildArgs{\n\t\tBuildArgs: *d.NewBuildArgs(argsFromOptions),\n\t}\n}\n\n\n\n\nfunc (b *BuildArgs) ReplacementEnvs(envs []string) []string {\n\tresultEnv := make([]string, len(envs))\n\tcopy(resultEnv, envs)\n\tfiltered := b.FilterAllowed(envs)\n\treturn append(resultEnv, filtered...)\n}\n\n\nfunc (b *BuildArgs) AddMetaArgs(metaArgs []instructions.ArgCommand) {\n\tfor _, marg := range metaArgs {\n\t\tfor _, arg := range marg.Args {\n\t\t\tv := arg.Value\n\t\t\tb.AddMetaArg(arg.Key, v)\n\t\t}\n\t}\n}\n\nfunc (b *BuildArgs) Clone() *BuildArgs ", "output": "{\n\tclone := b.BuildArgs.Clone()\n\treturn &BuildArgs{\n\t\tBuildArgs: *clone,\n\t}\n}"}
{"input": "package validation\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/client-go/kubernetes/fake\"\n)\n\n\n\n\n\n\n\n\n\nfunc TestWaitForNodeToBeReady(t *testing.T) {\n\tconditions := []v1.NodeCondition{{Type: \"Ready\", Status: \"True\"}}\n\tnodeName := \"node-foo\"\n\tnodeAA := setupNodeAA(t, conditions, nodeName)\n\n\ttest, err := nodeAA.WaitForNodeToBeReady(nodeName)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\tif test != true {\n\t\tt.Fatalf(\"unexpected error WaitForNodeToBeReady Failed: %v\", test)\n\t}\n}\n\nfunc TestWaitForNodeToBeNotReady(t *testing.T) {\n\tconditions := []v1.NodeCondition{{Type: \"Ready\", Status: \"False\"}}\n\tnodeName := \"node-foo\"\n\tnodeAA := setupNodeAA(t, conditions, nodeName)\n\n\ttest, err := nodeAA.WaitForNodeToBeNotReady(nodeName)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\tif test != true {\n\t\tt.Fatalf(\"unexpected error WaitForNodeToBeNotReady Failed: %v\", test)\n\t}\n}\n\n\n\n\n\n\n\nfunc setupNodeAA(t *testing.T, conditions []v1.NodeCondition, nodeName string) *NodeAPIAdapter ", "output": "{\n\tnode := &v1.Node{\n\t\tObjectMeta: metav1.ObjectMeta{Name: nodeName},\n\t\tSpec:       v1.NodeSpec{Unschedulable: false},\n\t\tStatus:     v1.NodeStatus{Conditions: conditions},\n\t}\n\n\tc := fake.NewSimpleClientset(node)\n\tnodeAA, err := NewNodeAPIAdapter(c, time.Duration(10)*time.Millisecond)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error building NodeAPIAdapter: %v\", err)\n\t}\n\treturn nodeAA\n}"}
{"input": "package servicefabricmesh\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient {\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}\n\nfunc New(subscriptionID string) BaseClient ", "output": "{\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}"}
{"input": "package gosmparse\n\n\n\nfunc unpackTags(st []string, pos int, kv []int32) (int, map[string]string) ", "output": "{\n\tvar end int = pos\n\tfor end < len(kv) && kv[end] != 0 {\n\t\tend = end + 2\n\t}\n\n\ttags := make(map[string]string, (end-pos)/2)\n\tfor pos < len(kv) {\n\t\tif kv[pos] == 0 {\n\t\t\tpos++\n\t\t\tbreak\n\t\t}\n\t\ttags[st[kv[pos]]] = st[kv[pos+1]]\n\t\tpos = pos + 2\n\t}\n\treturn pos, tags\n}"}
{"input": "package ui\n\nimport (\n\t\"sync\"\n\n\t\"github.com/gdamore/tcell/views\"\n)\n\n\n\n\n\ntype Panel struct {\n\ttb   *TitleBar\n\tsb   *StatusBar\n\tkb   *KeyBar\n\tonce sync.Once\n\tapp  *App\n\n\tviews.Panel\n}\n\nfunc (p *Panel) SetTitle(title string) {\n\tp.tb.SetCenter(title)\n}\n\n\n\nfunc (p *Panel) SetStatus(status string) {\n\tp.sb.SetText(status)\n}\n\nfunc (p *Panel) SetGood() {\n\tp.sb.SetGood()\n}\n\nfunc (p *Panel) SetNormal() {\n\tp.sb.SetNormal()\n}\n\nfunc (p *Panel) SetWarn() {\n\tp.sb.SetWarn()\n}\n\nfunc (p *Panel) SetError() {\n\tp.sb.SetError()\n}\n\nfunc (p *Panel) Init(app *App) {\n\tp.once.Do(func() {\n\t\tp.app = app\n\n\t\tp.tb = NewTitleBar()\n\t\tp.tb.SetRight(app.GetAppName())\n\t\tp.tb.SetCenter(\" \")\n\n\t\tp.kb = NewKeyBar()\n\n\t\tp.sb = NewStatusBar()\n\n\t\tp.Panel.SetTitle(p.tb)\n\t\tp.Panel.SetMenu(p.sb)\n\t\tp.Panel.SetStatus(p.kb)\n\t})\n}\n\nfunc (p *Panel) App() *App {\n\treturn p.app\n}\n\nfunc NewPanel(app *App) *Panel {\n\tp := &Panel{}\n\tp.Init(app)\n\treturn p\n}\n\nfunc (p *Panel) SetKeys(words []string) ", "output": "{\n\tp.kb.SetKeys(words)\n}"}
{"input": "package provider\n\nimport (\n\t\"strings\"\n)\n\n\ntype DomainFilter struct {\n\tfilters []string\n\texclude []string\n}\n\n\nfunc prepareFilters(filters []string) []string {\n\tfs := make([]string, len(filters))\n\tfor i, domain := range filters {\n\t\tfs[i] = strings.ToLower(strings.TrimSuffix(strings.TrimSpace(domain), \".\"))\n\t}\n\treturn fs\n}\n\n\nfunc NewDomainFilterWithExclusions(domainFilters []string, excludeDomains []string) DomainFilter {\n\treturn DomainFilter{prepareFilters(domainFilters), prepareFilters(excludeDomains)}\n}\n\n\nfunc NewDomainFilter(domainFilters []string) DomainFilter {\n\treturn DomainFilter{prepareFilters(domainFilters), []string{}}\n}\n\n\n\n\n\n\n\nfunc matchFilter(filters []string, domain string, emptyval bool) bool {\n\tif len(filters) == 0 {\n\t\treturn emptyval\n\t}\n\n\tfor _, filter := range filters {\n\t\tstrippedDomain := strings.ToLower(strings.TrimSuffix(domain, \".\"))\n\n\t\tif filter == \"\" {\n\t\t\treturn emptyval\n\t\t} else if strings.HasPrefix(filter, \".\") && strings.HasSuffix(strippedDomain, filter) {\n\t\t\treturn true\n\t\t} else if strings.Count(strippedDomain, \".\") == strings.Count(filter, \".\") {\n\t\t\tif strippedDomain == filter {\n\t\t\t\treturn true\n\t\t\t}\n\t\t} else if strings.HasSuffix(strippedDomain, \".\"+filter) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc (df DomainFilter) IsConfigured() bool {\n\tif len(df.filters) == 1 {\n\t\treturn df.filters[0] != \"\"\n\t}\n\treturn len(df.filters) > 0\n}\n\nfunc (df DomainFilter) Match(domain string) bool ", "output": "{\n\treturn matchFilter(df.filters, domain, true) && !matchFilter(df.exclude, domain, false)\n}"}
{"input": "package assetmap\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"regexp\"\n)\n\ntype assets map[string]string\n\n\ntype AssetMap struct {\n\tpath           string\n\tstat           os.FileInfo\n\treloadOnChange bool\n\tassets         assets\n}\n\n\n\nfunc NewAssetMap(path string, reloadOnChange bool) *AssetMap {\n\tstat, _ := os.Stat(path)\n\tm := &AssetMap{\n\t\tpath:           path,\n\t\treloadOnChange: reloadOnChange,\n\t\tstat:           stat,\n\t}\n\tm.Load()\n\treturn m\n}\n\n\n\n\n\nfunc (m *AssetMap) Load() (err error) {\n\tbuf, err := ioutil.ReadFile(m.path)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"failed to read file(%v): %v\", err, m.path))\n\t}\n\terr = json.Unmarshal(buf, &m.assets)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"failed to decode json(%v): %v\", err, string(buf)))\n\t}\n\treturn\n}\n\n\nfunc (m *AssetMap) AssetPath(name string) (string, error) {\n\tif m.reloadOnChange {\n\t\tstat, err := os.Stat(m.path)\n\t\tif err == nil && (stat.Size() != m.stat.Size() || stat.ModTime() != m.stat.ModTime()) {\n\t\t\tm.stat = stat\n\t\t\tm.Load()\n\t\t}\n\t}\n\n\tif hash, ok := m.assets[name]; ok {\n\t\tre := regexp.MustCompile(\"^([^\\\\.]+)(.+)$\")\n\t\treturn re.ReplaceAllString(name, fmt.Sprintf(\"$1-%v$2\", hash)), nil\n\t}\n\n\treturn \"\", fmt.Errorf(\"unknown resource: %v\", name)\n}\n\nfunc (m *AssetMap) Path() string ", "output": "{\n\treturn m.path\n}"}
{"input": "package fingerprint\n\nimport log \"github.com/hashicorp/go-hclog\"\n\ntype BridgeFingerprint struct {\n\tStaticFingerprinter\n\n\tlogger log.Logger\n}\n\n\n\nfunc NewBridgeFingerprint(logger log.Logger) Fingerprint ", "output": "{\n\treturn &BridgeFingerprint{logger: logger}\n}"}
{"input": "package archive\n\nimport \"golang.org/x/sys/unix\"\n\n\n\n\n\n\nfunc lsetxattrCreate(link string, attr string, data []byte) error {\n\terr := unix.Lsetxattr(link, attr, data, 0)\n\tif err == unix.ENOTSUP || err == unix.EEXIST {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc mknod(path string, mode uint32, dev uint64) error ", "output": "{\n\treturn unix.Mknod(path, mode, dev)\n}"}
{"input": "package commands\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype basicHandler struct {\n\thandler func(args ...string) (string, error)\n\thelp    func(args ...string) string\n}\n\nvar _ CommandHandler = (*basicHandler)(nil)\n\n\n\nfunc (h *basicHandler) Help(argv ...string) string {\n\treturn h.help(argv...)\n}\n\nfunc Static(response, help string) CommandHandler {\n\treturn &basicHandler{\n\t\thandler: func(argv ...string) (string, error) {\n\t\t\treturn response, nil\n\t\t},\n\t\thelp: func(argv ...string) string {\n\t\t\treturn fmt.Sprintf(\"`!%s` - %s\", strings.Join(argv, \" \"), help)\n\t\t},\n\t}\n}\n\nfunc Simple(responder func(...string) (string, error), help string) CommandHandler {\n\treturn &basicHandler{\n\t\thandler: func(argv ...string) (string, error) {\n\t\t\treturn responder(argv...)\n\t\t},\n\t\thelp: func(argv ...string) string {\n\t\t\treturn fmt.Sprintf(\"`!%s` - %s\", strings.Join(argv, \" \"), help)\n\t\t},\n\t}\n}\n\nfunc (h *basicHandler) Handle(argv ...string) (string, error) ", "output": "{\n\treturn h.handler(argv...)\n}"}
{"input": "package conn\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"net/http\"\n\n\t\"github.com/garyburd/redigo/redis\"\n\t\"github.com/jmoiron/sqlx\"\n\t_ \"github.com/lib/pq\"\n\t\"google.golang.org/api/googleapi/transport\"\n\t\"google.golang.org/api/vision/v1\"\n\t\"googlemaps.github.io/maps\"\n)\n\nfunc DialPostgres(postgresURL string) (db *sqlx.DB) {\n\tvar err error\n\n\tdb, err = sqlx.Open(\"postgres\", postgresURL)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\terr = db.Ping()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn\n}\n\nfunc DialRedis(server string) *redis.Pool {\n\treturn &redis.Pool{\n\t\tMaxActive:   15,\n\t\tWait:        true,\n\t\tMaxIdle:     3,\n\t\tIdleTimeout: 240 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\tc, err := redis.DialURL(server)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif _, err := c.Do(\"PING\"); err != nil {\n\t\t\t\tc.Close()\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn c, nil\n\t\t},\n\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\tif time.Since(t) < time.Minute {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t_, err := c.Do(\"PING\")\n\t\t\treturn err\n\t\t},\n\t}\n}\n\n\n\nfunc DialGoogleServices(apiKey string) (*vision.Service, *maps.Client, error) ", "output": "{\n\tvar err error\n\n\tclient := &http.Client{\n\t\tTransport: &transport.APIKey{Key: apiKey},\n\t}\n\tvisionService, err := vision.New(client)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tmapsClient, err := maps.NewClient(maps.WithAPIKey(apiKey))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn visionService, mapsClient, nil\n}"}
{"input": "package automation\n\nimport (\n\tautomationpb \"vitess.io/vitess/go/vt/proto/automation\"\n)\n\n\n\n\nfunc MarkTaskSucceeded(t *automationpb.Task, output string) {\n\tt.State = automationpb.TaskState_DONE\n\tt.Output = output\n}\n\n\n\n\n\nfunc NewTask(taskName string, parameters map[string]string) *automationpb.Task {\n\treturn &automationpb.Task{\n\t\tState:      automationpb.TaskState_NOT_STARTED,\n\t\tName:       taskName,\n\t\tParameters: parameters,\n\t}\n}\n\nfunc MarkTaskFailed(t *automationpb.Task, output string, err error) ", "output": "{\n\tt.State = automationpb.TaskState_DONE\n\tt.Output = output\n\tt.Error = err.Error()\n}"}
{"input": "package collaboration\n\nimport \"sync\"\n\nfunc NewMemoryStorage() *memoryStorage {\n\treturn &memoryStorage{\n\t\tusers: make(map[string]*Option),\n\t}\n}\n\n\ntype memoryStorage struct {\n\tusers map[string]*Option\n\tsync.Mutex\n}\n\nfunc (m *memoryStorage) Get(username string) (*Option, error) {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\toption, ok := m.users[username]\n\tif !ok {\n\t\treturn nil, ErrUserNotFound\n\t}\n\n\treturn option, nil\n}\n\nfunc (m *memoryStorage) GetAll() (map[string]*Option, error) {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\treturn m.users, nil\n}\n\nfunc (m *memoryStorage) Set(username string, value *Option) error {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tm.users[username] = value\n\treturn nil\n}\n\nfunc (m *memoryStorage) Delete(username string) error {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tdelete(m.users, username)\n\treturn nil\n}\n\n\n\nfunc (m *memoryStorage) Close() error ", "output": "{\n\treturn nil\n}"}
{"input": "package fake\n\nimport (\n\tv1 \"github.com/openshift/origin/pkg/authorization/client/clientset_generated/release_v1_4/typed/core/v1\"\n\trestclient \"k8s.io/kubernetes/pkg/client/restclient\"\n\tcore \"k8s.io/kubernetes/pkg/client/testing/core\"\n)\n\ntype FakeCore struct {\n\t*core.Fake\n}\n\nfunc (c *FakeCore) Policies(namespace string) v1.PolicyInterface {\n\treturn &FakePolicies{c, namespace}\n}\n\n\n\n\n\nfunc (c *FakeCore) GetRESTClient() *restclient.RESTClient ", "output": "{\n\treturn nil\n}"}
{"input": "package main\n\n\ntype HelpBarView struct {\n\thelpRenderer HelpRenderer\n}\n\n\ntype ActionMessage struct {\n\taction  ActionType\n\tmessage string\n}\n\n\nfunc NewHelpBarView(helpRenderer HelpRenderer) *HelpBarView {\n\treturn &HelpBarView{\n\t\thelpRenderer: helpRenderer,\n\t}\n}\n\n\nfunc (helpBarView *HelpBarView) Initialise() (err error) {\n\treturn\n}\n\n\nfunc (helpBarView *HelpBarView) Dispose() {\n\n}\n\n\nfunc (helpBarView *HelpBarView) HandleEvent(event Event) (err error) {\n\treturn\n}\n\n\nfunc (helpBarView *HelpBarView) HandleAction(Action) (err error) {\n\treturn\n}\n\n\nfunc (helpBarView *HelpBarView) OnStateChange(viewState ViewState) {\n\n}\n\n\nfunc (helpBarView *HelpBarView) ViewID() ViewID {\n\treturn ViewHelpBar\n}\n\n\nfunc (helpBarView *HelpBarView) Render(win RenderWindow) (err error) {\n\tlineBuilder, err := win.LineBuilder(0, 1)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlineBuilder.Append(\" \")\n\n\treturn helpBarView.helpRenderer.RenderHelpBar(lineBuilder)\n}\n\n\n\n\n\nfunc RenderKeyBindingHelp(viewID ViewID, lineBuilder *LineBuilder, config Config, actionMessages []ActionMessage) {\n\tviewHierarchy := ViewHierarchy{viewID, ViewAll}\n\n\tfor _, actionMessage := range actionMessages {\n\t\tkeystrings := config.KeyStrings(actionMessage.action, viewHierarchy)\n\n\t\tif len(keystrings) > 0 {\n\t\t\tlineBuilder.\n\t\t\t\tAppendWithStyle(CmpHelpbarviewSpecial, \"%v \", keystrings[len(keystrings)-1].keystring).\n\t\t\t\tAppendWithStyle(CmpHelpbarviewNormal, \"%v   \", actionMessage.message)\n\t\t}\n\t}\n}\n\nfunc (helpBarView *HelpBarView) RenderHelpBar(lineBuilder *LineBuilder) (err error) ", "output": "{\n\treturn\n}"}
{"input": "package control\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\nvar (\n\tBuildSessionConfigs     = buildSessionConfigs\n\tComputeDiff             = computeDiff\n\tNewPathPolForEnteringAS = newPathPolForEnteringAS\n\tNewPrefixWatcher        = newPrefixWatcher\n\n\tCopyPathPolicy     = copyPathPolicy\n\tBuildRoutingChains = buildRoutingChains\n)\n\ntype ConjunctionPathPol = conjuctionPathPol\ntype Diff = diff\n\nfunc (w *GatewayWatcher) RunOnce(ctx context.Context) {\n\tw.run(ctx)\n}\n\nfunc (w *GatewayWatcher) RunAllPrefixWatchersOnceForTest(ctx context.Context) {\n\tvar wg sync.WaitGroup\n\tfor _, wi := range w.currentWatchers {\n\t\twi := wi\n\t\twi.prefixWatcher.resetRunMarker()\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\twi.prefixWatcher.Run(ctx)\n\t\t}()\n\t}\n\twg.Wait()\n}\n\n\n\nfunc (w *prefixWatcher) resetRunMarker() ", "output": "{\n\tw.runMarkerLock.Lock()\n\tdefer w.runMarkerLock.Unlock()\n\tw.runMarker = false\n}"}
{"input": "package script\n\nimport (\n\t\"gitlab.com/lycis/kami/privilege\"\n\t\"github.com/robertkrimen/otto\"\n)\n\ntype ExposedFunction interface {\n\tFunction() func(call otto.FunctionCall) otto.Value\n\tRequiredPrivilegeLevel() privilege.Level\n}\n\ntype EFunCreator func(ctx *ScriptContext) ExposedFunction\n\nvar eFuns map[string]EFunCreator\n\n\n\nfunc exposeStaticFunctions(ctx *ScriptContext) {\n\tfor name, f := range eFuns {\n\t\tefun := f(ctx)\n\n\n\t\tctx.Vm().Set(name, func(call otto.FunctionCall) otto.Value {\n\t\t\tif ctx.privilegeLevel >= efun.RequiredPrivilegeLevel() {\n\t\t\t\treturn efun.Function()(call)\n\t\t\t} else {\n\t\t\t\tpanic(ctx.Vm().MakeCustomError(\"privilege violation\", \"insufficient privileges\"))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc ExposeFunction(name string, f EFunCreator) ", "output": "{\n\tif eFuns == nil {\n\t\teFuns = make(map[string]EFunCreator)\n\t}\n\n\teFuns[name] = f\n}"}
{"input": "package ccerror\n\n\n\ntype OrganizationNameTakenError struct {\n\tMessage string\n}\n\n\n\nfunc (e OrganizationNameTakenError) Error() string ", "output": "{\n\treturn e.Message\n}"}
{"input": "package httpmux\n\nimport \"net/http\"\n\n\ntype ConfigOption interface {\n\tSet(c *Config)\n}\n\n\ntype ConfigOptionFunc func(c *Config)\n\n\nfunc (f ConfigOptionFunc) Set(c *Config) { f(c) }\n\n\nfunc WithPrefix(prefix string) ConfigOption {\n\treturn ConfigOptionFunc(func(c *Config) { c.Prefix = prefix })\n}\n\n\nfunc WithMiddleware(mw ...Middleware) ConfigOption {\n\treturn ConfigOptionFunc(func(c *Config) { c.Middleware = mw })\n}\n\n\nfunc WithMiddlewareFunc(mw ...MiddlewareFunc) ConfigOption {\n\treturn ConfigOptionFunc(func(c *Config) { c.UseFunc(mw...) })\n}\n\n\nfunc WithRedirectTrailingSlash(v bool) ConfigOption {\n\treturn ConfigOptionFunc(func(c *Config) { c.RedirectTrailingSlash = v })\n}\n\n\nfunc WithRedirectFixedPath(v bool) ConfigOption {\n\treturn ConfigOptionFunc(func(c *Config) { c.RedirectFixedPath = v })\n}\n\n\nfunc WithHandleMethodNotAllowed(v bool) ConfigOption {\n\treturn ConfigOptionFunc(func(c *Config) { c.HandleMethodNotAllowed = v })\n}\n\n\nfunc WithNotFound(f http.Handler) ConfigOption {\n\treturn ConfigOptionFunc(func(c *Config) { c.NotFound = f })\n}\n\n\nfunc WithMethodNotAllowed(f http.Handler) ConfigOption {\n\treturn ConfigOptionFunc(func(c *Config) { c.MethodNotAllowed = f })\n}\n\n\n\n\nfunc WithPanicHandler(f func(http.ResponseWriter, *http.Request, interface{})) ConfigOption ", "output": "{\n\treturn ConfigOptionFunc(func(c *Config) { c.PanicHandler = f })\n}"}
{"input": "package commitstats\n\nimport (\n\t\"fmt\"\n\n\t\"gopkg.in/src-d/go-git.v4\"\n\t\"gopkg.in/src-d/go-git.v4/plumbing/object\"\n)\n\n\ntype CommitStats struct {\n\tFiles int\n\tCode KindStats\n\tComment KindStats\n\tBlank KindStats\n\tOther KindStats\n\tTotal KindStats\n}\n\n\n\n\n\n\nfunc Calculate(r *git.Repository, from, to *object.Commit) (*CommitStats, error) {\n\tfs, err := CalculateByFile(r, from, to)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn commitStatsFromCommitFileStats(fs), nil\n}\n\nfunc commitStatsFromCommitFileStats(fs []CommitFileStats) *CommitStats {\n\tvar s CommitStats\n\tfor _, f := range fs {\n\t\ts.Blank.Add(f.Blank)\n\t\ts.Comment.Add(f.Comment)\n\t\ts.Code.Add(f.Code)\n\t\ts.Other.Add(f.Other)\n\t\ts.Total.Add(f.Total)\n\t\ts.Files++\n\t}\n\treturn &s\n}\n\nfunc (s *CommitStats) String() string ", "output": "{\n\treturn fmt.Sprintf(\"Code (+%d/-%d)\\nComment (+%d/-%d)\\nBlank (+%d/-%d)\\nOther (+%d/-%d)\\nTotal (+%d/-%d)\\nFiles (%d)\\n\",\n\t\ts.Code.Additions, s.Code.Deletions,\n\t\ts.Comment.Additions, s.Comment.Deletions,\n\t\ts.Blank.Additions, s.Blank.Deletions,\n\t\ts.Other.Additions, s.Other.Deletions,\n\t\ts.Total.Additions, s.Total.Deletions,\n\t\ts.Files,\n\t)\n}"}
{"input": "package main\n\nimport (\n\t\"image\"\n\t\"net/url\"\n\n\t\"github.com/ChimeraCoder/anaconda\"\n\tartsparts \"github.com/OpenGLAMTools/ArtsParts\"\n)\n\n\n\ntype tweetResponse struct {\n\ttwitterID       int64\n\ttwitterIDString string\n\tmediaID         int64\n\tmediaIDString   string\n}\n\nfunc postPartTweet(ap *artsparts.Part, img image.Image, twitterAPI *anaconda.TwitterApi) error {\n\tlog.Infoln(\"-----postPartTweet----\")\n\tresp, err := tweetImage(ap.Text, img, twitterAPI)\n\tap.TweetID = resp.twitterID\n\tap.TweetIDString = resp.twitterIDString\n\tap.MediaID = resp.mediaID\n\tap.MediaIDString = resp.mediaIDString\n\treturn err\n}\n\nfunc tweetImage(text string, img image.Image, twitterAPI *anaconda.TwitterApi) (tweetResponse, error) {\n\tvar resp tweetResponse\n\timgString, err := artsparts.ImageToBaseString(img)\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\tm, err := twitterAPI.UploadMedia(imgString)\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\tresp.mediaID = m.MediaID\n\tresp.mediaIDString = m.MediaIDString\n\tv := url.Values{\n\t\t\"media_ids\": []string{m.MediaIDString},\n\t}\n\ttweet, err := twitterAPI.PostTweet(text, v)\n\tlog.Infof(\"TweetImage: %#v\\n\", tweet)\n\tresp.twitterID = tweet.Id\n\tresp.twitterIDString = tweet.IdStr\n\treturn resp, err\n\n}\n\nfunc initTwitter(conf Conf) ", "output": "{\n\tanaconda.SetConsumerKey(conf.Env[\"TWITTER_KEY\"])\n\tanaconda.SetConsumerSecret(conf.Env[\"TWITTER_SECRET\"])\n}"}
{"input": "package log\n\nimport (\n\t\"github.com/sirupsen/logrus\"\n)\n\ntype LogLevel uint32\n\nconst (\n\tPanicLevel LogLevel = iota\n\tFatalLevel\n\tErrorLevel\n\tWarnLevel\n\tInfoLevel\n\tDebugLevel\n\tTraceLevel\n)\n\ntype Fields map[string]interface{}\n\ntype Logger interface {\n\tPanic(msg string, fields Fields)\n\tFatal(msg string, fields Fields)\n\tError(msg string, fields Fields)\n\tWarn(msg string, fields Fields)\n\tInfo(msg string, fields Fields)\n\tDebug(msg string, fields Fields)\n\tSetLevel(level LogLevel)\n\tGetLevel() LogLevel\n}\n\ntype DefaultLogger struct {\n\tlogger *logrus.Logger\n}\n\nfunc (l *DefaultLogger) Panic(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Panic(msg)\n}\n\nfunc (l *DefaultLogger) Fatal(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Fatal(msg)\n}\n\nfunc (l *DefaultLogger) Error(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Error(msg)\n}\n\n\n\nfunc (l *DefaultLogger) Info(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Info(msg)\n}\n\nfunc (l *DefaultLogger) Debug(msg string, fields Fields) {\n\tl.logger.WithFields(logrus.Fields(fields)).Debug(msg)\n}\n\nfunc (l *DefaultLogger) SetLevel(level LogLevel) {\n\tl.logger.SetLevel(logrus.Level(level))\n}\n\nfunc (l *DefaultLogger) GetLevel() LogLevel {\n\treturn LogLevel(l.logger.GetLevel())\n}\n\nfunc NewDefaultLogger() *DefaultLogger {\n\treturn &DefaultLogger{\n\t\tlogger: logrus.New(),\n\t}\n}\n\nfunc (l *DefaultLogger) Warn(msg string, fields Fields) ", "output": "{\n\tl.logger.WithFields(logrus.Fields(fields)).Warn(msg)\n}"}
{"input": "package watch\n\n\n\ntype FilterFunc func(in Event) (out Event, keep bool)\n\n\n\n\n\n\n\n\n\n\n\n\ntype filteredWatch struct {\n\tincoming Interface\n\tresult   chan Event\n\tf        FilterFunc\n}\n\n\nfunc (fw *filteredWatch) ResultChan() <-chan Event {\n\treturn fw.result\n}\n\n\nfunc (fw *filteredWatch) Stop() {\n\tfw.incoming.Stop()\n}\n\n\nfunc (fw *filteredWatch) loop() {\n\tdefer close(fw.result)\n\tfor {\n\t\tevent, ok := <-fw.incoming.ResultChan()\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tfiltered, keep := fw.f(event)\n\t\tif keep {\n\t\t\tfw.result <- filtered\n\t\t}\n\t}\n}\n\nfunc Filter(w Interface, f FilterFunc) Interface ", "output": "{\n\tfw := &filteredWatch{\n\t\tincoming: w,\n\t\tresult:   make(chan Event),\n\t\tf:        f,\n\t}\n\tgo fw.loop()\n\treturn fw\n}"}
{"input": "package http\n\nimport (\n\t\"context\"\n\n\t\"github.com/micro/go-micro/v2/broker\"\n\t\"github.com/micro/go-micro/v2/codec\"\n\t\"github.com/micro/go-micro/v2/registry\"\n\t\"github.com/micro/go-micro/v2/server\"\n)\n\n\n\nfunc newOptions(opt ...server.Option) server.Options ", "output": "{\n\topts := server.Options{\n\t\tCodecs:   make(map[string]codec.NewCodec),\n\t\tMetadata: map[string]string{},\n\t\tContext:  context.Background(),\n\t}\n\n\tfor _, o := range opt {\n\t\to(&opts)\n\t}\n\n\tif opts.Broker == nil {\n\t\topts.Broker = broker.DefaultBroker\n\t}\n\n\tif opts.Registry == nil {\n\t\topts.Registry = registry.DefaultRegistry\n\t}\n\n\tif len(opts.Address) == 0 {\n\t\topts.Address = server.DefaultAddress\n\t}\n\n\tif len(opts.Name) == 0 {\n\t\topts.Name = server.DefaultName\n\t}\n\n\tif len(opts.Id) == 0 {\n\t\topts.Id = server.DefaultId\n\t}\n\n\tif len(opts.Version) == 0 {\n\t\topts.Version = server.DefaultVersion\n\t}\n\n\treturn opts\n}"}
{"input": "package echo\n\ntype (\n\tGroup struct {\n\t\techo Echo\n\t}\n)\n\nfunc (g *Group) Use(m ...Middleware) {\n\tfor _, h := range m {\n\t\tg.echo.middleware = append(g.echo.middleware, wrapMiddleware(h))\n\t}\n}\n\nfunc (g *Group) Connect(path string, h Handler) {\n\tg.echo.Connect(path, h)\n}\n\nfunc (g *Group) Delete(path string, h Handler) {\n\tg.echo.Delete(path, h)\n}\n\nfunc (g *Group) Get(path string, h Handler) {\n\tg.echo.Get(path, h)\n}\n\nfunc (g *Group) Head(path string, h Handler) {\n\tg.echo.Head(path, h)\n}\n\nfunc (g *Group) Options(path string, h Handler) {\n\tg.echo.Options(path, h)\n}\n\nfunc (g *Group) Patch(path string, h Handler) {\n\tg.echo.Patch(path, h)\n}\n\nfunc (g *Group) Post(path string, h Handler) {\n\tg.echo.Post(path, h)\n}\n\nfunc (g *Group) Put(path string, h Handler) {\n\tg.echo.Put(path, h)\n}\n\nfunc (g *Group) Trace(path string, h Handler) {\n\tg.echo.Trace(path, h)\n}\n\nfunc (g *Group) WebSocket(path string, h HandlerFunc) {\n\tg.echo.WebSocket(path, h)\n}\n\n\n\nfunc (g *Group) ServeDir(path, root string) {\n\tg.echo.ServeDir(path, root)\n}\n\nfunc (g *Group) ServeFile(path, file string) {\n\tg.echo.ServeFile(path, file)\n}\n\nfunc (g *Group) Group(prefix string, m ...Middleware) *Group {\n\treturn g.echo.Group(prefix, m...)\n}\n\nfunc (g *Group) Static(path, root string) ", "output": "{\n\tg.echo.Static(path, root)\n}"}
{"input": "package ghalloc\n\nimport \"unsafe\"\n\ntype slab struct {\n\tslabClass *slabClass \n\tmemory    []byte     \n\tfull      bool       \n\tallocated uint64     \n\tchunkMap  uint64     \n}\n\nfunc newSlab(sc *slabClass) *slab {\n\ts := &slab{\n\t\tslabClass: sc,\n\t\tmemory:    make([]byte, sc.SlabSize),\n\t\tfull:      false,\n\t\tallocated: 0,\n\t}\n\n\treturn s\n}\n\n\nfunc (s *slab) allocChunk() unsafe.Pointer {\n\tif s.full {\n\t\treturn nil\n\t}\n\n\ti := s.getUnusedChunkIndex()\n\tptr := unsafe.Pointer(&s.memory[s.getUnusedChunkIndex()])\n\n\ts.chunkMap |= 1 << i\n\ts.allocated++\n\n\tif s.allocated >= s.slabClass.Capacity {\n\t\ts.full = true\n\t}\n\n\treturn ptr\n}\n\n\n\n\nfunc (s *slab) getUnusedChunkIndex() uint64 {\n\tvar i uint64\n\n\tfor i = 0; i < s.slabClass.Capacity; i++ {\n\t\tif s.chunkMap&(1<<i) == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn i\n}\n\nfunc (s *slab) freeChunk(ptr unsafe.Pointer) ", "output": "{\n\tuptr := uintptr(ptr)\n\tbegin := uintptr(unsafe.Pointer(&s.memory[0]))\n\n\tif uptr >= begin && uptr <= uintptr(unsafe.Pointer(&s.memory[0]))+uintptr(s.slabClass.SlabSize) {\n\t\ts.chunkMap &^= 1 << uint64(uptr-begin) % uint64(s.slabClass.SlabSize)\n\n\t\ts.allocated--\n\t\tif s.full {\n\t\t\ts.full = false\n\t\t}\n\t}\n}"}
{"input": "package amalgam8\n\nimport \"strings\"\n\n\ntype InstanceLinks struct {\n\tSelf      string `json:\"self,omitempty\"`\n\tHeartbeat string `json:\"heartbeat,omitempty\"`\n}\n\n\n\n\n\nfunc BuildLinks(baseURL, id string) *InstanceLinks ", "output": "{\n\treturn &InstanceLinks{\n\t\tSelf:      strings.Join([]string{baseURL, InstanceURL(id)}, \"\"),\n\t\tHeartbeat: strings.Join([]string{baseURL, InstanceHeartbeatURL(id)}, \"\"),\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net/http\"\n\t\"os\"\n\n\t\"golang.org/x/oauth2\"\n)\n\n\nvar Endpoint = oauth2.Endpoint{\n\tAuthURL:  \"https://accounts.spotify.com/authorize\",\n\tTokenURL: \"https://accounts.spotify.com/api/token\",\n}\n\n\ntype ClientCredentials struct {\n\tconfig  *oauth2.Config\n\tcontext context.Context\n}\n\n\nfunc CreateClientCredentials(redirectURL string, scopes []string) ClientCredentials {\n\tauthcfg := &oauth2.Config{\n\t\tClientID:     os.Getenv(\"SPOTIFY_ID\"),\n\t\tClientSecret: os.Getenv(\"SPOTIFY_SECRET\"),\n\t\tRedirectURL:  redirectURL,\n\t\tScopes:       scopes,\n\t\tEndpoint:     Endpoint,\n\t}\n\n\ttr := &http.Transport{\n\t\tTLSNextProto: map[string]func(authority string, c *tls.Conn) http.RoundTripper{},\n\t}\n\tctx := context.WithValue(context.Background(), oauth2.HTTPClient, &http.Client{Transport: tr})\n\n\treturn ClientCredentials{\n\t\tconfig:  authcfg,\n\t\tcontext: ctx,\n\t}\n}\n\n\n\n\nfunc (c ClientCredentials) Token(state string, r *http.Request) (*oauth2.Token, error) ", "output": "{\n\tvalues := r.URL.Query()\n\tqueriedState := values.Get(\"state\")\n\tif queriedState != state {\n\t\treturn nil, errors.New(\"auth: states are different - cannot authenticate\")\n\t}\n\tcode := values.Get(\"code\")\n\tif code == \"\" {\n\t\treturn nil, errors.New(\"auth: didn't get access code\")\n\t}\n\treturn c.config.Exchange(c.context, code)\n}"}
{"input": "package archive\n\nimport (\n\t\"io\"\n\n\t\"github.com/sacloud/libsacloud/v2/helper/validate\"\n\t\"github.com/sacloud/libsacloud/v2/sacloud/types\"\n)\n\ntype UploadRequest struct {\n\tZone string   `request:\"-\" validate:\"required\"`\n\tID   types.ID `request:\"-\" validate:\"required\"`\n\n\tPath   string `validate:\"omitempty,file\"`\n\tReader io.Reader\n}\n\n\n\nfunc (req *UploadRequest) Validate() error ", "output": "{\n\treturn validate.Struct(req)\n}"}
{"input": "package api\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/af83/edwig/core\"\n\t\"github.com/af83/edwig/logger\"\n\t\"github.com/af83/edwig/siri\"\n)\n\ntype SIRIStopDiscoveryRequestHandler struct {\n\txmlRequest *siri.XMLStopPointsDiscoveryRequest\n}\n\n\n\nfunc (handler *SIRIStopDiscoveryRequestHandler) ConnectorType() string {\n\treturn core.SIRI_STOP_POINTS_DISCOVERY_REQUEST_BROADCASTER\n}\n\nfunc (handler *SIRIStopDiscoveryRequestHandler) Respond(connector core.Connector, rw http.ResponseWriter) {\n\tlogger.Log.Debugf(\"StopDiscovery %s\\n\", handler.xmlRequest.MessageIdentifier())\n\n\ttmp := connector.(*core.SIRIStopPointsDiscoveryRequestBroadcaster)\n\tresponse, _ := tmp.StopAreas(handler.xmlRequest)\n\txmlResponse, err := response.BuildXML()\n\tif err != nil {\n\t\tsiriError(\"InternalServiceError\", fmt.Sprintf(\"Internal Error: %v\", err), rw)\n\t\treturn\n\t}\n\n\tsoapEnvelope := siri.NewSOAPEnvelopeBuffer()\n\tsoapEnvelope.WriteXML(xmlResponse)\n\n\t_, err = soapEnvelope.WriteTo(rw)\n\tif err != nil {\n\t\tsiriError(\"InternalServiceError\", fmt.Sprintf(\"Internal Error: %v\", err), rw)\n\t\treturn\n\t}\n}\n\nfunc (handler *SIRIStopDiscoveryRequestHandler) RequestorRef() string ", "output": "{\n\treturn handler.xmlRequest.RequestorRef()\n}"}
{"input": "package kuberuntime\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"path\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nconst letterBytes = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nfunc randStringBytes(n int) string {\n\tb := make([]byte, n)\n\tfor i := range b {\n\t\tb[i] = letterBytes[rand.Intn(len(letterBytes))]\n\t}\n\treturn string(b)\n}\n\nfunc TestLogSymLink(t *testing.T) {\n\tas := assert.New(t)\n\tcontainerLogsDir := \"/foo/bar\"\n\tpodFullName := randStringBytes(128)\n\tcontainerName := randStringBytes(70)\n\tdockerId := randStringBytes(80)\n\texpectedPath := path.Join(containerLogsDir, fmt.Sprintf(\"%s_%s-%s\", podFullName, containerName, dockerId)[:251]+\".log\")\n\tas.Equal(expectedPath, logSymlink(containerLogsDir, podFullName, containerName, dockerId))\n}\n\n\n\nfunc TestLegacyLogSymLink(t *testing.T) ", "output": "{\n\tas := assert.New(t)\n\tcontainerID := randStringBytes(80)\n\tcontainerName := randStringBytes(70)\n\tpodName := randStringBytes(128)\n\tpodNamespace := randStringBytes(10)\n\texpectedPath := path.Join(legacyContainerLogsDir, fmt.Sprintf(\"%s_%s_%s-%s\", podName, podNamespace, containerName, containerID)[:251]+\".log\")\n\tas.Equal(expectedPath, legacyLogSymlink(containerID, containerName, podName, podNamespace))\n}"}
{"input": "package nl\n\nimport (\n\t\"syscall\"\n\t\"unsafe\"\n)\n\ntype RtMsg struct {\n\tsyscall.RtMsg\n}\n\nfunc NewRtMsg() *RtMsg {\n\treturn &RtMsg{\n\t\tRtMsg: syscall.RtMsg{\n\t\t\tTable:    syscall.RT_TABLE_MAIN,\n\t\t\tScope:    syscall.RT_SCOPE_UNIVERSE,\n\t\t\tProtocol: syscall.RTPROT_BOOT,\n\t\t\tType:     syscall.RTN_UNICAST,\n\t\t},\n\t}\n}\n\nfunc NewRtDelMsg() *RtMsg {\n\treturn &RtMsg{\n\t\tRtMsg: syscall.RtMsg{\n\t\t\tTable: syscall.RT_TABLE_MAIN,\n\t\t\tScope: syscall.RT_SCOPE_NOWHERE,\n\t\t},\n\t}\n}\n\nfunc (msg *RtMsg) Len() int {\n\treturn syscall.SizeofRtMsg\n}\n\n\n\nfunc (msg *RtMsg) Serialize() []byte {\n\treturn (*(*[syscall.SizeofRtMsg]byte)(unsafe.Pointer(msg)))[:]\n}\n\ntype RtNexthop struct {\n\tsyscall.RtNexthop\n}\n\nfunc DeserializeRtNexthop(b []byte) *RtNexthop {\n\treturn (*RtNexthop)(unsafe.Pointer(&b[0:syscall.SizeofRtNexthop][0]))\n}\n\nfunc (msg *RtNexthop) Serialize() []byte {\n\treturn (*(*[syscall.SizeofRtNexthop]byte)(unsafe.Pointer(msg)))[:]\n}\n\nfunc DeserializeRtMsg(b []byte) *RtMsg ", "output": "{\n\treturn (*RtMsg)(unsafe.Pointer(&b[0:syscall.SizeofRtMsg][0]))\n}"}
{"input": "package database\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype CreateDbHomeRequest struct {\n\n\tCreateDbHomeWithDbSystemIdDetails CreateDbHomeBase `contributesTo:\"body\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\n\n\n\nfunc (request CreateDbHomeRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request CreateDbHomeRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request CreateDbHomeRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype CreateDbHomeResponse struct {\n\n\tRawResponse *http.Response\n\n\tDbHome `presentIn:\"body\"`\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response CreateDbHomeResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response CreateDbHomeResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request CreateDbHomeRequest) String() string ", "output": "{\n\treturn common.PointerString(request)\n}"}
{"input": "package pipedrive\n\nimport \"time\"\n\ntype Time struct {\n\ttime.Time\n}\n\n\n\nfunc (t *Time) UnmarshalJSON(buf []byte) error {\n\ttt, err := time.Parse(\"2006-01-02 15:04:05\", string(buf[1:len(buf)-1]))\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.Time = tt\n\treturn nil\n}\n\nfunc (t *Time) String() string {\n\tif t == nil {\n\t\treturn \"\"\n\t}\n\treturn t.Time.Local().Format(\"2006-01-02 15:04:05\")\n}\n\ntype Date struct {\n\ttime.Time\n}\n\nfunc NewDate(t time.Time) Date {\n\treturn Date{t}\n}\n\nfunc (t *Date) UnmarshalJSON(buf []byte) error {\n\ttt, err := time.Parse(\"2006-01-02\", string(buf[1:len(buf)-1]))\n\tif err != nil {\n\t\treturn err\n\t}\n\tt.Time = tt\n\treturn nil\n}\n\nfunc (t *Date) String() string {\n\tif t == nil {\n\t\treturn \"\"\n\t}\n\treturn t.Time.Local().Format(\"2006-01-02\")\n}\n\nfunc NewTime(t time.Time) Time ", "output": "{\n\treturn Time{t}\n}"}
{"input": "package test\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc CreateTempfile(b []byte, t *testing.T) *os.File {\n\tf, err := ioutil.TempFile(os.TempDir(), \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(b) > 0 {\n\t\t_, err = f.Write(b)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\treturn f\n}\n\nfunc DeleteTempfile(f *os.File, t *testing.T) {\n\tif err := os.Remove(f.Name()); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n\n\nfunc WaitForFileContents(path string, contents []byte, t *testing.T) ", "output": "{\n\treadCh := make(chan struct{})\n\n\tgo func(ch chan struct{}, path string, contents []byte) {\n\t\tfor {\n\t\t\tdata, err := ioutil.ReadFile(path)\n\t\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\t\tt.Fatal(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif bytes.Equal(data, contents) {\n\t\t\t\tclose(readCh)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\t}(readCh, path, contents)\n\n\tselect {\n\tcase <-readCh:\n\tcase <-time.After(2 * time.Second):\n\t\tt.Fatal(\"file contents not present after 2 seconds\")\n\t}\n}"}
{"input": "package models\n\n\n\n\nimport (\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\ntype SendPhotoLinkBody struct {\n\n\tCaption string `json:\"caption,omitempty\"`\n\n\tChatID interface{} `json:\"chat_id\"`\n\n\tDisableNotification bool `json:\"disable_notification,omitempty\"`\n\n\tPhoto *string `json:\"photo\"`\n\n\tReplyMarkup interface{} `json:\"reply_markup,omitempty\"`\n\n\tReplyToMessageID int64 `json:\"reply_to_message_id,omitempty\"`\n}\n\n\n\n\nfunc (m *SendPhotoLinkBody) validateChatID(formats strfmt.Registry) error {\n\n\treturn nil\n}\n\nfunc (m *SendPhotoLinkBody) validatePhoto(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"photo\", \"body\", m.Photo); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc (m *SendPhotoLinkBody) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\nfunc (m *SendPhotoLinkBody) UnmarshalBinary(b []byte) error {\n\tvar res SendPhotoLinkBody\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *SendPhotoLinkBody) Validate(formats strfmt.Registry) error ", "output": "{\n\tvar res []error\n\n\tif err := m.validateChatID(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif err := m.validatePhoto(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package wraps\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-on/wrap\"\n)\n\n\n\n\ntype BeforeFunc func(http.ResponseWriter, *http.Request)\n\nfunc (b BeforeFunc) ServeHTTPNext(next http.Handler, wr http.ResponseWriter, req *http.Request) {\n\tb(wr, req)\n\tnext.ServeHTTP(wr, req)\n}\n\n\n\n\n\nfunc Before(h http.Handler) wrap.Wrapper {\n\treturn BeforeFunc(h.ServeHTTP)\n}\n\nfunc (b BeforeFunc) Wrap(next http.Handler) http.Handler ", "output": "{\n\treturn wrap.NextHandler(b).Wrap(next)\n}"}
{"input": "package vm\n\nimport (\n\t\"math/big\"\n\n\t\"github.com/akroma-project/akroma/common\"\n\t\"github.com/akroma-project/akroma/common/math\"\n)\n\n\nfunc calcMemSize(off, l *big.Int) *big.Int {\n\tif l.Sign() == 0 {\n\t\treturn common.Big0\n\t}\n\n\treturn new(big.Int).Add(off, l)\n}\n\n\n\nfunc getData(data []byte, start uint64, size uint64) []byte {\n\tlength := uint64(len(data))\n\tif start > length {\n\t\tstart = length\n\t}\n\tend := start + size\n\tif end > length {\n\t\tend = length\n\t}\n\treturn common.RightPadBytes(data[start:end], int(size))\n}\n\n\n\nfunc getDataBig(data []byte, start *big.Int, size *big.Int) []byte {\n\tdlen := big.NewInt(int64(len(data)))\n\n\ts := math.BigMin(start, dlen)\n\te := math.BigMin(new(big.Int).Add(s, size), dlen)\n\treturn common.RightPadBytes(data[s.Uint64():e.Uint64()], int(size.Uint64()))\n}\n\n\n\nfunc bigUint64(v *big.Int) (uint64, bool) {\n\treturn v.Uint64(), v.BitLen() > 64\n}\n\n\n\n\nfunc allZero(b []byte) bool {\n\tfor _, byte := range b {\n\t\tif byte != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc toWordSize(size uint64) uint64 ", "output": "{\n\tif size > math.MaxUint64-31 {\n\t\treturn math.MaxUint64/32 + 1\n\t}\n\n\treturn (size + 31) / 32\n}"}
{"input": "package openal\n\nimport (\n\t\"encoding/binary\"\n\t\"github.com/autovelop/playthos/audio\"\n\t\"golang.org/x/mobile/exp/audio/al\"\n)\n\n\ntype OpenALClip struct {\n\t*audio.Clip\n\tdata []byte\n}\n\n\nfunc (o *OpenALClip) Data() []byte {\n\treturn o.data\n}\n\n\nfunc (o *OpenALClip) Decode() {\n\to.Clip.Set(\n\t\tbinary.LittleEndian.Uint32(o.data[4:8]),\n\t\to.data[22],\n\t\tuint32(o.data[24])|uint32(o.data[25])<<8|uint32(o.data[26])<<16|uint32(o.data[27])<<24,\n\t\tuint32(o.data[34]),\n\t)\n\to.data = o.data[44:]\n}\n\n\ntype OpenALSound struct {\n\t*audio.Sound\n\tclip   *OpenALClip\n\tbuffer *al.Buffer\n}\n\n\nfunc NewOpenALSound(s *audio.Sound) *OpenALSound {\n\topenALSound := &OpenALSound{Sound: s}\n\treturn openALSound\n}\n\n\n\n\n\nfunc (o *OpenALSound) Buffer() *al.Buffer {\n\treturn o.buffer\n}\n\n\ntype OpenALSource struct {\n\t*audio.Source\n\tsource *al.Source\n}\n\n\nfunc NewOpenALSource(s *audio.Source) *OpenALSource {\n\topenALSource := &OpenALSource{Source: s}\n\treturn openALSource\n}\n\n\nfunc (o *OpenALSource) OverridePlaySound(fn func(audio.Soundable)) {\n\to.PlaySound = fn\n\ts := o.BasePlaySound()\n\tif s != nil {\n\t\to.PlaySound(s.(*audio.Sound))\n\t}\n}\n\nfunc (o *OpenALSound) OverrideClip(fn func(audio.Clipable)) ", "output": "{\n\to.SetClip = fn\n\to.SetClip(o.BaseClip().(*audio.Clip))\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n)\n\ntype IFile interface {\n\tRead(buf []byte) (n int, err error)\n\tWrite(buf []byte) (n int, err error)\n\tClose() error\n}\n\ntype IReader interface {\n\tRead(buf []byte) (n int, err error)\n}\n\ntype IWriter interface {\n\tWrite(buf []byte) (n int, err error)\n}\n\ntype ICloser interface {\n\tClose() error\n}\n\ntype File struct {\n\tfilename string\n\tfid int64\n}\n\nfunc (f *File) Read(buf []byte) (n int, err error) {\n\tfmt.Println(\"File opened\")\n\treturn 0, nil\n}\n\nfunc (f *File) Write(buf []byte) (n int, err error) {\n\tfmt.Println(\"File writed\")\n\treturn 0, nil\n}\n\n\n\nfunc main() {\n\tbytes := []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tvar file1 IFile = new(File)\n\tfile1.Read(bytes)\n\tfile1.Write(bytes)\n\tfile1.Close()\n\n\tvar file2 IReader = new(File)\n\tfile2.Read(bytes)\n\n\tvar file3 IWriter = new(File)\n\tfile3.Write(bytes)\n\n\tvar file4 ICloser = new(File)\n\tfile4.Close()\n}\n\nfunc (f *File) Close() error ", "output": "{\n\tfmt.Println(\"File closed\")\n\treturn nil\n}"}
{"input": "package containerengine\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ListWorkRequestLogsRequest struct {\n\n\tCompartmentId *string `mandatory:\"true\" contributesTo:\"query\" name:\"compartmentId\"`\n\n\tWorkRequestId *string `mandatory:\"true\" contributesTo:\"path\" name:\"workRequestId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request ListWorkRequestLogsRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request ListWorkRequestLogsRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request ListWorkRequestLogsRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request ListWorkRequestLogsRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ListWorkRequestLogsResponse struct {\n\n\tRawResponse *http.Response\n\n\tItems []WorkRequestLogEntry `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response ListWorkRequestLogsResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\n\n\nfunc (response ListWorkRequestLogsResponse) HTTPResponse() *http.Response ", "output": "{\n\treturn response.RawResponse\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n)\n\nfunc TestParseMimeType(t *testing.T) {\n\tvar mimeType = parseMimeType(\"application/json\")\n\tassert.Equal(t, \"application\", mimeType.Type)\n\tassert.Equal(t, \"json\", mimeType.subType)\n\tassert.Equal(t, \"\", mimeType.scope)\n\tassert.True(t, mimeType.isTextContent())\n\tassert.False(t, mimeType.isBinaryContent())\n}\n\nfunc TestParseXMimeType(t *testing.T) {\n\tvar mimeType = parseMimeType(\"application/x-msdownload\")\n\tassert.Equal(t, \"application\", mimeType.Type)\n\tassert.Equal(t, \"msdownload\", mimeType.subType)\n\tassert.Equal(t, \"x\", mimeType.scope)\n\tassert.False(t, mimeType.isTextContent())\n\tassert.True(t, mimeType.isBinaryContent())\n}\n\n\n\nfunc TestWildcardMatch(t *testing.T) {\n\tassert.True(t, wildcardMatch(\"test\", \"test\"))\n\tassert.True(t, wildcardMatch(\"test\", \"tes*\"))\n\tassert.True(t, wildcardMatch(\"test\", \"tes?\"))\n\tassert.True(t, wildcardMatch(\"test\", \"t*\"))\n\tassert.True(t, wildcardMatch(\"test\", \"*t*\"))\n\tassert.False(t, wildcardMatch(\"test\", \"tt*\"))\n\tassert.False(t, wildcardMatch(\"test\", \"es\"))\n}\n\nfunc TestVndMimeType(t *testing.T) ", "output": "{\n\tvar mimeType = parseMimeType(\"application/vnd.ms-powerpoint.template.macroenabled.12\")\n\tassert.Equal(t, \"application\", mimeType.Type)\n\tassert.Equal(t, \"ms-powerpoint\", mimeType.subType)\n\tassert.Equal(t, \"vnd\", mimeType.scope)\n\tassert.False(t, mimeType.isTextContent())\n\tassert.True(t, mimeType.isBinaryContent())\n}"}
{"input": "package config\n\ntype Dependencies interface {\n\tConfigurator\n\tInstalls() []string\n\tmerge(other Dependencies)\n}\n\nfunc NewDependencies(deps ...string) Dependencies {\n\ts := make(map[string]bool, len(deps))\n\tfor _, dep := range deps {\n\t\ts[dep] = exists\n\t}\n\treturn dependencies{\n\t\tset: s,\n\t}\n}\n\nconst exists = true\n\ntype dependencies struct {\n\tset map[string]bool\n}\n\nfunc (d dependencies) Installs() []string {\n\tkeys := make([]string, len(d.set))\n\n\ti := 0\n\tfor k := range d.set {\n\t\tkeys[i] = k\n\t\ti++\n\t}\n\n\treturn keys\n}\n\nfunc (d dependencies) Configure(cfg Configurable) {\n\tcfg.Config().Dependencies.merge(d)\n}\n\n\n\nfunc (d dependencies) merge(other Dependencies) ", "output": "{\n\tfor _, dep := range other.Installs() {\n\t\td.set[dep] = exists\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/mreithub/goref\"\n)\n\n\n\nfunc delayedHTML(w http.ResponseWriter, r *http.Request) {\n\tref := goref.Ref(\"/delayed.html\")\n\tdefer ref.Deref()\n\n\ttime.Sleep(200 * time.Millisecond)\n\tmsg := fmt.Sprintf(\"The time is %s\", time.Now().String())\n\tw.Write([]byte(msg))\n}\n\nfunc gorefJSON(w http.ResponseWriter, r *http.Request) {\n\tref := goref.Ref(\"/goref.json\")\n\tdefer ref.Deref()\n\n\tdata, _ := json.MarshalIndent(goref.GetSnapshot().Data, \"\", \"  \")\n\n\tw.Header().Add(\"Content-type\", \"application/json\")\n\tw.Write(data)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", indexHTML)\n\thttp.HandleFunc(\"/delayed.html\", delayedHTML)\n\thttp.HandleFunc(\"/goref.json\", gorefJSON)\n\n\thttp.ListenAndServe(\"localhost:1234\", nil)\n}\n\nfunc indexHTML(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tref := goref.Ref(\"/\")\n\tdefer ref.Deref()\n\n\tw.Write([]byte(`<h1>Index</h1>\n  <a href=\"/delayed.html\">delayed.html</a><br />\n  <a href=\"/goref.json\">goref.json</a>`))\n}"}
{"input": "package mock\n\nimport \"bytes\"\n\n\ntype Job struct {\n\tPayload, Name, GearmanHandle, ID string\n\tGearmanErr                       error\n\tGearmanWarnings                  [][]byte\n\tDataBuffer                       bytes.Buffer\n\tNumerator, Denominator           int\n}\n\n\nfunc CreateMockJob(payload string) *Job {\n\treturn &Job{Payload: payload}\n}\n\n\nfunc (m Job) Data() []byte {\n\treturn []byte(m.Payload)\n}\n\n\nfunc (m Job) OutData() []byte {\n\treturn m.DataBuffer.Bytes()\n}\n\n\nfunc (m Job) Fn() string {\n\treturn m.Name\n}\n\n\nfunc (m Job) Err() error {\n\treturn m.GearmanErr\n}\n\n\nfunc (m Job) Handle() string {\n\treturn m.GearmanHandle\n}\n\n\n\n\n\nfunc (m *Job) Warnings() [][]byte {\n\treturn m.GearmanWarnings\n}\n\n\nfunc (m *Job) SendWarning(warning []byte) {\n\tm.GearmanWarnings = append(m.GearmanWarnings, warning)\n}\n\n\nfunc (m *Job) SendData(data []byte) {\n\tm.DataBuffer.Write(data)\n}\n\n\nfunc (m *Job) UpdateStatus(numerator, denominator int) {\n\tm.Numerator = numerator\n\tm.Denominator = denominator\n}\n\nfunc (m Job) UniqueId() string ", "output": "{\n\treturn m.ID\n}"}
{"input": "package common\n\nimport \"math/big\"\n\ntype _N_ [_S_]byte\n\nfunc BytesTo_N_(b []byte) _N_ {\n\tvar h _N_\n\th.SetBytes(b)\n\treturn h\n}\nfunc StringTo_N_(s string) _N_ { return BytesTo_N_([]byte(s)) }\nfunc BigTo_N_(b *big.Int) _N_  { return BytesTo_N_(b.Bytes()) }\nfunc HexTo_N_(s string) _N_    { return BytesTo_N_(FromHex(s)) }\n\n\n\n\nfunc (h _N_) Str() string   { return string(h[:]) }\nfunc (h _N_) Bytes() []byte { return h[:] }\nfunc (h _N_) Big() *big.Int { return Bytes2Big(h[:]) }\n\n\n\nfunc (h *_N_) SetBytes(b []byte) {\n\tif len(b) > len(h) {\n\t\tb = b[len(b)-_S_:]\n\t}\n\n\tfor i := len(b) - 1; i >= 0; i-- {\n\t\th[_S_-len(b)+i] = b[i]\n\t}\n}\n\n\nfunc (h *_N_) SetString(s string) { h.SetBytes([]byte(s)) }\n\n\nfunc (h *_N_) Set(other _N_) {\n\tfor i, v := range other {\n\t\th[i] = v\n\t}\n}\n\nfunc (h _N_) Hex() string   ", "output": "{ return \"0x\" + Bytes2Hex(h[:]) }"}
{"input": "package command\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\n\t\"github.com/spf13/cobra\"\n\t\"github.com/zaphod-concur/etcd/clientv3\"\n)\n\nvar (\n\tleaseStr  string\n\tputPrevKV bool\n)\n\n\nfunc NewPutCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"put [options] <key> <value> (<value> can also be given from stdin)\",\n\t\tShort: \"Puts the given key into the store\",\n\t\tLong: `\nPuts the given key into the store.\n\nWhen <value> begins with '-', <value> is interpreted as a flag.\nInsert '--' for workaround:\n\n$ put <key> -- <value>\n$ put -- <key> <value>\n\nIf <value> isn't given as command line argument, this command tries to read the value from standard input.\nFor example,\n$ cat file | put <key>\nwill store the content of the file to <key>.\n`,\n\t\tRun: putCommandFunc,\n\t}\n\tcmd.Flags().StringVar(&leaseStr, \"lease\", \"0\", \"lease ID (in hexadecimal) to attach to the key\")\n\tcmd.Flags().BoolVar(&putPrevKV, \"prev-kv\", false, \"return the previous key-value pair before modification\")\n\treturn cmd\n}\n\n\nfunc putCommandFunc(cmd *cobra.Command, args []string) {\n\tkey, value, opts := getPutOp(cmd, args)\n\n\tctx, cancel := commandCtx(cmd)\n\tresp, err := mustClientFromCmd(cmd).Put(ctx, key, value, opts...)\n\tcancel()\n\tif err != nil {\n\t\tExitWithError(ExitError, err)\n\t}\n\tdisplay.Put(*resp)\n}\n\n\n\nfunc getPutOp(cmd *cobra.Command, args []string) (string, string, []clientv3.OpOption) ", "output": "{\n\tif len(args) == 0 {\n\t\tExitWithError(ExitBadArgs, fmt.Errorf(\"put command needs 1 argument and input from stdin or 2 arguments.\"))\n\t}\n\n\tkey := args[0]\n\tvalue, err := argOrStdin(args, os.Stdin, 1)\n\tif err != nil {\n\t\tExitWithError(ExitBadArgs, fmt.Errorf(\"put command needs 1 argument and input from stdin or 2 arguments.\"))\n\t}\n\n\tid, err := strconv.ParseInt(leaseStr, 16, 64)\n\tif err != nil {\n\t\tExitWithError(ExitBadArgs, fmt.Errorf(\"bad lease ID (%v), expecting ID in Hex\", err))\n\t}\n\n\topts := []clientv3.OpOption{}\n\tif id != 0 {\n\t\topts = append(opts, clientv3.WithLease(clientv3.LeaseID(id)))\n\t}\n\tif putPrevKV {\n\t\topts = append(opts, clientv3.WithPrevKV())\n\t}\n\n\treturn key, value, opts\n}"}
{"input": "package main\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\n\n\nfunc internalServerError(w http.ResponseWriter, r *http.Request) {\n\thttp.Error(w, http.StatusText(http.StatusInternalServerError),\n\t\t\t\thttp.StatusInternalServerError)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", internalServerError)\n\thttp.ListenAndServe(\":8000\", nil)\n}\n\nfunc hello(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tio.WriteString(w, \"Fabio rocks!\")\n}"}
{"input": "package j_provisioner\n\n\n\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/go-openapi/runtime\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"koding/remoteapi/models\"\n)\n\n\ntype JProvisionerOneReader struct {\n\tformats strfmt.Registry\n}\n\n\n\n\n\nfunc NewJProvisionerOneOK() *JProvisionerOneOK {\n\treturn &JProvisionerOneOK{}\n}\n\n\ntype JProvisionerOneOK struct {\n\tPayload *models.DefaultResponse\n}\n\nfunc (o *JProvisionerOneOK) Error() string {\n\treturn fmt.Sprintf(\"[POST /remote.api/JProvisioner.one][%d] jProvisionerOneOK  %+v\", 200, o.Payload)\n}\n\nfunc (o *JProvisionerOneOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {\n\n\to.Payload = new(models.DefaultResponse)\n\n\tif err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc NewJProvisionerOneUnauthorized() *JProvisionerOneUnauthorized {\n\treturn &JProvisionerOneUnauthorized{}\n}\n\n\ntype JProvisionerOneUnauthorized struct {\n\tPayload *models.UnauthorizedRequest\n}\n\nfunc (o *JProvisionerOneUnauthorized) Error() string {\n\treturn fmt.Sprintf(\"[POST /remote.api/JProvisioner.one][%d] jProvisionerOneUnauthorized  %+v\", 401, o.Payload)\n}\n\nfunc (o *JProvisionerOneUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {\n\n\to.Payload = new(models.UnauthorizedRequest)\n\n\tif err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (o *JProvisionerOneReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) ", "output": "{\n\tswitch response.Code() {\n\n\tcase 200:\n\t\tresult := NewJProvisionerOneOK()\n\t\tif err := result.readResponse(response, consumer, o.formats); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn result, nil\n\n\tcase 401:\n\t\tresult := NewJProvisionerOneUnauthorized()\n\t\tif err := result.readResponse(response, consumer, o.formats); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, result\n\n\tdefault:\n\t\treturn nil, runtime.NewAPIError(\"unknown error\", response, response.Code())\n\t}\n}"}
{"input": "package metadata\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/cpg1111/kubongo/hostProvider\"\n)\n\n\ntype Instances []hostProvider.Instance\n\n\nfunc (inst Instances) ToMap() (instanceMap map[string]hostProvider.Instance) {\n\tfor i := range inst {\n\t\tcastInst := inst[i].(hostProvider.LocalInstance)\n\t\tinstanceMap[fmt.Sprintf(\"%v\", castInst.Name)] = inst[i]\n\t}\n\treturn\n}\n\nvar current *Instances\n\n\n\n\n\nfunc AddInstance(list *Instances, instance hostProvider.Instance) *Instances {\n\tnewList := append(*list, instance)\n\tlist = &newList\n\treturn list\n}\n\n\nfunc RemoveInstance(list Instances, instance hostProvider.Instance) Instances {\n\tnewList := make(Instances, len(list)-1)\n\tfor i := range list {\n\t\tcastInst := list[i].(hostProvider.LocalInstance)\n\t\tcastOther := instance.(hostProvider.LocalInstance)\n\t\tif castInst.Name != castOther.Name {\n\t\t\tnewList[i] = list[i]\n\t\t}\n\t}\n\treturn newList\n}\n\nfunc New(firstInstance *hostProvider.Instance) *Instances ", "output": "{\n\tif current != nil {\n\t\treturn current\n\t}\n\tif firstInstance != nil {\n\t\tcurrent = &Instances{*firstInstance}\n\t\treturn current\n\t}\n\tcurrent = &Instances{}\n\treturn current\n}"}
{"input": "package apiserver\n\nimport (\n\t\"net/http\"\n)\n\n\ntype MuxHelper struct {\n\tMux             Mux\n\tRegisteredPaths []string\n}\n\nfunc (m *MuxHelper) Handle(path string, handler http.Handler) {\n\tm.RegisteredPaths = append(m.RegisteredPaths, path)\n\tm.Mux.Handle(path, handler)\n}\n\n\n\nfunc (m *MuxHelper) HandleFunc(path string, handler func(http.ResponseWriter, *http.Request)) ", "output": "{\n\tm.RegisteredPaths = append(m.RegisteredPaths, path)\n\tm.Mux.HandleFunc(path, handler)\n}"}
{"input": "package adb\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n)\n\n\n\ntype Port interface {\n\tadbForwardString() string\n}\n\n\n\ntype TCPPort int\n\nfunc (p TCPPort) adbForwardString() string {\n\treturn fmt.Sprintf(\"tcp:%d\", p)\n}\n\n\n\n\n\n\n\nfunc LocalFreeTCPPort() (TCPPort, error) {\n\tdummy, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer dummy.Close()\n\treturn TCPPort(dummy.Addr().(*net.TCPAddr).Port), nil\n}\n\n\n\n\ntype NamedAbstractSocket string\n\nfunc (p NamedAbstractSocket) adbForwardString() string {\n\treturn fmt.Sprintf(\"localabstract:%s\", p)\n}\n\n\n\ntype Jdwp int\n\n\n\n\nfunc (b *binding) Forward(ctx context.Context, local, device Port) error {\n\treturn b.Command(\"forward\", local.adbForwardString(), device.adbForwardString()).Run(ctx)\n}\n\n\nfunc (b *binding) RemoveForward(ctx context.Context, local Port) error {\n\treturn b.Command(\"forward\", \"--remove\", local.adbForwardString()).Run(ctx)\n}\n\nfunc (p Jdwp) adbForwardString() string ", "output": "{\n\treturn fmt.Sprintf(\"jdwp:%d\", p)\n}"}
{"input": "package mgodrv\n\nimport (\n\t\"reflect\"\n\n\t\"github.com/gohxs/hqi\"\n\n\tmgo \"gopkg.in/mgo.v2-unstable\"\n)\n\ntype Driver struct {\n\tColl *mgo.Collection\n}\n\nfunc (d *Driver) Schema(obj interface{}) error {\n\treturn nil\n}\n\nfunc (d *Driver) Insert(objs ...interface{}) error {\n\tdObj := []interface{}{}\n\tfor _, obj := range objs {\n\t\tobjVal := reflect.Indirect(reflect.ValueOf(obj))\n\t\tif reflect.TypeOf(obj).Kind() == reflect.Slice {\n\t\t\tfor i := 0; i < objVal.Len(); i++ {\n\t\t\t\tdObj = append(dObj, objVal.Index(i).Interface())\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tdObj = append(dObj, objVal.Interface())\n\t}\n\treturn d.Coll.Insert(dObj...)\n}\n\n\n\nfunc (d *Driver) Count(qp *hqi.QueryParam) int {\n\treturn -1 \n}\n\nfunc (d *Driver) Delete(qp *hqi.QueryParam) error {\n\te := &executor{driver: d}\n\te.match(qp.Samples)\n\treturn e.delete()\n}\n\nfunc (d *Driver) Update(qp *hqi.QueryParam, obj hqi.M) error {\n\te := &executor{driver: d}\n\te.match(qp.Samples)\n\treturn e.update(obj)\n}\n\nfunc (d *Driver) Query(qp *hqi.QueryParam, res interface{}) error ", "output": "{\n\te := &executor{driver: d}\n\n\te.match(qp.Samples)\n\te.sort(qp.Sort)\n\te.limit(qp.Skip, qp.Max)\n\te.retrieve(res)\n\treturn nil\n}"}
{"input": "package jobfile\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/dshearer/jobber/common\"\n)\n\nconst (\n\tErrorHandlerStopName     = \"Stop\"\n\tErrorHandlerBackoffName  = \"Backoff\"\n\tErrorHandlerContinueName = \"Continue\"\n\n\tMaxBackoffWait = 8\n)\n\ntype ErrorHandler interface {\n\tHandle(job *Job)\n\tfmt.Stringer\n}\n\ntype ContinueErrorHandler struct{}\n\nfunc (self ContinueErrorHandler) Handle(job *Job) {\n\tjob.Status = JobGood\n}\n\nfunc (self ContinueErrorHandler) String() string {\n\treturn ErrorHandlerContinueName\n}\n\ntype StopErrorHandler struct{}\n\nfunc (self StopErrorHandler) Handle(job *Job) {\n\tjob.Status = JobFailed\n}\n\nfunc (self StopErrorHandler) String() string {\n\treturn ErrorHandlerStopName\n}\n\ntype BackoffErrorHandler struct{}\n\nfunc (self BackoffErrorHandler) Handle(job *Job) {\n\n\tif job.Status == JobGood {\n\t\tjob.Status = JobBackoff\n\t\tjob.backoffLevel = 1\n\t} else {\n\t\tjob.backoffLevel *= 2\n\t}\n\tif job.backoffLevel > MaxBackoffWait {\n\t\tjob.Status = JobFailed\n\t\tjob.backoffLevel = 0\n\t\tjob.skipsLeft = 0\n\t} else {\n\t\tjob.skipsLeft = job.backoffLevel\n\t}\n}\n\nfunc (self BackoffErrorHandler) String() string {\n\treturn ErrorHandlerBackoffName\n}\n\n\n\nfunc GetErrorHandler(name string) (ErrorHandler, error) ", "output": "{\n\tswitch name {\n\tcase ErrorHandlerStopName:\n\t\treturn StopErrorHandler{}, nil\n\tcase ErrorHandlerBackoffName:\n\t\treturn BackoffErrorHandler{}, nil\n\tcase ErrorHandlerContinueName:\n\t\treturn ContinueErrorHandler{}, nil\n\tdefault:\n\t\treturn nil, &common.Error{What: \"Invalid error handler: \" + name}\n\t}\n}"}
{"input": "package model\n\nimport (\n\t\"time\"\n\n\t\"gopkg.in/mgo.v2\"\n)\n\ntype Relation struct {\n\tUids     [2]string `bson:\"uids\"`\n\tApproved [2]bool   `bson:\"approved\"`\n\tSource   string    `bson:\"source\"`\n\tDate     time.Time `bson:\"date\"`\n}\n\nfunc (r Relation) Index() []mgo.Index {\n\treturn []mgo.Index{\n\t\t{Key: []string{\"uids\"}, Unique: true},\n\t}\n}\n\ntype RelationModel struct {\n\t*BaseModel\n}\n\n\n\nfunc (r *RelationModel) Add() {\n\n}\n\nfunc NewRelationModel(mdb *Mdb) *RelationModel ", "output": "{\n\treturn &RelationModel{NewBaseModel(mdb, User{})}\n}"}
{"input": "package models\n\n\n\n\nimport (\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n)\n\n\n\n\ntype IPListEntryMetadata struct {\n\n\tName string `json:\"name,omitempty\"`\n\n\tNamespace string `json:\"namespace,omitempty\"`\n\n\tSource string `json:\"source,omitempty\"`\n}\n\n\n\n\n\nfunc (m *IPListEntryMetadata) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\nfunc (m *IPListEntryMetadata) UnmarshalBinary(b []byte) error {\n\tvar res IPListEntryMetadata\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *IPListEntryMetadata) Validate(formats strfmt.Registry) error ", "output": "{\n\treturn nil\n}"}
{"input": "package eliteConfiguration\n\n\ntype mutableState struct {\n}\n\n\nfunc (state mutableState) New(requiredName string) Configuration {\n\n\treturn &mutableConfiguration{iName: requiredName}\n}\n\n\n\n\n\nfunc (state mutableState) Save(configuration Configuration, fileName string) error {\n\n\treturn save(configuration, fileName)\n}\n\nfunc (state mutableState) Load(fileName string) (Configuration, error) ", "output": "{\n\n\treturn load(fileName, state.New)\n}"}
{"input": "package openapi\n\nimport (\n\t\"net/http\"\n)\n\ntype APIResponse struct {\n\t*http.Response `json:\"-\"`\n\tMessage        string `json:\"message,omitempty\"`\n\tOperation string `json:\"operation,omitempty\"`\n\tRequestURL string `json:\"url,omitempty\"`\n\tMethod string `json:\"method,omitempty\"`\n\tPayload []byte `json:\"-\"`\n}\n\n\n\nfunc NewAPIResponseWithError(errorMessage string) *APIResponse {\n\n\tresponse := &APIResponse{Message: errorMessage}\n\treturn response\n}\n\nfunc NewAPIResponse(r *http.Response) *APIResponse ", "output": "{\n\n\tresponse := &APIResponse{Response: r}\n\treturn response\n}"}
{"input": "package structs\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nconst (\n\tDefaultUnpriviledgedUser = \"nobody\"\n\n\tCheckBufSize = 4 * 1024\n)\n\n\ntype WaitResult struct {\n\tExitCode int\n\tSignal   int\n\tErr      error\n}\n\n\n\nfunc (r *WaitResult) Successful() bool {\n\treturn r.ExitCode == 0 && r.Signal == 0 && r.Err == nil\n}\n\nfunc (r *WaitResult) String() string {\n\treturn fmt.Sprintf(\"Wait returned exit code %v, signal %v, and error %v\",\n\t\tr.ExitCode, r.Signal, r.Err)\n}\n\n\n\ntype RecoverableError struct {\n\tErr         error\n\tRecoverable bool\n}\n\n\n\nfunc NewRecoverableError(e error, recoverable bool) *RecoverableError {\n\treturn &RecoverableError{\n\t\tErr:         e,\n\t\tRecoverable: recoverable,\n\t}\n}\n\nfunc (r *RecoverableError) Error() string {\n\treturn r.Err.Error()\n}\n\n\ntype CheckResult struct {\n\n\tExitCode int\n\n\tOutput string\n\n\tTimestamp time.Time\n\n\tDuration time.Duration\n\n\tErr error\n}\n\nfunc NewWaitResult(code, signal int, err error) *WaitResult ", "output": "{\n\treturn &WaitResult{\n\t\tExitCode: code,\n\t\tSignal:   signal,\n\t\tErr:      err,\n\t}\n}"}
{"input": "package blocksutil\n\nimport \"gx/ipfs/Qmej7nf81hi2x2tvjRBF3mcp74sQyuDH4VMYDGd1YtXjb2/go-block-format\"\n\n\n\n\n\n\n\n\n\ntype BlockGenerator struct {\n\tseq int\n}\n\n\nfunc (bg *BlockGenerator) Next() *blocks.BasicBlock {\n\tbg.seq++\n\treturn blocks.NewBlock([]byte(string(bg.seq)))\n}\n\n\nfunc (bg *BlockGenerator) Blocks(n int) []blocks.Block {\n\tblocks := make([]blocks.Block, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\tb := bg.Next()\n\t\tblocks = append(blocks, b)\n\t}\n\treturn blocks\n}\n\nfunc NewBlockGenerator() BlockGenerator ", "output": "{\n\treturn BlockGenerator{}\n}"}
{"input": "package cmd\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/coreos/etcd/clientv3\"\n)\n\nvar (\n\tdialTotal int\n)\n\nfunc mustCreateConn() *clientv3.Client {\n\teps := strings.Split(endpoints, \",\")\n\tendpoint := eps[dialTotal%len(eps)]\n\tdialTotal++\n\tclient, err := clientv3.NewFromURL(endpoint)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"dial error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\treturn client\n}\n\n\n\nfunc mustRandBytes(n int) []byte {\n\trb := make([]byte, n)\n\t_, err := rand.Read(rb)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"failed to generate value: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\treturn rb\n}\n\nfunc mustCreateClients(totalClients, totalConns uint) []*clientv3.Client ", "output": "{\n\tconns := make([]*clientv3.Client, totalConns)\n\tfor i := range conns {\n\t\tconns[i] = mustCreateConn()\n\t}\n\n\tclients := make([]*clientv3.Client, totalClients)\n\tfor i := range clients {\n\t\tclients[i] = conns[i%int(totalConns)].Clone()\n\t}\n\treturn clients\n}"}
{"input": "package indicators\n\nimport (\n\t\"github.com/thetruetrade/gotrade\"\n)\n\n\ntype AvgPriceWithoutStorage struct {\n\t*baseIndicatorWithFloatBounds\n}\n\n\nfunc NewAvgPriceWithoutStorage(valueAvailableAction ValueAvailableActionFloat) (indicator *AvgPriceWithoutStorage, err error) {\n\n\tif valueAvailableAction == nil {\n\t\treturn nil, ErrValueAvailableActionIsNil\n\t}\n\n\tlookback := 0\n\tind := AvgPriceWithoutStorage{\n\t\tbaseIndicatorWithFloatBounds: newBaseIndicatorWithFloatBounds(lookback, valueAvailableAction),\n\t}\n\n\treturn &ind, nil\n}\n\n\ntype AvgPrice struct {\n\t*AvgPriceWithoutStorage\n\n\tData []float64\n}\n\n\nfunc NewAvgPrice() (indicator *AvgPrice, err error) {\n\tind := AvgPrice{}\n\tind.AvgPriceWithoutStorage, err = NewAvgPriceWithoutStorage(func(dataItem float64, streamBarIndex int) {\n\t\tind.Data = append(ind.Data, dataItem)\n\t})\n\n\treturn &ind, err\n}\n\n\n\n\n\nfunc NewAvgPriceForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *AvgPrice, err error) {\n\tind, err := NewAvgPrice()\n\tpriceStream.AddTickSubscription(ind)\n\treturn ind, err\n}\n\n\nfunc NewAvgPriceForStreamWithSrcLen(sourceLength uint, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *AvgPrice, err error) {\n\tind, err := NewAvgPriceWithSrcLen(sourceLength)\n\tpriceStream.AddTickSubscription(ind)\n\treturn ind, err\n}\n\n\nfunc (ind *AvgPriceWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) {\n\n\tresult := (tickData.O() + tickData.H() + tickData.L() + tickData.C()) / float64(4.0)\n\n\tind.UpdateIndicatorWithNewValue(result, streamBarIndex)\n}\n\nfunc NewAvgPriceWithSrcLen(sourceLength uint) (indicator *AvgPrice, err error) ", "output": "{\n\tind, err := NewAvgPrice()\n\tind.Data = make([]float64, 0, sourceLength)\n\n\treturn ind, err\n}"}
{"input": "package util\n\nimport \"fmt\"\n\n\n\n\n\n\nfunc ValidIndex(index, length int) error ", "output": "{\n\tif index <= 0 || index-1 >= length {\n\t\treturn fmt.Errorf(\"index(%d) is out of range\", index)\n\t}\n\treturn nil\n}"}
{"input": "package bytealg\n\nconst MaxBruteForce = 0\n\n\n\n\n\n\n\nfunc IndexString(s, substr string) int {\n\tn := len(substr)\n\tc0 := substr[0]\n\tc1 := substr[1]\n\ti := 0\n\tt := len(s) - n + 1\n\tfails := 0\n\tfor i < t {\n\t\tif s[i] != c0 {\n\t\t\to := IndexByteString(s[i:t], c0)\n\t\t\tif o < 0 {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t\ti += o\n\t\t}\n\t\tif s[i+1] == c1 && s[i:i+n] == substr {\n\t\t\treturn i\n\t\t}\n\t\ti++\n\t\tfails++\n\t\tif fails >= 4+i>>4 && i < t {\n\t\t\tj := IndexRabinKarp(s[i:], substr)\n\t\t\tif j < 0 {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t\treturn i + j\n\t\t}\n\t}\n\treturn -1\n}\n\n\n\n\n\nfunc Cutover(n int) int {\n\tpanic(\"unimplemented\")\n}\n\nfunc Index(a, b []byte) int ", "output": "{\n\tpanic(\"unimplemented\")\n}"}
{"input": "package arm\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest/azure\"\n\t\"github.com/mitchellh/packer/builder/azure/common\"\n)\n\ntype configRetriever struct {\n\tfindTenantID func(azure.Environment, string) (string, error)\n}\n\n\n\nfunc (cr configRetriever) FillParameters(c *Config) error {\n\tif c.TenantID == \"\" {\n\t\ttenantID, err := cr.findTenantID(*c.cloudEnvironment, c.SubscriptionID)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.TenantID = tenantID\n\t}\n\treturn nil\n}\n\nfunc newConfigRetriever() configRetriever ", "output": "{\n\treturn configRetriever{common.FindTenantID}\n}"}
{"input": "package main\n\nimport \"sort\"\n\n\n\nfunc main() {\n\tprintln(longestConsecutive([]int{100, 4, 200, 1, 3, 2})) \n\tprintln(longestConsecutive([]int{0}))                    \n\tprintln(longestConsecutive([]int{1, 2, 0, 1}))           \n}\n\nfunc longestConsecutive(nums []int) int ", "output": "{\n\tsort.Ints(nums)\n\ta := 0\n\tlargest := 0\n\tvar last int\n\n\tfor _, i := range nums {\n\t\tif a == 0 {\n\t\t\ta += 1\n\t\t\tlast = i\n\t\t\tcontinue\n\t\t}\n\n\t\tif i-last == 1 {\n\t\t\ta += 1\n\n\t\t} else if i-last == 0 {\n\n\t\t} else {\n\t\t\tif a >= largest {\n\t\t\t\tlargest = a\n\t\t\t}\n\t\t\ta = 1\n\t\t}\n\t\tlast = i\n\n\t}\n\n\tif a >= largest {\n\t\tlargest = a\n\t}\n\n\treturn largest\n}"}
{"input": "package locus\n\nimport (\n\t\"github.com/gocircuit/circuit/use/circuit\"\n)\n\nfunc init() {\n\tcircuit.RegisterValue(XLocus{})\n}\n\ntype XLocus struct {\n\tl *Locus\n}\n\nfunc (x XLocus) GetPeers() []*Peer {\n\treturn x.l.GetPeers()\n}\n\nfunc (x XLocus) Self() interface{} {\n\treturn x.l.Self()\n}\n\n\ntype YLocus struct {\n\tX circuit.PermX\n}\n\nfunc (y YLocus) GetPeers() map[string]*Peer {\n\tr := make(map[string]*Peer)\n\tfor _, p := range y.X.Call(\"GetPeers\")[0].([]*Peer) {\n\t\tr[p.Key()] = p\n\t}\n\treturn r\n}\n\n\n\nfunc (y YLocus) Self() *Peer ", "output": "{\n\treturn y.X.Call(\"Self\")[0].(*Peer)\n}"}
{"input": "package dos\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n\nfunc GetHome() string {\n\thome := os.Getenv(\"HOME\")\n\tif home == \"\" {\n\t\thome = os.Getenv(\"USERPROFILE\")\n\t}\n\treturn home\n}\n\n\nfunc ReplaceHomeToTilde(wd string) string {\n\thome := GetHome()\n\thomeLen := len(home)\n\tif len(wd) >= homeLen && strings.EqualFold(home, wd[0:homeLen]) {\n\t\twd = \"~\" + wd[homeLen:]\n\t}\n\treturn wd\n}\n\n\n\n\nfunc ReplaceHomeToTildeSlash(wd string) string ", "output": "{\n\treturn filepath.ToSlash(ReplaceHomeToTilde(wd))\n}"}
{"input": "package main\n\nimport(\n\t\"time\"\n\t\"fmt\"\n\t\"math/rand\"\n)\n\n\n\n\nfunc main(){\n\trandNo:= randGen(1,30)\n\tvar guess int\n\tvar lastGuess int\n\tvar counter int \n\tfmt.Print(\"Enter a number between 1 and 30: \")\n\n\tfor counter = 1; counter < 30; counter++{\n\t\tfmt.Scanf(\"%d\", &guess)\n\t\tfmt.Scanf(\"%d\")\n\t\tif guess == lastGuess {\n\t\t\tfmt.Print(\"You just guessed that! Try again: \")\n\t\t\tcounter--\n\t\t} else {\n\t\t\tif guess == randNo {\n\t\t\t\tfmt.Print(\"Correctamundo! And it only took you \", counter, \" guesses!\\n\")\n\t\t\t\tbreak\n\t\t\t} else if guess < randNo {\n\t\t\t\tfmt.Print(\"Wrong! Try a higher number: \")\n\t\t\t} else if guess > randNo {\n\t\t\t\tfmt.Print(\"Wrong! Try a lower number: \")\n\t\t\t}\n\t\t}\n\t\tlastGuess = guess\n\t}\n\tif counter == 29 {\n\t\tfmt.Print(\"\\nToo took to long! You lose!\")\n\t}\n}\n\nfunc randGen(min, max int) int", "output": "{\n\trand.Seed(time.Now().UTC().UnixNano())\n\treturn min + rand.Intn(max-min)\n}"}
{"input": "package modules\n\nimport (\n\t\"io\"\n\n\t\"github.com/kylelemons/go-gypsy/yaml\"\n)\n\ntype Node interface{}\ntype Scalar string\ntype Map map[string]Node\ntype List []Node\n\nfunc YamlNodeToNode(node yaml.Node) Node {\n\tscalar, ok := node.(yaml.Scalar)\n\tif ok {\n\t\treturn Scalar(scalar.String())\n\t}\n\tlist, ok := node.(yaml.List)\n\tif ok {\n\t\tresult := make(List, list.Len())\n\t\tfor i, n := range list {\n\t\t\tresult[i] = YamlNodeToNode(n)\n\t\t}\n\t\treturn result\n\t}\n\tmp, ok := node.(yaml.Map)\n\tif ok {\n\t\tresult := make(Map)\n\t\tfor k, v := range mp {\n\t\t\tresult[k] = YamlNodeToNode(v)\n\t\t}\n\t\treturn result\n\t}\n\treturn nil\n}\n\nfunc Parse(r io.Reader) (Node, error) {\n\tn, err := yaml.Parse(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn YamlNodeToNode(n), err\n}\n\nfunc Child(root Node, spec string) (Node, error) {\n\treturn nil, nil\n}\n\nfunc (s Scalar) String() string {\n\treturn string(s)\n}\n\nfunc (s Scalar) GetBool() bool {\n\tif s == \"true\" || s == \"yes\" || s == \"1\" {\n\t\treturn true\n\t} else if s == \"false\" || s == \"no\" || s == \"0\" {\n\t\treturn false\n\t}\n\tpanic(\"Invalid bool value:\" + s.String())\n}\n\n\n\nfunc (m Map) Key(key string) Node {\n\treturn m[key]\n}\n\nfunc (l List) Item(idx int) Node {\n\treturn l[idx]\n}\n\nfunc (l List) Len() int {\n\treturn len(l)\n}\n\nfunc (m Map) Keys() []string ", "output": "{\n\tkeys := make([]string, 0, len(m))\n\tfor key := range m {\n\t\tkeys = append(keys, key)\n\t}\n\treturn keys\n}"}
{"input": "package pflag\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\n\ntype boolValue bool\n\n\n\nfunc (b *boolValue) Set(s string) error {\n\tv, err := strconv.ParseBool(s)\n\t*b = boolValue(v)\n\treturn err\n}\n\nfunc (b *boolValue) String() string { return fmt.Sprintf(\"%v\", *b) }\n\n\n\nfunc (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string) {\n\tf.VarP(newBoolValue(value, p), name, \"\", usage)\n}\n\n\nfunc (f *FlagSet) BoolVarP(p *bool, name, shorthand string, value bool, usage string) {\n\tf.VarP(newBoolValue(value, p), name, shorthand, usage)\n}\n\n\n\nfunc BoolVar(p *bool, name string, value bool, usage string) {\n\tCommandLine.VarP(newBoolValue(value, p), name, \"\", usage)\n}\n\n\nfunc BoolVarP(p *bool, name, shorthand string, value bool, usage string) {\n\tCommandLine.VarP(newBoolValue(value, p), name, shorthand, usage)\n}\n\n\n\nfunc (f *FlagSet) Bool(name string, value bool, usage string) *bool {\n\tp := new(bool)\n\tf.BoolVarP(p, name, \"\", value, usage)\n\treturn p\n}\n\n\nfunc (f *FlagSet) BoolP(name, shorthand string, value bool, usage string) *bool {\n\tp := new(bool)\n\tf.BoolVarP(p, name, shorthand, value, usage)\n\treturn p\n}\n\n\n\nfunc Bool(name string, value bool, usage string) *bool {\n\treturn CommandLine.BoolP(name, \"\", value, usage)\n}\n\n\nfunc BoolP(name, shorthand string, value bool, usage string) *bool {\n\treturn CommandLine.BoolP(name, shorthand, value, usage)\n}\n\nfunc newBoolValue(val bool, p *bool) *boolValue ", "output": "{\n\t*p = val\n\treturn (*boolValue)(p)\n}"}
{"input": "package gorma\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/goadesign/goa/dslengine\"\n)\n\n\nfunc (a *StorageGroupDefinition) Validate() *dslengine.ValidationErrors {\n\tfmt.Println(\"Validating Group\")\n\tverr := new(dslengine.ValidationErrors)\n\tif a.Name == \"\" {\n\t\tverr.Add(a, \"storage group name not defined\")\n\t}\n\ta.IterateStores(func(store *RelationalStoreDefinition) error {\n\t\tverr.Merge(store.Validate())\n\t\treturn nil\n\t})\n\n\treturn verr.AsError()\n}\n\n\n\n\n\nfunc (a *RelationalModelDefinition) Validate() *dslengine.ValidationErrors {\n\tfmt.Println(\"Validating Model\")\n\tverr := new(dslengine.ValidationErrors)\n\tif a.ModelName == \"\" {\n\t\tverr.Add(a, \"model name not defined\")\n\t}\n\tif a.Parent == nil {\n\t\tverr.Add(a, \"missing relational store parent\")\n\t}\n\ta.IterateFields(func(field *RelationalFieldDefinition) error {\n\t\tverr.Merge(field.Validate())\n\t\treturn nil\n\t})\n\n\treturn verr.AsError()\n}\n\n\nfunc (field *RelationalFieldDefinition) Validate() *dslengine.ValidationErrors {\n\tfmt.Println(\"Validing Field\")\n\tverr := new(dslengine.ValidationErrors)\n\n\tif field.Parent == nil {\n\t\tverr.Add(field, \"missing relational model parent\")\n\t}\n\tif field.FieldName == \"\" {\n\t\tverr.Add(field, \"field name not defined\")\n\t}\n\treturn verr.AsError()\n}\n\nfunc (a *RelationalStoreDefinition) Validate() *dslengine.ValidationErrors ", "output": "{\n\tfmt.Println(\"Validating Store\")\n\tverr := new(dslengine.ValidationErrors)\n\tif a.Name == \"\" {\n\t\tverr.Add(a, \"store name not defined\")\n\t}\n\tif a.Parent == nil {\n\t\tverr.Add(a, \"missing storage group parent\")\n\t}\n\ta.IterateModels(func(model *RelationalModelDefinition) error {\n\t\tverr.Merge(model.Validate())\n\t\treturn nil\n\t})\n\n\treturn verr.AsError()\n}"}
{"input": "package service\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n)\n\n\ntype StandardErrorRespModel struct {\n\tErrorMessage string `json:\"error\"`\n}\n\n\n\n\n\nfunc RespondWith(w http.ResponseWriter, httpStatusCode int, respModel interface{}) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(httpStatusCode)\n\tif err := json.NewEncoder(w).Encode(&respModel); err != nil {\n\t\tlog.Println(\" [!] Exception: RespondWith: Error: \", err)\n\t}\n}\n\n\n\n\n\nfunc RespondWithSuccessOK(w http.ResponseWriter, respModel interface{}) {\n\tRespondWith(w, http.StatusOK, respModel)\n}\n\n\n\n\n\nfunc RespondWithBadRequestError(w http.ResponseWriter, errMsg string) {\n\tRespondWithError(w, http.StatusBadRequest, errMsg)\n}\n\n\nfunc RespondWithNotFoundError(w http.ResponseWriter, errMsg string) {\n\tRespondWithError(w, http.StatusNotFound, errMsg)\n}\n\n\n\n\n\nfunc RespondWithErrorJSON(w http.ResponseWriter, httpErrCode int, respModel interface{}) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(httpErrCode)\n\tif err := json.NewEncoder(w).Encode(&respModel); err != nil {\n\t\tlog.Println(\" [!] Exception: RespondWithErrorJSON: Error: \", err)\n\t}\n}\n\nfunc RespondWithError(w http.ResponseWriter, httpErrCode int, errMsg string) ", "output": "{\n\tresp := StandardErrorRespModel{\n\t\tErrorMessage: errMsg,\n\t}\n\tRespondWithErrorJSON(w, httpErrCode, resp)\n}"}
{"input": "package v3\n\nimport (\n\t\"github.com/apache/servicecomb-service-center/pkg/rest\"\n\t\"github.com/apache/servicecomb-service-center/server/rest/controller/v4\"\n)\n\ntype TagService struct {\n\tv4.TagService\n}\n\n\n\nfunc (this *TagService) URLPatterns() []rest.Route ", "output": "{\n\treturn []rest.Route{\n\t\t{rest.HTTP_METHOD_POST, \"/registry/v3/microservices/:serviceId/tags\", this.AddTags},\n\t\t{rest.HTTP_METHOD_PUT, \"/registry/v3/microservices/:serviceId/tags/:key\", this.UpdateTag},\n\t\t{rest.HTTP_METHOD_GET, \"/registry/v3/microservices/:serviceId/tags\", this.GetTags},\n\t\t{rest.HTTP_METHOD_DELETE, \"/registry/v3/microservices/:serviceId/tags/:key\", this.DeleteTags},\n\t}\n}"}
{"input": "package model\n\nimport \"time\"\n\ntype folder struct {\n\tstateTracker\n\tscan  folderscan\n\tmodel *Model\n\tstop  chan struct{}\n}\n\nfunc (f *folder) IndexUpdated() {\n}\n\nfunc (f *folder) DelayScan(next time.Duration) {\n\tf.scan.Delay(next)\n}\n\n\nfunc (f *folder) Stop() {\n\tclose(f.stop)\n}\n\nfunc (f *folder) Jobs() ([]string, []string) {\n\treturn nil, nil\n}\n\nfunc (f *folder) BringToFront(string) {}\n\nfunc (f *folder) scanSubdirsIfHealthy(subDirs []string) error {\n\tif err := f.model.CheckFolderHealth(f.folderID); err != nil {\n\t\tl.Infoln(\"Skipping folder\", f.folderID, \"scan due to folder error:\", err)\n\t\treturn err\n\t}\n\tl.Debugln(f, \"Scanning subdirectories\")\n\tif err := f.model.internalScanFolderSubdirs(f.folderID, subDirs); err != nil {\n\t\tf.setError(err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (f *folder) Scan(subdirs []string) error ", "output": "{\n\treturn f.scan.Scan(subdirs)\n}"}
{"input": "package app\n\nimport (\n\t\"github.com/revel/revel\"\n)\n\nvar (\n\tDB string\n)\n\nfunc AppInit() {\n\tRegisterDB()\n}\n\n\n\nfunc RegisterDB() ", "output": "{\n\tvar found bool\n\tif DB, found = revel.Config.String(\"bloggo.db\"); !found {\n\t\tDB = \"bloggo\"\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n\ntype MapVar struct {\n\tContext map[string]interface{}\n}\n\n\n\nfunc (v *MapVar) Set(value string) error {\n\tif v.Context == nil {\n\t\tv.Context = map[string]interface{}{}\n\t}\n\tparts := strings.SplitN(value, \"=\", 2)\n\tif len(parts) == 1 {\n\t\tv.Context[parts[0]] = \"\"\n\t} else {\n\t\tv.Context[parts[0]] = parts[1]\n\t}\n\treturn nil\n}\n\n\ntype JsonVar struct {\n\tContext map[string]interface{}\n}\n\nfunc (j *JsonVar) String() string {\n\treturn fmt.Sprintf(\"%+v\", j.Context)\n}\n\nfunc (v *JsonVar) Set(value string) error {\n\tif v.Context == nil {\n\t\tv.Context = map[string]interface{}{}\n\t}\n\tm := map[string]interface{}{}\n\terr := json.Unmarshal([]byte(value), &m)\n\tif err == nil {\n\t\tv.Context = Merge(v.Context, m, true)\n\t}\n\treturn err\n}\n\nfunc (v *MapVar) String() string ", "output": "{\n\tparts := make([]string, 0, len(v.Context))\n\tfor name, value := range v.Context {\n\t\tparts = append(parts, name+\"=\"+fmt.Sprint(value))\n\t}\n\treturn strings.Join(parts, \",\")\n}"}
{"input": "package main\n\nimport \"math\"\n\ntype Vec2 [2]float64\n\nfunc main() {\n\tvar a Vec2\n\ta.A().B().C().D()\n}\n\n\n\nfunc (v Vec2) B() Vec2 {\n\treturn Vec2{1.0 / v.D(), 0}\n}\n\nfunc (v Vec2) C() Vec2 {\n\treturn Vec2{v[0], v[0]}\n}\n\nfunc (v Vec2) D() float64 {\n\treturn math.Sqrt(v[0])\n}\n\nfunc (v Vec2) A() Vec2 ", "output": "{\n\treturn Vec2{v[0], v[0]}\n}"}
{"input": "package syscallx\n\nimport \"syscall\"\n\nimport \"unsafe\"\n\n\n\n\n\nfunc Msync(b []byte, flags int) (err error) ", "output": "{\n\tvar _p0 unsafe.Pointer\n\tif len(b) > 0 {\n\t\t_p0 = unsafe.Pointer(&b[0])\n\t} else {\n\t\t_p0 = unsafe.Pointer(&_zero)\n\t}\n\t_, _, e1 := syscall.Syscall(syscall.SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))\n\tif e1 != 0 {\n\t\terr = e1\n\t}\n\treturn\n}"}
{"input": "package datastorehandler\n\nimport (\n\t\"net/http\"\n)\n\n\n\nfunc baseHandler(w http.ResponseWriter, r *http.Request) {\n\n}\n\nfunc init() ", "output": "{\n\thttp.HandleFunc(\"/\", baseHandler)\n}"}
{"input": "package mon\n\nimport (\n\t\"strings\"\n\n\t\"github.com/rook/rook/pkg/daemon/ceph/client\"\n\t\"github.com/rook/rook/pkg/operator/k8sutil\"\n\tv1 \"k8s.io/api/core/v1\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n)\n\nfunc monInQuorum(monitor client.MonMapEntry, quorum []int) bool {\n\tfor _, rank := range quorum {\n\t\tif rank == monitor.Rank {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\n\n\n\nfunc addServicePort(service *v1.Service, name string, port int32) {\n\tif port == 0 {\n\t\treturn\n\t}\n\tservice.Spec.Ports = append(service.Spec.Ports, v1.ServicePort{\n\t\tName:       name,\n\t\tPort:       port,\n\t\tTargetPort: intstr.FromInt(int(port)),\n\t\tProtocol:   v1.ProtocolTCP,\n\t})\n}\n\n\nfunc addContainerPort(container v1.Container, name string, port int32) {\n\tif port == 0 {\n\t\treturn\n\t}\n\tcontainer.Ports = append(container.Ports, v1.ContainerPort{\n\t\tName:          name,\n\t\tContainerPort: port,\n\t\tProtocol:      v1.ProtocolTCP,\n\t})\n}\n\nfunc fullNameToIndex(name string) (int, error) ", "output": "{\n\tname = strings.TrimPrefix(name, AppName)\n\tname = strings.TrimPrefix(name, \"-\")\n\treturn k8sutil.NameToIndex(name)\n}"}
{"input": "package chunkserver\n\nimport (\n\t\"bufio\"\n\t\"net\"\n)\n\ntype Conn struct {\n\taddr string\n\tnet.Conn\n\tclosed bool\n\tbr     *bufio.Reader\n}\n\nfunc (c *Conn) Close() {\n\tc.Conn.Close()\n\tc.closed = true\n}\n\nfunc (c *Conn) IsClosed() bool {\n\treturn c.closed\n}\n\ntype PooledConn struct {\n\t*Conn\n\tpool *ConnectionPool\n}\n\nfunc (pc *PooledConn) Recycle() {\n\tif pc.IsClosed() {\n\t\tpc.pool.Put(nil)\n\t} else {\n\t\tpc.pool.Put(pc)\n\t}\n}\n\n\n\nfunc ConnectionCreator(addr string) CreateConnectionFunc {\n\treturn func(pool *ConnectionPool) (PoolConnection, error) {\n\t\tc, err := NewConnection(addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn &PooledConn{c, pool}, nil\n\t}\n}\n\nfunc NewConnection(addr string) (*Conn, error) ", "output": "{\n\tconn, err := net.Dial(\"tcp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Conn{\n\t\taddr: addr,\n\t\tConn: conn,\n\t\tbr:   bufio.NewReaderSize(conn, 1024*1024*1),\n\t}, nil\n}"}
{"input": "package event\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\n\ntype Modified struct {\n\ttarget   Target\n\tfinished bool\n}\n\n\nfunc NewModified(target Target) *Modified {\n\treturn &Modified{target: target}\n}\n\n\nfunc (e *Modified) Type() Type {\n\treturn ModifiedType\n}\n\n\nfunc (e *Modified) Target() Target {\n\treturn e.target\n}\n\n\n\n\n\nfunc (e *Modified) Finished() bool {\n\treturn e.finished\n}\n\n\nfunc (e *Modified) Finish() {\n\te.finished = true\n}\n\n\nfunc (e *Modified) String() string {\n\tvar buffer bytes.Buffer\n\tbuffer.WriteString(fmt.Sprintf(\"Modified[Target: %v\", e.target))\n\tif e.finished {\n\t\tbuffer.WriteString(\", Finished\")\n\t}\n\tbuffer.WriteString(\"]\")\n\treturn buffer.String()\n}\n\nfunc (e *Modified) Cascade() bool ", "output": "{\n\treturn false\n}"}
{"input": "package api_xhr\n\nimport (\n\t\"compress/gzip\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"github.com/deze333/vroom/reqres\"\n)\n\n\n\n\n\n\nfunc ParseReq(w http.ResponseWriter, r *http.Request) (req *reqres.Req, err error) {\n\n\tparams := map[string]interface{}{}\n\n\tswitch r.Header.Get(\"Content-Encoding\") {\n\tcase \"gzip\":\n\t\tparams, err = decodeAsGzipReq(r)\n\n\tdefault:\n\t\tparams, err = decodeAsUnencodedReq(r)\n\t}\n\n\treq = &reqres.Req{\n\t\tParams:        params,\n\t\tHttpReq:       r,\n\t\tHttpResWriter: w,\n\t}\n\treturn\n}\n\n\n\n\nfunc decodeAsGzipReq(r *http.Request) (params map[string]interface{}, err error) {\n\n\tvar reader *gzip.Reader\n\treader, err = gzip.NewReader(r.Body)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdecoder := json.NewDecoder(reader)\n\terr = decoder.Decode(&params)\n\n\tif err == io.EOF {\n\t\terr = nil\n\t}\n\n\treturn\n}\n\nfunc decodeAsUnencodedReq(r *http.Request) (params map[string]interface{}, err error) ", "output": "{\n\n\tdecoder := json.NewDecoder(r.Body)\n\terr = decoder.Decode(&params)\n\n\tif err == io.EOF {\n\t\terr = nil\n\t}\n\n\treturn\n}"}
{"input": "package blockwatch\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n)\n\ntype filterLogsResponse struct {\n\tLogs []types.Log\n\tErr  error\n}\n\n\n\ntype fakeLogClient struct {\n\tcount           int64\n\trangeToResponse map[string]filterLogsResponse\n}\n\n\n\n\n\nfunc (fc *fakeLogClient) HeaderByNumber(number *big.Int) (*MiniHeader, error) {\n\treturn nil, errors.New(\"NOT_IMPLEMENTED\")\n}\n\n\nfunc (fc *fakeLogClient) HeaderByHash(hash common.Hash) (*MiniHeader, error) {\n\treturn nil, errors.New(\"NOT_IMPLEMENTED\")\n}\n\n\nfunc (fc *fakeLogClient) FilterLogs(q ethereum.FilterQuery) ([]types.Log, error) {\n\ttime.Sleep(5 * time.Millisecond)\n\tr := toRange(q.FromBlock, q.ToBlock)\n\tres, ok := fc.rangeToResponse[r]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"Didn't find response for range %s but  was expecting it to exist\", r)\n\t}\n\tatomic.AddInt64(&fc.count, 1)\n\treturn res.Logs, res.Err\n}\n\n\nfunc (fc *fakeLogClient) Count() int {\n\treturn int(fc.count)\n}\n\nfunc toRange(from, to *big.Int) string {\n\tr := fmt.Sprintf(\"%s-%s\", from, to)\n\treturn r\n}\n\nfunc newFakeLogClient(rangeToResponse map[string]filterLogsResponse) (*fakeLogClient, error) ", "output": "{\n\treturn &fakeLogClient{count: 0, rangeToResponse: rangeToResponse}, nil\n}"}
{"input": "package v3\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"time\"\n)\n\nconst DASHBOARD_VERSION int = 3\n\ntype Dashboard struct {\n\tName        string     `json:\"name\"`\n\tId          string     `json:\"_id\"`\n\tTags        []string   `json:\"tags\"`\n\tLayout      [][][]*Pod `json:\"layout\"`\n\tVersion     int        `json:\"version\"`\n\tLastUpdated int64      `json:\"_lastUpdated\"`\n}\n\n\n\nfunc NewDashboardFromFile(dpath string) (*Dashboard, error) {\n\tvar d Dashboard\n\tb, err := ioutil.ReadFile(dpath)\n\tif err != nil {\n\t\treturn &d, err\n\t}\n\terr = json.Unmarshal(b, &d)\n\tif err != nil {\n\t\treturn &d, err\n\t}\n\treturn &d, nil\n}\n\nfunc NewDashboard(skeleton bool) *Dashboard ", "output": "{\n\tif skeleton {\n\t\treturn &Dashboard{\n\t\t\tName:        \"\",\n\t\t\tId:          \"\",\n\t\t\tTags:        make([]string, 0),\n\t\t\tLayout:      [][][]*Pod{{{}}},\n\t\t\tVersion:     DASHBOARD_VERSION,\n\t\t\tLastUpdated: time.Now().UnixNano(),\n\t\t}\n\t} else {\n\t\treturn &Dashboard{\n\t\t\tName:        \"\",\n\t\t\tId:          \"\",\n\t\t\tTags:        make([]string, 0),\n\t\t\tLayout:      [][][]*Pod{{{NewPod(false)}}},\n\t\t\tVersion:     DASHBOARD_VERSION,\n\t\t\tLastUpdated: time.Now().UnixNano(),\n\t\t}\n\t}\n}"}
{"input": "package authenticator\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/qingyuancloud/QingYuan/pkg/auth/user\"\n)\n\n\n\n\ntype Token interface {\n\tAuthenticateToken(token string) (user.Info, bool, error)\n}\n\n\n\n\ntype Request interface {\n\tAuthenticateRequest(req *http.Request) (user.Info, bool, error)\n}\n\n\n\n\ntype Password interface {\n\tAuthenticatePassword(user, password string) (user.Info, bool, error)\n}\n\n\ntype TokenFunc func(token string) (user.Info, bool, error)\n\n\n\n\n\ntype RequestFunc func(req *http.Request) (user.Info, bool, error)\n\n\nfunc (f RequestFunc) AuthenticateRequest(req *http.Request) (user.Info, bool, error) {\n\treturn f(req)\n}\n\n\ntype PasswordFunc func(user, password string) (user.Info, bool, error)\n\n\nfunc (f PasswordFunc) AuthenticatePassword(user, password string) (user.Info, bool, error) {\n\treturn f(user, password)\n}\n\nfunc (f TokenFunc) AuthenticateToken(token string) (user.Info, bool, error) ", "output": "{\n\treturn f(token)\n}"}
{"input": "package reversereader\n\nimport (\n\t\"io\"\n\t\"os\"\n\n\t\"github.com/pkg/errors\"\n)\n\n\ntype ReverseReader struct {\n\treader   *os.File\n\toffset   int64\n\treadSize int64\n}\n\n\n\n\n\n\n\n\nfunc (r *ReverseReader) Read() (string, error) {\n\tif r.offset < 0 {\n\t\treturn \"\", errors.Wrap(io.EOF, \"at beginning of file\")\n\t}\n\tb := make([]byte, r.readSize)\n\tn, err := r.reader.ReadAt(b, r.offset)\n\tif err != nil && errors.Cause(err) != io.EOF {\n\t\treturn \"\", err\n\t}\n\tif int64(n) < r.readSize {\n\t\tb = b[0:n]\n\t}\n\tr.offset = -r.readSize\n\treturn string(b), nil\n}\n\nfunc NewReverseReader(reader *os.File) (*ReverseReader, error) ", "output": "{\n\tpageSize := int64(os.Getpagesize())\n\tstat, err := reader.Stat()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tremainder := stat.Size() % pageSize\n\tend, err := reader.Seek(0, 2)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstartOffset := end - remainder\n\tif startOffset < 0 {\n\t\tstartOffset = 0\n\t}\n\trr := ReverseReader{\n\t\treader:   reader,\n\t\toffset:   startOffset,\n\t\treadSize: pageSize,\n\t}\n\treturn &rr, nil\n}"}
{"input": "package values\n\nimport \"fmt\"\nimport \"strconv\"\n\n\ntype Int int\n\n\nfunc NewInt(val int, p *int) *Int {\n\t*p = val\n\treturn (*Int)(p)\n}\n\n\n\n\n\nfunc (i *Int) Set(s string) error {\n\tv, err := strconv.ParseInt(s, 0, 64)\n\t*i = Int(v)\n\treturn err\n}\n\n\nfunc (i *Int) String() string {\n\treturn fmt.Sprintf(\"%v\", *i)\n}\n\nfunc (i *Int) Get() interface{} ", "output": "{\n\treturn int(*i)\n}"}
{"input": "package compress\n\nimport (\n\t\"bytes\"\n\t\"github.com/xitongsys/parquet-go/parquet\"\n\t\"testing\"\n)\n\nfunc TestGzipCompression(t *testing.T) {\n\tgzipCompressor := compressors[parquet.CompressionCodec_GZIP]\n\tinput := []byte(\"test data\")\n\tcompressed := gzipCompressor.Compress(input)\n\toutput, err := gzipCompressor.Uncompress(compressed)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !bytes.Equal(input, output) {\n\t\tt.Fatalf(\"expected output %s but was %s\", string(input), string(output))\n\t}\n}\n\n\n\nfunc BenchmarkGzipCompression(b *testing.B) ", "output": "{\n\tgzipCompressor := compressors[parquet.CompressionCodec_GZIP]\n\tinput := []byte(\"test data\")\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tgzipCompressor.Compress(input)\n\t}\n}"}
{"input": "package util\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n)\n\n\n\n\nfunc ReadEnvironmentFile(path string) (map[string]string, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\tresult := map[string]string{}\n\n\tscanner := bufio.NewScanner(f)\n\tfor scanner.Scan() {\n\t\ts := strings.TrimSpace(scanner.Text())\n\t\tif strings.HasPrefix(s, \"#\") || strings.HasPrefix(s, \"//\") {\n\t\t\tcontinue\n\t\t}\n\t\tparts := strings.SplitN(s, \"=\", 2)\n\t\tif len(parts) != 2 {\n\t\t\tcontinue\n\t\t}\n\t\tresult[strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])\n\t}\n\n\treturn result, scanner.Err()\n}\n\n\n\nfunc SafeForLoggingEnv(env []string) []string {\n\tproxyRegex := regexp.MustCompile(\"(?i).*proxy.*\")\n\tnewEnv := make([]string, len(env))\n\tcopy(newEnv, env)\n\tfor i, entry := range newEnv {\n\t\tparts := strings.SplitN(entry, \"=\", 2)\n\t\tif !proxyRegex.MatchString(parts[0]) {\n\t\t\tcontinue\n\t\t}\n\t\tnewVal, _ := SafeForLoggingURL(parts[1])\n\t\tnewEnv[i] = fmt.Sprintf(\"%s=%s\", parts[0], newVal)\n\t}\n\treturn newEnv\n}\n\n\n\n\n\n\nfunc SafeForLoggingURL(input string) (string, error) ", "output": "{\n\tu, err := url.Parse(input)\n\tif err != nil {\n\t\treturn input, err\n\t}\n\tu.User = url.User(\"redacted\")\n\treturn u.String(), nil\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/mail\"\n\t\"net/smtp\"\n\t\"time\"\n)\n\ntype mailSender func(addr string, a smtp.Auth, from string, to []string, msg []byte) error\n\n\n\nfunc makeToAddresses(to []string) string {\n\tvar toString string\n\tfor i, t := range to {\n\t\tma := mail.Address{Address: t}\n\t\ttoString += ma.String()\n\t\tif i != len(to)-1 {\n\t\t\ttoString += \", \"\n\t\t}\n\t}\n\treturn toString\n}\n\nfunc makeHeaders(from string, to string, title string, ts time.Time) string {\n\tconst rfc2822 = \"Mon, 02 Jan 2006 15:04:05 -0700\"\n\n\theader := make(map[string]string)\n\theader[\"From\"] = from\n\theader[\"To\"] = to\n\theader[\"Subject\"] = title\n\theader[\"Date\"] = ts.Format(rfc2822)\n\theader[\"MIME-Version\"] = \"1.0\"\n\theader[\"Content-Type\"] = \"text/plain; charset=\\\"utf-8\\\"\"\n\theader[\"Content-Transfer-Encoding\"] = \"base64\"\n\n\tmessage := \"\"\n\tfor k, v := range header {\n\t\tmessage += fmt.Sprintf(\"%s: %s\\r\\n\", k, v)\n\t}\n\n\treturn message\n}\n\nfunc makeMessage(errors []verificationError) string {\n\tbody := \"\"\n\tfor _, e := range errors {\n\t\tbody += fmt.Sprintf(\"%s\\n   %s\\n\", e.title, e.message)\n\t}\n\n\treturn body\n}\n\nfunc sendEmail(senderFunc mailSender, smtpConfig smtpConfiguration, ts time.Time, errors []verificationError) error ", "output": "{\n\tvar auth smtp.Auth\n\tif smtpConfig.Auth != nil {\n\t\ta := *smtpConfig.Auth\n\t\tauth = smtp.PlainAuth(\n\t\t\t\"\",\n\t\t\ta.Username,\n\t\t\ta.Password,\n\t\t\tsmtpConfig.Host,\n\t\t)\n\t} else {\n\t\tauth = nil\n\t}\n\n\tfrom := mail.Address{Address: smtpConfig.From}\n\ttoString := makeToAddresses(smtpConfig.To)\n\n\ttitle := \"Ismonitor alert\"\n\n\tbody := makeMessage(errors)\n\n\tmessage := makeHeaders(from.String(), toString, title, ts) \n\tmessage += \"\\r\\n\"\n\tmessage += base64.StdEncoding.EncodeToString([]byte(body)) \n\n\treturn senderFunc(\n\t\tsmtpConfig.Host+\":\"+fmt.Sprintf(\"%d\", smtpConfig.Port),\n\t\tauth,\n\t\tfrom.Address,\n\t\tsmtpConfig.To,\n\t\t[]byte(message))\n}"}
{"input": "package gfile_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gogf/gf/v2/os/gfile\"\n\t\"github.com/gogf/gf/v2/test/gtest\"\n)\n\nfunc Test_MTime(t *testing.T) {\n\tgtest.C(t, func(t *gtest.T) {\n\n\t\tvar (\n\t\t\tfile1   = \"/testfile_t1.txt\"\n\t\t\terr     error\n\t\t\tfileobj os.FileInfo\n\t\t)\n\n\t\tcreateTestFile(file1, \"\")\n\t\tdefer delTestFiles(file1)\n\t\tfileobj, err = os.Stat(testpath() + file1)\n\t\tt.Assert(err, nil)\n\n\t\tt.Assert(gfile.MTime(testpath()+file1), fileobj.ModTime())\n\t\tt.Assert(gfile.MTime(\"\"), \"\")\n\t})\n}\n\n\n\nfunc Test_MTimeMillisecond(t *testing.T) ", "output": "{\n\tgtest.C(t, func(t *gtest.T) {\n\t\tvar (\n\t\t\tfile1   = \"/testfile_t1.txt\"\n\t\t\terr     error\n\t\t\tfileobj os.FileInfo\n\t\t)\n\n\t\tcreateTestFile(file1, \"\")\n\t\tdefer delTestFiles(file1)\n\t\tfileobj, err = os.Stat(testpath() + file1)\n\t\tt.Assert(err, nil)\n\n\t\ttime.Sleep(time.Millisecond * 100)\n\t\tt.AssertGE(\n\t\t\tgfile.MTimestampMilli(testpath()+file1),\n\t\t\tfileobj.ModTime().UnixNano()/1000000,\n\t\t)\n\t\tt.Assert(gfile.MTimestampMilli(\"\"), -1)\n\t})\n}"}
{"input": "package server\n\nimport \"log\"\n\n\nfunc logf(format string, a ...interface{}) {\n\tlog.Printf(\"skydns: \"+format, a...)\n}\n\n\n\n\nfunc fatalf(format string, a ...interface{}) ", "output": "{\n\tlog.Fatalf(\"skydns: \"+format, a...)\n}"}
{"input": "package subprocess\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\n\t\"github.com/rubyist/tracerx\"\n)\n\n\nfunc SimpleExec(name string, args ...string) (string, error) {\n\ttracerx.Printf(\"run_command: '%s' %s\", name, strings.Join(args, \" \"))\n\tcmd := ExecCommand(name, args...)\n\n\toutput, err := cmd.Output()\n\tif _, ok := err.(*exec.ExitError); ok {\n\t\treturn \"\", nil\n\t}\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"Error running %s %s\", name, args), err\n\t}\n\n\treturn strings.Trim(string(output), \" \\n\"), nil\n}\n\n\nvar env []string\nvar traceEnv = \"GIT_TRACE=\"\n\n\n\nfunc init() ", "output": "{\n\trealEnv := os.Environ()\n\tenv = make([]string, 0, len(realEnv))\n\n\tfor _, kv := range realEnv {\n\t\tif strings.HasPrefix(kv, traceEnv) {\n\t\t\tcontinue\n\t\t}\n\t\tenv = append(env, kv)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tcounts := make(map[string]int)\n\tnames := make(map[string][]string)\n\tfiles := os.Args[1:]\n\tif len(files) == 0 {\n\t\tcountLines(os.Stdin, counts, names)\n\t} else {\n\t\tfor _, arg := range files {\n\t\t\tf, err := os.Open(arg)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"dup2: %v\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcountLines(f, counts, names)\n\t\t\tf.Close()\n\t\t}\n\t}\n\tfor line, n := range counts {\n\t\tif n > 1 {\n\t\t\tfmt.Printf(\"%s\\n\", line)\n\t\t\tfmt.Printf(\"%s\\n\\n\", names[line])\n\t\t}\n\t}\n}\n\n\n\nfunc contains(s []string, e string) bool {\n\tfor _, a := range s {\n\t\tif a == e {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc countLines(f *os.File, counts map[string]int, names map[string][]string) ", "output": "{\n\tinput := bufio.NewScanner(f)\n\tfor input.Scan() {\n\t\tcounts[input.Text()]++\n\t\tvalue := names[input.Text()]\n\t\tif !contains(value, f.Name()) {\n\t\t\tnames[input.Text()] = append(names[input.Text()], f.Name())\n\t\t}\n\t}\n}"}
{"input": "package persona\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype personaResponse struct {\n\tStatus string `json:\"status\"`\n\tEmail  string `json:\"email\"`\n}\n\n\n\nfunc assert(audience, assertion string) (string, error) ", "output": "{\n\tparams := url.Values{}\n\tparams.Add(\"assertion\", assertion)\n\tparams.Add(\"audience\", audience)\n\n\tresp, err := http.PostForm(\"https://verifier.login.persona.org/verify\", params)\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\n\tvar f personaResponse\n\terr = json.Unmarshal(body, &f)\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif f.Status != \"okay\" {\n\t\treturn \"\", errors.New(\"Status not okay\")\n\t}\n\n\treturn f.Email, nil\n}"}
{"input": "package lxd\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/lxc/lxd/shared/api\"\n)\n\n\n\n\n\n\n\nfunc (r *ProtocolLXD) GetCertificates() ([]api.Certificate, error) {\n\tcertificates := []api.Certificate{}\n\n\t_, err := r.queryStruct(\"GET\", \"/certificates?recursion=1\", nil, \"\", &certificates)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn certificates, nil\n}\n\n\nfunc (r *ProtocolLXD) GetCertificate(fingerprint string) (*api.Certificate, string, error) {\n\tcertificate := api.Certificate{}\n\n\tetag, err := r.queryStruct(\"GET\", fmt.Sprintf(\"/certificates/%s\", fingerprint), nil, \"\", &certificate)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\treturn &certificate, etag, nil\n}\n\n\nfunc (r *ProtocolLXD) CreateCertificate(certificate api.CertificatesPost) error {\n\t_, _, err := r.query(\"POST\", \"/certificates\", certificate, \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc (r *ProtocolLXD) UpdateCertificate(fingerprint string, certificate api.CertificatePut, ETag string) error {\n\tif !r.HasExtension(\"certificate_update\") {\n\t\treturn fmt.Errorf(\"The server is missing the required \\\"certificate_update\\\" API extension\")\n\t}\n\n\t_, _, err := r.query(\"PUT\", fmt.Sprintf(\"/certificates/%s\", fingerprint), certificate, ETag)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc (r *ProtocolLXD) DeleteCertificate(fingerprint string) error {\n\t_, _, err := r.query(\"DELETE\", fmt.Sprintf(\"/certificates/%s\", fingerprint), nil, \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (r *ProtocolLXD) GetCertificateFingerprints() ([]string, error) ", "output": "{\n\tcertificates := []string{}\n\n\t_, err := r.queryStruct(\"GET\", \"/certificates\", nil, \"\", &certificates)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfingerprints := []string{}\n\tfor _, fingerprint := range fingerprints {\n\t\tfields := strings.Split(fingerprint, \"/certificates/\")\n\t\tfingerprints = append(fingerprints, fields[len(fields)-1])\n\t}\n\n\treturn fingerprints, nil\n}"}
{"input": "package avl\n\n\nfunc (tree *Tree) First() *Node {\n\treturn tree.root.first()\n}\n\n\nfunc (tree *Node) first() *Node {\n\tif nil == tree {\n\t\treturn nil\n\t}\n\tfor nil != tree.left {\n\t\ttree = tree.left\n\t}\n\treturn tree\n}\n\n\nfunc (tree *Tree) Last() *Node {\n\treturn tree.root.last()\n}\n\n\n\n\n\n\nfunc (tree *Node) Next() *Node {\n\tif nil == tree.right {\n\t\tkey := tree.key\n\t\tfor {\n\t\t\ttree = tree.up\n\t\t\tif nil == tree {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif 1 == tree.key.Compare(key) { \n\t\t\t\treturn tree\n\t\t\t}\n\t\t}\n\t}\n\treturn tree.right.first()\n}\n\n\n\nfunc (tree *Node) Prev() *Node {\n\tif nil == tree.left {\n\t\tkey := tree.key\n\t\tfor {\n\t\t\ttree = tree.up\n\t\t\tif nil == tree {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif -1 == tree.key.Compare(key) { \n\t\t\t\treturn tree\n\t\t\t}\n\t\t}\n\t}\n\treturn tree.left.last()\n}\n\nfunc (tree *Node) last() *Node ", "output": "{\n\tif nil == tree {\n\t\treturn nil\n\t}\n\tfor nil != tree.right {\n\t\ttree = tree.right\n\t}\n\treturn tree\n}"}
{"input": "package ledclient\n\nimport (\n\tcolorful \"github.com/lucasb-eyer/go-colorful\"\n)\n\n\ntype Canvas struct {\n\tpixels []colorful.Color\n\twidth  int\n\theight int\n}\n\n\n\nfunc (c *Canvas) PixelIndex(x, y int) int {\n\treturn c.width*y + x\n}\n\nfunc (c *Canvas) Set(x, y int, col colorful.Color) {\n\tc.pixels[c.PixelIndex(x, y)] = col\n}\n\nfunc (c *Canvas) At(x, y int) colorful.Color {\n\treturn c.pixels[c.PixelIndex(x, y)]\n}\n\nfunc (c *Canvas) Size() (int, int) {\n\treturn c.width, c.height\n}\n\nfunc NewCanvas(width, height int) *Canvas ", "output": "{\n\treturn &Canvas{\n\t\tpixels: make([]colorful.Color, width*height),\n\t\twidth:  width,\n\t\theight: height,\n\t}\n}"}
{"input": "package zcldec\n\nimport (\n\t\"github.com/zclconf/go-cty/cty\"\n\t\"github.com/zclconf/go-zcl/zcl\"\n)\n\n\n\n\n\n\n\nfunc Decode(body zcl.Body, spec Spec, ctx *zcl.EvalContext) (cty.Value, zcl.Diagnostics) {\n\tval, _, diags := decode(body, nil, ctx, spec, false)\n\treturn val, diags\n}\n\n\n\n\n\n\n\nfunc PartialDecode(body zcl.Body, spec Spec, ctx *zcl.EvalContext) (cty.Value, zcl.Body, zcl.Diagnostics) {\n\treturn decode(body, nil, ctx, spec, true)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc SourceRange(body zcl.Body, spec Spec) zcl.Range ", "output": "{\n\treturn sourceRange(body, nil, spec)\n}"}
{"input": "package main\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestVttablet(t *testing.T) ", "output": "{\n\tmain()\n}"}
{"input": "package u\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync/atomic\"\n)\n\n\ntype FileWalkEntry struct {\n\tDir      string\n\tFileInfo os.FileInfo\n}\n\n\nfunc (e *FileWalkEntry) Path() string {\n\treturn filepath.Join(e.Dir, e.FileInfo.Name())\n}\n\n\ntype FileWalk struct {\n\tstartDir    string\n\tFilesChan   chan *FileWalkEntry\n\taskedToStop int32\n}\n\n\nfunc (ft *FileWalk) Stop() {\n\tatomic.StoreInt32(&ft.askedToStop, 1)\n\tfor range ft.FilesChan {\n\t}\n}\n\n\n\n\nfunc StartFileWalk(startDir string) *FileWalk {\n\tch := make(chan *FileWalkEntry, 1024*64)\n\tft := &FileWalk{\n\t\tstartDir:  startDir,\n\t\tFilesChan: ch,\n\t}\n\tgo fileWalkWorker(ft)\n\treturn ft\n}\n\nfunc fileWalkWorker(ft *FileWalk) ", "output": "{\n\ttoVisit := []string{ft.startDir}\n\tdefer close(ft.FilesChan)\n\n\tfor len(toVisit) > 0 {\n\t\tshouldStop := atomic.LoadInt32(&ft.askedToStop)\n\t\tif shouldStop > 0 {\n\t\t\treturn\n\t\t}\n\t\tdir := toVisit[0]\n\t\ttoVisit = StringsRemoveFirst(toVisit)\n\n\t\tfiles, err := ioutil.ReadDir(dir)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, fi := range files {\n\t\t\tpath := filepath.Join(dir, fi.Name())\n\t\t\tmode := fi.Mode()\n\t\t\tif mode.IsDir() {\n\t\t\t\ttoVisit = append(toVisit, path)\n\t\t\t} else if mode.IsRegular() {\n\t\t\t\tfte := &FileWalkEntry{\n\t\t\t\t\tDir:      dir,\n\t\t\t\t\tFileInfo: fi,\n\t\t\t\t}\n\t\t\t\tft.FilesChan <- fte\n\t\t\t}\n\t\t}\n\t}\n}"}
{"input": "package transactionidutils\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/dchest/uniuri\"\n)\n\ntype tidKeyType int\n\nconst (\n\tTransactionIDHeader = \"X-Request-Id\"\n\ttransactionIDKey tidKeyType = iota\n)\n\n\n\n\n\nfunc GetTransactionIDFromRequest(req *http.Request) string {\n\ttransactionID := req.Header.Get(TransactionIDHeader)\n\tif transactionID == \"\" {\n\t\ttransactionID = NewTransactionID()\n\t\treq.Header.Set(TransactionIDHeader, transactionID)\n\t}\n\treturn transactionID\n}\n\n\nfunc NewTransactionID() string {\n\treturn fmt.Sprintf(\"tid_%s\", uniuri.NewLen(10))\n}\n\n\n\nfunc TransactionAwareContext(ctx context.Context, transactionID string) context.Context {\n\treturn context.WithValue(ctx, transactionIDKey, transactionID)\n}\n\n\n\n\n\n\nfunc GetTransactionIDFromContext(ctx context.Context) (string, error) ", "output": "{\n\ttransactionID, ok := ctx.Value(transactionIDKey).(string)\n\tif ok {\n\t\treturn transactionID, nil\n\t}\n\treturn \"\", fmt.Errorf(\"no transactionID found\")\n}"}
{"input": "package main\n\nimport (\n\t\"go/ast\"\n\t\"strconv\"\n)\n\n\n\nvar gotypesFix = fix{\n\t\"gotypes\",\n\t\"2015-07-16\",\n\tgotypes,\n\t`Change imports of golang.org/x/tools/go/{exact,types} to go/{constant,types}`,\n}\n\nfunc gotypes(f *ast.File) bool {\n\ttruth := fixGoTypes(f)\n\tif fixGoExact(f) {\n\t\ttruth = true\n\t}\n\treturn truth\n}\n\nfunc fixGoTypes(f *ast.File) bool {\n\treturn rewriteImport(f, \"golang.org/x/tools/go/types\", \"go/types\")\n}\n\nfunc fixGoExact(f *ast.File) bool {\n\tvar importSpec *ast.ImportSpec\n\twalk(f, func(n interface{}) {\n\t\tif importSpec != nil {\n\t\t\treturn\n\t\t}\n\t\tspec, ok := n.(*ast.ImportSpec)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tpath, err := strconv.Unquote(spec.Path.Value)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif path == \"golang.org/x/tools/go/exact\" {\n\t\t\timportSpec = spec\n\t\t}\n\n\t})\n\tif importSpec == nil {\n\t\treturn false\n\t}\n\n\texists := renameTop(f, \"constant\", \"constant\")\n\tsuffix := \"\"\n\tif exists {\n\t\tsuffix = \"_\"\n\t}\n\trenameTop(f, \"exact\", \"constant\"+suffix)\n\trewriteImport(f, \"golang.org/x/tools/go/exact\", \"go/constant\")\n\timportSpec.Name = nil\n\treturn true\n}\n\nfunc init() ", "output": "{\n\tregister(gotypesFix)\n}"}
{"input": "package math\n\n\n\nfunc MinInt(a, b int) int ", "output": "{\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}"}
{"input": "package chaincode\n\nimport (\n\t\"github.com/hyperledger/fabric/core/container/ccintf\"\n)\n\n\n\nfunc SetHandlerChaincodeID(h *Handler, chaincodeID string) {\n\th.chaincodeID = chaincodeID\n}\n\nfunc SetHandlerChatStream(h *Handler, chatStream ccintf.ChaincodeStream) {\n\th.chatStream = chatStream\n}\n\n\n\nfunc SetStreamDoneChan(h *Handler, ch chan struct{}) {\n\th.streamDoneChan = ch\n}\n\nfunc StreamDone(h *Handler) <-chan struct{} ", "output": "{\n\treturn h.streamDone()\n}"}
{"input": "package main\n\nimport \"fmt\"\n\n\n\nfunc main() {\n\tvar s int\n\tvar m int = 0\n\tfmt.Scanf(\"%v\\n\", &s)\n\ta := capt(s)\n\tb := capt(s)\n\n\tm = a[0] + b[0]\n\tfor i, v1 := range a {\n\t\tif v1 < m {\n\t\t\tfor k, v2 := range b {\n\t\t\t\tif v2 < m {\n\t\t\t\t\tif i != k {\n\t\t\t\t\t\tif (v1 + v2) < m {\n\t\t\t\t\t\t\tm = (v1 + v2)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Println(m)\n}\n\nfunc capt(s int) []int ", "output": "{\n\tx := make([]int, s)\n\ty := make([]interface{}, len(x))\n\tfor i := range x {\n\t\ty[i] = &x[i]\n\t}\n\tn, _ := fmt.Scanln(y...)\n\tx = x[:n]\n\treturn x\n}"}
{"input": "package native\n\nimport (\n\t\"testing\"\n\n\t\"github.com/gonum/blas/testblas\"\n)\n\nvar impl Implementation\n\n\n\nfunc TestDaxpy(t *testing.T) {\n\ttestblas.DaxpyTest(t, impl)\n}\n\nfunc TestDdot(t *testing.T) {\n\ttestblas.DdotTest(t, impl)\n}\n\nfunc TestDnrm2(t *testing.T) {\n\ttestblas.Dnrm2Test(t, impl)\n}\n\nfunc TestIdamax(t *testing.T) {\n\ttestblas.IdamaxTest(t, impl)\n}\n\nfunc TestDswap(t *testing.T) {\n\ttestblas.DswapTest(t, impl)\n}\n\nfunc TestDcopy(t *testing.T) {\n\ttestblas.DcopyTest(t, impl)\n}\n\nfunc TestDrotg(t *testing.T) {\n\ttestblas.DrotgTest(t, impl)\n}\n\nfunc TestDrotmg(t *testing.T) {\n\ttestblas.DrotmgTest(t, impl)\n}\n\nfunc TestDrot(t *testing.T) {\n\ttestblas.DrotTest(t, impl)\n}\n\nfunc TestDrotm(t *testing.T) {\n\ttestblas.DrotmTest(t, impl)\n}\n\nfunc TestDscal(t *testing.T) {\n\ttestblas.DscalTest(t, impl)\n}\n\nfunc TestDasum(t *testing.T) ", "output": "{\n\ttestblas.DasumTest(t, impl)\n}"}
{"input": "package rds_region\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc TestDescribeDBInstanceIPArrayList(t *testing.T) ", "output": "{\n\tvar req DescribeDBInstanceIPArrayListRequest\n\treq.Init()\n\treq.SetFormat(\"JSON\")\n\treq.SetRegionId(\"cn-shenzhen\")\n\tvar accessId = \"Ie65kUInu5GeAsma\"\n\tvar accessSecret = \"8cCqoxdYU9zKUihwXFXiN1HEACBDwB\"\n\tresp, err := DescribeDBInstanceIPArrayList(&req, accessId, accessSecret)\n\tif err != nil {\n\t\tt.Errorf(\"Error: %s\", err.Error())\n\t}\n\tfmt.Printf(\"Success: %v\\n\", resp)\n}"}
{"input": "package influxdb_v2\n\nimport (\n\t\"net/url\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\n\n\nfunc TestMakeWriteURL(t *testing.T) {\n\ttests := []struct {\n\t\terr bool\n\t\turl *url.URL\n\t\tact string\n\t}{\n\t\t{\n\t\t\turl: genURL(\"http://localhost:9999\"),\n\t\t\tact: \"http://localhost:9999/api/v2/write?bucket=telegraf&org=influx\",\n\t\t},\n\t\t{\n\t\t\turl: genURL(\"unix://var/run/influxd.sock\"),\n\t\t\tact: \"http://127.0.0.1/api/v2/write?bucket=telegraf&org=influx\",\n\t\t},\n\t\t{\n\t\t\terr: true,\n\t\t\turl: genURL(\"udp://localhost:9999\"),\n\t\t},\n\t}\n\n\tfor i := range tests {\n\t\trURL, err := makeWriteURL(*tests[i].url, \"influx\", \"telegraf\")\n\t\tif !tests[i].err {\n\t\t\trequire.NoError(t, err)\n\t\t} else {\n\t\t\trequire.Error(t, err)\n\t\t\tt.Log(err)\n\t\t}\n\t\tif err == nil {\n\t\t\trequire.Equal(t, tests[i].act, rURL)\n\t\t}\n\t}\n}\n\nfunc genURL(u string) *url.URL ", "output": "{\n\tURL, _ := url.Parse(u)\n\treturn URL\n}"}
{"input": "package relay\n\n\n\n\n\n\n\n\ntype AccessRights string\n\nconst (\n\tListen AccessRights = \"Listen\"\n\tManage AccessRights = \"Manage\"\n\tSendEnumValue AccessRights = \"Send\"\n)\n\n\nfunc PossibleAccessRightsValues() []AccessRights {\n\treturn []AccessRights{Listen, Manage, SendEnumValue}\n}\n\n\ntype KeyType string\n\nconst (\n\tPrimaryKey KeyType = \"PrimaryKey\"\n\tSecondaryKey KeyType = \"SecondaryKey\"\n)\n\n\nfunc PossibleKeyTypeValues() []KeyType {\n\treturn []KeyType{PrimaryKey, SecondaryKey}\n}\n\n\ntype ProvisioningStateEnum string\n\nconst (\n\tCreated ProvisioningStateEnum = \"Created\"\n\tDeleted ProvisioningStateEnum = \"Deleted\"\n\tFailed ProvisioningStateEnum = \"Failed\"\n\tSucceeded ProvisioningStateEnum = \"Succeeded\"\n\tUnknown ProvisioningStateEnum = \"Unknown\"\n\tUpdating ProvisioningStateEnum = \"Updating\"\n)\n\n\nfunc PossibleProvisioningStateEnumValues() []ProvisioningStateEnum {\n\treturn []ProvisioningStateEnum{Created, Deleted, Failed, Succeeded, Unknown, Updating}\n}\n\n\ntype RelaytypeEnum string\n\nconst (\n\tHTTP RelaytypeEnum = \"Http\"\n\tNetTCP RelaytypeEnum = \"NetTcp\"\n)\n\n\n\n\n\ntype SkuTier string\n\nconst (\n\tStandard SkuTier = \"Standard\"\n)\n\n\nfunc PossibleSkuTierValues() []SkuTier {\n\treturn []SkuTier{Standard}\n}\n\n\ntype UnavailableReason string\n\nconst (\n\tInvalidName UnavailableReason = \"InvalidName\"\n\tNameInLockdown UnavailableReason = \"NameInLockdown\"\n\tNameInUse UnavailableReason = \"NameInUse\"\n\tNone UnavailableReason = \"None\"\n\tSubscriptionIsDisabled UnavailableReason = \"SubscriptionIsDisabled\"\n\tTooManyNamespaceInCurrentSubscription UnavailableReason = \"TooManyNamespaceInCurrentSubscription\"\n)\n\n\nfunc PossibleUnavailableReasonValues() []UnavailableReason {\n\treturn []UnavailableReason{InvalidName, NameInLockdown, NameInUse, None, SubscriptionIsDisabled, TooManyNamespaceInCurrentSubscription}\n}\n\nfunc PossibleRelaytypeEnumValues() []RelaytypeEnum ", "output": "{\n\treturn []RelaytypeEnum{HTTP, NetTCP}\n}"}
{"input": "package datatypes\n\ntype Time int64\n\ntype StreamName string\n\ntype Event struct {\n    Time Time;\n    Payload EvPayload\n}\n\ntype EvPayload struct {\n    IsSet bool;\n    Val interface{}\n}\n\ntype MaybeTime struct {\n    IsSet bool;\n    Val Time\n}\n\n\n\nvar NothingTime MaybeTime = MaybeTime{false, -100}\n\nfunc Some(val interface{}) EvPayload {\n    return EvPayload{true, val}\n}\n\nvar NothingPayload EvPayload = EvPayload{false, nil}\n\ntype EpsVal struct {\n    Eps Time\n    Val interface{}\n}\n\ntype OutStream struct {\n    Name StreamName\n    TicksDef TickerNode\n    ValDef ValNode\n}\n\ntype InStream struct {\n    Name StreamName\n    StreamDef InStreamDef\n}\n\ntype InStreamDef interface {\n    PeekNextTime() MaybeTime\n    Exec(t Time) EvPayload\n}\n\ntype FlowingEvent struct {\n    Name StreamName\n    Event Event\n}\n\nfunc SomeTime(val Time) MaybeTime ", "output": "{\n    return MaybeTime{true, val}\n}"}
{"input": "package server\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"k8s.io/klog/v2\"\n\n\t\"k8s.io/apiserver/pkg/authentication/authenticator\"\n\t\"k8s.io/apiserver/pkg/authentication/user\"\n\t\"k8s.io/client-go/rest\"\n)\n\n\n\n\ntype DeprecatedInsecureServingInfo struct {\n\tListener net.Listener\n\tName string\n}\n\n\n\nfunc (s *DeprecatedInsecureServingInfo) Serve(handler http.Handler, shutdownTimeout time.Duration, stopCh <-chan struct{}) error {\n\tinsecureServer := &http.Server{\n\t\tAddr:           s.Listener.Addr().String(),\n\t\tHandler:        handler,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\n\tif len(s.Name) > 0 {\n\t\tklog.Infof(\"Serving %s insecurely on %s\", s.Name, s.Listener.Addr())\n\t} else {\n\t\tklog.Infof(\"Serving insecurely on %s\", s.Listener.Addr())\n\t}\n\t_, _, err := RunServer(insecureServer, s.Listener, shutdownTimeout, stopCh)\n\treturn err\n}\n\n\n\n\n\n\ntype InsecureSuperuser struct{}\n\nfunc (InsecureSuperuser) AuthenticateRequest(req *http.Request) (*authenticator.Response, bool, error) {\n\tauds, _ := authenticator.AudiencesFrom(req.Context())\n\treturn &authenticator.Response{\n\t\tUser: &user.DefaultInfo{\n\t\t\tName:   \"system:unsecured\",\n\t\t\tGroups: []string{user.SystemPrivilegedGroup, user.AllAuthenticated},\n\t\t},\n\t\tAudiences: auds,\n\t}, true, nil\n}\n\nfunc (s *DeprecatedInsecureServingInfo) NewLoopbackClientConfig() (*rest.Config, error) ", "output": "{\n\tif s == nil {\n\t\treturn nil, nil\n\t}\n\n\thost, port, err := LoopbackHostPort(s.Listener.Addr().String())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &rest.Config{\n\t\tHost: \"http://\" + net.JoinHostPort(host, port),\n\t\tQPS:   50,\n\t\tBurst: 100,\n\t}, nil\n}"}
{"input": "package install\n\nimport (\n\t\"k8s.io/apimachinery/pkg/apimachinery/announced\"\n\t\"k8s.io/apimachinery/pkg/apimachinery/registered\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/code-generator/_examples/apiserver/apis/example\"\n\t\"k8s.io/code-generator/_examples/apiserver/apis/example/v1\"\n)\n\n\n\n\nfunc Install(groupFactoryRegistry announced.APIGroupFactoryRegistry, registry *registered.APIRegistrationManager, scheme *runtime.Scheme) ", "output": "{\n\tif err := announced.NewGroupMetaFactory(\n\t\t&announced.GroupMetaFactoryArgs{\n\t\t\tGroupName:                  example.SchemeGroupVersion.Group,\n\t\t\tVersionPreferenceOrder:     []string{v1.SchemeGroupVersion.Version},\n\t\t\tAddInternalObjectsToScheme: example.AddToScheme,\n\t\t},\n\t\tannounced.VersionToSchemeFunc{\n\t\t\tv1.SchemeGroupVersion.Version: v1.AddToScheme,\n\t\t},\n\t).Announce(groupFactoryRegistry).RegisterAndEnable(registry, scheme); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"input": "package tools\n\n\nfunc MinInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\n\treturn b\n}\n\n\n\n\n\nfunc ClampInt(n, min, max int) int {\n\treturn MinInt(max, MaxInt(min, n))\n}\n\n\nfunc MinInt64(a, b int64) int64 {\n\tif a < b {\n\t\treturn a\n\t}\n\n\treturn b\n}\n\n\nfunc MaxInt64(a, b int64) int64 {\n\tif a > b {\n\t\treturn a\n\t}\n\n\treturn b\n}\n\nfunc MaxInt(a, b int) int ", "output": "{\n\tif a > b {\n\t\treturn a\n\t}\n\n\treturn b\n}"}
{"input": "package main\n\nimport (\n  \"fmt\"\n  \"github.com/gin-gonic/gin\"\n  \"github.com/dgrijalva/jwt-go\"\n)\n\nfunc resendEmailVerificationHandler(c *gin.Context){\n  var request struct{\n    Token string `form:\"token\" binding:\"required\"`\n  }\n  if c.Bind(&request) == nil{\n    if mobileno, client_id, email_id := getDetailsfromToken(request.Token); mobileno != \"\" || client_id != \"\" || email_id != \"\"{\n      sendEmailVerification(mobileno, client_id, email_id)\n      c.JSON(200, gin.H{\n        \"status\" : \"success\",\n      })\n    }else{\n      c.JSON(200, gin.H{\n        \"status\" : \"failed\",\n        \"message\" : \"Failed to Send Verification Email! Please try again\",\n      })\n    }\n  }\n}\n\n\n\nfunc getDetailsfromToken(tokenString string) (string, string, string) ", "output": "{\n  vertoken, _ := jwt.Parse(tokenString, func (token *jwt.Token) (interface{}, error)  {\n    if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n       return nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n   }\n   return mySigningKey, nil\n  })\n  if claims, _ := vertoken.Claims.(jwt.MapClaims); !vertoken.Valid {\n    id := claims[\"id\"].(string)\n    email_id := claims[\"email_id\"].(string)\n    client_id := claims[\"client_id\"].(string)\n    fmt.Println(\"Resending email for :\", id, email_id, client_id)\n    return id, client_id, email_id\n  }\n  return \"\",\"\",\"\"\n}"}
{"input": "package ui\n\nimport (\n\t\"sync\"\n\n\t\"github.com/gdamore/tcell/views\"\n)\n\n\n\n\n\ntype Panel struct {\n\ttb   *TitleBar\n\tsb   *StatusBar\n\tkb   *KeyBar\n\tonce sync.Once\n\tapp  *App\n\n\tviews.Panel\n}\n\nfunc (p *Panel) SetTitle(title string) {\n\tp.tb.SetCenter(title)\n}\n\nfunc (p *Panel) SetKeys(words []string) {\n\tp.kb.SetKeys(words)\n}\n\nfunc (p *Panel) SetStatus(status string) {\n\tp.sb.SetText(status)\n}\n\nfunc (p *Panel) SetGood() {\n\tp.sb.SetGood()\n}\n\nfunc (p *Panel) SetNormal() {\n\tp.sb.SetNormal()\n}\n\n\n\nfunc (p *Panel) SetError() {\n\tp.sb.SetError()\n}\n\nfunc (p *Panel) Init(app *App) {\n\tp.once.Do(func() {\n\t\tp.app = app\n\n\t\tp.tb = NewTitleBar()\n\t\tp.tb.SetRight(app.GetAppName())\n\t\tp.tb.SetCenter(\" \")\n\n\t\tp.kb = NewKeyBar()\n\n\t\tp.sb = NewStatusBar()\n\n\t\tp.Panel.SetTitle(p.tb)\n\t\tp.Panel.SetMenu(p.sb)\n\t\tp.Panel.SetStatus(p.kb)\n\t})\n}\n\nfunc (p *Panel) App() *App {\n\treturn p.app\n}\n\nfunc NewPanel(app *App) *Panel {\n\tp := &Panel{}\n\tp.Init(app)\n\treturn p\n}\n\nfunc (p *Panel) SetWarn() ", "output": "{\n\tp.sb.SetWarn()\n}"}
{"input": "package main\n\ntype Layout struct {\n\tpressure    int\n\tspacing     int\n\tnum_spaces  int\n\tshow_date   bool\n\twidget_size Size\n}\n\n\n\nfunc (layout Layout) width() int ", "output": "{\n\treturn layout.widget_size.width + layout.num_spaces*layout.spacing\n}"}
{"input": "package console\n\nimport \"github.com/accurateproject/accurate/api/v1\"\n\n\n\n\ntype CmdExecuteScheduledActions struct {\n\tname      string\n\trpcMethod string\n\trpcParams *v1.AttrsExecuteScheduledActions\n\t*CommandExecuter\n}\n\nfunc (self *CmdExecuteScheduledActions) Name() string {\n\treturn self.name\n}\n\nfunc (self *CmdExecuteScheduledActions) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\nfunc (self *CmdExecuteScheduledActions) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &v1.AttrsExecuteScheduledActions{}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *CmdExecuteScheduledActions) PostprocessRpcParams() error {\n\treturn nil\n}\n\nfunc (self *CmdExecuteScheduledActions) RpcResult() interface{} {\n\tvar s string\n\treturn &s\n}\n\nfunc init() ", "output": "{\n\tc := &CmdExecuteScheduledActions{\n\t\tname:      \"scheduler_execute\",\n\t\trpcMethod: \"ApiV1.ExecuteScheduledActions\",\n\t\trpcParams: &v1.AttrsExecuteScheduledActions{},\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}"}
{"input": "package cli\n\nimport \"github.com/scaleway/scaleway-cli/pkg/commands\"\n\nvar cmdStop = &Command{\n\tExec:        runStop,\n\tUsageLine:   \"stop [OPTIONS] SERVER [SERVER...]\",\n\tDescription: \"Stop a running server\",\n\tHelp:        \"Stop a running server.\",\n\tExamples: `\n    $ scw stop my-running-server my-second-running-server\n    $ scw stop -t my-running-server my-second-running-server\n    $ scw stop $(scw ps -q)\n    $ scw stop $(scw ps | grep mysql | awk '{print $1}')\n    $ scw stop server && stop wait server\n    $ scw stop -w server\n`,\n}\n\nfunc init() {\n\tcmdStop.Flag.BoolVar(&stopT, []string{\"t\", \"-terminate\"}, false, \"Stop and trash a server with its volumes\")\n\tcmdStop.Flag.BoolVar(&stopHelp, []string{\"h\", \"-help\"}, false, \"Print usage\")\n\tcmdStop.Flag.BoolVar(&stopW, []string{\"w\", \"-wait\"}, false, \"Synchronous stop. Wait for SSH to be ready\")\n}\n\n\nvar stopT bool    \nvar stopHelp bool \nvar stopW bool    \n\n\n\nfunc runStop(cmd *Command, rawArgs []string) error ", "output": "{\n\tif stopHelp {\n\t\treturn cmd.PrintUsage()\n\t}\n\tif len(rawArgs) < 1 {\n\t\treturn cmd.PrintShortUsage()\n\t}\n\n\targs := commands.StopArgs{\n\t\tTerminate: stopT,\n\t\tWait:      stopW,\n\t\tServers:   rawArgs,\n\t}\n\tctx := cmd.GetContext(rawArgs)\n\treturn commands.RunStop(ctx, args)\n}"}
{"input": "package unix\n\nimport (\n\t\"syscall\"\n\t\"unsafe\"\n)\n\nfunc setTimespec(sec, nsec int64) Timespec {\n\treturn Timespec{Sec: sec, Nsec: nsec}\n}\n\n\n\nfunc SetKevent(k *Kevent_t, fd, mode, flags int) {\n\tk.Ident = uint64(fd)\n\tk.Filter = int16(mode)\n\tk.Flags = uint16(flags)\n}\n\nfunc (iov *Iovec) SetLen(length int) {\n\tiov.Len = uint64(length)\n}\n\nfunc (msghdr *Msghdr) SetControllen(length int) {\n\tmsghdr.Controllen = uint32(length)\n}\n\nfunc (cmsg *Cmsghdr) SetLen(length int) {\n\tcmsg.Len = uint32(length)\n}\n\nfunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {\n\tvar writtenOut uint64 = 0\n\t_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(count), 0, uintptr(unsafe.Pointer(&writtenOut)), 0, 0, 0)\n\n\twritten = int(writtenOut)\n\n\tif e1 != 0 {\n\t\terr = e1\n\t}\n\treturn\n}\n\nfunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)\n\nfunc setTimeval(sec, usec int64) Timeval ", "output": "{\n\treturn Timeval{Sec: sec, Usec: usec}\n}"}
{"input": "package dploy\n\nimport \"testing\"\n\n\n\nfunc TestInit(t *testing.T) {\n\n}\n\n\n\n\n\nfunc ExampleInit_output() ", "output": "{\n\tInit(\"/tmp/\")\n}"}
{"input": "package route\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"path\"\n\t\"strings\"\n)\n\n\nvar match matcher = prefixMatcher\n\n\ntype matcher func(uri string, r *Route) bool\n\n\nfunc prefixMatcher(uri string, r *Route) bool {\n\treturn strings.HasPrefix(uri, r.Path)\n}\n\n\nfunc globMatcher(uri string, r *Route) bool {\n\tvar hasMatch, err = path.Match(r.Path, uri)\n\tif err != nil {\n\t\tlog.Printf(\"[ERROR] Glob matching error %s for path %s route %s\", err, uri, r.Path)\n\t\treturn false\n\t}\n\treturn hasMatch\n}\n\n\n\n\nfunc SetMatcher(s string) error ", "output": "{\n\tswitch s {\n\tcase \"prefix\":\n\t\tmatch = prefixMatcher\n\tcase \"glob\":\n\t\tmatch = globMatcher\n\tdefault:\n\t\treturn fmt.Errorf(\"route: invalid matcher: %s\", s)\n\t}\n\treturn nil\n}"}
{"input": "package ec2\n\nimport \"github.com/timob/javabind\"\n\ntype AuthAWSCredentialsInterface interface {\n\n\tGetAWSAccessKeyId() string\n\n\tGetAWSSecretKey() string\n}\n\ntype AuthAWSCredentials struct {\n\tJavaLangObject\n}\n\n\nfunc (jbobject *AuthAWSCredentials) GetAWSAccessKeyId() string {\n\tjret, err := jbobject.CallMethod(javabind.GetEnv(), \"getAWSAccessKeyId\", \"java/lang/String\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tretconv := javabind.NewJavaToGoString()\n\tdst := new(string)\n\tretconv.Dest(dst)\n\tif err := retconv.Convert(javabind.ObjectRef(jret)); err != nil {\n\t\tpanic(err)\n\t}\n\tretconv.CleanUp()\n\treturn *dst\n}\n\n\n\n\nfunc (jbobject *AuthAWSCredentials) GetAWSSecretKey() string ", "output": "{\n\tjret, err := jbobject.CallMethod(javabind.GetEnv(), \"getAWSSecretKey\", \"java/lang/String\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tretconv := javabind.NewJavaToGoString()\n\tdst := new(string)\n\tretconv.Dest(dst)\n\tif err := retconv.Convert(javabind.ObjectRef(jret)); err != nil {\n\t\tpanic(err)\n\t}\n\tretconv.CleanUp()\n\treturn *dst\n}"}
{"input": "package texture\n\nimport (\n\t. \"github.com/barnex/bruteray/geom\"\n\t. \"github.com/barnex/bruteray/imagef/colorf\"\n)\n\n\ntype Func2D func(u, v float64) Color\n\n\n\nfunc (f Func2D) AtUV(u, v float64) Color {\n\treturn f(u, v)\n}\n\n\n\ntype Func func(p Vec) Color\n\nfunc (f Func) At(p Vec) Color {\n\treturn f(p)\n}\n\nfunc (f Func2D) At(p Vec) Color ", "output": "{\n\treturn f(p[0], p[1])\n}"}
{"input": "package cache\n\nimport (\n\t\"context\"\n\t\"io\"\n\n\t\"github.com/GoogleContainerTools/skaffold/pkg/skaffold/graph\"\n\t\"github.com/GoogleContainerTools/skaffold/pkg/skaffold/platform\"\n\tlatestV1 \"github.com/GoogleContainerTools/skaffold/pkg/skaffold/schema/latest/v1\"\n\t\"github.com/GoogleContainerTools/skaffold/pkg/skaffold/tag\"\n)\n\ntype BuildAndTestFn func(context.Context, io.Writer, tag.ImageTags, []*latestV1.Artifact, platform.Resolver) ([]graph.Artifact, error)\n\ntype Cache interface {\n\tBuild(context.Context, io.Writer, tag.ImageTags, []*latestV1.Artifact, platform.Resolver, BuildAndTestFn) ([]graph.Artifact, error)\n}\n\ntype noCache struct{}\n\n\n\nfunc (n *noCache) Build(ctx context.Context, out io.Writer, tags tag.ImageTags, artifacts []*latestV1.Artifact, platforms platform.Resolver, buildAndTest BuildAndTestFn) ([]graph.Artifact, error) ", "output": "{\n\treturn buildAndTest(ctx, out, tags, artifacts, platforms)\n}"}
{"input": "package main\n\nimport (\n\tgd \"github.com/shadowapex/godot-go/gdnative\"\n\t\"github.com/shadowapex/godot-go/godot\"\n\t\"log\"\n\t\"math/rand\"\n)\n\n\n\n\n\ntype Mob struct {\n\tgodot.RigidBody2D\n\tMinSpeed       gd.Real\n\tMaxSpeed       gd.Real\n\tanimatedSprite godot.AnimatedSpriteImplementer\n}\n\n\nfunc (m *Mob) X_Ready() {\n\tlog.Println(\"X_Ready called!\")\n\n\tanimatedSpritePath := gd.NewNodePath(\"AnimatedSprite\")\n\tanimatedSpriteNode := m.GetNode(animatedSpritePath)\n\tm.animatedSprite = animatedSpriteNode.(godot.AnimatedSpriteImplementer)\n\n\tmobTypes := []gd.String{\"walk\", \"swim\", \"fly\"}\n\n\tm.animatedSprite.SetAnimation(mobTypes[rand.Int()%len(mobTypes)])\n}\n\nfunc (m *Mob) X_OnVisibilityScreenExited() {\n\tm.QueueFree()\n}\n\n\nfunc (m *Mob) X_Process(delta gd.Double) {\n}\n\nfunc NewMob() godot.Class ", "output": "{\n\tmob := &Mob{}\n\n\treturn mob\n}"}
{"input": "package gwf\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n)\n\n\ntype Context struct {\n\tw http.ResponseWriter\n\tr *http.Request\n\n\tpath []string\n}\n\ntype Module interface {\n\tAction(*Context)\n}\n\ntype Dispatcher struct {\n\tmodules map[string]Module\n}\n\nfunc (c *Context) Request() *http.Request {\n\treturn c.r\n}\n\n\n\nfunc (c *Context) Init(w http.ResponseWriter, r *http.Request) {\n\tc.w, c.r = w, r\n\n\tpath := strings.Split(r.URL.Path, \"/\")\n\tc.path = path[1:]\n}\n\nfunc (c *Context) Path(index int) (string, bool) {\n\tif index < 0 || index >= len(c.path) {\n\t\treturn \"\", false\n\t} else {\n\t\treturn c.path[index], true\n\t}\n}\n\nfunc (c *Context) Depth() int {\n\treturn len(c.path)\n}\n\n\nfunc (d *Dispatcher) AddModule(name string, m Module) {\n\tif nil == d.modules {\n\t\td.modules = make(map[string]Module)\n\t}\n\td.modules[name] = m\n}\n\nfunc (d *Dispatcher) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\n\tvar c Context\n\tc.Init(w, r)\n\n\tif name, ok := c.Path(0); ok {\n\t\tif module, ok := d.modules[name]; ok && module != nil {\n\t\t\t(module).Action(&c)\n\t\t\treturn\n\t\t}\n\t}\n\tw.WriteHeader(http.StatusNotFound)\n}\n\nfunc (c *Context) Writer() http.ResponseWriter ", "output": "{\n\treturn c.w\n}"}
{"input": "package dockerfile\n\nimport (\n\t\"strings\"\n\n\td \"github.com/docker/docker/builder/dockerfile\"\n\t\"github.com/moby/buildkit/frontend/dockerfile/instructions\"\n)\n\ntype BuildArgs struct {\n\td.BuildArgs\n}\n\nfunc NewBuildArgs(args []string) *BuildArgs {\n\targsFromOptions := make(map[string]*string)\n\tfor _, a := range args {\n\t\ts := strings.SplitN(a, \"=\", 2)\n\t\tif len(s) == 1 {\n\t\t\targsFromOptions[s[0]] = nil\n\t\t} else {\n\t\t\targsFromOptions[s[0]] = &s[1]\n\t\t}\n\t}\n\treturn &BuildArgs{\n\t\tBuildArgs: *d.NewBuildArgs(argsFromOptions),\n\t}\n}\n\nfunc (b *BuildArgs) Clone() *BuildArgs {\n\tclone := b.BuildArgs.Clone()\n\treturn &BuildArgs{\n\t\tBuildArgs: *clone,\n\t}\n}\n\n\n\n\n\nfunc (b *BuildArgs) AddMetaArgs(metaArgs []instructions.ArgCommand) {\n\tfor _, marg := range metaArgs {\n\t\tfor _, arg := range marg.Args {\n\t\t\tv := arg.Value\n\t\t\tb.AddMetaArg(arg.Key, v)\n\t\t}\n\t}\n}\n\nfunc (b *BuildArgs) ReplacementEnvs(envs []string) []string ", "output": "{\n\tresultEnv := make([]string, len(envs))\n\tcopy(resultEnv, envs)\n\tfiltered := b.FilterAllowed(envs)\n\treturn append(resultEnv, filtered...)\n}"}
{"input": "package airac\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/jwkohnen/airac/proto\"\n)\n\nfunc TestProto(t *testing.T) {\n\tfor want := AIRAC(0); want < FromStringMust(\"9213\"); want++ {\n\t\tp := want.Proto()\n\t\tgot := FromProto(p)\n\t\tif want != got {\n\t\t\tt.Errorf(\"Want %v, got %x\", want, got)\n\t\t}\n\t}\n}\n\n\n\nfunc TestProtoOverflow(t *testing.T) ", "output": "{\n\twant := AIRAC(0)\n\tp := proto.AiracMessage{Airac19010110: math.MaxUint16 + 1}\n\tgot := FromProto(p)\n\tif got != want {\n\t\tt.Errorf(\"Want %s, got %s\", want, got)\n\t}\n}"}
{"input": "package matchers\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/atlassian/git-lob/Godeps/_workspace/src/github.com/onsi/gomega/format\"\n)\n\ntype BeEmptyMatcher struct {\n}\n\nfunc (matcher *BeEmptyMatcher) Match(actual interface{}) (success bool, err error) {\n\tlength, ok := lengthOf(actual)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"BeEmpty matcher expects a string/array/map/channel/slice.  Got:\\n%s\", format.Object(actual, 1))\n\t}\n\n\treturn length == 0, nil\n}\n\nfunc (matcher *BeEmptyMatcher) FailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, \"to be empty\")\n}\n\n\n\nfunc (matcher *BeEmptyMatcher) NegatedFailureMessage(actual interface{}) (message string) ", "output": "{\n\treturn format.Message(actual, \"not to be empty\")\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/emicklei/go-restful\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n)\n\n\n\n\n\n\n\ntype UserResource struct{}\n\n\n\nfunc (u UserResource) nop(request *restful.Request, response *restful.Response) {\n\tio.WriteString(response.ResponseWriter, \"this would be a normal response\")\n}\n\nfunc main() {\n\twsContainer := restful.NewContainer()\n\tu := UserResource{}\n\tu.RegisterTo(wsContainer)\n\n\twsContainer.Filter(wsContainer.OPTIONSFilter)\n\n\n\tlog.Printf(\"start listening on localhost:8080\")\n\tserver := &http.Server{Addr: \":8080\", Handler: wsContainer}\n\tlog.Fatal(server.ListenAndServe())\n}\n\nfunc (u UserResource) RegisterTo(container *restful.Container) ", "output": "{\n\tws := new(restful.WebService)\n\tws.\n\t\tPath(\"/users\").\n\t\tConsumes(\"*/*\").\n\t\tProduces(\"*/*\")\n\n\tws.Route(ws.GET(\"/{user-id}\").To(u.nop))\n\tws.Route(ws.POST(\"\").To(u.nop))\n\tws.Route(ws.PUT(\"/{user-id}\").To(u.nop))\n\tws.Route(ws.DELETE(\"/{user-id}\").To(u.nop))\n\n\tcontainer.Add(ws)\n}"}
{"input": "package region\n\nimport (\n\t\"github.com/sacloud/usacloud/pkg/cmd/cflag\"\n\t\"github.com/sacloud/usacloud/pkg/cmd/core\"\n)\n\nvar listCommand = &core.Command{\n\tName:               \"list\",\n\tAliases:            []string{\"ls\", \"find\", \"select\"},\n\tCategory:           \"basic\",\n\tOrder:              10,\n\tServiceFuncAltName: \"Find\",\n\tNoProgress:         true,\n\n\tColumnDefs: defaultColumnDefs,\n\n\tParameterInitializer: func() interface{} {\n\t\treturn newListParameter()\n\t},\n}\n\ntype listParameter struct {\n\tcflag.CommonParameter      `cli:\",squash\" mapconv:\"-\"`\n\tcflag.LimitOffsetParameter `cli:\",squash\" mapconv:\",squash\"`\n\tcflag.OutputParameter      `cli:\",squash\" mapconv:\"-\"`\n\n\tcflag.FilterByNamesParameter `cli:\",squash\" mapconv:\",omitempty,squash\"`\n}\n\n\n\nfunc init() {\n\tResource.AddCommand(listCommand)\n}\n\nfunc newListParameter() *listParameter ", "output": "{\n\treturn &listParameter{}\n}"}
{"input": "package labmeasure\n\ntype BodyStat struct {\n\tExamined         int\n\tBothEmpty        int\n\tDiffbotEmpty     int\n\tLabEmpty         int\n\tQualified        int\n\tAcceptable       int\n\tUnacceptable     int\n\tIncorrectRecords []PBodyRecord\n\tTotalRecall      float32\n\tTotalPrecision   float32\n\tConfiguration    Config\n}\n\nfunc (st BodyStat) GetIncorrectRecords() interface{} {\n\treturn st.IncorrectRecords\n}\n\nfunc (st BodyStat) Correct() int {\n\treturn st.Acceptable + st.BothEmpty\n}\n\nfunc (st BodyStat) Incorrect() int {\n\treturn st.Unacceptable + st.DiffbotEmpty + st.LabEmpty\n}\n\nfunc (st BodyStat) Accuracy() float32 {\n\treturn float32(st.Correct()) / float32(st.Examined)\n}\n\nfunc (st BodyStat) AverageRecall() float32 {\n\treturn float32(st.TotalRecall) / float32(st.Qualified)\n}\n\n\n\nfunc (st BodyStat) PrecisionThreshold() float32 {\n\treturn st.Configuration.PrecisionThreshold\n}\n\nfunc (st BodyStat) RecallThreshold() float32 {\n\treturn st.Configuration.RecallThreshold\n}\n\nfunc (st BodyStat) AveragePrecision() float32 ", "output": "{\n\treturn float32(st.TotalPrecision) / float32(st.Qualified)\n}"}
{"input": "package iso20022\n\n\ntype OrderStatus4Choice struct {\n\n\tStatus *OrderStatus4Code `xml:\"Sts\"`\n\n\tCancelled *CancelledStatusReason16 `xml:\"Canc\"`\n\n\tConditionallyAccepted *ConditionallyAcceptedStatus3Choice `xml:\"CondlyAccptd\"`\n\n\tRejected []*RejectedStatus9 `xml:\"Rjctd\"`\n\n\tSuspended *SuspendedStatusReason4Choice `xml:\"Sspd\"`\n\n\tInRepair *InRepairStatusReason4Choice `xml:\"InRpr\"`\n\n\tPartiallySettled *PartiallySettledStatus10 `xml:\"PrtlySttld\"`\n}\n\nfunc (o *OrderStatus4Choice) SetStatus(value string) {\n\to.Status = (*OrderStatus4Code)(&value)\n}\n\nfunc (o *OrderStatus4Choice) AddCancelled() *CancelledStatusReason16 {\n\to.Cancelled = new(CancelledStatusReason16)\n\treturn o.Cancelled\n}\n\nfunc (o *OrderStatus4Choice) AddConditionallyAccepted() *ConditionallyAcceptedStatus3Choice {\n\to.ConditionallyAccepted = new(ConditionallyAcceptedStatus3Choice)\n\treturn o.ConditionallyAccepted\n}\n\nfunc (o *OrderStatus4Choice) AddRejected() *RejectedStatus9 {\n\tnewValue := new(RejectedStatus9)\n\to.Rejected = append(o.Rejected, newValue)\n\treturn newValue\n}\n\n\n\nfunc (o *OrderStatus4Choice) AddInRepair() *InRepairStatusReason4Choice {\n\to.InRepair = new(InRepairStatusReason4Choice)\n\treturn o.InRepair\n}\n\nfunc (o *OrderStatus4Choice) AddPartiallySettled() *PartiallySettledStatus10 {\n\to.PartiallySettled = new(PartiallySettledStatus10)\n\treturn o.PartiallySettled\n}\n\nfunc (o *OrderStatus4Choice) AddSuspended() *SuspendedStatusReason4Choice ", "output": "{\n\to.Suspended = new(SuspendedStatusReason4Choice)\n\treturn o.Suspended\n}"}
{"input": "package perfcounters\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n\n\ntype CountPerTimeInterval32 struct {\n\tlastCount    int32\n\tlastTime     *time.Time\n\tcurrentCount int32\n\tmu           sync.Mutex\n}\n\nfunc NewCountPerTimeInterval32() *CountPerTimeInterval32 {\n\n\treturn &CountPerTimeInterval32{\n\t\tlastTime:     nil,\n\t\tlastCount:    0,\n\t\tcurrentCount: 0,\n\t}\n}\n\nfunc (self *CountPerTimeInterval32) Increment() {\n\tself.Add(1)\n}\n\nfunc (self *CountPerTimeInterval32) Add(value int32) {\n\tself.mu.Lock()\n\tdefer self.mu.Unlock()\n\n\tself.currentCount += value\n\n\tif self.lastTime == nil {\n\t\tnow := time.Now()\n\t\tself.lastTime = &now\n\t}\n}\n\nfunc (self *CountPerTimeInterval32) CalculatedValue() float64 {\n\tself.mu.Lock()\n\tdefer self.mu.Unlock()\n\n\tcurrentTime := time.Now()\n\n\tif self.lastTime == nil {\n\t\tself.lastTime = &currentTime\n\t\treturn 0\n\t}\n\n\tlastTime := *self.lastTime\n\tlastCount := self.lastCount\n\tcurrentCount := self.currentCount\n\n\tcalculatedValue := float64(int64(currentCount-lastCount) / (currentTime.Sub(lastTime).Nanoseconds() / 1e6))\n\n\tself.lastTime = &currentTime\n\tself.lastCount = currentCount\n\n\treturn calculatedValue\n}\n\n\n\nfunc (self *CountPerTimeInterval32) String() string ", "output": "{\n\treturn fmt.Sprintf(\"%.3f\", self.CalculatedValue())\n}"}
{"input": "package trie\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAddContainsWith128CharAlphabet(t *testing.T) {\n\tkey := \"hello\"\n\n\tset := NewTrieSet('A', 128)\n\n\tset.Add(key)\n\n\twant := true\n\tgot := set.Contains(key)\n\n\tif want != got {\n\t\tt.Errorf(\"Want %#v got %#v\", want, got)\n\t}\n}\n\n\n\nfunc TestAddDeletesWith128CharAlphabet(t *testing.T) ", "output": "{\n\tkey := \"hello\"\n\n\tset := NewTrieSet('A', 128)\n\n\tset.Add(key)\n\n\twant := true\n\tgot := set.Contains(key)\n\n\tif want != got {\n\t\tt.Errorf(\"Want %#v got %#v\", want, got)\n\t}\n\n\tset.Delete(key)\n\n\twant = false\n\tgot = set.Contains(key)\n\n\tif want != got {\n\t\tt.Errorf(\"Want %#v got %#v\", want, got)\n\t}\n}"}
{"input": "package system \n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\nfunc MkdirAllWithACL(path string, perm os.FileMode, sddl string) error {\n\treturn os.MkdirAll(path, perm)\n}\n\n\n\nfunc MkdirAll(path string, perm os.FileMode) error {\n\treturn os.MkdirAll(path, perm)\n}\n\n\nfunc IsAbs(path string) bool {\n\treturn filepath.IsAbs(path)\n}\n\n\n\n\n\n\n\n\n\nfunc CreateSequential(name string) (*os.File, error) {\n\treturn os.Create(name)\n}\n\n\n\n\n\nfunc OpenSequential(name string) (*os.File, error) {\n\treturn os.Open(name)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc TempFileSequential(dir, prefix string) (f *os.File, err error) {\n\treturn ioutil.TempFile(dir, prefix)\n}\n\nfunc OpenFileSequential(name string, flag int, perm os.FileMode) (*os.File, error) ", "output": "{\n\treturn os.OpenFile(name, flag, perm)\n}"}
{"input": "package giraffe\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst (\n\tContentBinary = \"application/octet-stream\"\n\tContentJSON = \"application/json\"\n\tContentJSONP = \"application/javascript\"\n\tContentText = \"text/plain\"\n\tContentHTML = \"text/html\"\n\n\tContentType = \"Content-Type\"\n\tContentDefaultCharset = \"UTF-8\"\n)\n\nfunc setContentType(writer http.ResponseWriter, contentType string) {\n\tif writer.Header().Get(ContentType) != \"\" {\n\t\treturn\n\t}\n\n\tcontentType = fmt.Sprintf(\"%s; charset=%s\", contentType, ContentDefaultCharset)\n\twriter.Header().Set(ContentType, contentType)\n}\n\n\n\nfunc ext(dir, path string) (string, string, error) {\n\trel, err := filepath.Rel(dir, path)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\text := \"\"\n\tif strings.Index(rel, \".\") != -1 {\n\t\text = filepath.Ext(rel)\n\t}\n\treturn rel, ext, nil\n}\n\nfunc name(dir, ext string) string ", "output": "{\n\tname := (dir[0 : len(dir)-len(ext)])\n\treturn name\n}"}
{"input": "package outputs\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/lfkeitel/spartan/event\"\n\n\ttomb \"gopkg.in/tomb.v2\"\n)\n\n\n\n\ntype OutputController struct {\n\tstart     Output\n\tbatchSize int\n\tt         tomb.Tomb\n\tin        <-chan *event.Event\n\tout       chan<- *event.Event\n}\n\n\n\nfunc NewOutputController(start Output, batchSize int) *OutputController {\n\treturn &OutputController{\n\t\tstart:     start,\n\t\tbatchSize: batchSize,\n\t}\n}\n\n\n\n\nfunc (o *OutputController) Start(in chan *event.Event) error {\n\to.in = in\n\to.t.Go(o.run)\n\treturn nil\n}\n\n\n\n\n\n\nfunc (o *OutputController) run() error {\n\tfmt.Println(\"Output Pipeline started\")\n\tfor {\n\t\tselect {\n\t\tcase <-o.t.Dying():\n\t\t\treturn nil\n\t\tdefault:\n\t\t}\n\n\t\tcurrentBatch := 0\n\t\tbatch := make([]*event.Event, o.batchSize)\n\t\tstopping := false\n\n\tCURRENT:\n\t\tfor currentBatch < o.batchSize {\n\t\t\tselect {\n\t\t\tcase event := <-o.in:\n\t\t\t\tbatch[currentBatch] = event\n\t\t\t\tcurrentBatch++\n\t\t\tcase <-o.t.Dying():\n\t\t\t\tstopping = true\n\t\t\t\tbreak CURRENT\n\t\t\t}\n\t\t}\n\n\t\tfmt.Println(\"Processing batch\")\n\t\to.start.Run(batch)\n\n\t\tif stopping {\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n\nfunc checkOptionsMap(o map[string]interface{}) map[string]interface{} {\n\tif o == nil {\n\t\to = make(map[string]interface{})\n\t}\n\treturn o\n}\n\nfunc (o *OutputController) Close() error ", "output": "{\n\to.t.Kill(nil)\n\treturn o.t.Wait()\n}"}
{"input": "package ovnmodel\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/skydive-project/skydive/graffiti/getter\"\n\t\"github.com/skydive-project/skydive/graffiti/graph\"\n)\n\n\n\n\ntype LoadBalancerHealthCheck struct {\n\tUUID        string            `ovsdb:\"_uuid\" json:\",omitempty\" `\n\tExternalIDs map[string]string `ovsdb:\"external_ids\" json:\",omitempty\" `\n\tOptions     map[string]string `ovsdb:\"options\" json:\",omitempty\" `\n\tVip         string            `ovsdb:\"vip\" json:\",omitempty\" `\n\n\tExternalIDsMeta graph.Metadata `json:\",omitempty\" field:\"Metadata\"`\n\tOptionsMeta     graph.Metadata `json:\",omitempty\" field:\"Metadata\"`\n}\n\nfunc (t *LoadBalancerHealthCheck) Metadata() graph.Metadata {\n\tt.ExternalIDsMeta = graph.NormalizeValue(t.ExternalIDs).(map[string]interface{})\n\tt.OptionsMeta = graph.NormalizeValue(t.Options).(map[string]interface{})\n\n\treturn graph.Metadata{\n\t\t\"Type\":    \"LoadBalancerHealthCheck\",\n\t\t\"Manager\": \"ovn\",\n\t\t\"UUID\":    t.GetUUID(),\n\t\t\"Name\":    t.GetName(),\n\t\t\"OVN\":     t,\n\t}\n}\n\nfunc (t *LoadBalancerHealthCheck) GetUUID() string {\n\treturn t.UUID\n}\n\n\n\n\nfunc LoadBalancerHealthCheckDecoder(raw json.RawMessage) (getter.Getter, error) {\n\tvar t LoadBalancerHealthCheck\n\tif err := json.Unmarshal(raw, &t); err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to unmarshal LoadBalancerHealthCheck metadata %s: %s\", string(raw), err)\n\t}\n\treturn &t, nil\n}\n\nfunc (t *LoadBalancerHealthCheck) GetName() string ", "output": "{\n\tif name := t.UUID; name != \"\" {\n\t\treturn name\n\t}\n\treturn t.GetUUID()\n}"}
{"input": "package gofaker\n\nimport \"fmt\"\n\nfunc ExampleCat_Name() {\n\tf, _ := NewFaker(\"en\")\n\tf.Reset()\n\tfmt.Println(f.Cat.Name())\n}\n\n\n\nfunc ExampleCat_Registry() {\n\tf, _ := NewFaker(\"en\")\n\tf.Reset()\n\tfmt.Println(f.Cat.Registry())\n}\n\nfunc ExampleCat_Breed() ", "output": "{\n\tf, _ := NewFaker(\"en\")\n\tf.Reset()\n\tfmt.Println(f.Cat.Breed())\n}"}
{"input": "package policy\n\nimport original \"github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2015-10-01-preview/policy\"\n\ntype AssignmentsClient = original.AssignmentsClient\n\nconst (\n\tDefaultBaseURI = original.DefaultBaseURI\n)\n\ntype BaseClient = original.BaseClient\ntype DefinitionsClient = original.DefinitionsClient\ntype Type = original.Type\n\nconst (\n\tBuiltIn      Type = original.BuiltIn\n\tCustom       Type = original.Custom\n\tNotSpecified Type = original.NotSpecified\n)\n\ntype Assignment = original.Assignment\ntype AssignmentListResult = original.AssignmentListResult\ntype AssignmentListResultIterator = original.AssignmentListResultIterator\ntype AssignmentListResultPage = original.AssignmentListResultPage\ntype AssignmentProperties = original.AssignmentProperties\ntype Definition = original.Definition\ntype DefinitionListResult = original.DefinitionListResult\ntype DefinitionListResultIterator = original.DefinitionListResultIterator\ntype DefinitionListResultPage = original.DefinitionListResultPage\ntype DefinitionProperties = original.DefinitionProperties\n\nfunc NewAssignmentsClient(subscriptionID string) AssignmentsClient {\n\treturn original.NewAssignmentsClient(subscriptionID)\n}\nfunc NewAssignmentsClientWithBaseURI(baseURI string, subscriptionID string) AssignmentsClient {\n\treturn original.NewAssignmentsClientWithBaseURI(baseURI, subscriptionID)\n}\nfunc New(subscriptionID string) BaseClient {\n\treturn original.New(subscriptionID)\n}\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient {\n\treturn original.NewWithBaseURI(baseURI, subscriptionID)\n}\nfunc NewDefinitionsClient(subscriptionID string) DefinitionsClient {\n\treturn original.NewDefinitionsClient(subscriptionID)\n}\nfunc NewDefinitionsClientWithBaseURI(baseURI string, subscriptionID string) DefinitionsClient {\n\treturn original.NewDefinitionsClientWithBaseURI(baseURI, subscriptionID)\n}\nfunc PossibleTypeValues() []Type {\n\treturn original.PossibleTypeValues()\n}\n\nfunc Version() string {\n\treturn original.Version()\n}\n\nfunc UserAgent() string ", "output": "{\n\treturn original.UserAgent() + \" profiles/2017-03-09\"\n}"}
{"input": "package token\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestBase64(t *testing.T) {\n\ttestHandler(t, NewBase64Handler())\n}\n\nfunc TestMemory(t *testing.T) {\n\ttestHandler(t, NewMemoryHandler())\n}\n\nfunc TestRedis(t *testing.T) {\n\ttestHandler(t, newRedisHandler(&memRedisStore{data: make(map[string][]byte)}))\n}\n\n\n\ntype memRedisStore struct {\n\tdata map[string][]byte\n}\n\nfunc (m *memRedisStore) Set(key string, value []byte) error {\n\tm.data[key] = value\n\treturn nil\n}\n\nfunc (m *memRedisStore) Get(key string) ([]byte, error) {\n\treturn m.data[key], nil\n}\n\nfunc testHandler(t *testing.T, h Handler) ", "output": "{\n\texpected := SubscriptionData{\n\t\tUserId:    \"uid\",\n\t\tExpiresAt: time.Now().Add(time.Second),\n\t\tLevel:     \"all\",\n\t\tPlatform:  \"mobile\",\n\t}\n\ttoken, err := h.Encrypt(expected)\n\tif err != nil {\n\t\tt.Errorf(\"Encrypt failed %v\", err)\n\t}\n\tsd, err := h.Decrypt(token)\n\tif err != nil {\n\t\tt.Errorf(\"Decrypt failed %v\", err)\n\t}\n\tif !sd.Equal(expected) {\n\t\tt.Errorf(\"%v != %v, they should be equal\", sd, expected)\n\t}\n}"}
{"input": "package backingstore\n\nimport (\n\t\"github.com/gostor/gotgt/pkg/api\"\n\t\"github.com/gostor/gotgt/pkg/scsi\"\n)\n\nfunc init() {\n\tscsi.RegisterBackingStore(\"null\", newNull)\n}\n\ntype NullBackingStore struct {\n\tscsi.BaseBackingStore\n}\n\nfunc newNull() (api.BackingStore, error) {\n\treturn &NullBackingStore{\n\t\tBaseBackingStore: scsi.BaseBackingStore{\n\t\t\tName:            \"null\",\n\t\t\tDataSize:        0,\n\t\t\tOflagsSupported: 0,\n\t\t},\n\t}, nil\n}\n\nfunc (bs *NullBackingStore) Open(dev *api.SCSILu, path string) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Close(dev *api.SCSILu) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Init(dev *api.SCSILu, Opts string) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Exit(dev *api.SCSILu) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) Size(dev *api.SCSILu) uint64 {\n\treturn 0\n}\n\nfunc (bs *NullBackingStore) Read(offset, tl int64) ([]byte, error) {\n\treturn nil, nil\n}\n\nfunc (bs *NullBackingStore) Write(wbuf []byte, offset int64) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) DataSync(offset, tl int64) error {\n\treturn nil\n}\n\n\n\nfunc (bs *NullBackingStore) Unmap([]api.UnmapBlockDescriptor) error {\n\treturn nil\n}\n\nfunc (bs *NullBackingStore) DataAdvise(offset, length int64, advise uint32) error ", "output": "{\n\treturn nil\n}"}
{"input": "package users\n\n\n\n\n\nfunc (user *User) GetName() string {\n\treturn user.name\n}\n\n\nfunc (user *User) GetSurname() string {\n\treturn user.surname\n}\n\n\nfunc (user *User) GetID() int64 {\n\treturn user.id\n}\n\n\n\nfunc (admin *AdminUser) Create(name, surname string) *AdminUser {\n\treturn &AdminUser{User:User{name:name, surname:surname}, admin:true}\n}\n\nfunc (admin *AdminUser) IsAdmin() bool {\n\treturn admin.admin\n}\n\n\n\n\n\nfunc (users *Users) Append(user *User) {\n\tusers.index += 1\n\tuser.id = users.index\n\tusers.users = append(users.users, user)\n}\n\n\nfunc (users *Users) GetIndex() int64 {\n\treturn users.index\n}\n\nfunc (users *Users) GetUsers() []*User {\n\treturn users.users\n}\n\nfunc (user *User) Create(name, surname string) *User ", "output": "{\n\treturn &User{name: name, surname:surname}\n}"}
{"input": "package ldap\n\ntype Control interface {\n\tEncode() interface{}\n\tGetControlType() string\n\tString() string\n}\n\n\n\nvar NeverDerefAliases int = 0\n\nfunc NewSearchRequest(_ string, _ int, _ int, _ int, _ int, _ bool, _ string, _ []string, _ []Control) *SearchRequest {\n\treturn nil\n}\n\nvar ScopeWholeSubtree int = 0\n\ntype SearchRequest struct {\n\tBaseDN       string\n\tScope        int\n\tDerefAliases int\n\tSizeLimit    int\n\tTimeLimit    int\n\tTypesOnly    bool\n\tFilter       string\n\tAttributes   []string\n\tControls     []Control\n}\n\nfunc EscapeFilter(_ string) string ", "output": "{\n\treturn \"\"\n}"}
{"input": "package common\n\n\n\nfunc NewConfigGroup() *ConfigGroup ", "output": "{\n\treturn &ConfigGroup{\n\t\tGroups:   make(map[string]*ConfigGroup),\n\t\tValues:   make(map[string]*ConfigValue),\n\t\tPolicies: make(map[string]*ConfigPolicy),\n\t}\n}"}
{"input": "package main\n\nimport \"testing\"\n\nfunc TestValidateURL(t *testing.T) {\n\tif !validateURL(\"https://github.com/chadev/Chadev_ircbot\") {\n\t\tt.Error(\"failed to validate proper URL: https://github.com/chadev/Chadev_ircbot\")\n\t}\n}\n\n\n\nfunc TestGetIssueURL(t *testing.T) {\n\tURL, err := getIssueURL(\"Chadev_ircbot\")\n\tif err != nil {\n\t\tt.Errorf(\"failed fetching GitHub Issue URL: %s\\n\", err.Error())\n\t}\n\n\tt.Logf(\"returned URL: %s\\n\", URL)\n\tif !validateGitHubURL(URL) {\n\t\tt.Error(\"the URL came back as invalid\")\n\t}\n}\n\nfunc TestGetIssueIDURL(t *testing.T) {\n\tURL, err := getIssueURL(\"Chadev_ircbot\")\n\tif err != nil {\n\t\tt.Errorf(\"failed fetching GitHub Issue URL: %s\\n\", err.Error())\n\t}\n\n\tt.Logf(\"returned URL: %s\\n\", URL)\n\tif !validateGitHubURL(URL) {\n\t\tt.Error(\"the issue queue URL came back as invalid\")\n\t}\n\n\tURL, err = getIssueIDURL(URL, \"#1\")\n\tif err != nil {\n\t\tt.Errorf(\"failed fetching GitHub Issue URL: %s\\n\", err.Error())\n\t}\n\n\tt.Logf(\"returned URL: %s\\n\", URL)\n\tif !validateGitHubURL(URL) {\n\t\tt.Errorf(\"the issue URL came back as invalid\")\n\t}\n}\n\nfunc TestGetGitHubURL(t *testing.T) ", "output": "{\n\tURL, err := getGitHubURL(\"Chadev_ircbot\")\n\tif err != nil {\n\t\tt.Errorf(\"failed fetching GitHub repo URL: %s\\n\", err.Error())\n\t}\n\n\tt.Logf(\"returned URL: %s\\n\", URL)\n\tif !validateGitHubURL(URL) {\n\t\tt.Error(\"the URL came back as invalid\")\n\t}\n}"}
{"input": "package splunk\n\nimport (\n        \"fmt\"\n        \"net/url\"\n)\n\n\n\nfunc (conn SplunkConnection) InstallApp(path string, update bool) (string, error) ", "output": "{\n        data := make(url.Values)\n        data.Add(\"name\", path)\n\n        update_app := \"false\"\n        if (update == true) {\n                update_app = \"true\"\n        }\n\n        data.Add(\"update\", update_app)\n        response, err := conn.httpPost(fmt.Sprintf(\"%s/services/apps/appinstall/\", conn.BaseURL), &data)\n        return response, err\n}"}
{"input": "package service\n\nimport (\n\t\"encoding/json\"\n\t\"toutGin/app/common\"\n\t\"toutGin/app/dao\"\n\t\"toutGin/app/model\"\n)\n\ntype UserService struct {\n\tUD *dao.UserDao\n}\n\nfunc (s *UserService) Add(data map[string]interface{}) uint {\n\ts.UD = new(dao.UserDao)\n\tparams := common.CopyParams([]string{\"name\", \"password\"}, data)\n\tjson.Unmarshal(common.MakeJson(params), &s.UD.User)\n\ts.UD.Add()\n\treturn s.UD.User.Id\n}\n\nfunc (s *UserService) GetInfo(id uint) model.User {\n\ts.UD = new(dao.UserDao)\n\ts.UD.User.Id = id\n\ts.UD.GetOne()\n\treturn s.UD.User\n}\n\n\n\nfunc (s *UserService) Delete(id uint) {\n\ts.UD = new(dao.UserDao)\n\ts.UD.User.Id = id\n\ts.UD.Delete()\n}\n\nfunc (s *UserService) GetList(data map[string]interface{}) []model.User {\n\ts.UD = new(dao.UserDao)\n\ts.UD.GetAll(data)\n\treturn s.UD.UserList\n}\n\nfunc (s *UserService) Update(data map[string]interface{}) ", "output": "{\n\ts.UD = new(dao.UserDao)\n\tparams := common.CopyParams([]string{\"id\", \"name\", \"password\"}, data)\n\ts.UD.Update(params)\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\n\ntype Configuration struct {\n\tLicense   string     `json:\"license\"`\n\tEndpoints []Endpoint `json:\"endpoints\"`\n}\n\n\ntype Endpoint struct {\n\tEpLicense string `json:\"eplicense\"` \n\tName      string `json:\"name\"`\n\tAddr      string `json:\"addr\"`\n\tPassword  string `json:\"password\"`\n\tDB        int    `json:\"db\"`\n}\n\n\n\n\nfunc LoadConfig(configFile string) (Configuration, error) ", "output": "{\n\tf, err := ioutil.ReadFile(configFile)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tvar config Configuration\n\terr = json.Unmarshal(f, &config)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn config, nil\n}"}
{"input": "package authorizationutil\n\nimport (\n\trbacv1 \"k8s.io/api/rbac/v1\"\n\t\"k8s.io/apiserver/pkg/authentication/serviceaccount\"\n)\n\n\n\nfunc RBACSubjectsToUsersAndGroups(subjects []rbacv1.Subject, defaultNamespace string) (users []string, groups []string) {\n\tfor _, subject := range subjects {\n\n\t\tswitch {\n\t\tcase subject.APIGroup == rbacv1.GroupName && subject.Kind == rbacv1.GroupKind:\n\t\t\tgroups = append(groups, subject.Name)\n\t\tcase subject.APIGroup == rbacv1.GroupName && subject.Kind == rbacv1.UserKind:\n\t\t\tusers = append(users, subject.Name)\n\t\tcase subject.APIGroup == \"\" && subject.Kind == rbacv1.ServiceAccountKind:\n\t\t\tns := defaultNamespace\n\t\t\tif len(subject.Namespace) > 0 {\n\t\t\t\tns = subject.Namespace\n\t\t\t}\n\t\t\tif len(ns) > 0 {\n\t\t\t\tname := serviceaccount.MakeUsername(ns, subject.Name)\n\t\t\t\tusers = append(users, name)\n\t\t\t} else {\n\t\t\t}\n\t\tdefault:\n\t\t}\n\t}\n\n\treturn users, groups\n}\n\nfunc BuildRBACSubjects(users, groups []string) []rbacv1.Subject ", "output": "{\n\tsubjects := []rbacv1.Subject{}\n\n\tfor _, user := range users {\n\t\tsaNamespace, saName, err := serviceaccount.SplitUsername(user)\n\t\tif err == nil {\n\t\t\tsubjects = append(subjects, rbacv1.Subject{Kind: rbacv1.ServiceAccountKind, Namespace: saNamespace, Name: saName})\n\t\t} else {\n\t\t\tsubjects = append(subjects, rbacv1.Subject{Kind: rbacv1.UserKind, APIGroup: rbacv1.GroupName, Name: user})\n\t\t}\n\t}\n\n\tfor _, group := range groups {\n\t\tsubjects = append(subjects, rbacv1.Subject{Kind: rbacv1.GroupKind, APIGroup: rbacv1.GroupName, Name: group})\n\t}\n\n\treturn subjects\n}"}
{"input": "package models\n\n\n\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\n\n\ntype EndpointHealthStatus string\n\nconst (\n\n\tEndpointHealthStatusOK EndpointHealthStatus = \"OK\"\n\n\tEndpointHealthStatusBootstrap EndpointHealthStatus = \"Bootstrap\"\n\n\tEndpointHealthStatusPending EndpointHealthStatus = \"Pending\"\n\n\tEndpointHealthStatusWarning EndpointHealthStatus = \"Warning\"\n\n\tEndpointHealthStatusFailure EndpointHealthStatus = \"Failure\"\n\n\tEndpointHealthStatusDisabled EndpointHealthStatus = \"Disabled\"\n)\n\n\nvar endpointHealthStatusEnum []interface{}\n\nfunc init() {\n\tvar res []EndpointHealthStatus\n\tif err := json.Unmarshal([]byte(`[\"OK\",\"Bootstrap\",\"Pending\",\"Warning\",\"Failure\",\"Disabled\"]`), &res); err != nil {\n\t\tpanic(err)\n\t}\n\tfor _, v := range res {\n\t\tendpointHealthStatusEnum = append(endpointHealthStatusEnum, v)\n\t}\n}\n\n\n\n\nfunc (m EndpointHealthStatus) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateEndpointHealthStatusEnum(\"\", \"body\", m); err != nil {\n\t\treturn err\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m EndpointHealthStatus) validateEndpointHealthStatusEnum(path, location string, value EndpointHealthStatus) error ", "output": "{\n\tif err := validate.EnumCase(path, location, value, endpointHealthStatusEnum, true); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package commands\nimport \"fmt\"\nimport . \"github.com/popcorp/doenv/lib\"\n\n\n\nfunc GuessCommand(DropletName string) ", "output": "{\n\tfmt.Printf(\"Unknown command %s .. Trying some magic trick\\n\", DropletName)\n\td, _ := DropletByName(DropletName)\n\tif d == nil {\n\t\trestoreDroplet(DropletName, DropletName)\n\t}\n\tif d.Status == \"off\" {\n\t\tfmt.Println(\"Droplet %s is powered off, starting it ...\\n\", DropletName)\n\t\taction, _, err := GetClient().DropletActions.PowerOn(d.ID)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tWaitAction(action.ID)\n\t\td, _, _ = GetClient().Droplets.Get(d.ID)\n\t}\n\n\tif d.Status == \"active\" {\n\t\tfmt.Println(\"Droplet is running, let's hack into it ! :D\")\n\t\tSshDroplet(d)\n\t}\n}"}
{"input": "package mongo\n\nimport (\n\t\"github.com/mongoeye/mongoeye/tests\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"gopkg.in/mgo.v2\"\n\t\"testing\"\n)\n\nfunc TestConnect(t *testing.T) {\n\tsession, err := Connect(tests.TestDbUri, mgo.Secondary)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tassert.IsType(t, &mgo.Session{}, session)\n}\n\n\n\nfunc TestCollection(t *testing.T) ", "output": "{\n\tc := Collection(tests.TestDbSession, \"_test\", \"_test\")\n\tassert.IsType(t, &mgo.Collection{}, c)\n\tc.DropCollection()\n}"}
{"input": "package sol\n\n\ntype Operator interface {\n\tWrap(string) string \n}\n\n\nfunc Function(name string, col Columnar) ColumnElem {\n\treturn col.Column().AddOperator(FuncClause{Name: name})\n}\n\n\nfunc Avg(col Columnar) ColumnElem {\n\treturn Function(AVG, col)\n}\n\n\nfunc Count(col Columnar) ColumnElem {\n\treturn Function(COUNT, col)\n}\n\n\n\n\n\n\nfunc DatePart(part string, col Columnar) ColumnElem {\n\treturn col.Column().AddOperator(\n\t\tFuncClause{Name: DATEPART},\n\t).AddOperator(\n\t\tArrayClause{clauses: []Clause{String(part)}, post: true, sep: \", \"},\n\t)\n}\n\n\nfunc Max(col Columnar) ColumnElem {\n\treturn Function(MAX, col)\n}\n\n\nfunc Min(col Columnar) ColumnElem {\n\treturn Function(MIN, col)\n}\n\n\nfunc StdDev(col Columnar) ColumnElem {\n\treturn Function(STDDEV, col)\n}\n\n\nfunc Sum(col Columnar) ColumnElem {\n\treturn Function(SUM, col)\n}\n\n\nfunc Variance(col Columnar) ColumnElem {\n\treturn Function(VARIANCE, col)\n}\n\nfunc Date(col Columnar) ColumnElem ", "output": "{\n\treturn Function(DATE, col)\n}"}
{"input": "package ctx\n\nimport \"fmt\"\n\ntype repoRef struct {\n\tOwner string\n\tName  string\n}\n\nfunc (r repoRef) String() string {\n\treturn fmt.Sprintf(\"%s/%s\", r.Owner, r.Name)\n}\n\n\n\nfunc (c *Context) SetRepo(owner, repo string) {\n\tc.Repo = repoRef{\n\t\tOwner: owner,\n\t\tName:  repo,\n\t}\n}\n\nfunc (r repoRef) IsEmpty() bool ", "output": "{\n\treturn r.Owner == \"\" || r.Name == \"\"\n}"}
{"input": "package post\n\nimport \"github.com/barnex/bruteray/imagef\"\n\ntype Params struct {\n\tGaussian BloomParams\n\tAiry     BloomParams\n\tStar     BloomParams\n}\n\ntype BloomParams struct {\n\tRadius    float64\n\tAmplitude float64\n\tThreshold float64\n}\n\nfunc (p *Params) ApplyTo(img imagef.Image, pixelSize float64) imagef.Image {\n\tif b := p.Gaussian; b.Radius != 0 {\n\t\timg = ApplyGaussianBloom(img, pixelSize, b.Radius, b.Amplitude, b.Threshold)\n\t}\n\tif b := p.Airy; b.Radius != 0 {\n\t\timg = ApplyAiryBloom(img, pixelSize, b.Radius, b.Amplitude, b.Threshold)\n\t}\n\tif b := p.Star; b.Radius != 0 {\n\t\timg = ApplyStarBloom(img, pixelSize, b.Radius, b.Amplitude, b.Threshold)\n\t}\n\treturn img\n}\n\n\n\nfunc ApplyAiryBloom(img imagef.Image, pixelSize, radius, amplitude, threshold float64) imagef.Image {\n\twidthPix := radius / pixelSize\n\tnumPix := int(8*widthPix) + 1\n\tK := Airy(numPix, widthPix)\n\timg2 := img.Copy()\n\tAddConvolution(img2, img, K, amplitude, threshold)\n\treturn img2\n}\n\nfunc ApplyStarBloom(img imagef.Image, pixelSize, radius, amplitude, threshold float64) imagef.Image {\n\twidthPix := radius / pixelSize\n\tnumPix := int(widthPix)\n\tK := starKernel(numPix)\n\timg2 := img.Copy()\n\tAddConvolution(img2, img, K, amplitude, threshold)\n\treturn img2\n}\n\nfunc ApplyGaussianBloom(img imagef.Image, pixelSize, radius, amplitude, threshold float64) imagef.Image ", "output": "{\n\twidthPix := radius / pixelSize\n\tnumPix := int(5*widthPix) + 1\n\tK := Gaussian(numPix, widthPix)\n\timg2 := img.Copy()\n\tAddConvolution(img2, img, K, amplitude, threshold)\n\treturn img2\n}"}
{"input": "package v1alpha1\n\nimport (\n\tv1alpha1 \"kubedb.dev/apimachinery/apis/catalog/v1alpha1\"\n\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/client-go/tools/cache\"\n)\n\n\n\ntype MariaDBVersionLister interface {\n\tList(selector labels.Selector) (ret []*v1alpha1.MariaDBVersion, err error)\n\tGet(name string) (*v1alpha1.MariaDBVersion, error)\n\tMariaDBVersionListerExpansion\n}\n\n\ntype mariaDBVersionLister struct {\n\tindexer cache.Indexer\n}\n\n\nfunc NewMariaDBVersionLister(indexer cache.Indexer) MariaDBVersionLister {\n\treturn &mariaDBVersionLister{indexer: indexer}\n}\n\n\n\n\n\nfunc (s *mariaDBVersionLister) Get(name string) (*v1alpha1.MariaDBVersion, error) {\n\tobj, exists, err := s.indexer.GetByKey(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !exists {\n\t\treturn nil, errors.NewNotFound(v1alpha1.Resource(\"mariadbversion\"), name)\n\t}\n\treturn obj.(*v1alpha1.MariaDBVersion), nil\n}\n\nfunc (s *mariaDBVersionLister) List(selector labels.Selector) (ret []*v1alpha1.MariaDBVersion, err error) ", "output": "{\n\terr = cache.ListAll(s.indexer, selector, func(m interface{}) {\n\t\tret = append(ret, m.(*v1alpha1.MariaDBVersion))\n\t})\n\treturn ret, err\n}"}
{"input": "package pgsql\n\nimport (\n\t\"database/sql\"\n\t\"time\"\n\n\t\"github.com/coreos/clair/pkg/commonerr\"\n)\n\n\nfunc (pgSQL *pgSQL) InsertKeyValue(key, value string) (err error) {\n\tif key == \"\" || value == \"\" {\n\t\tlog.Warning(\"could not insert a flag which has an empty name or value\")\n\t\treturn commonerr.NewBadRequestError(\"could not insert a flag which has an empty name or value\")\n\t}\n\n\tdefer observeQueryTime(\"InsertKeyValue\", \"all\", time.Now())\n\n\n\tfor {\n\t\tr, err := pgSQL.Exec(updateKeyValue, value, key)\n\t\tif err != nil {\n\t\t\treturn handleError(\"updateKeyValue\", err)\n\t\t}\n\t\tif n, _ := r.RowsAffected(); n > 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\t_, err = pgSQL.Exec(insertKeyValue, key, value)\n\t\tif err != nil {\n\t\t\tif isErrUniqueViolation(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn handleError(\"insertKeyValue\", err)\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n\n\n\nfunc (pgSQL *pgSQL) GetKeyValue(key string) (string, error) ", "output": "{\n\tdefer observeQueryTime(\"GetKeyValue\", \"all\", time.Now())\n\n\tvar value string\n\terr := pgSQL.QueryRow(searchKeyValue, key).Scan(&value)\n\n\tif err == sql.ErrNoRows {\n\t\treturn \"\", nil\n\t}\n\tif err != nil {\n\t\treturn \"\", handleError(\"searchKeyValue\", err)\n\t}\n\n\treturn value, nil\n}"}
{"input": "package nes\n\nimport \"syscall/js\"\n\ntype JSAudio struct {\n\tinput      chan int16\n\tsampleSize int\n}\n\n\n\nfunc (audio *JSAudio) Input() chan int16 {\n\treturn audio.input\n}\n\nfunc (audio *JSAudio) Run() {\n\tctx := js.Global().Get(\"AudioContext\").New()\n\n\tendedChan := make(chan bool, 1)\n\tplaying := false\n\n\tbuffer := ctx.Call(\"createBuffer\", 1, audio.sampleSize, 44100)\n\tdata := buffer.Call(\"getChannelData\", 0)\n\n\tslice := make([]float32, data.Length())\n\tbuf := js.TypedArrayOf(slice)\n\tdefer buf.Release()\n\n\tonendedCallback := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tgo func() {\n\t\t\tendedChan <- true\n\t\t}()\n\t\treturn nil\n\t})\n\tdefer onendedCallback.Release()\n\n\tfor {\n\t\tfor i := 0; i < audio.sampleSize; i++ {\n\t\t\tslice[i] = float32(<-audio.input) / float32(0x7fff)\n\t\t}\n\t\tbuffer.Call(\"copyToChannel\", buf, 0)\n\n\t\tsource := ctx.Call(\"createBufferSource\")\n\t\tsource.Set(\"buffer\", buffer)\n\t\tsource.Call(\"connect\", ctx.Get(\"destination\"))\n\n\t\tsource.Set(\"onended\", onendedCallback)\n\n\t\tif playing {\n\t\t\t<-endedChan\n\t\t}\n\n\t\tsource.Call(\"start\", 0)\n\t\tplaying = true\n\t}\n}\n\nfunc (audio *JSAudio) TogglePaused() {\n}\n\nfunc (audio *JSAudio) SetSpeed(speed float32) {\n}\n\nfunc (audio *JSAudio) Close() {\n}\n\nfunc NewAudio(frequency int, sampleSize int) (audio *JSAudio, err error) ", "output": "{\n\taudio = &JSAudio{\n\t\tinput:      make(chan int16),\n\t\tsampleSize: sampleSize,\n\t}\n\treturn\n}"}
{"input": "package main\n\nimport \"strings\"\n\nvar x = make([]byte, 10)\n\nfunc main() {\n\ttest1()\n\ttest2()\n\ttest3()\n\ttest4()\n\ttest5()\n\ttest6()\n\ttest7()\n}\n\nfunc mustRecover(s string) {\n\tv := recover()\n\tif v == nil {\n\t\tpanic(\"expected panic\")\n\t}\n\tif e := v.(error).Error(); strings.Index(e, s) < 0 {\n\t\tpanic(\"want: \" + s + \"; have: \" + e)\n\t}\n}\n\n\n\nfunc test2() {\n\tdefer mustRecover(\"slice\")\n\tprintln(x[5:15])\n}\n\nfunc test3() {\n\tdefer mustRecover(\"slice\")\n\tvar lo = 11\n\tvar hi = 9\n\tprintln(x[lo:hi])\n}\n\nfunc test4() {\n\tdefer mustRecover(\"interface\")\n\tvar x interface{} = 1\n\tprintln(x.(float32))\n}\n\ntype T struct {\n\ta, b int\n\tc    []int\n}\n\nfunc test5() {\n\tdefer mustRecover(\"uncomparable\")\n\tvar x T\n\tvar z interface{} = x\n\tprintln(z != z)\n}\n\nfunc test6() {\n\tdefer mustRecover(\"unhashable\")\n\tvar x T\n\tvar z interface{} = x\n\tm := make(map[interface{}]int)\n\tm[z] = 1\n}\n\nfunc test7() {\n\tdefer mustRecover(\"divide by zero\")\n\tvar x, y int\n\tprintln(x / y)\n}\n\nfunc test1() ", "output": "{\n\tdefer mustRecover(\"index\")\n\tprintln(x[123])\n}"}
{"input": "package syscall\n\nfunc setTimespec(sec, nsec int64) Timespec {\n\treturn Timespec{Sec: sec, Nsec: nsec}\n}\n\nfunc setTimeval(sec, usec int64) Timeval {\n\treturn Timeval{Sec: sec, Usec: usec}\n}\n\nfunc SetKevent(k *Kevent_t, fd, mode, flags int) {\n\tk.Ident = uint64(fd)\n\tk.Filter = int16(mode)\n\tk.Flags = uint16(flags)\n}\n\n\n\nfunc (msghdr *Msghdr) SetControllen(length int) {\n\tmsghdr.Controllen = uint32(length)\n}\n\nfunc (cmsg *Cmsghdr) SetLen(length int) {\n\tcmsg.Len = uint32(length)\n}\n\n\nconst RTM_LOCK = 0x8\n\n\n\nconst SYS___SYSCTL = SYS_SYSCTL\n\nfunc (iov *Iovec) SetLen(length int) ", "output": "{\n\tiov.Len = uint64(length)\n}"}
{"input": "package watt\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n\n\t\"github.com/datawire/ambassador/pkg/consulwatch\"\n\n\t\"github.com/datawire/ambassador/pkg/k8s\"\n)\n\ntype ConsulSnapshot struct {\n\tEndpoints map[string]consulwatch.Endpoints `json:\",omitempty\"`\n}\n\nfunc (s *ConsulSnapshot) DeepCopy() (*ConsulSnapshot, error) {\n\tjsonBytes, err := json.Marshal(s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres := &ConsulSnapshot{}\n\terr = json.Unmarshal(jsonBytes, res)\n\n\treturn res, err\n}\n\ntype Error struct {\n\tSource    string\n\tMessage   string\n\tTimestamp int64\n}\n\n\n\ntype Snapshot struct {\n\tConsul     ConsulSnapshot            `json:\",omitempty\"`\n\tKubernetes map[string][]k8s.Resource `json:\",omitempty\"`\n\tErrors     map[string][]Error        `json:\",omitempty\"`\n}\n\nfunc NewError(source, message string) Error ", "output": "{\n\treturn Error{Source: source, Message: message, Timestamp: time.Now().Unix()}\n}"}
{"input": "package mock\n\nimport \"bytes\"\n\n\ntype Job struct {\n\tPayload, Name, GearmanHandle, ID string\n\tGearmanErr                       error\n\tGearmanWarnings                  [][]byte\n\tDataBuffer                       bytes.Buffer\n\tNumerator, Denominator           int\n}\n\n\nfunc CreateMockJob(payload string) *Job {\n\treturn &Job{Payload: payload}\n}\n\n\n\n\n\nfunc (m Job) OutData() []byte {\n\treturn m.DataBuffer.Bytes()\n}\n\n\nfunc (m Job) Fn() string {\n\treturn m.Name\n}\n\n\nfunc (m Job) Err() error {\n\treturn m.GearmanErr\n}\n\n\nfunc (m Job) Handle() string {\n\treturn m.GearmanHandle\n}\n\n\nfunc (m Job) UniqueId() string {\n\treturn m.ID\n}\n\n\nfunc (m *Job) Warnings() [][]byte {\n\treturn m.GearmanWarnings\n}\n\n\nfunc (m *Job) SendWarning(warning []byte) {\n\tm.GearmanWarnings = append(m.GearmanWarnings, warning)\n}\n\n\nfunc (m *Job) SendData(data []byte) {\n\tm.DataBuffer.Write(data)\n}\n\n\nfunc (m *Job) UpdateStatus(numerator, denominator int) {\n\tm.Numerator = numerator\n\tm.Denominator = denominator\n}\n\nfunc (m Job) Data() []byte ", "output": "{\n\treturn []byte(m.Payload)\n}"}
{"input": "package routing\n\nimport \"net/http\"\n\n\nfunc Method(method string, handler http.Handler) Matcher {\n\treturn func(remainingPath string, resp http.ResponseWriter, req *http.Request) bool {\n\t\tif req.Method == method {\n\t\t\thandler.ServeHTTP(resp, req)\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n}\n\n\nfunc GET(handler http.Handler) Matcher {\n\treturn Method(\"GET\", handler)\n}\n\n\nfunc GETFunc(handler func(http.ResponseWriter, *http.Request)) Matcher {\n\treturn GET(http.HandlerFunc(handler))\n}\n\n\nfunc POST(handler http.Handler) Matcher {\n\treturn Method(\"POST\", handler)\n}\n\n\nfunc POSTFunc(handler func(http.ResponseWriter, *http.Request)) Matcher {\n\treturn POST(http.HandlerFunc(handler))\n}\n\n\nfunc PUT(handler http.Handler) Matcher {\n\treturn Method(\"PUT\", handler)\n}\n\n\nfunc PUTFunc(handler func(http.ResponseWriter, *http.Request)) Matcher {\n\treturn PUT(http.HandlerFunc(handler))\n}\n\n\nfunc PATCH(handler http.Handler) Matcher {\n\treturn Method(\"PATCH\", handler)\n}\n\n\nfunc PATCHFunc(handler func(http.ResponseWriter, *http.Request)) Matcher {\n\treturn PATCH(http.HandlerFunc(handler))\n}\n\n\n\n\n\nfunc DELETEFunc(handler func(http.ResponseWriter, *http.Request)) Matcher {\n\treturn DELETE(http.HandlerFunc(handler))\n}\n\n\n\nfunc MethodNotAllowed(remainingPath string, resp http.ResponseWriter, req *http.Request) bool {\n\tresp.WriteHeader(405)\n\treturn true\n}\n\nfunc DELETE(handler http.Handler) Matcher ", "output": "{\n\treturn Method(\"DELETE\", handler)\n}"}
{"input": "package idm\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/docker/libnetwork/bitseq\"\n\t\"github.com/docker/libnetwork/datastore\"\n)\n\n\ntype Idm struct {\n\tstart  uint64\n\tend    uint64\n\thandle *bitseq.Handle\n}\n\n\nfunc New(ds datastore.DataStore, id string, start, end uint64) (*Idm, error) {\n\tif id == \"\" {\n\t\treturn nil, fmt.Errorf(\"Invalid id\")\n\t}\n\tif end <= start {\n\t\treturn nil, fmt.Errorf(\"Invalid set range: [%d, %d]\", start, end)\n\t}\n\n\th, err := bitseq.NewHandle(\"idm\", ds, id, 1+end-start)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to initialize bit sequence handler: %s\", err.Error())\n\t}\n\n\treturn &Idm{start: start, end: end, handle: h}, nil\n}\n\n\n\n\n\nfunc (i *Idm) GetSpecificID(id uint64) error {\n\tif i.handle == nil {\n\t\treturn fmt.Errorf(\"ID set is not initialized\")\n\t}\n\n\tif id < i.start || id > i.end {\n\t\treturn fmt.Errorf(\"Requested id does not belong to the set\")\n\t}\n\n\treturn i.handle.Set(id - i.start)\n}\n\n\nfunc (i *Idm) Release(id uint64) {\n\ti.handle.Unset(id - i.start)\n}\n\nfunc (i *Idm) GetID() (uint64, error) ", "output": "{\n\tif i.handle == nil {\n\t\treturn 0, fmt.Errorf(\"ID set is not initialized\")\n\t}\n\tordinal, err := i.handle.SetAny()\n\treturn i.start + ordinal, err\n}"}
{"input": "package hll\n\nimport \"testing\"\n\nfunc TestOnesTo(t *testing.T) {\n\ttestCases := []struct {\n\t\tstartPos, endPos uint\n\t\texpectResult     uint64\n\t}{\n\t\t{0, 0, 1},\n\t\t{63, 63, 1 << 63},\n\t\t{2, 4, 4 + 8 + 16},\n\t\t{56, 63, 0xFF00000000000000},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tactualResult := onesFromTo(testCase.startPos, testCase.endPos)\n\t\tif testCase.expectResult != actualResult {\n\t\t\tt.Errorf(\"Case %d actual result was %v\", i, actualResult)\n\t\t}\n\t}\n}\n\nfunc TestExtractShift(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput            uint64\n\t\tstartPos, endPos uint\n\t\texpectResult     uint64\n\t}{\n\t\t{0, 0, 63, 0},\n\t\t{0xAABBCCDD00, 8, 47, 0xAABBCCDD},\n\t\t{0xFF00000000000000, 56, 63, 0xFF},\n\t\t{0xFF, 0, 7, 0xFF},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tactualResult := extractShift(testCase.input, testCase.startPos, testCase.endPos)\n\t\tif testCase.expectResult != actualResult {\n\t\t\tt.Errorf(\"Case %d actual result was %v\", i, actualResult)\n\t\t}\n\t}\n}\n\n\n\nfunc TestConcat(t *testing.T) ", "output": "{\n\ttestCases := []struct {\n\t\tinputs       []concatInput\n\t\texpectResult uint64\n\t}{\n\t\t{[]concatInput{{0xABCD, 0, 15}, {0x1234, 0, 15}}, 0xABCD1234},\n\t\t{[]concatInput{{0x0000ABCD0000, 16, 31}, {0x1234000000000000, 48, 63}}, 0xABCD1234},\n\t\t{[]concatInput{{0x1234, 0, 15}, {0x12, 0, 7}}, 0x123412},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tactualResult := concat(testCase.inputs)\n\t\tif testCase.expectResult != actualResult {\n\t\t\tt.Errorf(\"Case %d actual result was %x\", i, actualResult)\n\t\t}\n\t}\n}"}
{"input": "package pdf417\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\n\t\"github.com/boombuler/barcode\"\n\t\"github.com/boombuler/barcode/utils\"\n)\n\ntype pdfBarcode struct {\n\tdata  string\n\twidth int\n\tcode  *utils.BitList\n}\n\nfunc (c *pdfBarcode) Metadata() barcode.Metadata {\n\treturn barcode.Metadata{barcode.TypePDF, 2}\n}\n\nfunc (c *pdfBarcode) Content() string {\n\treturn c.data\n}\n\nfunc (c *pdfBarcode) ColorModel() color.Model {\n\treturn color.Gray16Model\n}\n\nfunc (c *pdfBarcode) Bounds() image.Rectangle {\n\theight := c.code.Len() / c.width\n\n\treturn image.Rect(0, 0, c.width, height*moduleHeight)\n}\n\n\n\nfunc (c *pdfBarcode) At(x, y int) color.Color ", "output": "{\n\tif c.code.GetBit((y/moduleHeight)*c.width + x) {\n\t\treturn color.Black\n\t}\n\treturn color.White\n}"}
{"input": "package css\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/sparkymat/webdsl/css/size\"\n)\n\nfunc Padding(sizes ...size.Size) Property {\n\tvar values []string\n\n\tfor _, value := range sizes {\n\t\tvalues = append(values, value.String())\n\t}\n\n\tproperty := Property{propertyType: \"padding\"}\n\tproperty.values = append(property.values, strings.Join(values, \" \"))\n\n\treturn property\n}\n\n\n\nfunc PaddingRight(distance size.Size) Property {\n\tproperty := Property{propertyType: \"padding-right\"}\n\tproperty.values = append(property.values, fmt.Sprintf(\"%v\", distance))\n\n\treturn property\n}\n\nfunc PaddingTop(distance size.Size) Property {\n\tproperty := Property{propertyType: \"padding-top\"}\n\tproperty.values = append(property.values, fmt.Sprintf(\"%v\", distance))\n\n\treturn property\n}\n\nfunc PaddingBottom(distance size.Size) Property {\n\tproperty := Property{propertyType: \"padding-bottom\"}\n\tproperty.values = append(property.values, fmt.Sprintf(\"%v\", distance))\n\n\treturn property\n}\n\nfunc PaddingLeft(distance size.Size) Property ", "output": "{\n\tproperty := Property{propertyType: \"padding-left\"}\n\tproperty.values = append(property.values, fmt.Sprintf(\"%v\", distance))\n\n\treturn property\n}"}
{"input": "package component \n\nimport (\n\t\"context\"\n\n\t\"go.opentelemetry.io/collector/config\"\n)\n\n\n\n\ntype Extension interface {\n\tComponent\n}\n\n\n\n\n\ntype PipelineWatcher interface {\n\tReady() error\n\n\tNotReady() error\n}\n\n\ntype ExtensionCreateSettings struct {\n\tTelemetrySettings\n\n\tBuildInfo BuildInfo\n}\n\n\ntype ExtensionDefaultConfigFunc func() config.Extension\n\n\nfunc (f ExtensionDefaultConfigFunc) CreateDefaultConfig() config.Extension {\n\treturn f()\n}\n\n\ntype CreateExtensionFunc func(context.Context, ExtensionCreateSettings, config.Extension) (Extension, error)\n\n\nfunc (f CreateExtensionFunc) CreateExtension(ctx context.Context, set ExtensionCreateSettings, cfg config.Extension) (Extension, error) {\n\treturn f(ctx, set, cfg)\n}\n\n\ntype ExtensionFactory interface {\n\tFactory\n\n\tCreateDefaultConfig() config.Extension\n\n\tCreateExtension(ctx context.Context, set ExtensionCreateSettings, cfg config.Extension) (Extension, error)\n}\n\ntype extensionFactory struct {\n\tbaseFactory\n\tExtensionDefaultConfigFunc\n\tCreateExtensionFunc\n}\n\n\n\nfunc NewExtensionFactory(\n\tcfgType config.Type,\n\tcreateDefaultConfig ExtensionDefaultConfigFunc,\n\tcreateServiceExtension CreateExtensionFunc) ExtensionFactory ", "output": "{\n\treturn &extensionFactory{\n\t\tbaseFactory:                baseFactory{cfgType: cfgType},\n\t\tExtensionDefaultConfigFunc: createDefaultConfig,\n\t\tCreateExtensionFunc:        createServiceExtension,\n\t}\n}"}
{"input": "package target\n\nimport (\n\t\"os\"\n)\n\n\n\n\n\n\n\nfunc Path(dst string, sources ...string) (bool, error) {\n\tstat, err := os.Stat(os.ExpandEnv(dst))\n\tif os.IsNotExist(err) {\n\t\treturn true, nil\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn PathNewer(stat.ModTime(), sources...)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Dir(dst string, sources ...string) (bool, error) {\n\tdst = os.ExpandEnv(dst)\n\tstat, err := os.Stat(dst)\n\tif os.IsNotExist(err) {\n\t\treturn true, nil\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdestTime := stat.ModTime()\n\tif stat.IsDir() {\n\t\tdestTime, err = NewestModTime(dst)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn DirNewer(destTime, sources...)\n}\n\nfunc Glob(dst string, globs ...string) (bool, error) ", "output": "{\n\tstat, err := os.Stat(os.ExpandEnv(dst))\n\tif os.IsNotExist(err) {\n\t\treturn true, nil\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn GlobNewer(stat.ModTime(), globs...)\n}"}
{"input": "package libcontainerd\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/containerd/containerd\"\n\t\"github.com/containerd/containerd/windows/hcsshimtypes\"\n\tspecs \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/pkg/errors\"\n)\n\n\n\nfunc prepareBundleDir(bundleDir string, ociSpec *specs.Spec) (string, error) {\n\treturn bundleDir, nil\n}\n\nfunc pipeName(containerID, processID, name string) string {\n\treturn fmt.Sprintf(`\\\\.\\pipe\\containerd-%s-%s-%s`, containerID, processID, name)\n}\n\nfunc newFIFOSet(bundleDir, containerID, processID string, withStdin, withTerminal bool) *containerd.FIFOSet {\n\tfifos := &containerd.FIFOSet{\n\t\tTerminal: withTerminal,\n\t\tOut:      pipeName(containerID, processID, \"stdout\"),\n\t}\n\n\tif withStdin {\n\t\tfifos.In = pipeName(containerID, processID, \"stdin\")\n\t}\n\n\tif !fifos.Terminal {\n\t\tfifos.Err = pipeName(containerID, processID, \"stderr\")\n\t}\n\n\treturn fifos\n}\n\nfunc summaryFromInterface(i interface{}) (*Summary, error) ", "output": "{\n\tswitch pd := i.(type) {\n\tcase *hcsshimtypes.ProcessDetails:\n\t\treturn &Summary{\n\t\t\tCreateTimestamp:              pd.CreatedAt,\n\t\t\tImageName:                    pd.ImageName,\n\t\t\tKernelTime100ns:              pd.KernelTime_100Ns,\n\t\t\tMemoryCommitBytes:            pd.MemoryCommitBytes,\n\t\t\tMemoryWorkingSetPrivateBytes: pd.MemoryWorkingSetPrivateBytes,\n\t\t\tMemoryWorkingSetSharedBytes:  pd.MemoryWorkingSetSharedBytes,\n\t\t\tProcessId:                    pd.ProcessID,\n\t\t\tUserTime100ns:                pd.UserTime_100Ns,\n\t\t}, nil\n\tdefault:\n\t\treturn nil, errors.Errorf(\"Unknown process details type %T\", pd)\n\t}\n}"}
{"input": "package core\n\nimport (\n\t\"net\";\n\t\"os\";\n\t\"log\";\n)\n\ntype acceptFunc\tfunc(net.Conn)\ntype errorFunc\tfunc(os.Error)\n\n\ntype listenConn struct {\n\tlisten\tnet.Listener;\n\taccept\tacceptFunc;\n\terror\terrorFunc;\n}\n\nfunc newListenConn(listen net.Listener, accept acceptFunc, error errorFunc) *listenConn {\n\tl := &listenConn{listen, accept, error};\n\tgo l.run();\n\treturn l;\n}\n\nfunc (l *listenConn) run() {\n\tlog.Stderrf(\"listening on %s\\n\", l.listen.Addr());\n\tfor {\n\t\tconn, err := l.listen.Accept();\n\t\tif err != nil {\n\t\t\tlog.Stderrf(\"accept failed: %s\\n\", err);\n\t\t\tl.listen.Close();\n\t\t\tif l.error != nil {\n\t\t\t\tl.error(err);\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tl.accept(conn);\n\t}\n}\n\n\n\nfunc (l *listenConn) Addr() net.Addr ", "output": "{\n\treturn l.listen.Addr()\n}"}
{"input": "package pdf\n\ntype ObjectNumber struct {\n\tnumber     uint32\n\tgeneration uint16\n}\n\n\n\ntype File interface {\n\tWriteObject(Object) (Indirect)\n\n\tWriteObjectAt(ObjectNumber, Object)\n\n\tIndirect(ObjectNumber) Indirect\n\n\tObject(ObjectNumber) (Object,error)\n\n\tReserveObjectNumber(Indirect) ObjectNumber\n\n\tInfo() Dictionary\n\n\tCatalog() ProtectedDictionary\n\n\tSetCatalog(Dictionary)\n\n\tSetInfo(DocumentInfo)\n\n\tTrailer() ProtectedDictionary\n\n\tDeleteObject(Indirect)\n\n\tClose()\n\n\tClosed() bool\n}\n\nfunc NewObjectNumber(number uint32, generation uint16) ObjectNumber ", "output": "{\n\treturn ObjectNumber{number,generation}\n}"}
{"input": "package model\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n)\n\nconst (\n\tACCESS_TOKEN_GRANT_TYPE  = \"authorization_code\"\n\tACCESS_TOKEN_TYPE        = \"bearer\"\n\tREFRESH_TOKEN_GRANT_TYPE = \"refresh_token\"\n)\n\ntype AccessData struct {\n\tAuthCode     string `json:\"auth_code\"`\n\tToken        string `json:\"token\"`\n\tRefreshToken string `json:\"refresh_token\"`\n\tRedirectUri  string `json:\"redirect_uri\"`\n}\n\ntype AccessResponse struct {\n\tAccessToken  string `json:\"access_token\"`\n\tTokenType    string `json:\"token_type\"`\n\tExpiresIn    int32  `json:\"expires_in\"`\n\tScope        string `json:\"scope\"`\n\tRefreshToken string `json:\"refresh_token\"`\n}\n\n\n\n\n\nfunc (ad *AccessData) ToJson() string {\n\tb, err := json.Marshal(ad)\n\tif err != nil {\n\t\treturn \"\"\n\t} else {\n\t\treturn string(b)\n\t}\n}\n\nfunc AccessDataFromJson(data io.Reader) *AccessData {\n\tdecoder := json.NewDecoder(data)\n\tvar ad AccessData\n\terr := decoder.Decode(&ad)\n\tif err == nil {\n\t\treturn &ad\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc (ar *AccessResponse) ToJson() string {\n\tb, err := json.Marshal(ar)\n\tif err != nil {\n\t\treturn \"\"\n\t} else {\n\t\treturn string(b)\n\t}\n}\n\nfunc AccessResponseFromJson(data io.Reader) *AccessResponse {\n\tdecoder := json.NewDecoder(data)\n\tvar ar AccessResponse\n\terr := decoder.Decode(&ar)\n\tif err == nil {\n\t\treturn &ar\n\t} else {\n\t\treturn nil\n\t}\n}\n\nfunc (ad *AccessData) IsValid() *AppError ", "output": "{\n\n\tif len(ad.AuthCode) == 0 || len(ad.AuthCode) > 128 {\n\t\treturn NewLocAppError(\"AccessData.IsValid\", \"model.access.is_valid.auth_code.app_error\", nil, \"\")\n\t}\n\n\tif len(ad.Token) != 26 {\n\t\treturn NewLocAppError(\"AccessData.IsValid\", \"model.access.is_valid.access_token.app_error\", nil, \"\")\n\t}\n\n\tif len(ad.RefreshToken) > 26 {\n\t\treturn NewLocAppError(\"AccessData.IsValid\", \"model.access.is_valid.refresh_token.app_error\", nil, \"\")\n\t}\n\n\tif len(ad.RedirectUri) > 256 {\n\t\treturn NewLocAppError(\"AccessData.IsValid\", \"model.access.is_valid.redirect_uri.app_error\", nil, \"\")\n\t}\n\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"common\"\n\t\"os\"\n\t\"ui\"\n)\n\nfunc uiEvent(event ui.Event) {\n\tswitch event.Type {\n\tcase ui.PeerLookupRequested:\n\t\tsendNetworkingCommand(\"lookup-peers\", map[string]string{})\n\tcase ui.PeerSelectRequested:\n\t\tsendNetworkingCommand(\"select-peer\", map[string]string{})\n\tcase ui.MessageSendRequested:\n\t\targs := map[string]string{\"msg\": event.Data.(string)}\n\t\tsendNetworkingCommand(\"send-message\", args)\n\tcase ui.UsageRequested:\n\t\tsendUsageCommand(\"get-usage-self\", map[string]string{})\n\tcase ui.InterpRequested: \n\t\targs := map[string]string{\"code\": event.Data.(string)}\n\t\tsendNetworkingCommand(\"eval\", args)\n\tcase ui.UserExit:\n\t\tos.Exit(0)\n\tdefault:\n\t}\n}\n\n\n\nfunc uiPrint(msg string) {\n\targs := map[string]string{\n\t\t\"msg\": msg,\n\t}\n\tsendUICommand(\"print\", args)\n}\n\nfunc sendUICommand(cmd string, args map[string]string) ", "output": "{\n\tui.In() <- common.Command{\n\t\tCmd:  cmd,\n\t\tArgs: args,\n\t}\n}"}
{"input": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/CodisLabs/codis/pkg/models/etcd\"\n\t\"github.com/CodisLabs/codis/pkg/models/fs\"\n\t\"github.com/CodisLabs/codis/pkg/models/zk\"\n\t\"github.com/CodisLabs/codis/pkg/utils/errors\"\n)\n\ntype Client interface {\n\tCreate(path string, data []byte) error\n\tUpdate(path string, data []byte) error\n\tDelete(path string) error\n\n\tRead(path string, must bool) ([]byte, error)\n\tList(path string, must bool) ([]string, error)\n\n\tClose() error\n\n\tWatchInOrder(path string) (<-chan struct{}, []string, error)\n\n\tCreateEphemeral(path string, data []byte) (<-chan struct{}, error)\n\tCreateEphemeralInOrder(path string, data []byte) (<-chan struct{}, string, error)\n}\n\n\n\n\nfunc NewClient(coordinator string, addrlist string, timeout time.Duration) (Client, error) ", "output": "{\n\tswitch coordinator {\n\tcase \"zk\", \"zookeeper\":\n\t\treturn zkclient.New(addrlist, timeout)\n\tcase \"etcd\":\n\t\treturn etcdclient.New(addrlist, timeout)\n\tcase \"fs\", \"filesystem\":\n\t\treturn fsclient.New(addrlist)\n\t}\n\treturn nil, errors.Errorf(\"invalid coordinator name = %s\", coordinator)\n}"}
{"input": "package operations\n\n\n\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n\tgolangswaggerpaths \"path\"\n)\n\n\ntype GetUserURL struct {\n\t_basePath string\n}\n\n\n\n\nfunc (o *GetUserURL) WithBasePath(bp string) *GetUserURL {\n\to.SetBasePath(bp)\n\treturn o\n}\n\n\n\n\nfunc (o *GetUserURL) SetBasePath(bp string) {\n\to._basePath = bp\n}\n\n\nfunc (o *GetUserURL) Build() (*url.URL, error) {\n\tvar result url.URL\n\n\tvar _path = \"/user\"\n\n\t_basePath := o._basePath\n\tif _basePath == \"\" {\n\t\t_basePath = \"/v1\"\n\t}\n\tresult.Path = golangswaggerpaths.Join(_basePath, _path)\n\n\treturn &result, nil\n}\n\n\n\n\n\nfunc (o *GetUserURL) String() string {\n\treturn o.Must(o.Build()).String()\n}\n\n\nfunc (o *GetUserURL) BuildFull(scheme, host string) (*url.URL, error) {\n\tif scheme == \"\" {\n\t\treturn nil, errors.New(\"scheme is required for a full url on GetUserURL\")\n\t}\n\tif host == \"\" {\n\t\treturn nil, errors.New(\"host is required for a full url on GetUserURL\")\n\t}\n\n\tbase, err := o.Build()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbase.Scheme = scheme\n\tbase.Host = host\n\treturn base, nil\n}\n\n\nfunc (o *GetUserURL) StringFull(scheme, host string) string {\n\treturn o.Must(o.BuildFull(scheme, host)).String()\n}\n\nfunc (o *GetUserURL) Must(u *url.URL, err error) *url.URL ", "output": "{\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif u == nil {\n\t\tpanic(\"url can't be nil\")\n\t}\n\treturn u\n}"}
{"input": "package main\n\nimport \"testing\"\n\nvar args []string = []string{\"main_test\", \"a\", \"b\", \"c\", \"d\", \"f\"}\n\nfunc BenchmarkEchoSlow(b *testing.B) {\n  for i := 0; i < b.N; i++ {\n    echoSlow(args)\n  }\n}\n\n\n\nfunc BenchmarkEchoFast(b *testing.B) ", "output": "{\n  for i := 0; i < b.N; i++ {\n    echoFast(args)\n  }\n}"}
{"input": "package marshaller\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\tkrautreporter \"github.com/metalmatze/krautreporter-api\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMarshallImage(t *testing.T) {\n\ti := &krautreporter.Image{ID: 123, Width: 256, Src: \"/foo.jpg\"}\n\n\tb, err := json.Marshal(marshallImage(i))\n\tassert.Nil(t, err)\n\tassert.JSONEq(t, `{\"id\":123,\"width\":256,\"src\":\"https://krautreporter.de/foo.jpg\"}`, string(b))\n}\n\n\n\nfunc TestImage(t *testing.T) ", "output": "{\n\ti := []*krautreporter.Image{}\n\n\tb, err := json.Marshal(FromImages(i))\n\tassert.Nil(t, err)\n\tassert.JSONEq(t, `{\"data\":[]}`, string(b))\n\n\ti = append(i, &krautreporter.Image{ID: 123, Width: 256, Src: \"/foo.jpg\"})\n\tb, err = json.Marshal(FromImages(i))\n\tassert.Nil(t, err)\n\tassert.JSONEq(t, `{\"data\":[{\"id\":123,\"width\":256,\"src\":\"https://krautreporter.de/foo.jpg\"}]}`, string(b))\n}"}
{"input": "package runtime\n\nimport (\n\t\"gopkg.in/v1/yaml\"\n)\n\n\n\n\n\n\n\nfunc (a *Object) UnmarshalJSON(b []byte) error {\n\tif len(b) == 4 && string(b) == \"null\" {\n\t\ta.Object = nil\n\t\treturn nil\n\t}\n\n\tobj, err := Decode(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\ta.Object = obj\n\treturn nil\n}\n\n\n\n\n\nfunc (a *Object) SetYAML(tag string, value interface{}) bool {\n\tif value == nil {\n\t\ta.Object = nil\n\t\treturn true\n\t}\n\tb, err := yaml.Marshal(value)\n\tif err != nil {\n\t\tpanic(\"yaml can't reverse its own object\")\n\t}\n\tobj, err := Decode(b)\n\tif err != nil {\n\t\treturn false\n\t}\n\ta.Object = obj\n\treturn true\n}\n\n\nfunc (a Object) GetYAML() (tag string, value interface{}) {\n\tif a.Object == nil {\n\t\tvalue = \"null\"\n\t\treturn\n\t}\n\tv, err := Encode(a.Object)\n\tif err != nil {\n\t\tpanic(\"impossible to encode API object!\")\n\t}\n\treturn tag, v\n}\n\nfunc (a Object) MarshalJSON() ([]byte, error) ", "output": "{\n\tif a.Object == nil {\n\t\treturn []byte(\"null\"), nil\n\t}\n\n\treturn Encode(a.Object)\n}"}
{"input": "package main\n\nimport (\n\tlog \"github.com/sirupsen/logrus\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n\t\"strings\"\n)\n\ntype ContextHook struct{}\n\n\n\nfunc (hook ContextHook) Fire(entry *log.Entry) error {\n\tpc := make([]uintptr, 3, 3)\n\tcnt := runtime.Callers(6, pc)\n\n\tfor i := 0; i < cnt; i++ {\n\t\tfu := runtime.FuncForPC(pc[i] - 1)\n\t\tname := fu.Name()\n\t\tif !strings.Contains(name, \"github.com/Sirupsen/log\") {\n\t\t\tfile, line := fu.FileLine(pc[i] - 1)\n\t\t\tentry.Data[\"file\"] = path.Base(file)\n\t\t\tentry.Data[\"func\"] = path.Base(name)\n\t\t\tentry.Data[\"line\"] = line\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc init() {\n\tlog.SetFormatter(&log.TextFormatter{FullTimestamp: true})\n\n\tif os.Getenv(\"BYTOM_DEBUG\") != \"\" {\n\t\tlog.AddHook(ContextHook{})\n\t\tlog.SetLevel(log.DebugLevel)\n\t}\n}\n\nfunc (hook ContextHook) Levels() []log.Level ", "output": "{\n\treturn log.AllLevels\n}"}
{"input": "package dbr\n\ntype union struct {\n\tbuilder []Builder\n\tall     bool\n}\n\n\n\n\n\nfunc UnionAll(builder ...Builder) interface {\n\tBuilder\n\tAs(string) Builder\n} {\n\treturn &union{\n\t\tbuilder: builder,\n\t\tall:     true,\n\t}\n}\n\nfunc (u *union) Build(d Dialect, buf Buffer) error {\n\tfor i, b := range u.builder {\n\t\tif i > 0 {\n\t\t\tbuf.WriteString(\" UNION \")\n\t\t\tif u.all {\n\t\t\t\tbuf.WriteString(\"ALL \")\n\t\t\t}\n\t\t}\n\t\tbuf.WriteString(placeholder)\n\t\tbuf.WriteValue(b)\n\t}\n\treturn nil\n}\n\nfunc (u *union) As(alias string) Builder {\n\treturn as(u, alias)\n}\n\nfunc Union(builder ...Builder) interface {\n\tBuilder\n\tAs(string) Builder\n} ", "output": "{\n\treturn &union{\n\t\tbuilder: builder,\n\t}\n}"}
{"input": "package apis\n\nimport (\n\t\"github.com/k8s-sqldb-operator/pkg/apis/infra/v1alpha1\"\n)\n\n\n\nfunc init() ", "output": "{\n\tAddToSchemes = append(AddToSchemes, v1alpha1.SchemeBuilder.AddToScheme)\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nconst cookieName = \"Site-Cookie1\"\n\nfunc main() {\n\thttp.Handle(\"/favicon.ico\", http.NotFoundHandler())\n\thttp.HandleFunc(\"/\", root)\n\thttp.HandleFunc(\"/set\", set)\n\thttp.HandleFunc(\"/read\", read)\n\thttp.HandleFunc(\"/expire\", expire)\n\tlog.Println(\"Starting server on 8080\")\n\tlog.Fatalln(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc root(w http.ResponseWriter, _ *http.Request) {\n\tfmt.Fprint(w, `<h1><a href=\"/set\">Set</a></h1>`)\n}\n\nfunc set(w http.ResponseWriter, _ *http.Request) {\n\thttp.SetCookie(w, &http.Cookie{\n\t\tName:  cookieName,\n\t\tValue: \"This is a Site Cookie created\",\n\t})\n\tfmt.Fprint(w, `<h1><a href=\"/read\">Read</a></h1>`)\n}\n\nfunc read(w http.ResponseWriter, r *http.Request) {\n\tcoo, err := r.Cookie(cookieName)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\thttp.Redirect(w, r, \"/set\", http.StatusSeeOther)\n\t\treturn\n\t}\n\tfmt.Fprintf(w, \"<h1>Cookie Value: %s</h1>\", coo.Value)\n\tfmt.Fprint(w, `<h1><a href=\"/expire\">Expire</a></h1>`)\n}\n\n\n\nfunc expire(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tcoo, err := r.Cookie(cookieName)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\thttp.Redirect(w, r, \"/set\", http.StatusSeeOther)\n\t\treturn\n\t}\n\tcoo.MaxAge = -1 \n\thttp.SetCookie(w, coo)\n\thttp.Redirect(w, r, \"/\", http.StatusSeeOther)\n}"}
{"input": "package git\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc (r *Repo) resolveRef(name string) (id Id) {\n\tif id := r.refs[name]; id != \"\" {\n\t\treturn id\n\t}\n\tcontent, err := ioutil.ReadFile(r.file(name))\n\tif err != nil {\n\t\tpanic(err.Error())\n\t\treturn \"\"\n\t}\n\tcontent = bytes.TrimSpace(content)\n\tif bytes.HasPrefix(content, []byte(\"ref: \")) {\n\t\tid = r.resolveRef(string(content[5:]))\n\t} else {\n\t\tid = IdFromString(string(content))\n\t}\n\tif id != \"\" {\n\t\tr.refs[name] = id\n\t}\n\treturn\n}\n\n\nfunc (r *Repo) Head() Id {\n\treturn r.resolveRef(\"HEAD\")\n}\n\n\n\n\nfunc (r *Repo) Refs() map[string]Id {\n\tr.packedRefs()\n\tif head := r.Head(); head != \"\" {\n\t\tr.refs[\"HEAD\"] = head\n\t}\n\tfilepath.Walk(r.file(\"refs\"), refVisitor(r))\n\treturn r.refs\n}\n\nfunc refVisitor(r *Repo) filepath.WalkFunc {\n\treturn func(path string, f os.FileInfo, err error) error {\n\t\tif !f.IsDir() {\n\t\t\tr.resolveRef(path[5:])\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc (r *Repo) packedRefs() ", "output": "{\n\tif r.refs == nil {\n\t\tr.refs = map[string]Id{}\n\t}\n\tpackedRefs := r.file(\"packed-refs\")\n\tcontent, err := ioutil.ReadFile(packedRefs)\n\tif err != nil {\n\t\treturn\n\t}\n\tlines := bytes.Split(content, []byte{'\\n'})\n\tfor _, line := range lines {\n\t\tif len(line) == 0 || line[0] == '#' {\n\t\t\tcontinue\n\t\t}\n\t\tparts := bytes.SplitN(line, []byte{' '}, 2)\n\t\tif len(parts[0]) != 40 {\n\t\t\tcontinue\n\t\t}\n\t\tid := IdFromString(string(parts[0]))\n\t\trefname := string(parts[1])\n\t\tr.refs[refname] = id\n\t}\n\treturn\n}"}
{"input": "package test\n\nimport (\n\t\"sync\"\n\n\tkapi \"github.com/GoogleCloudPlatform/kubernetes/pkg/api\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/labels\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/watch\"\n\t\"github.com/openshift/origin/pkg/deploy/api\"\n)\n\ntype DeploymentConfigRegistry struct {\n\tErr               error\n\tDeploymentConfig  *api.DeploymentConfig\n\tDeploymentConfigs *api.DeploymentConfigList\n\tsync.Mutex\n}\n\nfunc NewDeploymentConfigRegistry() *DeploymentConfigRegistry {\n\treturn &DeploymentConfigRegistry{}\n}\n\nfunc (r *DeploymentConfigRegistry) ListDeploymentConfigs(ctx kapi.Context, label, field labels.Selector) (*api.DeploymentConfigList, error) {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\treturn r.DeploymentConfigs, r.Err\n}\n\nfunc (r *DeploymentConfigRegistry) GetDeploymentConfig(ctx kapi.Context, id string) (*api.DeploymentConfig, error) {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\treturn r.DeploymentConfig, r.Err\n}\n\n\n\nfunc (r *DeploymentConfigRegistry) UpdateDeploymentConfig(ctx kapi.Context, image *api.DeploymentConfig) error {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\tr.DeploymentConfig = image\n\treturn r.Err\n}\n\nfunc (r *DeploymentConfigRegistry) DeleteDeploymentConfig(ctx kapi.Context, id string) error {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\treturn r.Err\n}\n\nfunc (r *DeploymentConfigRegistry) WatchDeploymentConfigs(ctx kapi.Context, label, field labels.Selector, resourceVersion string) (watch.Interface, error) {\n\treturn nil, r.Err\n}\n\nfunc (r *DeploymentConfigRegistry) CreateDeploymentConfig(ctx kapi.Context, image *api.DeploymentConfig) error ", "output": "{\n\tr.Lock()\n\tdefer r.Unlock()\n\n\tr.DeploymentConfig = image\n\treturn r.Err\n}"}
{"input": "package flog\n\nimport \"github.com/Sirupsen/logrus\"\n\ntype Parameter interface {\n\tConvert() map[string]interface{}\n}\n\ntype Fields struct {\n\tEvent string\n\tError error\n}\n\nfunc (f Fields) Convert() map[string]interface{} {\n\tfields := map[string]interface{}{}\n\n\tif f.Event != \"\" {\n\t\tfields[\"event\"] = f.Event\n\t}\n\n\tif f.Error != nil {\n\t\tfields[\"error\"] = f.Error\n\t}\n\n\treturn fields\n}\n\ntype Details map[string]interface{}\n\nfunc (d Details) Convert() map[string]interface{} {\n\treturn d\n}\n\ntype DebugFields map[string]interface{}\n\nfunc (d DebugFields) Convert() map[string]interface{} {\n\treturn map[string]interface{}{}\n}\n\nfunc transform(params []Parameter) logrus.Fields {\n\tlogrusFields := logrus.Fields{}\n\n\tfor _, p := range params {\n\t\tfieldMap := p.Convert()\n\n\t\tfor k, v := range fieldMap {\n\t\t\tlogrusFields[k] = v\n\t\t}\n\t}\n\n\treturn logrusFields\n}\n\n\n\nfunc Info(msg string, params ...Parameter) {\n\tf := transform(params)\n\n\tlogrus.WithFields(f).Info(msg)\n}\n\nfunc Warn(msg string, params ...Parameter) {\n\tf := transform(params)\n\n\tlogrus.WithFields(f).Warning(msg)\n}\n\nfunc Error(msg string, params ...Parameter) {\n\tf := transform(params)\n\n\tlogrus.WithFields(f).Error(msg)\n}\n\nfunc Fatal(msg string, params ...Parameter) {\n\tf := transform(params)\n\n\tlogrus.WithFields(f).Fatal(msg)\n}\n\nfunc Panic(msg string, params ...Parameter) {\n\tf := transform(params)\n\n\tlogrus.WithFields(f).Panic(msg)\n}\n\nfunc Debug(msg string, params ...Parameter) ", "output": "{\n\tf := transform(params)\n\n\tlogrus.WithFields(f).Debug(msg)\n}"}
{"input": "package api\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/mattermost/platform/model\"\n)\n\n\n\nfunc TestMeCommand(t *testing.T) ", "output": "{\n\tth := Setup().InitBasic()\n\tClient := th.BasicClient\n\tchannel := th.BasicChannel\n\n\ttestString := \"/me hello\"\n\n\tr1 := Client.Must(Client.Command(channel.Id, testString)).Data.(*model.CommandResponse)\n\tif r1 == nil {\n\t\tt.Fatal(\"Command failed to execute\")\n\t}\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tp1 := Client.Must(Client.GetPosts(channel.Id, 0, 2, \"\")).Data.(*model.PostList)\n\tif len(p1.Order) != 2 {\n\t\tt.Fatal(\"Command failed to send\")\n\t} else {\n\t\tif p1.Posts[p1.Order[0]].Message != `*hello*` {\n\t\t\tt.Log(p1.Posts[p1.Order[0]].Message)\n\t\t\tt.Fatal(\"invalid shrug reponse\")\n\t\t}\n\t}\n}"}
{"input": "package ro\n\nimport (\n\t\"github.com/blevesearch/bleve/analysis\"\n\t\"github.com/blevesearch/bleve/registry\"\n\n\t\"github.com/blevesearch/bleve/analysis/token_filters/lower_case_filter\"\n\t\"github.com/blevesearch/bleve/analysis/tokenizers/icu\"\n)\n\nconst AnalyzerName = \"ro\"\n\nfunc AnalyzerConstructor(config map[string]interface{}, cache *registry.Cache) (*analysis.Analyzer, error) {\n\ticuTokenizer, err := cache.TokenizerNamed(icu.Name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttoLowerFilter, err := cache.TokenFilterNamed(lower_case_filter.Name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstopRoFilter, err := cache.TokenFilterNamed(StopName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstemmerRoFilter, err := cache.TokenFilterNamed(StemmerName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trv := analysis.Analyzer{\n\t\tTokenizer: icuTokenizer,\n\t\tTokenFilters: []analysis.TokenFilter{\n\t\t\ttoLowerFilter,\n\t\t\tstopRoFilter,\n\t\t\tstemmerRoFilter,\n\t\t},\n\t}\n\treturn &rv, nil\n}\n\n\n\nfunc init() ", "output": "{\n\tregistry.RegisterAnalyzer(AnalyzerName, AnalyzerConstructor)\n}"}
{"input": "package container\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang/glog\"\n)\n\n\ntype ContainerGCPolicy struct {\n\tMinAge time.Duration\n\n\tMaxPerPodContainer int\n\n\tMaxContainers int\n}\n\n\n\n\ntype ContainerGC interface {\n\tGarbageCollect() error\n\tDeleteAllUnusedContainers() error\n}\n\n\ntype SourcesReadyProvider interface {\n\tAllReady() bool\n}\n\n\ntype realContainerGC struct {\n\truntime Runtime\n\n\tpolicy ContainerGCPolicy\n\n\tsourcesReadyProvider SourcesReadyProvider\n}\n\n\nfunc NewContainerGC(runtime Runtime, policy ContainerGCPolicy, sourcesReadyProvider SourcesReadyProvider) (ContainerGC, error) {\n\tif policy.MinAge < 0 {\n\t\treturn nil, fmt.Errorf(\"invalid minimum garbage collection age: %v\", policy.MinAge)\n\t}\n\n\treturn &realContainerGC{\n\t\truntime:              runtime,\n\t\tpolicy:               policy,\n\t\tsourcesReadyProvider: sourcesReadyProvider,\n\t}, nil\n}\n\n\n\nfunc (cgc *realContainerGC) DeleteAllUnusedContainers() error {\n\tglog.Infof(\"attempting to delete unused containers\")\n\treturn cgc.runtime.GarbageCollect(cgc.policy, cgc.sourcesReadyProvider.AllReady(), true)\n}\n\nfunc (cgc *realContainerGC) GarbageCollect() error ", "output": "{\n\treturn cgc.runtime.GarbageCollect(cgc.policy, cgc.sourcesReadyProvider.AllReady(), false)\n}"}
{"input": "package console\n\nimport (\n\t\"fmt\"\n\t\"github.com/serainville/gologger/logger\"\n\t\"time\"\n)\n\nfunc ConsolePrinter(log logger.LogInstance, packageName string, fileName string, lineNumber int, funcName string, time time.Time) {\n\tcolor := getColor(log)\n\tcolor.Set()\n\tfmt.Printf(\"[%s] [%s] [%s::%s::%s] [%d] %s\\n\", log.LogType, time.Format(\"2006-01-02 15:04:05\"), packageName, fileName, funcName, lineNumber, log.Message)\n\tUnset()\n}\n\nfunc ConsoleBasicPrinter(log logger.LogInstance, time time.Time) {\n\tcolor := getColor(log)\n\tcolor.Set()\n\tfmt.Printf(\"[%s] [%s] %s\\n\", log.LogType, time.Format(\"2006-01-02 15:04:05\"), log.Message)\n\tUnset()\n}\n\n\n\nfunc getColor(log logger.LogInstance) *Color ", "output": "{\n\tvar color *Color\n\n\tif log.LoggerInit.Location == \"simple\" {\n\t\tcolor = New(Reset)\n\t\treturn color\n\t}\n\n\tswitch log.LogType {\n\tcase \"LOG\":\n\t\tcolor = New(Reset)\n\t\tbreak\n\tcase \"MSG\":\n\t\tcolor = New(FgBlue)\n\t\tbreak\n\tcase \"INF\":\n\t\tcolor = New(FgGreen)\n\t\tbreak\n\tcase \"WRN\":\n\t\tcolor = New(FgMagenta)\n\t\tbreak\n\tcase \"DBG\":\n\t\tcolor = New(FgYellow)\n\t\tbreak\n\tcase \"ERR\":\n\t\tcolor = New(FgRed)\n\t\tbreak\n\tcase \"RSS\":\n\t\tcolor = New(Reset)\n\t\tbreak\n\tdefault:\n\t\tcolor = New(Reset)\n\t\tbreak\n\t}\n\treturn color\n}"}
{"input": "package denypassword\n\nimport (\n\t\"k8s.io/apiserver/pkg/authentication/authenticator\"\n\t\"k8s.io/apiserver/pkg/authentication/user\"\n)\n\n\ntype denyPasswordAuthenticator struct {\n}\n\n\nfunc New() authenticator.Password {\n\treturn &denyPasswordAuthenticator{}\n}\n\n\n\n\nfunc (a denyPasswordAuthenticator) AuthenticatePassword(username, password string) (user.Info, bool, error) ", "output": "{\n\treturn nil, false, nil\n}"}
{"input": "package app\n\nimport \"fmt\"\n\n\nfunc AccountHref(accountID interface{}) string {\n\treturn fmt.Sprintf(\"/api/accounts/%v\", accountID)\n}\n\n\n\n\n\nfunc UserHref(accountID, userID interface{}) string {\n\treturn fmt.Sprintf(\"/api/accounts/%v/users/%v\", accountID, userID)\n}\n\nfunc SeriesHref(accountID, seriesID interface{}) string ", "output": "{\n\treturn fmt.Sprintf(\"/api/accounts/%v/series/%v\", accountID, seriesID)\n}"}
{"input": "package image_ecosystem\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\tauthorizationv1 \"k8s.io/api/authorization/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/apimachinery/pkg/util/wait\"\n\tauthorizationv1client \"k8s.io/client-go/kubernetes/typed/authorization/v1\"\n)\n\nconst (\n\tPolicyCachePollInterval = 100 * time.Millisecond\n\tPolicyCachePollTimeout  = 10 * time.Second\n)\n\n\n\n\n\nfunc WaitForPolicyUpdate(c authorizationv1client.SelfSubjectAccessReviewsGetter, namespace, verb string, resource schema.GroupResource, allowed bool) error ", "output": "{\n\treview := &authorizationv1.SelfSubjectAccessReview{\n\t\tSpec: authorizationv1.SelfSubjectAccessReviewSpec{\n\t\t\tResourceAttributes: &authorizationv1.ResourceAttributes{\n\t\t\t\tNamespace: namespace,\n\t\t\t\tVerb:      verb,\n\t\t\t\tGroup:     resource.Group,\n\t\t\t\tResource:  resource.Resource,\n\t\t\t},\n\t\t},\n\t}\n\terr := wait.Poll(PolicyCachePollInterval, PolicyCachePollTimeout, func() (bool, error) {\n\t\tresponse, err := c.SelfSubjectAccessReviews().Create(context.Background(), review, metav1.CreateOptions{})\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn response.Status.Allowed == allowed, nil\n\t})\n\treturn err\n}"}
{"input": "package p\n\ntype T1 int\n\n\n\ntype T2 int\n\nfunc (t T2) F() {\n\ttype s struct {\n\t\tf string\n\t}\n}\n\nfunc (t T1) F() ", "output": "{\n\ttype s struct {\n\t\tf string\n\t}\n}"}
{"input": "package nes\n\nimport \"math\"\n\ntype Filter interface {\n\tStep(x float32) float32\n}\n\n\n\ntype FirstOrderFilter struct {\n\tB0    float32\n\tB1    float32\n\tA1    float32\n\tprevX float32\n\tprevY float32\n}\n\nfunc (f *FirstOrderFilter) Step(x float32) float32 {\n\ty := f.B0*x + f.B1*f.prevX - f.A1*f.prevY\n\tf.prevY = y\n\tf.prevX = x\n\treturn y\n}\n\n\n\n\n\nfunc HighPassFilter(sampleRate float32, cutoffFreq float32) Filter {\n\tc := sampleRate / math.Pi / cutoffFreq\n\ta0i := 1 / (1 + c)\n\treturn &FirstOrderFilter{\n\t\tB0: c * a0i,\n\t\tB1: -c * a0i,\n\t\tA1: (1 - c) * a0i,\n\t}\n}\n\ntype FilterChain []Filter\n\nfunc (fc FilterChain) Step(x float32) float32 {\n\tif fc != nil {\n\t\tfor i := range fc {\n\t\t\tx = fc[i].Step(x)\n\t\t}\n\t}\n\treturn x\n}\n\nfunc LowPassFilter(sampleRate float32, cutoffFreq float32) Filter ", "output": "{\n\tc := sampleRate / math.Pi / cutoffFreq\n\ta0i := 1 / (1 + c)\n\treturn &FirstOrderFilter{\n\t\tB0: a0i,\n\t\tB1: a0i,\n\t\tA1: (1 - c) * a0i,\n\t}\n}"}
{"input": "package core\n\nimport (\n\t\"fmt\"\n)\n\ntype BuiltInClass struct {\n\tname   Instance\n\tsupers []Class\n\tslots  []Instance\n}\n\nfunc NewBuiltInClass(name string, super Class, slots ...string) Class {\n\tslotNames := []Instance{}\n\tfor _, slot := range slots {\n\t\tslotNames = append(slotNames, NewSymbol(slot))\n\t}\n\treturn BuiltInClass{NewSymbol(name), []Class{super}, slotNames}\n}\n\nfunc (p BuiltInClass) Supers() []Class {\n\treturn p.supers\n}\n\nfunc (p BuiltInClass) Slots() []Instance {\n\treturn p.slots\n}\n\n\n\nfunc (p BuiltInClass) Initarg(arg Instance) (v Instance, ok bool) {\n\treturn arg, true\n}\n\nfunc (BuiltInClass) Class() Class {\n\treturn BuiltInClassClass\n}\n\nfunc (p BuiltInClass) String() string {\n\treturn fmt.Sprint(p.name)\n}\n\nfunc (p BuiltInClass) Initform(arg Instance) (v Instance, ok bool) ", "output": "{\n\treturn nil, false\n}"}
{"input": "package pelican\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n\n\ntype TestConfig struct {\n\torigdir string\n\ttempdir string\n}\n\nfunc NewTestConfig() *TestConfig {\n\treturn &TestConfig{}\n}\n\nfunc MoveToTestDir() *TestConfig {\n\tcfg := NewTestConfig()\n\tcfg.origdir, cfg.tempdir = MakeAndMoveToTempDir() \n\treturn cfg\n}\n\nfunc (cfg *TestConfig) ByeTestDir(skip *bool) {\n\tif skip != nil && !(*skip) {\n\t\tTempDirCleanup(cfg.origdir, cfg.tempdir)\n\t}\n\tVPrintf(\"\\n ByeTestConfig done.\\n\")\n}\n\nfunc MakeAndMoveToTempDir() (origdir string, tmpdir string) {\n\n\tvar err error\n\torigdir, err = os.Getwd()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttmpdir, err = ioutil.TempDir(origdir, \"tempgoqtestdir\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = os.Chdir(tmpdir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn origdir, tmpdir\n}\n\n\n\nfunc TempDirCleanup(origdir string, tmpdir string) ", "output": "{\n\tos.Chdir(origdir)\n\terr := os.RemoveAll(tmpdir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tVPrintf(\"\\n TempDirCleanup of '%s' done.\\n\", tmpdir)\n}"}
{"input": "package goFrontEnd\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"math/rand\"\n    \"strconv\"\n)\n\n\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    wHeader := w.Header()\n    wHeader.Set(\"Content-Type\",\"application/json\")\n    fmt.Fprint(w, \"{\\\"a\\\":\\\"beetle\\\",\\\"b\\\":\\\"juice\\\"}\")\n}\n\nfunc handler2(w http.ResponseWriter, r *http.Request) {\n    wHeader := w.Header()\n    x := rand.Intn(18)\n    y := rand.Intn(18)\n    xx := strconv.Itoa(x)\n    yy := strconv.Itoa(y)\n    wHeader.Set(\"Content-Type\",\"application/json\")\n    fmt.Fprint(w, \"{\\\"x\\\":\\\"\" + xx + \"\\\",\\\"y\\\":\\\"\" + yy + \"\\\"}\")\n    \n}\n\nfunc init() ", "output": "{\n    http.HandleFunc(\"/\", handler)\n    http.HandleFunc(\"/abc\", handler2)\n}"}
{"input": "package windows\n\nimport (\n\t\"github.com/docker/libnetwork/driverapi\"\n\t\"github.com/docker/libnetwork/types\"\n)\n\nconst networkType = \"windows\"\n\n\n\ntype driver struct{}\n\n\n\n\nfunc (d *driver) Config(option map[string]interface{}) error {\n\treturn nil\n}\n\nfunc (d *driver) CreateNetwork(id types.UUID, option map[string]interface{}) error {\n\treturn nil\n}\n\nfunc (d *driver) DeleteNetwork(nid types.UUID) error {\n\treturn nil\n}\n\nfunc (d *driver) CreateEndpoint(nid, eid types.UUID, epInfo driverapi.EndpointInfo, epOptions map[string]interface{}) error {\n\treturn nil\n}\n\nfunc (d *driver) DeleteEndpoint(nid, eid types.UUID) error {\n\treturn nil\n}\n\nfunc (d *driver) EndpointOperInfo(nid, eid types.UUID) (map[string]interface{}, error) {\n\treturn make(map[string]interface{}, 0), nil\n}\n\n\nfunc (d *driver) Join(nid, eid types.UUID, sboxKey string, jinfo driverapi.JoinInfo, options map[string]interface{}) error {\n\treturn nil\n}\n\n\nfunc (d *driver) Leave(nid, eid types.UUID) error {\n\treturn nil\n}\n\nfunc (d *driver) Type() string {\n\treturn networkType\n}\n\nfunc Init(dc driverapi.DriverCallback) error ", "output": "{\n\tc := driverapi.Capability{\n\t\tScope: driverapi.LocalScope,\n\t}\n\treturn dc.RegisterDriver(networkType, &driver{}, c)\n}"}
{"input": "package slack\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/nlopes/slack\"\n\t\"strings\"\n)\n\nfunc getUserWithUsername(username string) (user slack.User, err error) {\n\n\tusers, err := slackClient.GetUsers()\n\tif err != nil {\n\t\treturn slack.User{}, err\n\t}\n\n\tfor _, user := range users {\n\t\tif user.Name == username {\n\t\t\treturn user, nil\n\t\t}\n\t}\n\n\treturn slack.User{}, errors.New(fmt.Sprintf(\"No user with username %s\", username))\n}\n\n\n\nfunc parseUsername(name string) (username string, err error) ", "output": "{\n\n\tusername = strings.ToLower(name)\n\n\tif strings.Contains(username, \" \") {\n\t\treturn \"\", errors.New(fmt.Sprintf(\"%s is not a Slack username\", name))\n\t}\n\n\tif strings.Contains(name, \"@\") {\n\t\tusername = strings.Replace(username, \"@\", \"\", 1)\n\t}\n\n\treturn\n}"}
{"input": "package escalation\n\nimport (\n\t\"context\"\n\t\"github.com/opsgenie/opsgenie-go-sdk-v2/client\"\n)\n\ntype Client struct {\n\tclient *client.OpsGenieClient\n}\n\nfunc NewClient(config *client.Config) (*Client, error) {\n\topsgenieClient, err := client.NewOpsGenieClient(config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Client{opsgenieClient}, nil\n}\n\nfunc (c *Client) Create(context context.Context, request *CreateRequest) (*CreateResult, error) {\n\tresult := &CreateResult{}\n\terr := c.client.Exec(context, request, result)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\n\n\nfunc (c *Client) Update(context context.Context, request *UpdateRequest) (*UpdateResult, error) {\n\tresult := &UpdateResult{}\n\terr := c.client.Exec(context, request, result)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\nfunc (c *Client) Delete(context context.Context, request *DeleteRequest) (*DeleteResult, error) {\n\tresult := &DeleteResult{}\n\terr := c.client.Exec(context, request, result)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\nfunc (c *Client) List(context context.Context) (*ListResult, error) {\n\tresult := &ListResult{}\n\terr := c.client.Exec(context, &listRequest{}, result)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\nfunc (c *Client) Get(context context.Context, request *GetRequest) (*GetResult, error) ", "output": "{\n\tresult := &GetResult{}\n\terr := c.client.Exec(context, request, result)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}"}
{"input": "package sns\n\n\n\nimport (\n\t\"encoding/xml\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/goamz/goamz/aws\"\n)\n\n\ntype SNS struct {\n\taws.Auth\n\taws.Region\n\tprivate byte \n}\n\ntype AttributeEntry struct {\n\tKey   string `xml:\"key\"`\n\tValue string `xml:\"value\"`\n}\n\ntype ResponseMetadata struct {\n\tRequestId string  `xml:\"ResponseMetadata>RequestId\"`\n\tBoxUsage  float64 `xml:\"ResponseMetadata>BoxUsage\"`\n}\n\nfunc New(auth aws.Auth, region aws.Region) *SNS {\n\treturn &SNS{auth, region, 0}\n}\n\nfunc makeParams(action string) map[string]string {\n\tparams := make(map[string]string)\n\tparams[\"Action\"] = action\n\treturn params\n}\n\ntype Error struct {\n\tStatusCode int\n\tCode       string\n\tMessage    string\n\tRequestId  string\n}\n\nfunc (err *Error) Error() string {\n\treturn err.Message\n}\n\ntype xmlErrors struct {\n\tRequestId string\n\tErrors    []Error `xml:\"Errors>Error\"`\n}\n\n\n\nfunc buildError(r *http.Response) error {\n\terrors := xmlErrors{}\n\txml.NewDecoder(r.Body).Decode(&errors)\n\tvar err Error\n\tif len(errors.Errors) > 0 {\n\t\terr = errors.Errors[0]\n\t}\n\terr.RequestId = errors.RequestId\n\terr.StatusCode = r.StatusCode\n\tif err.Message == \"\" {\n\t\terr.Message = r.Status\n\t}\n\treturn &err\n}\n\nfunc multimap(p map[string]string) url.Values {\n\tq := make(url.Values, len(p))\n\tfor k, v := range p {\n\t\tq[k] = []string{v}\n\t}\n\treturn q\n}\n\nfunc (sns *SNS) query(params map[string]string, resp interface{}) error ", "output": "{\n\tparams[\"Timestamp\"] = time.Now().UTC().Format(time.RFC3339)\n\tu, err := url.Parse(sns.Region.SNSEndpoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsign(sns.Auth, \"GET\", \"/\", params, u.Host)\n\tu.RawQuery = multimap(params).Encode()\n\tr, err := http.Get(u.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Body.Close()\n\n\tif r.StatusCode != http.StatusOK {\n\t\treturn buildError(r)\n\t}\n\terr = xml.NewDecoder(r.Body).Decode(resp)\n\treturn err\n}"}
{"input": "package wraps\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-on/wrap\"\n)\n\n\n\ntype Catcher interface {\n\tCatch(recovered interface{}, w http.ResponseWriter, r *http.Request)\n}\n\n\ntype CatchFunc func(recovered interface{}, w http.ResponseWriter, r *http.Request)\n\n\n\n\n\n\n\nfunc (c CatchFunc) ServeHTTPNext(next http.Handler, wr http.ResponseWriter, req *http.Request) {\n\tchecked := wrap.NewPeek(wr, func(ck *wrap.Peek) bool {\n\t\tck.FlushHeaders()\n\t\tck.FlushCode()\n\t\treturn true\n\t})\n\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\tc(p, wr, req)\n\t\t} else {\n\t\t\tchecked.FlushMissing()\n\t\t}\n\t}()\n\n\tnext.ServeHTTP(checked, req)\n}\n\n\nfunc (c CatchFunc) Wrap(next http.Handler) http.Handler {\n\treturn wrap.NextHandler(c).Wrap(next)\n}\n\n\nfunc Catch(c Catcher) wrap.Wrapper {\n\treturn CatchFunc(c.Catch)\n}\n\nfunc (c CatchFunc) Catch(recovered interface{}, w http.ResponseWriter, r *http.Request) ", "output": "{\n\tc(recovered, w, r)\n}"}
{"input": "package cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/alexei-led/pumba/pkg/chaos\"\n\t\"github.com/alexei-led/pumba/pkg/chaos/docker\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/urfave/cli\"\n)\n\ntype stopContext struct {\n\tcontext context.Context\n}\n\n\nfunc NewStopCLICommand(ctx context.Context) *cli.Command {\n\tcmdContext := &stopContext{ctx}\n\treturn &cli.Command{\n\t\tName: \"stop\",\n\t\tFlags: []cli.Flag{\n\t\t\tcli.IntFlag{\n\t\t\t\tName:  \"time, t\",\n\t\t\t\tUsage: \"seconds to wait for stop before killing container (default 5)\",\n\t\t\t\tValue: docker.DeafultWaitTime,\n\t\t\t},\n\t\t\tcli.IntFlag{\n\t\t\t\tName:  \"limit, l\",\n\t\t\t\tUsage: \"limit number of container to stop (0: stop all matching)\",\n\t\t\t\tValue: 0,\n\t\t\t},\n\t\t\tcli.BoolFlag{\n\t\t\t\tName:  \"restart, r\",\n\t\t\t\tUsage: \"restart stopped container after specified duration\",\n\t\t\t},\n\t\t\tcli.StringFlag{\n\t\t\t\tName:  \"duration, d\",\n\t\t\t\tUsage: \"stop duration (works only with `restart` flag): must be shorter than recurrent interval; use with optional unit suffix: 'ms/s/m/h'\",\n\t\t\t\tValue: \"10s\",\n\t\t\t},\n\t\t},\n\t\tUsage:       \"stop containers\",\n\t\tArgsUsage:   fmt.Sprintf(\"containers (name, list of names, or RE2 regex if prefixed with %q\", chaos.Re2Prefix),\n\t\tDescription: \"stop the main process inside target containers, sending  SIGTERM, and then SIGKILL after a grace period\",\n\t\tAction:      cmdContext.stop,\n\t}\n}\n\n\n\n\nfunc (cmd *stopContext) stop(c *cli.Context) error ", "output": "{\n\tparams, err := chaos.ParseGlobalParams(c)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"error parsing global parameters\")\n\t}\n\twaitTime := c.Int(\"time\")\n\tlimit := c.Int(\"limit\")\n\trestart := c.Bool(\"restart\")\n\tduration := c.Duration(\"duration\")\n\tif duration == 0 {\n\t\treturn errors.New(\"unset or invalid duration value\")\n\t}\n\tstopCommand := docker.NewStopCommand(chaos.DockerClient, params, restart, duration, waitTime, limit)\n\terr = chaos.RunChaosCommand(cmd.context, stopCommand, params)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to stop containers\")\n\t}\n\treturn nil\n}"}
{"input": "package complete\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\ntype Args struct {\n\tAll []string\n\tCompleted []string\n\tLast string\n\tLastCompleted string\n}\n\n\n\n\nfunc (a Args) Directory() string {\n\tif info, err := os.Stat(a.Last); err == nil && info.IsDir() {\n\t\treturn fixPathForm(a.Last, a.Last)\n\t}\n\tdir := filepath.Dir(a.Last)\n\tif info, err := os.Stat(dir); err != nil || !info.IsDir() {\n\t\treturn \"./\"\n\t}\n\treturn fixPathForm(a.Last, dir)\n}\n\n\n\nfunc (a Args) from(i int) Args {\n\tif i > len(a.All) {\n\t\ti = len(a.All)\n\t}\n\ta.All = a.All[i:]\n\n\tif i > len(a.Completed) {\n\t\ti = len(a.Completed)\n\t}\n\ta.Completed = a.Completed[i:]\n\treturn a\n}\n\nfunc removeLast(a []string) []string {\n\tif len(a) > 0 {\n\t\treturn a[:len(a)-1]\n\t}\n\treturn a\n}\n\nfunc last(args []string) (last string) {\n\tif len(args) > 0 {\n\t\tlast = args[len(args)-1]\n\t}\n\treturn\n}\n\nfunc newArgs(line []string) Args ", "output": "{\n\tcompleted := removeLast(line[1:])\n\treturn Args{\n\t\tAll:           line[1:],\n\t\tCompleted:     completed,\n\t\tLast:          last(line),\n\t\tLastCompleted: last(completed),\n\t}\n}"}
{"input": "package framework\n\ntype SizeMode int\n\nconst (\n\tExpandToContent SizeMode = iota\n\tFill\n)\n\nfunc (s SizeMode) ExpandToContent() bool {\n\treturn s == ExpandToContent\n}\n\n\n\nfunc (s SizeMode) Fill() bool ", "output": "{\n\treturn s == Fill\n}"}
{"input": "package trie\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/uther/go-uther/common\"\n\t\"github.com/uther/go-uther/crypto\"\n\t\"github.com/uther/go-uther/ethdb\"\n)\n\nfunc newEmptySecure() *SecureTrie {\n\tdb, _ := ethdb.NewMemDatabase()\n\ttrie, _ := NewSecure(common.Hash{}, db)\n\treturn trie\n}\n\nfunc TestSecureDelete(t *testing.T) {\n\ttrie := newEmptySecure()\n\tvals := []struct{ k, v string }{\n\t\t{\"do\", \"verb\"},\n\t\t{\"ether\", \"wookiedoo\"},\n\t\t{\"horse\", \"stallion\"},\n\t\t{\"shaman\", \"horse\"},\n\t\t{\"doge\", \"coin\"},\n\t\t{\"ether\", \"\"},\n\t\t{\"dog\", \"puppy\"},\n\t\t{\"shaman\", \"\"},\n\t}\n\tfor _, val := range vals {\n\t\tif val.v != \"\" {\n\t\t\ttrie.Update([]byte(val.k), []byte(val.v))\n\t\t} else {\n\t\t\ttrie.Delete([]byte(val.k))\n\t\t}\n\t}\n\thash := trie.Hash()\n\texp := common.HexToHash(\"29b235a58c3c25ab83010c327d5932bcf05324b7d6b1185e650798034783ca9d\")\n\tif hash != exp {\n\t\tt.Errorf(\"expected %x got %x\", exp, hash)\n\t}\n}\n\n\n\nfunc TestSecureGetKey(t *testing.T) ", "output": "{\n\ttrie := newEmptySecure()\n\ttrie.Update([]byte(\"foo\"), []byte(\"bar\"))\n\n\tkey := []byte(\"foo\")\n\tvalue := []byte(\"bar\")\n\tseckey := crypto.Keccak256(key)\n\n\tif !bytes.Equal(trie.Get(key), value) {\n\t\tt.Errorf(\"Get did not return bar\")\n\t}\n\tif k := trie.GetKey(seckey); !bytes.Equal(k, key) {\n\t\tt.Errorf(\"GetKey returned %q, want %q\", k, key)\n\t}\n}"}
{"input": "package payload\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/hyperledger/burrow/acm/acmstate\"\n\t\"github.com/hyperledger/burrow/crypto\"\n)\n\nfunc NewBondTx(address crypto.Address, amount uint64) *BondTx {\n\treturn &BondTx{\n\t\tInput: &TxInput{\n\t\t\tAddress: address,\n\t\t\tAmount:  amount,\n\t\t},\n\t}\n}\n\nfunc (tx *BondTx) Type() Type {\n\treturn TypeBond\n}\n\n\n\nfunc (tx *BondTx) String() string {\n\treturn fmt.Sprintf(\"BondTx{%v}\", tx.Input)\n}\n\nfunc (tx *BondTx) AddInput(st acmstate.AccountGetter, pubkey *crypto.PublicKey, amt uint64) error {\n\taddr := pubkey.GetAddress()\n\tacc, err := st.GetAccount(addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif acc == nil {\n\t\treturn fmt.Errorf(\"invalid address %s from pubkey %s\", addr, pubkey)\n\t}\n\treturn tx.AddInputWithSequence(pubkey, amt, acc.Sequence+uint64(1))\n}\n\nfunc (tx *BondTx) AddInputWithSequence(pubkey *crypto.PublicKey, amt uint64, sequence uint64) error {\n\ttx.Input = &TxInput{\n\t\tAddress:  pubkey.GetAddress(),\n\t\tAmount:   amt,\n\t\tSequence: sequence,\n\t}\n\treturn nil\n}\n\nfunc (tx *BondTx) Any() *Any {\n\treturn &Any{\n\t\tBondTx: tx,\n\t}\n}\n\nfunc (tx *BondTx) GetInputs() []*TxInput ", "output": "{\n\treturn []*TxInput{tx.Input}\n}"}
{"input": "package gtreap\n\nimport (\n\t\"github.com/akhenakh/oureadb/store\"\n\n\t\"github.com/steveyen/gtreap\"\n)\n\ntype Reader struct {\n\tt *gtreap.Treap\n}\n\nfunc (w *Reader) Get(k []byte) (v []byte, err error) {\n\tvar rv []byte\n\titm := w.t.Get(&Item{k: k})\n\tif itm != nil {\n\t\trv = make([]byte, len(itm.(*Item).v))\n\t\tcopy(rv, itm.(*Item).v)\n\t\treturn rv, nil\n\t}\n\treturn nil, nil\n}\n\nfunc (r *Reader) MultiGet(keys [][]byte) ([][]byte, error) {\n\treturn store.MultiGet(r, keys)\n}\n\nfunc (w *Reader) PrefixIterator(k []byte) store.KVIterator {\n\trv := Iterator{\n\t\tt:      w.t,\n\t\tprefix: k,\n\t}\n\trv.restart(&Item{k: k})\n\treturn &rv\n}\n\n\n\nfunc (w *Reader) Close() error {\n\treturn nil\n}\n\nfunc (w *Reader) RangeIterator(start, end []byte) store.KVIterator ", "output": "{\n\trv := Iterator{\n\t\tt:     w.t,\n\t\tstart: start,\n\t\tend:   end,\n\t}\n\trv.restart(&Item{k: start})\n\treturn &rv\n}"}
{"input": "package leet_572\n\ntype TreeNode struct {\n\tVal   int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}\n\nfunc isSubtree(s *TreeNode, t *TreeNode) bool {\n\tif s == nil || t == nil {\n\t\treturn false\n\t}\n\n\treturn visit(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)\n}\n\n\n\nfunc visit(s *TreeNode, t *TreeNode) bool ", "output": "{\n\tif s == nil && t == nil {\n\t\treturn true\n\t}\n\tif s == nil || t == nil {\n\t\treturn false\n\t}\n\tif s.Val != t.Val {\n\t\treturn false\n\t}\n\treturn visit(s.Left, t.Left) && visit(s.Right, t.Right)\n}"}
{"input": "package httpcache\n\nimport \"log\"\n\nconst (\n\tansiRed   = \"\\x1b[31;1m\"\n\tansiReset = \"\\x1b[0m\"\n)\n\nvar DebugLogging = false\n\n\n\nfunc errorf(format string, args ...interface{}) {\n\tlog.Printf(ansiRed+\"✗ \"+format+ansiReset, args)\n}\n\nfunc debugf(format string, args ...interface{}) ", "output": "{\n\tif DebugLogging {\n\t\tlog.Printf(format, args...)\n\t}\n}"}
{"input": "package main\n\nimport \"fmt\"\n\n\n\n\n\n\nfunc getRemoveFeedMessage(sessionid string, tp string) []byte {\n\n\treturn []byte(fmt.Sprintf(`{\"event\":\"remove\",\"data\":{\"id\":\"%s\",\"type\":\"%s\"}}`, sessionid, tp))\n}\n\nfunc getRemoveClientMessage(sessionid string) []byte {\n\treturn []byte(fmt.Sprintf(`{\"event\":\"remove\",\"data\":{\"id\":\"%s\"}}`, sessionid))\n}\n\nfunc getConnectMessage(sessionid string) []byte ", "output": "{\n\tif len(TURN) == 0 {\n\t\treturn []byte(fmt.Sprintf(`{\"event\":\"connect\",\"data\":{\"sessionid\":\"%s\",\"stunservers\":[{\"url\":\"%s\"}],\"turnservers\":[]}}`, sessionid, STUN))\n\t}\n\treturn []byte(fmt.Sprintf(`{\"event\":\"connect\",\"data\":{\"sessionid\":\"%s\",\"stunservers\":[{\"url\":\"%s\"}],\"turnservers\":[]}}`, sessionid, STUN))\n}"}
{"input": "package lnwire\n\nimport \"io\"\n\n\n\n\n\n\ntype UpdateFulfillHTLC struct {\n\tChanID ChannelID\n\n\tID uint64\n\n\tPaymentPreimage [32]byte\n}\n\n\nfunc NewUpdateFulfillHTLC(chanID ChannelID, id uint64,\n\tpreimage [32]byte) *UpdateFulfillHTLC {\n\n\treturn &UpdateFulfillHTLC{\n\t\tChanID:          chanID,\n\t\tID:              id,\n\t\tPaymentPreimage: preimage,\n\t}\n}\n\n\n\nvar _ Message = (*UpdateFulfillHTLC)(nil)\n\n\n\n\n\nfunc (c *UpdateFulfillHTLC) Decode(r io.Reader, pver uint32) error {\n\treturn ReadElements(r,\n\t\t&c.ChanID,\n\t\t&c.ID,\n\t\tc.PaymentPreimage[:],\n\t)\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc (c *UpdateFulfillHTLC) MsgType() MessageType {\n\treturn MsgUpdateFulfillHTLC\n}\n\n\n\n\n\nfunc (c *UpdateFulfillHTLC) MaxPayloadLength(uint32) uint32 {\n\treturn 72\n}\n\nfunc (c *UpdateFulfillHTLC) Encode(w io.Writer, pver uint32) error ", "output": "{\n\treturn WriteElements(w,\n\t\tc.ChanID,\n\t\tc.ID,\n\t\tc.PaymentPreimage[:],\n\t)\n}"}
{"input": "package quickfix\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc sessionIDFilenamePrefix(s SessionID) string {\n\tsender := []string{s.SenderCompID}\n\tif s.SenderSubID != \"\" {\n\t\tsender = append(sender, s.SenderSubID)\n\t}\n\tif s.SenderLocationID != \"\" {\n\t\tsender = append(sender, s.SenderLocationID)\n\t}\n\n\ttarget := []string{s.TargetCompID}\n\tif s.TargetSubID != \"\" {\n\t\ttarget = append(target, s.TargetSubID)\n\t}\n\tif s.TargetLocationID != \"\" {\n\t\ttarget = append(target, s.TargetLocationID)\n\t}\n\n\tfname := []string{s.BeginString, strings.Join(sender, \"_\"), strings.Join(target, \"_\")}\n\tif s.Qualifier != \"\" {\n\t\tfname = append(fname, s.Qualifier)\n\t}\n\treturn strings.Join(fname, \"-\")\n}\n\n\nfunc closeFile(f *os.File) error {\n\tif f != nil {\n\t\tif err := f.Close(); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc openOrCreateFile(fname string, perm os.FileMode) (f *os.File, err error) {\n\tif f, err = os.OpenFile(fname, os.O_RDWR, perm); err != nil {\n\t\tif f, err = os.OpenFile(fname, os.O_RDWR|os.O_CREATE, perm); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error opening or creating file: %s: %s\", fname, err.Error())\n\t\t}\n\t}\n\treturn f, nil\n}\n\nfunc removeFile(fname string) error ", "output": "{\n\terr := os.Remove(fname)\n\tif (err != nil) && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package postactions\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/fragmenta/auth/can\"\n\t\"github.com/fragmenta/mux\"\n\t\"github.com/fragmenta/server\"\n\t\"github.com/fragmenta/view\"\n\n\t\"github.com/fragmenta/fragmenta-cms/src/lib/session\"\n\t\"github.com/fragmenta/fragmenta-cms/src/posts\"\n\t\"github.com/fragmenta/fragmenta-cms/src/users\"\n)\n\n\nfunc HandleUpdateShow(w http.ResponseWriter, r *http.Request) error {\n\n\tparams, err := mux.Params(r)\n\tif err != nil {\n\t\treturn server.InternalError(err)\n\t}\n\n\tpost, err := posts.Find(params.GetInt(posts.KeyName))\n\tif err != nil {\n\t\treturn server.NotFoundError(err)\n\t}\n\n\tuser := session.CurrentUser(w, r)\n\terr = can.Update(post, user)\n\tif err != nil {\n\t\treturn server.NotAuthorizedError(err)\n\t}\n\n\tauthors, err := users.FindAll(users.Where(\"role=?\", users.Admin))\n\tif err != nil {\n\t\treturn server.InternalError(err)\n\t}\n\n\tview := view.NewRenderer(w, r)\n\tview.AddKey(\"currentUser\", user)\n\tview.AddKey(\"post\", post)\n\tview.AddKey(\"authors\", authors)\n\treturn view.Render()\n}\n\n\n\n\nfunc HandleUpdate(w http.ResponseWriter, r *http.Request) error ", "output": "{\n\n\tparams, err := mux.Params(r)\n\tif err != nil {\n\t\treturn server.InternalError(err)\n\t}\n\n\tpost, err := posts.Find(params.GetInt(posts.KeyName))\n\tif err != nil {\n\t\treturn server.NotFoundError(err)\n\t}\n\n\terr = session.CheckAuthenticity(w, r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tuser := session.CurrentUser(w, r)\n\terr = can.Update(post, user)\n\tif err != nil {\n\t\treturn server.NotAuthorizedError(err)\n\t}\n\n\tpostParams := post.ValidateParams(params.Map(), posts.AllowedParams())\n\n\terr = post.Update(postParams)\n\tif err != nil {\n\t\treturn server.InternalError(err)\n\t}\n\n\treturn server.Redirect(w, r, post.ShowURL())\n}"}
{"input": "package jsondns\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/miekg/dns\"\n)\n\ntype dnsError struct {\n\tStatus  uint32 `json:\"Status\"`\n\tComment string `json:\"Comment,omitempty\"`\n}\n\n\n\nfunc FormatError(w http.ResponseWriter, comment string, errcode int) ", "output": "{\n\tw.Header().Set(\"Content-Type\", \"application/json; charset=UTF-8\")\n\terrJSON := dnsError{\n\t\tStatus:  dns.RcodeServerFailure,\n\t\tComment: comment,\n\t}\n\terrStr, err := json.Marshal(errJSON)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tw.WriteHeader(errcode)\n\tw.Write(errStr)\n}"}
{"input": "package flamingo\n\ntype Selectors map[string]interface{}\n\n\n\ntype MongoQuery struct {\n}\n\nfunc (ms *MongoQuery) One(result interface{}) error {\n\treturn nil\n}\n\nfunc (ms *MongoQuery) All(result interface{}) error {\n\treturn nil\n}\n\n\ntype MongoCollection struct {\n}\n\nfunc (ms *MongoCollection) Query(selectors Selectors) *MongoQuery {\n\treturn &MongoQuery{}\n}\n\nfunc (ms *MongoCollection) FindById(id interface{}) *MongoQuery {\n\treturn &MongoQuery{}\n}\n\nfunc (ms *MongoCollection) Insert(entity interface{}) error {\n\treturn nil\n}\n\nfunc (ms *MongoCollection) Update(entity interface{}) error {\n\treturn nil\n}\n\nfunc (ms *MongoCollection) Remove(selectors Selectors) error {\n\treturn nil\n}\n\n\n\n\n\ntype MongoSession struct {\n}\n\nfunc (ms *MongoSession) Close() error {\n\treturn nil\n}\n\nfunc (ms *MongoSession) Db(name string) *MongoSession {\n\treturn ms\n}\n\nfunc (ms *MongoSession) Collection(name string) *MongoCollection {\n\treturn &MongoCollection{}\n}\n\n\n\ntype MongoClient struct {\n\tloggerFactory *LoggerFactory\n}\n\nfunc (m *MongoClient) OpenSession() (MongoSession, error) {\n\treturn MongoSession{}, nil\n}\n\nfunc NewMongoClient(uri string, loggerFactory *LoggerFactory) MongoClient {\n\treturn MongoClient{loggerFactory}\n}\n\nfunc (ms *MongoCollection) RemoveById(id interface{}) error ", "output": "{\n\treturn nil\n}"}
{"input": "package server\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"os/signal\"\n\n\t\"k8s.io/klog/v2\"\n)\n\nvar onlyOneSignalHandler = make(chan struct{})\nvar shutdownHandler chan os.Signal\n\n\n\n\n\n\nfunc SetupSignalHandler() <-chan struct{} {\n\treturn SetupSignalContext().Done()\n}\n\n\n\nfunc SetupSignalHandlerIgnoringFurtherSignals() <-chan struct{} {\n\treturn SetupSignalContextNotExiting().Done()\n}\n\n\n\n\nfunc SetupSignalContext() context.Context {\n\treturn setupSignalContext(true)\n}\n\n\n\n\n\nfunc setupSignalContext(exitOnSecondSignal bool) context.Context {\n\tclose(onlyOneSignalHandler) \n\n\tshutdownHandler = make(chan os.Signal, 2)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tsignal.Notify(shutdownHandler, shutdownSignals...)\n\tgo func() {\n\t\t<-shutdownHandler\n\t\tcancel()\n\t\tif exitOnSecondSignal {\n\t\t\t<-shutdownHandler\n\t\t\tos.Exit(1)\n\t\t} else {\n\t\t\tfor {\n\t\t\t\t<-shutdownHandler\n\t\t\t\tklog.Infof(\"Termination signal has been received already. Ignoring signal.\")\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn ctx\n}\n\n\n\nfunc RequestShutdown() bool {\n\tif shutdownHandler != nil {\n\t\tselect {\n\t\tcase shutdownHandler <- shutdownSignals[0]:\n\t\t\treturn true\n\t\tdefault:\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc SetupSignalContextNotExiting() context.Context ", "output": "{\n\treturn setupSignalContext(false)\n}"}
{"input": "package chapter1\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc Test_HasUniqueChar_MustWork(t *testing.T) {\n\tDoTestUniqueCharFunction(t, HasUniqueChar)\n}\n\nfunc Test_HasUniqueCharV1_MustWork(t *testing.T) {\n\tDoTestUniqueCharFunction(t, HasUniqueCharV1)\n}\n\nfunc DoTestUniqueCharFunction(t *testing.T, f func(a string) bool) ", "output": "{\n\ttype TestCase struct {\n\t\tinput  string\n\t\tresult bool\n\t}\n\ttest_cases := []TestCase{\n\t\t{\"\", true},\n\t\t{\"1\", true},\n\t\t{\"ab\", true},\n\t\t{\"aa\", false},\n\t}\n\n\tfor idx, tc := range test_cases {\n\t\tif f(tc.input) != tc.result {\n\t\t\tt.Fatalf(\"%d: expected %v\", idx, tc.result)\n\t\t}\n\t}\n}"}
{"input": "package targets\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\n\t\"github.com/mattermost/logr/v2\"\n)\n\n\ntype Writer struct {\n\tout io.Writer\n}\n\n\nfunc NewWriterTarget(out io.Writer) *Writer {\n\tif out == nil {\n\t\tout = ioutil.Discard\n\t}\n\tw := &Writer{out: out}\n\treturn w\n}\n\n\nfunc (w *Writer) Init() error {\n\treturn nil\n}\n\n\nfunc (w *Writer) Write(p []byte, rec *logr.LogRec) (int, error) {\n\treturn w.out.Write(p)\n}\n\n\n\n\n\nfunc (w *Writer) Shutdown() error ", "output": "{\n\treturn nil\n}"}
{"input": "package devtestlabs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc UserAgent() string {\n\treturn \"Azure-SDK-For-Go/v12.4.0-beta arm-devtestlabs/2016-05-15\"\n}\n\n\n\n\nfunc Version() string ", "output": "{\n\treturn \"v12.4.0-beta\"\n}"}
{"input": "package fixrupr\n\nimport (\n\t\"errors\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\nfunc (s *MySuite) Test_newDbError(c *C) {\n\terr := newDbError(errors.New(\"this-is-my-error\"), \"this-is-my-query\", []interface{}{\"these\", \"are\", \"my\", \"parameters\"})\n\tc.Assert(err, FitsTypeOf, &dbError{})\n\n\tdbErr, ok := err.(*dbError)\n\tc.Assert(dbErr, NotNil)\n\tc.Assert(ok, Equals, true)\n\tc.Assert(dbErr.err, NotNil)\n\tc.Check(dbErr.err.Error(), Equals, \"this-is-my-error\")\n\tc.Check(dbErr.query, Equals, \"this-is-my-query\")\n\tc.Assert(dbErr.parameters, HasLen, 4)\n\tc.Check(dbErr.parameters[0], Equals, \"these\")\n\tc.Check(dbErr.parameters[1], Equals, \"are\")\n\tc.Check(dbErr.parameters[2], Equals, \"my\")\n\tc.Check(dbErr.parameters[3], Equals, \"parameters\")\n}\n\n\n\nfunc (s *MySuite) Test_dbError_Error(c *C) ", "output": "{\n\terr := newDbError(errors.New(\"this-is-my-error\"), \"this-is-my-query\", []interface{}{\"this\", \"are\", \"my\", \"parameters\"})\n\tc.Check(err.Error(), Equals, \"this-is-my-error\")\n}"}
{"input": "package fakeobserver\n\nimport (\n\t\"net/http\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/juju/names/v4\"\n\t\"github.com/juju/testing\"\n\n\t\"github.com/juju/juju/rpc\"\n)\n\n\ntype Instance struct {\n\ttesting.Stub\n}\n\n\nfunc (f *Instance) Join(req *http.Request, connectionID uint64) {\n\tf.AddCall(funcName(), req, connectionID)\n}\n\n\nfunc (f *Instance) Leave() {\n\tf.AddCall(funcName())\n}\n\n\nfunc (f *Instance) Login(entity names.Tag, model names.ModelTag, fromController bool, userData string) {\n\tf.AddCall(funcName(), entity, model, fromController, userData)\n}\n\n\nfunc (f *Instance) RPCObserver() rpc.Observer {\n\tresult := &RPCInstance{}\n\tf.AddCall(funcName(), result)\n\treturn result\n}\n\n\ntype RPCInstance struct {\n\ttesting.Stub\n}\n\n\nfunc (f *RPCInstance) ServerReply(req rpc.Request, hdr *rpc.Header, body interface{}) {\n\tf.AddCall(funcName(), req, hdr, body)\n}\n\n\n\n\n\n\nfunc funcName() string {\n\tif pc, _, _, ok := runtime.Caller(1); ok == false {\n\t\tpanic(\"could not find function name\")\n\t} else {\n\t\tparts := strings.Split(runtime.FuncForPC(pc).Name(), \".\")\n\t\treturn parts[len(parts)-1]\n\t}\n}\n\nfunc (f *RPCInstance) ServerRequest(hdr *rpc.Header, body interface{}) ", "output": "{\n\tf.AddCall(funcName(), hdr, body)\n}"}
{"input": "package proxy\n\nimport (\n\t\"github.com/micro/go-micro/v2/broker\"\n)\n\ntype publication struct {\n\ttopic   string\n\tmessage *broker.Message\n\terr     error\n}\n\nfunc (p *publication) Topic() string {\n\treturn p.topic\n}\n\n\n\nfunc (p *publication) Ack() error {\n\treturn nil\n}\n\nfunc (p *publication) Error() error {\n\treturn p.err\n}\n\nfunc (p *publication) Message() *broker.Message ", "output": "{\n\treturn p.message\n}"}
{"input": "package common\n\nimport (\n\t\"encoding/binary\"\n\t\"sort\"\n)\n\n\n\ntype Uint64Slice []uint64\n\nfunc (p Uint64Slice) Len() int           { return len(p) }\nfunc (p Uint64Slice) Less(i, j int) bool { return p[i] < p[j] }\nfunc (p Uint64Slice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n\n\nfunc SearchUint64s(a []uint64, x uint64) int {\n\treturn sort.Search(len(a), func(i int) bool { return a[i] >= x })\n}\n\nfunc (p Uint64Slice) Search(x uint64) int { return SearchUint64s(p, x) }\n\n\n\nfunc PutUint64LE(dest []byte, i uint64) {\n\tbinary.LittleEndian.PutUint64(dest, i)\n}\n\nfunc GetUint64LE(src []byte) uint64 {\n\treturn binary.LittleEndian.Uint64(src)\n}\n\nfunc PutUint64BE(dest []byte, i uint64) {\n\tbinary.BigEndian.PutUint64(dest, i)\n}\n\nfunc GetUint64BE(src []byte) uint64 {\n\treturn binary.BigEndian.Uint64(src)\n}\n\nfunc PutInt64LE(dest []byte, i int64) {\n\tbinary.LittleEndian.PutUint64(dest, uint64(i))\n}\n\nfunc GetInt64LE(src []byte) int64 {\n\treturn int64(binary.LittleEndian.Uint64(src))\n}\n\nfunc PutInt64BE(dest []byte, i int64) {\n\tbinary.BigEndian.PutUint64(dest, uint64(i))\n}\n\nfunc GetInt64BE(src []byte) int64 {\n\treturn int64(binary.BigEndian.Uint64(src))\n}\n\nfunc (p Uint64Slice) Sort()              ", "output": "{ sort.Sort(p) }"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\ntype BuildCommand struct {\n\tType      string `short:\"t\" long:\"type\" description:\"Type of environment.\"`\n\tVersion   string `short:\"v\" long:\"version\" description:\"Version of environment type.\"`\n\tImage     string `short:\"i\" long:\"image\" description:\"Image to use for creating environment.\"`\n\tForcePull bool   `long:\"force-pull\" description:\"Force pulling base image.\"`\n}\n\nvar buildCommand BuildCommand\n\nfunc (ccommand *BuildCommand) toBuildOpts(sc SystemClient) BuildOpts {\n\treturn BuildOpts{\n\t\tImage: ImageOpts{\n\t\t\tType:    ccommand.Type,\n\t\t\tVersion: ccommand.Version,\n\t\t\tImage:   ccommand.Image,\n\t\t},\n\t\tForcePull: ccommand.ForcePull,\n\t\tUsername:  sc.Username(),\n\t\tUID:       sc.UID(),\n\t\tGID:       sc.GID(),\n\t}\n}\n\nfunc (x *BuildCommand) Execute(args []string) error {\n\tdc, err := NewDockerClient(globalOptions.toConnectOpts())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsc, err := NewSystemClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\timage, err := BuildImage(dc, buildCommand.toBuildOpts(sc), os.Stdout)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"Built image: \", image)\n\n\treturn nil\n}\n\n\n\nfunc init() ", "output": "{\n\t_, err := parser.AddCommand(\"build\",\n\t\t\"Build an image.\",\n\t\t\"\",\n\t\t&buildCommand)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}"}
{"input": "package testdata\n\nimport \"testing\"\n\n\n\nfunc TestFoo2(t *testing.T) ", "output": "{\n\ttype args struct {\n\t\tin0 string\n\t\tin1 int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t}{\n\t}\n\tfor _, tt := range tests {\n\t\tFoo2(tt.args.in0, tt.args.in1)\n\t}\n}"}
{"input": "package tunnel\n\ntype IdAllocator struct {\n\tfreeList chan uint16\n}\n\nfunc (alloc *IdAllocator) Acquire() uint16 {\n\treturn <-alloc.freeList\n}\n\nfunc (alloc *IdAllocator) Release(id uint16) {\n\talloc.freeList <- id\n}\n\n\n\nfunc newAllocator() *IdAllocator ", "output": "{\n\tcapacity := ^uint16(0)\n\tfreeList := make(chan uint16, capacity)\n\tvar id uint16\n\tfor id = 1; id != capacity; id++ {\n\t\tfreeList <- id\n\t}\n\treturn &IdAllocator{freeList: freeList}\n}"}
{"input": "package vendor_pkg\n\nimport (\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n\ntype MockElem struct {\n\tctrl     *gomock.Controller\n\trecorder *MockElemMockRecorder\n}\n\n\ntype MockElemMockRecorder struct {\n\tmock *MockElem\n}\n\n\nfunc NewMockElem(ctrl *gomock.Controller) *MockElem {\n\tmock := &MockElem{ctrl: ctrl}\n\tmock.recorder = &MockElemMockRecorder{mock}\n\treturn mock\n}\n\n\nfunc (m *MockElem) EXPECT() *MockElemMockRecorder {\n\treturn m.recorder\n}\n\n\nfunc (m *MockElem) TemplateName() string {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"TemplateName\")\n\tret0, _ := ret[0].(string)\n\treturn ret0\n}\n\n\n\n\nfunc (mr *MockElemMockRecorder) TemplateName() *gomock.Call ", "output": "{\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"TemplateName\", reflect.TypeOf((*MockElem)(nil).TemplateName))\n}"}
{"input": "package sysinfo\n\n\n\n\nfunc New(quiet bool) *SysInfo ", "output": "{\n\tsysInfo := &SysInfo{}\n\treturn sysInfo\n}"}
{"input": "package registry \n\nimport (\n\t\"encoding/json\"\n\t\"net\"\n\n\t\"github.com/opencontainers/image-spec/specs-go/v1\"\n)\n\n\ntype ServiceConfig struct {\n\tAllowNondistributableArtifactsCIDRs     []*NetIPNet\n\tAllowNondistributableArtifactsHostnames []string\n\tInsecureRegistryCIDRs                   []*NetIPNet           `json:\"InsecureRegistryCIDRs\"`\n\tIndexConfigs                            map[string]*IndexInfo `json:\"IndexConfigs\"`\n\tMirrors                                 []string\n}\n\n\n\ntype NetIPNet net.IPNet\n\n\nfunc (ipnet *NetIPNet) String() string {\n\treturn (*net.IPNet)(ipnet).String()\n}\n\n\nfunc (ipnet *NetIPNet) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal((*net.IPNet)(ipnet).String())\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype IndexInfo struct {\n\tName string\n\tMirrors []string\n\tSecure bool\n\tOfficial bool\n}\n\n\ntype SearchResult struct {\n\tStarCount int `json:\"star_count\"`\n\tIsOfficial bool `json:\"is_official\"`\n\tName string `json:\"name\"`\n\tIsAutomated bool `json:\"is_automated\"`\n\tDescription string `json:\"description\"`\n}\n\n\ntype SearchResults struct {\n\tQuery string `json:\"query\"`\n\tNumResults int `json:\"num_results\"`\n\tResults []SearchResult `json:\"results\"`\n}\n\n\n\ntype DistributionInspect struct {\n\tDescriptor v1.Descriptor\n\tPlatforms []v1.Platform\n}\n\nfunc (ipnet *NetIPNet) UnmarshalJSON(b []byte) (err error) ", "output": "{\n\tvar ipnetStr string\n\tif err = json.Unmarshal(b, &ipnetStr); err == nil {\n\t\tvar cidr *net.IPNet\n\t\tif _, cidr, err = net.ParseCIDR(ipnetStr); err == nil {\n\t\t\t*ipnet = NetIPNet(*cidr)\n\t\t}\n\t}\n\treturn\n}"}
{"input": "package gtka\n\nimport (\n\t\"github.com/gotk3/gotk3/gtk\"\n\t\"github.com/coyim/gotk3adapter/gliba\"\n\t\"github.com/coyim/gotk3adapter/gtki\"\n)\n\ntype settings struct {\n\t*gliba.Object\n\tinternal *gtk.Settings\n}\n\nfunc wrapSettingsSimple(v *gtk.Settings) *settings {\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn &settings{gliba.WrapObjectSimple(v.Object), v}\n}\n\nfunc wrapSettings(v *gtk.Settings, e error) (*settings, error) {\n\treturn wrapSettingsSimple(v), e\n}\n\n\n\nfunc unwrapSettings(v gtki.Settings) *gtk.Settings ", "output": "{\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn v.(*settings).internal\n}"}
{"input": "package decide\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/trinchan/slackbot/robots\"\n)\n\ntype bot struct {\n\tRandom *rand.Rand\n}\n\nfunc init() {\n\td := &bot{}\n\td.Random = rand.New(rand.NewSource(time.Now().UnixNano()))\n\trobots.RegisterRobot(\"decide\", d)\n}\n\n\n\nfunc (d bot) DeferredAction(p *robots.Payload) {\n\tresponse := robots.IncomingWebhook{\n\t\tDomain:      p.TeamDomain,\n\t\tChannel:     p.ChannelID,\n\t\tUsername:    \"Fate Bot\",\n\t\tIconEmoji:   \":ghost:\",\n\t\tUnfurlLinks: true,\n\t\tParse:       robots.ParseStyleFull,\n\t}\n\ttext := strings.TrimSpace(p.Text)\n\tif text != \"\" {\n\t\tsplit := strings.Split(text, \", \")\n\t\tresponse.Text = fmt.Sprintf(\"@%s: Deciding between: (%s) -> %s\", p.UserName, strings.Join(split, \", \"), d.decide(split))\n\t\tresponse.Send()\n\t}\n}\n\nfunc (d bot) Description() (description string) {\n\treturn \"Decides your fate!\\n\\tUsage: /decide Life Death ...\\n\\tExpected Response: Deciding on (Life, Death, ...)\\n\\tDecided on Life!\"\n}\n\nfunc (d bot) decide(fates []string) (result string) {\n\tn := len(fates)\n\tif n > 0 {\n\t\treturn fates[d.Random.Intn(n)]\n\t}\n\treturn fmt.Sprintf(\"Error\")\n}\n\nfunc (d bot) Run(p *robots.Payload) (slashCommandImmediateReturn string) ", "output": "{\n\tgo d.DeferredAction(p)\n\ttext := strings.TrimSpace(p.Text)\n\tif text == \"\" {\n\t\treturn \"I need something to decide on!\"\n\t}\n\treturn \"\"\n}"}
{"input": "package raspui\n\ntype Textbox struct {\n\trect\n\ttext      string\n\toldlength int\n}\n\nfunc CreateTextbox(x, y, width, height int, text string) *Textbox {\n\ttxt := &Textbox{}\n\ttxt.x = x\n\ttxt.y = y\n\ttxt.width = width\n\ttxt.height = height\n\ttxt.draw = true\n\ttxt.text = text\n\ttxt.oldlength = 0\n\treturn txt\n}\n\nfunc (t *Textbox) doDraw() {\n\tif t.draw == true {\n\t\tty := int((t.height-16)/2 + t.y)\n\t\tdrawFilledBox(t.x, ty, t.x+8*t.oldlength, ty+16, WHITE)\n\t\tif len(t.text) * 8 > t.width {\n\t\t\tdrawText(t.x, ty, 0, t.text[0:t.width/8], BLACK, WHITE)\n\t\t} else {\n\t\t\tdrawText(t.x, ty, 0, t.text, BLACK, WHITE)\n\t\t}\n\t}\n}\n\nfunc (t *Textbox) getRect() rect {\n\treturn t.rect\n}\n\nfunc (t *Textbox) setRect(r rect) {\n\tt.rect = r\n}\n\nfunc (t *Textbox) setDrawable(draw bool) {\n\tt.draw = draw\n}\n\n\n\nfunc (t *Textbox) GetText() string {\n\treturn t.text\n}\n\nfunc (t *Textbox) SetText(text string) ", "output": "{\n\tt.oldlength = len(t.text)\n\tt.text = text\n\tdeclareInvalid(t)\n}"}
{"input": "package qemu\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"path/filepath\"\n\n\t\"github.com/hashicorp/packer/helper/multistep\"\n\t\"github.com/hashicorp/packer/packer\"\n)\n\n\n\ntype stepCopyDisk struct{}\n\n\n\nfunc (s *stepCopyDisk) Cleanup(state multistep.StateBag) {}\n\nfunc (s *stepCopyDisk) Run(ctx context.Context, state multistep.StateBag) multistep.StepAction ", "output": "{\n\tconfig := state.Get(\"config\").(*Config)\n\tdriver := state.Get(\"driver\").(Driver)\n\tisoPath := state.Get(\"iso_path\").(string)\n\tui := state.Get(\"ui\").(packer.Ui)\n\tpath := filepath.Join(config.OutputDir, config.VMName)\n\n\tcommand := []string{\n\t\t\"convert\",\n\t\t\"-O\", config.Format,\n\t\tisoPath,\n\t\tpath,\n\t}\n\n\tif !config.DiskImage || config.UseBackingFile {\n\t\treturn multistep.ActionContinue\n\t}\n\n\tui.Say(\"Copying hard drive...\")\n\tif err := driver.QemuImg(command...); err != nil {\n\t\terr := fmt.Errorf(\"Error creating hard drive: %s\", err)\n\t\tstate.Put(\"error\", err)\n\t\tui.Error(err.Error())\n\t\treturn multistep.ActionHalt\n\t}\n\n\treturn multistep.ActionContinue\n}"}
{"input": "package chain\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\t\"github.com/containous/alice\"\n\t\"github.com/traefik/traefik/v2/pkg/config/dynamic\"\n\t\"github.com/traefik/traefik/v2/pkg/log\"\n\t\"github.com/traefik/traefik/v2/pkg/middlewares\"\n)\n\nconst (\n\ttypeName = \"Chain\"\n)\n\ntype chainBuilder interface {\n\tBuildChain(ctx context.Context, middlewares []string) *alice.Chain\n}\n\n\n\n\nfunc New(ctx context.Context, next http.Handler, config dynamic.Chain, builder chainBuilder, name string) (http.Handler, error) ", "output": "{\n\tlog.FromContext(middlewares.GetLoggerCtx(ctx, name, typeName)).Debug(\"Creating middleware\")\n\n\tmiddlewareChain := builder.BuildChain(ctx, config.Middlewares)\n\treturn middlewareChain.Then(next)\n}"}
{"input": "package msgraph\n\nimport \"context\"\n\n\ntype WorkbookFunctionsAcoshRequestBuilder struct{ BaseRequestBuilder }\n\n\n\n\n\ntype WorkbookFunctionsAcoshRequest struct{ BaseRequest }\n\n\nfunc (b *WorkbookFunctionsAcoshRequestBuilder) Request() *WorkbookFunctionsAcoshRequest {\n\treturn &WorkbookFunctionsAcoshRequest{\n\t\tBaseRequest: BaseRequest{baseURL: b.baseURL, client: b.client, requestObject: b.requestObject},\n\t}\n}\n\n\nfunc (r *WorkbookFunctionsAcoshRequest) Post(ctx context.Context) (resObj *WorkbookFunctionResult, err error) {\n\terr = r.JSONRequest(ctx, \"POST\", \"\", r.requestObject, &resObj)\n\treturn\n}\n\nfunc (b *WorkbookFunctionsRequestBuilder) Acosh(reqObj *WorkbookFunctionsAcoshRequestParameter) *WorkbookFunctionsAcoshRequestBuilder ", "output": "{\n\tbb := &WorkbookFunctionsAcoshRequestBuilder{BaseRequestBuilder: b.BaseRequestBuilder}\n\tbb.BaseRequestBuilder.baseURL += \"/acosh\"\n\tbb.BaseRequestBuilder.requestObject = reqObj\n\treturn bb\n}"}
{"input": "package handler\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/dinever/golf\"\n\t\"github.com/dingoblog/dingo/app/model\"\n)\n\nfunc registerUserHandlers(app *golf.Application, routes map[string]map[string]interface{}) {\n\tapp.Get(\"/api/users\", APIUsersHandler)\n\troutes[\"GET\"][\"users_url\"] = \"/api/users\"\n\n\tapp.Get(\"/api/users/:user_id\", APIUserHandler)\n\troutes[\"GET\"][\"user_url\"] = \"/api/users/:user_id\"\n\n\tapp.Get(\"/api/users/slug/:slug\", APIUserSlugHandler)\n\troutes[\"GET\"][\"user_slug_url\"] = \"/api/users/slug/:slug\"\n\n\tapp.Get(\"/api/users/email/:email\", APIUserEmailHandler)\n\troutes[\"GET\"][\"user_email_url\"] = \"/api/users/email/:email\"\n}\n\n\n\n\n\nfunc APIUserSlugHandler(ctx *golf.Context) {\n\tslug := ctx.Param(\"slug\")\n\tuser := &model.User{Slug: slug}\n\terr := user.GetUserBySlug()\n\tif err != nil {\n\t\thandleErr(ctx, 404, err)\n\t\treturn\n\t}\n\tctx.JSONIndent(user, \"\", \"  \")\n}\n\n\nfunc APIUserEmailHandler(ctx *golf.Context) {\n\temail := ctx.Param(\"email\")\n\tuser := &model.User{Email: email}\n\terr := user.GetUserByEmail()\n\tif err != nil {\n\t\thandleErr(ctx, 404, err)\n\t\treturn\n\t}\n\tctx.JSONIndent(user, \"\", \"  \")\n}\n\n\nfunc APIUsersHandler(ctx *golf.Context) {\n\tctx.JSONIndent(map[string]interface{}{\n\t\t\"message\": \"Not implemented\",\n\t}, \"\", \"  \")\n}\n\nfunc APIUserHandler(ctx *golf.Context) ", "output": "{\n\tid, err := strconv.Atoi(ctx.Param(\"user_id\"))\n\tif err != nil {\n\t\thandleErr(ctx, 500, err)\n\t\treturn\n\t}\n\tuser := &model.User{Id: int64(id)}\n\terr = user.GetUserById()\n\tif err != nil {\n\t\thandleErr(ctx, 404, err)\n\t\treturn\n\t}\n\tctx.JSONIndent(user, \"\", \"  \")\n}"}
{"input": "package zip_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/klauspost/compress/flate\"\n\t\"github.com/klauspost/compress/zip\"\n)\n\n\n\nfunc ExampleReader() {\n\tr, err := zip.OpenReader(\"testdata/readme.zip\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer r.Close()\n\n\tfor _, f := range r.File {\n\t\tfmt.Printf(\"Contents of %s:\\n\", f.Name)\n\t\trc, err := f.Open()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\t_, err = io.CopyN(os.Stdout, rc, 68)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\trc.Close()\n\t\tfmt.Println()\n\t}\n}\n\nfunc ExampleWriter_RegisterCompressor() {\n\n\tbuf := new(bytes.Buffer)\n\n\tw := zip.NewWriter(buf)\n\n\tvar fw *flate.Writer\n\n\tw.RegisterCompressor(zip.Deflate, func(out io.Writer) (io.WriteCloser, error) {\n\t\tvar err error\n\t\tif fw == nil {\n\t\t\tfw, err = flate.NewWriter(out, flate.BestCompression)\n\t\t} else {\n\t\t\tfw.Reset(out)\n\t\t}\n\t\treturn fw, err\n\t})\n\n}\n\nfunc ExampleWriter() ", "output": "{\n\tbuf := new(bytes.Buffer)\n\n\tw := zip.NewWriter(buf)\n\n\tvar files = []struct {\n\t\tName, Body string\n\t}{\n\t\t{\"readme.txt\", \"This archive contains some text files.\"},\n\t\t{\"gopher.txt\", \"Gopher names:\\nGeorge\\nGeoffrey\\nGonzo\"},\n\t\t{\"todo.txt\", \"Get animal handling licence.\\nWrite more examples.\"},\n\t}\n\tfor _, file := range files {\n\t\tf, err := w.Create(file.Name)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\t_, err = f.Write([]byte(file.Body))\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\terr := w.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"input": "package test\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype MockProcess struct {\n\tname      string\n\texitAfter time.Duration\n\texitError error\n\tdelayCh   <-chan time.Time\n}\n\nfunc (p *MockProcess) Start() error {\n\tif p.delayCh != nil {\n\t\treturn fmt.Errorf(\"delayCh is already set\")\n\t}\n\tif p.exitAfter > time.Duration(0) {\n\t\tp.delayCh = time.After(p.exitAfter)\n\t}\n\treturn nil\n}\n\nfunc (p *MockProcess) Stop() error {\n\tp.delayCh = nil\n\treturn p.exitError\n}\n\nfunc (p *MockProcess) WaitRunning() bool {\n\treturn true\n}\n\n\n\nfunc (p *MockProcess) String() string {\n\treturn fmt.Sprintf(\"mock:%s\", p.name)\n}\n\nfunc (p *MockProcess) Logf(msg string, v ...interface{}) string {\n\tv = append([]interface{}{p.String()}, v...)\n\treturn fmt.Sprintf(\"[%s] \"+msg, v...)\n}\n\nfunc (p *MockProcess) Wait() error ", "output": "{\n\tif p.exitAfter > time.Duration(0) {\n\t\t<-p.delayCh\n\t\tp.delayCh = nil\n\t} else {\n\t\t<-make(chan bool)\n\t}\n\treturn p.exitError\n}"}
{"input": "package cmd\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-imsto/imsto/config\"\n)\n\nvar cmdBundle = &Command{\n\tUsageLine: \"bundle\",\n\tShort:     \"run all services\",\n\tLong:      ``,\n}\n\n\n\nfunc runBundle(args []string) bool {\n\tfmt.Printf(\"Start RPC/Stage/Tiring service %s\\n\", config.Version)\n\tgo runTiring(args)\n\tgo runStage(args)\n\treturn runRPC(args)\n}\n\nfunc init() ", "output": "{\n\tcmdBundle.Run = runBundle\n}"}
{"input": "package alg\n\nimport (\n\t\"math\"\n)\n\n\n\n\ntype Node struct {\n\tadj            []*Node\n\tadjMap         map[*Node]bool\n\tX              float64\n\tY              float64\n\tPrev           *Node\n\tPathCost       float64\n\tHieuristicCost float64\n}\n\nfunc NewNode() (n Node) {\n\tn.adj = make([]*Node, 0)\n\tn.adjMap = make(map[*Node]bool)\n\tn.PathCost = math.MaxFloat64\n\treturn n\n}\n\nfunc (node *Node) CalcHieuristic(goal *Node) {\n\tnode.HieuristicCost = math.Sqrt(math.Pow(node.X-goal.X, 2) + math.Pow(node.Y-goal.Y, 2))\n}\n\nfunc (node *Node) Adj() (nodes []*Node) {\n\treturn node.adj\n}\n\n\n\nfunc (node *Node) AddAdjNode(adjNode *Node) {\n\tnode.adj = append(node.adj, adjNode)\n\tnode.adjMap[adjNode] = true\n}\n\nfunc (n *Node) TraversalCost(node *Node) float64 {\n\treturn math.Sqrt(math.Pow(node.X-n.X, 2) + math.Pow(node.Y-n.Y, 2))\n}\n\nfunc (n *Node) Path() (path []*Node) {\n\tif n.Prev == nil {\n\t\treturn []*Node{n}\n\t} else {\n\t\treturn append(n.Prev.Path(), n)\n\t}\n}\n\nfunc (node *Node) AdjTo(adj Node) (adjTo bool) ", "output": "{\n\tif node.adjMap[&adj] == true {\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}"}
{"input": "package lexer\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc EqualSentences(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\n\tfor i := 0; i < len(a); i++ {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n\n\nfunc TestLexer(t *testing.T) {\n\ts := strings.NewReader(`foo bar; spaces  \"and quotes\"; \"es\\\"ca\\\\p e\"`)\n\tz := New(s)\n\n\tAssertNextSentence(z, t, []string{\"foo\", \"bar\"})\n\tAssertNextSentence(z, t, []string{\"spaces\", \"and quotes\"})\n\tAssertNextSentence(z, t, []string{`es\"ca\\p e`})\n}\n\nfunc TestSplit(t *testing.T) {\n\tss, err := Split(\"foo bar baz\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif len(ss) != 1 {\n\t\tt.Errorf(\"bad result: %s\", ss)\n\t}\n\tif !EqualSentences(ss[0], []string{\"foo\", \"bar\", \"baz\"}) {\n\t\tt.Errorf(\"bad result: %s\", ss)\n\t}\n}\n\nfunc AssertNextSentence(l *Lexer, t *testing.T, a []string) ", "output": "{\n\tb, _ := l.NextSentence()\n\n\tif !EqualSentences(a, b) {\n\t\tt.Errorf(\"bad sentence: '%s' VS '%s'\", a, b)\n\t}\n}"}
{"input": "package delayqueue\n\nimport (\n\t\"strconv\"\n)\n\n\ntype BucketItem struct {\n\ttimestamp int64\n\tjobId     string\n}\n\n\n\n\n\nfunc getFromBucket(key string) (*BucketItem, error) {\n\tvalue, err := execRedisCommand(\"ZRANGE\", key, 0, 0, \"WITHSCORES\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif value == nil {\n\t\treturn nil, nil\n\t}\n\n\tvar valueBytes []interface{}\n\tvalueBytes = value.([]interface{})\n\tif len(valueBytes) == 0 {\n\t\treturn nil, nil\n\t}\n\ttimestampStr := string(valueBytes[1].([]byte))\n\titem := &BucketItem{}\n\titem.timestamp, _ = strconv.ParseInt(timestampStr, 10, 64)\n\titem.jobId = string(valueBytes[0].([]byte))\n\n\treturn item, nil\n}\n\n\nfunc removeFromBucket(bucket string, jobId string) error {\n\t_, err := execRedisCommand(\"ZREM\", bucket, jobId)\n\n\treturn err\n}\n\nfunc pushToBucket(key string, timestamp int64, jobId string) error ", "output": "{\n\t_, err := execRedisCommand(\"ZADD\", key, timestamp, jobId)\n\n\treturn err\n}"}
{"input": "package chunks\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\n\t\"github.com/rtmfpew/amfy/vlu\"\n)\n\nconst BufferProbeChunkType = 0x18\n\n\ntype BufferProbeChunk struct {\n\tFlowID vlu.Vlu\n}\n\nfunc (chnk *BufferProbeChunk) Type() byte {\n\treturn BufferProbeChunkType\n}\n\nfunc (chnk *BufferProbeChunk) Len() uint16 {\n\treturn 1 + uint16(chnk.FlowID.ByteLength())\n}\n\nfunc (chnk *BufferProbeChunk) WriteTo(buffer *bytes.Buffer) error {\n\n\terr := buffer.WriteByte(chnk.Type())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = binary.Write(buffer, binary.BigEndian, chnk.Len()-1); err != nil {\n\t\treturn err\n\t}\n\n\tif err = chnk.FlowID.WriteTo(buffer); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (chnk *BufferProbeChunk) ReadFrom(buffer *bytes.Buffer) error ", "output": "{\n\n\tlength := uint16(0)\n\terr := binary.Read(buffer, binary.BigEndian, &length)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = chnk.FlowID.ReadFrom(buffer); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package fuzzing\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"vitess.io/vitess/go/mysql\"\n\t\"vitess.io/vitess/go/mysql/fakesqldb\"\n\t\"vitess.io/vitess/go/sqltypes\"\n\t\"vitess.io/vitess/go/vt/dbconfigs\"\n\t\"vitess.io/vitess/go/vt/mysqlctl/fakemysqldaemon\"\n\t\"vitess.io/vitess/go/vt/vttablet/tabletmanager\"\n\t\"vitess.io/vitess/go/vt/vttablet/tabletservermock\"\n)\n\n\n\nfunc FuzzTabletManager_ExecuteFetchAsDba(f *testing.F) ", "output": "{\n\tf.Fuzz(func(t *testing.T, data []byte) {\n\t\tctx := context.Background()\n\t\tcp := mysql.ConnParams{}\n\t\tdb := fakesqldb.New(t)\n\t\tdb.AddQueryPattern(\".*\", &sqltypes.Result{})\n\t\tdaemon := fakemysqldaemon.NewFakeMysqlDaemon(db)\n\n\t\tdbName := \"dbname\"\n\t\ttm := &tabletmanager.TabletManager{\n\t\t\tMysqlDaemon:         daemon,\n\t\t\tDBConfigs:           dbconfigs.NewTestDBConfigs(cp, cp, dbName),\n\t\t\tQueryServiceControl: tabletservermock.NewController(),\n\t\t}\n\t\t_, _ = tm.ExecuteFetchAsDba(ctx, data, dbName, 10, false, false)\n\t})\n}"}
{"input": "package controllers\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/astaxie/beego\"\n\t\"github.com/scmo/apayment-backend/models\"\n\t\"github.com/scmo/apayment-backend/services\"\n)\n\n\ntype PointGroupController struct {\n\tbeego.Controller\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (this *PointGroupController) GetAll() {\n\tthis.Data[\"json\"] = services.GetAllPointGroups()\n\tthis.ServeJSON()\n}\n\nfunc (this *PointGroupController) Post() ", "output": "{\n\tvar pointGroup models.PointGroup\n\tjson.Unmarshal(this.Ctx.Input.RequestBody, &pointGroup)\n\n\terr := services.CreatePointGroup(&pointGroup)\n\tif err != nil {\n\t\tbeego.Error(\"Create Point Group \", err.Error())\n\t\tthis.CustomAbort(500, \"Post Point Group Error\")\n\t}\n\tthis.Data[\"json\"] = pointGroup\n\tthis.ServeJSON()\n}"}
{"input": "package controller\n\nimport (\n\t\"sync\"\n)\n\ntype events struct {\n\tevents            []string\n\tcompleteFirstTime bool\n\texpected          int\n\tmutex             *sync.Mutex\n}\n\nfunc newEvents() *events {\n\treturn &events{\n\t\tevents: make([]string, 0, 100),\n\t\tmutex:  &sync.Mutex{},\n\t}\n}\n\nfunc (e *events) append(event string) {\n\te.mutex.Lock()\n\tdefer e.mutex.Unlock()\n\n\te.events = append(e.events, event)\n}\n\nfunc (e *events) isCompleteFirstTime() bool {\n\te.mutex.Lock()\n\tdefer e.mutex.Unlock()\n\n\tif e.expected == len(e.events) && !e.completeFirstTime {\n\t\te.completeFirstTime = true\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n\n\nfunc (e *events) get() []string {\n\te.mutex.Lock()\n\tdefer e.mutex.Unlock()\n\n\tresults := make([]string, 0, len(e.events))\n\tresults = append(results, e.events...)\n\n\treturn results\n}\n\nfunc (e *events) reset(expected int) ", "output": "{\n\te.mutex.Lock()\n\tdefer e.mutex.Unlock()\n\n\te.expected = expected\n\te.events = make([]string, 0, 100)\n\te.completeFirstTime = false\n}"}
{"input": "package ignition\n\nimport (\n\t\"github.com/coreos/ignition/config/types\"\n\t\"github.com/hashicorp/terraform/helper/schema\"\n)\n\nfunc resourceGroup() *schema.Resource {\n\treturn &schema.Resource{\n\t\tCreate: resourceGroupCreate,\n\t\tDelete: resourceGroupDelete,\n\t\tExists: resourceGroupExists,\n\t\tRead:   resourceGroupRead,\n\t\tSchema: map[string]*schema.Schema{\n\t\t\t\"name\": &schema.Schema{\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tRequired: true,\n\t\t\t\tForceNew: true,\n\t\t\t},\n\t\t\t\"gid\": &schema.Schema{\n\t\t\t\tType:     schema.TypeInt,\n\t\t\t\tOptional: true,\n\t\t\t\tForceNew: true,\n\t\t\t},\n\t\t\t\"password_hash\": &schema.Schema{\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tOptional: true,\n\t\t\t\tForceNew: true,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc resourceGroupCreate(d *schema.ResourceData, meta interface{}) error {\n\tid, err := buildGroup(d, meta.(*cache))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\td.SetId(id)\n\treturn nil\n}\n\nfunc resourceGroupDelete(d *schema.ResourceData, meta interface{}) error {\n\td.SetId(\"\")\n\treturn nil\n}\n\nfunc resourceGroupExists(d *schema.ResourceData, meta interface{}) (bool, error) {\n\tid, err := buildGroup(d, meta.(*cache))\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn id == d.Id(), nil\n}\n\nfunc resourceGroupRead(d *schema.ResourceData, meta interface{}) error {\n\treturn nil\n}\n\n\n\nfunc buildGroup(d *schema.ResourceData, c *cache) (string, error) ", "output": "{\n\treturn c.addGroup(&types.Group{\n\t\tName:         d.Get(\"name\").(string),\n\t\tPasswordHash: d.Get(\"password_hash\").(string),\n\t\tGid:          getUInt(d, \"gid\"),\n\t}), nil\n}"}
{"input": "package iso20022\n\n\ntype Statement55 struct {\n\n\tReportNumber *Number3Choice `xml:\"RptNb,omitempty\"`\n\n\tQueryReference *RestrictedFINXMax16Text `xml:\"QryRef,omitempty\"`\n\n\tStatementIdentification *RestrictedFINXMax16Text `xml:\"StmtId,omitempty\"`\n\n\tStatementDateTime *DateAndDateTimeChoice `xml:\"StmtDtTm\"`\n\n\tFrequency *Frequency26Choice `xml:\"Frqcy,omitempty\"`\n\n\tUpdateType *UpdateType16Choice `xml:\"UpdTp,omitempty\"`\n\n\tStatementStructure *StatementStructure1Code `xml:\"StmtStr\"`\n\n\tActivityIndicator *YesNoIndicator `xml:\"ActvtyInd\"`\n}\n\nfunc (s *Statement55) AddReportNumber() *Number3Choice {\n\ts.ReportNumber = new(Number3Choice)\n\treturn s.ReportNumber\n}\n\nfunc (s *Statement55) SetQueryReference(value string) {\n\ts.QueryReference = (*RestrictedFINXMax16Text)(&value)\n}\n\nfunc (s *Statement55) SetStatementIdentification(value string) {\n\ts.StatementIdentification = (*RestrictedFINXMax16Text)(&value)\n}\n\nfunc (s *Statement55) AddStatementDateTime() *DateAndDateTimeChoice {\n\ts.StatementDateTime = new(DateAndDateTimeChoice)\n\treturn s.StatementDateTime\n}\n\n\n\nfunc (s *Statement55) AddUpdateType() *UpdateType16Choice {\n\ts.UpdateType = new(UpdateType16Choice)\n\treturn s.UpdateType\n}\n\nfunc (s *Statement55) SetStatementStructure(value string) {\n\ts.StatementStructure = (*StatementStructure1Code)(&value)\n}\n\nfunc (s *Statement55) SetActivityIndicator(value string) {\n\ts.ActivityIndicator = (*YesNoIndicator)(&value)\n}\n\nfunc (s *Statement55) AddFrequency() *Frequency26Choice ", "output": "{\n\ts.Frequency = new(Frequency26Choice)\n\treturn s.Frequency\n}"}
{"input": "package v1\n\n\n\ntype EnvVarApplyConfiguration struct {\n\tName      *string                         `json:\"name,omitempty\"`\n\tValue     *string                         `json:\"value,omitempty\"`\n\tValueFrom *EnvVarSourceApplyConfiguration `json:\"valueFrom,omitempty\"`\n}\n\n\n\nfunc EnvVar() *EnvVarApplyConfiguration {\n\treturn &EnvVarApplyConfiguration{}\n}\n\n\n\n\nfunc (b *EnvVarApplyConfiguration) WithName(value string) *EnvVarApplyConfiguration {\n\tb.Name = &value\n\treturn b\n}\n\n\n\n\n\n\n\n\n\nfunc (b *EnvVarApplyConfiguration) WithValueFrom(value *EnvVarSourceApplyConfiguration) *EnvVarApplyConfiguration {\n\tb.ValueFrom = value\n\treturn b\n}\n\nfunc (b *EnvVarApplyConfiguration) WithValue(value string) *EnvVarApplyConfiguration ", "output": "{\n\tb.Value = &value\n\treturn b\n}"}
{"input": "package syscall\n\nfunc setTimespec(sec, nsec int64) Timespec {\n\treturn Timespec{Sec: sec, Nsec: nsec}\n}\n\nfunc setTimeval(sec, usec int64) Timeval {\n\treturn Timeval{Sec: sec, Usec: usec}\n}\n\nfunc SetKevent(k *Kevent_t, fd, mode, flags int) {\n\tk.Ident = uint64(fd)\n\tk.Filter = int16(mode)\n\tk.Flags = uint16(flags)\n}\n\nfunc (iov *Iovec) SetLen(length int) {\n\tiov.Len = uint64(length)\n}\n\nfunc (msghdr *Msghdr) SetControllen(length int) {\n\tmsghdr.Controllen = uint32(length)\n}\n\n\n\n\nconst RTM_LOCK = 0x8\n\n\n\nconst SYS___SYSCTL = SYS_SYSCTL\n\nfunc (cmsg *Cmsghdr) SetLen(length int) ", "output": "{\n\tcmsg.Len = uint32(length)\n}"}
{"input": "package util\n\nimport (\n  \"os\"\n  \"fmt\"\n  \"time\"\n)\n\ntype LumberJack struct {\n  Channel chan string\n}\n\nconst (\n  timeLayout = \"2006-01-02 15:04:05.000 MST\"\n)\n\nfunc NewLumberJack(fpath string) (*LumberJack) {\n  fi, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)\n  if err != nil {\n    panic(err)\n  }\n  ch := make(chan string, 100)\n  go run(ch, fi)\n  return &LumberJack {\n    Channel: ch,\n  }\n}\n\nfunc (lggr *LumberJack) Write(msg string) {\n  lggr.Channel <- msg\n}\n\n\n\nfunc run(ch <-chan string, fi *os.File) ", "output": "{\n  defer fi.Close()\n\n  for {\n    select {\n    case msg := <-ch:\n      fmsg := fmt.Sprintf(\"%s %s\\n\", time.Now().Format(timeLayout), msg)\n      if _, err :=  fi.WriteString(fmsg); err != nil {\n        panic(err)\n      }\n      fi.Sync()\n    }\n  }\n}"}
{"input": "package redis\n\nimport (\n\t\"github.com/fagongzi/goetty\"\n)\n\ntype redisDecoder struct {\n}\n\n\nfunc NewRedisDecoder() goetty.Decoder {\n\treturn &redisDecoder{}\n}\n\n\nfunc (decoder *redisDecoder) Decode(in *goetty.ByteBuf) (bool, interface{}, error) {\n\tcomplete, cmd, err := ReadCommand(in)\n\tif err != nil {\n\t\treturn true, nil, err\n\t}\n\n\tif !complete {\n\t\treturn false, nil, nil\n\t}\n\n\treturn true, cmd, nil\n}\n\ntype redisReplyDecoder struct {\n}\n\n\nfunc NewRedisReplyDecoder() goetty.Decoder {\n\treturn &redisReplyDecoder{}\n}\n\n\n\n\nfunc (decoder *redisReplyDecoder) Decode(in *goetty.ByteBuf) (bool, interface{}, error) ", "output": "{\n\tcomplete, cmd, err := readCommandReply(in)\n\tif err != nil {\n\t\treturn true, nil, err\n\t}\n\n\tif !complete {\n\t\treturn false, nil, nil\n\t}\n\n\treturn true, cmd, nil\n}"}
{"input": "package alg\n\n\n\n\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype Histogram struct {\n\tName string\n\tData map[string] int\n}\n\n\n\ntype Sample struct {\n\tFrequency int\n\tName      string\n}\n\ntype Samples []Sample\n\nfunc (s Samples) Len() int {\n\treturn len(s)\n}\n\nfunc (s Samples) Swap(i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\nfunc (s Samples) Less(i, j int) bool {\n\treturn s[j].Frequency < s[i].Frequency\n}\n\nfunc NewHistogram(name string) *Histogram {\n\treturn &Histogram{\n\t\tName: name,\n\t\tData: map[string] int {},\n\t}\n}\n\nfunc (h *Histogram) Add(sample string) {\n\tif _, ok := h.Data[sample]; ok {\n\t\th.Data[sample]++\n\t} else {\n\t\th.Data[sample] = 1\n\t}\n}\n\nfunc (h *Histogram) Samples() Samples {\n\tvar s Samples = make([]Sample, 0)\n\tfor key, frequency := range h.Data {\n\t\ts = append(s, Sample{frequency, key})\n\t}\n\tsort.Sort(s)\n\treturn s\n}\n\n\n\nfunc (h *Histogram) Print() ", "output": "{\n\tfmt.Printf(\"Histogram for %s:\\n\", h.Name)\n\ttotal := 0\n\tfor _, frequency := range h.Data {\n\t\ttotal += frequency\n\t}\n\tfmt.Printf(\" - Sample Count: %d\\n\", total)\n\tfmt.Printf(\"=========================\\n\")\n\tsamples := h.Samples()\n\tmaxLen  := 1\n\tfor _, sample := range samples {\n\t\tif len(sample.Name) > maxLen {\n\t\t\tmaxLen = len(sample.Name)\n\t\t}\n\t}\n\tformat := fmt.Sprintf(\" %%%ds: %%d\\n\", maxLen)\n\tfor _, sample := range samples {\n\t\tkey := sample.Name\n\t\tfrequency := sample.Frequency\n\t\tfmt.Printf(format, key, frequency)\n\t}\n}"}
{"input": "package storage\n\nimport (\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apiserver/pkg/registry/generic\"\n\tgenericregistry \"k8s.io/apiserver/pkg/registry/generic/registry\"\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/apis/rbac\"\n\t\"k8s.io/kubernetes/pkg/registry/rbac/clusterrolebinding\"\n)\n\n\ntype REST struct {\n\t*genericregistry.Store\n}\n\n\n\n\nfunc NewREST(optsGetter generic.RESTOptionsGetter) *REST ", "output": "{\n\tstore := &genericregistry.Store{\n\t\tCopier:                   api.Scheme,\n\t\tNewFunc:                  func() runtime.Object { return &rbac.ClusterRoleBinding{} },\n\t\tNewListFunc:              func() runtime.Object { return &rbac.ClusterRoleBindingList{} },\n\t\tDefaultQualifiedResource: rbac.Resource(\"clusterrolebindings\"),\n\n\t\tCreateStrategy: clusterrolebinding.Strategy,\n\t\tUpdateStrategy: clusterrolebinding.Strategy,\n\t\tDeleteStrategy: clusterrolebinding.Strategy,\n\t}\n\toptions := &generic.StoreOptions{RESTOptions: optsGetter}\n\tif err := store.CompleteWithOptions(options); err != nil {\n\t\tpanic(err) \n\t}\n\n\treturn &REST{store}\n}"}
{"input": "package dev\n\nimport \"fmt\"\n\n\n\ntype Configuration struct {\n\tid    uint32\n\tnodes []*Node\n\tn     int\n\tmgr   *Manager\n\tqspec QuorumSpec\n\terrs  chan CallGRPCError\n}\n\n\n\nfunc (c *Configuration) SubError() <-chan CallGRPCError {\n\treturn c.errs\n}\n\n\nfunc (c *Configuration) ID() uint32 {\n\treturn c.id\n}\n\n\n\n\n\n\n\n\nfunc (c *Configuration) Nodes() []*Node {\n\treturn c.nodes\n}\n\n\nfunc (c *Configuration) Size() int {\n\treturn c.n\n}\n\nfunc (c *Configuration) String() string {\n\treturn fmt.Sprintf(\"configuration %d\", c.id)\n}\n\nfunc (c *Configuration) tstring() string {\n\treturn fmt.Sprintf(\"config-%d\", c.id)\n}\n\n\n\nfunc Equal(a, b *Configuration) bool { return a.id == b.id }\n\n\n\n\nfunc NewTestConfiguration(q, n int) *Configuration {\n\treturn &Configuration{\n\t\tnodes: make([]*Node, n),\n\t}\n}\n\nfunc (c *Configuration) NodeIDs() []uint32 ", "output": "{\n\tids := make([]uint32, len(c.nodes))\n\tfor i, node := range c.nodes {\n\t\tids[i] = node.ID()\n\t}\n\treturn ids\n}"}
{"input": "package router\n\ntype SurrogateGossipData struct {\n\tmessages [][]byte\n}\n\n\n\nfunc (d *SurrogateGossipData) Encode() [][]byte {\n\treturn d.messages\n}\n\nfunc (d *SurrogateGossipData) Merge(other GossipData) {\n\td.messages = append(d.messages, other.(*SurrogateGossipData).messages...)\n}\n\n\n\ntype SurrogateGossiper struct{}\n\nfunc (*SurrogateGossiper) OnGossipUnicast(sender PeerName, msg []byte) error {\n\treturn nil\n}\n\nfunc (*SurrogateGossiper) OnGossipBroadcast(update []byte) (GossipData, error) {\n\treturn NewSurrogateGossipData(update), nil\n}\n\nfunc (*SurrogateGossiper) Gossip() GossipData {\n\treturn nil\n}\n\nfunc (*SurrogateGossiper) OnGossip(update []byte) (GossipData, error) {\n\treturn NewSurrogateGossipData(update), nil\n}\n\nvar (\n\tsurrogateGossiper SurrogateGossiper\n)\n\nfunc NewSurrogateGossipData(msg []byte) *SurrogateGossipData ", "output": "{\n\treturn &SurrogateGossipData{messages: [][]byte{msg}}\n}"}
{"input": "package runtime\n\nimport _ \"unsafe\" \n\n\n\n\nfunc bytes_Compare(s1, s2 []byte) int {\n\tl := len(s1)\n\tif len(s2) < l {\n\t\tl = len(s2)\n\t}\n\tfor i := 0; i < l; i++ {\n\t\tc1, c2 := s1[i], s2[i]\n\t\tif c1 < c2 {\n\t\t\treturn -1\n\t\t}\n\t\tif c1 > c2 {\n\t\t\treturn +1\n\t\t}\n\t}\n\tif len(s1) < len(s2) {\n\t\treturn -1\n\t}\n\tif len(s1) > len(s2) {\n\t\treturn +1\n\t}\n\treturn 0\n}\n\nfunc cmpstring(s1, s2 string) int ", "output": "{\n\tl := len(s1)\n\tif len(s2) < l {\n\t\tl = len(s2)\n\t}\n\tfor i := 0; i < l; i++ {\n\t\tc1, c2 := s1[i], s2[i]\n\t\tif c1 < c2 {\n\t\t\treturn -1\n\t\t}\n\t\tif c1 > c2 {\n\t\t\treturn +1\n\t\t}\n\t}\n\tif len(s1) < len(s2) {\n\t\treturn -1\n\t}\n\tif len(s1) > len(s2) {\n\t\treturn +1\n\t}\n\treturn 0\n}"}
{"input": "package github\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/url\"\n\n\t\"golang.org/x/oauth2\"\n\n\t\"github.com/laicosly/goth\"\n)\n\n\ntype Session struct {\n\tAuthURL     string\n\tAccessToken string\n\tState string\n\tParams url.Values\n}\n\n\n\n\n\nfunc (s *Session) Authorize(provider goth.Provider, params goth.Params) (string, error) {\n\tp := provider.(*Provider)\n\ttoken, err := p.config.Exchange(oauth2.NoContext, params.Get(\"code\"))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\ts.AccessToken = token.AccessToken\n\treturn token.AccessToken, err\n}\n\n\nfunc (s Session) Marshal() string {\n\tb, _ := json.Marshal(s)\n\treturn string(b)\n}\n\nfunc (s Session) String() string {\n\treturn s.Marshal()\n}\n\nfunc (s Session) GetAuthURL() (string, error) ", "output": "{\n\tif s.AuthURL == \"\" {\n\t\treturn \"\", errors.New(\"an AuthURL has not be set\")\n\t}\n\treturn s.AuthURL, nil\n}"}
{"input": "package arangolite\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc longRequest(w http.ResponseWriter, r *http.Request) {\n\tio.WriteString(w, \"Waiting 2 seconds...\")\n\ttime.Sleep(200 * time.Millisecond)\n\tpanic(\"The request was not canceled\")\n}\n\n\n\nfunc TestSendCanBeCanceled(t *testing.T) {\n\trunWebserver()\n\n\tclient := &http.Client{}\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:9999\", nil)\n\n\tsender := basicSender{}\n\tparent := context.Background()\n\tctx, cancel := context.WithTimeout(parent, 100*time.Millisecond)\n\tdefer cancel()\n\n\tresp, err := sender.Send(ctx, client, req)\n\n\tassertEqual(t, err.Error(), \"the database HTTP request failed: Get http://localhost:9999: context deadline exceeded\")\n\tassertTrue(t, resp == nil, \"The response of a canceled request should be nil\")\n}\n\nfunc runWebserver() ", "output": "{\n\tgo func() {\n\t\thttp.HandleFunc(\"/\", longRequest)\n\t\thttp.ListenAndServe(\":9999\", nil)\n\t}()\n}"}
{"input": "package gdb\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n\n\n\n\ntype NotificationCallback func(notification map[string]interface{})\n\n\n\n\n\n\n\n\n\n\n\nfunc (gdb *Gdb) CheckedSend(operation string, arguments ...string) (map[string]interface{}, error) {\n\tresult, err := gdb.Send(operation, arguments...)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif result[\"class\"] == \"error\" {\n\t\tif payload, isMap := result[\"payload\"].(map[string]interface{}); isMap {\n\t\t\tif msg, isString := payload[\"msg\"].(string); isString {\n\t\t\t\treturn nil, errors.New(msg)\n\t\t\t}\n\t\t}\n\t\treturn nil, errors.New(\"Unknown gdb error: \" + fmt.Sprint(result[\"payload\"]))\n\t}\n\n\treturn result, nil\n}\n\nfunc (gdb *Gdb) recordReader() {\n\tscanner := bufio.NewScanner(gdb.stdout)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tif line == terminator {\n\t\t\tcontinue\n\t\t}\n\n\t\trecord := parseRecord(line)\n\t\tsequence, isResult := record[sequenceKey]\n\t\tif isResult {\n\t\t\tdelete(record, sequenceKey)\n\t\t\tgdb.mutex.RLock()\n\t\t\tpending := gdb.pending[sequence.(string)]\n\t\t\tgdb.mutex.RUnlock()\n\t\t\tpending <- record\n\t\t} else {\n\t\t\tif gdb.onNotification != nil {\n\t\t\t\tgdb.onNotification(record)\n\t\t\t}\n\t\t}\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\tpanic(err)\n\t}\n\tgdb.recordReaderDone <- true\n}\n\nfunc (gdb *Gdb) Send(operation string, arguments ...string) (map[string]interface{}, error) ", "output": "{\n\tpending := make(chan map[string]interface{})\n\tgdb.mutex.Lock()\n\tsequence := strconv.FormatInt(gdb.sequence, 10)\n\tgdb.pending[sequence] = pending\n\tgdb.sequence++\n\tgdb.mutex.Unlock()\n\n\tbuffer := bytes.NewBufferString(fmt.Sprintf(\"%s-%s\", sequence, operation))\n\tfor _, argument := range arguments {\n\t\tbuffer.WriteByte(' ')\n\t\tif strings.ContainsAny(argument, \"\\a\\b\\f\\n\\r\\t\\v\\\\'\\\" \") {\n\t\t\targument = strconv.Quote(argument)\n\t\t}\n\t\tbuffer.WriteString(argument)\n\t}\n\tbuffer.WriteByte('\\n')\n\n\tif _, err := gdb.stdin.Write(buffer.Bytes()); err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult := <-pending\n\tgdb.mutex.Lock()\n\tdelete(gdb.pending, sequence)\n\tgdb.mutex.Unlock()\n\treturn result, nil\n}"}
{"input": "package common\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/root-gg/plik/server/Godeps/_workspace/src/github.com/root-gg/utils\"\n)\n\n\ntype Result struct {\n\tMessage string      `json:\"message\"`\n\tValue   interface{} `json:\"value\"`\n}\n\n\n\nfunc NewResult(message string, value interface{}) (r *Result) {\n\tr = new(Result)\n\tr.Message = message\n\tr.Value = value\n\treturn\n}\n\n\n\n\n\n\nfunc (result *Result) ToJSONString() string {\n\treturn string(result.ToJSON())\n}\n\nfunc (result *Result) ToJSON() []byte ", "output": "{\n\tj, err := utils.ToJson(result)\n\tif err != nil {\n\t\tmsg := fmt.Sprintf(\"Unable to serialize result %s to json : %s\", result.Message, err)\n\t\tLog().Warning(msg)\n\t\treturn []byte(\"{message:\\\"\" + msg + \"\\\"}\")\n\t}\n\n\treturn j\n}"}
{"input": "package service\n\nimport (\n\t\"errors\"\n\n\t\"github.com/juju/cmd\"\n\n\t\"github.com/juju/juju/cmd/envcmd\"\n\t\"github.com/juju/juju/cmd/juju/block\"\n)\n\n\n\ntype UnsetCommand struct {\n\tenvcmd.EnvCommandBase\n\tServiceName string\n\tOptions     []string\n\tapi         UnsetServiceAPI\n}\n\nconst unsetDoc = `\nSet one or more configuration options for the specified service to their\ndefault. See also the set commmand to set one or more configuration options for\na specified service.\n`\n\nfunc (c *UnsetCommand) Info() *cmd.Info {\n\treturn &cmd.Info{\n\t\tName:    \"unset\",\n\t\tArgs:    \"<service> name ...\",\n\t\tPurpose: \"set service config options back to their default\",\n\t\tDoc:     unsetDoc,\n\t}\n}\n\nfunc (c *UnsetCommand) Init(args []string) error {\n\tif len(args) == 0 {\n\t\treturn errors.New(\"no service name specified\")\n\t}\n\tc.ServiceName = args[0]\n\tc.Options = args[1:]\n\tif len(c.Options) == 0 {\n\t\treturn errors.New(\"no configuration options specified\")\n\t}\n\treturn nil\n}\n\n\n\ntype UnsetServiceAPI interface {\n\tClose() error\n\tServiceUnset(service string, options []string) error\n}\n\n\n\n\nfunc (c *UnsetCommand) Run(ctx *cmd.Context) error {\n\tapiclient, err := c.getAPI()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer apiclient.Close()\n\treturn block.ProcessBlockedError(apiclient.ServiceUnset(c.ServiceName, c.Options), block.BlockChange)\n}\n\nfunc (c *UnsetCommand) getAPI() (UnsetServiceAPI, error) ", "output": "{\n\tif c.api != nil {\n\t\treturn c.api, nil\n\t}\n\treturn c.NewAPIClient()\n}"}
{"input": "package receiver\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"net\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n)\n\n\ntype UDP struct {\n\tBase\n\tconn      *net.UDPConn\n\tparseChan chan *Buffer\n}\n\n\nfunc (rcv *UDP) Addr() net.Addr {\n\tif rcv.conn == nil {\n\t\treturn nil\n\t}\n\treturn rcv.conn.LocalAddr()\n}\n\nfunc (rcv *UDP) Stat(send func(metric string, value float64)) {\n\trcv.SendStat(send, \"metricsReceived\", \"errors\", \"incompleteReceived\", \"futureDropped\", \"pastDropped\",\n\t\t\"tooLongDropped\")\n}\n\nfunc (rcv *UDP) receiveWorker(ctx context.Context) {\n\tdefer rcv.conn.Close()\n\n\tbuffer := GetBuffer()\n\nReceiveLoop:\n\tfor {\n\n\t\tn, peer, err := rcv.conn.ReadFromUDP(buffer.Body[:])\n\t\tif err != nil {\n\t\t\tif strings.Contains(err.Error(), \"use of closed network connection\") {\n\t\t\t\tbreak ReceiveLoop\n\t\t\t}\n\t\t\tatomic.AddUint64(&rcv.stat.errors, 1)\n\t\t\trcv.logger.Error(\"ReadFromUDP failed\", zap.Error(err), zap.String(\"peer\", peer.String()))\n\t\t\tcontinue ReceiveLoop\n\t\t}\n\n\t\tif n > 0 {\n\t\t\tchunkSize := bytes.LastIndexByte(buffer.Body[:n], '\\n') + 1\n\n\t\t\tif chunkSize < n {\n\t\t\t}\n\n\t\t\tif chunkSize > 0 {\n\t\t\t\tbuffer.Used = chunkSize\n\t\t\t\tbuffer.Time = uint32(time.Now().Unix())\n\t\t\t\trcv.parseChan <- buffer\n\t\t\t\tbuffer = GetBuffer()\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n\n\n\nfunc (rcv *UDP) Listen(addr *net.UDPAddr) error ", "output": "{\n\treturn rcv.StartFunc(func() error {\n\t\tvar err error\n\n\t\trcv.conn, err = net.ListenUDP(\"udp\", addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\trcv.Go(func(ctx context.Context) {\n\t\t\t<-ctx.Done()\n\t\t\trcv.conn.Close()\n\t\t})\n\n\t\tfor i := 0; i < rcv.parseThreads; i++ {\n\t\t\trcv.Go(func(ctx context.Context) {\n\t\t\t\trcv.PlainParser(ctx, rcv.parseChan)\n\t\t\t})\n\t\t}\n\n\t\trcv.Go(rcv.receiveWorker)\n\n\t\treturn nil\n\t})\n}"}
{"input": "package report\n\nimport (\n\t\"github.com/elm-tangram/tangram/source\"\n\t\"github.com/elm-tangram/tangram/token\"\n)\n\n\n\ntype Reporter struct {\n\tcm      *source.CodeMap\n\temitter Emitter\n\treports map[string][]Report\n}\n\n\nfunc NewReporter(cm *source.CodeMap, emitter Emitter) *Reporter {\n\treturn &Reporter{cm, emitter, make(map[string][]Report)}\n}\n\n\nfunc (r *Reporter) IsOK() bool {\n\treturn len(r.reports) == 0\n}\n\nfunc (r *Reporter) Reports(path string) []Report {\n\treturn r.reports[path]\n}\n\n\nfunc (r *Reporter) Emit() error {\n\tfor file, reports := range r.reports {\n\t\tvar ds = make([]*Diagnostic, 0, len(reports))\n\t\tfor _, report := range reports {\n\t\t\td, err := r.makeDiagnostic(file, report)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tds = append(ds, d)\n\t\t}\n\n\t\tif err := r.emitter.Emit(file, ds); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (r *Reporter) Report(path string, report Report) {\n\tr.reports[path] = append(r.reports[path], report)\n}\n\n\n\n\n\nfunc (r *Reporter) makeDiagnostic(path string, report Report) (*Diagnostic, error) ", "output": "{\n\tif report.Pos() == token.NoPos {\n\t\treturn &Diagnostic{\n\t\t\tType:    report.Type(),\n\t\t\tMessage: report.Message(),\n\t\t}, nil\n\t}\n\n\tsrc := r.cm.Source(path)\n\tpos, err := src.LinePos(report.Pos())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tregion := report.Region()\n\n\tvar snippet *source.Snippet\n\tif region != nil {\n\t\tsnippet, err = src.Region(region.Start, region.End)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn &Diagnostic{\n\t\tType:    report.Type(),\n\t\tMessage: report.Message(),\n\t\tPos:     pos,\n\t\tRegion:  snippet,\n\t}, nil\n}"}
{"input": "package test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\n\ntype SuiteSuite struct {\n\tSuite\n}\n\n\n\n\n\nfunc (t *SuiteSuite) GetFileLine() {\n\texpected := \"drydock/runtime/base/test/test_suite_test.go:39\"\n\twrapper := func() string {\n\t\treturn t.getFileLine()\n\t}\n\tif s := wrapper(); !strings.HasSuffix(s, expected) {\n\t\tt.Errorf(\"Invalid file and line: Got: %s, Want: %s\", s, expected)\n\t}\n}\n\n\nfunc (t *SuiteSuite) TestInfof() {\n\tt.Infof(\"This is a log statement produced by t.Infof\")\n}\n\n\n\nfunc (t *SuiteSuite) VerifyMethodsWrongSignatureSkipped1(x int) {\n\tt.Fatalf(\"This should never run.\")\n}\n\n\n\nfunc (t *SuiteSuite) VerifyMethodsWrongSignatureSkipped2() int {\n\tt.Fatalf(\"This should never run.\")\n\treturn 0\n}\n\nfunc TestTestSuite(t *testing.T) ", "output": "{\n\tRunSuite(t, new(SuiteSuite))\n}"}
{"input": "package security\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n)\n\n\n\n\nfunc GenerateCSRFToken() string ", "output": "{\n\ttoken := make([]byte, 32)\n\trand.Read(token)\n\treturn base64.StdEncoding.EncodeToString(token)\n}"}
{"input": "package data\n\nimport (\n  \"github.com/twitchyliquid64/CNC/registry/syscomponents\"\n)\n\nvar trackerObj DatabaseComponent\n\ntype DatabaseComponent struct{\n  err error\n}\n\nfunc (d *DatabaseComponent)Name() string{\n  return \"Database\"\n}\nfunc (d *DatabaseComponent)IconStr() string{\n  return \"list\"\n}\nfunc (d *DatabaseComponent)IsNominal()bool{\n  return d.err == nil\n}\nfunc (d *DatabaseComponent)IsDisabled()bool{\n  return false\n}\n\nfunc (d *DatabaseComponent)Error()string{\n  if d.err == nil{\n    return \"\"\n  }\n  return d.err.Error()\n}\nfunc (d *DatabaseComponent)SetError(e error){\n  d.err = e\n}\n\nfunc trackingSetup(){\n  trackerObj = DatabaseComponent{}\n  syscomponents.Register(&trackerObj)\n}\n\nfunc tracking_notifyFault(err error){\n  syscomponents.SetError(trackerObj.Name(), err)\n}\n\nfunc (d *DatabaseComponent)IsFault()bool", "output": "{\n  return d.err != nil\n}"}
{"input": "package goqueryja\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/PuerkitoBio/goquery\"\n\t\"golang.org/x/text/encoding/japanese\"\n\t\"golang.org/x/text/transform\"\n)\n\n\n\nfunc NewUTF8Reader(r io.Reader, encoding string) (io.Reader, error) {\n\tswitch strings.ToLower(encoding) {\n\tcase \"utf-8\":\n\t\treturn r, nil\n\tcase \"euc-jp\":\n\t\treturn transform.NewReader(r, japanese.EUCJP.NewDecoder()), nil\n\tcase \"shift_jis\":\n\t\treturn transform.NewReader(r, japanese.ShiftJIS.NewDecoder()), nil\n\tcase \"iso-2022-jp\":\n\t\treturn transform.NewReader(r, japanese.ISO2022JP.NewDecoder()), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported encoding: %s\", encoding)\n\t}\n}\n\nfunc GetResponseEncoding(res *http.Response) string {\n\tcontentType := res.Header.Get(\"Content-Type\")\n\tcontentTypeLower := strings.ToLower(contentType)\n\tif index := strings.Index(contentTypeLower, \"charset=\"); index != -1 {\n\t\treturn contentType[index+len(\"charset=\"):]\n\t} else {\n\t\treturn \"\"\n\t}\n}\n\nfunc NewDocument(url_ string) (*goquery.Document, error) ", "output": "{\n\tres, err := http.Get(url_)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tencoding := GetResponseEncoding(res)\n\treader, err := NewUTF8Reader(res.Body, encoding)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn goquery.NewDocumentFromReader(reader)\n}"}
{"input": "package pass1\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc debug(f string, l ...interface{}) { fmt.Fprintf(os.Stderr, f+\"\\n\", l...) }\n\nfunc (l intfList) nameList() string {\n\tvar names stringList\n\tfor _, intf := range l {\n\t\tnames.push(intf.name)\n\t}\n\treturn \" - \" + strings.Join(names, \"\\n - \")\n}\n\n\n\nfunc (l stringerList) nameList() string {\n\tvar names stringList\n\tfor _, x := range l {\n\t\tnames.push(x.String())\n\t}\n\treturn \" - \" + strings.Join(names, \"\\n - \")\n}\n\nfunc (l stringList) nameList() string {\n\treturn \" - \" + strings.Join(l, \"\\n - \")\n}\n\nfunc (l netList) nameList() string ", "output": "{\n\tvar names stringList\n\tfor _, intf := range l {\n\t\tnames.push(intf.name)\n\t}\n\treturn \" - \" + strings.Join(names, \"\\n - \")\n}"}
{"input": "package rfc\n\n\n\nimport (\n\t\"strings\"\n\n\t\"github.com/zmap/zcrypto/x509\"\n\t\"github.com/zmap/zlint/v3/lint\"\n\t\"github.com/zmap/zlint/v3/util\"\n)\n\ntype aiaNoHTTPorLDAP struct{}\n\n\n\nfunc init() {\n\tlint.RegisterLint(&lint.Lint{\n\t\tName:          \"w_ext_aia_access_location_missing\",\n\t\tDescription:   \"When the id-ad-caIssuers accessMethod is used, at least one instance SHOULD specify an accessLocation that is an HTTP or LDAP URI\",\n\t\tCitation:      \"RFC 5280: 4.2.2.1\",\n\t\tSource:        lint.RFC5280,\n\t\tEffectiveDate: util.RFC5280Date,\n\t\tLint:          NewAiaNoHTTPorLDAP,\n\t})\n}\n\nfunc NewAiaNoHTTPorLDAP() lint.LintInterface {\n\treturn &aiaNoHTTPorLDAP{}\n}\n\n\n\nfunc (l *aiaNoHTTPorLDAP) Execute(c *x509.Certificate) *lint.LintResult {\n\tfor _, caIssuer := range c.IssuingCertificateURL {\n\t\tif caIssuer = strings.ToLower(caIssuer); strings.HasPrefix(caIssuer, \"http://\") || strings.HasPrefix(caIssuer, \"ldap://\") {\n\t\t\treturn &lint.LintResult{Status: lint.Pass}\n\t\t}\n\t}\n\treturn &lint.LintResult{Status: lint.Warn}\n}\n\nfunc (l *aiaNoHTTPorLDAP) CheckApplies(c *x509.Certificate) bool ", "output": "{\n\treturn util.IsExtInCert(c, util.AiaOID) && c.IssuingCertificateURL != nil\n}"}
{"input": "package insights\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\n\n\n\nfunc Version() string {\n\treturn version.Number\n}\n\nfunc UserAgent() string ", "output": "{\n\treturn \"Azure-SDK-For-Go/\" + Version() + \" insights/2019-11-01-preview\"\n}"}
{"input": "package net\n\nimport (\n\t\"net\"\n\t\"reflect\"\n\n\t\"github.com/segmentio/objconv\"\n)\n\nfunc init() {\n\tobjconv.Install(reflect.TypeOf(net.TCPAddr{}), TCPAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.UDPAddr{}), UDPAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.UnixAddr{}), UnixAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.IPAddr{}), IPAddrAdapter())\n\tobjconv.Install(reflect.TypeOf(net.IP(nil)), IPAdapter())\n}\n\n\nfunc TCPAddrAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeTCPAddr,\n\t\tDecode: decodeTCPAddr,\n\t}\n}\n\n\nfunc UDPAddrAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeUDPAddr,\n\t\tDecode: decodeUDPAddr,\n\t}\n}\n\n\nfunc UnixAddrAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeUnixAddr,\n\t\tDecode: decodeUnixAddr,\n\t}\n}\n\n\nfunc IPAddrAdapter() objconv.Adapter {\n\treturn objconv.Adapter{\n\t\tEncode: encodeIPAddr,\n\t\tDecode: decodeIPAddr,\n\t}\n}\n\n\n\n\nfunc IPAdapter() objconv.Adapter ", "output": "{\n\treturn objconv.Adapter{\n\t\tEncode: encodeIP,\n\t\tDecode: decodeIP,\n\t}\n}"}
{"input": "package lsb \n\n\ntype Friendly interface {\n\tIndex(i int) byte \n\tAppend(c byte)    \n\tUnpend()          \n\tString() string   \n\tPos() int         \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype LazyStringBuffer struct {\n\tori string \n\tbuf []byte \n\tw   int    \n}\n\n\nfunc New(s string) *LazyStringBuffer {\n\treturn &LazyStringBuffer{ori: s}\n}\n\n\n\n\n\nfunc (b *LazyStringBuffer) Append(c byte) {\n\tif b.buf == nil {\n\t\tif b.w < len(b.ori) && b.ori[b.w] == c {\n\t\t\tb.w++\n\t\t\treturn\n\t\t}\n\t\tb.buf = make([]byte, len(b.ori))\n\t\tcopy(b.buf, b.ori[:b.w])\n\t}\n\tb.buf[b.w] = c\n\tb.w++\n}\n\n\nfunc (b *LazyStringBuffer) Unpend() {\n\tb.w--\n}\n\n\nfunc (b *LazyStringBuffer) String() string {\n\tswitch {\n\tcase b.buf == nil:\n\t\treturn b.ori[:b.w]\n\tdefault:\n\t\treturn string(b.buf[:b.w])\n\t}\n}\n\n\nfunc (b *LazyStringBuffer) Pos() int {\n\treturn b.w\n}\n\nfunc (b *LazyStringBuffer) Index(i int) byte ", "output": "{\n\tswitch {\n\tcase b.buf == nil:\n\t\treturn b.ori[i]\n\tdefault:\n\t\treturn b.buf[i]\n\t}\n}"}
{"input": "package pmgo\n\nimport mgo \"gopkg.in/mgo.v2\"\n\ntype IterManager interface {\n\tAll(result interface{}) error\n\tClose() error\n\tDone() bool\n\tErr() error\n\tFor(result interface{}, f func() error) (err error)\n\tNext(result interface{}) bool\n\tTimeout() bool\n}\n\ntype Iter struct {\n\titer *mgo.Iter\n}\n\nfunc NewIter(iter *mgo.Iter) IterManager {\n\treturn &Iter{iter}\n}\n\nfunc (i *Iter) All(result interface{}) error {\n\treturn i.iter.All(result)\n}\n\n\n\nfunc (i *Iter) Done() bool {\n\treturn i.iter.Done()\n}\n\nfunc (i *Iter) Err() error {\n\treturn i.iter.Err()\n}\n\nfunc (i *Iter) For(result interface{}, f func() error) (err error) {\n\treturn i.iter.For(result, f)\n}\n\nfunc (i *Iter) Next(result interface{}) bool {\n\treturn i.iter.Next(result)\n}\n\nfunc (i *Iter) Timeout() bool {\n\treturn i.iter.Timeout()\n}\n\nfunc (i *Iter) Close() error ", "output": "{\n\treturn i.iter.Close()\n}"}
{"input": "package bandwidth\n\nimport (\n\t\"errors\"\n\n\t\"github.com/jordic/k8s/cloudsqlip/Godeps/_workspace/src/k8s.io/kubernetes/pkg/api/resource\"\n)\n\ntype unsupportedShaper struct {\n}\n\nfunc NewTCShaper(iface string) BandwidthShaper {\n\treturn &unsupportedShaper{}\n}\n\nfunc (f *unsupportedShaper) Limit(cidr string, egress, ingress *resource.Quantity) error {\n\treturn errors.New(\"unimplemented\")\n}\n\nfunc (f *unsupportedShaper) Reset(cidr string) error {\n\treturn nil\n}\n\n\n\nfunc (f *unsupportedShaper) ReconcileCIDR(cidr string, egress, ingress *resource.Quantity) error {\n\treturn errors.New(\"unimplemented\")\n}\n\nfunc (f *unsupportedShaper) GetCIDRs() ([]string, error) {\n\treturn []string{}, nil\n}\n\nfunc (f *unsupportedShaper) ReconcileInterface() error ", "output": "{\n\treturn errors.New(\"unimplemented\")\n}"}
{"input": "package apl\n\nimport (\n\t\"fmt\"\n\t\"github.com/dghubble/sling\"\n\t\"net/http\"\n)\n\n\ntype ComponentService struct {\n\tsling    *sling.Sling\n\tendpoint string\n}\n\n\n\n\n\ntype Component struct {\n\tID           string            `json:\"id\"`\n\tName         string            `json:\"name\"`\n\tCategory     string            `json:\"category\"`\n\tLastModified string            `json:\"last_modified\"`\n\tCreatedTime  string            `json:\"created_time\"`\n\tVersions     []string          `json:\"versions,omitempty\"`\n\tMetaData     map[string]string `json:\"meta_data,omitempty\"`\n}\n\n\ntype ComponentParams struct {\n\tCategory string `url:\"category,omitempty\"`\n\tName     string `url:\"name,omitempty\"`\n}\n\n\nfunc (c *ComponentService) List(params *ComponentParams) ([]Component, *http.Response, error) {\n\toutput := &struct {\n\t\tData []Component `json:\"data\"`\n\t}{}\n\tresp, err := doList(c.sling, c.endpoint, params, output)\n\treturn output.Data, resp, err\n}\n\n\nfunc (c *ComponentService) Get(id string) (Component, *http.Response, error) {\n\n\toutput := &struct {\n\t\tData Component `json:\"data\"`\n\t}{}\n\tpath := fmt.Sprintf(\"%s/%s\", c.endpoint, id)\n\tresp, err := doGet(c.sling, path, output)\n\treturn output.Data, resp, err\n\n}\n\nfunc NewComponentsService(sling *sling.Sling) *ComponentService ", "output": "{\n\treturn &ComponentService{\n\t\tsling:    sling,\n\t\tendpoint: \"components\",\n\t}\n}"}
{"input": "package controllers\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/astaxie/beego\"\n\t\"github.com/scmo/apayment-backend/models\"\n\t\"github.com/scmo/apayment-backend/services\"\n\t\"time\"\n)\n\n\n\n\ntype JournalController struct {\n\tbeego.Controller\n}\n\n\n\n\n\n\n\n\n\nfunc (this *JournalController) GetMonthlyStats() {\n\n\tuser := this.getUser()\n\n\tmonth, err := this.GetUint8(\"month\")\n\tif err != nil {\n\t\tthis.CustomAbort(400, \"Month not sent\")\n\t}\n\tyear, err := this.GetUint16(\"year\")\n\tif err != nil {\n\t\tthis.CustomAbort(400, \"Year not sent\")\n\t}\n\n\tif month < 1 || month > 12 || year < 1900 || year > uint16(time.Now().Year()) {\n\t\tthis.CustomAbort(400, \"Value not possible for one of the parameter. Year must be a 4 digit integer. Month parameter must be a interger between 1 and 31.\")\n\t}\n\n\tmonthlyStats, err := services.GetMonthlyStats(user.TVD, month, year)\n\tif err != nil {\n\t\tthis.CustomAbort(501, \"Internal Error \"+err.Error())\n\t}\n\tthis.Data[\"json\"] = monthlyStats\n\tthis.ServeJSON()\n}\n\n\n\n\n\n\nfunc (this *JournalController) AddJournalEntry() {\n\tuser := this.getUser()\n\n\tvar journalEntry models.JournalEntry\n\tjson.Unmarshal(this.Ctx.Input.RequestBody, &journalEntry)\n\n\tjournalEntry.SetDate()\n\tservices.AddJournalEntry(&journalEntry)\n\n\tthis.Data[\"json\"] = user\n\tthis.ServeJSON()\n}\n\nfunc (controller *JournalController) getUser() *models.User ", "output": "{\n\tclaims, err := services.ParseToken(controller.Ctx.Request.Header.Get(\"Authorization\"))\n\tif err != nil {\n\t\tcontroller.CustomAbort(401, \"Unauthorized\")\n\t}\n\tuser, err := services.GetUserByUsername(claims.Subject)\n\tif err != nil {\n\t\tcontroller.CustomAbort(404, err.Error())\n\t}\n\treturn user\n}"}
{"input": "package versioned\n\nimport (\n\tappsv1 \"github.com/openshift/client-go/apps/clientset/versioned/typed/apps/v1\"\n\tdiscovery \"k8s.io/client-go/discovery\"\n\trest \"k8s.io/client-go/rest\"\n\tflowcontrol \"k8s.io/client-go/util/flowcontrol\"\n)\n\ntype Interface interface {\n\tDiscovery() discovery.DiscoveryInterface\n\tAppsV1() appsv1.AppsV1Interface\n\tApps() appsv1.AppsV1Interface\n}\n\n\n\ntype Clientset struct {\n\t*discovery.DiscoveryClient\n\tappsV1 *appsv1.AppsV1Client\n}\n\n\nfunc (c *Clientset) AppsV1() appsv1.AppsV1Interface {\n\treturn c.appsV1\n}\n\n\n\nfunc (c *Clientset) Apps() appsv1.AppsV1Interface {\n\treturn c.appsV1\n}\n\n\nfunc (c *Clientset) Discovery() discovery.DiscoveryInterface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.DiscoveryClient\n}\n\n\n\n\n\n\nfunc NewForConfigOrDie(c *rest.Config) *Clientset {\n\tvar cs Clientset\n\tcs.appsV1 = appsv1.NewForConfigOrDie(c)\n\n\tcs.DiscoveryClient = discovery.NewDiscoveryClientForConfigOrDie(c)\n\treturn &cs\n}\n\n\nfunc New(c rest.Interface) *Clientset {\n\tvar cs Clientset\n\tcs.appsV1 = appsv1.New(c)\n\n\tcs.DiscoveryClient = discovery.NewDiscoveryClient(c)\n\treturn &cs\n}\n\nfunc NewForConfig(c *rest.Config) (*Clientset, error) ", "output": "{\n\tconfigShallowCopy := *c\n\tif configShallowCopy.RateLimiter == nil && configShallowCopy.QPS > 0 {\n\t\tconfigShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)\n\t}\n\tvar cs Clientset\n\tvar err error\n\tcs.appsV1, err = appsv1.NewForConfig(&configShallowCopy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcs.DiscoveryClient, err = discovery.NewDiscoveryClientForConfig(&configShallowCopy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &cs, nil\n}"}
{"input": "package syscall\n\n\n\nfunc TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }\n\n\n\n\n\n\n\nfunc TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }\n\n\n\nfunc NsecToTimeval(nsec int64) Timeval {\n\tnsec += 999 \n\tusec := nsec % 1e9 / 1e3\n\tsec := nsec / 1e9\n\tif usec < 0 {\n\t\tusec += 1e6\n\t\tsec--\n\t}\n\treturn setTimeval(sec, usec)\n}\n\nfunc NsecToTimespec(nsec int64) Timespec ", "output": "{\n\tsec := nsec / 1e9\n\tnsec = nsec % 1e9\n\tif nsec < 0 {\n\t\tnsec += 1e9\n\t\tsec--\n\t}\n\treturn setTimespec(sec, nsec)\n}"}
{"input": "package sorting\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype sentence []rune\n\nfunc (s sentence) Less(i, j int) bool { return s[i] < s[j] }\nfunc (s sentence) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\n\n\n\n\nfunc CountOccurrences(s string) string {\n\tif len(s) == 0 {\n\t\treturn \"\"\n\t}\n\n\tchars := sentence(s)\n\tsort.Sort(chars)\n\tcnt := 1\n\tbuf := new(bytes.Buffer)\n\tfor i := 1; i < len(chars); i++ {\n\t\tif chars[i-1] != chars[i] {\n\t\t\tfmt.Fprintf(buf, \"(%c, %d), \", chars[i-1], cnt)\n\t\t\tcnt = 0\n\t\t}\n\t\tcnt++\n\t}\n\tfmt.Fprintf(buf, \"(%c, %d)\", chars[len(chars)-1], cnt)\n\treturn buf.String()\n}\n\nfunc (s sentence) Len() int           ", "output": "{ return len(s) }"}
{"input": "package chart\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n)\n\ntype CT_Thickness struct {\n\tValAttr ST_Thickness\n}\n\nfunc NewCT_Thickness() *CT_Thickness {\n\tret := &CT_Thickness{}\n\treturn ret\n}\n\n\n\nfunc (m *CT_Thickness) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n\tfor _, attr := range start.Attr {\n\t\tif attr.Name.Local == \"val\" {\n\t\t\tparsed, err := ParseUnionST_Thickness(attr.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tm.ValAttr = parsed\n\t\t}\n\t}\n\tfor {\n\t\ttok, err := d.Token()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing CT_Thickness: %s\", err)\n\t\t}\n\t\tif el, ok := tok.(xml.EndElement); ok && el.Name == start.Name {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (m *CT_Thickness) Validate() error {\n\treturn m.ValidateWithPath(\"CT_Thickness\")\n}\n\n\nfunc (m *CT_Thickness) ValidateWithPath(path string) error {\n\tif err := m.ValAttr.ValidateWithPath(path + \"/ValAttr\"); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (m *CT_Thickness) MarshalXML(e *xml.Encoder, start xml.StartElement) error ", "output": "{\n\tstart.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: \"val\"},\n\t\tValue: fmt.Sprintf(\"%v\", m.ValAttr)})\n\te.EncodeToken(start)\n\te.EncodeToken(xml.EndElement{Name: start.Name})\n\treturn nil\n}"}
{"input": "package containerservice\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc UserAgent() string {\n\treturn \"Azure-SDK-For-Go/\" + version.Number + \" containerservice/2018-09-30-preview\"\n}\n\n\n\n\nfunc Version() string ", "output": "{\n\treturn version.Number\n}"}
{"input": "package main\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"path\"\n\n\t\"github.com/DATA-DOG/godog\"\n\n\tqs \"github.com/yunify/qingstor-sdk-go/service\"\n)\n\n\nfunc ImageFeatureContext(s *godog.Suite) {\n\ts.Step(`^image process with key \"([^\"]*)\" and query \"([^\"]*)\"$`, imageProcessWithKeyAndQuery)\n\ts.Step(`^image process status code is (\\d+)$`, imageProcessStatusCodeIs)\n\n}\n\nvar imageName string\n\nfunc imageProcessWithKeyAndQuery(objectKey, query string) error {\n\tif bucket == nil {\n\t\treturn errors.New(\"The bucket is not exist\")\n\t}\n\tfile, err := os.Open(path.Join(\"features\", \"fixtures\", objectKey))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\timageName = objectKey\n\n\t_, err = bucket.PutObject(imageName, &qs.PutObjectInput{Body: file})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toutput, err := bucket.ImageProcess(objectKey, &qs.ImageProcessInput{\n\t\tAction: &query})\n\tif err != nil {\n\t\treturn err\n\t}\n\timageProcessOutput = output\n\treturn nil\n}\n\nvar imageProcessOutput *qs.ImageProcessOutput\n\n\n\nvar oOutput *qs.DeleteObjectOutput\n\nfunc deleteImage(imageName string) error {\n\n\tif bucket == nil {\n\t\treturn errors.New(\"The bucket is not exist\")\n\t}\n\n\toOutput, err = bucket.DeleteObject(imageName)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn checkEqual(qs.IntValue(oOutput.StatusCode), 204)\n}\n\nfunc imageProcessStatusCodeIs(statusCode int) error ", "output": "{\n\tdefer deleteImage(imageName)\n\treturn checkEqual(qs.IntValue(imageProcessOutput.StatusCode), statusCode)\n}"}
{"input": "package directory\n\nimport (\n\t\"github.com/corestoreio/csfw/config\"\n\t\"github.com/corestoreio/csfw/config/model\"\n\t\"github.com/corestoreio/csfw/store/scope\"\n\t\"github.com/juju/errgo\"\n\t\"golang.org/x/text/currency\"\n)\n\n\ntype ConfigCurrency struct {\n\tmodel.Str\n}\n\n\nfunc NewConfigCurrency(path string, opts ...model.Option) ConfigCurrency {\n\treturn ConfigCurrency{\n\t\tStr: model.NewStr(path, opts...),\n\t}\n}\n\n\n\n\n\nfunc (p ConfigCurrency) Write(w config.Writer, v Currency, s scope.Scope, id int64) error {\n\treturn p.Str.Write(w, v.String(), s, id)\n}\n\nfunc (p ConfigCurrency) Get(sg config.ScopedGetter) (Currency, error) ", "output": "{\n\tcur := p.Str.Get(sg)\n\tu, err := currency.ParseISO(cur)\n\tif err != nil {\n\t\treturn Currency{}, errgo.Mask(err)\n\t}\n\treturn Currency{Unit: u}, nil\n}"}
{"input": "package extended\n\nimport (\n\t\"instructions/base\"\n\t\"rtda\"\n)\n\n\ntype GOTO_W struct {\n\toffset int\n}\n\n\n\nfunc (self *GOTO_W) Execute(frame *rtda.Frame) {\n\tbase.Branch(frame, self.offset)\n}\n\nfunc (self *GOTO_W) FetchOperands(reader *base.BytecodeReader) ", "output": "{\n\tself.offset = int(reader.ReadInt32())\n}"}
{"input": "package imath\n\n\n\nfunc Abs(x int) int ", "output": "{\n\tif x < 0 {\n\t\treturn -x\n\t}\n\n\treturn x\n}"}
{"input": "package main\nimport (\n    \"gopkg.in/libgit2/git2go.v22\"\n    \"fmt\"\n    \"strings\"\n    \"os/exec\"\n)\n\n\n\ntype GlobalGitConfig struct {}\n\nfunc NewGlobalGitConfig() (*GlobalGitConfig) {\n    config := new(GlobalGitConfig)\n    return config\n}\n\nfunc (this *GlobalGitConfig) Host() (string, error) {\n    path, e := git.ConfigFindGlobal()\n    global, e := git.OpenOndisk(nil, path)\n    host, e := global.LookupString(\"gitlab.host\")\n    return host, e\n}\n\nfunc (this *GlobalGitConfig) Token() (string, error) {\n    path, e := git.ConfigFindGlobal()\n    global, e := git.OpenOndisk(nil, path)\n    token , e := global.LookupString(\"gitlab.token\")\n    return token, e\n}\n\nfunc (this *GlobalGitConfig) ApiPath() (string, error) {\n    apiPath := fmt.Sprintf(\"/api/v3\")\n    return apiPath, nil\n}\n\nfunc ConfigForCurrentDir() (GitConfig, error) ", "output": "{\n    path, e := exec.Command(\"git\", \"rev-parse\", \"--show-toplevel\").Output()\n    p := strings.TrimRight(string(path), \"\\n\")\n    if len(p) < 1 {\n        \n        return NewGlobalGitConfig(), e\n    }\n\n    return NewLocalGitConfig()\n}"}
{"input": "package cli\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"context\"\n\t\"github.com/spf13/cobra\"\n\n\tpb \"github.com/coreos/matchbox/matchbox/server/serverpb\"\n)\n\n\nvar groupListCmd = &cobra.Command{\n\tUse:   \"list\",\n\tShort: \"List machine groups\",\n\tLong:  `List machine groups`,\n\tRun:   runGroupListCmd,\n}\n\n\n\nfunc runGroupListCmd(cmd *cobra.Command, args []string) {\n\ttw := newTabWriter(os.Stdout)\n\tdefer tw.Flush()\n\tfmt.Fprintf(tw, \"ID\\tGROUP NAME\\tSELECTORS\\tPROFILE\\n\")\n\n\tclient := mustClientFromCmd(cmd)\n\tresp, err := client.Groups.GroupList(context.TODO(), &pb.GroupListRequest{})\n\tif err != nil {\n\t\treturn\n\t}\n\tfor _, group := range resp.Groups {\n\t\tfmt.Fprintf(tw, \"%s\\t%s\\t%#v\\t%s\\n\", group.Id, group.Name, group.Selector, group.Profile)\n\t}\n}\n\nfunc init() ", "output": "{\n\tgroupCmd.AddCommand(groupListCmd)\n}"}
{"input": "package matchers\n\nvar (\n\tTypeWoff  = newType(\"woff\", \"application/font-woff\")\n\tTypeWoff2 = newType(\"woff2\", \"application/font-woff\")\n\tTypeTtf   = newType(\"ttf\", \"application/font-sfnt\")\n\tTypeOtf   = newType(\"otf\", \"application/font-sfnt\")\n)\n\nvar Font = Map{\n\tTypeWoff:  Woff,\n\tTypeWoff2: Woff2,\n\tTypeTtf:   Ttf,\n\tTypeOtf:   Otf,\n}\n\n\n\nfunc Woff2(buf []byte) bool {\n\treturn len(buf) > 7 &&\n\t\tbuf[0] == 0x77 && buf[1] == 0x4F && buf[2] == 0x46 && buf[3] == 0x32 &&\n\t\tbuf[4] == 0x00 && buf[5] == 0x01 && buf[6] == 0x00 && buf[7] == 0x00\n}\n\nfunc Ttf(buf []byte) bool {\n\treturn len(buf) > 4 &&\n\t\tbuf[0] == 0x00 && buf[1] == 0x01 &&\n\t\tbuf[2] == 0x00 && buf[3] == 0x00 &&\n\t\tbuf[4] == 0x00\n}\n\nfunc Otf(buf []byte) bool {\n\treturn len(buf) > 4 &&\n\t\tbuf[0] == 0x4F && buf[1] == 0x54 &&\n\t\tbuf[2] == 0x54 && buf[3] == 0x4F &&\n\t\tbuf[4] == 0x00\n}\n\nfunc Woff(buf []byte) bool ", "output": "{\n\treturn len(buf) > 7 &&\n\t\tbuf[0] == 0x77 && buf[1] == 0x4F && buf[2] == 0x46 && buf[3] == 0x46 &&\n\t\tbuf[4] == 0x00 && buf[5] == 0x01 && buf[6] == 0x00 && buf[7] == 0x00\n}"}
{"input": "package gitea\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n\ntype AccessToken struct {\n\tID             int64  `json:\"id\"`\n\tName           string `json:\"name\"`\n\tToken          string `json:\"sha1\"`\n\tTokenLastEight string `json:\"token_last_eight\"`\n}\n\n\ntype ListAccessTokensOptions struct {\n\tListOptions\n}\n\n\nfunc (c *Client) ListAccessTokens(opts ListAccessTokensOptions) ([]*AccessToken, *Response, error) {\n\tif len(c.username) == 0 {\n\t\treturn nil, nil, fmt.Errorf(\"\\\"username\\\" not set: only BasicAuth allowed\")\n\t}\n\topts.setDefaults()\n\ttokens := make([]*AccessToken, 0, opts.PageSize)\n\tresp, err := c.getParsedResponse(\"GET\", fmt.Sprintf(\"/users/%s/tokens?%s\", c.username, opts.getURLQuery().Encode()), jsonHeader, nil, &tokens)\n\treturn tokens, resp, err\n}\n\n\ntype CreateAccessTokenOption struct {\n\tName string `json:\"name\"`\n}\n\n\nfunc (c *Client) CreateAccessToken(opt CreateAccessTokenOption) (*AccessToken, *Response, error) {\n\tif len(c.username) == 0 {\n\t\treturn nil, nil, fmt.Errorf(\"\\\"username\\\" not set: only BasicAuth allowed\")\n\t}\n\tbody, err := json.Marshal(&opt)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tt := new(AccessToken)\n\tresp, err := c.getParsedResponse(\"POST\", fmt.Sprintf(\"/users/%s/tokens\", c.username), jsonHeader, bytes.NewReader(body), t)\n\treturn t, resp, err\n}\n\n\n\n\nfunc (c *Client) DeleteAccessToken(value interface{}) (*Response, error) ", "output": "{\n\tif len(c.username) == 0 {\n\t\treturn nil, fmt.Errorf(\"\\\"username\\\" not set: only BasicAuth allowed\")\n\t}\n\n\tvar token = \"\"\n\n\tswitch reflect.ValueOf(value).Kind() {\n\tcase reflect.Int64:\n\t\ttoken = fmt.Sprintf(\"%d\", value.(int64))\n\tcase reflect.String:\n\t\tif err := c.CheckServerVersionConstraint(\">= 1.13.0\"); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttoken = value.(string)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"only string and int64 supported\")\n\t}\n\n\t_, resp, err := c.getResponse(\"DELETE\", fmt.Sprintf(\"/users/%s/tokens/%s\", c.username, token), jsonHeader, nil)\n\treturn resp, err\n}"}
{"input": "package plumb \n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\n\t\"9fans.net/go/plan9\"\n)\n\ntype ByteReadWriteCloser interface {\n\tio.ReadWriteCloser\n\tio.ByteReader\n}\n\ntype byter os.File\n\nfunc (b *byter) ReadByte() (byte, error) {\n\tf := make([]byte, 1)\n\t_, err := b.Read(f)\n\treturn f[0], err\n}\n\n\n\nfunc (b *byter) Read(buf []byte) (int, error) {\n\treturn (*os.File)(b).Read(buf)\n}\n\nfunc (b *byter) Write(buf []byte) (int, error) {\n\treturn (*os.File)(b).Write(buf)\n}\n\n\nfunc Open(name string, mode int) (ByteReadWriteCloser, error) {\n\tswitch mode {\n\tcase plan9.OREAD:\n\t\tf, err := os.Open(\"/mnt/plumb/\" + name)\n\t\treturn (*byter)(f), err\n\tcase plan9.OWRITE:\n\t\tf, err := os.OpenFile(\"/mnt/plumb/\" + name, plan9.OWRITE, 0644)\n\t\treturn (*byter)(f), err\n\t}\n\treturn nil, fmt.Errorf(\"Unsupported mode.\")\n}\n\nfunc (b *byter) Close() error ", "output": "{\n\treturn (*os.File)(b).Close()\n}"}
{"input": "package wire\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n\n\n\n\n\ntype MsgPong struct {\n\tNonce uint64\n}\n\n\n\n\n\n\n\nfunc (msg *MsgPong) BtcEncode(w io.Writer, pver uint32) error {\n\tif pver <= BIP0031Version {\n\t\tstr := fmt.Sprintf(\"pong message invalid for protocol \"+\n\t\t\t\"version %d\", pver)\n\t\treturn messageError(\"MsgPong.BtcEncode\", str)\n\t}\n\n\treturn writeElement(w, msg.Nonce)\n}\n\n\n\nfunc (msg *MsgPong) Command() string {\n\treturn CmdPong\n}\n\n\n\nfunc (msg *MsgPong) MaxPayloadLength(pver uint32) uint32 {\n\tplen := uint32(0)\n\tif pver > BIP0031Version {\n\t\tplen += 8\n\t}\n\n\treturn plen\n}\n\n\n\nfunc NewMsgPong(nonce uint64) *MsgPong {\n\treturn &MsgPong{\n\t\tNonce: nonce,\n\t}\n}\n\nfunc (msg *MsgPong) BtcDecode(r io.Reader, pver uint32) error ", "output": "{\n\tif pver <= BIP0031Version {\n\t\tstr := fmt.Sprintf(\"pong message invalid for protocol \"+\n\t\t\t\"version %d\", pver)\n\t\treturn messageError(\"MsgPong.BtcDecode\", str)\n\t}\n\n\treturn readElement(r, &msg.Nonce)\n}"}
{"input": "package parser\n\ntype Context struct {\n\tvars map[string]string \n\tuser interface{}       \n}\n\nfunc (c *Context) SetVar(key, value string) *Context {\n\tc.vars[key] = value\n\treturn c\n}\n\nfunc (c *Context) UnsetVar(key string) *Context {\n\tdelete(c.vars, key)\n\treturn c\n}\n\n\n\nfunc (c *Context) GetUserContext() interface{} {\n\treturn c.user\n}\n\nfunc (c *Context) SetUserContext(context interface{}) *Context ", "output": "{\n\tc.user = context\n\treturn c\n}"}
{"input": "package alert\n\nimport (\n\t. \"aliyun-openapi-go-sdk/core\"\n)\n\ntype GetContactGroupRequest struct {\n\tRoaRequest\n\tProjectName string\n\tGroupName   string\n}\n\nfunc (r *GetContactGroupRequest) SetProjectName(value string) {\n\tr.ProjectName = value\n\tr.PathParams.Set(\"ProjectName\", value)\n}\nfunc (r *GetContactGroupRequest) GetProjectName() string {\n\treturn r.ProjectName\n}\nfunc (r *GetContactGroupRequest) SetGroupName(value string) {\n\tr.GroupName = value\n\tr.PathParams.Set(\"GroupName\", value)\n}\nfunc (r *GetContactGroupRequest) GetGroupName() string {\n\treturn r.GroupName\n}\n\nfunc (r *GetContactGroupRequest) Init() {\n\tr.RoaRequest.Init()\n\tr.PathPattern = \"/projects/ProjectName/groups/GroupName\"\n\tr.SetMethod(\"GET\")\n\tr.SetProtocol(\"HTTP\")\n\tr.SetProduct(Product)\n}\n\ntype GetContactGroupResponse struct {\n\tcode    string `xml:\"code\" json:\"code\"`\n\tmessage string `xml:\"message\" json:\"message\"`\n\tsuccess string `xml:\"success\" json:\"success\"`\n\ttraceId string `xml:\"traceId\" json:\"traceId\"`\n\tresult  string `xml:\"result\" json:\"result\"`\n}\n\n\n\nfunc GetContactGroup(req *GetContactGroupRequest, accessId, accessSecret string) (*GetContactGroupResponse, error) ", "output": "{\n\tvar pResponse GetContactGroupResponse\n\tbody, err := ApiHttpRequest(accessId, accessSecret, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tApiUnmarshalResponse(req.GetFormat(), body, &pResponse)\n\treturn &pResponse, err\n}"}
{"input": "package starbound\n\nimport (\n\t\"io\"\n)\n\n\nfunc getInt(data []byte, n int) int {\n\treturn int(data[n])<<24 | int(data[n+1])<<16 | int(data[n+2])<<8 | int(data[n+3])\n}\n\n\ntype logger interface {\n\tFatalf(format string, args ...interface{})\n}\n\n\ntype readerAtReader struct {\n\tr   io.ReaderAt\n\toff int64\n}\n\n\n\nfunc (r *readerAtReader) Read(p []byte) (n int, err error) ", "output": "{\n\tn, err = r.r.ReadAt(p, r.off)\n\tr.off += int64(n)\n\treturn\n}"}
{"input": "package slack\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestNewSlackConfig(t *testing.T) {\n\tconf, err := newConfigGood()\n\n\tif err != nil {\n\t\tt.Log(\"could not load slack config file\")\n\t\tt.Log(err.Error())\n\t\tt.Fail()\n\t}\n\n\tif conf == nil {\n\t\tt.Log(\"conf is nil\")\n\t}\n\n\tif conf.WebhookUrl == \"\" {\n\t\tt.Log(\"conf.WebhookUrl is empty\")\n\t}\n\n\tif conf.WebhookUrl != \"http://test\" {\n\t\tt.Log(\"WebhookUrl was not the expected value: \" + conf.WebhookUrl)\n\t\tt.Fail()\n\t}\n\n\tif conf.BotUsername != \"GoShipit\" {\n\t\tt.Log(\"BotUsername exptected to be <GoShipit>. Actual <\" +\n\t\t\tconf.BotUsername + \">.\")\n\t\tt.Fail()\n\t}\n}\n\nfunc newConfigGood() (config *SlackConfig, err error) ", "output": "{\n\tconfig, err = newSlackConfig(\"testing/slack_good.json\")\n\treturn\n}"}
{"input": "package resources\n\nimport (\n\t\"github.com/nttlabs/cli/cf/models\"\n)\n\ntype ZoneResource struct {\n\tResource\n\tEntity ZoneEntity\n}\n\ntype ZoneEntity struct {\n\tName         *string               `json:\"name,omitempty\"`\n\tPriority     *int                  `json:\"priority,omitempty\"`\n\tDescription  *string               `json:\"description,omitempty\"`\n\tIsPublic     *bool                 `json:\"is_public,omitempty\"`\n\tOrgGuid      *string               `json:\"organization_guid,omitempty\"`\n\tOrganization *OrganizationResource `json:\"organization,omitempty\"`\n}\n\nfunc NewZoneEntityFromZoneParams(zone models.ZoneParams) ZoneEntity {\n\tentity := ZoneEntity{\n\t\tName:        zone.Name,\n\t\tPriority:    zone.Priority,\n\t\tDescription: zone.Description,\n\t\tIsPublic:    zone.IsPublic,\n\t\tOrgGuid:     zone.OrgGuid,\n\t}\n\treturn entity\n}\n\nfunc (resource ZoneResource) ToFields() (zone models.ZoneFields) {\n\tentity := resource.Entity\n\tzone.Guid = resource.Metadata.Guid\n\n\tif entity.Name != nil {\n\t\tzone.Name = *entity.Name\n\t}\n\tif entity.Priority != nil {\n\t\tzone.Priority = *entity.Priority\n\t}\n\tif entity.Description != nil {\n\t\tzone.Description = *entity.Description\n\t}\n\tif entity.IsPublic != nil {\n\t\tzone.IsPublic = *entity.IsPublic\n\t}\n\tif entity.OrgGuid != nil {\n\t\tzone.OrgGuid = *entity.OrgGuid\n\t}\n\tif entity.Organization != nil {\n\t\tzone.OrgName = entity.Organization.Entity.Name\n\t}\n\treturn\n}\n\n\n\nfunc (resource ZoneResource) ToModel() (zone models.Zone) ", "output": "{\n\tzone.ZoneFields = resource.ToFields()\n\treturn\n}"}
{"input": "package common\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\n\ntype FrontendRPC struct {\n\tlog          *log.Logger\n\tname         string\n\taddress      string\n\tmethodPrefix string\n}\n\n\nfunc NewFrontendRPC(name string, address string) *FrontendRPC {\n\tf := &FrontendRPC{}\n\tf.log = log.New(os.Stdout, \"[FrontendRPC:\"+name+\"] \", log.Ldate|log.Ltime|log.Lshortfile)\n\tf.name = name\n\tf.address = address\n\tf.methodPrefix = \"Frontend\"\n\n\treturn f\n}\n\n\nfunc (f *FrontendRPC) GetName(_ *interface{}, reply *string) error {\n\t*reply = f.name\n\treturn nil\n}\n\n\nfunc (f *FrontendRPC) GetConfig(_ *interface{}, reply *Config) error {\n\tvar args interface{}\n\terr := RPCCall(f.address, f.methodPrefix+\".GetConfig\", &args, reply)\n\treturn err\n}\n\n\n\nfunc (f *FrontendRPC) Read(args *EncodedReadArgs, reply *ReadReply) error {\n\terr := RPCCall(f.address, f.methodPrefix+\".Read\", args, reply)\n\treturn err\n}\n\n\nfunc (f *FrontendRPC) GetUpdates(args *GetUpdatesArgs, reply *GetUpdatesReply) error {\n\terr := RPCCall(f.address, f.methodPrefix+\".GetUpdates\", args, reply)\n\treturn err\n}\n\nfunc (f *FrontendRPC) Write(args *WriteArgs, reply *WriteReply) error ", "output": "{\n\terr := RPCCall(f.address, f.methodPrefix+\".Write\", args, reply)\n\treturn err\n}"}
{"input": "package graphdriver\n\n\nimport \"C\"\nimport (\n\t\"path/filepath\"\n\t\"unsafe\"\n\n\t\"github.com/docker/docker/pkg/mount\"\n\t\"github.com/sirupsen/logrus\"\n)\n\nconst (\n\tFsMagicZfs = FsMagic(0x2fc12fc1)\n)\n\nvar (\n\tpriority = []string{\n\t\t\"zfs\",\n\t}\n\n\tFsNames = map[FsMagic]string{\n\t\tFsMagicZfs: \"zfs\",\n\t}\n)\n\n\nfunc GetFSMagic(rootpath string) (FsMagic, error) {\n\treturn 0, nil\n}\n\ntype fsChecker struct {\n\tt FsMagic\n}\n\nfunc (c *fsChecker) IsMounted(path string) bool {\n\tm, _ := Mounted(c.t, path)\n\treturn m\n}\n\n\nfunc NewFsChecker(t FsMagic) Checker {\n\treturn &fsChecker{\n\t\tt: t,\n\t}\n}\n\n\n\n\nfunc NewDefaultChecker() Checker {\n\treturn &defaultChecker{}\n}\n\ntype defaultChecker struct {\n}\n\n\n\n\n\nfunc Mounted(fsType FsMagic, mountPath string) (bool, error) {\n\n\tcs := C.CString(filepath.Dir(mountPath))\n\tdefer C.free(unsafe.Pointer(cs))\n\tbuf := C.getstatfs(cs)\n\tdefer C.free(unsafe.Pointer(buf))\n\n\tif (buf.f_basetype[0] != 122) || (buf.f_basetype[1] != 102) || (buf.f_basetype[2] != 115) ||\n\t\t(buf.f_basetype[3] != 0) {\n\t\tlogrus.Debugf(\"[zfs] no zfs dataset found for rootdir '%s'\", mountPath)\n\t\treturn false, ErrPrerequisites\n\t}\n\n\treturn true, nil\n}\n\nfunc (c *defaultChecker) IsMounted(path string) bool ", "output": "{\n\tm, _ := mount.Mounted(path)\n\treturn m\n}"}
{"input": "package addrmgr\n\nimport (\n\t\"time\"\n\n\t\"github.com/roasbeef/btcd/wire\"\n)\n\n\n\ntype KnownAddress struct {\n\tna          *wire.NetAddress\n\tsrcAddr     *wire.NetAddress\n\tattempts    int\n\tlastattempt time.Time\n\tlastsuccess time.Time\n\ttried       bool\n\trefs        int \n}\n\n\n\n\n\n\nfunc (ka *KnownAddress) LastAttempt() time.Time {\n\treturn ka.lastattempt\n}\n\n\n\n\nfunc (ka *KnownAddress) chance() float64 {\n\tnow := time.Now()\n\tlastAttempt := now.Sub(ka.lastattempt)\n\n\tif lastAttempt < 0 {\n\t\tlastAttempt = 0\n\t}\n\n\tc := 1.0\n\n\tif lastAttempt < 10*time.Minute {\n\t\tc *= 0.01\n\t}\n\n\tfor i := ka.attempts; i > 0; i-- {\n\t\tc /= 1.5\n\t}\n\n\treturn c\n}\n\n\n\n\n\n\n\n\n\nfunc (ka *KnownAddress) isBad() bool {\n\tif ka.lastattempt.After(time.Now().Add(-1 * time.Minute)) {\n\t\treturn false\n\t}\n\n\tif ka.na.Timestamp.After(time.Now().Add(10 * time.Minute)) {\n\t\treturn true\n\t}\n\n\tif ka.na.Timestamp.Before(time.Now().Add(-1 * numMissingDays * time.Hour * 24)) {\n\t\treturn true\n\t}\n\n\tif ka.lastsuccess.IsZero() && ka.attempts >= numRetries {\n\t\treturn true\n\t}\n\n\tif !ka.lastsuccess.After(time.Now().Add(-1*minBadDays*time.Hour*24)) &&\n\t\tka.attempts >= maxFailures {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (ka *KnownAddress) NetAddress() *wire.NetAddress ", "output": "{\n\treturn ka.na\n}"}
{"input": "package hidraw\n\nimport (\n    \"os\"\n)\n\ntype Device struct {\n    file        *os.File\n}\n\nfunc Open(info DeviceInfo) (*Device, error) {\n    device := &Device{}\n\n    if file, err := os.OpenFile(info.DevNode, os.O_RDWR, 0); err != nil {\n        return nil, err\n    } else {\n        device.file = file\n    }\n\n    return device, nil\n}\n\n\n\n\n\n\nfunc (self *Device) DevInfo() (devInfo DevInfo, err error) {\n    return self.ioctlGetDevInfo()\n}\n\n\n\n\n\nfunc (self *Device) ReportDescriptor() ([]byte, error) {\n    return self.ioctlGetReportDescriptor()\n}\n\nfunc (self *Device) Read(buf []byte) (int, error) {\n    return self.file.Read(buf)\n}\n\nfunc (self *Device) Close() {\n    self.file.Close()\n}\n\nfunc (self *Device) String() string ", "output": "{\n    return self.file.Name()\n}"}
{"input": "package minion\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\tfake_cloud \"github.com/GoogleCloudPlatform/kubernetes/pkg/cloudprovider/fake\"\n)\n\nfunc TestCloudList(t *testing.T) {\n\tinstances := []string{\"m1\", \"m2\"}\n\tfakeCloud := fake_cloud.FakeCloud{\n\t\tMachines: instances,\n\t}\n\tregistry, err := NewCloudRegistry(&fakeCloud, \".*\")\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tlist, err := registry.List()\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tif !reflect.DeepEqual(list, instances) {\n\t\tt.Errorf(\"Unexpected inequality: %#v, %#v\", list, instances)\n\t}\n}\n\n\n\nfunc TestCloudListRegexp(t *testing.T) {\n\tinstances := []string{\"m1\", \"m2\", \"n1\", \"n2\"}\n\tfakeCloud := fake_cloud.FakeCloud{\n\t\tMachines: instances,\n\t}\n\tregistry, err := NewCloudRegistry(&fakeCloud, \"m[0-9]+\")\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tlist, err := registry.List()\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\texpectedList := []string{\"m1\", \"m2\"}\n\tif !reflect.DeepEqual(list, expectedList) {\n\t\tt.Errorf(\"Unexpected inequality: %#v, %#v\", list, expectedList)\n\t}\n}\n\nfunc TestCloudContains(t *testing.T) ", "output": "{\n\tinstances := []string{\"m1\", \"m2\"}\n\tfakeCloud := fake_cloud.FakeCloud{\n\t\tMachines: instances,\n\t}\n\tregistry, err := NewCloudRegistry(&fakeCloud, \".*\")\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tcontains, err := registry.Contains(\"m1\")\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tif !contains {\n\t\tt.Errorf(\"Unexpected !contains\")\n\t}\n\n\tcontains, err = registry.Contains(\"m100\")\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tif contains {\n\t\tt.Errorf(\"Unexpected contains\")\n\t}\n}"}
{"input": "package docker\n\nimport (\n\t\"fmt\"\n)\n\n\ntype RunConfig struct {\n\tOptions []string\n\tArgs    []string\n}\n\n\nfunc NewRunConfig() *RunConfig {\n\treturn &RunConfig{\n\t\tmake([]string, 0),\n\t\tmake([]string, 0),\n\t}\n}\n\n\nfunc (s *RunConfig) Detach() {\n\ts.Options = append(s.Options, \"-d\")\n}\n\n\nfunc (s *RunConfig) PublishPort(hostPort, containerPort uint16) {\n\ts.Options = append(s.Options, \"-p\",\n\t\tfmt.Sprintf(\"%d:%d\", hostPort, containerPort))\n}\n\n\nfunc (s *RunConfig) Name(name string) {\n\ts.Options = append(s.Options, \"--name\", name)\n}\n\n\n\n\nfunc (s *RunConfig) AddArgs(args ...string) ", "output": "{\n\ts.Args = append(s.Args, args...)\n}"}
{"input": "package apimgr\n\nimport \"reflect\"\n\nfunc newSorter(manager *Manager) *sorter {\n\tapis := []Definition{}\n\tfor _, api := range manager.apiMethodPatternMap {\n\t\tapis = append(apis, api)\n\t}\n\treturn &sorter{\n\t\tManager: manager,\n\t\tapis:    apis,\n\t}\n}\n\ntype sorter struct {\n\t*Manager\n\n\tapis []Definition\n}\n\nfunc (t sorter) Len() int {\n\treturn len(t.apis)\n}\n\n\n\nfunc (t sorter) Less(i int, j int) bool {\n\tki := t.getSortKey(t.apis[i])\n\tkj := t.getSortKey(t.apis[j])\n\treturn ki < kj\n}\n\nfunc (t sorter) getSortKey(api Definition) string {\n\tpkgpath := getPackagePath(reflect.ValueOf(api.Request))\n\tkey := pkgpath + \" \" + t.GetMethodPatternKey(t.Manager, api)\n\treturn key\n}\n\nfunc (t sorter) Swap(i int, j int) ", "output": "{\n\tt.apis[i], t.apis[j] = t.apis[j], t.apis[i]\n}"}
{"input": "package syscall_test\n\nimport (\n\t\"syscall\"\n\t\"testing\"\n)\n\n\n\nfunc testalias(t *testing.T, fn string, sys1, sys2 func() error) {\n\terr := sys1().Error()\n\terrcopy := string([]byte(err))\n\tsys2()\n\tif err != errcopy {\n\t\tt.Errorf(\"syscall.%s error string changed from %q to %q\\n\", fn, errcopy, err)\n\t}\n}\n\n\n\n\n\nfunc TestPlan9Syserr(t *testing.T) ", "output": "{\n\ttestalias(t,\n\t\t\"Syscall\",\n\t\tfunc() error {\n\t\t\treturn syscall.Mkdir(\"/\", 0)\n\t\t},\n\t\tfunc() error {\n\t\t\treturn syscall.Mkdir(\"#\", 0)\n\t\t})\n\ttestalias(t,\n\t\t\"Syscall6\",\n\t\tfunc() error {\n\t\t\treturn syscall.Mount(0, 0, \"\", 0, \"\")\n\t\t},\n\t\tfunc() error {\n\t\t\treturn syscall.Mount(-1, 0, \"\", 0, \"\")\n\t\t})\n\ttestalias(t,\n\t\t\"seek\",\n\t\tfunc() error {\n\t\t\t_, err := syscall.Seek(0, 0, -1)\n\t\t\treturn err\n\t\t},\n\t\tfunc() error {\n\t\t\t_, err := syscall.Seek(-1, 0, 0)\n\t\t\treturn err\n\t\t})\n}"}
{"input": "package client \n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\n\t\"github.com/docker/docker/api/types/swarm\"\n\t\"golang.org/x/net/context\"\n)\n\n\n\n\nfunc (cli *Client) ConfigInspectWithRaw(ctx context.Context, id string) (swarm.Config, []byte, error) ", "output": "{\n\tif id == \"\" {\n\t\treturn swarm.Config{}, nil, objectNotFoundError{object: \"config\", id: id}\n\t}\n\tif err := cli.NewVersionError(\"1.30\", \"config inspect\"); err != nil {\n\t\treturn swarm.Config{}, nil, err\n\t}\n\tresp, err := cli.get(ctx, \"/configs/\"+id, nil, nil)\n\tif err != nil {\n\t\treturn swarm.Config{}, nil, wrapResponseError(err, resp, \"config\", id)\n\t}\n\tdefer ensureReaderClosed(resp)\n\n\tbody, err := ioutil.ReadAll(resp.body)\n\tif err != nil {\n\t\treturn swarm.Config{}, nil, err\n\t}\n\n\tvar config swarm.Config\n\trdr := bytes.NewReader(body)\n\terr = json.NewDecoder(rdr).Decode(&config)\n\n\treturn config, body, err\n}"}
{"input": "package utils\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n)\n\n\n\nfunc RandomHexString(byteLength uint32) (str string, err error) ", "output": "{\n\tslice := make([]byte, byteLength)\n\tif _, err = rand.Read(slice); err == nil {\n\t\tstr = fmt.Sprintf(\"%x\", slice)\n\t}\n\treturn\n}"}
{"input": "package bot\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n)\n\ntype WhiteList struct {\n\tpath  string\n\tnames map[string]struct{}\n\tlock  sync.Mutex\n}\n\nfunc LoadWhiteList(path string) (*WhiteList, error) {\n\tfile, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE, 0666)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to open file %s: %v\", path, err)\n\t}\n\tdefer file.Close()\n\n\tlist := make(map[string]struct{})\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tlist[scanner.Text()] = struct{}{}\n\t}\n\n\terr = scanner.Err()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinstance := &WhiteList{\n\t\tpath:  path,\n\t\tnames: list,\n\t}\n\n\treturn instance, nil\n}\n\nfunc (whitelist *WhiteList) Write() error {\n\twhitelist.lock.Lock()\n\tdefer whitelist.lock.Unlock()\n\n\treturn whitelist.write()\n}\n\n\n\nfunc (whitelist *WhiteList) Add(name string) error {\n\twhitelist.lock.Lock()\n\tdefer whitelist.lock.Unlock()\n\n\twhitelist.names[name] = struct{}{}\n\n\treturn whitelist.write()\n}\n\nfunc (whitelist *WhiteList) Contains(name string) bool {\n\t_, exists := whitelist.names[name]\n\n\treturn exists\n}\n\nfunc (whitelist *WhiteList) Remove(name string) error {\n\twhitelist.lock.Lock()\n\tdefer whitelist.lock.Unlock()\n\n\t_, exists := whitelist.names[name]\n\n\tif !exists {\n\t\treturn nil\n\t}\n\n\tdelete(whitelist.names, name)\n\n\treturn whitelist.write()\n}\n\nfunc (whitelist *WhiteList) write() error ", "output": "{\n\tfile, err := os.Create(whitelist.path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tw := bufio.NewWriter(file)\n\tfor line := range whitelist.names {\n\t\t_, err = fmt.Fprintln(w, line)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\terr = w.Flush()\n\treturn err\n}"}
{"input": "package awstasks\n\nimport (\n\t\"encoding/json\"\n\n\t\"k8s.io/kops/upup/pkg/fi\"\n)\n\n\n\n\ntype realSubnet Subnet\n\n\n\n\nvar _ fi.HasLifecycle = &Subnet{}\n\n\nfunc (o *Subnet) GetLifecycle() *fi.Lifecycle {\n\treturn o.Lifecycle\n}\n\n\nfunc (o *Subnet) SetLifecycle(lifecycle fi.Lifecycle) {\n\to.Lifecycle = &lifecycle\n}\n\nvar _ fi.HasName = &Subnet{}\n\n\nfunc (o *Subnet) GetName() *string {\n\treturn o.Name\n}\n\n\nfunc (o *Subnet) SetName(name string) {\n\to.Name = &name\n}\n\n\nfunc (o *Subnet) String() string {\n\treturn fi.TaskAsString(o)\n}\n\nfunc (o *Subnet) UnmarshalJSON(data []byte) error ", "output": "{\n\tvar jsonName string\n\tif err := json.Unmarshal(data, &jsonName); err == nil {\n\t\to.Name = &jsonName\n\t\treturn nil\n\t}\n\n\tvar r realSubnet\n\tif err := json.Unmarshal(data, &r); err != nil {\n\t\treturn err\n\t}\n\t*o = Subnet(r)\n\treturn nil\n}"}
{"input": "package engine\n\nimport (\n\t\"github.com/funkygao/go-metrics\"\n)\n\n\ntype routerMetrics struct {\n\tm map[string]metrics.Meter \n}\n\n\n\nfunc (m *routerMetrics) Update(pack *Packet) {\n\tif _, present := m.m[pack.Ident]; !present {\n\t\tm.m[pack.Ident] = metrics.NewRegisteredMeter(pack.Ident, metrics.DefaultRegistry)\n\t}\n\n\tm.m[pack.Ident].Mark(1)\n}\n\nfunc newMetrics() *routerMetrics ", "output": "{\n\treturn &routerMetrics{\n\t\tm: make(map[string]metrics.Meter, 10),\n\t}\n}"}
{"input": "package market_manager\n\n\n\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/go-openapi/runtime\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"openpitrix.io/openpitrix/test/models\"\n)\n\n\ntype DescribeMarketsReader struct {\n\tformats strfmt.Registry\n}\n\n\nfunc (o *DescribeMarketsReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {\n\tswitch response.Code() {\n\n\tcase 200:\n\t\tresult := NewDescribeMarketsOK()\n\t\tif err := result.readResponse(response, consumer, o.formats); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn result, nil\n\n\tdefault:\n\t\treturn nil, runtime.NewAPIError(\"unknown error\", response, response.Code())\n\t}\n}\n\n\n\n\n\ntype DescribeMarketsOK struct {\n\tPayload *models.OpenpitrixDescribeMarketsResponse\n}\n\nfunc (o *DescribeMarketsOK) Error() string {\n\treturn fmt.Sprintf(\"[GET /v1/markets][%d] describeMarketsOK  %+v\", 200, o.Payload)\n}\n\nfunc (o *DescribeMarketsOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {\n\n\to.Payload = new(models.OpenpitrixDescribeMarketsResponse)\n\n\tif err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc NewDescribeMarketsOK() *DescribeMarketsOK ", "output": "{\n\treturn &DescribeMarketsOK{}\n}"}
{"input": "package webservices\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Version() string {\n\treturn \"v9.0.0-beta\"\n}\n\nfunc UserAgent() string ", "output": "{\n\treturn \"Azure-SDK-For-Go/v9.0.0-beta arm-webservices/2016-05-01-preview\"\n}"}
{"input": "package leetcode\n\nconst MAX_INT32 = 1<<31 - 1\nconst MIN_INT32 = -1 << 31\n\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\nfunc maxInt(a, b int) int {\n\tif a < b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\n\nfunc minInt(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\n\nfunc absInt(num int) int {\n\tif num > 0 {\n\t\treturn num\n\t} else {\n\t\treturn -num\n\t}\n}\n\nfunc qsortInt(nums []int) []int {\n\tif len(nums) <= 1 {\n\t\treturn nums\n\t}\n\n\thead, tail := 0, len(nums)-1\n\tidx, mid := 1, nums[0]\n\tfor head < tail {\n\t\tif nums[idx] > mid {\n\t\t\tnums[idx], nums[tail] = nums[tail], nums[idx]\n\t\t\ttail--\n\t\t} else {\n\t\t\tnums[idx], nums[head] = nums[head], nums[idx]\n\t\t\thead++\n\t\t\tidx++\n\t\t}\n\t}\n\tnums[head] = mid\n\tqsortInt(nums[:head])\n\tqsortInt(nums[head+1:])\n\treturn nums\n}\n\ntype Stack struct {\n\tdata []rune\n}\n\nfunc (s *Stack) push(data rune) {\n\ts.data = append(s.data, data)\n}\n\nfunc (s *Stack) pop() rune {\n\tif len(s.data) == 0 {\n\t\treturn 0\n\t}\n\tret := s.data[len(s.data)-1]\n\ts.data = s.data[:len(s.data)-1]\n\treturn ret\n}\n\n\n\nfunc (s Stack) empty() bool ", "output": "{\n\treturn len(s.data) == 0\n}"}
{"input": "package bloomfilter\n\nimport (\n\t\"testing\"\n)\n\n\n\n\nfunc Benchmark_Add(b *testing.B) {\n\tb.ReportAllocs()\n\n\tloadStrings := []string{\n\t\t\"cat\", \"dog\", \"mate\", \"frog\", \"moose\",\n\t\t\"el capitan\", \"spruce goose\"}\n\n\tf := NewBloomFilter(15)\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, j := range loadStrings {\n\t\t\tf.Add(j)\n\t\t}\n\t}\n}\n\nfunc Benchmark_Exists(b *testing.B) {\n\tb.ReportAllocs()\n\n\tcheckStrings := []string{\n\t\t\"klingon\", \"frog\", \"donkey\",\n\t\t\"tame\", \"spruce goose\", \"light speed\",\n\t}\n\n\tf := NewBloomFilter(15)\n\n\tloadStrings := []string{\n\t\t\"cat\", \"dog\", \"mate\", \"frog\", \"moose\",\n\t\t\"el capitan\", \"spruce goose\"}\n\n\tfor _, j := range loadStrings {\n\t\tf.Add(j)\n\t}\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, j := range checkStrings {\n\t\t\t_ = f.Exists(j)\n\t\t}\n\t}\n\n}\n\nfunc Test_Exists(t *testing.T) ", "output": "{\n\tloadStrings := []string{\n\t\t\"cat\", \"dog\", \"mate\", \"frog\", \"moose\",\n\t\t\"el capitan\", \"spruce goose\"}\n\n\ttype TestCase struct {\n\t\tInput    string\n\t\tExpected bool\n\t}\n\n\ttestcases := []TestCase{\n\t\t{\"klingon\", false},\n\t\t{\"frog\", true},\n\t\t{\"donkey\", true},\n\t\t{\"tame\", true},\n\t\t{\"spruce goose\", true},\n\t\t{\"light speed\", false},\n\t}\n\n\tb := NewBloomFilter(15)\n\tfor _, j := range loadStrings {\n\t\tb.Add(j)\n\t}\n\n\tfor _, j := range testcases {\n\t\tactual := b.Exists(j.Input)\n\t\tif actual != j.Expected {\n\t\t\tt.Error(\"\\nExpected:\", j.Expected, \"\\nGot:\", actual, \"\\nFor:\", j.Input)\n\t\t}\n\t}\n}"}
{"input": "package user\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/juju/cmd\"\n\t\"github.com/juju/errors\"\n\t\"github.com/juju/names\"\n\t\"launchpad.net/gnuflag\"\n\n\t\"github.com/juju/juju/cmd/envcmd\"\n)\n\nconst userCredentialsDoc = `\nWrites out the current user and credentials to a file that can be used\nwith 'juju system login' to allow the user to access the same environments\nas the same user from another machine.\n\nExamples:\n\n    $ juju user credentials --output staging.creds\n\n    # copy the staging.creds file to another machine\n\n    $ juju system login staging --server staging.creds --keep-password\n\n\nSee Also:\n    juju system login\n`\n\nfunc newCredentialsCommand() cmd.Command {\n\treturn envcmd.WrapSystem(&credentialsCommand{})\n}\n\n\ntype credentialsCommand struct {\n\tUserCommandBase\n\tOutPath string\n}\n\n\nfunc (c *credentialsCommand) Info() *cmd.Info {\n\treturn &cmd.Info{\n\t\tName:    \"credentials\",\n\t\tPurpose: \"save the credentials and server details to a file\",\n\t\tDoc:     userCredentialsDoc,\n\t}\n}\n\n\n\n\n\nfunc (c *credentialsCommand) Run(ctx *cmd.Context) error {\n\tcreds, err := c.ConnectionCredentials()\n\tif err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\n\tfilename := c.OutPath\n\tif filename == \"\" {\n\t\tname := names.NewUserTag(creds.User).Name()\n\t\tfilename = fmt.Sprintf(\"%s.server\", name)\n\t}\n\treturn writeServerFile(c, ctx, creds.User, creds.Password, filename)\n}\n\nfunc (c *credentialsCommand) SetFlags(f *gnuflag.FlagSet) ", "output": "{\n\tf.StringVar(&c.OutPath, \"o\", \"\", \"specifies the path of the generated file\")\n\tf.StringVar(&c.OutPath, \"output\", \"\", \"\")\n}"}
{"input": "package pubsub\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/libp2p/go-libp2p-core/peer\"\n\t\"github.com/whyrusleeping/timecache\"\n)\n\n\ntype Blacklist interface {\n\tAdd(peer.ID) bool\n\tContains(peer.ID) bool\n}\n\n\ntype MapBlacklist map[peer.ID]struct{}\n\n\nfunc NewMapBlacklist() Blacklist {\n\treturn MapBlacklist(make(map[peer.ID]struct{}))\n}\n\nfunc (b MapBlacklist) Add(p peer.ID) bool {\n\tb[p] = struct{}{}\n\treturn true\n}\n\n\n\n\ntype TimeCachedBlacklist struct {\n\tsync.RWMutex\n\ttc *timecache.TimeCache\n}\n\n\nfunc NewTimeCachedBlacklist(expiry time.Duration) (Blacklist, error) {\n\tb := &TimeCachedBlacklist{tc: timecache.NewTimeCache(expiry)}\n\treturn b, nil\n}\n\n\nfunc (b *TimeCachedBlacklist) Add(p peer.ID) bool {\n\tb.Lock()\n\tdefer b.Unlock()\n\ts := p.String()\n\tif b.tc.Has(s) {\n\t\treturn false\n\t}\n\tb.tc.Add(s)\n\treturn true\n}\n\nfunc (b *TimeCachedBlacklist) Contains(p peer.ID) bool {\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\treturn b.tc.Has(p.String())\n}\n\nfunc (b MapBlacklist) Contains(p peer.ID) bool ", "output": "{\n\t_, ok := b[p]\n\treturn ok\n}"}
{"input": "package util\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"maunium.net/go/mauirc-server/interfaces\"\n)\n\nvar config interfaces.Configuration\n\n\n\n\n\nfunc GetIP(r *http.Request) string {\n\tif config.TrustHeaders() {\n\t\treturn r.Header.Get(\"X-Forwarded-For\")\n\t}\n\treturn strings.Split(r.RemoteAddr, \":\")[0]\n}\n\nfunc Init(cfg interfaces.Configuration) ", "output": "{\n\tconfig = cfg\n}"}
{"input": "package core\n\nimport (\n\t\"encoding/json\"\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/oci/oci-go-sdk/v43/common\"\n)\n\n\n\n\ntype TopologyRoutesToEntityRelationship struct {\n\n\tId1 *string `mandatory:\"true\" json:\"id1\"`\n\n\tId2 *string `mandatory:\"true\" json:\"id2\"`\n\n\tRouteRuleDetails *TopologyRoutesToRelationshipDetails `mandatory:\"true\" json:\"routeRuleDetails\"`\n}\n\n\n\n\n\nfunc (m TopologyRoutesToEntityRelationship) GetId2() *string {\n\treturn m.Id2\n}\n\nfunc (m TopologyRoutesToEntityRelationship) String() string {\n\treturn common.PointerString(m)\n}\n\n\nfunc (m TopologyRoutesToEntityRelationship) MarshalJSON() (buff []byte, e error) {\n\ttype MarshalTypeTopologyRoutesToEntityRelationship TopologyRoutesToEntityRelationship\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"type\"`\n\t\tMarshalTypeTopologyRoutesToEntityRelationship\n\t}{\n\t\t\"ROUTES_TO\",\n\t\t(MarshalTypeTopologyRoutesToEntityRelationship)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}\n\nfunc (m TopologyRoutesToEntityRelationship) GetId1() *string ", "output": "{\n\treturn m.Id1\n}"}
{"input": "package aerospike\n\nimport \"fmt\"\n\ntype privilegeCode string\n\n\ntype Privilege struct {\n\tCode privilegeCode\n\n\tNamespace string\n\n\tSetName string\n}\n\nfunc (p *Privilege) code() int {\n\tswitch p.Code {\n\tcase UserAdmin:\n\t\treturn 0\n\n\tcase SysAdmin:\n\t\treturn 1\n\n\tcase DataAdmin:\n\t\treturn 2\n\n\tcase Read:\n\t\treturn 10\n\n\tcase ReadWrite:\n\t\treturn 11\n\n\tcase ReadWriteUDF:\n\t\treturn 12\n\n\tcase Write:\n\t\treturn 13\n\t}\n\n\tpanic(\"invalid role: \" + p.Code)\n}\n\n\n\nfunc (p *Privilege) canScope() bool {\n\tif p.code() >= 10 {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc privilegeFrom(code uint8) privilegeCode ", "output": "{\n\tswitch code {\n\tcase 0:\n\t\treturn UserAdmin\n\n\tcase 1:\n\t\treturn SysAdmin\n\n\tcase 2:\n\t\treturn DataAdmin\n\n\tcase 10:\n\t\treturn Read\n\n\tcase 11:\n\t\treturn ReadWrite\n\n\tcase 12:\n\t\treturn ReadWriteUDF\n\n\tcase 13:\n\t\treturn Write\n\t}\n\n\tpanic(fmt.Sprintf(\"invalid privilege code: %v\", code))\n}"}
{"input": "package uuid\n\n\n\nconst (\n\tvariantIndex = 8\n\tversionIndex = 6\n)\n\n\ntype UUIDArray [length]byte\n\nfunc (UUIDArray) Size() int {\n\treturn length\n}\n\nfunc (o UUIDArray) Version() int {\n\treturn int(o[versionIndex]) >> 4\n}\n\nfunc (o *UUIDArray) setVersion(pVersion int) {\n\to[versionIndex] &= 0x0F\n\to[versionIndex] |= byte(pVersion) << 4\n}\n\nfunc (o *UUIDArray) Variant() byte {\n\treturn variant(o[variantIndex])\n}\n\n\n\nfunc (o *UUIDArray) Unmarshal(pData []byte) {\n\tcopy(o[:], pData)\n}\n\nfunc (o *UUIDArray) Bytes() []byte {\n\treturn o[:]\n}\n\nfunc (o UUIDArray) String() string {\n\treturn formatter(&o, format)\n}\n\nfunc (o UUIDArray) Format(pFormat Format) string {\n\treturn formatter(&o, pFormat)\n}\n\n\n\nfunc (o *UUIDArray) setRFC4122Variant() {\n\to[variantIndex] &= 0x3F\n\to[variantIndex] |= ReservedRFC4122\n}\n\n\nfunc (o *UUIDArray) MarshalBinary() ([]byte, error) {\n\treturn o.Bytes(), nil\n}\n\n\nfunc (o *UUIDArray) UnmarshalBinary(pData []byte) error {\n\treturn UnmarshalBinary(o, pData)\n}\n\nfunc (o *UUIDArray) setVariant(pVariant byte) ", "output": "{\n\tsetVariant(&o[variantIndex], pVariant)\n}"}
{"input": "package colony\n\nimport ()\n\ntype Colony struct {\n\tNodes []ListeningNoder\n}\n\nfunc NewColony() *Colony {\n\treturn &Colony{\n\t\tNodes: make([]ListeningNoder, 0),\n\t}\n}\n\nfunc (self *Colony) AddNode(node ListeningNoder) {\n\tfor _, otherNode := range self.Nodes {\n\t\tnode.AddEdge(NewChannelEdge(otherNode, otherNode.GetResourceChan()))\n\t\totherNode.AddEdge(NewChannelEdge(node, node.GetResourceChan()))\n\t}\n\n\tself.Nodes = append(self.Nodes, node)\n}\n\n\n\nfunc (self *Colony) Listen() ", "output": "{\n\tfor _, node := range self.Nodes {\n\t\tgo node.Listen()\n\t}\n}"}
{"input": "package iso20022\n\n\ntype CashAccountType2Choice struct {\n\n\tCode *ExternalCashAccountType1Code `xml:\"Cd\"`\n\n\tProprietary *Max35Text `xml:\"Prtry\"`\n}\n\nfunc (c *CashAccountType2Choice) SetCode(value string) {\n\tc.Code = (*ExternalCashAccountType1Code)(&value)\n}\n\n\n\nfunc (c *CashAccountType2Choice) SetProprietary(value string) ", "output": "{\n\tc.Proprietary = (*Max35Text)(&value)\n}"}
{"input": "package redditnews\n\nimport (\n  \"encoding/json\"\n  \"errors\"\n  \"fmt\"\n  \"net/http\"\n)\n\n\ntype Item struct {\n  Author  string  `json:\"author\"`\n  Score   int     `json:\"score\"`\n  URL     string  `json:\"url\"`\n  Title   string  `json:\"title\"`\n}\n\ntype response struct {\n  Data1 struct {\n    Children []struct {\n      Data2 Item `json:\"data\"`\n    } `json:\"children\"`\n  } `json:\"data\"`\n}\n\n\nfunc Get(reddit string) ([]Item, error) {\n  url := fmt.Sprintf(\"http://reddit.com/r/%s.json\", reddit)\n  resp, err := http.Get(url)\n  if err != nil {\n    return nil, err\n  }\n\n  defer resp.Body.Close()\n\n  if resp.StatusCode != http.StatusOK {\n    return nil, errors.New(resp.Status)\n  }\n\n  r := new(response)\n  err = json.NewDecoder(resp.Body).Decode(r)\n  if err != nil {\n    return nil, err\n  }\n\n  items := make([]Item, len(r.Data1.Children))\n  for i, child := range r.Data1.Children {\n    items[i] = child.Data2\n  }\n  return items, nil\n}\n\n\n\nfunc (i Item) String() string ", "output": "{\n  return fmt.Sprintf(\n    \"Author: %s\\nScore: %d\\nURL: %s\\nTitle: %s\\n\\n\",\n    i.Author,\n    i.Score,\n    i.URL,\n    i.Title)\n}"}
{"input": "package i3ipc\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestGetBarConfig(t *testing.T) ", "output": "{\n\tipc, _ := GetIPCSocket()\n\n\tids, err := ipc.GetBarIds()\n\tif err != nil {\n\t\tt.Errorf(\"Getting bar IDs failed: %v\", err)\n\t}\n\n\tid := ids[0]\n\t_, err = ipc.GetBarConfig(id)\n\tif err != nil {\n\t\tt.Errorf(\"Getting bar config failed: %v\", err)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"github.com/ginuerzh/gosocks5\"\n\t\"net\"\n)\n\ntype TlsServer struct {\n\tAddr              string\n\tCertFile, KeyFile string\n}\n\n\n\nfunc (s *TlsServer) listenAndServeTLS() error {\n\tvar cert tls.Certificate\n\tvar err error\n\n\tif len(s.CertFile) == 0 || len(s.KeyFile) == 0 {\n\t\tcert, err = tls.X509KeyPair([]byte(rawCert), []byte(rawKey))\n\t} else {\n\t\tcert, err = tls.LoadX509KeyPair(s.CertFile, s.KeyFile)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconfig := &tls.Config{Certificates: []tls.Certificate{cert}}\n\tl, err := tls.Listen(\"tcp\", s.Addr, config)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer l.Close()\n\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tgo func(c net.Conn) {\n\t\t\tc = gosocks5.ServerConn(c, serverConfig)\n\t\t\tserveSocks5(c)\n\t\t}(conn)\n\t}\n\n\treturn nil\n}\n\nfunc (s *TlsServer) ListenAndServe() error ", "output": "{\n\treturn s.listenAndServeTLS()\n}"}
{"input": "package handlers\n\nimport (\n\t\"github.com/THUNDERGROOVE/SDETool2/log\"\n\t\"html/template\"\n\t\"path/filepath\"\n)\n\nvar Templates map[string]*template.Template\n\n\n\nfunc LoadTemplates() {\n\tTemplates = make(map[string]*template.Template)\n\n\tglob := []string{\"template/index.tmpl\", \"template/login.tmpl\",\n\t\t\"template/fit.tmpl\", \"template/newfit.tmpl\",\n\t\t\"template/error.tmpl\", \"template/usermanage.tmpl\",\n\t\t\"template/fits.tmpl\"}\n\tincludes := []string{\"template/base.tmpl\"}\n\tfor _, v := range glob {\n\t\tvar err error\n\t\tlog.Info(\"Attempting to load template\", v, \"with index of\", filepath.Base(v))\n\t\tfiles := append(includes, v)\n\t\tTemplates[filepath.Base(v)] = template.Must(template.ParseFiles(files...))\n\t\tif err != nil {\n\t\t\tlog.LogError(err.Error())\n\t\t}\n\t}\n}\n\nfunc init() ", "output": "{\n\tif Templates == nil {\n\t\tTemplates = make(map[string]*template.Template)\n\t}\n}"}
{"input": "package security\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"fmt\"\n\t\"syscall\"\n\n\t\"github.com/pkg/errors\"\n\n\t\"golang.org/x/crypto/bcrypt\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\n\n\n\nconst bcryptCost = bcrypt.DefaultCost\n\nfunc compareHashAndPassword(hashedPassword []byte, password string) error {\n\th := sha256.New()\n\treturn bcrypt.CompareHashAndPassword(hashedPassword, h.Sum([]byte(password)))\n}\n\n\nfunc HashPassword(password string) ([]byte, error) {\n\th := sha256.New()\n\treturn bcrypt.GenerateFromPassword(h.Sum([]byte(password)), bcryptCost)\n}\n\n\n\nfunc PromptForPassword() (string, error) {\n\tfmt.Print(\"Enter password: \")\n\tone, err := terminal.ReadPassword(syscall.Stdin)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfmt.Print(\"\\nConfirm password: \")\n\ttwo, err := terminal.ReadPassword(syscall.Stdin)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfmt.Print(\"\\n\")\n\tif !bytes.Equal(one, two) {\n\t\treturn \"\", errors.New(\"password mismatch\")\n\t}\n\n\treturn string(one), nil\n}\n\n\n\n\n\nfunc PromptForPasswordAndHash() ([]byte, error) ", "output": "{\n\tpassword, err := PromptForPassword()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn HashPassword(password)\n}"}
{"input": "package ui\n\n\ntype TranslationLanguage interface {\n\tLang() string\n\tSetLang(string)\n}\n\n\ntype Language struct {\n\tlang string\n}\n\n\n\n\n\nfunc (l *Language) SetLang(lang string) {\n\tl.lang = lang\n}\n\nfunc (l *Language) Lang() string ", "output": "{\n\treturn l.lang\n}"}
{"input": "package wxshield2\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestPacket_InsertNamed(t *testing.T) {\n\tn := Packet{}\n\twant := `INSERT INTO test (timestamp, pressure, tempa, tempb, humidity, ptemp, htemp, battery, indx) VALUES (:timestamp, :pressure, :tempa, :tempb, :humidity, :ptemp, :htemp, :battery, :indx)`\n\tif n.InsertNamed(\"test\") != want {\n\t\tt.Errorf(\"Got %q not %q\", n.InsertNamed(\"test\"), want)\n\t}\n}\n\nfunc TestPacket_Jsonable(t *testing.T) {\n\tn := Packet{}\n\t*n.Jsonable().Battery = 1.0\n\tif n.Battery.Float64 != 1.0 {\n\t\tt.Errorf(\"Should be able to set values\")\n\t}\n}\n\nfunc TestPacket_InsertEroteme(t *testing.T) ", "output": "{\n\tn := Packet{}\n\twant := `INSERT INTO test (timestamp, pressure, tempa, tempb, humidity, ptemp, htemp, battery, indx) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`\n\tif n.InsertEroteme(\"test\") != want {\n\t\tt.Errorf(\"Got %q not %q\", n.InsertEroteme(\"test\"), want)\n\t}\n}"}
{"input": "package config\n\nimport (\n\t\"github.com/minishift/minishift/pkg/minikube/constants\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\n\n\nfunc TestModifyData(t *testing.T) {\n\ttestDir, err := ioutil.TempDir(\"\", \"minishift-config-\")\n\tif err != nil {\n\t\tt.Error()\n\t}\n\tconstants.ConfigFile = filepath.Join(testDir, \"config.json\")\n\tdefer os.RemoveAll(testDir)\n\n\tverifyValueUnset(t, \"cpus\")\n\n\tpersistValue(t, \"cpus\", \"4\")\n\tverifyStoredValue(t, \"cpus\", \"4\")\n\n\tpersistValue(t, \"cpus\", \"10\")\n\tverifyStoredValue(t, \"cpus\", \"10\")\n}\n\nfunc verifyStoredValue(t *testing.T, key string, expectedValue string) {\n\tactualValue, err := get(key)\n\tif err != nil {\n\t\tt.Fatalf(\"Error getting value %s\", err)\n\t}\n\tif actualValue != expectedValue {\n\t\tt.Fatalf(\"Unexpexted value in confif. Expected '%s'. Got '%s'.\", expectedValue, actualValue)\n\t}\n}\n\nfunc verifyValueUnset(t *testing.T, key string) {\n\tactualValue, err := get(key)\n\tif err != nil {\n\t\tt.Fatalf(\"Error getting value %s\", err)\n\t}\n\tif actualValue != \"<nil>\" {\n\t\tt.Fatalf(\"Expexted '<nil>' value. Got '%s'.\", actualValue)\n\t}\n}\n\nfunc persistValue(t *testing.T, key string, value string) {\n\terr := set(key, value)\n\tif err != nil {\n\t\tt.Fatalf(\"Error setting value %s\", err)\n\t}\n}\n\nfunc TestNotFound(t *testing.T) ", "output": "{\n\terr := set(\"nonexistant\", \"10\")\n\tif err == nil {\n\t\tt.Fatal(\"Set did not return error for unknown property\")\n\t}\n}"}
{"input": "package v1\n\nimport (\n\t\"context\"\n\n\tv1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\tscheme \"k8s.io/client-go/kubernetes/scheme\"\n)\n\n\ntype NamespaceExpansion interface {\n\tFinalize(ctx context.Context, item *v1.Namespace, opts metav1.UpdateOptions) (*v1.Namespace, error)\n}\n\n\n\n\nfunc (c *namespaces) Finalize(ctx context.Context, namespace *v1.Namespace, opts metav1.UpdateOptions) (result *v1.Namespace, err error) ", "output": "{\n\tresult = &v1.Namespace{}\n\terr = c.client.Put().Resource(\"namespaces\").Name(namespace.Name).VersionedParams(&opts, scheme.ParameterCodec).SubResource(\"finalize\").Body(namespace).Do(ctx).Into(result)\n\treturn\n}"}
{"input": "package swagger\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n)\n\n\n\nfunc (prop *ModelProperty) setDefaultValue(field reflect.StructField) {\n\tif tag := field.Tag.Get(\"default\"); tag != \"\" {\n\t\tprop.DefaultValue = Special(tag)\n\t}\n}\n\nfunc (prop *ModelProperty) setEnumValues(field reflect.StructField) {\n\tif tag := field.Tag.Get(\"enum\"); tag != \"\" {\n\t\tprop.Enum = strings.Split(tag, \"|\")\n\t}\n}\n\nfunc (prop *ModelProperty) setMaximum(field reflect.StructField) {\n\tif tag := field.Tag.Get(\"maximum\"); tag != \"\" {\n\t\tprop.Maximum = tag\n\t}\n}\n\nfunc (prop *ModelProperty) setMinimum(field reflect.StructField) {\n\tif tag := field.Tag.Get(\"minimum\"); tag != \"\" {\n\t\tprop.Minimum = tag\n\t}\n}\n\nfunc (prop *ModelProperty) setUniqueItems(field reflect.StructField) {\n\ttag := field.Tag.Get(\"unique\")\n\tswitch tag {\n\tcase \"true\":\n\t\tv := true\n\t\tprop.UniqueItems = &v\n\tcase \"false\":\n\t\tv := false\n\t\tprop.UniqueItems = &v\n\t}\n}\n\nfunc (prop *ModelProperty) setPropertyMetadata(field reflect.StructField) {\n\tprop.setDescription(field)\n\tprop.setEnumValues(field)\n\tprop.setMinimum(field)\n\tprop.setMaximum(field)\n\tprop.setUniqueItems(field)\n\tprop.setDefaultValue(field)\n}\n\nfunc (prop *ModelProperty) setDescription(field reflect.StructField) ", "output": "{\n\tif tag := field.Tag.Get(\"description\"); tag != \"\" {\n\t\tprop.Description = tag\n\t}\n}"}
{"input": "package json\n\nimport \"io\"\n\n\ntype Array struct {\n\tdata []interface{}\n}\n\n\nfunc NewArray(arr []interface{}) *Array {\n\treturn &Array{arr}\n}\n\n\nfunc (a *Array) Get(i int) interface{} {\n\treturn a.data[i]\n}\n\n\nfunc (a *Array) Set(i int, v interface{}) {\n\ta.data[i] = v\n}\n\n\n\n\n\nfunc (a *Array) ToArray() []interface{} {\n\treturn a.data\n}\n\n\nfunc (a *Array) MarshalJSON() ([]byte, error) {\n\treturn []byte(a.JSON()), nil\n}\n\n\nfunc (a *Array) JSON(pretty ...bool) string {\n\treturn Stringify(&a.data, pretty...)\n}\n\n\nfunc (a *Array) WriteJSON(w io.Writer, pretty ...bool) {\n\tw.Write([]byte(a.JSON(pretty...)))\n}\n\nfunc (a *Array) Add(item interface{}) ", "output": "{\n\ta.data = append(a.data, item)\n}"}
{"input": "package retry\n\nimport (\n\t\"time\"\n)\n\ntype strategyFunc func(now time.Time) Timer\n\n\n\n\n\n\n\nfunc LimitCount(n int, strategy Strategy) Strategy {\n\treturn strategyFunc(func(now time.Time) Timer {\n\t\treturn &countLimitTimer{\n\t\t\ttimer:  strategy.NewTimer(now),\n\t\t\tremain: n,\n\t\t}\n\t})\n}\n\ntype countLimitTimer struct {\n\ttimer  Timer\n\tremain int\n}\n\nfunc (t *countLimitTimer) NextSleep(now time.Time) (time.Duration, bool) {\n\tif t.remain--; t.remain <= 0 {\n\t\treturn 0, false\n\t}\n\treturn t.timer.NextSleep(now)\n}\n\n\n\nfunc LimitTime(limit time.Duration, strategy Strategy) Strategy {\n\treturn strategyFunc(func(now time.Time) Timer {\n\t\treturn &timeLimitTimer{\n\t\t\ttimer: strategy.NewTimer(now),\n\t\t\tend:   now.Add(limit),\n\t\t}\n\t})\n}\n\ntype timeLimitTimer struct {\n\ttimer Timer\n\tend   time.Time\n}\n\nfunc (t *timeLimitTimer) NextSleep(now time.Time) (time.Duration, bool) {\n\tsleep, ok := t.timer.NextSleep(now)\n\tif ok && now.Add(sleep).After(t.end) {\n\t\treturn 0, false\n\t}\n\treturn sleep, ok\n}\n\nfunc (f strategyFunc) NewTimer(now time.Time) Timer ", "output": "{\n\treturn f(now)\n}"}
{"input": "package godspeed\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\ntype bodyWrapperFactory func(http.ResponseWriter) io.Writer\n\ntype bodyWrapper struct {\n\trespw http.ResponseWriter\n\tw     io.Writer\n\tposthandler bodyWrapperFactory\n}\n\nfunc (w *bodyWrapper) Header() http.Header {\n\treturn w.respw.Header()\n}\n\nfunc (w *bodyWrapper) Write(data []byte) (int, error) {\n\tif w.w == nil {\n\t\tw.w = w.posthandler(w.respw)\n\t}\n\treturn w.w.Write(data)\n}\n\n\n\nfunc (w *bodyWrapper) Close() error {\n\tvar err error\n\tif c, ok := w.w.(io.Closer); ok {\n\t\terr = c.Close()\n\t}\n\treturn err\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc wrapBody(respw http.ResponseWriter, writerGen bodyWrapperFactory) *bodyWrapper {\n\treturn &bodyWrapper{\n\t\trespw:       respw,\n\t\tposthandler: writerGen,\n\t}\n}\n\nfunc (w *bodyWrapper) WriteHeader(s int) ", "output": "{\n\tw.respw.WriteHeader(s)\n}"}
{"input": "package http\n\nimport (\n\t\"strconv\"\n\n\t\"go-common/library/ecode\"\n\t\"go-common/library/log\"\n\tbm \"go-common/library/net/http/blademaster\"\n)\n\n\n\nfunc audit(c *bm.Context) ", "output": "{\n\tparams := c.Request.Form\n\tbuildStr := params.Get(\"build\")\n\tmobiApp := params.Get(\"mobi_app\")\n\tbuild, err := strconv.Atoi(buildStr)\n\tif err != nil {\n\t\tlog.Error(\"stronv.ParseInt(%s) error(%v)\", buildStr, err)\n\t\tc.JSON(nil, ecode.RequestErr)\n\t\treturn\n\t}\n\tc.JSON(nil, auditSvc.Audit(c, mobiApp, build))\n}"}
{"input": "package routers\n\nimport (\n\t\"github.com/Unknwon/macaron\"\n)\n\n\n\nfunc Index(ctx *macaron.Context) ", "output": "{\n\tctx.HTML(200, \"index\") \n}"}
{"input": "package logical\n\ntype HTTPCodedError interface {\n\tError() string\n\tCode() int\n}\n\n\n\ntype codedError struct {\n\tStatus  int\n\tMessage string\n}\n\nfunc (e *codedError) Error() string {\n\treturn e.Message\n}\n\nfunc (e *codedError) Code() int {\n\treturn e.Status\n}\n\n\n\ntype StatusBadRequest struct {\n\tErr string\n}\n\n\nfunc (s *StatusBadRequest) Error() string {\n\treturn s.Err\n}\n\n\n\n\n\ntype ReplicationCodedError struct {\n\tMsg  string\n\tCode int\n}\n\nfunc (r *ReplicationCodedError) Error() string {\n\treturn r.Msg\n}\n\nfunc CodedError(status int, msg string) HTTPCodedError ", "output": "{\n\treturn &codedError{\n\t\tStatus:  status,\n\t\tMessage: msg,\n\t}\n}"}
{"input": "package nondimensionalize\n\nimport (\n\t\"math\"\n)\n\n\n\nconst (\n\tGasConstantAir = 287.87\n)\n\n\n\n\n\n\nfunc TotalTemperature(temperature, mach, gamma float64) float64 {\n\treturn temperature * (1 + ((gamma-1)/2)*math.Pow(mach, 2))\n}\n\nfunc TotalPressure(pressure, mach, gamma float64) float64 {\n\treturn pressure * math.Pow((1+((gamma-1)/2)*math.Pow(mach, 2)), gamma/(gamma-1))\n}\n\nfunc SpeedOfSound(gamma, gasConstant, temperature float64) float64 {\n\treturn math.Sqrt(gamma * gasConstant * temperature)\n}\n\nfunc Values(temperature, reynolds, Mach, gasConstant, length, gamma float64) (pressure, density float64) ", "output": "{\n\tspeedOfSound := SpeedOfSound(gamma, gasConstant, temperature)\n\tViscosityFreestream := 1.853E-5 * (math.Pow(temperature/300.0, 3.0/2.0) * (300.0 + 110.3) / (temperature + 110.3))\n\tVelocityFreestream := Mach * speedOfSound\n\tdensity = reynolds * ViscosityFreestream / (VelocityFreestream * length)\n\tpressure = density * gasConstant * temperature\n\treturn\n}"}
{"input": "package empty_dir\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n\n\t\"github.com/golang/glog\"\n\t\"github.com/opencontainers/runc/libcontainer/selinux\"\n\t\"k8s.io/kubernetes/pkg/util/mount\"\n)\n\n\nconst linuxTmpfsMagic = 0x01021994\n\n\ntype realMountDetector struct {\n\tmounter mount.Interface\n}\n\n\n\n\nfunc selinuxEnabled() bool {\n\treturn selinux.SelinuxEnabled()\n}\n\nfunc (m *realMountDetector) GetMountMedium(path string) (storageMedium, bool, error) ", "output": "{\n\tglog.V(5).Infof(\"Determining mount medium of %v\", path)\n\tnotMnt, err := m.mounter.IsLikelyNotMountPoint(path)\n\tif err != nil {\n\t\treturn 0, false, fmt.Errorf(\"IsLikelyNotMountPoint(%q): %v\", path, err)\n\t}\n\tbuf := syscall.Statfs_t{}\n\tif err := syscall.Statfs(path, &buf); err != nil {\n\t\treturn 0, false, fmt.Errorf(\"statfs(%q): %v\", path, err)\n\t}\n\n\tglog.V(5).Infof(\"Statfs_t of %v: %+v\", path, buf)\n\tif buf.Type == linuxTmpfsMagic {\n\t\treturn mediumMemory, !notMnt, nil\n\t}\n\treturn mediumUnknown, !notMnt, nil\n}"}
{"input": "package v1alpha1\n\nimport (\n\t\"fmt\"\n\n\t\"kubedb.dev/apimachinery/apis\"\n\t\"kubedb.dev/apimachinery/apis/catalog\"\n\t\"kubedb.dev/apimachinery/crds\"\n\n\t\"kmodules.xyz/client-go/apiextensions\"\n)\n\nfunc (_ RedisAutoscaler) CustomResourceDefinition() *apiextensions.CustomResourceDefinition {\n\treturn crds.MustCustomResourceDefinition(SchemeGroupVersion.WithResource(ResourcePluralRedisAutoscaler))\n}\n\nvar _ apis.ResourceInfo = &RedisAutoscaler{}\n\nfunc (r RedisAutoscaler) ResourceFQN() string {\n\treturn fmt.Sprintf(\"%s.%s\", ResourcePluralRedisAutoscaler, catalog.GroupName)\n}\n\nfunc (r RedisAutoscaler) ResourceShortCode() string {\n\treturn ResourceCodeRedisAutoscaler\n}\n\nfunc (r RedisAutoscaler) ResourceKind() string {\n\treturn ResourceKindRedisAutoscaler\n}\n\nfunc (r RedisAutoscaler) ResourceSingular() string {\n\treturn ResourceSingularRedisAutoscaler\n}\n\n\n\nfunc (r RedisAutoscaler) ValidateSpecs() error {\n\treturn nil\n}\n\nfunc (r RedisAutoscaler) ResourcePlural() string ", "output": "{\n\treturn ResourcePluralRedisAutoscaler\n}"}
{"input": "package hplot\n\nimport (\n\t\"github.com/go-hep/hbook\"\n\t\"github.com/gonum/plot\"\n\t\"github.com/gonum/plot/palette\"\n\t\"github.com/gonum/plot/palette/brewer\"\n\t\"github.com/gonum/plot/plotter\"\n\t\"github.com/gonum/plot/vg/draw\"\n)\n\n\n\ntype H2D struct {\n\tH *hbook.H2D\n\n\tPalette palette.Palette\n\n\tInfos HInfos\n\n\tp *plotter.HeatMap\n}\n\n\n\n\nfunc (h *H2D) pltr() *plotter.HeatMap {\n\tif h.p == nil {\n\t\th.p = plotter.NewHeatMap(h.H.GridXYZ(), h.Palette)\n\t}\n\treturn h.p\n}\n\n\n\nfunc (h *H2D) Plot(c draw.Canvas, p *plot.Plot) {\n\th.pltr().Plot(c, p)\n}\n\n\n\nfunc (h *H2D) DataRange() (xmin, xmax, ymin, ymax float64) {\n\treturn h.pltr().DataRange()\n}\n\n\n\n\nfunc (h *H2D) GlyphBoxes(p *plot.Plot) []plot.GlyphBox {\n\treturn h.pltr().GlyphBoxes(p)\n}\n\n\nvar _ plot.Plotter = (*H2D)(nil)\nvar _ plot.DataRanger = (*H2D)(nil)\nvar _ plot.GlyphBoxer = (*H2D)(nil)\n\nfunc NewH2D(h *hbook.H2D, p palette.Palette) *H2D ", "output": "{\n\tif p == nil {\n\t\tp, _ = brewer.GetPalette(brewer.TypeAny, \"RdYlBu\", 11)\n\t}\n\treturn &H2D{\n\t\tH:       h,\n\t\tPalette: p,\n\t}\n}"}
{"input": "package db\n\nimport (\n\t\"github.com/globalsign/mgo\"\n\t\"github.com/tsuru/config\"\n\t\"github.com/tsuru/tsuru/db/storage\"\n)\n\nconst (\n\tDefaultDatabaseURL  = \"127.0.0.1:27017\"\n\tDefaultDatabaseName = \"gandalf\"\n)\n\ntype Storage struct {\n\t*storage.Storage\n}\n\n\n\n\n\nfunc conn() (*storage.Storage, error) {\n\turl, dbname := DbConfig()\n\treturn storage.Open(url, dbname)\n}\n\nfunc Conn() (*Storage, error) {\n\tvar (\n\t\tstrg Storage\n\t\terr  error\n\t)\n\tstrg.Storage, err = conn()\n\treturn &strg, err\n}\n\nfunc DbConfig() (string, string) {\n\turl, _ := config.GetString(\"database:url\")\n\tif url == \"\" {\n\t\turl = DefaultDatabaseURL\n\t}\n\tdbname, _ := config.GetString(\"database:name\")\n\tif dbname == \"\" {\n\t\tdbname = DefaultDatabaseName\n\t}\n\treturn url, dbname\n}\n\n\nfunc (s *Storage) Repository() *storage.Collection {\n\treturn s.Collection(\"repository\")\n}\n\n\n\n\nfunc (s *Storage) Key() *storage.Collection {\n\tbodyIndex := mgo.Index{Key: []string{\"body\"}, Unique: true}\n\tnameIndex := mgo.Index{Key: []string{\"username\", \"name\"}, Unique: true}\n\tc := s.Collection(\"key\")\n\tc.EnsureIndex(bodyIndex)\n\tc.EnsureIndex(nameIndex)\n\treturn c\n}\n\nfunc (s *Storage) User() *storage.Collection ", "output": "{\n\treturn s.Collection(\"user\")\n}"}
{"input": "package converter\n\nimport (\n\t\"github.com/nono/gofpdf\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\n\ntype PdfGenerator struct {\n\tpdfObj *gofpdf.Fpdf\n}\n\n\n\nfunc NewPdf() *PdfGenerator {\n\treturn &PdfGenerator{gofpdf.New(\"L\", \"mm\", \"A4\", \"\")}\n}\n\n\n\nfunc (pdfGen *PdfGenerator) AddPngImage(imageName string) {\n\tpdfGen.pdfObj.Image(imageName, 0, 0, 0, 0, true, \"PNG\", 0, \"\")\n}\n\n\n\n\n\n\n\nfunc (pdfGen *PdfGenerator) ClosePdf(pdfName string) error {\n\treturn pdfGen.pdfObj.OutputFileAndClose(pdfName)\n\n}\n\n\n\n\nfunc SaveSWFPage(swfUrl, swfDir string) (string, error) {\n\tpageReq, errRequest := http.Get(swfUrl)\n\n\tif errRequest != nil {\n\t\treturn \"\", errRequest\n\t}\n\n\tdefer pageReq.Body.Close()\n\n\tswfImage, errImage := ioutil.ReadAll(pageReq.Body)\n\n\tif errImage != nil {\n\t\treturn \"\", errImage\n\t}\n\n\tslideIndex := strings.Index(swfUrl, \"-slide\")\n\n\tslideFileName := swfDir + string(os.PathSeparator) + swfUrl[slideIndex+1:]\n\n\tioutil.WriteFile(slideFileName, swfImage, os.ModePerm)\n\n\treturn slideFileName, nil\n\n}\n\n\n\nfunc ExecuteConversion(slideFileName string) (string, error) {\n\treplacer := strings.NewReplacer(\".swf\", \".png\")\n\timageName := replacer.Replace(slideFileName)\n\n\tswfCommand := exec.Command(\"swfrender\", slideFileName, \"-o\", imageName)\n\n\treturn imageName, swfCommand.Run()\n}\n\nfunc (pdfGen *PdfGenerator) AddJPEGImage(imageName string) ", "output": "{\n\tpdfGen.pdfObj.Image(imageName, 0, 0, 0, 0, true, \"JPEG\", 0, \"\")\n}"}
{"input": "package testers\n\nimport (\n\t\"testing\"\n\n\t\"github.com/keratin/authn-server/app/data\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar BlobStoreTesters = []func(*testing.T, data.BlobStore){\n\ttestRead,\n\ttestWriteNX,\n}\n\nfunc testRead(t *testing.T, bs data.BlobStore) {\n\tblob, err := bs.Read(\"unknown\")\n\tassert.NoError(t, err)\n\tassert.Empty(t, blob)\n\n\tok, err := bs.WriteNX(\"blob\", []byte(\"val\"))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\n\tblob, err = bs.Read(\"blob\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"val\", string(blob))\n}\n\n\n\nfunc testWriteNX(t *testing.T, bs data.BlobStore) ", "output": "{\n\tset, err := bs.WriteNX(\"key\", []byte(\"first\"))\n\tassert.NoError(t, err)\n\tassert.True(t, set)\n\n\tset, err = bs.WriteNX(\"key\", []byte(\"second\"))\n\tassert.NoError(t, err)\n\tassert.False(t, set)\n}"}
{"input": "package types\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"time\"\n)\n\n\n\ntype CommitObject struct {\n\tAuthor string\n\tMessage string\n\tTime time.Time\n\tTree Hash\n\tParents []Hash\n}\n\n\nfunc (commit *CommitObject) Serialize() []byte {\n\tbuffer := new(bytes.Buffer)\n\te := gob.NewEncoder(buffer)\n\terr := e.Encode(commit)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn buffer.Bytes()\n}\n\n\n\n\n\nfunc DeserializeCommitObject(input []byte) *CommitObject ", "output": "{\n\tbuffer := bytes.NewBuffer(input)\n\tdec := gob.NewDecoder(buffer)\n\n\tvar commit CommitObject\n\terr := dec.Decode(&commit)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &commit\n}"}
{"input": "package gwf\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n)\n\n\ntype Context struct {\n\tw http.ResponseWriter\n\tr *http.Request\n\n\tpath []string\n}\n\ntype Module interface {\n\tAction(*Context)\n}\n\ntype Dispatcher struct {\n\tmodules map[string]Module\n}\n\nfunc (c *Context) Request() *http.Request {\n\treturn c.r\n}\n\nfunc (c *Context) Writer() http.ResponseWriter {\n\treturn c.w\n}\n\n\n\nfunc (c *Context) Path(index int) (string, bool) {\n\tif index < 0 || index >= len(c.path) {\n\t\treturn \"\", false\n\t} else {\n\t\treturn c.path[index], true\n\t}\n}\n\nfunc (c *Context) Depth() int {\n\treturn len(c.path)\n}\n\n\nfunc (d *Dispatcher) AddModule(name string, m Module) {\n\tif nil == d.modules {\n\t\td.modules = make(map[string]Module)\n\t}\n\td.modules[name] = m\n}\n\nfunc (d *Dispatcher) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\n\tvar c Context\n\tc.Init(w, r)\n\n\tif name, ok := c.Path(0); ok {\n\t\tif module, ok := d.modules[name]; ok && module != nil {\n\t\t\t(module).Action(&c)\n\t\t\treturn\n\t\t}\n\t}\n\tw.WriteHeader(http.StatusNotFound)\n}\n\nfunc (c *Context) Init(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tc.w, c.r = w, r\n\n\tpath := strings.Split(r.URL.Path, \"/\")\n\tc.path = path[1:]\n}"}
{"input": "package utils\n\ntype Task struct {\n\thttpMethod string\n\texURL *ExURL\n}\n\nfunc NewTask(pMehtod string, pExURL *ExURL) Task{\n\tvar theElement Task\n\ttheElement.httpMethod = pMehtod\n\ttheElement.exURL = pExURL\n\n\treturn theElement\n}\n\n\n\nfunc (theElement *Task) GetExURL() *ExURL {\n\treturn theElement.exURL\n}\n\ntype TaskQueue struct {\n\ttheList []Task\n\ttheCurrentIndex int\n}\n\nfunc NewTaskQueue() *TaskQueue {\n\tvar theQueue *TaskQueue\n\ttheQueue = new(TaskQueue)\n\ttheQueue.theList = make([]Task, 0)\n\treturn theQueue\n}\n\nfunc (theQueue *TaskQueue) PushBack(pMethod string, pExURL *ExURL) bool {\n\tvar anElement Task\n\tanElement = NewTask(pMethod, pExURL)\n\ttheQueue.theList = append(theQueue.theList, anElement)\n\treturn true\n}\n\nfunc (theQueue *TaskQueue) PullFront() Task {\n\tvar theFrontTask Task\n\ttheFrontTask = theQueue.theList[theQueue.theCurrentIndex]\n\ttheQueue.theCurrentIndex++\n\treturn theFrontTask\n}\n\nfunc (theQueue *TaskQueue) GetLength() int {\n\treturn len(theQueue.theList)\n}\n\nfunc (theQueue *TaskQueue) GetCurrentIndex() int {\n\treturn theQueue.theCurrentIndex\n}\n\nfunc (theElement *Task) GetMethod() string", "output": "{\n\treturn theElement.httpMethod\n}"}
{"input": "package main\n\nimport (\n\t\"flag\"\n\t\"os\"\n)\n\ntype config struct {\n\tPort        string\n\tAddr        string\n\tDataDir     string\n\tContentType string\n}\n\n\n\nfunc (c *config) setAddr(defaultPort string) {\n\tif c.Port != \"\" {\n\t\tc.Addr = \":\" + c.Port\n\t}\n\n\tif c.Addr == \"\" {\n\t\tc.Addr = \":\" + os.Getenv(\"PORT\")\n\t}\n\n\tif c.Addr == \":\" {\n\t\tc.Addr = \":\" + defaultPort\n\t}\n}\n\nfunc (c *config) setDataDir(defaultDatadir string) {\n\tvar err error\n\n\tif c.DataDir == \"\" {\n\t\tc.DataDir = os.Getenv(\"DATADIR\")\n\t}\n\n\tif c.DataDir == \"\" {\n\t\tc.DataDir, err = os.Getwd()\n\t\tif err != nil {\n\t\t\tc.DataDir = defaultDatadir\n\t\t}\n\t}\n}\n\nfunc (c *config) setContentType() {\n\tc.ContentType = os.Getenv(\"CONTENT_TYPE\")\n\tif c.ContentType == \"\" {\n\t\tc.ContentType = \"application/json\"\n\t}\n}\n\nfunc (c *config) Grok(defaultPort, defaultDatadir string) ", "output": "{\n\tflag.StringVar(&c.DataDir, \"d\", defaultDatadir, \"root directory for files\")\n\tflag.StringVar(&c.Port, \"p\", defaultPort, \"port number on which to listen\")\n\n\tflag.Parse()\n\n\tc.setAddr(defaultPort)\n\tc.setDataDir(defaultDatadir)\n\tc.setContentType()\n}"}
{"input": "package tagginges\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/olivere/elastic\"\n\t\"github.com/trackit/jsonlog\"\n\n\tindexSource \"github.com/trackit/trackit/aws/usageReports/es\"\n\t\"github.com/trackit/trackit/tagging/utils\"\n)\n\nconst urlFormat = \"https:console.aws.amazon.com/es/home?region=%s#domain:resource=%s;action=dashboard;tab=TAB_OVERVIEW_ID\"\n\n\n\n\n\n\nfunc processHit(ctx context.Context, hit *elastic.SearchHit, resourceTypeString string) (utils.TaggingReportDocument, bool) {\n\tlogger := jsonlog.LoggerFromContextOrDefault(ctx)\n\tvar source indexSource.DomainReport\n\terr := json.Unmarshal(*hit.Source, &source)\n\tif err != nil {\n\t\tlogger.Error(\"Could not process report.\", map[string]interface{}{\n\t\t\t\"type\": resourceTypeString,\n\t\t})\n\t\treturn utils.TaggingReportDocument{}, false\n\t}\n\n\tregionForURL := utils.GetRegionForURL(source.Domain.Region)\n\n\tdocument := utils.TaggingReportDocument{\n\t\tAccount:      source.Account,\n\t\tResourceID:   source.Domain.DomainID,\n\t\tResourceType: resourceTypeString,\n\t\tRegion:       source.Domain.Region,\n\t\tURL:          fmt.Sprintf(urlFormat, regionForURL, source.Domain.DomainID),\n\t\tTags:         source.Domain.Tags,\n\t}\n\treturn document, true\n}\n\nfunc Process(ctx context.Context, userId int, resourceTypeString string) ([]utils.TaggingReportDocument, error) ", "output": "{\n\tlogger := jsonlog.LoggerFromContextOrDefault(ctx)\n\tlogger.Info(\"Processing reports.\", map[string]interface{}{\n\t\t\"type\": resourceTypeString,\n\t})\n\n\thits, err := fetchReports(ctx, userId)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar documents []utils.TaggingReportDocument\n\tfor _, hit := range hits {\n\t\tdocument, success := processHit(ctx, hit, resourceTypeString)\n\t\tif success {\n\t\t\tdocuments = append(documents, document)\n\t\t}\n\t}\n\n\tlogger.Info(\"Reports processed.\", map[string]interface{}{\n\t\t\"type\":  resourceTypeString,\n\t\t\"count\": len(documents),\n\t})\n\treturn documents, nil\n}"}
{"input": "package dbutil\n\nimport (\n\t\"log\"\n\t\"testing\"\n\t\"time\"\n\n\tConfig \"../config\"\n\t_ \"github.com/lib/pq\"\n)\n\nfunc dbOperation(dbHost, dbUser, dbPasswd, dbName string, t *testing.T) {\n\tconn := New(dbHost, dbUser, dbPasswd, dbName)\n\tdefer conn.Close()\n\n\tusers := conn.Rows(\"users\", \"id, openid, nickname, created\")\n\tdefer users.Close()\n\tfor users.Next() {\n\t\tvar id, openid, nickname string\n\t\tvar created time.Time\n\t\tif err := users.Scan(&id, &openid, &nickname, &created); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tlog.Println(id, openid, nickname, created.Format(time.RFC3339))\n\t}\n}\n\n\n\nfunc TestDBWithToml(t *testing.T) {\n\tlog.Println(\"[test toml]\")\n\tcfg, err := Config.GetTomlConfig(\"../config/database.toml\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tdev := cfg.Env[\"development\"]\n\tdbOperation(dev.Host, dev.Username, dev.Password, dev.Database, t)\n}\n\nfunc TestDBWithYaml(t *testing.T) ", "output": "{\n\tlog.Println(\"[test yaml]\")\n\t_, err := Config.GetConfig(\"../config/database.yml\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n}"}
{"input": "package paymill\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n)\n\nfunc (c *ApiClient) CreatePayment(token string, client *string) (*Payment, error) {\n\tvalues := url.Values{}\n\tvalues.Add(\"token\", token)\n\n\tif client != nil {\n\t\tvalues.Add(\"client\", *client)\n\t}\n\n\tresp, body := c.doRequest(\"payments\", \"POST\", nil, values)\n\n\tr, err := NewPaymentResponse(resp, body)\n\n\treturn r.Data, err\n}\n\nfunc (c *ApiClient) PaymentDetails(id string) (*Payment, error) {\n\tresource := fmt.Sprintf(\"payments/%s\", id)\n\n\tresp, body := c.doRequest(resource, \"GET\", nil, nil)\n\n\tr, err := NewPaymentResponse(resp, body)\n\n\treturn r.Data, err\n}\n\nfunc (c *ApiClient) ListPayments(order string, filter string) (payments []Payment, err error) {\n\tvalues := url.Values{}\n\tif !Empty(order) {\n\t\tvalues.Add(\"order\", order)\n\t}\n\n\tif !Empty(filter) {\n\t\tvalues.Add(\"filter\", filter)\n\t}\n\n\tresource := \"payments\"\n\n\tresp, body := c.doRequest(resource, \"GET\", values, nil)\n\n\tr, err := NewListPaymentResponse(resp, body)\n\n\treturn r.Data, err\n}\n\n\n\nfunc (c *ApiClient) DeletePayment(id string) (ok bool, err error) ", "output": "{\n\tresource := fmt.Sprintf(\"payments/%s\", id)\n\n\tresp, body := c.doRequest(resource, \"DELETE\", nil, nil)\n\n\t_, err = NewDeletePaymentResponse(resp, body)\n\n\treturn (err == nil), err\n}"}
{"input": "package fake\n\nimport (\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n\tv1beta1 \"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/apps/v1beta1\"\n)\n\ntype FakeAppsV1beta1 struct {\n\t*testing.Fake\n}\n\nfunc (c *FakeAppsV1beta1) ControllerRevisions(namespace string) v1beta1.ControllerRevisionInterface {\n\treturn &FakeControllerRevisions{c, namespace}\n}\n\nfunc (c *FakeAppsV1beta1) Deployments(namespace string) v1beta1.DeploymentInterface {\n\treturn &FakeDeployments{c, namespace}\n}\n\nfunc (c *FakeAppsV1beta1) Scales(namespace string) v1beta1.ScaleInterface {\n\treturn &FakeScales{c, namespace}\n}\n\n\n\n\n\nfunc (c *FakeAppsV1beta1) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakeAppsV1beta1) StatefulSets(namespace string) v1beta1.StatefulSetInterface ", "output": "{\n\treturn &FakeStatefulSets{c, namespace}\n}"}
{"input": "package common\n\nimport (\n\t\"github.com/graph-gophers/graphql-go/errors\"\n)\n\n\ntype InputValue struct {\n\tName    Ident\n\tType    Type\n\tDefault Literal\n\tDesc    string\n\tLoc     errors.Location\n\tTypeLoc errors.Location\n}\n\ntype InputValueList []*InputValue\n\n\n\nfunc ParseInputValue(l *Lexer) *InputValue {\n\tp := &InputValue{}\n\tp.Loc = l.Location()\n\tp.Desc = l.DescComment()\n\tp.Name = l.ConsumeIdentWithLoc()\n\tl.ConsumeToken(':')\n\tp.TypeLoc = l.Location()\n\tp.Type = ParseType(l)\n\tif l.Peek() == '=' {\n\t\tl.ConsumeToken('=')\n\t\tp.Default = ParseLiteral(l, true)\n\t}\n\treturn p\n}\n\ntype Argument struct {\n\tName  Ident\n\tValue Literal\n}\n\ntype ArgumentList []Argument\n\nfunc (l ArgumentList) Get(name string) (Literal, bool) {\n\tfor _, arg := range l {\n\t\tif arg.Name.Name == name {\n\t\t\treturn arg.Value, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc (l ArgumentList) MustGet(name string) Literal {\n\tvalue, ok := l.Get(name)\n\tif !ok {\n\t\tpanic(\"argument not found\")\n\t}\n\treturn value\n}\n\nfunc ParseArguments(l *Lexer) ArgumentList {\n\tvar args ArgumentList\n\tl.ConsumeToken('(')\n\tfor l.Peek() != ')' {\n\t\tname := l.ConsumeIdentWithLoc()\n\t\tl.ConsumeToken(':')\n\t\tvalue := ParseLiteral(l, false)\n\t\targs = append(args, Argument{Name: name, Value: value})\n\t}\n\tl.ConsumeToken(')')\n\treturn args\n}\n\nfunc (l InputValueList) Get(name string) *InputValue ", "output": "{\n\tfor _, v := range l {\n\t\tif v.Name.Name == name {\n\t\t\treturn v\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package models\n\nimport (\n\t\"time\"\n\n\t\"github.com/jinzhu/gorm\"\n)\n\ntype App struct {\n\tID       uint      `gorm:\"primary_key\"`\n\tName     string    `gorm:\"size:30;not null\"`\n\tType     string    `gorm:\"type:char;not null\"`\n\tKey      string    `gorm:\"type:char(32);not null\"`\n\tAppUsers []AppUser `gorm:\"many2many:app_user_app;\"`\n\n\tCreatedAt time.Time  `gorm:\"not null;type:datetime;default:CURRENT_TIMESTAMP\"`\n\tUpdatedAt *time.Time `gorm:\"default:NULL\"`\n\tUpdatedBy *uint      `gorm:\"default:NULL\"`\n\tDeletedAt *time.Time `gorm:\"default:NULL\"`\n}\n\n\n\n\nfunc GetApp(key string, db *gorm.DB) *gorm.DB ", "output": "{\n\tvar result App\n\n\treturn db.Where(&App{Key: key}).First(&result)\n}"}
{"input": "package workflow\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"fmt\"\n\n\t\"github.com/zmj/sfslack/sharefile\"\n)\n\ntype wfBase struct {\n\tHost\n\tsf           *sharefile.Login\n\tstarted      time.Time\n\terr          error\n\tevents       chan sharefile.WebhookSubscriptionEvent\n\tfolder       sharefile.Folder\n\tfiles        []sharefile.File\n\tsubscription *sharefile.WebhookSubscription\n}\n\nfunc newBase(host Host) *wfBase {\n\treturn &wfBase{\n\t\tHost:    host,\n\t\tsf:      host.Authenticate(),\n\t\tstarted: time.Now(),\n\t\tevents:  make(chan sharefile.WebhookSubscriptionEvent),\n\t}\n}\n\n\n\nfunc (wf *wfBase) Cleanup() error {\n\tvar err error\n\tif wf.subscription != nil && wf.sf != nil {\n\t\te := wf.sf.DeleteSubscription(context.TODO(), wf.subscription.ID)\n\t\tif e != nil {\n\t\t\terr = fmt.Errorf(\"Failed to unsubscribe: %v\", e)\n\t\t}\n\t}\n\n\treturn err\n}\n\nfunc (wf *wfBase) Event(event sharefile.WebhookSubscriptionEvent) {\n\tif wf.err != nil {\n\t\treturn \n\t}\n\tgo func() {\n\t\twf.events <- event\n\t}()\n}\n\nfunc (wf *wfBase) Err() error ", "output": "{\n\treturn wf.err\n}"}
{"input": "package config\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n)\n\n\ntype Witness struct {\n\tURL string `yaml:\"URL\"`\n}\n\n\n\n\nfunc (w Witness) Validate() error ", "output": "{\n\tif w.URL != \"\" {\n\t\tif _, err := url.Parse(w.URL); err != nil {\n\t\t\treturn fmt.Errorf(\"unparseable URL: %v\", err)\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package unix\n\nfunc NsecToTimespec(nsec int64) (ts Timespec) {\n\tts.Sec = nsec / 1e9\n\tts.Nsec = nsec % 1e9\n\treturn\n}\n\nfunc NsecToTimeval(nsec int64) (tv Timeval) {\n\tnsec += 999 \n\ttv.Usec = nsec % 1e9 / 1e3\n\ttv.Sec = int64(nsec / 1e9)\n\treturn\n}\n\n\n\nfunc (cmsg *Cmsghdr) SetLen(length int) {\n\tcmsg.Len = uint32(length)\n}\n\nfunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {\n\tpanic(\"unimplemented\")\n}\n\nfunc (iov *Iovec) SetLen(length int) ", "output": "{\n\tiov.Len = uint64(length)\n}"}
{"input": "package blobstore\n\nimport (\n\t\"io\"\n\n\t\"code.google.com/p/go.net/context\"\n)\n\ntype Blobstore interface {\n\tDel(path string) error\n\n\tGet(path string) ([]byte, error)\n\n\tGetReader(path string) (io.ReadCloser, error)\n\n\tPut(path string, data []byte) error\n\n\tPutReader(path string, r io.Reader) error\n}\n\n\nfunc Del(c context.Context, path string) error {\n\treturn FromContext(c).Del(path)\n}\n\n\nfunc Get(c context.Context, path string) ([]byte, error) {\n\treturn FromContext(c).Get(path)\n}\n\n\n\n\nfunc GetReader(c context.Context, path string) (io.ReadCloser, error) {\n\treturn FromContext(c).GetReader(path)\n}\n\n\nfunc Put(c context.Context, path string, data []byte) error {\n\treturn FromContext(c).Put(path, data)\n}\n\n\n\n\n\nfunc PutReader(c context.Context, path string, r io.Reader) error ", "output": "{\n\treturn FromContext(c).PutReader(path, r)\n}"}
{"input": "package documentdb\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\nfunc UserAgent() string {\n\treturn \"Azure-SDK-For-Go/\" + Version() + \" documentdb/2021-03-01-preview\"\n}\n\n\n\n\nfunc Version() string ", "output": "{\n\treturn version.Number\n}"}
{"input": "package dependency\n\nimport (\n\t\"testing\"\n\n\t\"github.com/hashicorp/consul/api\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestConnectCAQuery_Fetch(t *testing.T) ", "output": "{\n\n\td := NewConnectCAQuery()\n\traw, _, err := d.Fetch(testClients, nil)\n\tassert.NoError(t, err)\n\tact := raw.([]*api.CARoot)\n\tif assert.Len(t, act, 1) {\n\t\troot := act[0]\n\t\tassert.Equal(t, root.Name, \"Consul CA Root Cert\")\n\t\tassert.True(t, root.Active)\n\t\tassert.NotEmpty(t, root.RootCertPEM)\n\t}\n}"}
{"input": "package main\n\nimport \"github.com/nsf/termbox-go\"\n\ntype Menu struct {\n\tfirstTurn Cell\n}\n\n\n\nfunc (m *Menu) React(g *Game, e termbox.Event) error {\n\tswitch e.Type {\n\tcase termbox.EventError:\n\t\treturn e.Err\n\tcase termbox.EventKey:\n\t\tswitch e.Ch {\n\t\tcase 'q':\n\t\t\tg.Close()\n\t\t}\n\t\tswitch e.Key {\n\t\tcase termbox.KeyCtrlC:\n\t\t\tg.Close()\n\t\tcase termbox.KeyArrowLeft, termbox.KeyArrowRight:\n\t\t\tm.firstTurn = m.firstTurn.Reversed()\n\t\tcase termbox.KeySpace, termbox.KeyEnter:\n\t\t\tt := m.firstTurn\n\t\t\tg.SetFirstTurn(t)\n\t\t\tg.SetScene(NewCompetition(t))\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (m *Menu) SetView() {\n\ttermbox.HideCursor()\n\n\tx, y := tbxCenterXY()\n\ttbxSetText(x+4, y-1, \"Which is first?\",\n\t\ttermbox.ColorGreen, termbox.ColorDefault)\n\tswitch m.firstTurn {\n\tcase Circle:\n\t\ttbxSetText(x+4, y+1, \"Circle\",\n\t\t\ttermbox.ColorGreen|termbox.AttrBold, termbox.ColorDefault)\n\t\ttbxSetText(x+12, y+1, \"Cross\",\n\t\t\ttermbox.ColorGreen, termbox.ColorDefault)\n\tcase Cross:\n\t\ttbxSetText(x+4, y+1, \"Circle\",\n\t\t\ttermbox.ColorGreen, termbox.ColorDefault)\n\t\ttbxSetText(x+12, y+1, \"Cross\",\n\t\t\ttermbox.ColorGreen|termbox.AttrBold, termbox.ColorDefault)\n\t}\n}\n\nfunc NewMenu() *Menu ", "output": "{\n\treturn &Menu{\n\t\tfirstTurn: Circle,\n\t}\n}"}
{"input": "package gocountries\n\nimport (\n  \"errors\"\n  \"fmt\"\n  \"net/http\"\n  \"io/ioutil\"\n  \"encoding/json\"\n)\n\nconst baseURL = \"https://restcountries.eu/rest/v1/%s\"\n\ntype Country struct {\n  Name           string\n  Capital        string\n  AltSpellings   []string\n  Relevance      string\n  Region         string\n  Subregion      string\n  Translations   map[string]string\n  Population     int32\n  LatLng         []float32\n  Demonym        string\n  Area           float32\n  Gini           float32\n  Timezones      []string\n  Borders        []string\n  NativeName     string\n  CallingCodes   []string\n  TopLevelDomain []string\n  Alpha2Code     string\n  Alpha3Code     string\n  Currencies     []string\n  Languages      []string\n}\n\nfunc doRestcountriesCall(apiSuffix string) ([]byte, error) {\n  url := fmt.Sprintf(baseURL, apiSuffix)\n  res, err := http.Get(url)\n  if err != nil {\n    return []byte{}, err\n  }\n  defer res.Body.Close()\n  if res.StatusCode != 200 {\n    e := errors.New(fmt.Sprintf(\"Unexpected API status code %s\", res.Status))\n    return []byte{}, e\n  }\n  body, err := ioutil.ReadAll(res.Body)\n  if err != nil {\n    return []byte{}, err\n  }\n  return body, nil\n}\n\n\n\nfunc CountriesByCapital(name string) ([]Country, error) {\n  resData, err := doRestcountriesCall(fmt.Sprintf(\"capital/%s\", name))\n\n  if err != nil {\n    return nil, err\n  }\n  var c []Country\n  err = json.Unmarshal(resData, &c)\n  if err != nil {\n    return nil, err\n  }\n  return c, nil\n}\n\nfunc CountriesByName(name string) ([]Country, error) ", "output": "{\n  resData, err := doRestcountriesCall(fmt.Sprintf(\"name/%s\", name))\n\n  if err != nil {\n    return nil, err\n  }\n  var c []Country\n  err = json.Unmarshal(resData, &c)\n  if err != nil {\n    return nil, err\n  }\n  return c, nil\n}"}
{"input": "package packets\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n\n\ntype UnsubackPacket struct {\n\tFixedHeader\n\tMessageID uint16\n}\n\nfunc (ua *UnsubackPacket) Type() byte {\n\treturn ua.FixedHeader.MessageType\n}\nfunc (ua *UnsubackPacket) String() string {\n\tstr := fmt.Sprintf(\"%s\\n\", ua.FixedHeader)\n\tstr += fmt.Sprintf(\"MessageID: %d\", ua.MessageID)\n\treturn str\n}\n\nfunc (ua *UnsubackPacket) Write(w io.Writer) error {\n\tvar err error\n\tua.FixedHeader.RemainingLength = 2\n\tpacket := ua.FixedHeader.pack()\n\tpacket.Write(encodeUint16(ua.MessageID))\n\t_, err = packet.WriteTo(w)\n\n\treturn err\n}\n\n\n\n\n\n\n\nfunc (ua *UnsubackPacket) Details() Details {\n\treturn Details{Qos: 0, MessageID: ua.MessageID}\n}\n\nfunc (ua *UnsubackPacket) Unpack(b io.Reader) error ", "output": "{\n\tua.MessageID = decodeUint16(b)\n\n\treturn nil\n}"}
{"input": "package proto_test\n\nimport (\n\t\"testing\"\n\n\tpb \"./testdata\"\n\t\"github.com/ipfs/go-ipfs/Godeps/_workspace/src/code.google.com/p/gogoprotobuf/proto\"\n)\n\n\n\nfunc TestGetExtensionsWithMissingExtensions(t *testing.T) ", "output": "{\n\tmsg := &pb.MyMessage{}\n\text1 := &pb.Ext{}\n\tif err := proto.SetExtension(msg, pb.E_Ext_More, ext1); err != nil {\n\t\tt.Fatalf(\"Could not set ext1: %s\", ext1)\n\t}\n\texts, err := proto.GetExtensions(msg, []*proto.ExtensionDesc{\n\t\tpb.E_Ext_More,\n\t\tpb.E_Ext_Text,\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"GetExtensions() failed: %s\", err)\n\t}\n\tif exts[0] != ext1 {\n\t\tt.Errorf(\"ext1 not in returned extensions: %T %v\", exts[0], exts[0])\n\t}\n\tif exts[1] != nil {\n\t\tt.Errorf(\"ext2 in returned extensions: %T %v\", exts[1], exts[1])\n\t}\n}"}
{"input": "package app\n\nimport (\n\t\"net/url\"\n)\n\ntype Service interface {\n\tProxyPath() string\n\tURL() string\n\tBasicAuth() (username, password string, ok bool)\n\tAddSecret(parameters url.Values)\n}\n\ntype basicAuthService struct {\n\tproxyPath, url, clientId, clientSecret string\n}\n\nfunc (s basicAuthService) ProxyPath() string {\n\treturn s.proxyPath\n}\n\nfunc (s basicAuthService) URL() string {\n\treturn s.url\n}\n\nfunc (s basicAuthService) BasicAuth() (string, string, bool) {\n\treturn s.clientId, s.clientSecret, true\n}\n\nfunc (s basicAuthService) AddSecret(parameters url.Values) {\n}\n\ntype addParameterService struct {\n\tproxyPath, url, parameterName, clientSecret string\n}\n\nfunc (s addParameterService) ProxyPath() string {\n\treturn s.proxyPath\n}\n\nfunc (s addParameterService) URL() string {\n\treturn s.url\n}\n\n\n\nfunc (s addParameterService) AddSecret(parameters url.Values) {\n\tparameters.Add(s.parameterName, s.clientSecret)\n}\n\nfunc BasicAuthService(proxyPath, url, clientId, clientSecret string) Service {\n\treturn basicAuthService{proxyPath, url, clientId, clientSecret}\n}\n\nfunc AddParameterService(proxyPath, url, parameterName, clientSecret string) Service {\n\treturn addParameterService{proxyPath, url, parameterName, clientSecret}\n}\n\nfunc (s addParameterService) BasicAuth() (string, string, bool) ", "output": "{\n\treturn \"\", \"\", false\n}"}
{"input": "package configcore\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/snapcore/snapd/dirs\"\n\t\"github.com/snapcore/snapd/overlord/configstate/config\"\n\t\"github.com/snapcore/snapd/systemd\"\n)\n\nfunc init() {\n\tsupportedConfigurations[\"core.system.disable-backlight-service\"] = true\n}\n\nfunc validateBacklightServiceSettings(tr config.ConfGetter) error {\n\treturn validateBoolFlag(tr, \"system.disable-backlight-service\")\n}\n\ntype backlightSysdLogger struct{}\n\nfunc (l *backlightSysdLogger) Notify(status string) {\n\tfmt.Fprintf(Stderr, \"sysd: %s\\n\", status)\n}\n\n\n\n\n\n\nfunc handleBacklightServiceConfiguration(tr config.ConfGetter, opts *fsOnlyContext) error ", "output": "{\n\tvar sysd systemd.Systemd\n\tconst serviceName = \"systemd-backlight@.service\"\n\tif opts != nil {\n\t\tsysd = systemd.NewEmulationMode(opts.RootDir)\n\t} else {\n\t\tsysd = systemd.NewUnderRoot(dirs.GlobalRootDir, systemd.SystemMode, &backlightSysdLogger{})\n\t}\n\toutput, err := coreCfg(tr, \"system.disable-backlight-service\")\n\tif err != nil {\n\t\treturn nil\n\t}\n\tif output != \"\" {\n\t\tswitch output {\n\t\tcase \"true\":\n\t\t\treturn sysd.Mask(serviceName)\n\t\tcase \"false\":\n\t\t\treturn sysd.Unmask(serviceName)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unsupported disable-backlight-service option: %q\", output)\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package loaders\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/volatiletech/sqlboiler/boil\"\n)\n\ntype config struct {\n\texec boil.ContextExecutor\n}\n\nfunc convertIds(ids []string) []interface{} {\n\tvar translatedIds []interface{}\n\tfor _, id := range ids {\n\t\ttranslatedIds = append(translatedIds, id)\n\t}\n\treturn translatedIds\n}\n\n\n\nfunc AddToContext(ctx context.Context, exec boil.ContextExecutor, wait time.Duration) context.Context ", "output": "{\n\tctx = context.WithValue(ctx, TopicLoaderKey, newTopicLoader(ctx, exec, wait))\n\tctx = context.WithValue(ctx, OrganizationLoaderKey, newOrganizationLoader(ctx, exec, wait))\n\tctx = context.WithValue(ctx, RepositoryLoaderKey, newRepositoryLoader(ctx, exec, wait))\n\treturn ctx\n}"}
{"input": "package floc\n\nimport \"fmt\"\n\n\ntype Result int32\n\n\nconst (\n\tNone         Result = 1\n\tCompleted    Result = 2\n\tCanceled     Result = 4\n\tFailed       Result = 8\n\tusedBitsMask Result = None | Completed | Canceled | Failed\n\tfinishedMask Result = Completed | Canceled | Failed\n)\n\n\nfunc (result Result) IsNone() bool {\n\treturn result == None\n}\n\n\nfunc (result Result) IsCompleted() bool {\n\treturn result == Completed\n}\n\n\nfunc (result Result) IsCanceled() bool {\n\treturn result == Canceled\n}\n\n\nfunc (result Result) IsFailed() bool {\n\treturn result == Failed\n}\n\n\nfunc (result Result) IsFinished() bool {\n\treturn result&finishedMask != 0\n}\n\n\n\n\n\nfunc (result Result) Mask() ResultMask {\n\treturn NewResultMask(result)\n}\n\n\nfunc (result Result) i32() int32 {\n\treturn int32(result)\n}\n\nfunc (result Result) String() string {\n\tswitch result {\n\tcase None:\n\t\treturn \"None\"\n\tcase Completed:\n\t\treturn \"Completed\"\n\tcase Canceled:\n\t\treturn \"Canceled\"\n\tcase Failed:\n\t\treturn \"Failed\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"Result(%d)\", result.i32())\n\t}\n}\n\nfunc (result Result) IsValid() bool ", "output": "{\n\treturn result == None || result == Completed || result == Canceled || result == Failed\n}"}
{"input": "package fake_command_runner_matchers \n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n\n\t\"code.cloudfoundry.org/commandrunner/fake_command_runner\"\n)\n\nfunc HaveExecutedSerially(specs ...fake_command_runner.CommandSpec) *HaveExecutedSeriallyMatcher {\n\treturn &HaveExecutedSeriallyMatcher{Specs: specs}\n}\n\ntype HaveExecutedSeriallyMatcher struct {\n\tSpecs    []fake_command_runner.CommandSpec\n\texecuted []*exec.Cmd\n}\n\nfunc (m *HaveExecutedSeriallyMatcher) Match(actual interface{}) (bool, error) {\n\trunner, ok := actual.(*fake_command_runner.FakeCommandRunner)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"Not a fake command runner: %#v.\", actual)\n\t}\n\n\tm.executed = runner.ExecutedCommands()\n\n\tmatched := false\n\tstartSearch := 0\n\n\tfor _, spec := range m.Specs {\n\t\tmatched = false\n\n\t\tfor i := startSearch; i < len(m.executed); i++ {\n\t\t\tstartSearch++\n\n\t\t\tif !spec.Matches(m.executed[i]) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmatched = true\n\n\t\t\tbreak\n\t\t}\n\n\t\tif !matched {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif matched {\n\t\treturn true, nil\n\t} else {\n\t\treturn false, nil\n\t}\n}\n\nfunc (m *HaveExecutedSeriallyMatcher) FailureMessage(actual interface{}) (message string) {\n\treturn fmt.Sprintf(\"Expected to execute:%s\\n\\nActually executed:%s\", prettySpecs(m.Specs), prettyCommands(m.executed))\n}\n\n\n\nfunc (m *HaveExecutedSeriallyMatcher) NegatedFailureMessage(actual interface{}) (message string) ", "output": "{\n\treturn fmt.Sprintf(\"Expected to not execute the following commands:%s\", prettySpecs(m.Specs))\n}"}
{"input": "package persistentvolumeclaim\n\nimport (\n\tcontext \"context\"\n\n\tv1 \"k8s.io/client-go/informers/core/v1\"\n\tfactory \"knative.dev/pkg/client/injection/kube/informers/factory\"\n\tcontroller \"knative.dev/pkg/controller\"\n\tinjection \"knative.dev/pkg/injection\"\n\tlogging \"knative.dev/pkg/logging\"\n)\n\n\n\n\ntype Key struct{}\n\nfunc withInformer(ctx context.Context) (context.Context, controller.Informer) {\n\tf := factory.Get(ctx)\n\tinf := f.Core().V1().PersistentVolumeClaims()\n\treturn context.WithValue(ctx, Key{}, inf), inf.Informer()\n}\n\n\nfunc Get(ctx context.Context) v1.PersistentVolumeClaimInformer {\n\tuntyped := ctx.Value(Key{})\n\tif untyped == nil {\n\t\tlogging.FromContext(ctx).Panic(\n\t\t\t\"Unable to fetch k8s.io/client-go/informers/core/v1.PersistentVolumeClaimInformer from context.\")\n\t}\n\treturn untyped.(v1.PersistentVolumeClaimInformer)\n}\n\nfunc init() ", "output": "{\n\tinjection.Default.RegisterInformer(withInformer)\n}"}
{"input": "package util\n\nimport (\n  \"github.com/twitchyliquid64/CNC/logging\"\n  \"github.com/robertkrimen/otto\"\n)\n\n\n\nfunc GetFunc(argument otto.Value, vm *otto.Otto) otto.Value ", "output": "{\n  if (argument.IsFunction()) {\n    return argument;\n  }\n\n  mname := argument.String()\n  logging.Warning(\"plugin-builtin\", \"Using a string to name parameters is now deprecated. Please use callbacks directly: \" + mname)\n\n  method, err := vm.Get(mname)\n  if (err != nil){\n    logging.Error(\"plugin-builtin\", \"Error getting function \\\"\" + mname + \"\\\": \")\n  }\n\n  return method;\n}"}
{"input": "package url\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/Cloud-Foundations/tricorder/go/tricorder\"\n)\n\ntype urlconfig struct {\n\ttestname            string\n\turlpath             string\n\turlport             uint\n\tuseTLS              bool\n\thasTricorderMetrics bool\n\thealthy             bool\n\tstatusCode          uint\n\thttpTransport       *http.Transport\n\thttpClient          *http.Client\n\terror               string\n}\n\nfunc Makeurlprober(testname string, urlpath string, urlport uint) *urlconfig {\n\treturn newUrlProber(testname, urlpath, urlport)\n}\n\nfunc (p *urlconfig) GetPort() (uint, bool) {\n\treturn uint(p.urlport), p.useTLS\n}\n\nfunc (p *urlconfig) HasTricorderMetrics() bool {\n\treturn p.hasTricorderMetrics\n}\n\nfunc (p *urlconfig) HealthCheck() bool {\n\treturn p.healthy\n}\n\n\n\nfunc (p *urlconfig) Register(dir *tricorder.DirectorySpec) error {\n\treturn p.register(dir)\n}\n\nfunc (p *urlconfig) Probe() error ", "output": "{\n\treturn p.probe(p.useTLS)\n}"}
{"input": "package dnsrecorder\n\nimport (\n\t\"time\"\n\n\t\"github.com/miekg/dns\"\n)\n\n\n\n\n\n\n\ntype Recorder struct {\n\tdns.ResponseWriter\n\tRcode int\n\tLen   int\n\tMsg   *dns.Msg\n\tStart time.Time\n}\n\n\n\n\n\n\n\n\nfunc (r *Recorder) WriteMsg(res *dns.Msg) error {\n\tr.Rcode = res.Rcode\n\tr.Len += res.Len()\n\tr.Msg = res\n\treturn r.ResponseWriter.WriteMsg(res)\n}\n\n\nfunc (r *Recorder) Write(buf []byte) (int, error) {\n\tn, err := r.ResponseWriter.Write(buf)\n\tif err == nil {\n\t\tr.Len += n\n\t}\n\treturn n, err\n}\n\n\n\nfunc (r *Recorder) Hijack() { r.ResponseWriter.Hijack(); return }\n\nfunc New(w dns.ResponseWriter) *Recorder ", "output": "{\n\treturn &Recorder{\n\t\tResponseWriter: w,\n\t\tRcode:          0,\n\t\tMsg:            nil,\n\t\tStart:          time.Now(),\n\t}\n}"}
{"input": "package controllers\n\nimport (\n\t\"github.com/astaxie/beego\"\n\t\"github.com/dyzdyz010/MartianBlog/models\"\n)\n\ntype FrontController struct {\n\tbeego.Controller\n}\n\n\n\nfunc (this *FrontController) Article() {\n\tid := this.GetString(\"id\")\n\n\tthis.Data[\"json\"] = models.ArticleById(id)\n\tthis.ServeJson()\n}\n\nfunc (this *FrontController) BlogInfo() {\n\tthis.Data[\"json\"] = models.BlogInfo\n\tthis.ServeJson()\n}\n\nfunc (this *FrontController) Articles() ", "output": "{\n\tvar articles []models.Article\n\n\tif status := this.GetString(\"status\"); status != \"\" {\n\t\tarticles = models.ArticlesByStatus(status)\n\t} else {\n\t\tarticles = models.AllArticles()\n\t}\n\n\tthis.Data[\"json\"] = articles\n\tthis.ServeJson()\n}"}
{"input": "package main\n\nimport (\n\t\"os\"\n\t\"fmt\"\n\t\"time\"\n\t\"syscall\"\n\t\"runtime\"\n\t\"math/rand\"\n\t\"runtime/parlib\"\n)\n\nvar done chan bool = make(chan bool)\n\n\n\nfunc main() {\n\tfmt.Printf(\"Hello world from program %s!!\\n\", os.Args[0])\n\trand.Seed( time.Now().UTC().UnixNano())\n\tfor sig := 1; sig < parlib.SIGRTMIN; sig++ {\n\t\tparlib.Signal(sig, handle_signal)\n\t\tif (sig != int(syscall.SIGTERM)) && (sig != int(syscall.SIGKILL)) {\n\t\t\td := time.Duration(rand.Intn(1000))\n\t\t\tgo func(sig int, d time.Duration) {\n\t\t\t\ttime.Sleep(d * time.Microsecond)\n\t\t\t\tsyscall.Kill(int(parlib.Procinfo.Pid), syscall.Signal(sig))\n\t\t\t}(sig, d)\n\t\t}\n\t}\n\ttime.Sleep(1000 * time.Millisecond)\n\tsyscall.Kill(int(parlib.Procinfo.Pid), syscall.SIGTERM)\n\t<-done\n\tfmt.Printf(\"Exiting...\\n\")\n}\n\nfunc handle_signal(sig int) ", "output": "{\n\tfmt.Printf(\"Got posix signal %s\\n\", syscall.Signal(sig))\n\tif (syscall.Signal(sig) == syscall.SIGTERM) { done <- true; for { runtime.Gosched() } }\n}"}
{"input": "package chshare\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\n\ntype Logger struct {\n\tprefix      string\n\tlogger      *log.Logger\n\tInfo, Debug bool\n}\n\nfunc NewLogger(prefix string) *Logger {\n\treturn NewLoggerFlag(prefix, log.Ldate|log.Ltime)\n}\n\nfunc NewLoggerFlag(prefix string, flag int) *Logger {\n\tl := &Logger{\n\t\tprefix: prefix,\n\t\tlogger: log.New(os.Stdout, \"\", flag),\n\t\tInfo:   false,\n\t\tDebug:  false,\n\t}\n\treturn l\n}\n\nfunc (l *Logger) Infof(f string, args ...interface{}) {\n\tif l.Info {\n\t\tl.logger.Printf(l.prefix+\": \"+f, args...)\n\t}\n}\n\nfunc (l *Logger) Debugf(f string, args ...interface{}) {\n\tif l.Debug {\n\t\tl.logger.Printf(l.prefix+\": \"+f, args...)\n\t}\n}\n\nfunc (l *Logger) Errorf(f string, args ...interface{}) error {\n\treturn fmt.Errorf(l.prefix+\": \"+f, args...)\n}\n\n\n\nfunc (l *Logger) Prefix() string {\n\treturn l.prefix\n}\n\nfunc (l *Logger) Fork(prefix string, args ...interface{}) *Logger ", "output": "{\n\targs = append([]interface{}{l.prefix}, args...)\n\tll := NewLogger(fmt.Sprintf(\"%s: \"+prefix, args...))\n\tll.Info = l.Info\n\tll.Debug = l.Debug\n\treturn ll\n}"}
{"input": "package main\n\nimport \"stream\"\nimport \"unsafe\"\n\nvar x int = 12345\n\n\n\nfunc Start(console stream.Stream_t) ", "output": "{\n\tconsole.Put_String (\"Hello, World!\\n\")\n\n\tconsole.Put_String (\"Global variable x at \")\n\tconsole.Put_Unsigned (uintptr(unsafe.Pointer(&x)), 8, 16)\n\tconsole.Put_String (\" = \")\n\tconsole.Put_Integer (x, 0, 10)\n\tconsole.Put_String (\"\\n\")\n\tx += x;\n}"}
{"input": "package dax\n\n\ntype Grapher interface {\n\tGetParent() Grapher\n\tAddChild(child Grapher)\n\tGetChildren() []Grapher\n}\n\ntype nodeStack struct {\n\tnodes []Grapher\n}\n\nfunc (s *nodeStack) Init() {\n\ts.nodes = make([]Grapher, 0, 16)\n}\n\nfunc (s *nodeStack) Empty() bool {\n\treturn len(s.nodes) == 0\n}\n\n\n\nfunc (s *nodeStack) Pop() Grapher {\n\ti := len(s.nodes) - 1\n\tn := s.nodes[i]\n\ts.nodes[i] = nil\n\ts.nodes = s.nodes[:i]\n\treturn n\n}\n\ntype SceneGraph struct {\n\tNode\n}\n\nfunc NewSceneGraph() *SceneGraph {\n\tsg := new(SceneGraph)\n\tsg.Init()\n\treturn sg\n}\n\nfunc (sg *SceneGraph) Init() {\n\tsg.Node.Init()\n}\n\nfunc (sg *SceneGraph) updateWorldTransform() {\n\tsg.Node.updateWorldTransform(false)\n}\n\nfunc (sg *SceneGraph) Update(time float64) {\n\tsg.updateWorldTransform()\n}\n\n\nfunc (sg *SceneGraph) Traverse() <-chan Grapher {\n\tch := make(chan Grapher)\n\n\tgo func() {\n\t\tvar stack nodeStack\n\n\t\tstack.Init()\n\t\tstack.Push(sg)\n\n\t\tfor !stack.Empty() {\n\t\t\tn := stack.Pop()\n\t\t\tch <- n\n\t\t\tchildren := n.GetChildren()\n\t\t\tfor i := len(children) - 1; i >= 0; i-- {\n\t\t\t\tstack.Push(children[i])\n\t\t\t}\n\t\t}\n\t\tclose(ch)\n\t}()\n\n\treturn ch\n}\n\nfunc (sg *SceneGraph) Draw(fb Framebuffer) {\n\tfb.render().drawSceneGraph(fb, sg)\n}\n\nfunc (s *nodeStack) Push(n Grapher) ", "output": "{\n\ts.nodes = append(s.nodes, n)\n}"}
{"input": "package bosh\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\n\t\"github.com/cloudfoundry/bosh-bootloader/storage\"\n)\n\ntype ConfigUpdater struct {\n\tboshCLIProvider boshCLIProvider\n\tboshCLI         AuthenticatedCLIRunner\n}\n\ntype boshCLIProvider interface {\n\tAuthenticatedCLI(jumpbox storage.Jumpbox, stderr io.Writer, directorAddress, directorUsername, directorPassword, directorCACert string) (AuthenticatedCLIRunner, error)\n}\n\nfunc NewConfigUpdater(boshCLIProvider boshCLIProvider) ConfigUpdater {\n\treturn ConfigUpdater{boshCLIProvider: boshCLIProvider}\n}\n\nfunc (c ConfigUpdater) InitializeAuthenticatedCLI(state storage.State) (AuthenticatedCLIRunner, error) {\n\tboshCLI, err := c.boshCLIProvider.AuthenticatedCLI(\n\t\tstate.Jumpbox,\n\t\tos.Stderr,\n\t\tstate.BOSH.DirectorAddress,\n\t\tstate.BOSH.DirectorUsername,\n\t\tstate.BOSH.DirectorPassword,\n\t\tstate.BOSH.DirectorSSLCA,\n\t)\n\n\tif err != nil {\n\t\treturn AuthenticatedCLI{}, fmt.Errorf(\"failed to create bosh cli: %s\", err)\n\t}\n\n\treturn boshCLI, nil\n}\n\n\n\nfunc (c ConfigUpdater) UpdateRuntimeConfig(boshCLI AuthenticatedCLIRunner, filepath string, opsFilepaths []string, name string) error {\n\targs := []string{\"update-runtime-config\", filepath}\n\tfor _, opsFilepath := range opsFilepaths {\n\t\targs = append(args, \"--ops-file\", opsFilepath)\n\t}\n\targs = append(args, \"--name\", name)\n\n\treturn boshCLI.Run(nil, \"\", args)\n}\n\nfunc (c ConfigUpdater) UpdateCloudConfig(boshCLI AuthenticatedCLIRunner, filepath string, opsFilepaths []string, varsFilepath string) error ", "output": "{\n\targs := []string{\"update-cloud-config\", filepath}\n\tfor _, opsFilepath := range opsFilepaths {\n\t\targs = append(args, \"--ops-file\", opsFilepath)\n\t}\n\targs = append(args, \"--vars-file\", varsFilepath)\n\n\treturn boshCLI.Run(nil, \"\", args)\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ListShapesRequest struct {\n\n\tCompartmentId *string `mandatory:\"true\" contributesTo:\"query\" name:\"compartmentId\"`\n\n\tAvailabilityDomain *string `mandatory:\"false\" contributesTo:\"query\" name:\"availabilityDomain\"`\n\n\tLimit *int `mandatory:\"false\" contributesTo:\"query\" name:\"limit\"`\n\n\tPage *string `mandatory:\"false\" contributesTo:\"query\" name:\"page\"`\n\n\tImageId *string `mandatory:\"false\" contributesTo:\"query\" name:\"imageId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request ListShapesRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request ListShapesRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request ListShapesRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request ListShapesRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ListShapesResponse struct {\n\n\tRawResponse *http.Response\n\n\tItems []Shape `presentIn:\"body\"`\n\n\tOpcNextPage *string `presentIn:\"header\" name:\"opc-next-page\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\n\n\n\nfunc (response ListShapesResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (response ListShapesResponse) String() string ", "output": "{\n\treturn common.PointerString(response)\n}"}
{"input": "package mpunicorn\n\nimport \"github.com/mattn/go-pipeline\"\n\n\ntype PipedCommands interface {\n\tOutput(...[]string) ([]byte, error)\n}\n\n\ntype RealPipedCommands struct{}\n\nvar pipedCommands PipedCommands\n\n\n\n\nfunc (r RealPipedCommands) Output(commands ...[]string) ([]byte, error) ", "output": "{\n\tout, err := pipeline.Output(commands...)\n\treturn out, err\n}"}
{"input": "package complete\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n)\n\n\ntype Args struct {\n\tAll []string\n\tCompleted []string\n\tLast string\n\tLastCompleted string\n}\n\n\n\n\n\n\nfunc newArgs(line []string) Args {\n\tcompleted := removeLast(line[1:])\n\treturn Args{\n\t\tAll:           line[1:],\n\t\tCompleted:     completed,\n\t\tLast:          last(line),\n\t\tLastCompleted: last(completed),\n\t}\n}\n\nfunc (a Args) from(i int) Args {\n\tif i > len(a.All) {\n\t\ti = len(a.All)\n\t}\n\ta.All = a.All[i:]\n\n\tif i > len(a.Completed) {\n\t\ti = len(a.Completed)\n\t}\n\ta.Completed = a.Completed[i:]\n\treturn a\n}\n\nfunc removeLast(a []string) []string {\n\tif len(a) > 0 {\n\t\treturn a[:len(a)-1]\n\t}\n\treturn a\n}\n\nfunc last(args []string) (last string) {\n\tif len(args) > 0 {\n\t\tlast = args[len(args)-1]\n\t}\n\treturn\n}\n\nfunc (a Args) Directory() string ", "output": "{\n\tif info, err := os.Stat(a.Last); err == nil && info.IsDir() {\n\t\treturn fixPathForm(a.Last, a.Last)\n\t}\n\tdir := filepath.Dir(a.Last)\n\tif info, err := os.Stat(dir); err != nil || !info.IsDir() {\n\t\treturn \"./\"\n\t}\n\treturn fixPathForm(a.Last, dir)\n}"}
{"input": "package state\n\nimport (\n\t\"github.com/lastbackend/lastbackend/pkg/distribution/types\"\n\t\"github.com/lastbackend/lastbackend/pkg/log\"\n\t\"sync\"\n)\n\nconst logTaskPrefix = \"state:task:>\"\n\ntype TaskState struct {\n\tlock  sync.RWMutex\n\ttasks map[string]types.NodeTask\n}\n\n\n\nfunc (s *TaskState) GetTask(key string) *types.NodeTask {\n\tlog.V(logLevel).Debugf(\"%s get cancel func pod: %s\", logTaskPrefix, key)\n\n\tif _, ok := s.tasks[key]; ok {\n\t\tt := s.tasks[key]\n\t\treturn &t\n\t}\n\n\treturn nil\n}\n\nfunc (s *TaskState) DelTask(pod *types.Pod) {\n\tlog.V(logLevel).Debugf(\"%s del cancel func pod: %s\", logTaskPrefix, pod.SelfLink())\n\tdelete(s.tasks, pod.Meta.Name)\n}\n\nfunc (s *TaskState) AddTask(key string, task *types.NodeTask) ", "output": "{\n\tlog.V(logLevel).Debugf(\"%s add cancel func pod: %s\", logTaskPrefix, key)\n\ts.tasks[key] = *task\n}"}
{"input": "package leveldb\n\nimport (\n\t\"github.com/jmhodges/levigo\"\n)\n\ntype Iterator struct {\n\tstore    *Store\n\titerator *levigo.Iterator\n}\n\nfunc newIterator(store *Store) *Iterator {\n\tropts := defaultReadOptions()\n\trv := Iterator{\n\t\tstore:    store,\n\t\titerator: store.db.NewIterator(ropts),\n\t}\n\tropts.Close()\n\treturn &rv\n}\n\nfunc newIteratorWithSnapshot(store *Store, snapshot *levigo.Snapshot) *Iterator {\n\toptions := defaultReadOptions()\n\toptions.SetSnapshot(snapshot)\n\trv := Iterator{\n\t\tstore:    store,\n\t\titerator: store.db.NewIterator(options),\n\t}\n\toptions.Close()\n\treturn &rv\n}\n\nfunc (ldi *Iterator) SeekFirst() {\n\tldi.iterator.SeekToFirst()\n}\n\nfunc (ldi *Iterator) Seek(key []byte) {\n\tldi.iterator.Seek(key)\n}\n\nfunc (ldi *Iterator) Next() {\n\tldi.iterator.Next()\n}\n\nfunc (ldi *Iterator) Current() ([]byte, []byte, bool) {\n\tif ldi.Valid() {\n\t\treturn ldi.Key(), ldi.Value(), true\n\t}\n\treturn nil, nil, false\n}\n\nfunc (ldi *Iterator) Key() []byte {\n\treturn ldi.iterator.Key()\n}\n\nfunc (ldi *Iterator) Value() []byte {\n\treturn ldi.iterator.Value()\n}\n\nfunc (ldi *Iterator) Valid() bool {\n\treturn ldi.iterator.Valid()\n}\n\n\n\nfunc (ldi *Iterator) Close() error ", "output": "{\n\tldi.iterator.Close()\n\treturn nil\n}"}
{"input": "package compiler\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/d3media/llconf/compiler/parser\"\n\t\"github.com/d3media/llconf/promise\"\n)\n\ntype FolderReader struct {\n}\n\nfunc Compile(folder string) (map[string]promise.Promise, error) {\n\tch := make(chan string)\n\tgo listFiles(folder, \"cnf\", ch)\n\n\tinputs := []parser.Input{}\n\n\tfor filename := range ch {\n\t\tif content, err := ioutil.ReadFile(filename); err != nil {\n\t\t\treturn nil, err\n\t\t} else {\n\t\t\tinputs = append(inputs, parser.Input{\n\t\t\t\tfilename,\n\t\t\t\tstring(content)})\n\t\t}\n\t}\n\n\treturn parser.Parse(inputs)\n}\n\n\n\nfunc listFiles(folder, suffix string, filename chan<- string) ", "output": "{\n\tdefer close(filename)\n\n\terr := filepath.Walk(folder, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() && strings.HasSuffix(info.Name(), suffix) {\n\t\t\tfilename <- path\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tfmt.Printf(err.Error())\n\t}\n}"}
{"input": "package utils\n\nimport (\n\t\"crypto/sha512\"\n\t\"fmt\"\n)\n\nconst (\n\tmaxChainLength = 28\n\tchainPrefix    = \"CNI-\"\n\tprefixLength   = len(chainPrefix)\n)\n\n\n\n\n\n\n\n\nfunc FormatComment(name string, id string) string {\n\treturn fmt.Sprintf(\"name: %q id: %q\", name, id)\n}\n\nfunc FormatChainName(name string, id string) string ", "output": "{\n\tchainBytes := sha512.Sum512([]byte(name + id))\n\tchain := fmt.Sprintf(\"%s%x\", chainPrefix, chainBytes)\n\treturn chain[:maxChainLength]\n}"}
{"input": "package common\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n\nfunc NewDoubleSeries(name string) *DoubleSeries {\n\treturn &DoubleSeries{\n\t\tSeriesMeta: SeriesMeta{\n\t\t\tName:      name,\n\t\t\tTags:      map[string]string{},\n\t\t\tType:      TypeDoubleSeries,\n\t\t\tPrecision: time.Millisecond.Nanoseconds(),\n\t\t},\n\t}\n}\n\nfunc (m *DoubleSeries) GetMinTime() int64 {\n\tif len(m.Points) == 0 {\n\t\treturn 0\n\t}\n\treturn m.Points[0].T\n}\n\nfunc (m *DoubleSeries) GetMaxTime() int64 {\n\tif len(m.Points) == 0 {\n\t\treturn 0\n\t}\n\treturn m.Points[len(m.Points)-1].T\n}\n\n\n\nfunc (m *DoubleSeries) PrintPoints() {\n\tfor i, p := range m.Points {\n\t\tfmt.Printf(\"%d, %d, %v\\n\", i, p.T, p.V)\n\t}\n}\n\nfunc (m *DoubleSeriesColumnar) GetMinTime() int64 {\n\tif len(m.T) == 0 {\n\t\treturn 0\n\t}\n\treturn m.T[0]\n}\n\nfunc (m *DoubleSeriesColumnar) GetMaxTime() int64 {\n\tif len(m.T) == 0 {\n\t\treturn 0\n\t}\n\treturn m.T[len(m.T)-1]\n}\n\nfunc (m *DoubleSeriesColumnar) IsColumnar() bool {\n\treturn true\n}\n\nfunc (m *DoubleSeriesColumnar) Length() int {\n\treturn len(m.T)\n}\n\nfunc (m *DoubleSeriesColumnar) PrintPoints() {\n\tfor i := 0; i < len(m.T); i++ {\n\t\tfmt.Printf(\"%d, %d, %v\\n\", i, m.T[i], m.V[i])\n\t}\n}\n\nfunc (m *DoubleSeries) Length() int ", "output": "{\n\treturn len(m.Points)\n}"}
{"input": "package operations\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/lxc/lxd/lxd/db\"\n)\n\nfunc registerDBOperation(op *Operation, opType db.OperationType) error {\n\tif op.state == nil {\n\t\treturn nil\n\t}\n\n\terr := op.state.Cluster.Transaction(func(tx *db.ClusterTx) error {\n\t\topInfo := db.Operation{\n\t\t\tUUID:   op.id,\n\t\t\tType:   opType,\n\t\t\tNodeID: tx.GetNodeID(),\n\t\t}\n\n\t\tif op.projectName != \"\" {\n\t\t\tprojectID, err := tx.GetProjectID(op.projectName)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"Fetch project ID: %w\", err)\n\t\t\t}\n\t\t\topInfo.ProjectID = &projectID\n\t\t}\n\n\t\t_, err := tx.CreateOrReplaceOperation(opInfo)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to add %q Operation %s to database: %w\", opType.Description(), op.id, err)\n\t}\n\n\treturn nil\n}\n\nfunc removeDBOperation(op *Operation) error {\n\tif op.state == nil {\n\t\treturn nil\n\t}\n\n\terr := op.state.Cluster.Transaction(func(tx *db.ClusterTx) error {\n\t\treturn tx.DeleteOperation(op.id)\n\t})\n\n\treturn err\n}\n\n\n\nfunc (op *Operation) sendEvent(eventMessage interface{}) {\n\tif op.events == nil {\n\t\treturn\n\t}\n\n\top.events.Send(op.projectName, \"operation\", eventMessage)\n}\n\nfunc getServerName(op *Operation) (string, error) ", "output": "{\n\tif op.state == nil {\n\t\treturn \"\", nil\n\t}\n\n\tvar serverName string\n\tvar err error\n\terr = op.state.Cluster.Transaction(func(tx *db.ClusterTx) error {\n\t\tserverName, err = tx.GetLocalNodeName()\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn serverName, nil\n}"}
{"input": "package iterator_test\n\nimport (\n\t\"testing\"\n\n\t\"bosun.org/_third_party/github.com/syndtr/goleveldb/leveldb/testutil\"\n)\n\n\n\nfunc TestIterator(t *testing.T) ", "output": "{\n\ttestutil.RunSuite(t, \"Iterator Suite\")\n}"}
{"input": "package ir\n\nimport (\n  \"fmt\"\n  \"bitbucket.org/yyuu/xtc/core\"\n)\n\ntype Var struct {\n  ClassName string\n  TypeId int\n  Entity core.IEntity\n}\n\n\n\nfunc (self *Var) AsExpr() core.IExpr {\n  return self\n}\n\nfunc (self Var) GetTypeId() int {\n  return self.TypeId\n}\n\nfunc (self Var) IsAddr() bool {\n  return false\n}\n\nfunc (self Var) IsConstant() bool {\n  return false\n}\n\nfunc (self Var) IsVar() bool {\n  return true\n}\n\nfunc (self *Var) GetAddress() core.IOperand {\n  return self.Entity.GetAddress()\n}\n\nfunc (self *Var) GetAsmValue() core.IImmediateValue {\n  panic(\"#GetAsmValue called\")\n}\n\nfunc (self *Var) GetMemref() core.IMemoryReference {\n  return self.Entity.GetMemref()\n}\n\nfunc (self Var) GetAddressNode(t int) core.IExpr {\n  return NewAddr(t, self.Entity)\n}\n\nfunc (self Var) GetEntityForce() core.IEntity {\n  return self.Entity\n}\n\nfunc (self Var) String() string {\n  return fmt.Sprintf(\"Var(%s)\", self.Entity.GetName())\n}\n\nfunc NewVar(t int, e core.IEntity) *Var ", "output": "{\n  return &Var { \"ir.Var\", t, e }\n}"}
{"input": "package util\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc TestHashPassword(t *testing.T) {\n\tfmt.Println(HashAndSalt(\"123456\", \"245accec-3c12-4642-967f-e476cef558c0\"))\n}\n\nfunc TestIsBlank(t *testing.T) ", "output": "{\n\tif !IsBlank(\"\") {\n\t\tt.FailNow()\n\t}\n\n\tif !IsBlank(`\n\t`) {\n\t\tt.FailNow()\n\t}\n\n}"}
{"input": "package transporttest\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\n\n\n\ntype ContextMatcher struct {\n\tt   *testing.T\n\tttl time.Duration\n\n\tTTLDelta time.Duration\n}\n\n\ntype ContextMatcherOption interface {\n\trun(*ContextMatcher)\n}\n\n\n\ntype ContextTTL time.Duration\n\nfunc (ttl ContextTTL) run(c *ContextMatcher) {\n\tc.ttl = time.Duration(ttl)\n}\n\n\n\nfunc NewContextMatcher(t *testing.T, options ...ContextMatcherOption) *ContextMatcher {\n\tmatcher := &ContextMatcher{t: t, TTLDelta: DefaultTTLDelta}\n\tfor _, opt := range options {\n\t\topt.run(matcher)\n\t}\n\treturn matcher\n}\n\n\n\n\n\n\nfunc (c *ContextMatcher) String() string {\n\treturn fmt.Sprintf(\"ContextMatcher(TTL:%v±%v)\", c.ttl, c.TTLDelta)\n}\n\nfunc (c *ContextMatcher) Matches(got interface{}) bool ", "output": "{\n\tctx, ok := got.(context.Context)\n\tif !ok {\n\t\tc.t.Logf(\"expected a Context but got a %T: %v\", got, got)\n\t\treturn false\n\t}\n\n\tif c.ttl != 0 {\n\t\td, ok := ctx.Deadline()\n\t\tif !ok {\n\t\t\tc.t.Logf(\n\t\t\t\t\"expected Context to have a TTL of %v but it has no deadline\", c.ttl)\n\t\t\treturn false\n\t\t}\n\n\t\tttl := time.Until(d)\n\t\tmaxTTL := c.ttl + c.TTLDelta\n\t\tminTTL := c.ttl - c.TTLDelta\n\t\tif ttl > maxTTL || ttl < minTTL {\n\t\t\tc.t.Logf(\"TTL out of expected bounds: %v < %v < %v\", minTTL, ttl, maxTTL)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/nickvanw/ircx/v2\"\n\t\"gopkg.in/sorcix/irc.v2\"\n)\n\nconst timeBetweenMessages = 2 * time.Second\n\ntype throttler struct {\n\tbot   *ircx.Bot\n\tsendc chan *irc.Message\n}\n\n\n\nfunc (t *throttler) Send(m *irc.Message) {\n\tt.sendc <- m\n}\n\nfunc (t *throttler) Loop() ", "output": "{\n\tfor {\n\t\tm := <-t.sendc\n\t\tfor {\n\t\t\terr := t.bot.Sender.Send(m)\n\t\t\tif err != nil {\n\t\t\t\ttime.Sleep(timeBetweenMessages * 2)\n\t\t\t\tlog.Printf(\"Error sending message: %v\", err)\n\t\t\t} else {\n\t\t\t\ttime.Sleep(timeBetweenMessages)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}"}
{"input": "package models\n\nimport (\n\t\"fmt\"\n\t\"github.com/APTrust/exchange/util\"\n\t\"github.com/APTrust/exchange/util/s3util\"\n\t\"github.com/crowdmob/goamz/s3\"\n\t\"time\"\n)\n\n\n\n\n\n\n\n\n\n\ntype S3File struct {\n\tBucketName string\n\n\tKey s3.Key\n\n\tErrorMessage string\n\n\tDeletedAt time.Time\n\n\tDeleteSkippedPerConfig bool\n}\n\nfunc NewS3FileWithKey(bucketName string, key s3.Key) *S3File {\n\treturn &S3File{\n\t\tBucketName: bucketName,\n\t\tKey:        key,\n\t}\n}\n\nfunc NewS3FileWithName(bucketName, keyName string) *S3File {\n\treturn &S3File{\n\t\tBucketName: bucketName,\n\t\tKey:        s3.Key{Key: keyName},\n\t}\n}\n\n\n\n\n\n\n\nfunc (s3File *S3File) ObjectName() (string, error) {\n\tinstitution := util.OwnerOf(s3File.BucketName)\n\tcleanBagName := util.CleanBagName(s3File.Key.Key)\n\treturn fmt.Sprintf(\"%s/%s\", institution, cleanBagName), nil\n}\n\n\n\n\nfunc (s3File *S3File) BagName() string {\n\treturn fmt.Sprintf(\"%s/%s\", util.OwnerOf(s3File.BucketName), s3File.Key.Key)\n}\n\n\n\n\n\n\nfunc (s3File *S3File) KeyIsComplete() bool {\n\treturn s3util.KeyIsComplete(s3File.Key)\n}\n\nfunc (s3File *S3File) DeleteAttempted() bool ", "output": "{\n\treturn s3File.ErrorMessage != \"\" || s3File.DeletedAt.IsZero() == false\n}"}
{"input": "package main\n\nimport (\n\t_ \"github.com/mattn/go-sqlite3\"\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype (\n\tEvent struct {\n\t\tId    int64 `db:\"id\" json:\"-\"`\n\t\tEvent string `db:\"nombre_exhibicion\" json:\"event,omitempty\"`\n\t\tTotal string `db:\"count(nombre_exhibicion)\" json:\"total,omitempty\"`\n\t}\n\n\tResourceEvent struct {\n\t\tId         int64 `json:\"id\"`\n\t\tType       string `json:\"type\"`\n\t\tAttributes Event `json:\"attributes\"`\n\t}\n\n\tResourceEvents struct {\n\t\tData  []ResourceEvent `json:\"data\"`\n\t\tLinks PaginationLinks `json:\"links\"`\n\t\tMeta  Meta `json:\"meta\"`\n\t}\n)\n\nfunc newResourceEvent (attr Event) ResourceEvent {\n\treturn ResourceEvent {\n\t\tId: attr.Id,\n\t\tType: \"events\",\n\t\tAttributes: attr,\n\t}\n}\n\nfunc newResourceEvents (events []Event, endpoint string, pg string) ResourceEvents {\n\tresources := make([]ResourceEvent, 0)\n\tfor l := range events {\n\t\tresources = append(resources, newResourceEvent(events[l]))\n\t}\n\n\tlinks := PaginationLinks {\n\t\tFirst: paginationLink(endpoint, firstPage, \"first\"),\n\t\tLast: paginationLink(endpoint, lastPage, \"last\"),\n\t\tPrev: paginationLink(endpoint, pg, \"prev\"),\n\t\tNext: paginationLink(endpoint, pg, \"next\"),\n\t}\n\n\treturn ResourceEvents{Data: resources, Links: links, Meta: Meta{TotalPages: \"3\"}}\n}\n\n\n\n\n\nfunc GetEvents(c *gin.Context) ", "output": "{\n\tvar events []Event\n\tpage := c.DefaultQuery(\"page\", \"1\")\n\n\tquery := PaginateQuery(groupByQuery(\"SELECT id, %s, count(%s) FROM exhibiciones\", \"event\"), page)\n\t_, err := dbmap.Select(&events, query)\n\tcheckErr(err)\n\n\tif err == nil {\n\t\tcontent := newResourceEvents(events, \"events\", page)\n\t\tc.JSON(200, content)\n\t} else {\n\t\tjsonErr := &Error{\"not_found\", 404, \"Not Found Error\", \"No event found.\"}\n\t\tc.JSON(404, jsonErr)\n\t}\n}"}
{"input": "package store\n\nimport \"github.com/corestoreio/csfw/storage/dbr\"\n\n\n\n\n\n\n\n\n\nfunc (s *TableGroupSlice) SQLSelect(dbrSess dbr.SessionRunner, cbs ...dbr.SelectCb) (int, error) ", "output": "{\n\treturn s.parentSQLSelect(dbrSess, append(append([]dbr.SelectCb{nil}, func(sb *dbr.SelectBuilder) *dbr.SelectBuilder {\n\t\treturn sb.OrderBy(\"main_table.name ASC\")\n\t}), cbs...)...)\n}"}
{"input": "package atccmd\n\nimport (\n\t\"net\"\n\t\"time\"\n)\n\n\n\nfunc keepaliveDialer(network string, address string) (net.Conn, error) ", "output": "{\n\treturn net.DialTimeout(network, address, 5*time.Second)\n}"}
{"input": "package api\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/ant0ine/go-json-rest/rest\"\n\n\t\"github.com/pdxjohnny/s/api\"\n\t\"github.com/pdxjohnny/s/variables\"\n)\n\n\n\n\n\nfunc PostAccount(w rest.ResponseWriter, r *rest.Request) {\n\tvar recvDoc map[string]interface{}\n\tid := r.PathParam(\"id\")\n\terr := r.DecodeJsonPayload(&recvDoc)\n\tif err != nil {\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdoc, err := api.SaveAccount(variables.ServiceDBURL, r.Env[\"JWT_RAW\"].(string), id, recvDoc)\n\tif err != nil {\n\t\trest.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.WriteHeader(http.StatusOK)\n\tif doc == nil {\n\t\tw.(http.ResponseWriter).Write(variables.BlankResponse)\n\t\treturn\n\t}\n\tw.WriteJson(doc)\n}\n\nfunc GetAccount(w rest.ResponseWriter, r *rest.Request) ", "output": "{\n\tid := r.PathParam(\"id\")\n\tdoc, err := api.GetAccount(variables.ServiceDBURL, r.Env[\"JWT_RAW\"].(string), id)\n\tif err != nil {\n\t\trest.Error(w, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tif doc == nil {\n\t\tw.(http.ResponseWriter).Write(variables.BlankResponse)\n\t\treturn\n\t}\n\tw.WriteJson(doc)\n}"}
{"input": "package events\n\nimport \"github.com/awgh/ratnet/api\"\n\n\nfunc Info(node api.Node, args ...interface{}) {}\n\n\nfunc Debug(node api.Node, args ...interface{}) {}\n\n\nfunc Warning(node api.Node, args ...interface{}) {}\n\n\nfunc Error(node api.Node, args ...interface{}) {}\n\n\n\n\nfunc Critical(node api.Node, args ...interface{}) ", "output": "{\n\tpanic(args)\n}"}
{"input": "package fake\n\nimport (\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n\tv1alpha2 \"k8s.io/kops/pkg/client/clientset_generated/clientset/typed/kops/v1alpha2\"\n)\n\ntype FakeKopsV1alpha2 struct {\n\t*testing.Fake\n}\n\nfunc (c *FakeKopsV1alpha2) Clusters(namespace string) v1alpha2.ClusterInterface {\n\treturn &FakeClusters{c, namespace}\n}\n\nfunc (c *FakeKopsV1alpha2) InstanceGroups(namespace string) v1alpha2.InstanceGroupInterface {\n\treturn &FakeInstanceGroups{c, namespace}\n}\n\nfunc (c *FakeKopsV1alpha2) Keysets(namespace string) v1alpha2.KeysetInterface {\n\treturn &FakeKeysets{c, namespace}\n}\n\n\n\n\n\nfunc (c *FakeKopsV1alpha2) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakeKopsV1alpha2) SSHCredentials(namespace string) v1alpha2.SSHCredentialInterface ", "output": "{\n\treturn &FakeSSHCredentials{c, namespace}\n}"}
{"input": "package pdu\n\nimport (\n\t\"github.com/linxGnu/gosmpp/data\"\n)\n\n\n\n\n\ntype QuerySM struct {\n\tbase\n\tMessageID  string\n\tSourceAddr Address\n}\n\n\nfunc NewQuerySM() PDU {\n\tc := &QuerySM{\n\t\tSourceAddr: NewAddress(),\n\t}\n\tc.CommandID = data.QUERY_SM\n\treturn c\n}\n\n\nfunc (c *QuerySM) CanResponse() bool {\n\treturn true\n}\n\n\nfunc (c *QuerySM) GetResponse() PDU {\n\treturn NewQuerySMRespFromReq(c)\n}\n\n\n\n\n\nfunc (c *QuerySM) Unmarshal(b *ByteBuffer) error {\n\treturn c.base.unmarshal(b, func(b *ByteBuffer) (err error) {\n\t\tif c.MessageID, err = b.ReadCString(); err == nil {\n\t\t\terr = c.SourceAddr.Unmarshal(b)\n\t\t}\n\t\treturn\n\t})\n}\n\nfunc (c *QuerySM) Marshal(b *ByteBuffer) ", "output": "{\n\tc.base.marshal(b, func(b *ByteBuffer) {\n\t\tb.Grow(len(c.MessageID) + 1)\n\n\t\t_ = b.WriteCString(c.MessageID)\n\t\tc.SourceAddr.Marshal(b)\n\t})\n}"}
{"input": "package v6\n\nimport (\n\t\"code.cloudfoundry.org/cli/command\"\n\t\"code.cloudfoundry.org/cli/command/flag\"\n\t\"code.cloudfoundry.org/cli/command/translatableerror\"\n)\n\ntype SetOrgRoleCommand struct {\n\tRequiredArgs    flag.SetOrgRoleArgs `positional-args:\"yes\"`\n\tusage           interface{}         `usage:\"CF_NAME set-org-role USERNAME ORG ROLE\\n\\nROLES:\\n   'OrgManager' - Invite and manage users, select and change plans, and set spending limits\\n   'BillingManager' - Create and manage the billing account and payment info\\n   'OrgAuditor' - Read-only access to org info and reports\"`\n\trelatedCommands interface{}         `related_commands:\"org-users, set-space-role\"`\n}\n\n\n\nfunc (SetOrgRoleCommand) Execute(args []string) error {\n\treturn translatableerror.UnrefactoredCommandError{}\n}\n\nfunc (SetOrgRoleCommand) Setup(config command.Config, ui command.UI) error ", "output": "{\n\treturn nil\n}"}
{"input": "package bolt\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n)\n\n\nfunc TestPageTyp(t *testing.T) {\n\tassert.Equal(t, (&page{flags: branchPageFlag}).typ(), \"branch\")\n\tassert.Equal(t, (&page{flags: leafPageFlag}).typ(), \"leaf\")\n\tassert.Equal(t, (&page{flags: metaPageFlag}).typ(), \"meta\")\n\tassert.Equal(t, (&page{flags: bucketsPageFlag}).typ(), \"buckets\")\n\tassert.Equal(t, (&page{flags: freelistPageFlag}).typ(), \"freelist\")\n\tassert.Equal(t, (&page{flags: 20000}).typ(), \"unknown<4e20>\")\n}\n\n\n\n\nfunc TestPageDump(t *testing.T) ", "output": "{\n\t(&page{id: 256}).hexdump(16)\n}"}
{"input": "package perfsession\n\nimport \"sort\"\n\n\n\ntype Ranges struct {\n\trs     []rangeEnt\n\tsorted bool\n}\n\ntype rangeEnt struct {\n\tlo, hi uint64\n\tval    interface{}\n}\n\n\n\n\nfunc (r *Ranges) Add(lo, hi uint64, val interface{}) {\n\tr.rs = append(r.rs, rangeEnt{lo, hi, val})\n\tr.sorted = false\n}\n\n\n\n\nfunc (r *Ranges) Get(idx uint64) (lo, hi uint64, val interface{}, ok bool) ", "output": "{\n\tif r == nil {\n\t\treturn 0, 0, nil, false\n\t}\n\n\trs := r.rs\n\tif !r.sorted {\n\t\tsort.Slice(rs, func(i, j int) bool {\n\t\t\treturn rs[i].lo < rs[j].lo\n\t\t})\n\t\tr.sorted = true\n\t}\n\n\ti := sort.Search(len(rs), func(i int) bool {\n\t\treturn idx < rs[i].hi\n\t})\n\tif i < len(rs) && rs[i].lo <= idx && idx < rs[i].hi {\n\t\treturn rs[i].lo, rs[i].hi, rs[i].val, true\n\t}\n\treturn 0, 0, nil, false\n}"}
{"input": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/nicholasjackson/bench\"\n\t\"github.com/nicholasjackson/bench/output\"\n\t\"github.com/nicholasjackson/bench/util\"\n\t\"github.com/nicholasjackson/building-microservices-in-go/chapter6/vanilla_http/entities\"\n)\n\nfunc main() {\n\tfmt.Println(\"Benchmarking application\")\n\n\tb := bench.New(400, 300*time.Second, 90*time.Second, 5*time.Second)\n\tb.AddOutput(301*time.Second, os.Stdout, output.WriteTabularData)\n\tb.AddOutput(1*time.Second, util.NewFile(\"./output.txt\"), output.WriteTabularData)\n\tb.AddOutput(1*time.Second, util.NewFile(\"./error.txt\"), output.WriteErrorLogs)\n\tb.AddOutput(1*time.Second, util.NewFile(\"./output.png\"), output.PlotData)\n\tb.RunBenchmarks(GoMicroRequest)\n}\n\n\n\n\nfunc GoMicroRequest() error ", "output": "{\n\n\trequest := entities.HelloWorldRequest{\n\t\tName: \"Nic\",\n\t}\n\n\tdata, _ := json.Marshal(request)\n\n\treq, err := http.NewRequest(\"GET\", \"http://www.public.b.prod-eu-west-1.noths.com\", bytes.NewBuffer(data))\n\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tMaxIdleConnsPerHost: 5,\n\t\t},\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"Failed with status: %v\", resp.Status)\n\t}\n\n\treturn nil\n}"}
{"input": "package v1alpha1\n\nimport (\n\tv1alpha1 \"github.com/knative/build/pkg/apis/build/v1alpha1\"\n\t\"github.com/knative/build/pkg/client/clientset/versioned/scheme\"\n\tserializer \"k8s.io/apimachinery/pkg/runtime/serializer\"\n\trest \"k8s.io/client-go/rest\"\n)\n\ntype BuildV1alpha1Interface interface {\n\tRESTClient() rest.Interface\n\tBuildsGetter\n\tBuildTemplatesGetter\n}\n\n\ntype BuildV1alpha1Client struct {\n\trestClient rest.Interface\n}\n\nfunc (c *BuildV1alpha1Client) Builds(namespace string) BuildInterface {\n\treturn newBuilds(c, namespace)\n}\n\nfunc (c *BuildV1alpha1Client) BuildTemplates(namespace string) BuildTemplateInterface {\n\treturn newBuildTemplates(c, namespace)\n}\n\n\n\n\n\n\nfunc NewForConfigOrDie(c *rest.Config) *BuildV1alpha1Client {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n\n\nfunc New(c rest.Interface) *BuildV1alpha1Client {\n\treturn &BuildV1alpha1Client{c}\n}\n\nfunc setConfigDefaults(config *rest.Config) error {\n\tgv := v1alpha1.SchemeGroupVersion\n\tconfig.GroupVersion = &gv\n\tconfig.APIPath = \"/apis\"\n\tconfig.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: scheme.Codecs}\n\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = rest.DefaultKubernetesUserAgent()\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (c *BuildV1alpha1Client) RESTClient() rest.Interface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.restClient\n}\n\nfunc NewForConfig(c *rest.Config) (*BuildV1alpha1Client, error) ", "output": "{\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := rest.RESTClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &BuildV1alpha1Client{client}, nil\n}"}
{"input": "package hclsyntax\n\n\n\n\nimport (\n\t\"github.com/hashicorp/hcl2/hcl\"\n)\n\nfunc (e *AnonSymbolExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *BinaryOpExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *ConditionalExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *ForExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *FunctionCallExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *IndexExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\n\n\nfunc (e *ObjectConsExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *ObjectConsKeyExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *RelativeTraversalExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *ScopeTraversalExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *SplatExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *TemplateExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *TemplateJoinExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *TemplateWrapExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *TupleConsExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *UnaryOpExpr) Variables() []hcl.Traversal {\n\treturn Variables(e)\n}\n\nfunc (e *LiteralValueExpr) Variables() []hcl.Traversal ", "output": "{\n\treturn Variables(e)\n}"}
{"input": "package currencies\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n)\n\nconst (\n\tapiBase    = \"https://openexchangerates.org/api\"\n\tlatest     = apiBase + \"/latest.json?app_id=\"\n\tcurrencies = apiBase + \"/currencies?app_id=\"\n)\n\ntype OpenExchangeClient struct {\n\tAppID  string\n\tClient *http.Client\n}\n\n\n\ntype exchangeRate struct {\n\tDisclaimer string             `json:\"disclaimer\"`\n\tLicense    string             `json:\"license\"`\n\tTimestamp  int64              `json:\"timestamp\"`\n\tBase       string             `json:\"base\"`\n\tRates      map[string]float64 `json:\"rates\"`\n}\n\n\n\n\nfunc (c *OpenExchangeClient) GetLatest() (rates map[string]int64, err error) ", "output": "{\n\tif c.AppID == \"\" {\n\t\treturn nil, errors.New(\"No app Id\")\n\t}\n\tif c.Client == nil {\n\t\tc.Client = &http.Client{}\n\t}\n\n\tresp, err := c.Client.Get(latest + c.AppID)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if resp.StatusCode != 200 {\n\t\treturn nil, errors.New(resp.Status)\n\t}\n\n\tdefer resp.Body.Close()\n\n\tex := new(exchangeRate)\n\tdec := json.NewDecoder(resp.Body)\n\n\tif err := dec.Decode(&ex); err == io.EOF {\n\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\trates = make(map[string]int64)\n\tfor name, cur := range ex.Rates {\n\t\trates[name] = int64(cur * 100)\n\t}\n\treturn\n}"}
{"input": "package data\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n\n\t\"cloud.google.com/go/spanner/spansql\"\n)\n\n\nvar _ Generator = (*TimestampGenerator)(nil)\n\ntype (\n\tTimestampGenerator struct {\n\t\tsrc   rand.Source\n\t\tdelta int64\n\t\tmin   int64\n\t\tmax   int64\n\t\tr     bool\n\t}\n)\n\nfunc NewTimestampGenerator(cfg Config) (Generator, error) {\n\tret := &TimestampGenerator{\n\t\tsrc: cfg.Source(),\n\t}\n\n\tif cfg.Range() {\n\t\tret.r = true\n\n\t\tswitch min := cfg.Minimum().(type) {\n\t\tcase time.Time:\n\t\t\tret.min = min.Unix()\n\t\tcase int64:\n\t\t\tret.min = min\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"minimum '%s' of type '%T' invalid for timestamp generator\", min, min)\n\t\t}\n\n\t\tswitch max := cfg.Maximum().(type) {\n\t\tcase time.Time:\n\t\t\tret.max = max.Unix()\n\t\tcase int64:\n\t\t\tret.max = max\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"maximum '%s' of type '%T' invalid for timestamp generator\", max, max)\n\t\t}\n\t} else {\n\t\tret.min = time.Date(defaultDateMinYear, 1, 0, 0, 0, 0, 0, time.UTC).Unix()\n\t\tret.max = time.Date(defaultDateMaxYear, 1, 0, 0, 0, 0, 0, time.UTC).Unix()\n\t}\n\n\tret.delta = ret.max - ret.min\n\n\treturn ret, nil\n}\n\nfunc (g *TimestampGenerator) Next() interface{} {\n\tsec := rand.Int63n(g.delta) + g.min\n\treturn time.Unix(sec, 0)\n}\n\n\n\nfunc (g *TimestampGenerator) Type() spansql.TypeBase ", "output": "{\n\treturn spansql.Timestamp\n}"}
{"input": "package payload_test\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/RobotsAndPencils/buford/payload\"\n)\n\n\n\nfunc TestBrowser(t *testing.T) {\n\tp := payload.Browser{\n\t\tAlert: payload.BrowserAlert{\n\t\t\tTitle:  \"Flight A998 Now Boarding\",\n\t\t\tBody:   \"Boarding has begun for Flight A998.\",\n\t\t\tAction: \"View\",\n\t\t},\n\t\tURLArgs: []string{\"boarding\", \"A998\"},\n\t}\n\texpected := []byte(`{\"aps\":{\"alert\":{\"title\":\"Flight A998 Now Boarding\",\"body\":\"Boarding has begun for Flight A998.\",\"action\":\"View\"},\"url-args\":[\"boarding\",\"A998\"]}}`)\n\ttestPayload(t, p, expected)\n}\n\nfunc TestValidBrowser(t *testing.T) {\n\tp := payload.Browser{\n\t\tAlert: payload.BrowserAlert{\n\t\t\tTitle: \"Flight A998 Now Boarding\",\n\t\t\tBody:  \"Boarding has begun for Flight A998.\",\n\t\t},\n\t}\n\tif err := p.Validate(); err != nil {\n\t\tt.Errorf(\"Expected no error, got %v.\", err)\n\t}\n}\n\nfunc TestInvalidBrowser(t *testing.T) {\n\ttests := []*payload.Browser{\n\t\t{\n\t\t\tAlert: payload.BrowserAlert{Action: \"View\"},\n\t\t},\n\t\t{},\n\t\tnil,\n\t}\n\n\tfor _, p := range tests {\n\t\tif err := p.Validate(); err != payload.ErrIncomplete {\n\t\t\tt.Errorf(\"Expected err %v, got %v.\", payload.ErrIncomplete, err)\n\t\t}\n\t}\n}\n\nfunc ExampleBrowser() ", "output": "{\n\tp := payload.Browser{\n\t\tAlert: payload.BrowserAlert{\n\t\t\tTitle:  \"Flight A998 Now Boarding\",\n\t\t\tBody:   \"Boarding has begun for Flight A998.\",\n\t\t\tAction: \"View\",\n\t\t},\n\t\tURLArgs: []string{\"boarding\", \"A998\"},\n\t}\n\n\tb, err := json.Marshal(p)\n\tif err != nil {\n\t}\n\tfmt.Printf(\"%s\", b)\n}"}
{"input": "package client\n\nimport (\n\t\"encoding/xml\"\n)\n\ntype Frame struct {\n\tID            string `xml:\"id,attr\"`\n\tFrameType     int\n\tOpMode        int\n\tName          string\n\tContact       string\n\tOSVersion     string\n\tVersion       string\n\tIsConnected   int\n\tSyncedSetting int\n\n}\n\n\ntype FrameCollection map[string]Frame\n\nfunc (col *FrameCollection) UnmarshalXML(d *xml.Decoder, e xml.StartElement) error {\n\treturn unmarshalXMLCol(col, d, e)\n}\n\n\n\nfunc (col FrameCollection) MarshalJSON() ([]byte, error) ", "output": "{\n\treturn marshalJSONMap(col)\n}"}
{"input": "package initializer\n\nimport (\n\t\"k8s.io/apiserver/pkg/admission\"\n\t\"k8s.io/apiserver/pkg/authorization/authorizer\"\n\t\"k8s.io/client-go/informers\"\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/component-base/featuregate\"\n)\n\ntype pluginInitializer struct {\n\texternalClient    kubernetes.Interface\n\texternalInformers informers.SharedInformerFactory\n\tauthorizer        authorizer.Authorizer\n\tfeatureGates      featuregate.FeatureGate\n}\n\n\n\n\nfunc New(\n\textClientset kubernetes.Interface,\n\textInformers informers.SharedInformerFactory,\n\tauthz authorizer.Authorizer,\n\tfeatureGates featuregate.FeatureGate,\n) pluginInitializer {\n\treturn pluginInitializer{\n\t\texternalClient:    extClientset,\n\t\texternalInformers: extInformers,\n\t\tauthorizer:        authz,\n\t\tfeatureGates:      featureGates,\n\t}\n}\n\n\n\n\n\nvar _ admission.PluginInitializer = pluginInitializer{}\n\nfunc (i pluginInitializer) Initialize(plugin admission.Interface) ", "output": "{\n\tif wants, ok := plugin.(WantsFeatures); ok {\n\t\twants.InspectFeatureGates(i.featureGates)\n\t}\n\n\tif wants, ok := plugin.(WantsExternalKubeClientSet); ok {\n\t\twants.SetExternalKubeClientSet(i.externalClient)\n\t}\n\n\tif wants, ok := plugin.(WantsExternalKubeInformerFactory); ok {\n\t\twants.SetExternalKubeInformerFactory(i.externalInformers)\n\t}\n\n\tif wants, ok := plugin.(WantsAuthorizer); ok {\n\t\twants.SetAuthorizer(i.authorizer)\n\t}\n}"}
{"input": "package user\n\nimport (\n\t\"fmt\"\n\n\t\"k8s.io/apimachinery/pkg/util/validation/field\"\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/apis/extensions\"\n\tpsputil \"k8s.io/kubernetes/pkg/security/podsecuritypolicy/util\"\n)\n\n\ntype mustRunAs struct {\n\topts *extensions.RunAsUserStrategyOptions\n}\n\n\nfunc NewMustRunAs(options *extensions.RunAsUserStrategyOptions) (RunAsUserStrategy, error) {\n\tif options == nil {\n\t\treturn nil, fmt.Errorf(\"MustRunAsRange requires run as user options\")\n\t}\n\tif len(options.Ranges) == 0 {\n\t\treturn nil, fmt.Errorf(\"MustRunAsRange requires at least one range\")\n\t}\n\treturn &mustRunAs{\n\t\topts: options,\n\t}, nil\n}\n\n\nfunc (s *mustRunAs) Generate(pod *api.Pod, container *api.Container) (*int64, error) {\n\treturn &s.opts.Ranges[0].Min, nil\n}\n\n\nfunc (s *mustRunAs) Validate(fldPath *field.Path, _ *api.Pod, _ *api.Container, runAsNonRoot *bool, runAsUser *int64) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\n\tif runAsUser == nil {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"runAsUser\"), \"\"))\n\t\treturn allErrs\n\t}\n\n\tif !s.isValidUID(*runAsUser) {\n\t\tdetail := fmt.Sprintf(\"must be in the ranges: %v\", s.opts.Ranges)\n\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"runAsUser\"), *runAsUser, detail))\n\t}\n\treturn allErrs\n}\n\n\n\nfunc (s *mustRunAs) isValidUID(id int64) bool ", "output": "{\n\tfor _, rng := range s.opts.Ranges {\n\t\tif psputil.UserFallsInRange(id, rng) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"}
{"input": "package iso20022\n\n\ntype ATMTransaction26 struct {\n\n\tTypeOfOperation *ATMOperation1Code `xml:\"TpOfOpr,omitempty\"`\n\n\tTransactionIdentification *TransactionIdentifier1 `xml:\"TxId\"`\n\n\tReconciliationIdentification *Max35Text `xml:\"RcncltnId\"`\n\n\tTransactionResponse *ResponseType7 `xml:\"TxRspn\"`\n\n\tATMTotals []*ATMTotals1 `xml:\"ATMTtls,omitempty\"`\n\n\tCassette []*ATMCassette2 `xml:\"Csstt,omitempty\"`\n\n\tCommand []*ATMCommand7 `xml:\"Cmd,omitempty\"`\n}\n\nfunc (a *ATMTransaction26) SetTypeOfOperation(value string) {\n\ta.TypeOfOperation = (*ATMOperation1Code)(&value)\n}\n\nfunc (a *ATMTransaction26) AddTransactionIdentification() *TransactionIdentifier1 {\n\ta.TransactionIdentification = new(TransactionIdentifier1)\n\treturn a.TransactionIdentification\n}\n\nfunc (a *ATMTransaction26) SetReconciliationIdentification(value string) {\n\ta.ReconciliationIdentification = (*Max35Text)(&value)\n}\n\n\n\nfunc (a *ATMTransaction26) AddATMTotals() *ATMTotals1 {\n\tnewValue := new(ATMTotals1)\n\ta.ATMTotals = append(a.ATMTotals, newValue)\n\treturn newValue\n}\n\nfunc (a *ATMTransaction26) AddCassette() *ATMCassette2 {\n\tnewValue := new(ATMCassette2)\n\ta.Cassette = append(a.Cassette, newValue)\n\treturn newValue\n}\n\nfunc (a *ATMTransaction26) AddCommand() *ATMCommand7 {\n\tnewValue := new(ATMCommand7)\n\ta.Command = append(a.Command, newValue)\n\treturn newValue\n}\n\nfunc (a *ATMTransaction26) AddTransactionResponse() *ResponseType7 ", "output": "{\n\ta.TransactionResponse = new(ResponseType7)\n\treturn a.TransactionResponse\n}"}
{"input": "package utils_test\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/Konstantin8105/GoFea/input/point\"\n\t\"github.com/Konstantin8105/GoFea/utils\"\n)\n\nfunc TestLength2DZero(t *testing.T) {\n\tp0 := point.Dim2{\n\t\tX: 0.0,\n\t\tY: 0.0,\n\t}\n\tp1 := point.Dim2{\n\t\tX: 0.0,\n\t\tY: 0.0,\n\t}\n\tif utils.LengthDim2(p0, p1) > 0.0 {\n\t\tt.Errorf(\"Wrong zero length test\")\n\t}\n}\n\nfunc TestLength2DOne1(t *testing.T) {\n\tp0 := point.Dim2{\n\t\tX: 0.0,\n\t\tY: 0.0,\n\t}\n\tp1 := point.Dim2{\n\t\tX: 1.0,\n\t\tY: 0.0,\n\t}\n\tif utils.LengthDim2(p0, p1) != 1.0 {\n\t\tt.Errorf(\"Wrong test with length 1\")\n\t}\n}\n\n\n\nfunc TestLength2DOne3(t *testing.T) {\n\tp0 := point.Dim2{\n\t\tX: 0.0,\n\t\tY: 0.0,\n\t}\n\tp1 := point.Dim2{\n\t\tX: 1.0,\n\t\tY: 1.0,\n\t}\n\tif math.Abs(utils.LengthDim2(p0, p1)-math.Sqrt(2.0)) > 1e-7 {\n\t\tt.Errorf(\"Wrong test with length 1\")\n\t}\n}\n\nfunc TestLength2DOne2(t *testing.T) ", "output": "{\n\tp0 := point.Dim2{\n\t\tX: 0.0,\n\t\tY: 1.0,\n\t}\n\tp1 := point.Dim2{\n\t\tX: 0.0,\n\t\tY: 0.0,\n\t}\n\tif utils.LengthDim2(p0, p1) != 1.0 {\n\t\tt.Errorf(\"Wrong test with length 1\")\n\t}\n}"}
{"input": "package v1alpha1\n\nimport (\n\tv1alpha1 \"k8s.io/api/discovery/v1alpha1\"\n\t\"k8s.io/client-go/deprecated/scheme\"\n\trest \"k8s.io/client-go/rest\"\n)\n\ntype DiscoveryV1alpha1Interface interface {\n\tRESTClient() rest.Interface\n\tEndpointSlicesGetter\n}\n\n\ntype DiscoveryV1alpha1Client struct {\n\trestClient rest.Interface\n}\n\n\n\n\nfunc NewForConfig(c *rest.Config) (*DiscoveryV1alpha1Client, error) {\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := rest.RESTClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &DiscoveryV1alpha1Client{client}, nil\n}\n\n\n\nfunc NewForConfigOrDie(c *rest.Config) *DiscoveryV1alpha1Client {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n\n\nfunc New(c rest.Interface) *DiscoveryV1alpha1Client {\n\treturn &DiscoveryV1alpha1Client{c}\n}\n\nfunc setConfigDefaults(config *rest.Config) error {\n\tgv := v1alpha1.SchemeGroupVersion\n\tconfig.GroupVersion = &gv\n\tconfig.APIPath = \"/apis\"\n\tconfig.NegotiatedSerializer = scheme.Codecs.WithoutConversion()\n\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = rest.DefaultKubernetesUserAgent()\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (c *DiscoveryV1alpha1Client) RESTClient() rest.Interface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.restClient\n}\n\nfunc (c *DiscoveryV1alpha1Client) EndpointSlices(namespace string) EndpointSliceInterface ", "output": "{\n\treturn newEndpointSlices(c, namespace)\n}"}
{"input": "package iradix\n\n\n\n\ntype rawIterator struct {\n\tnode *Node\n\n\tstack []rawStackEntry\n\n\tpos *Node\n\n\tpath string\n}\n\n\n\ntype rawStackEntry struct {\n\tpath  string\n\tedges edges\n}\n\n\nfunc (i *rawIterator) Front() *Node {\n\treturn i.pos\n}\n\n\n\n\n\n\nfunc (i *rawIterator) Next() {\n\tif i.stack == nil && i.node != nil {\n\t\ti.stack = []rawStackEntry{\n\t\t\t{\n\t\t\t\tedges: edges{\n\t\t\t\t\tedge{node: i.node},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tfor len(i.stack) > 0 {\n\t\tn := len(i.stack)\n\t\tlast := i.stack[n-1]\n\t\telem := last.edges[0].node\n\n\t\tif len(last.edges) > 1 {\n\t\t\ti.stack[n-1].edges = last.edges[1:]\n\t\t} else {\n\t\t\ti.stack = i.stack[:n-1]\n\t\t}\n\n\t\tif len(elem.edges) > 0 {\n\t\t\tpath := last.path + string(elem.prefix)\n\t\t\ti.stack = append(i.stack, rawStackEntry{path, elem.edges})\n\t\t}\n\n\t\ti.pos = elem\n\t\ti.path = last.path + string(elem.prefix)\n\t\treturn\n\t}\n\n\ti.pos = nil\n\ti.path = \"\"\n}\n\nfunc (i *rawIterator) Path() string ", "output": "{\n\treturn i.path\n}"}
{"input": "package cart\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestSetRouteMethod(t *testing.T) {\n\tsrv := NewServer(80, mockHandler)\n\tsrv.Post(\"/hello\", mockHandler)\n\trt := srv.router.routes.Find([]string{\"hello\"}, \"POST\")\n\n\tif rt.key.method != \"POST\" {\n\t\tt.Fatalf(\"Should set method [POST] set [\" + rt.key.method + \"]\")\n\t}\n}\n\nfunc TestDispatchCorrectMethod(t *testing.T) {\n\tsrv := NewServer(80, mockHandler)\n\tsrv.Get(\"/hello\", mockHandler)\n\tsrv.Post(\"/hello\", mockHandler)\n\n\trt := srv.router.routes.Find([]string{\"hello\"}, \"POST\")\n\tif rt.key.method != \"POST\" {\n\t\tt.Fatalf(\"Should set method [POST] set [\" + rt.key.method + \"]\")\n\t}\n\n\trt = srv.router.routes.Find([]string{\"hello\"}, \"GET\")\n\tif rt.key.method != \"GET\" {\n\t\tt.Fatalf(\"Should set method [GET] set [\" + rt.key.method + \"]\")\n\t}\n}\n\nfunc TestSetRoutePath(t *testing.T) ", "output": "{\n\tsrv := NewServer(80, mockHandler)\n\tsrv.Get(\"/hello\", mockHandler)\n\trt := srv.router.routes.Find([]string{\"hello\"}, \"GET\")\n\n\tif rt.key.path != \"/hello\" {\n\t\tt.Fatalf(\"Should add route [/hello] added [\" + rt.key.path + \"]\")\n\t}\n}"}
{"input": "package logging\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype terribadLogMessage struct{}\n\n\nfunc (msg terribadLogMessage) DefaultLevel() Level {\n\tpanic(\"never panic while logging; it's not worth crashing the app!\")\n}\nfunc (msg terribadLogMessage) EachField(fn FieldReportFn) {\n\tpanic(\"never panic while logging; it's not worth crashing the app!\")\n}\n\nfunc TestLogMessagePanicking(t *testing.T) {\n\tlog, ctrl := NewLogSinkSpy(true)\n\n\tassert.NotPanics(t, func() {\n\t\tDeliver(log, terribadLogMessage{})\n\t})\n\n\tcalls := ctrl.CallsTo(\"Fields\")\n\tif assert.Len(t, calls, 2) {\n\t\tfields := calls[1].PassedArgs().Get(0).([]EachFielder)\n\t\tassert.IsType(t, &silentMessageError{}, fields[2])\n\t}\n}\n\nfunc (msg terribadLogMessage) Message() string ", "output": "{\n\tpanic(\"never panic while logging; it's not worth crashing the app!\")\n}"}
{"input": "package core\n\nimport (\n\t\"runtime\"\n\n\t\"github.com/Tzunami/go-earthdollar/core/types\"\n\t\"github.com/Tzunami/go-earthdollar/pow\"\n)\n\n\ntype nonceCheckResult struct {\n\tindex int  \n\tvalid bool \n}\n\n\n\n\n\n\n\n\n\nfunc verifyNoncesFromBlocks(checker pow.PoW, blocks []*types.Block) (chan<- struct{}, <-chan nonceCheckResult) {\n\titems := make([]pow.Block, len(blocks))\n\tfor i, block := range blocks {\n\t\titems[i] = block\n\t}\n\treturn verifyNonces(checker, items)\n}\n\n\n\nfunc verifyNonces(checker pow.PoW, items []pow.Block) (chan<- struct{}, <-chan nonceCheckResult) {\n\tworkers := runtime.GOMAXPROCS(0)\n\tif len(items) < workers {\n\t\tworkers = len(items)\n\t}\n\ttasks := make(chan int, workers)\n\tresults := make(chan nonceCheckResult, len(items)) \n\tfor i := 0; i < workers; i++ {\n\t\tgo func() {\n\t\t\tfor index := range tasks {\n\t\t\t\tresults <- nonceCheckResult{index: index, valid: checker.Verify(items[index])}\n\t\t\t}\n\t\t}()\n\t}\n\tabort := make(chan struct{})\n\tgo func() {\n\t\tdefer close(tasks)\n\n\t\tfor i := range items {\n\t\t\tselect {\n\t\t\tcase tasks <- i:\n\t\t\t\tcontinue\n\t\t\tcase <-abort:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn abort, results\n}\n\nfunc verifyNoncesFromHeaders(checker pow.PoW, headers []*types.Header) (chan<- struct{}, <-chan nonceCheckResult) ", "output": "{\n\titems := make([]pow.Block, len(headers))\n\tfor i, header := range headers {\n\t\titems[i] = types.NewBlockWithHeader(header)\n\t}\n\treturn verifyNonces(checker, items)\n}"}
{"input": "package event\n\nimport (\n\t\"testing\"\n\n\t\"github.com/xytis/gami\"\n)\n\n\n\nfunc TestUserEventEvent(t *testing.T) ", "output": "{\n\tfixture := map[string]string{\n\t\t\"Userevent\": \"UserEvent\",\n\t\t\"Uniqueid\":  \"UniqueID\",\n\t}\n\n\tev := gami.AMIEvent{\n\t\tID:        \"UserEvent\",\n\t\tPrivilege: []string{\"all\"},\n\t\tParams:    fixture,\n\t}\n\n\tevtype := New(&ev)\n\tif _, ok := evtype.(UserEvent); !ok {\n\t\tt.Log(\"UserEvent type assertion\")\n\t\tt.Fail()\n\t}\n\n\ttestEvent(t, fixture, evtype)\n}"}
{"input": "package dhcpv4\n\nimport \"encoding/binary\"\n\n\n\ntype DHCPAck struct {\n\tPacket\n\n\treq Request\n}\n\nfunc CreateDHCPAck(req Request) DHCPAck {\n\trep := DHCPAck{\n\t\tPacket: NewReply(req),\n\t\treq:    req,\n\t}\n\n\trep.SetMessageType(MessageTypeDHCPAck)\n\treturn rep\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar dhcpAckOnRequestValidation = []Validation{\n\tValidateMust(OptionAddressTime),\n}\n\nvar dhcpAckOnInformValidation = []Validation{\n\tValidateMustNot(OptionAddressTime),\n}\n\nvar dhcpAckValidation = []Validation{\n\tValidateMustNot(OptionAddressRequest),\n\tValidateMustNot(OptionParameterList),\n\tValidateMustNot(OptionClientID),\n\tValidateMust(OptionDHCPServerID),\n\tValidateMustNot(OptionDHCPMaxMsgSize),\n}\n\nfunc (d DHCPAck) Validate() error {\n\tvar err error\n\n\tswitch d.req.GetMessageType() {\n\tcase MessageTypeDHCPRequest:\n\t\terr = Validate(d.Packet, dhcpAckOnRequestValidation)\n\tcase MessageTypeDHCPInform:\n\t\terr = Validate(d.Packet, dhcpAckOnInformValidation)\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn Validate(d.Packet, dhcpAckValidation)\n}\n\nfunc (d DHCPAck) ToBytes() ([]byte, error) {\n\topts := packetToBytesOptions{}\n\n\tif v, ok := d.Request().GetOption(OptionDHCPMaxMsgSize); ok {\n\t\topts.maxLen = binary.BigEndian.Uint16(v)\n\t}\n\n\treturn PacketToBytes(d.Packet, &opts)\n}\n\n\n\nfunc (d DHCPAck) Request() Request ", "output": "{\n\treturn d.req\n}"}
{"input": "package ginkgoext\n\nimport (\n\t\"github.com/onsi/gomega/types\"\n)\n\ntype anythingMatcher struct{}\n\nfunc (matcher *anythingMatcher) Match(actual interface{}) (success bool, err error) {\n\treturn true, nil\n}\n\nfunc (matcher *anythingMatcher) FailureMessage(actual interface{}) (message string) {\n\treturn \"\"\n}\n\nfunc (matcher *anythingMatcher) NegatedFailureMessage(actual interface{}) (message string) {\n\treturn \"\"\n}\n\n\n\n\nfunc BeAnything() types.GomegaMatcher ", "output": "{\n\treturn &anythingMatcher{}\n}"}
{"input": "package main\n\ntype DummyBackendQueue struct {\n\treadChan chan []byte\n}\n\nfunc NewDummyBackendQueue() BackendQueue {\n\treturn &DummyBackendQueue{readChan: make(chan []byte)}\n}\n\n\n\nfunc (d *DummyBackendQueue) ReadChan() chan []byte {\n\treturn d.readChan\n}\n\nfunc (d *DummyBackendQueue) Close() error {\n\treturn nil\n}\n\nfunc (d *DummyBackendQueue) Depth() int64 {\n\treturn int64(0)\n}\n\nfunc (d *DummyBackendQueue) Empty() error {\n\treturn nil\n}\n\nfunc (d *DummyBackendQueue) Put([]byte) error ", "output": "{\n\treturn nil\n}"}
{"input": "package cloudsigma\n\nconst (\n\tEndpointBurstUsage = \"burstusage\"\n)\n\n\ntype BurstUsage struct {\n\tArgs *Args\n}\n\n\nfunc NewBurstUsage() *BurstUsage {\n\to := BurstUsage{}\n\to.Args = NewArgs()\n\to.Args.Resource = EndpointBurstUsage\n\treturn &o\n}\n\n\n\n\nfunc (o *BurstUsage) NewList() *Args ", "output": "{\n\to.Args.Verb = \"GET\"\n\to.Args.RequiresAuth = true\n\treturn o.Args\n}"}
{"input": "package wincred\n\nimport (\n\twinc \"github.com/danieljoos/wincred\"\n\t\"github.com/docker/docker-credential-helpers/credentials\"\n)\n\n\ntype Wincred struct{}\n\n\nfunc (h Wincred) Add(creds *credentials.Credentials) error {\n\tg := winc.NewGenericCredential(creds.ServerURL)\n\tg.UserName = creds.Username\n\tg.CredentialBlob = []byte(creds.Secret)\n\tg.Persist = winc.PersistLocalMachine\n\treturn g.Write()\n}\n\n\nfunc (h Wincred) Delete(serverURL string) error {\n\tg, err := winc.GetGenericCredential(serverURL)\n\tif g == nil {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn g.Delete()\n}\n\n\n\n\n\nfunc (h Wincred) List() (map[string]string, error) {\n\tcreds, err := winc.List()\n\tpaths := make([]string, len(creds))\n\taccts := make([]string, len(creds))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp := make(map[string]string)\n\tfor i := range creds {\n\t\tresp[creds[i].TargetName] = creds[i].UserName\n\t}\n\treturn resp, nil\n}\n\nfunc (h Wincred) Get(serverURL string) (string, string, error) ", "output": "{\n\tg, _ := winc.GetGenericCredential(serverURL)\n\tif g == nil {\n\t\treturn \"\", \"\", credentials.NewErrCredentialsNotFound()\n\t}\n\treturn g.UserName, string(g.CredentialBlob), nil\n}"}
{"input": "package state\n\nimport (\n\t\"net/url\"\n\n\t\"gopkg.in/juju/charm.v3\"\n)\n\n\ntype charmDoc struct {\n\tURL           *charm.URL `bson:\"_id\"`\n\tMeta          *charm.Meta\n\tConfig        *charm.Config\n\tActions       *charm.Actions\n\tBundleURL     *url.URL\n\tBundleSha256  string\n\tPendingUpload bool\n\tPlaceholder   bool\n}\n\n\ntype Charm struct {\n\tst  *State\n\tdoc charmDoc\n}\n\nfunc newCharm(st *State, cdoc *charmDoc) (*Charm, error) {\n\treturn &Charm{st: st, doc: *cdoc}, nil\n}\n\nfunc (c *Charm) String() string {\n\treturn c.doc.URL.String()\n}\n\n\nfunc (c *Charm) URL() *charm.URL {\n\tclone := *c.doc.URL\n\treturn &clone\n}\n\n\n\nfunc (c *Charm) Revision() int {\n\treturn c.doc.URL.Revision\n}\n\n\nfunc (c *Charm) Meta() *charm.Meta {\n\treturn c.doc.Meta\n}\n\n\nfunc (c *Charm) Config() *charm.Config {\n\treturn c.doc.Config\n}\n\n\n\n\n\n\nfunc (c *Charm) BundleURL() *url.URL {\n\treturn c.doc.BundleURL\n}\n\n\nfunc (c *Charm) BundleSha256() string {\n\treturn c.doc.BundleSha256\n}\n\n\n\nfunc (c *Charm) IsUploaded() bool {\n\treturn !c.doc.PendingUpload\n}\n\n\n\nfunc (c *Charm) IsPlaceholder() bool {\n\treturn c.doc.Placeholder\n}\n\nfunc (c *Charm) Actions() *charm.Actions ", "output": "{\n\treturn c.doc.Actions\n}"}
{"input": "package master\n\nimport ()\n\n\n\ntype frame struct {\n\tjob       *job\n\tslaveName string\n\tframe     int\n\tdata      []byte\n\tprogress  byte\n\tcompleted bool\n}\n\n\n\nfunc NewFrame(job *job, fr int) *frame {\n\treturn &frame{\n\t\tjob:       job,\n\t\tslaveName: \"\",\n\t\tframe:     fr,\n\t\tdata:      nil,\n\t\tprogress:  0,\n\t\tcompleted: false,\n\t}\n}\n\n\n\nfunc (f *frame) Job() *job {\n\treturn f.job\n}\n\nfunc (f *frame) SlaveName() string {\n\treturn f.slaveName\n}\n\nfunc (f *frame) Frame() int {\n\treturn f.frame\n}\n\nfunc (f *frame) AlignedFrame() int {\n\treturn f.frame + f.Job().Start()\n}\n\n\n\nfunc (f *frame) Progress() byte {\n\treturn f.progress\n}\n\nfunc (f *frame) Completed() bool {\n\treturn f.completed\n}\n\nfunc (f *frame) File() []byte {\n\treturn f.Job().File()\n}\n\n\n\nfunc (f *frame) SetSlaveName(slaveName string) {\n\tf.slaveName = slaveName\n}\n\nfunc (f *frame) SetData(data []byte) {\n\tf.data = data\n}\n\nfunc (f *frame) SetProgress(progress byte) {\n\tf.progress = progress\n}\n\nfunc (f *frame) SetCompleted(completed bool) {\n\tf.completed = completed\n\tif completed {\n\t\tf.SetProgress(100)\n\t}\n}\n\n\n\nfunc (f *frame) Reset() {\n\tf.SetSlaveName(\"\")\n\tf.SetData(nil)\n\tf.SetProgress(0)\n\tf.SetCompleted(false)\n}\n\nfunc (f *frame) Data() []byte ", "output": "{\n\treturn f.data\n}"}
{"input": "package gui\n\nimport (\n\t\"github.com/go-gl/gl/v3.3-core/gl\"\n)\n\ntype Image struct {\n\tStaticComponentImpl\n\ttexture uint32\n}\n\n\n\nfunc (img *Image) Render() ", "output": "{\n\tgl.ActiveTexture(gl.TEXTURE0)\n\tgl.BindTexture(gl.TEXTURE_2D, img.texture)\n\n}"}
{"input": "package graph\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestLinksTo(t *testing.T) ", "output": "{\n\tts := new(TestTripleStore)\n\ttsFixed := newFixedIterator()\n\ttsFixed.AddValue(2)\n\tts.On(\"GetIdFor\", \"cool\").Return(1)\n\tts.On(\"GetTripleIterator\", Object, 1).Return(tsFixed)\n\tfixed := newFixedIterator()\n\tfixed.AddValue(ts.GetIdFor(\"cool\"))\n\tlto := NewLinksToIterator(ts, fixed, Object)\n\tval, ok := lto.Next()\n\tif !ok {\n\t\tt.Error(\"At least one triple matches the fixed object\")\n\t}\n\tif val != 2 {\n\t\tt.Errorf(\"Triple index 2, such as %s, should match %s\", ts.GetTriple(2), ts.GetTriple(val))\n\t}\n}"}
{"input": "package task\n\nimport \"time\"\n\nconst (\n\tdownloadName     = \"download\"\n\ttestName         = \"test\"\n\tcoverageName     = \"coverage\"\n\tchecklistName    = \"checklist\"\n\tthirdPartiesName = \"thirdparties\"\n\tlocName          = \"loc\"\n\tlintName         = \"lint\"\n)\n\n\ntype Runner struct {\n\tLabel string `json:\"label\"`\n\n\tData interface{} `json:\"data,omitempty\"`\n\n\tRawOutput string `json:\"rawOutput,omitempty\"`\n\n\tExecutionTime time.Duration `json:\"executionTime\"`\n\n\tMgr *Manager `json:\"-\"`\n}\n\n\ntype Runnable interface {\n\tName() string\n\tExecute() error\n\tManager() *Manager\n}\n\n\nfunc (r *Runner) Manager() *Manager {\n\treturn r.Mgr\n}\n\n\n\n\n\nfunc (r *Runner) Execute() {\n}\n\n\nfunc (r *Runner) trackTime(start time.Time) {\n\tr.ExecutionTime = time.Since(start)\n}\n\nfunc (r *Runner) Name() string ", "output": "{\n\treturn r.Label\n}"}
{"input": "package repodelete\n\nvar Usage = []string{\"rt rdel <repository pattern>\"}\n\nfunc GetDescription() string {\n\treturn \"Permanently delete repositories with all of their content from Artifactory.\"\n}\n\n\n\nfunc GetArguments() string ", "output": "{\n\treturn `\trepository pattern\n\t\tSpecifies the repositories that should be removed. You can use wildcards to specify multiple repositories.`\n}"}
{"input": "package lzma\n\n\nconst (\n\tMinLC       = 0\n\tMaxLC       = 8\n\tMinLP       = 0\n\tMaxLP       = 4\n\tMinPB       = 0\n\tMaxPB       = 4\n\tMinDictSize = 1 << 12\n\tMaxDictSize = 1<<32 - 1\n)\n\n\ntype Properties byte\n\n\n\n\n\n\nfunc (p Properties) LC() int {\n\treturn int(p) % 9\n}\n\n\nfunc (p Properties) LP() int {\n\treturn (int(p) / 9) % 5\n}\n\n\nfunc (p Properties) PB() int {\n\treturn (int(p) / 45) % 5\n}\n\n\nfunc verifyProperties(lc, lp, pb int) error {\n\tif !(MinLC <= lc && lc <= MaxLC) {\n\t\treturn rangeError{\"lc\", lc}\n\t}\n\tif !(MinLP <= lp && lp <= MaxLC) {\n\t\treturn rangeError{\"lp\", lp}\n\t}\n\tif !(MinPB <= pb && pb <= MaxPB) {\n\t\treturn rangeError{\"pb\", pb}\n\t}\n\treturn nil\n}\n\nfunc NewProperties(lc, lp, pb int) (p Properties, err error) ", "output": "{\n\tif err = verifyProperties(lc, lp, pb); err != nil {\n\t\treturn\n\t}\n\treturn Properties((pb*5+lp)*9 + lc), nil\n}"}
{"input": "package subscriptions\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype SubscriptionID string\n\ntype Subscription struct {\n\tmu      sync.RWMutex\n\tid      SubscriptionID\n\tsignal  *filterSignal\n\tquit    chan struct{}\n\tfilter  filter\n\tstarted bool\n}\n\n\n\nfunc (s *Subscription) Start(checkPeriod time.Duration) error {\n\ts.mu.Lock()\n\tif s.started {\n\t\ts.mu.Unlock()\n\t\treturn errors.New(\"subscription already started or used\")\n\t}\n\ts.started = true\n\ts.quit = make(chan struct{})\n\tquit := s.quit\n\ts.mu.Unlock()\n\n\tticker := time.NewTicker(checkPeriod)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tfilterData, err := s.filter.getChanges()\n\t\t\tif err != nil {\n\t\t\t\ts.signal.SendError(err)\n\t\t\t} else if len(filterData) > 0 {\n\t\t\t\ts.signal.SendData(filterData)\n\t\t\t}\n\t\tcase <-quit:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (s *Subscription) Stop(uninstall bool) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif !s.started {\n\t\treturn nil\n\t}\n\tselect {\n\tcase _, ok := <-s.quit:\n\t\tif !ok {\n\t\t\treturn nil\n\t\t}\n\tdefault:\n\t\tclose(s.quit)\n\t}\n\tif !uninstall {\n\t\treturn nil\n\t}\n\treturn s.filter.uninstall()\n}\n\nfunc NewSubscriptionID(namespace, filterID string) SubscriptionID {\n\treturn SubscriptionID(fmt.Sprintf(\"%s-%s\", namespace, filterID))\n}\n\nfunc NewSubscription(namespace string, filter filter) *Subscription ", "output": "{\n\tsubscriptionID := NewSubscriptionID(namespace, filter.getID())\n\treturn &Subscription{\n\t\tid:     subscriptionID,\n\t\tsignal: newFilterSignal(string(subscriptionID)),\n\t\tfilter: filter,\n\t}\n}"}
{"input": "package sys\n\nimport \"github.com/e-XpertSolutions/f5-rest-client/f5\"\n\n\ntype DaemonLogSettingsLindConfigList struct {\n\tItems    []DaemonLogSettingsLindConfig `json:\"items\"`\n\tKind     string                        `json:\"kind\"`\n\tSelfLink string                        `json:\"selflink\"`\n}\n\n\ntype DaemonLogSettingsLindConfig struct {\n}\n\n\nconst DaemonLogSettingsLindEndpoint = \"/daemon-log-settings/lind\"\n\n\ntype DaemonLogSettingsLindResource struct {\n\tc *f5.Client\n}\n\n\nfunc (r *DaemonLogSettingsLindResource) ListAll() (*DaemonLogSettingsLindConfigList, error) {\n\tvar list DaemonLogSettingsLindConfigList\n\tif err := r.c.ReadQuery(BasePath+DaemonLogSettingsLindEndpoint, &list); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &list, nil\n}\n\n\nfunc (r *DaemonLogSettingsLindResource) Get(id string) (*DaemonLogSettingsLindConfig, error) {\n\tvar item DaemonLogSettingsLindConfig\n\tif err := r.c.ReadQuery(BasePath+DaemonLogSettingsLindEndpoint, &item); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &item, nil\n}\n\n\nfunc (r *DaemonLogSettingsLindResource) Create(item DaemonLogSettingsLindConfig) error {\n\tif err := r.c.ModQuery(\"POST\", BasePath+DaemonLogSettingsLindEndpoint, item); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\n\n\n\nfunc (r *DaemonLogSettingsLindResource) Delete(id string) error {\n\tif err := r.c.ModQuery(\"DELETE\", BasePath+DaemonLogSettingsLindEndpoint+\"/\"+id, nil); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (r *DaemonLogSettingsLindResource) Edit(id string, item DaemonLogSettingsLindConfig) error ", "output": "{\n\tif err := r.c.ModQuery(\"PUT\", BasePath+DaemonLogSettingsLindEndpoint+\"/\"+id, item); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package discovery\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"sync/atomic\"\n)\n\n\ntype Service struct {\n\tID   uint64 `json:\"id\"`\n\tName string `json:\"name\"`\n\tHost string `json:\"host\"`\n\tPort int    `json:\"port\"`\n\n\tlastIndex uint64\n\tquit      chan struct{}\n}\n\n\n\n\n\nfunc (srv *Service) Stop() {\n\tvar s struct{}\n\tsrv.quit <- s\n}\n\n\nfunc (srv *Service) SetIndex(index uint64) {\n\tatomic.StoreUint64(&srv.lastIndex, index)\n}\n\n\nfunc (srv *Service) GetIndex() uint64 {\n\treturn atomic.LoadUint64(&srv.lastIndex)\n}\n\nfunc (srv *Service) String() string {\n\tb, err := json.Marshal(srv)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn \"\"\n\t}\n\n\treturn string(b)\n}\n\nfunc NewService(name, host string, port int) *Service ", "output": "{\n\treturn &Service{\n\t\tName: name,\n\t\tHost: host,\n\t\tPort: port,\n\t\tquit: make(chan struct{}, 1),\n\t}\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSOpsWorksApp_Source struct {\n\n\tPassword string `json:\"Password,omitempty\"`\n\n\tRevision string `json:\"Revision,omitempty\"`\n\n\tSshKey string `json:\"SshKey,omitempty\"`\n\n\tType string `json:\"Type,omitempty\"`\n\n\tUrl string `json:\"Url,omitempty\"`\n\n\tUsername string `json:\"Username,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSOpsWorksApp_Source) AWSCloudFormationType() string {\n\treturn \"AWS::OpsWorks::App.Source\"\n}\n\n\n\n\n\n\n\nfunc (r *AWSOpsWorksApp_Source) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSOpsWorksApp_Source) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSOpsWorksApp_Source) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSOpsWorksApp_Source) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSOpsWorksApp_Source) DependsOn() []string ", "output": "{\n\treturn r._dependsOn\n}"}
{"input": "package statement\n\nimport (\n\t\"time\"\n)\n\n\n\ntype ResponseTime struct {\n\tValue int\n\tTime  time.Time\n}\n\n\n\nfunc NewResponseTime(v int) ResponseTime {\n\tr := ResponseTime{Value: v, Time: time.Now()}\n\treturn r\n}\n\n\ntype ResponseTimes []ResponseTime\n\n\n\n\n\n\n\nfunc (rs ResponseTimes) Less(i, j int) bool {\n\treturn rs[i].Value < rs[j].Value\n}\n\n\n\nfunc (rs ResponseTimes) Swap(i, j int) {\n\trs[i], rs[j] = rs[j], rs[i]\n}\n\nfunc (rs ResponseTimes) Len() int ", "output": "{\n\treturn len(rs)\n}"}
{"input": "package util\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n\n\ntype EnumFlag struct {\n\tdefaultValue string\n\tvs           []string\n\ti            int\n}\n\n\n\nfunc NewEnumFlag(defaultValue string, vs []string) *EnumFlag {\n\tf := &EnumFlag{\n\t\ti:            -1,\n\t\tvs:           vs,\n\t\tdefaultValue: defaultValue,\n\t}\n\treturn f\n}\n\n\nfunc (f *EnumFlag) Type() string {\n\treturn \"{\" + strings.Join(f.vs, \",\") + \"}\"\n}\n\n\nfunc (f *EnumFlag) String() string {\n\tif f.i == -1 {\n\t\treturn f.defaultValue\n\t}\n\treturn f.vs[f.i]\n}\n\n\n\n\n\n\nfunc (f *EnumFlag) Set(s string) error {\n\tfor i := range f.vs {\n\t\tif f.vs[i] == s {\n\t\t\tf.i = i\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn fmt.Errorf(\"must be one of %v\", f.Type())\n}\n\nfunc (f *EnumFlag) IsSet() bool ", "output": "{\n\treturn f.i != -1\n}"}
{"input": "package tournaments\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\n\t\"appengine\"\n\n\t\"github.com/taironas/gonawin/extract\"\n\t\"github.com/taironas/gonawin/helpers\"\n\ttemplateshlp \"github.com/taironas/gonawin/helpers/templates\"\n\n\tmdl \"github.com/taironas/gonawin/models\"\n)\n\n\n\ntype GroupJSON struct {\n\tName  string\n\tTeams []TeamJSON\n}\n\n\n\ntype TeamJSON struct {\n\tName   string\n\tPoints int64\n\tGoalsF int64\n\tGoalsA int64\n\tIso    string\n}\n\n\n\n\n\n\n\nfunc formatGroupsJSON(groups []*mdl.Tgroup) []GroupJSON {\n\n\tgroupsJSON := make([]GroupJSON, len(groups))\n\tfor i, g := range groups {\n\t\tgroupsJSON[i].Name = g.Name\n\t\tteams := make([]TeamJSON, len(g.Teams))\n\t\tfor j, t := range g.Teams {\n\t\t\tteams[j].Name = t.Name\n\t\t\tteams[j].Points = g.Points[j]\n\t\t\tteams[j].GoalsF = g.GoalsF[j]\n\t\t\tteams[j].GoalsA = g.GoalsA[j]\n\t\t\tteams[j].Iso = t.Iso\n\t\t}\n\t\tgroupsJSON[i].Teams = teams\n\t}\n\treturn groupsJSON\n}\n\nfunc Groups(w http.ResponseWriter, r *http.Request, u *mdl.User) error ", "output": "{\n\tif r.Method != \"GET\" {\n\t\treturn &helpers.BadRequest{Err: errors.New(helpers.ErrorCodeNotSupported)}\n\t}\n\n\tc := appengine.NewContext(r)\n\tdesc := \"Tournament Group Handler:\"\n\textract := extract.NewContext(c, desc, r)\n\n\tvar err error\n\tvar tournament *mdl.Tournament\n\tif tournament, err = extract.Tournament(); err != nil {\n\t\treturn err\n\t}\n\n\tgroups := mdl.Groups(c, tournament.GroupIds)\n\tgroupsJSON := formatGroupsJSON(groups)\n\n\tdata := struct {\n\t\tGroups []GroupJSON\n\t}{\n\t\tgroupsJSON,\n\t}\n\n\treturn templateshlp.RenderJSON(w, c, data)\n}"}
{"input": "package api\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestCrawlFetchAtom(t *testing.T) {\n\tcast := <-crawl.fetch(testAtom)\n\tassert.NotNil(t, cast)\n\tassert.Equal(t, testAtom, cast.URL)\n\tassert.Equal(t, \"Example Feed\", cast.Name)\n}\n\nfunc TestCrawlFetch(t *testing.T) ", "output": "{\n\tcast := <-crawl.fetch(testRSS)\n\tassert.NotNil(t, cast)\n\tassert.Equal(t, testRSS, cast.URL)\n\tassert.Equal(t, \"BSD Now HD\", cast.Name)\n\n\tassert.Nil(t, <-crawl.fetch(\"so_bad\"))\n\n\tassert.Nil(t, <-crawl.fetch(testServer.URL))\n\n\tassert.Nil(t, <-crawl.fetch(testServer.URL+\"/notxml\"))\n\n\tassert.Nil(t, <-crawl.fetch(testServer.URL+\"/notfeed\"))\n\tassert.Nil(t, <-crawl.fetch(testServer.URL+\"/badrss\"))\n\tassert.Nil(t, <-crawl.fetch(testServer.URL+\"/badatom\"))\n}"}
{"input": "package milter\n\n\n\ntype Response interface {\n\tResponse() *Message\n\tContinue() bool\n}\n\n\ntype SimpleResponse byte\n\n\n\n\n\nfunc (r SimpleResponse) Continue() bool {\n\treturn byte(r) == rspContinue\n}\n\n\nconst (\n\tRespAccept   = SimpleResponse(rspAccept)\n\tRespContinue = SimpleResponse(rspContinue)\n\tRespDiscard  = SimpleResponse(rspDiscard)\n\tRespReject   = SimpleResponse(rspReject)\n\tRespTempFail = SimpleResponse(rspTempFail)\n)\n\n\n\ntype CustomResponse struct {\n\tcode byte\n\tdata []byte\n}\n\n\nfunc (c *CustomResponse) Response() *Message {\n\treturn &Message{c.code, c.data}\n}\n\n\nfunc (c *CustomResponse) Continue() bool {\n\tfor _, q := range []byte{rspAccept, rspDiscard, rspReject, rspTempFail} {\n\t\tif c.code == q {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\nfunc NewResponse(code byte, data []byte) *CustomResponse {\n\treturn &CustomResponse{code, data}\n}\n\n\nfunc NewResponseStr(code byte, data string) *CustomResponse {\n\treturn NewResponse(code, []byte(data+null))\n}\n\nfunc (r SimpleResponse) Response() *Message ", "output": "{\n\treturn &Message{byte(r), nil}\n}"}
{"input": "package common\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/rakyll/globalconf\"\n)\n\n\ntype ConfigManager struct {\n\tExecPath string\n\tDebug    bool\n\tDiff     bool\n\tDiffType string\n\tParanoia bool\n\tVmType   int\n\n\tconf *globalconf.GlobalConf\n}\n\n\n\n\n\n\n\nfunc (c *ConfigManager) Save(key string, value interface{}) {\n\tf := &flag.Flag{Name: key, Value: newConfValue(value)}\n\tc.conf.Set(\"\", f)\n}\n\nfunc (c *ConfigManager) Delete(key string) {\n\tc.conf.Delete(\"\", key)\n}\n\n\ntype confValue struct {\n\tvalue string\n}\n\n\nfunc newConfValue(value interface{}) *confValue {\n\treturn &confValue{fmt.Sprintf(\"%v\", value)}\n}\n\nfunc (self confValue) String() string     { return self.value }\nfunc (self confValue) Set(s string) error { self.value = s; return nil }\n\nfunc ReadConfig(ConfigFile string, Datadir string, EnvPrefix string) *ConfigManager ", "output": "{\n\tif !FileExist(ConfigFile) {\n\t\tfmt.Printf(\"config file '%s' doesn't exist, creating it\\n\", ConfigFile)\n\t\tos.Create(ConfigFile)\n\t}\n\tg, err := globalconf.NewWithOptions(&globalconf.Options{\n\t\tFilename:  ConfigFile,\n\t\tEnvPrefix: EnvPrefix,\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tg.ParseAll()\n\t}\n\tcfg := &ConfigManager{ExecPath: Datadir, Debug: true, conf: g, Paranoia: true}\n\treturn cfg\n}"}
{"input": "package insertion\n\nimport (\n\t\"testing\"\n\n\t\"github.com/midnight-vivian/go-data-structures/utils\"\n)\n\n\n\nfunc TestSort(t *testing.T) ", "output": "{\n\tif !utils.SortTest(1000, Sort) {\n\t\tt.Error(\"Not Sorted!\")\n\t}\n}"}
{"input": "package utils\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n)\n\n\n\nfunc TestUtils(t *testing.T) ", "output": "{\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Utils Suite\")\n}"}
{"input": "package models\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n\n\t\"github.com/gobuffalo/pop/v5\"\n\t\"github.com/gobuffalo/validate/v3\"\n\t\"github.com/gobuffalo/validate/v3/validators\"\n\t\"github.com/gofrs/uuid\"\n)\n\n\ntype Post struct {\n\tID        uuid.UUID `json:\"id\" db:\"id\"`\n\tCreatedAt time.Time `json:\"created_at\" db:\"created_at\"`\n\tUpdatedAt time.Time `json:\"updated_at\" db:\"updated_at\"`\n\tTitle     string    `json:\"title\" db:\"title\"`\n\tContent   string    `json:\"content\" db:\"content\"`\n\tUserID    uuid.UUID `json:\"user_id\" db:\"user_id\" form:\"-\"`\n}\n\n\n\n\n\ntype Posts []Post\n\n\nfunc (p Posts) String() string {\n\tjp, _ := json.Marshal(p)\n\treturn string(jp)\n}\n\n\n\nfunc (p *Post) Validate(tx *pop.Connection) (*validate.Errors, error) {\n\treturn validate.Validate(\n\t\t&validators.StringIsPresent{Field: p.Title, Name: \"Title\"},\n\t\t&validators.StringIsPresent{Field: p.Content, Name: \"Content\"},\n\t), nil\n}\n\n\n\nfunc (p *Post) ValidateSave(tx *pop.Connection) (*validate.Errors, error) {\n\treturn validate.NewErrors(), nil\n}\n\n\n\nfunc (p *Post) ValidateUpdate(tx *pop.Connection) (*validate.Errors, error) {\n\treturn validate.NewErrors(), nil\n}\n\nfunc (p Post) String() string ", "output": "{\n\tjp, _ := json.Marshal(p)\n\treturn string(jp)\n}"}
{"input": "package utils\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/heketi/heketi/tests\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestNewStatusGroup(t *testing.T) {\n\ts := NewStatusGroup()\n\ttests.Assert(t, s != nil)\n\ttests.Assert(t, s.results != nil)\n\ttests.Assert(t, len(s.results) == 0)\n\ttests.Assert(t, s.err == nil)\n}\n\nfunc TestStatusGroupSuccess(t *testing.T) {\n\n\ts := NewStatusGroup()\n\n\tmax := 100\n\ts.Add(max)\n\n\tfor i := 0; i < max; i++ {\n\t\tgo func(value int) {\n\t\t\tdefer s.Done()\n\t\t\ttime.Sleep(time.Millisecond * 1 * time.Duration(value))\n\t\t}(i)\n\t}\n\n\terr := s.Result()\n\ttests.Assert(t, err == nil)\n\n}\n\n\n\nfunc TestStatusGroupFailure(t *testing.T) ", "output": "{\n\ts := NewStatusGroup()\n\n\tfor i := 0; i < 100; i++ {\n\n\t\ts.Add(1)\n\t\tgo func(value int) {\n\t\t\tdefer s.Done()\n\t\t\ttime.Sleep(time.Millisecond * 1 * time.Duration(value))\n\t\t\tif value%10 == 0 {\n\t\t\t\ts.Err(errors.New(fmt.Sprintf(\"Err: %v\", value)))\n\t\t\t}\n\n\t\t}(i)\n\n\t}\n\n\terr := s.Result()\n\n\ttests.Assert(t, err != nil)\n\ttests.Assert(t, err.Error() == \"Err: 90\", err)\n\n}"}
{"input": "package docs\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"lib/config\"\n\t\"os\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/golang/glog\"\n)\n\n\nfunc compileHelpTemplate(buffer *bytes.Buffer, templateName string, templateData map[string]string) (reterr error) {\n\n\ttmpl := getTemplate(\"_head\")\n    reterr = tmpl.Execute(buffer, templateData)\n    if nil == reterr {\n\t\ttmpl = getTemplate(templateName)\n\t\treterr = tmpl.Execute(buffer, templateData)\n\t\tif nil == reterr {\n\t\t\tstats, reterr := os.Stat(\"/go/bin/docker-tools\")\n\t\t\tif nil == reterr {\n\t\t\t\ttemplateData[\"footBUILD_ID\"]   = fmt.Sprintf(\"%s\", os.Getenv(\"GIT_COMMIT\"))\n\t\t\t\ttemplateData[\"footBUILD_DATE\"] = fmt.Sprintf(\"%s\", stats.ModTime().Format(time.RFC3339))\n\t\t\t\ttmpl = getTemplate(\"_foot\")\n\t\t\t\treterr = tmpl.Execute(buffer, templateData)\n\t\t\t}\n\t\t}\n\t}\n\n    return\n}\n\n\n\n\n\nfunc getTemplate(tmplName string) (retval *template.Template) {\n    file, err := ioutil.ReadFile(config.DockerToolsTemplateDir+\"/docs/\"+tmplName+\".tmpl\")\n\tif nil != err {\n\t\tglog.Fatalf(\"Could not read template file '%s': %s\", tmplName, err)\n\t}\n\n\tretval, err = template.New(\"css\").Parse(string(file))\n\tif nil != err {\n\t\tglog.Fatalf(\"Could not parse template file '%s': %s\", tmplName, err)\n\t}\n\n    return\n}\n\nfunc compileUsageTemplate(buffer *bytes.Buffer, templateName string, templateData map[string]string) (reterr error) ", "output": "{\n\ttmpl := getTemplate(templateName)\n\treterr = tmpl.Execute(buffer, templateData)\n    return\n}"}
{"input": "package validates\n\nconst (\n\tNON_POSITIVE_SIZE_PANIC Panic = iota\n\tDIFFERENT_SIZE_PANIC\n\tNOT_MULTIPLIABLE_PANIC\n\tOUT_OF_RANGE_PANIC\n\tINVALID_ELEMENTS_PANIC\n)\n\n\ntype Panic int\n\nfunc ShapeShouldBePositive(row, column int) {\n\tif row > 0 && column > 0 {\n\t\treturn\n\t}\n\n\tpanic(NON_POSITIVE_SIZE_PANIC)\n}\n\ntype HasShape interface {\n\tShape() (rows, columns int)\n\tRows() int\n\tColumns() int\n}\n\nfunc ShapeShouldBeSame(m, n HasShape) {\n\tmRow, mColumn := m.Shape()\n\tnRow, nColumn := n.Shape()\n\n\tif mRow == nRow && mColumn == nColumn {\n\t\treturn\n\t}\n\n\tpanic(DIFFERENT_SIZE_PANIC)\n}\n\nfunc ShapeShouldBeMultipliable(m, n HasShape) {\n\tif m.Columns() == n.Rows() {\n\t\treturn\n\t}\n\n\tpanic(NOT_MULTIPLIABLE_PANIC)\n}\n\n\n\nfunc IndexShouldBeInRange(rows, columns, row, column int) ", "output": "{\n\tif (0 <= row && row < rows) && (0 <= column && column < columns) {\n\t\treturn\n\t}\n\n\tpanic(OUT_OF_RANGE_PANIC)\n}"}
{"input": "package hyperleveldb\n\n\n\nimport \"C\"\n\nimport (\n\t\"unsafe\"\n)\n\n\n\n\n\n\ntype WriteBatch struct {\n\twbatch *C.hyperleveldb_writebatch_t\n}\n\n\nfunc NewWriteBatch() *WriteBatch {\n\twb := C.hyperleveldb_writebatch_create()\n\treturn &WriteBatch{wb}\n}\n\n\nfunc (w *WriteBatch) Close() {\n\tC.hyperleveldb_writebatch_destroy(w.wbatch)\n}\n\n\n\n\n\n\nfunc (w *WriteBatch) Put(key, value []byte) {\n\tvar k, v *C.char\n\tif len(key) != 0 {\n\t\tk = (*C.char)(unsafe.Pointer(&key[0]))\n\t}\n\tif len(value) != 0 {\n\t\tv = (*C.char)(unsafe.Pointer(&value[0]))\n\t}\n\n\tlenk := len(key)\n\tlenv := len(value)\n\n\tC.hyperleveldb_writebatch_put(w.wbatch, k, C.size_t(lenk), v, C.size_t(lenv))\n}\n\n\n\n\n\n\n\n\nfunc (w *WriteBatch) Clear() {\n\tC.hyperleveldb_writebatch_clear(w.wbatch)\n}\n\nfunc (w *WriteBatch) Delete(key []byte) ", "output": "{\n\tC.hyperleveldb_writebatch_delete(w.wbatch,\n\t\t(*C.char)(unsafe.Pointer(&key[0])), C.size_t(len(key)))\n}"}
{"input": "package sortedmap\n\nimport (\n\t\"testing\"\n\n\t\"github.com/umpc/go-sortedmap/asc\"\n)\n\n\n\nfunc batchInsertRecords(b *testing.B, n int) {\n\trecords := randRecords(n)\n\tsm := New(0, asc.Time)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsm.BatchInsert(records)\n\n\t\tb.StopTimer()\n\t\trecords = randRecords(n)\n\t\tsm = New(0, asc.Time)\n\t\tb.StartTimer()\n\t}\n}\n\nfunc BenchmarkInsert1Record(b *testing.B) {\n\tinsertRecord(b)\n}\n\nfunc BenchmarkBatchInsert10Records(b *testing.B) {\n\tbatchInsertRecords(b, 10)\n}\n\nfunc BenchmarkBatchInsert100Records(b *testing.B) {\n\tbatchInsertRecords(b, 100)\n}\n\nfunc BenchmarkBatchInsert1000Records(b *testing.B) {\n\tbatchInsertRecords(b, 1000)\n}\n\nfunc BenchmarkBatchInsert10000Records(b *testing.B) {\n\tbatchInsertRecords(b, 10000)\n}\n\nfunc insertRecord(b *testing.B) ", "output": "{\n\trecords := randRecords(1)\n\tsm := New(0, asc.Time)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsm.Insert(records[0].Key, records[0].Val)\n\n\t\tb.StopTimer()\n\t\trecords = randRecords(1)\n\t\tsm = New(0, asc.Time)\n\t\tb.StartTimer()\n\t}\n}"}
{"input": "package unicodes\n\nimport (\n\t\"unicode\"\n)\n\n\n\n\nfunc IsGraphic(r rune) bool {\n\treturn unicode.IsGraphic(r)\n}\n\n\n\n\n\n\nfunc IsPrint(r rune) bool {\n\treturn unicode.IsPrint(r)\n}\n\n\n\nfunc IsOneOf(ranges []*unicode.RangeTable, r rune) bool {\n\treturn unicode.IsOneOf(ranges, r)\n}\n\n\nfunc In(r rune, ranges ...*unicode.RangeTable) bool {\n\treturn unicode.In(r, ranges...)\n}\n\n\n\n\nfunc IsControl(r rune) bool {\n\treturn unicode.IsControl(r)\n}\n\n\nfunc IsLetter(r rune) bool {\n\treturn unicode.IsLetter(r)\n}\n\n\n\n\n\nfunc IsNumber(r rune) bool {\n\treturn unicode.IsNumber(r)\n}\n\n\n\nfunc IsPunct(r rune) bool {\n\treturn unicode.IsPunct(r)\n}\n\n\n\n\n\n\n\nfunc IsSpace(r rune) bool {\n\treturn unicode.IsSpace(r)\n}\n\n\nfunc IsSymbol(r rune) bool {\n\treturn unicode.IsSymbol(r)\n}\n\nfunc IsMark(r rune) bool ", "output": "{\n\treturn unicode.IsMark(r)\n}"}
{"input": "package rpkt\n\nimport (\n\t\"github.com/scionproto/scion/go/lib/addr\"\n\t\"github.com/scionproto/scion/go/lib/common\"\n\t\"github.com/scionproto/scion/go/lib/ctrl/path_mgmt\"\n\t\"github.com/scionproto/scion/go/lib/scmp\"\n)\n\ntype RevTokenCallbackArgs struct {\n\tRevInfo *path_mgmt.RevInfo\n\tAddrs   []addr.HostSVC\n}\n\n\n\n\n\nfunc (rp *RtrPkt) parseSCMPPayload() (HookResult, common.Payload, error) ", "output": "{\n\thdr := rp.l4.(*scmp.Hdr)\n\tpld, err := scmp.PldFromRaw(rp.Raw[rp.idxs.pld:],\n\t\tscmp.ClassType{Class: hdr.Class, Type: hdr.Type})\n\tif err != nil {\n\t\treturn HookError, nil, err\n\t}\n\treturn HookFinish, pld, nil\n}"}
{"input": "package opts\n\n\ntype CreateOption func(*CreateConfig)\n\n\n\ntype CreateConfig struct {\n\tOptions   map[string]string\n\tLabels    map[string]string\n\tReference string\n}\n\n\n\nfunc WithCreateLabels(labels map[string]string) CreateOption {\n\treturn func(cfg *CreateConfig) {\n\t\tcfg.Labels = labels\n\t}\n}\n\n\n\n\n\n\n\n\nfunc WithCreateReference(ref string) CreateOption {\n\treturn func(cfg *CreateConfig) {\n\t\tcfg.Reference = ref\n\t}\n}\n\n\n\ntype GetConfig struct {\n\tDriver        string\n\tReference     string\n\tResolveStatus bool\n}\n\n\ntype GetOption func(*GetConfig)\n\n\n\n\n\nfunc WithGetDriver(name string) GetOption {\n\treturn func(o *GetConfig) {\n\t\to.Driver = name\n\t}\n}\n\n\n\nfunc WithGetReference(ref string) GetOption {\n\treturn func(o *GetConfig) {\n\t\to.Reference = ref\n\t}\n}\n\n\n\nfunc WithGetResolveStatus(cfg *GetConfig) {\n\tcfg.ResolveStatus = true\n}\n\n\ntype RemoveConfig struct {\n\tPurgeOnError bool\n}\n\n\ntype RemoveOption func(*RemoveConfig)\n\n\n\n\nfunc WithPurgeOnError(b bool) RemoveOption {\n\treturn func(o *RemoveConfig) {\n\t\to.PurgeOnError = b\n\t}\n}\n\nfunc WithCreateOptions(opts map[string]string) CreateOption ", "output": "{\n\treturn func(cfg *CreateConfig) {\n\t\tcfg.Options = opts\n\t}\n}"}
{"input": "package client\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/docker/engine-api/types\"\n)\n\n\nfunc (cli *Client) ContainerExecCreate(config types.ExecConfig) (types.ContainerExecCreateResponse, error) {\n\tvar response types.ContainerExecCreateResponse\n\tresp, err := cli.post(\"/containers/\"+config.Container+\"/exec\", nil, config, nil)\n\tif err != nil {\n\t\treturn response, err\n\t}\n\tdefer ensureReaderClosed(resp)\n\terr = json.NewDecoder(resp.body).Decode(&response)\n\treturn response, err\n}\n\n\nfunc (cli *Client) ContainerExecStart(execID string, config types.ExecStartCheck) error {\n\tresp, err := cli.post(\"/exec/\"+execID+\"/start\", nil, config, nil)\n\tensureReaderClosed(resp)\n\treturn err\n}\n\n\n\n\n\n\n\n\nfunc (cli *Client) ContainerExecInspect(execID string) (types.ContainerExecInspect, error) {\n\tvar response types.ContainerExecInspect\n\tresp, err := cli.get(\"/exec/\"+execID+\"/json\", nil, nil)\n\tif err != nil {\n\t\treturn response, err\n\t}\n\tdefer ensureReaderClosed(resp)\n\n\terr = json.NewDecoder(resp.body).Decode(&response)\n\treturn response, err\n}\n\nfunc (cli *Client) ContainerExecAttach(execID string, config types.ExecConfig) (types.HijackedResponse, error) ", "output": "{\n\theaders := map[string][]string{\"Content-Type\": {\"application/json\"}}\n\treturn cli.postHijacked(\"/exec/\"+execID+\"/start\", nil, config, headers)\n}"}
{"input": "package services\n\nimport (\n\t\"github.com/astaxie/beego/orm\"\n\t\"github.com/scmo/apayment-backend/models\"\n)\n\nfunc CreateControlPoint(cp *models.ControlPoint) error {\n\to := orm.NewOrm()\n\t_, err := o.Insert(cp)\n\treturn err\n}\n\n\n\nfunc CountControlPoints() (int64, error) {\n\to := orm.NewOrm()\n\tcnt, err := o.QueryTable(new(models.ControlPoint)).Count() \n\treturn cnt, err\n}\n\nfunc GetAllControlPoints() []*models.ControlPoint ", "output": "{\n\to := orm.NewOrm()\n\tvar controlPoints []*models.ControlPoint\n\to.QueryTable(new(models.ControlPoint)).All(&controlPoints)\n\treturn controlPoints\n}"}
{"input": "package eliteConfiguration\n\n\ntype mutableState struct {\n}\n\n\nfunc (state mutableState) New(requiredName string) Configuration {\n\n\treturn &mutableConfiguration{iName: requiredName}\n}\n\n\nfunc (state mutableState) Load(fileName string) (Configuration, error) {\n\n\treturn load(fileName, state.New)\n}\n\n\n\n\nfunc (state mutableState) Save(configuration Configuration, fileName string) error ", "output": "{\n\n\treturn save(configuration, fileName)\n}"}
{"input": "package wait\n\nimport (\n\t\"context\"\n\t\"io/ioutil\"\n\t\"strings\"\n\t\"time\"\n)\n\n\nvar _ Strategy = (*LogStrategy)(nil)\n\n\ntype LogStrategy struct {\n\tstartupTimeout time.Duration\n\n\tLog          string\n\tOccurrence   int\n\tPollInterval time.Duration\n}\n\n\nfunc NewLogStrategy(log string) *LogStrategy {\n\treturn &LogStrategy{\n\t\tstartupTimeout: defaultStartupTimeout(),\n\t\tLog:            log,\n\t\tOccurrence:     1,\n\t\tPollInterval:   defaultPollInterval(),\n\t}\n\n}\n\n\n\n\n\n\nfunc (ws *LogStrategy) WithStartupTimeout(startupTimeout time.Duration) *LogStrategy {\n\tws.startupTimeout = startupTimeout\n\treturn ws\n}\n\n\nfunc (ws *LogStrategy) WithPollInterval(pollInterval time.Duration) *LogStrategy {\n\tws.PollInterval = pollInterval\n\treturn ws\n}\n\n\n\n\n\n\n\n\n\nfunc ForLog(log string) *LogStrategy {\n\treturn NewLogStrategy(log)\n}\n\n\nfunc (ws *LogStrategy) WaitUntilReady(ctx context.Context, target StrategyTarget) (err error) {\n\tctx, cancelContext := context.WithTimeout(ctx, ws.startupTimeout)\n\tdefer cancelContext()\n\nLOOP:\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\treader, err := target.Logs(ctx)\n\n\t\t\tif err != nil {\n\t\t\t\ttime.Sleep(ws.PollInterval)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tb, err := ioutil.ReadAll(reader)\n\t\t\tlogs := string(b)\n\t\t\tif strings.Count(logs, ws.Log) >= ws.Occurrence {\n\t\t\t\tbreak LOOP\n\t\t\t} else {\n\t\t\t\ttime.Sleep(ws.PollInterval)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (ws *LogStrategy) WithOccurrence(o int) *LogStrategy ", "output": "{\n\tif o <= 0 {\n\t\to = 1\n\t}\n\tws.Occurrence = o\n\treturn ws\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"net/http\"\n)\n\nfunc PingHandler(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\"status\": http.StatusOK, \"data\": \"PONG!\"})\n}\n\nfunc GetAllStats(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\"status\": http.StatusOK, \"data\": \"statistics go here\"})\n}\n\nfunc GetAllImages(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\"status\": http.StatusOK, \"data\": \"all images go here\"})\n}\n\n\n\nfunc CreateImage(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\"status\": http.StatusOK, \"data\": \"ID of the image we created goes here\"})\n}\n\nfunc UpdateImage(c *gin.Context) {\n\tc.JSON(http.StatusOK, gin.H{\"status\": http.StatusOK, \"data\": \"ID of the image we updated goes here\"})\n}\n\nfunc GetImage(c *gin.Context) ", "output": "{\n\tc.JSON(http.StatusOK, gin.H{\"status\": http.StatusOK, \"data\": \"one image goes here\"})\n}"}
{"input": "package db\n\nimport (\n\t\"database/sql\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype Connection struct {\n\tdb *sql.DB\n}\n\nfunc NewConnection(db *sql.DB) *Connection {\n\treturn &Connection{\n\t\tdb: db,\n\t}\n}\n\nfunc (c *Connection) Connect() *sql.DB {\n\treturn c.db\n}\n\n\n\nfunc (c *Connection) Begin() (*sql.Tx, error) ", "output": "{\n\treturn c.db.Begin()\n}"}
{"input": "package model\n\nimport (\n\t\"path/filepath\"\n)\n\ntype Secret struct {\n\tName string `json:\"name\"`\n\n\tValue string `json:\"value\"`\n\n\tImages []string `json:\"image,omitempty\"`\n\n\tEvents []string `json:\"event,omitempty\"`\n\n\tSkipVerify bool `json:\"skip_verify\"`\n\n\tConceal bool `json:\"conceal\"`\n}\n\n\n\n\n\nfunc (s *Secret) MatchImage(image string) bool {\n\tfor _, pattern := range s.Images {\n\t\tif match, _ := filepath.Match(pattern, image); match {\n\t\t\treturn true\n\t\t} else if pattern == \"*\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc (s *Secret) MatchEvent(event string) bool {\n\tfor _, pattern := range s.Events {\n\t\tif match, _ := filepath.Match(pattern, event); match {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\nfunc (s *Secret) Validate() error {\n\treturn nil\n}\n\nfunc (s *Secret) Match(image, event string) bool ", "output": "{\n\treturn s.MatchImage(image) && s.MatchEvent(event)\n}"}
{"input": "package authz\n\nimport (\n\t\"testing\"\n\n\t\"istio.io/istio/pkg/test/util/assert\"\n)\n\n\n\nfunc TestNamespaceMatch(t *testing.T) ", "output": "{\n\tassert.Equal(t, namespaceMatch(\"test-login\", \"*\"), true)\n\n\tassert.Equal(t, namespaceMatch(\"test-login\", \"test-*\"), true)\n\tassert.Equal(t, namespaceMatch(\"test-login\", \"*-test\"), false)\n\n\tassert.Equal(t, namespaceMatch(\"test-login\", \"login-*\"), false)\n\tassert.Equal(t, namespaceMatch(\"test-login\", \"*-login\"), true)\n}"}
{"input": "package gonfler\n\nimport (\n\t\"archive/tar\"\n\t\"os\"\n)\n\ntype TarArchive struct {\n\thandle *tar.Reader\n\tfile   *os.File\n}\n\n\n\nfunc (archive TarArchive) Volumes() VolumeIterator {\n\tvar next func() VolumeIterator\n\tnext = func() VolumeIterator {\n\t\theader, err := archive.handle.Next()\n\t\tif err != nil {\n\t\t\treturn VolumeIterator{nil, nil}\n\t\t} else {\n\t\t\treturn VolumeIterator{\n\t\t\t\tvolume: &Volume{archive.handle, header.Name},\n\t\t\t\tnext:   next,\n\t\t\t}\n\t\t}\n\t}\n\treturn next()\n}\n\nfunc openTar(name string) (Archive, error) {\n\tfile, e := os.Open(name)\n\tif file != nil {\n\t\treturn TarArchive{tar.NewReader(file), file}, nil\n\t} else {\n\t\treturn nil, e\n\t}\n}\n\nfunc (archive TarArchive) Close() error ", "output": "{\n\treturn archive.file.Close()\n}"}
{"input": "package main\n\nimport (\n\t\"os\"\n)\n\n\n\nfunc getResolverPath() string ", "output": "{\n\treturn os.Getenv(\"RESOLVER_PATH\")\n}"}
{"input": "package p207\n\nimport \"testing\"\n\n\n\nfunc Test1(t *testing.T) {\n\tans := canFinish(2, [][]int{{1, 0}, {0, 1}})\n\tif ans {\n\t\tt.Fatal(ans)\n\t}\n}\n\nfunc Test0(t *testing.T) ", "output": "{\n\tans := canFinish(2, [][]int{{1, 0}})\n\tif !ans {\n\t\tt.Fatal(ans)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n)\n\n\n\nfunc OpenBuffer(gs *GlobalState, pathname string) (Buffer, os.Error) {\n\twd, e := os.Getwd()\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\tif !path.IsAbs(pathname) {\n\t\tpathname = path.Join(wd, pathname)\n\t}\n\n\tf, e := os.Open(pathname)\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\tdefer f.Close()\n\n\tif st, e := f.Stat(); e == nil {\n\t\tif st.IsRegular() {\n\t\t\teb := NewEditBuffer(gs, pathname)\n\t\t\tif _, e = eb.readFile(f, 0); e == nil {\n\t\t\t\treturn eb, nil\n\t\t\t}\n\t\t} else {\n\t\t\te = &DviError{fmt.Sprintf(\"%s: can't deal with this filetype\", pathname)}\n\t\t}\n\t}\n\treturn nil, e\n}\n\nfunc NewTempEditBuffer(gs *GlobalState, prefix string) (*EditBuffer, os.Error) ", "output": "{\n\tf, e := ioutil.TempFile(os.TempDir(), prefix)\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\tdefer f.Close() \n\n\teb := NewEditBuffer(gs, f.Name())\n\teb.temp = true\n\treturn eb, nil\n}"}
{"input": "package lib\n\n\n\nfunc cacheHintTagList(repository string) string {\n\treturn \"pull:\" + repository\n}\n\nfunc cacheHintTagDetails(repository string) string {\n\treturn \"pull:\" + repository\n}\n\nfunc cacheHintRegistryList() string ", "output": "{\n\treturn \"catalog:\"\n}"}
{"input": "package iso20022\n\n\ntype SettlementParties49 struct {\n\n\tDepository *PartyIdentification108 `xml:\"Dpstry,omitempty\"`\n\n\tParty1 *PartyIdentificationAndAccount146 `xml:\"Pty1,omitempty\"`\n\n\tParty2 *PartyIdentificationAndAccount146 `xml:\"Pty2,omitempty\"`\n\n\tParty3 *PartyIdentificationAndAccount146 `xml:\"Pty3,omitempty\"`\n\n\tParty4 *PartyIdentificationAndAccount146 `xml:\"Pty4,omitempty\"`\n\n\tParty5 *PartyIdentificationAndAccount146 `xml:\"Pty5,omitempty\"`\n}\n\n\n\nfunc (s *SettlementParties49) AddParty1() *PartyIdentificationAndAccount146 {\n\ts.Party1 = new(PartyIdentificationAndAccount146)\n\treturn s.Party1\n}\n\nfunc (s *SettlementParties49) AddParty2() *PartyIdentificationAndAccount146 {\n\ts.Party2 = new(PartyIdentificationAndAccount146)\n\treturn s.Party2\n}\n\nfunc (s *SettlementParties49) AddParty3() *PartyIdentificationAndAccount146 {\n\ts.Party3 = new(PartyIdentificationAndAccount146)\n\treturn s.Party3\n}\n\nfunc (s *SettlementParties49) AddParty4() *PartyIdentificationAndAccount146 {\n\ts.Party4 = new(PartyIdentificationAndAccount146)\n\treturn s.Party4\n}\n\nfunc (s *SettlementParties49) AddParty5() *PartyIdentificationAndAccount146 {\n\ts.Party5 = new(PartyIdentificationAndAccount146)\n\treturn s.Party5\n}\n\nfunc (s *SettlementParties49) AddDepository() *PartyIdentification108 ", "output": "{\n\ts.Depository = new(PartyIdentification108)\n\treturn s.Depository\n}"}
{"input": "package iso20022\n\n\ntype TaxParty1 struct {\n\n\tTaxIdentification *Max35Text `xml:\"TaxId,omitempty\"`\n\n\tRegistrationIdentification *Max35Text `xml:\"RegnId,omitempty\"`\n\n\tTaxType *Max35Text `xml:\"TaxTp,omitempty\"`\n}\n\n\n\nfunc (t *TaxParty1) SetRegistrationIdentification(value string) {\n\tt.RegistrationIdentification = (*Max35Text)(&value)\n}\n\nfunc (t *TaxParty1) SetTaxType(value string) {\n\tt.TaxType = (*Max35Text)(&value)\n}\n\nfunc (t *TaxParty1) SetTaxIdentification(value string) ", "output": "{\n\tt.TaxIdentification = (*Max35Text)(&value)\n}"}
{"input": "package core\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/oci/oci-go-sdk/v43/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype GetVolumeKmsKeyRequest struct {\n\n\tVolumeId *string `mandatory:\"true\" contributesTo:\"path\" name:\"volumeId\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request GetVolumeKmsKeyRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request GetVolumeKmsKeyRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\n\n\n\nfunc (request GetVolumeKmsKeyRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype GetVolumeKmsKeyResponse struct {\n\n\tRawResponse *http.Response\n\n\tVolumeKmsKey `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response GetVolumeKmsKeyResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response GetVolumeKmsKeyResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request GetVolumeKmsKeyRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) ", "output": "{\n\n\treturn nil, false\n\n}"}
{"input": "package store_instructions\n\nimport (\n\t\"github.com/Frederick-S/jvmgo/instructions/base_instructions\"\n\t\"github.com/Frederick-S/jvmgo/runtime_data_area\"\n)\n\n\n\ntype AAStore struct {\n\tbase_instructions.NoOperandsInstruction\n}\n\n\n\nfunc (aAStore *AAStore) Execute(frame *runtime_data_area.Frame) ", "output": "{\n\toperandStack := frame.GetOperandStack()\n\treferenceValue := operandStack.PopReferenceValue()\n\tindex := operandStack.PopIntegerValue()\n\tarrayReference := operandStack.PopReferenceValue()\n\n\tif arrayReference == nil {\n\t\tpanic(\"java.lang.NullPointerException\")\n\t}\n\n\treferenceArray := arrayReference.GetReferenceArray()\n\n\tif index < 0 || index >= int32(len(referenceArray)) {\n\t\tpanic(\"ArrayIndexOutOfBoundsException\")\n\t}\n\n\treferenceArray[index] = referenceValue\n}"}
{"input": "package reeky\n\nimport (\n\t\"fmt\"\n\n\t. \"github.com/konjoot/reeky/interfaces\"\n)\n\ntype App struct {\n\troutes  bool\n\tmidware bool\n\tEngine  EngineIface\n}\n\n\n\nfunc (app *App) Setup() {\n\tapp.midware = app.SetMiddleWare()\n\tapp.routes = app.SetRoutes()\n}\n\nfunc (app *App) Ok() bool {\n\treturn app.midware && app.routes\n}\n\nfunc (app *App) String() string {\n\treturn fmt.Sprintf(\"App{Ok: \\\"%t\\\"}\", app.Ok())\n}\n\nfunc (app *App) RunOn(port string) ", "output": "{\n\tapp.Setup()\n\tapp.Engine.Run(\":\" + port)\n}"}
{"input": "package s2\n\n\nvar (\n\t_ Shape = (*PointVector)(nil)\n)\n\n\n\n\n\n\n\n\ntype PointVector []Point\n\nfunc (p *PointVector) NumEdges() int                     { return len(*p) }\nfunc (p *PointVector) Edge(i int) Edge                   { return Edge{(*p)[i], (*p)[i]} }\nfunc (p *PointVector) ReferencePoint() ReferencePoint    { return OriginReferencePoint(false) }\n\nfunc (p *PointVector) Chain(i int) Chain                 { return Chain{i, 1} }\nfunc (p *PointVector) ChainEdge(i, j int) Edge           { return Edge{(*p)[i], (*p)[j]} }\nfunc (p *PointVector) ChainPosition(e int) ChainPosition { return ChainPosition{e, 0} }\nfunc (p *PointVector) Dimension() int                    { return 0 }\nfunc (p *PointVector) IsEmpty() bool                     { return defaultShapeIsEmpty(p) }\nfunc (p *PointVector) IsFull() bool                      { return defaultShapeIsFull(p) }\nfunc (p *PointVector) typeTag() typeTag                  { return typeTagPointVector }\nfunc (p *PointVector) privateInterface()                 {}\n\nfunc (p *PointVector) NumChains() int                    ", "output": "{ return len(*p) }"}
{"input": "package budget\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype CreateBudgetRequest struct {\n\n\tCreateBudgetDetails `contributesTo:\"body\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request CreateBudgetRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request CreateBudgetRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request CreateBudgetRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\n\n\n\ntype CreateBudgetResponse struct {\n\n\tRawResponse *http.Response\n\n\tBudget `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n}\n\nfunc (response CreateBudgetResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response CreateBudgetResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request CreateBudgetRequest) RetryPolicy() *common.RetryPolicy ", "output": "{\n\treturn request.RequestMetadata.RetryPolicy\n}"}
{"input": "package hijackhelpers\n\nimport (\n\t\"strings\"\n\n\t\"github.com/concourse/atc\"\n)\n\ntype ContainerSorter []atc.Container\n\n\n\nfunc (sorter ContainerSorter) Swap(i, j int) {\n\tsorter[i], sorter[j] = sorter[j], sorter[i]\n}\n\nfunc (sorter ContainerSorter) Less(i, j int) bool {\n\tswitch {\n\tcase sorter[i].BuildID < sorter[j].BuildID:\n\t\treturn true\n\tcase sorter[i].BuildID > sorter[j].BuildID:\n\t\treturn false\n\tcase strings.Compare(sorter[i].ResourceName, sorter[j].ResourceName) == -1:\n\t\treturn true\n\tcase strings.Compare(sorter[i].ResourceName, sorter[j].ResourceName) == 1:\n\t\treturn false\n\tcase strings.Compare(sorter[i].StepName, sorter[j].StepName) == -1:\n\t\treturn true\n\tcase strings.Compare(sorter[i].StepName, sorter[j].StepName) == 1:\n\t\treturn false\n\tcase strings.Compare(sorter[i].Type, sorter[j].Type) == -1:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (sorter ContainerSorter) Len() int ", "output": "{\n\treturn len(sorter)\n}"}
{"input": "package httpx\n\nimport (\n\t\"net/http\"\n\n\t\"golang.org/x/net/context\"\n)\n\nvar clientContextKey = 0\nvar defaultClient = &http.Client{}\n\n\n\n\n\n\n\n\n\nfunc ClientContext(parent context.Context, client *http.Client) context.Context {\n\tif client == nil {\n\t\tpanic(\"Cannot bind nil *http.Client to context tree\")\n\t}\n\n\treturn context.WithValue(parent, &clientContextKey, client)\n}\n\nfunc ClientFromContext(ctx context.Context) *http.Client ", "output": "{\n\tfound := ctx.Value(&clientContextKey)\n\n\tif found == nil {\n\t\treturn defaultClient\n\t}\n\n\treturn found.(*http.Client)\n}"}
{"input": "package data\n\nimport (\n\t\"fmt\"\n\n\t\"appengine/memcache\"\n)\n\n\n\nfunc (op *DataConn) GetCacheItem(item DataItem) error {\n\tkey := fmt.Sprintf(\"%s:%d\", op.Entity, item.ID())\n\t_, err := memcache.Gob.Get(op.Wreq.C, key, item)\n\treturn err\n}\n\nfunc (op *DataConn) PutCacheItem(item DataItem) error ", "output": "{\n\tcitem := new(memcache.Item)\n\tcitem.Key = fmt.Sprintf(\"%s:%d\", op.Entity, item.ID())\n\tcitem.Object = item\n\n\terr := memcache.Gob.Set(op.Wreq.C, citem)\n\treturn err\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/franela/goreq\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype VaultRequest struct {\n\tgoreq.Request\n}\n\nfunc (r VaultRequest) Do() (*goreq.Response, error) {\n\tconfig := goreq.DefaultTransport.(*http.Transport).TLSClientConfig\n\tif config != nil {\n\t\tr.Insecure = config.InsecureSkipVerify\n\t}\n\tresp, err := r.Request.Do()\n\tfor err == nil && resp.StatusCode == 307 {\n\t\tio.Copy(ioutil.Discard, resp.Body)\n\t\tresp.Body.Close()\n\t\tr.Request.Uri = resp.Header.Get(\"Location\")\n\t\tresp, err = r.Request.Do()\n\t}\n\treturn resp, err\n}\n\ntype VaultWrappedResponse struct {\n\tData struct {\n\t\tWrappedSecret string `json:\"response\"`\n\t} `json:\"data\"`\n}\n\n\n\nfunc (vr *VaultWrappedResponse) Unwrap(v interface{}) error ", "output": "{\n\treturn json.Unmarshal([]byte(vr.Data.WrappedSecret), v)\n}"}
{"input": "package mergesort \n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\t\"fmt\"\n)\n\nfunc TestMerge(t *testing.T) {\n\ta1 := []int{1,2,3,4}\n\ta2 := []int{5,6,7,8}\n\tres := merge(a1,a2)\n\tother := merge(a2,a1)\n\tfmt.Printf(\"Merge %#v & %#v, get %#v \\n\", a1, a2, res)\n\tif !reflect.DeepEqual(res, other) {\n\t\tt.Error(fmt.Sprintf(\"Merge %#v & %#v, get %#v or %#v \\n\", a1, a2, res, other))\n\t}\n}\n\nfunc TestSmallSort(t *testing.T) {\n\ta1:= []int{6,5}\n\tfmt.Printf(\"sort %#v to get %#v \\n\", a1, Sort(a1))\n}\n\n\nfunc TestSort(t *testing.T) {\n\ta1:= []int{56,345,34,77,22,23,90,1,2,8,88,75,6,5}\n\tfmt.Printf(\"sort %#v to get [%#v \\n\", a1, Sort(a1))\n}\n\n\n\nfunc TestLargerSort(t *testing.T) ", "output": "{\n\tin := []int{\n\t\t1986, 2003, 1927, 1959, 1957, 1988, 2009, 2003, 2003, 2003, 1945, 1941, 1917, 1953, 1991}\n\tfmt.Printf(\"sorting %#v\\n gives %#v\\n\", in, Sort(in))\n}"}
{"input": "package iso20022\n\n\ntype InstructionCancellationRequestStatus7Choice struct {\n\n\tCancellationCompleted *CancelledStatus7Choice `xml:\"CxlCmpltd\"`\n\n\tAccepted *NoSpecifiedReason1 `xml:\"Accptd\"`\n\n\tRejected *RejectedStatus14Choice `xml:\"Rjctd\"`\n\n\tPendingCancellation *PendingCancellationStatus3Choice `xml:\"PdgCxl\"`\n\n\tProprietaryStatus *ProprietaryStatusAndReason1 `xml:\"PrtrySts\"`\n}\n\nfunc (i *InstructionCancellationRequestStatus7Choice) AddCancellationCompleted() *CancelledStatus7Choice {\n\ti.CancellationCompleted = new(CancelledStatus7Choice)\n\treturn i.CancellationCompleted\n}\n\nfunc (i *InstructionCancellationRequestStatus7Choice) AddAccepted() *NoSpecifiedReason1 {\n\ti.Accepted = new(NoSpecifiedReason1)\n\treturn i.Accepted\n}\n\n\n\nfunc (i *InstructionCancellationRequestStatus7Choice) AddPendingCancellation() *PendingCancellationStatus3Choice {\n\ti.PendingCancellation = new(PendingCancellationStatus3Choice)\n\treturn i.PendingCancellation\n}\n\nfunc (i *InstructionCancellationRequestStatus7Choice) AddProprietaryStatus() *ProprietaryStatusAndReason1 {\n\ti.ProprietaryStatus = new(ProprietaryStatusAndReason1)\n\treturn i.ProprietaryStatus\n}\n\nfunc (i *InstructionCancellationRequestStatus7Choice) AddRejected() *RejectedStatus14Choice ", "output": "{\n\ti.Rejected = new(RejectedStatus14Choice)\n\treturn i.Rejected\n}"}
{"input": "package auth\n\n\nconst GSSAPI = \"GSSAPI\"\n\n\n\nfunc newGSSAPIAuthenticator(cred *Cred) (Authenticator, error) ", "output": "{\n\treturn nil, newAuthError(\"GSSAPI support not enabled during build (-tags gssapi)\", nil)\n}"}
{"input": "package app\n\nimport (\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/kubernetes/pkg/controller/disruption\"\n)\n\n\n\nfunc startDisruptionController(ctx ControllerContext) (bool, error) ", "output": "{\n\tif !ctx.AvailableResources[schema.GroupVersionResource{Group: \"policy\", Version: \"v1beta1\", Resource: \"poddisruptionbudgets\"}] {\n\t\treturn false, nil\n\t}\n\tgo disruption.NewDisruptionController(\n\t\tctx.NewInformerFactory.Core().V1().Pods(),\n\t\tctx.NewInformerFactory.Policy().V1beta1().PodDisruptionBudgets(),\n\t\tctx.NewInformerFactory.Core().V1().ReplicationControllers(),\n\t\tctx.NewInformerFactory.Extensions().V1beta1().ReplicaSets(),\n\t\tctx.NewInformerFactory.Extensions().V1beta1().Deployments(),\n\t\tctx.NewInformerFactory.Apps().V1beta1().StatefulSets(),\n\t\tctx.ClientBuilder.ClientOrDie(\"disruption-controller\"),\n\t).Run(ctx.Stop)\n\treturn true, nil\n}"}
{"input": "package containerengine\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype ImagePolicyConfig struct {\n\n\tIsPolicyEnabled *bool `mandatory:\"false\" json:\"isPolicyEnabled\"`\n\n\tKeyDetails []KeyDetails `mandatory:\"false\" json:\"keyDetails\"`\n}\n\n\n\nfunc (m ImagePolicyConfig) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package files\n\nimport (\n\t\"../../proto\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype File struct {\n\tRootdir string\n}\n\n\n\nfunc (f *File) RecvFile(args *proto.File, resp *proto.FileResponse) error {\n\tfull_path := filepath.Join(f.Rootdir, args.Filename)\n\tfull_dir := filepath.Dir(full_path)\n\n\tvar mode os.FileMode = os.ModeDir + 0755\n\terr := os.MkdirAll(full_dir, mode)\n\tif err != nil {\n\t\treturn errors.New(\"Creating directory: \" + err.Error())\n\t}\n\n\t_, err = os.Stat(full_path)\n\n\tresp.Overwritten = (err != nil)\n\n\terr = ioutil.WriteFile(full_path, args.Content, args.Mode)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp.Filename = args.Filename\n\tresp.Checksum = proto.GetDataChecksum(args.Content)\n\treturn nil\n}\n\nfunc (f *File) SendFile(args *proto.FileRequest, resp *proto.File) error ", "output": "{\n\tfull_path := filepath.Join(f.Rootdir, args.Filename)\n\n\tdata, err := ioutil.ReadFile(full_path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfi, err := os.Stat(full_path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp.Filename = args.Filename\n\tresp.Content = data\n\tresp.Mode = fi.Mode()\n\treturn nil\n}"}
{"input": "package log\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\nvar (\n\tinternalLog *logMux\n\tdebugMode   bool\n)\n\n\nfunc init() {\n\tinternalLog = NewMux()\n\tinternalLog.Add(NewSyslogSink())\n\tinternalLog.Add(NewColourisedTerminalSink())\n}\n\n\ntype Sink interface {\n\tInfo(message string)\n\tWarning(message string)\n\tError(message string)\n\tDebug(message string)\n}\n\n\n\nfunc Info(message string, v ...interface{}) {\n\tvar fileMessage string\n\tif debugMode {\n\t\t_, f, l, _ := runtime.Caller(1)\n\t\tfileMessage = fmt.Sprintf(\"(%s:%d) %s\", f, l, message)\n\t} else {\n\t\tfileMessage = message\n\t}\n\tinternalLog.Info(fileMessage, v...)\n}\n\nfunc Warning(message string, v ...interface{}) {\n\tvar fileMessage string\n\tif debugMode {\n\t\t_, f, l, _ := runtime.Caller(1)\n\t\tfileMessage = fmt.Sprintf(\"(%s:%d) %s\", f, l, message)\n\t} else {\n\t\tfileMessage = message\n\t}\n\tinternalLog.Warning(fileMessage, v...)\n}\n\n\n\nfunc Debug(message string, v ...interface{}) {\n\tvar fileMessage string\n\tif debugMode {\n\t\t_, f, l, _ := runtime.Caller(1)\n\t\tfileMessage = fmt.Sprintf(\"(%s:%d) %s\", f, l, message)\n\t} else {\n\t\tfileMessage = message\n\t}\n\tinternalLog.Debug(fileMessage, v...)\n}\n\n\nfunc DebugMode(status bool) {\n\tinternalLog.DebugMode(status)\n\tdebugMode = status\n}\n\nfunc Errorf(message string, v ...interface{}) ", "output": "{\n\tvar fileMessage string\n\tif debugMode {\n\t\t_, f, l, _ := runtime.Caller(1)\n\t\tfileMessage = fmt.Sprintf(\"(%s:%d) %s\", f, l, message)\n\t} else {\n\t\tfileMessage = message\n\t}\n\tinternalLog.Error(fileMessage, v...)\n}"}
{"input": "package meta\n\nimport \"io\"\n\n\nvar readBuf = make([]byte, 4096)\n\n\n\n\n\n\n\n\n\n\n\n\nfunc readBytes(r io.Reader, n int) ([]byte, error) ", "output": "{\n\tif n > len(readBuf) {\n\t\treadBuf = make([]byte, n)\n\t}\n\t_, err := io.ReadFull(r, readBuf[:n])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn readBuf[:n:n], nil\n}"}
{"input": "package lockedfile\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\ntype Mutex struct {\n\tPath string     \n\tmu   sync.Mutex \n}\n\n\nfunc MutexAt(path string) *Mutex {\n\tif path == \"\" {\n\t\tpanic(\"lockedfile.MutexAt: path must be non-empty\")\n\t}\n\treturn &Mutex{Path: path}\n}\n\nfunc (mu *Mutex) String() string {\n\treturn fmt.Sprintf(\"lockedfile.Mutex(%s)\", mu.Path)\n}\n\n\n\n\n\n\n\n\nfunc (mu *Mutex) Lock() (unlock func(), err error) ", "output": "{\n\tif mu.Path == \"\" {\n\t\tpanic(\"lockedfile.Mutex: missing Path during Lock\")\n\t}\n\n\tf, err := OpenFile(mu.Path, os.O_RDWR|os.O_CREATE, 0666)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmu.mu.Lock()\n\n\treturn func() {\n\t\tmu.mu.Unlock()\n\t\tf.Close()\n\t}, nil\n}"}
{"input": "package bingo \n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"stathat.com/c/spitz\"\n)\n\ntype Env int\n\nconst (\n\tEnvProduction Env = iota\n\tEnvTesting\n\tEnvDevel\n)\n\nvar ContentDir string\nvar Environment Env\nvar AfterErrorFunc func(Context, *AppError)\n\n\n\nfunc trapSignals() {\n\tc := make(chan os.Signal, 10)\n\tsignal.Notify(c, syscall.SIGINT, syscall.SIGHUP, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGKILL)\n\tfor {\n\t\tx := <-c\n\t\tif x == syscall.SIGHUP {\n\t\t\tfmt.Printf(\"!!! signal %s trapped, reopening log files\\n\", x)\n\t\t\tlogReload()\n\t\t} else {\n\t\t\tfmt.Printf(\"!!! signal %s trapped, exiting\\n\", x)\n\t\t\tcleanup()\n\t\t\tos.Exit(0)\n\t\t}\n\t}\n}\n\nfunc cleanup() {\n\tlogCleanup()\n}\n\nfunc ListenAndServe(addr string) {\n\thttp.ListenAndServe(addr, nil)\n}\n\nfunc init() ", "output": "{\n\tvar envFlag string\n\tflag.StringVar(&envFlag, \"e\", \"production\", \"environment to run in [devel|testing|production]\")\n\tflag.StringVar(&ContentDir, \"d\", \".\", \"content root directory (where server can find 'templates/')\")\n\tflag.Parse()\n\n\tswitch envFlag {\n\tcase \"production\":\n\t\tEnvironment = EnvProduction\n\tcase \"testing\":\n\t\tEnvironment = EnvTesting\n\tcase \"devel\":\n\t\tEnvironment = EnvDevel\n\tdefault:\n\t\tlog.Fatalf(\"unknown environment %q\", envFlag)\n\t}\n\n\treloadTemplates := Environment != EnvProduction\n\tDefaultPool = spitz.New(ContentDir+\"/templates\", reloadTemplates)\n\tfmt.Printf(\"bingo content directory: %q\\n\", ContentDir)\n\tfmt.Printf(\"bingo reloading templates? %v\\n\", reloadTemplates)\n\n\tgo trapSignals()\n}"}
{"input": "package main\n\nimport (\n    \"runtime\"\n    \"os\"\n\n    \"dicewa.re/server\"\n    \"github.com/codegangsta/cli\"\n)\n\nfunc main() {\n    runtime.GOMAXPROCS(runtime.NumCPU())\n\n    app := cli.NewApp()\n    app.Name = \"diceware\"\n    app.Usage = \"Diceware password generator www/api\"\n\n    app.Commands = []cli.Command{\n        {\n            Name:   \"start\",\n            Usage:  \"Start server\",\n            Action: StartServer,\n        },\n    }\n    app.Run(os.Args)\n}\n\n\n\nfunc StartServer(c *cli.Context) ", "output": "{\n    app := server.NewApp()\n    app.Run(\":8000\")\n}"}
{"input": "package internal\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestRegisterBrokenAuthHeaderProvider(t *testing.T) {\n\tRegisterBrokenAuthHeaderProvider(\"https://aaa.com/\")\n\ttokenURL := \"https://aaa.com/token\"\n\tif providerAuthHeaderWorks(tokenURL) {\n\t\tt.Errorf(\"got %q as unbroken; want broken\", tokenURL)\n\t}\n}\n\n\n\nfunc Test_providerAuthHeaderWorks(t *testing.T) ", "output": "{\n\tfor _, p := range brokenAuthHeaderProviders {\n\t\tif providerAuthHeaderWorks(p) {\n\t\t\tt.Errorf(\"got %q as unbroken; want broken\", p)\n\t\t}\n\t\tp := fmt.Sprintf(\"%ssomesuffix\", p)\n\t\tif providerAuthHeaderWorks(p) {\n\t\t\tt.Errorf(\"got %q as unbroken; want broken\", p)\n\t\t}\n\t}\n\tp := \"https://api.not-in-the-list-example.com/\"\n\tif !providerAuthHeaderWorks(p) {\n\t\tt.Errorf(\"got %q as unbroken; want broken\", p)\n\t}\n}"}
{"input": "package summultiples\n\n\n\nfunc getMultiples(limit int, divisors []int) (set map[int]bool) {\n\tset = map[int]bool{}\n\tfor _, divisor := range divisors {\n\t\tmultiples := getMultiplesForDivisor(limit, divisor)\n\t\tfor _, multiple := range multiples {\n\t\t\tset[multiple] = true\n\t\t}\n\t}\n\treturn set\n}\n\nfunc getMultiplesForDivisor(limit int, divisor int) (multiples []int) {\n\tif divisor == 0 {\n\t\treturn multiples\n\t}\n\tmultiplyer := 1\n\tcandidate := divisor * multiplyer\n\tfor candidate < limit {\n\t\tmultiples = append(multiples, candidate)\n\t\tmultiplyer += 1\n\t\tcandidate = divisor * multiplyer\n\t}\n\treturn multiples\n}\n\nfunc SumMultiples(limit int, divisors ...int) (sum int) ", "output": "{\n\tmultiples := getMultiples(limit, divisors)\n\tfor multiple := range multiples {\n\t\tsum += multiple\n\t}\n\treturn sum\n}"}
{"input": "package core\n\nimport (\n\tctypes \"github.com/tendermint/tendermint/rpc/core/types\"\n\trpctypes \"github.com/tendermint/tendermint/rpc/lib/types\"\n\t\"github.com/tendermint/tendermint/types\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Subscribe(wsCtx rpctypes.WSRPCContext, event string) (*ctypes.ResultSubscribe, error) {\n\tlogger.Info(\"Subscribe to event\", \"remote\", wsCtx.GetRemoteAddr(), \"event\", event)\n\ttypes.AddListenerForEvent(wsCtx.GetEventSwitch(), wsCtx.GetRemoteAddr(), event, func(msg types.TMEventData) {\n\t\ttmResult := &ctypes.ResultEvent{event, msg}\n\t\twsCtx.TryWriteRPCResponse(rpctypes.NewRPCSuccessResponse(wsCtx.Request.ID+\"#event\", tmResult))\n\t})\n\treturn &ctypes.ResultSubscribe{}, nil\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Unsubscribe(wsCtx rpctypes.WSRPCContext, event string) (*ctypes.ResultUnsubscribe, error) ", "output": "{\n\tlogger.Info(\"Unsubscribe to event\", \"remote\", wsCtx.GetRemoteAddr(), \"event\", event)\n\twsCtx.GetEventSwitch().RemoveListenerForEvent(event, wsCtx.GetRemoteAddr())\n\treturn &ctypes.ResultUnsubscribe{}, nil\n}"}
{"input": "package cat\n\nimport \"time\"\nimport \"bytes\"\nimport \"fmt\"\n\ntype Meta interface {\n\tSetStatus(Panic)\n\tAddData(string, string)\n\tGetType() string\n\tGetName() string\n\tGetStatus() string\n\tGetTimestamp() time.Time\n\tSetData([]byte)\n\tGetData() []byte\n}\n\ntype meta struct {\n\tm_type      string\n\tm_name      string\n\tm_status    string\n\tm_timestamp time.Time\n\tm_data      *bytes.Buffer\n}\n\nfunc NewMeta(t string, n string) Meta {\n\treturn &meta{\n\t\tm_type:      t,\n\t\tm_name:      n,\n\t\tm_status:    \"unset\",\n\t\tm_timestamp: time.Now(),\n\t\tm_data:      nil,\n\t}\n}\n\nfunc (m *meta) SetStatus(err Panic) {\n\tif err == nil {\n\t\tm.m_status = \"0\"\n\t} else {\n\t\tm.m_status = fmt.Sprintf(\"%v\", err)\n\t}\n}\n\n\n\nfunc (m *meta) GetType() string {\n\treturn m.m_type\n}\n\nfunc (m *meta) GetName() string {\n\treturn m.m_name\n}\n\nfunc (m *meta) GetStatus() string {\n\treturn m.m_status\n}\n\nfunc (m *meta) GetTimestamp() time.Time {\n\treturn m.m_timestamp\n}\n\nfunc (m *meta) SetData(data []byte) {\n\tm.m_data = new(bytes.Buffer)\n\tm.m_data.Write(data)\n}\n\nfunc (m *meta) GetData() []byte {\n\tif m.m_data != nil {\n\t\treturn m.m_data.Bytes()\n\t} else {\n\t\treturn make([]byte, 0)\n\t}\n}\n\nfunc (m *meta) AddData(key string, value string) ", "output": "{\n\tif m.m_data == nil {\n\t\tm.m_data = new(bytes.Buffer)\n\t\tm.m_data.WriteString(key)\n\t\tm.m_data.WriteString(\"=\")\n\t\tm.m_data.WriteString(value)\n\t} else {\n\t\tm.m_data.WriteString(\"&\")\n\t\tm.m_data.WriteString(key)\n\t\tm.m_data.WriteString(\"=\")\n\t\tm.m_data.WriteString(value)\n\t}\n}"}
{"input": "package query\n\n\n\nfunc shouldEscape(c byte) bool {\n\tif 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || '0' <= c && c <= '9' {\n\t\treturn false\n\t}\n\n\tswitch c {\n\tcase '-', '_', '.', '~': \n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc Escape(s string) string ", "output": "{\n\thexCount := 0\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif shouldEscape(c) {\n\t\t\thexCount++\n\t\t}\n\t}\n\n\tif hexCount == 0 {\n\t\treturn s\n\t}\n\n\tt := make([]byte, len(s)+2*hexCount)\n\tj := 0\n\tfor i := 0; i < len(s); i++ {\n\t\tswitch c := s[i]; {\n\t\tcase shouldEscape(c):\n\t\t\tt[j] = '%'\n\t\t\tt[j+1] = \"0123456789ABCDEF\"[c>>4]\n\t\t\tt[j+2] = \"0123456789ABCDEF\"[c&15]\n\t\t\tj += 3\n\t\tdefault:\n\t\t\tt[j] = s[i]\n\t\t\tj++\n\t\t}\n\t}\n\treturn string(t)\n}"}
{"input": "package driver\n\nimport (\n\t\"github.com/Azure/azure-docker-extension/pkg/dockeropts\"\n)\n\ntype UbuntuUpstartDriver struct {\n\tubuntuBaseDriver\n\tupstartBaseDriver\n}\n\n\n\nfunc (u UbuntuUpstartDriver) UpdateDockerArgs(args string) (bool, error) {\n\tconst cfgPath = \"/etc/default/docker\"\n\te := dockeropts.UpstartCfgEditor{}\n\treturn rewriteOpts(e, cfgPath, args)\n}\n\nfunc (u UbuntuUpstartDriver) BaseOpts() []string ", "output": "{\n\treturn []string{\"-H=unix://\"}\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/binary\"\n\t\"io\"\n\t\"log\"\n)\n\n\n\n\n\n\n\n\nfunc readOne(r io.ReaderAt, i interface{}, o int64) {\n\treadOneSize(r, i, o, 65536)\n}\n\nfunc readOneSize(r io.ReaderAt, i interface{}, o int64, n int64) ", "output": "{\n\terr := binary.Read(io.NewSectionReader(r, o, n), binary.LittleEndian, i)\n\tif err != nil {\n\t\tlog.Fatalf(\"Trying to read section for %T: %v\", r, err)\n\t}\n}"}
{"input": "package generators\n\nimport (\n\t\"go-sysgen/src/definitions\"\n)\n\ntype (\n\tPrimaryStarGenerator struct{}\n)\n\n\nfunc (Generator PrimaryStarGenerator) GetName() string {\n\treturn \"PrimaryStarGenerator\"\n}\n\n\nfunc (Generator PrimaryStarGenerator) Run(system *definitions.System) {\n\tvar resultStar definitions.Star\n\tvar result interface{}\n\n\tresultStar.Primary = true\n\tresultStar.Dwarf = false\n\n\tclassProb := Generator.getStarClassProbability()\n\tresult = definitions.GetProbabilityResult(\n\t\tclassProb.RollAll(),\n\t\tclassProb.Lookup,\n\t)\n\tresultStar.Class = result.(string)\n\n\tsizeProb := Generator.getStarSizeProbability()\n\tresult = definitions.GetProbabilityResult(\n\t\tsizeProb.RollAll(),\n\t\tsizeProb.Lookup,\n\t)\n\tresultStar.Size = result.(string)\n\n\tresultStar.DecimalClassification = resultStar.GetDecimalClassification()\n\n\tresultStar.DwarfType = \"-\"\n\n\tsystem.Bodies = append(system.Bodies, resultStar)\n}\n\nfunc (Generator PrimaryStarGenerator) getStarClassProbability() definitions.Probability {\n\tvar result definitions.Probability\n\n\tresult.Dice = append(result.Dice, definitions.Dice{\n\t\tSides: 10,\n\t}, definitions.Dice{\n\t\tSides: 10,\n\t})\n\n\tresult.Lookup = map[int]interface{}{\n\t\t3:  \"A\",\n\t\t7:  \"F\",\n\t\t12: \"G\",\n\t\t17: \"K\",\n\t\t20: \"M\",\n\t}\n\n\treturn result\n}\n\n\n\nfunc (Generator PrimaryStarGenerator) getStarSizeProbability() definitions.Probability ", "output": "{\n\tvar result definitions.Probability\n\n\tresult.Dice = append(result.Dice, definitions.Dice{\n\t\tSides: 10,\n\t}, definitions.Dice{\n\t\tSides: 10,\n\t})\n\n\tresult.Lookup = map[int]interface{}{\n\t\t2:  \"II\",\n\t\t4:  \"III\",\n\t\t8:  \"IV\",\n\t\t18: \"V\",\n\t\t20: \"VI\",\n\t}\n\n\treturn result\n}"}
{"input": "package crypto\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\n\t. \"github.com/tendermint/go-common\"\n\t\"golang.org/x/crypto/openpgp/armor\"\n)\n\nfunc EncodeArmor(blockType string, headers map[string]string, data []byte) string {\n\tbuf := new(bytes.Buffer)\n\tw, err := armor.Encode(buf, blockType, headers)\n\tif err != nil {\n\t\tPanicSanity(\"Error encoding ascii armor: \" + err.Error())\n\t}\n\t_, err = w.Write(data)\n\tif err != nil {\n\t\tPanicSanity(\"Error encoding ascii armor: \" + err.Error())\n\t}\n\terr = w.Close()\n\tif err != nil {\n\t\tPanicSanity(\"Error encoding ascii armor: \" + err.Error())\n\t}\n\treturn string(buf.Bytes())\n}\n\n\n\nfunc DecodeArmor(armorStr string) (blockType string, headers map[string]string, data []byte, err error) ", "output": "{\n\tbuf := bytes.NewBufferString(armorStr)\n\tblock, err := armor.Decode(buf)\n\tif err != nil {\n\t\treturn \"\", nil, nil, err\n\t}\n\tdata, err = ioutil.ReadAll(block.Body)\n\tif err != nil {\n\t\treturn \"\", nil, nil, err\n\t}\n\treturn block.Type, block.Header, data, nil\n}"}
{"input": "package http\n\nimport (\n\t\"github.com/coraldane/falcon-agent/g\"\n\t\"github.com/toolkits/nux\"\n\t\"github.com/toolkits/sys\"\n\t\"net/http\"\n)\n\n\n\nfunc configKernelRoutes() ", "output": "{\n\thttp.HandleFunc(\"/proc/kernel/hostname\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdata, err := g.Hostname()\n\t\tAutoRender(w, data, err)\n\t})\n\n\thttp.HandleFunc(\"/proc/kernel/maxproc\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdata, err := nux.KernelMaxProc()\n\t\tAutoRender(w, data, err)\n\t})\n\n\thttp.HandleFunc(\"/proc/kernel/maxfiles\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdata, err := nux.KernelMaxFiles()\n\t\tAutoRender(w, data, err)\n\t})\n\n\thttp.HandleFunc(\"/proc/kernel/version\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdata, err := sys.CmdOutNoLn(\"uname\", \"-r\")\n\t\tAutoRender(w, data, err)\n\t})\n\n}"}
{"input": "package lib\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n\ntype GoTickets interface {\n\tTake()\n\tReturn()\n\tActive() bool\n\tTotal() uint32\n\tRemainder() uint32\n}\n\n\ntype myGoTickets struct {\n\ttotal    uint32    \n\tticketCh chan byte \n\tactive   bool      \n}\n\nfunc NewGoTickets(total uint32) (GoTickets, error) {\n\tgt := myGoTickets{}\n\tif !gt.init(total) {\n\t\terrMsg :=\n\t\t\tfmt.Sprintf(\"The goroutine ticket pool can NOT be initialized! (total=%d)\\n\", total)\n\t\treturn nil, errors.New(errMsg)\n\t}\n\treturn &gt, nil\n}\n\nfunc (gt *myGoTickets) init(total uint32) bool {\n\tif gt.active {\n\t\treturn false\n\t}\n\tif total == 0 {\n\t\treturn false\n\t}\n\tch := make(chan byte, total)\n\tn := int(total)\n\tfor i := 0; i < n; i++ {\n\t\tch <- 1\n\t}\n\tgt.ticketCh = ch\n\tgt.total = total\n\tgt.active = true\n\treturn true\n}\n\nfunc (gt *myGoTickets) Take() {\n\t<-gt.ticketCh\n}\n\nfunc (gt *myGoTickets) Return() {\n\tgt.ticketCh <- 1\n}\n\n\n\nfunc (gt *myGoTickets) Total() uint32 {\n\treturn gt.total\n}\n\nfunc (gt *myGoTickets) Remainder() uint32 {\n\treturn uint32(len(gt.ticketCh))\n}\n\nfunc (gt *myGoTickets) Active() bool ", "output": "{\n\treturn gt.active\n}"}
{"input": "package users\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/runtime/middleware\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n)\n\n\n\nfunc NewDeleteUserByIDParams() DeleteUserByIDParams {\n\tvar ()\n\treturn DeleteUserByIDParams{}\n}\n\n\n\n\n\ntype DeleteUserByIDParams struct {\n\n\tHTTPRequest *http.Request `json:\"-\"`\n\n\tUserID string\n}\n\n\n\nfunc (o *DeleteUserByIDParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {\n\tvar res []error\n\to.HTTPRequest = r\n\n\trUserID, rhkUserID, _ := route.Params.GetOK(\"userID\")\n\tif err := o.bindUserID(rUserID, rhkUserID, route.Formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n\n\nfunc (o *DeleteUserByIDParams) bindUserID(rawData []string, hasKey bool, formats strfmt.Registry) error ", "output": "{\n\tvar raw string\n\tif len(rawData) > 0 {\n\t\traw = rawData[len(rawData)-1]\n\t}\n\n\to.UserID = raw\n\n\treturn nil\n}"}
{"input": "package gtreap\n\nimport (\n\t\"math/rand\"\n\n\t\"github.com/blevesearch/bleve/index/store\"\n)\n\nfunc (w *Writer) BytesSafeAfterClose() bool {\n\treturn false\n}\n\n\n\nfunc (w *Writer) Iterator(k []byte) store.KVIterator {\n\tw.s.m.Lock()\n\tt := w.s.t\n\tw.s.m.Unlock()\n\n\treturn newIterator(t).restart(&Item{k: k})\n}\n\nfunc (w *Writer) Close() error {\n\tw.s.availableWriters <- true\n\tw.s = nil\n\n\treturn nil\n}\n\nfunc (w *Writer) Set(k, v []byte) (err error) {\n\tw.s.m.Lock()\n\tw.s.t = w.s.t.Upsert(&Item{k: k, v: v}, rand.Int())\n\tw.s.m.Unlock()\n\n\treturn nil\n}\n\nfunc (w *Writer) Delete(k []byte) (err error) {\n\tw.s.m.Lock()\n\tw.s.t = w.s.t.Delete(&Item{k: k})\n\tw.s.m.Unlock()\n\n\treturn nil\n}\n\nfunc (w *Writer) NewBatch() store.KVBatch {\n\treturn store.NewEmulatedBatch(w, w.s.mo)\n}\n\nfunc (w *Writer) Get(k []byte) (v []byte, err error) ", "output": "{\n\tw.s.m.Lock()\n\tt := w.s.t\n\tw.s.m.Unlock()\n\n\titm := t.Get(&Item{k: k})\n\tif itm != nil {\n\t\treturn itm.(*Item).v, nil\n\t}\n\treturn nil, nil\n}"}
{"input": "package v1\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"knative.dev/pkg/apis\"\n)\n\n\n\n\n\nfunc (sink *Sequence) ConvertFrom(ctx context.Context, source apis.Convertible) error {\n\treturn fmt.Errorf(\"v1 is the highest known version, got: %T\", source)\n}\n\nfunc (source *Sequence) ConvertTo(ctx context.Context, sink apis.Convertible) error ", "output": "{\n\treturn fmt.Errorf(\"v1 is the highest known version, got: %T\", sink)\n}"}
{"input": "package cache\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/smartystreets/goconvey/convey\"\n)\n\n\n\nfunc TestCacheRefreshUpType(t *testing.T) {\n\tconvey.Convey(\"RefreshUpType\", t, func(ctx convey.C) {\n\t\tvar (\n\t\t\ttm = time.Now()\n\t\t)\n\t\tctx.Convey(\"When everything goes positive\", func(ctx convey.C) {\n\t\t\tRefreshUpType(tm)\n\t\t\tctx.Convey(\"No return values\", func(ctx convey.C) {\n\t\t\t})\n\t\t})\n\t})\n}\n\nfunc TestCacheGetTidName(t *testing.T) {\n\tconvey.Convey(\"GetTidName\", t, func(ctx convey.C) {\n\t\tvar (\n\t\t\ttids = int64(0)\n\t\t)\n\t\tctx.Convey(\"When everything goes positive\", func(ctx convey.C) {\n\t\t\ttpNames := GetTidName(tids)\n\t\t\tctx.Convey(\"Then tpNames should not be nil.\", func(ctx convey.C) {\n\t\t\t\tctx.So(tpNames, convey.ShouldNotBeNil)\n\t\t\t})\n\t\t})\n\t})\n}\n\nfunc TestCacheRefreshUpTypeAsync(t *testing.T) ", "output": "{\n\tconvey.Convey(\"RefreshUpTypeAsync\", t, func(ctx convey.C) {\n\t\tvar (\n\t\t\ttm = time.Now()\n\t\t)\n\t\tctx.Convey(\"When everything goes positive\", func(ctx convey.C) {\n\t\t\tRefreshUpTypeAsync(tm)\n\t\t\tctx.Convey(\"No return values\", func(ctx convey.C) {\n\t\t\t})\n\t\t})\n\t})\n}"}
{"input": "package spnego\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/apcera/gssapi\"\n)\n\n\n\n\n\n\n\nfunc CheckSPNEGONegotiate(lib *gssapi.Lib, h http.Header, name string) (present bool, token *gssapi.Buffer) {\n\tvar err error\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tlib.Debug(fmt.Sprintf(\"CheckSPNEGONegotiate: %v\", err))\n\t\t}\n\t}()\n\n\tv := h.Get(name)\n\tif len(v) == 0 || !strings.HasPrefix(v, \"Negotiate\") {\n\t\treturn false, nil\n\t}\n\n\tpresent = true\n\ttbytes, err := base64.StdEncoding.DecodeString(strings.TrimSpace(v[len(\"Negotiate\"):]))\n\tif err != nil {\n\t\treturn false, nil\n\t}\n\n\tif len(tbytes) > 0 {\n\t\ttoken, err = lib.MakeBufferBytes(tbytes)\n\t\tif err != nil {\n\t\t\treturn false, nil\n\t\t}\n\t}\n\n\treturn present, token\n}\n\nfunc AddSPNEGONegotiate(h http.Header, name string, token *gssapi.Buffer) ", "output": "{\n\tif name == \"\" {\n\t\treturn\n\t}\n\n\tv := \"Negotiate\"\n\tif token.Length() != 0 {\n\t\tdata := token.Bytes()\n\t\tv = v + \" \" + base64.StdEncoding.EncodeToString(data)\n\t}\n\th.Set(name, v)\n}"}
{"input": "package lib\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"time\"\n)\n\nfunc BytesToUint32(data []byte) (uint32, bool) {\n\tif len(data) != 4 {\n\t\treturn 0, false\n\t}\n\treturn binary.LittleEndian.Uint32(data), true\n}\n\n\n\nfunc CalcPocketCount(length, pocket_length uint32) uint32 {\n\treturn ((length / pocket_length) + 1)\n}\n\n\nfunc Log(message string) {\n\tfmt.Println(message)\n}\n\nfunc CombineBytesMap(data map[uint32][]byte) (ret_data []byte) {\n\tvar keys []int\n\tfor k, _ := range data {\n\t\tkeys = append(keys, int(k))\n\t}\n\tsort.Ints(keys)\n\tfor _, k := range keys {\n\t\tret_data = append(ret_data, data[uint32(k)]...)\n\t}\n\treturn\n}\n\nfunc Random(min, max int) uint32 {\n\trand.Seed(time.Now().UnixNano())\n\treturn uint32(rand.Intn(max-min) + min)\n}\n\n\nfunc FakeData(count int) []byte {\n\tret_data := make([]byte, count)\n\tfor i := 0; i < count; i++ {\n\t\tret_data[i] = byte(15) \n\t}\n\treturn ret_data\n}\n\nfunc Uin32ToBytes(number uint32) (ret_data []byte) ", "output": "{\n\tret_data = make([]byte, 4)\n\tbinary.LittleEndian.PutUint32(ret_data, number)\n\treturn ret_data\n}"}
{"input": "package v1alpha1\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestNewVerificationClaims(t *testing.T) {\n\tt.Parallel()\n\n\tgot := NewVerificationClaims()\n\twant := &VerificationClaims{\n\t\tTransmissionRisks: []TransmissionRiskOverride{},\n\t}\n\n\tif diff := cmp.Diff(want, got); diff != \"\" {\n\t\tt.Errorf(\"mismatch (-want +got):\\n%v\", diff)\n\t}\n}\n\n\n\nfunc TestTransmissionRiskVectorSort(t *testing.T) ", "output": "{\n\tt.Parallel()\n\n\tgot := TransmissionRiskVector{\n\t\t{0, 0},\n\t\t{3, 100},\n\t\t{5, 200},\n\t}\n\tsort.Sort(got)\n\n\twant := TransmissionRiskVector{{5, 200}, {3, 100}, {0, 0}}\n\n\tif diff := cmp.Diff(want, got); diff != \"\" {\n\t\tt.Errorf(\"sort(TransmissionRiskVector) mismatch (-want +got):\\n%v\", diff)\n\t}\n}"}
{"input": "package gce\n\nimport (\n\t\"context\"\n\t\"github.com/supergiant/control/pkg/clouds/gcesdk\"\n\t\"io\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/supergiant/control/pkg/workflows/steps\"\n\t\"google.golang.org/api/compute/v1\"\n)\n\nconst DeleteTargetPoolStepName = \"gce_delete_target_pool\"\n\ntype DeleteTargetPoolStep struct {\n\tgetComputeSvc func(context.Context, steps.GCEConfig) (*computeService, error)\n}\n\n\n\nfunc (s *DeleteTargetPoolStep) Run(ctx context.Context, output io.Writer,\n\tconfig *steps.Config) error {\n\n\tlogrus.Debugf(\"Step %s\", DeleteTargetPoolStepName)\n\n\tsvc, err := s.getComputeSvc(ctx, config.GCEConfig)\n\n\tif err != nil {\n\t\tlogrus.Errorf(\"Error getting service %v\", err)\n\t\treturn errors.Wrapf(err, \"%s getting service caused\", DeleteTargetPoolStepName)\n\t}\n\n\t_, err = svc.deleteTargetPool(ctx, config.GCEConfig, config.GCEConfig.TargetPoolName)\n\n\tif err != nil {\n\t\tlogrus.Errorf(\"Error deleting target pool %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (s *DeleteTargetPoolStep) Name() string {\n\treturn DeleteTargetPoolStepName\n}\n\nfunc (s *DeleteTargetPoolStep) Depends() []string {\n\treturn nil\n}\n\nfunc (s *DeleteTargetPoolStep) Description() string {\n\treturn \"Delete target pool master nodes\"\n}\n\nfunc (s *DeleteTargetPoolStep) Rollback(context.Context, io.Writer, *steps.Config) error {\n\treturn nil\n}\n\nfunc NewDeleteTargetPoolStep() *DeleteTargetPoolStep ", "output": "{\n\treturn &DeleteTargetPoolStep{\n\t\tgetComputeSvc: func(ctx context.Context, config steps.GCEConfig) (*computeService, error) {\n\t\t\tclient, err := gcesdk.GetClient(ctx, config)\n\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn &computeService{\n\t\t\t\tdeleteTargetPool: func(ctx context.Context, config steps.GCEConfig, targetPoolName string) (*compute.Operation, error) {\n\t\t\t\t\treturn client.TargetPools.Delete(config.ServiceAccount.ProjectID, config.Region, targetPoolName).Do()\n\t\t\t\t},\n\t\t\t}, nil\n\t\t},\n\t}\n}"}
{"input": "package httphandlers\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t_ \"github.com/jamesrr39/tracks-app/build/client/statik\"\n\t\"github.com/rakyll/statik/fs\"\n)\n\n\n\nfunc NewClientHandler() http.Handler ", "output": "{\n\tstatikFS, err := fs.New()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn http.FileServer(statikFS)\n}"}
{"input": "package cmd\n\nimport (\n\t\"github.com/negz/secret-volume/volume\"\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/spf13/afero\"\n)\n\n\n\nfunc setupFs(virt bool, root string) (volume.Mounter, afero.Fs, error) ", "output": "{\n\tif virt {\n\t\tlog.Debug(\"Using in-memory filesystem and noop mounter\")\n\t\tfs := afero.NewMemMapFs()\n\t\tif err := fs.MkdirAll(root, 0700); err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\treturn volume.NewNoopMounter(root), fs, nil\n\t}\n\ttmpfs, err := volume.NewTmpFsMounter(root)\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrapf(err, \"cannot setup tmpfs mounter\")\n\t}\n\n\tlog.Debug(\"Using OS filesystem and tmpfs mounter\")\n\treturn tmpfs, afero.NewOsFs(), nil\n}"}
{"input": "package config_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/minero/minero/config\"\n)\n\n\n\nfunc ExamplePrettyMap() ", "output": "{\n\tc := config.New()\n\tc.Parse(\"a:\\n b:2\\n c:3\\nd:4\")\n\n\tm := c.Copy()\n\tfmt.Println(config.PrettyMap(m))\n}"}
{"input": "package bst\n\n\n\n\n\nfunc (tr Tree) Max() *Node {\n\tnd := tr.Root\n\tif nd == nil {\n\t\treturn nil\n\t}\n\tfor nd.Right != nil {\n\t\tnd = nd.Right\n\t}\n\treturn nd\n}\n\n\nfunc (tr Tree) Search(key Interface) *Node {\n\tnd := tr.Root\n\tfor nd != nil {\n\t\tif nd.Key == nil {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase nd.Key.Less(key):\n\t\t\tnd = nd.Right\n\t\tcase key.Less(nd.Key):\n\t\t\tnd = nd.Left\n\t\tdefault:\n\t\t\treturn nd\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (tr Tree) SearchChan(key Interface, ch chan *Node) {\n\tsearchChan(tr.Root, key, ch)\n\tclose(ch)\n}\n\nfunc searchChan(nd *Node, key Interface, ch chan *Node) {\n\tif nd == nil {\n\t\treturn\n\t}\n\tif !nd.Key.Less(key) && !key.Less(nd.Key) {\n\t\tch <- nd\n\t\treturn\n\t}\n\tsearchChan(nd.Left, key, ch)  \n\tsearchChan(nd.Right, key, ch) \n}\n\n\nfunc (tr Tree) SearchParent(key Interface) *Node {\n\tnd := tr.Root\n\tparent := new(Node)\n\tparent = nil\n\tfor nd != nil {\n\t\tif nd.Key == nil {\n\t\t\tbreak\n\t\t}\n\t\tswitch {\n\t\tcase nd.Key.Less(key):\n\t\t\tparent = nd \n\t\t\tnd = nd.Right\n\t\tcase key.Less(nd.Key):\n\t\t\tparent = nd \n\t\t\tnd = nd.Left\n\t\tdefault:\n\t\t\treturn parent\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (tr Tree) Min() *Node ", "output": "{\n\tnd := tr.Root\n\tif nd == nil {\n\t\treturn nil\n\t}\n\tfor nd.Left != nil {\n\t\tnd = nd.Left\n\t}\n\treturn nd\n}"}
{"input": "package sale\n\nimport \"go2o/src/core/domain/interface/valueobject\"\n\n\n\n\n\nfunc ParseToValueGoods(v *valueobject.Goods) *ValueGoods {\n\treturn &ValueGoods{\n\t\tId:            v.GoodsId,\n\t\tItemId:        v.Item_Id,\n\t\tIsPresent:     v.IsPresent,\n\t\tSkuId:         v.SkuId,\n\t\tPromotionFlag: v.PromotionFlag,\n\t\tStockNum:      v.StockNum,\n\t\tSaleNum:       v.SaleNum,\n\t\tSalePrice:     v.SalePrice,\n\t\tPromPrice:     v.PromPrice,\n\t\tPrice:         v.Price,\n\t}\n}\n\nfunc ParseToPartialValueItem(v *valueobject.Goods) *ValueItem ", "output": "{\n\treturn &ValueItem{\n\t\tId:         v.Item_Id,\n\t\tCategoryId: v.CategoryId,\n\t\tName:       v.Name,\n\t\tGoodsNo:    v.GoodsNo,\n\t\tImage:      v.Image,\n\t\tPrice:      v.Price,\n\t\tSalePrice:  v.SalePrice,\n\t}\n}"}
{"input": "package eav\n\ntype (\n\tAttributeFrontendModeller interface {\n\t\tInputRenderer() FrontendInputRendererIFace\n\t\tGetValue()\n\t\tGetInputType() string\n\n\t\tConfig(...AttributeFrontendConfig) AttributeFrontendModeller\n\t}\n\tFrontendInputRendererIFace interface {\n\t}\n\tAttributeFrontend struct {\n\t\ta *Attribute\n\t\tidx AttributeIndex\n\t}\n\tAttributeFrontendConfig func(*AttributeFrontend)\n)\n\nvar _ AttributeFrontendModeller = (*AttributeFrontend)(nil)\n\n\nfunc NewAttributeFrontend(cfgs ...AttributeFrontendConfig) *AttributeFrontend {\n\tas := &AttributeFrontend{\n\t\ta: nil,\n\t}\n\tas.Config(cfgs...)\n\treturn as\n}\n\n\nfunc AttributeFrontendIdx(i AttributeIndex) AttributeFrontendConfig {\n\treturn func(as *AttributeFrontend) {\n\t\tas.idx = i\n\t}\n}\n\n\nfunc (af *AttributeFrontend) Config(configs ...AttributeFrontendConfig) AttributeFrontendModeller {\n\tfor _, cfg := range configs {\n\t\tcfg(af)\n\t}\n\treturn af\n}\n\nfunc (af *AttributeFrontend) InputRenderer() FrontendInputRendererIFace { return nil }\nfunc (af *AttributeFrontend) GetValue()                                 {}\n\n\nfunc (af *AttributeFrontend) GetInputType() string ", "output": "{\n\treturn af.a.FrontendInput()\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\nconst (\n\tStatusUnknown = iota\n\tStatusPassed\n\tStatusRunning\n\tStatusFailed\n\tStatusError\n)\n\nvar statusText = []string{\"Unknown\", \"Passed\", \"Running\", \"Failed\", \"Error\"}\n\n\ntype BuildReport struct {\n\tRepoName     string\n\tOwner        string\n\tTag          string\n\tImageName    string\n\tBuildContext string\n\tDuration     time.Duration\n\tStart        time.Time\n\tstatus int\n\tStatusNotify GitStatusNotify\n}\n\n\nfunc (r *BuildReport) SetStatus(status int) {\n\tr.status = status % 5\n\tif r.StatusNotify != nil {\n\t\tgo r.StatusNotify.UpdateStatus(r.Owner, r.RepoName, r.Tag, r.status)\n\t}\n}\n\n\n\n\n\ntype BuildStats struct {\n\treports []BuildReport\n}\n\n\nfunc (s *BuildStats) SendReport(report BuildReport) {\n\ts.reports = append(s.reports, report)\n}\n\n\nfunc (s *BuildStats) GetStatsReport() string {\n\tvar report string\n\tfor _, r := range s.reports {\n\t\trepJSON, err := json.Marshal(r)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\treport += fmt.Sprintln(string(repJSON))\n\t}\n\treturn report\n}\n\n\nfunc (s *BuildStats) ReportHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"MicroCI Build Reports\")\n\tfmt.Fprintln(w, \"=====================\")\n\tfmt.Fprintln(w, s.GetStatsReport())\n}\n\nfunc (r *BuildReport) GetStatus() string ", "output": "{\n\treturn statusText[r.status]\n}"}
{"input": "package tokenattributes\n\nimport (\n\t\"github.com/balzaczyy/golucene/core/util\"\n)\n\n\ntype OffsetAttribute interface {\n\tutil.Attribute\n\tStartOffset() int\n\tSetOffset(int, int)\n\tEndOffset() int\n}\n\n\ntype OffsetAttributeImpl struct {\n\tstartOffset, endOffset int\n}\n\n\n\nfunc (a *OffsetAttributeImpl) Interfaces() []string {\n\treturn []string{\"OffsetAttribute\"}\n}\n\nfunc (a *OffsetAttributeImpl) StartOffset() int {\n\treturn a.startOffset\n}\n\nfunc (a *OffsetAttributeImpl) SetOffset(startOffset, endOffset int) {\n\tassert2(startOffset >= 0 && startOffset <= endOffset,\n\t\t\"startOffset must be non-negative, and endOffset must be >= startOffset, startOffset=%v,endOffset=%v\",\n\t\tstartOffset, endOffset)\n\ta.startOffset = startOffset\n\ta.endOffset = a.endOffset\n}\n\nfunc (a *OffsetAttributeImpl) EndOffset() int {\n\treturn a.endOffset\n}\n\nfunc (a *OffsetAttributeImpl) Clear() {\n\ta.startOffset = 0\n\ta.endOffset = 0\n}\n\nfunc (a *OffsetAttributeImpl) Clone() util.AttributeImpl {\n\treturn &OffsetAttributeImpl{\n\t\tstartOffset: a.startOffset,\n\t\tendOffset:   a.endOffset,\n\t}\n}\n\nfunc (a *OffsetAttributeImpl) CopyTo(target util.AttributeImpl) {\n\ttarget.(OffsetAttribute).SetOffset(a.startOffset, a.endOffset)\n}\n\nfunc newOffsetAttributeImpl() util.AttributeImpl ", "output": "{\n\treturn new(OffsetAttributeImpl)\n}"}
{"input": "package service\n\nimport (\n\tcontext \"context\"\n\n\tv1 \"k8s.io/client-go/informers/core/v1\"\n\tfactory \"knative.dev/pkg/client/injection/kube/informers/factory\"\n\tcontroller \"knative.dev/pkg/controller\"\n\tinjection \"knative.dev/pkg/injection\"\n\tlogging \"knative.dev/pkg/logging\"\n)\n\nfunc init() {\n\tinjection.Default.RegisterInformer(withInformer)\n}\n\n\ntype Key struct{}\n\nfunc withInformer(ctx context.Context) (context.Context, controller.Informer) {\n\tf := factory.Get(ctx)\n\tinf := f.Core().V1().Services()\n\treturn context.WithValue(ctx, Key{}, inf), inf.Informer()\n}\n\n\n\n\nfunc Get(ctx context.Context) v1.ServiceInformer ", "output": "{\n\tuntyped := ctx.Value(Key{})\n\tif untyped == nil {\n\t\tlogging.FromContext(ctx).Panic(\n\t\t\t\"Unable to fetch k8s.io/client-go/informers/core/v1.ServiceInformer from context.\")\n\t}\n\treturn untyped.(v1.ServiceInformer)\n}"}
{"input": "package framework\n\nimport \"github.com/onsi/gomega\"\n\n\nfunc ExpectEqual(actual interface{}, extra interface{}, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1, actual).To(gomega.Equal(extra), explain...)\n}\n\n\nfunc ExpectNotEqual(actual interface{}, extra interface{}, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1, actual).NotTo(gomega.Equal(extra), explain...)\n}\n\n\nfunc ExpectError(err error, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1, err).To(gomega.HaveOccurred(), explain...)\n}\n\n\nfunc ExpectNoError(err error, explain ...interface{}) {\n\tExpectNoErrorWithOffset(1, err, explain...)\n}\n\n\n\nfunc ExpectNoErrorWithOffset(offset int, err error, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1+offset, err).NotTo(gomega.HaveOccurred(), explain...)\n}\n\n\n\n\n\nfunc ExpectHaveKey(actual interface{}, key interface{}, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1, actual).To(gomega.HaveKey(key), explain...)\n}\n\n\nfunc ExpectEmpty(actual interface{}, explain ...interface{}) {\n\tgomega.ExpectWithOffset(1, actual).To(gomega.BeEmpty(), explain...)\n}\n\nfunc ExpectConsistOf(actual interface{}, extra interface{}, explain ...interface{}) ", "output": "{\n\tgomega.ExpectWithOffset(1, actual).To(gomega.ConsistOf(extra), explain...)\n}"}
{"input": "package main\n\nimport (\n    \"net\"\n)\n\nfunc LocalAddrs() ([]string, error) {\n    var localAddrs = []string{}\n    addrs, err := net.InterfaceAddrs()\n    if err != nil {\n        return nil, err\n    }\n    for _, addr := range addrs {\n        \n        ip, _, err := net.ParseCIDR(addr.String())\n        if ip.IsLoopback() {\n            continue\n        }\n        if err == nil && ip != nil {\n            localAddrs = append(localAddrs, ip.String())\n        }\n    }\n    return localAddrs, nil\n}\n\n\n\nfunc IsLoopback(ip_str string) (bool, error) ", "output": "{\n\n    ip := net.ParseIP(ip_str)\n    if ip == nil {\n        return false, MsgError(\"Wrong IP format %s\", ip_str)\n    }\n    return ip.IsLoopback(), nil\n}"}
{"input": "package install\n\nimport (\n\t\"k8s.io/apimachinery/pkg/apimachinery/announced\"\n\t\"k8s.io/apimachinery/pkg/apimachinery/registered\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\t\"k8s.io/metrics/pkg/apis/metrics\"\n\t\"k8s.io/metrics/pkg/apis/metrics/v1beta1\"\n)\n\n\n\n\nfunc Install(groupFactoryRegistry announced.APIGroupFactoryRegistry, registry *registered.APIRegistrationManager, scheme *runtime.Scheme) ", "output": "{\n\tif err := announced.NewGroupMetaFactory(\n\t\t&announced.GroupMetaFactoryArgs{\n\t\t\tGroupName:                  metrics.GroupName,\n\t\t\tVersionPreferenceOrder:     []string{v1beta1.SchemeGroupVersion.Version},\n\t\t\tRootScopedKinds:            sets.NewString(\"NodeMetrics\"),\n\t\t\tAddInternalObjectsToScheme: metrics.AddToScheme,\n\t\t},\n\t\tannounced.VersionToSchemeFunc{\n\t\t\tv1beta1.SchemeGroupVersion.Version:  v1beta1.AddToScheme,\n\t\t},\n\t).Announce(groupFactoryRegistry).RegisterAndEnable(registry, scheme); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"input": "package helper\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/user\"\n\t\"path\"\n)\n\nconst (\n\tDateFormat = \"2006-01-02\"\n)\n\n\n\nfunc GetDBPath(pathFromArgs string) string ", "output": "{\n\tif pathFromArgs != \"\" {\n\t\treturn pathFromArgs\n\t}\n\n\tfilePath := \"flowette.db\"\n\tif _, err := os.Stat(filePath); err == nil {\n\t\treturn filePath\n\t}\n\n\tif usr, err := user.Current(); err == nil {\n\t\tfilePath = path.Join(usr.HomeDir, \".\"+filePath)\n\t\tif _, err := os.Stat(filePath); err == nil {\n\t\t\treturn filePath\n\t\t}\n\t}\n\n\tlog.Fatal(\"Could not locate flowette.db\")\n\treturn \"\"\n}"}
{"input": "package dhcpv6\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/u-root/uio/uio\"\n)\n\n\nfunc OptRelayPort(port uint16) Option {\n\treturn &optRelayPort{DownstreamSourcePort: port}\n}\n\ntype optRelayPort struct {\n\tDownstreamSourcePort uint16\n}\n\nfunc (op *optRelayPort) Code() OptionCode {\n\treturn OptionRelayPort\n}\n\n\n\nfunc (op *optRelayPort) String() string {\n\treturn fmt.Sprintf(\"RelayPort: %d\", op.DownstreamSourcePort)\n}\n\n\n\nfunc parseOptRelayPort(data []byte) (*optRelayPort, error) {\n\tvar opt optRelayPort\n\tbuf := uio.NewBigEndianBuffer(data)\n\topt.DownstreamSourcePort = buf.Read16()\n\treturn &opt, buf.FinError()\n}\n\nfunc (op *optRelayPort) ToBytes() []byte ", "output": "{\n\tbuf := uio.NewBigEndianBuffer(nil)\n\tbuf.Write16(op.DownstreamSourcePort)\n\treturn buf.Data()\n}"}
{"input": "package optimization\n\nimport ma \"github.com/entropyx/math\"\n\n\n\n\nfunc GradientChecking(fn func([]float64) float64, theta []float64, epsilon float64) float64 {\n\tvar x, y []float64\n\tfor i := 0; i < len(theta); i++ {\n\t\tx = append(x, theta[i]+epsilon)\n\t\ty = append(y, theta[i]-epsilon)\n\t}\n\tchecking := (fn(x) - fn(y)) / 2 * epsilon\n\treturn checking\n}\n\n\n\n\nfunc GradientDecent(gradient func([]float64) []float64, p []float64, alpha float64, iter int) (optim []float64) ", "output": "{\n\tfor i := 0; i < iter; i++ {\n\t\tdelta := gradient(p)\n\t\tfor j := 0; j < len(p); j++ {\n\t\t\tdelta[j] = alpha * delta[j]\n\t\t}\n\t\tp = ma.VectorDiff(p, delta)\n\t}\n\toptim = p\n\treturn\n}"}
{"input": "package base\n\nimport (\n\t\"math\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc GaussianRandom() {\n\n\trand.Seed(99)\n\n}\n\n\n\nfunc GetRani(a float64, b float64) float64 {\n\n\treturn math.Floor(GetRandf(a, b))\n}\n\nfunc GetRandn(mu float64, std float64) float64 {\n\n\treturn rand.NormFloat64()*mu + std\n}\n\nfunc GetRandf(a float64, b float64) float64 ", "output": "{\n\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\treturn (b-a)*r.Float64() + a \n}"}
{"input": "package baseutil\n\n\n\n\n\n\n\nfunc Check(e error) ", "output": "{\n\tif e != nil {\n\t\tpanic(e)\n\t}\n}"}
{"input": "package answers\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\n\t\"model/users\"\n\n\t\"appengine/srv\"\n)\n\n\n\nvar infoTmpl = \"\"\n\n\n\nfunc GetList(wr srv.WrapperRequest, tc map[string]interface{}) (string, error) {\n\tif wr.NU.GetRole() < users.ROLE_STUDENT {\n\t\treturn infoTmpl, fmt.Errorf(\"answers: getlist: %v\", users.ERR_NOTOPERATIONALLOWED)\n\t}\n\n\twr.R.ParseForm()\n\tvar err error\n\tfilters := wr.R.Form\n\texerciseId := int64(0)\n\tquestId := int64(0)\n\tauthorId := wr.NU.ID()\n\n\tif filters[\"exercise\"] != nil {\n\t\texerciseId, err = strconv.ParseInt(filters[\"exercise\"][0], 10, 64)\n\t\tif err != nil {\n\t\t\treturn infoTmpl, fmt.Errorf(\"answers: getlist: %v\", err)\n\t\t}\n\t}\n\n\tif filters[\"quest\"] != nil {\n\t\tquestId, err = strconv.ParseInt(filters[\"quest\"][0], 10, 64)\n\t\tif err != nil {\n\t\t\treturn infoTmpl, fmt.Errorf(\"answers: getlist: %v\", err)\n\t\t}\n\t}\n\n\tall, err := GetAnswers(wr, authorId, questId, exerciseId)\n\tif err != nil {\n\t\treturn infoTmpl, fmt.Errorf(\"answers: getlist: %v\", err)\n\t}\n\n\ttc[\"Content\"] = all\n\n\treturn infoTmpl, nil\n}\n\nfunc Add(wr srv.WrapperRequest, tc map[string]interface{}) (string, error) ", "output": "{\n\tif wr.NU.GetRole() < users.ROLE_STUDENT {\n\t\treturn infoTmpl, errors.New(users.ERR_NOTOPERATIONALLOWED)\n\t}\n\n\tvar a *Answer\n\n\tdecoder := json.NewDecoder(wr.R.Body)\n\terr := decoder.Decode(&a)\n\tif err != nil {\n\t\treturn infoTmpl, err\n\t}\n\n\ta.BuildBody()\n\ta.AuthorId = wr.NU.ID()\n\n\terr = putAnswer(wr, a)\n\tif err != nil {\n\t\treturn infoTmpl, err\n\t}\n\n\ttc[\"Content\"] = a\n\treturn infoTmpl, nil\n}"}
{"input": "package fakes\n\nimport (\n\tboshas \"github.com/cloudfoundry/bosh-agent/agent/applier/applyspec\"\n\t\"github.com/cloudfoundry/bosh-agent/agent/applier/models\"\n)\n\ntype FakeApplier struct {\n\tPrepared                bool\n\tPrepareDesiredApplySpec boshas.ApplySpec\n\tPrepareError            error\n\n\tApplied               bool\n\tApplyCurrentApplySpec boshas.ApplySpec\n\tApplyDesiredApplySpec boshas.ApplySpec\n\tApplyError            error\n\n\tConfigured                 bool\n\tConfiguredDesiredApplySpec boshas.ApplySpec\n\tConfiguredJobs             []models.Job\n\tConfiguredError            error\n}\n\nfunc NewFakeApplier() *FakeApplier {\n\treturn &FakeApplier{}\n}\n\nfunc (s *FakeApplier) Prepare(desiredApplySpec boshas.ApplySpec) error {\n\ts.Prepared = true\n\ts.PrepareDesiredApplySpec = desiredApplySpec\n\treturn s.PrepareError\n}\n\n\n\nfunc (s *FakeApplier) Apply(currentApplySpec, desiredApplySpec boshas.ApplySpec) error {\n\ts.Applied = true\n\ts.ApplyCurrentApplySpec = currentApplySpec\n\ts.ApplyDesiredApplySpec = desiredApplySpec\n\treturn s.ApplyError\n}\n\nfunc (s *FakeApplier) ConfigureJobs(desiredApplySpec boshas.ApplySpec) error ", "output": "{\n\ts.Configured = true\n\ts.ConfiguredDesiredApplySpec = desiredApplySpec\n\treturn s.ConfiguredError\n}"}
{"input": "package models\n\n\ntype DefaultTrigger struct{}\n\n\n\n\nfunc (dt DefaultTrigger) IsTriggered(times interface{}, user interface{}) bool ", "output": "{\n\treturn true\n}"}
{"input": "package adapterManager\n\nimport (\n\t\"istio.io/mixer/pkg/adapter\"\n\t\"istio.io/mixer/pkg/pool\"\n)\n\ntype env struct {\n\tlogger adapter.Logger\n\tgp     *pool.GoroutinePool\n}\n\n\n\nfunc (e env) Logger() adapter.Logger {\n\treturn e.logger\n}\n\nfunc (e env) ScheduleWork(fn adapter.WorkFunc) {\n\te.gp.ScheduleWork(func() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\t_ = e.Logger().Errorf(\"Adapter worker failed: %v\", r)\n\n\t\t\t}\n\t\t}()\n\n\t\tfn()\n\t})\n}\n\nfunc (e env) ScheduleDaemon(fn adapter.DaemonFunc) {\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\t_ = e.Logger().Errorf(\"Adapter daemon failed: %v\", r)\n\n\t\t\t}\n\t\t}()\n\n\t\tfn()\n\t}()\n}\n\nfunc newEnv(aspect string, gp *pool.GoroutinePool) adapter.Env ", "output": "{\n\treturn env{\n\t\tlogger: newLogger(aspect),\n\t\tgp:     gp,\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tDEBUG = false\n)\n\n\n\nfunc main() {\n\tvar line string\n\tstdin := bufio.NewReader(os.Stdin)\n\n\tvar i, count int = 0, 1\n\tfmt.Scanf(\"%d \", &i)\n\tfor ; i != 0; count++ {\n\t\tanimals := make(map[string]int)\n\n\t\tfor ; i > 0; i-- {\n\t\t\tline, _ = stdin.ReadString('\\n')\n\t\t\tfields := strings.Fields(line)\n\t\t\tanimals[strings.ToLower(fields[len(fields)-1])]++\n\t\t}\n\n\t\tvar keys []string\n\t\tfor key, _ := range animals {\n\t\t\tkeys = append(keys, key)\n\t\t}\n\n\t\tsort.Strings(keys)\n\n\t\tfmt.Printf(\"List %d:\\n\", count)\n\t\tfor _, key := range keys {\n\t\t\tfmt.Println(key, \"|\", animals[key])\n\t\t}\n\n\t\tline, _ = stdin.ReadString('\\n')\n\t\tfields := strings.Fields(line)\n\t\ti, _ = strconv.Atoi(fields[0])\n\t\tdebug(map[string]interface{}{\n\t\t\t\"i\":    i,\n\t\t\t\"keys\": keys,\n\t\t})\n\t}\n}\n\nfunc debug(a map[string]interface{}) ", "output": "{\n\tif DEBUG == true && len(a) > 0 {\n\t\tvar strs []string\n\t\tfor k, v := range a {\n\t\t\tstrs = append(strs, fmt.Sprintf(\"%v: %v\", k, v))\n\t\t}\n\t\tfmt.Println(strings.Join(strs, \"\\n\"))\n\t}\n}"}
{"input": "package iso20022\n\n\ntype IdentificationModification1 struct {\n\n\tIdentification *Max35Text `xml:\"Id\"`\n\n\tOriginalPartyAndAccountIdentification *IdentificationInformation1 `xml:\"OrgnlPtyAndAcctId,omitempty\"`\n\n\tUpdatedPartyAndAccountIdentification *IdentificationInformation1 `xml:\"UpdtdPtyAndAcctId\"`\n\n\tAdditionalInformation *Max140Text `xml:\"AddtlInf,omitempty\"`\n}\n\nfunc (i *IdentificationModification1) SetIdentification(value string) {\n\ti.Identification = (*Max35Text)(&value)\n}\n\n\n\nfunc (i *IdentificationModification1) AddUpdatedPartyAndAccountIdentification() *IdentificationInformation1 {\n\ti.UpdatedPartyAndAccountIdentification = new(IdentificationInformation1)\n\treturn i.UpdatedPartyAndAccountIdentification\n}\n\nfunc (i *IdentificationModification1) SetAdditionalInformation(value string) {\n\ti.AdditionalInformation = (*Max140Text)(&value)\n}\n\nfunc (i *IdentificationModification1) AddOriginalPartyAndAccountIdentification() *IdentificationInformation1 ", "output": "{\n\ti.OriginalPartyAndAccountIdentification = new(IdentificationInformation1)\n\treturn i.OriginalPartyAndAccountIdentification\n}"}
{"input": "package victor\n\nimport (\n\t\"github.com/FogCreek/victor/pkg/chat\"\n)\n\n\ntype Handler interface {\n\tHandle(State)\n}\n\n\ntype HandlerFunc func(State)\n\n\n\nfunc (f HandlerFunc) Handle(s State) {\n\tf(s)\n}\n\n\n\ntype State interface {\n\tRobot() Robot\n\tChat() chat.Adapter\n\tMessage() chat.Message\n\tFields() []string\n\tReply(string)\n}\n\ntype state struct {\n\trobot   Robot\n\tmessage chat.Message\n\tfields  []string\n}\n\n\n\n\n\n\n\n\nfunc (s *state) Robot() Robot {\n\treturn s.robot\n}\n\n\nfunc (s *state) Chat() chat.Adapter {\n\treturn s.robot.Chat()\n}\n\n\nfunc (s *state) Message() chat.Message {\n\treturn s.message\n}\n\nfunc (s *state) Fields() []string {\n\treturn s.fields\n}\n\nfunc (s *state) Reply(msg string) ", "output": "{\n\ts.robot.Chat().Send(s.message.Channel().ID(), msg)\n}"}
{"input": "package boshio\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\ntype Downloader interface {\n\tDownload(string, string) error\n}\n\ntype downloader struct{}\n\nfunc NewDownloader() Downloader {\n\treturn &downloader{}\n}\n\n\n\nfunc (d *downloader) Download(url string, targetFile string) error ", "output": "{\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tout, err := os.Create(targetFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\t_, err = io.Copy(out, resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package aggregation\n\nimport (\n\t\"github.com/pingcap/tidb/sessionctx/stmtctx\"\n\t\"github.com/pingcap/tidb/types\"\n\t\"github.com/pingcap/tidb/util/chunk\"\n)\n\ntype sumFunction struct {\n\taggFunction\n}\n\n\n\n\n\nfunc (sf *sumFunction) GetResult(evalCtx *AggEvaluateContext) (d types.Datum) {\n\treturn evalCtx.Value\n}\n\n\nfunc (sf *sumFunction) GetPartialResult(evalCtx *AggEvaluateContext) []types.Datum {\n\treturn []types.Datum{sf.GetResult(evalCtx)}\n}\n\nfunc (sf *sumFunction) Update(evalCtx *AggEvaluateContext, sc *stmtctx.StatementContext, row chunk.Row) error ", "output": "{\n\treturn sf.updateSum(sc, evalCtx, row)\n}"}
{"input": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\n\nfunc test() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tfmt.Println(err)\n\t\t}\n\t}()\n\n\terr := initConfig()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn\n}\n\nfunc main() {\n\tfor {\n\t\ttest()\n\t\tfmt.Println(\"hello\")\n\t\ttime.Sleep(time.Second)\n\t}\n\n}\n\nfunc initConfig() (err error) ", "output": "{\n\treturn errors.New(\"init config faild\")\n}"}
{"input": "package builtin\n\n\nconst gpioMemoryControlSummary = `allows write access to all gpio memory`\n\nconst gpioMemoryControlBaseDeclarationSlots = `\n  gpio-memory-control:\n    allow-installation:\n      slot-snap-type:\n        - core\n    deny-auto-connection: true\n`\n\nconst gpioMemoryControlConnectedPlugAppArmor = `\n# Description: Allow writing to /dev/gpiomem on kernels that provide it (eg,\n# via the bcm2835-gpiomem kernel module). This allows direct access to the\n# physical memory for GPIO devices (i.e. a subset of /dev/mem) and therefore\n# grants access to all GPIO devices on the system.\n/dev/gpiomem rw,\n`\n\nvar gpioMemoryControlConnectedPlugUDev = []string{`KERNEL==\"gpiomem\"`}\n\n\n\nfunc init() ", "output": "{\n\tregisterIface(&commonInterface{\n\t\tname:                  \"gpio-memory-control\",\n\t\tsummary:               gpioMemoryControlSummary,\n\t\timplicitOnCore:        true,\n\t\timplicitOnClassic:     true,\n\t\tbaseDeclarationSlots:  gpioMemoryControlBaseDeclarationSlots,\n\t\tconnectedPlugAppArmor: gpioMemoryControlConnectedPlugAppArmor,\n\t\tconnectedPlugUDev:     gpioMemoryControlConnectedPlugUDev,\n\t})\n}"}
{"input": "package config\n\nimport (\n\tcb \"github.com/hyperledger/fabric/protos/common\"\n\tab \"github.com/hyperledger/fabric/protos/orderer\"\n\t\"github.com/hyperledger/fabric/protos/utils\"\n)\n\nfunc ordererConfigGroup(key string, value []byte) *cb.ConfigGroup {\n\tresult := cb.NewConfigGroup()\n\tresult.Groups[OrdererGroupKey] = cb.NewConfigGroup()\n\tresult.Groups[OrdererGroupKey].Values[key] = &cb.ConfigValue{\n\t\tValue: value,\n\t}\n\treturn result\n}\n\n\nfunc TemplateConsensusType(typeValue string) *cb.ConfigGroup {\n\treturn ordererConfigGroup(ConsensusTypeKey, utils.MarshalOrPanic(&ab.ConsensusType{Type: typeValue}))\n}\n\n\nfunc TemplateBatchSize(batchSize *ab.BatchSize) *cb.ConfigGroup {\n\treturn ordererConfigGroup(BatchSizeKey, utils.MarshalOrPanic(batchSize))\n}\n\n\nfunc TemplateBatchTimeout(batchTimeout string) *cb.ConfigGroup {\n\treturn ordererConfigGroup(BatchTimeoutKey, utils.MarshalOrPanic(&ab.BatchTimeout{Timeout: batchTimeout}))\n}\n\n\nfunc TemplateChannelRestrictions(maxChannels uint64) *cb.ConfigGroup {\n\treturn ordererConfigGroup(ChannelRestrictionsKey, utils.MarshalOrPanic(&ab.ChannelRestrictions{MaxCount: maxChannels}))\n}\n\n\n\n\nfunc TemplateKafkaBrokers(brokers []string) *cb.ConfigGroup ", "output": "{\n\treturn ordererConfigGroup(KafkaBrokersKey, utils.MarshalOrPanic(&ab.KafkaBrokers{Brokers: brokers}))\n}"}
{"input": "package gocode\n\nimport (\n\t\"go/build\"\n)\n\nvar bctx go_build_context\n\nfunc InitDaemon(bc *build.Context) {\n\tbctx = pack_build_context(bc)\n\tg_config.ProposeBuiltins = true\n\tg_daemon = new(daemon)\n\tg_daemon.drop_cache()\n}\n\nfunc SetBuildContext(bc *build.Context) {\n\tbctx = pack_build_context(bc)\n}\n\n\n\n\nvar (\n\tg_sock              *string\n\tg_addr              *string\n\tfals                = false\n\tg_debug             = &fals\n\tget_socket_filename func() string\n\tconfig_dir          func() string\n\tconfig_file         func() string\n)\n\n\ntype (\n\tRPC struct{}\n)\n\nfunc AutoComplete(file []byte, filename string, offset int) ([]candidate, int) ", "output": "{\n\treturn server_auto_complete(file, filename, offset, bctx)\n}"}
{"input": "package handler_frontend\n\nimport (\n\t\"git.vdo.space/berk/model\"\n\tdm \"git.vdo.space/foy/model\"\n\t\"git.vdo.space/foy/proto\"\n)\n\n\n\n\n\nfunc (m *FController) FeedbackList(req *proto.RequestParams) (*dm.ResultModel, error) {\n\n\trm := dm.ResultModel{}\n\n\tts, count, err := model.FindFeedbacksByParams(req, true)\n\n\tif err != nil {\n\n\n\t\trm.Errors = append(rm.Errors, dm.NewError(err))\n\t} else {\n\t\tpm := dm.PageModelBase{}\n\t\tpm.PageData = ts\n\t\tpm.Count = count\n\t\trm.Data = pm\n\t}\n\n\treturn &rm, nil\n}\n\nfunc (m *FController) FeedbacksCreate(ts []*model.Feedback) (*dm.ResultModel, error) ", "output": "{\n\n\trm := dm.ResultModel{}\n\n\tt, err := model.NewFeedbacks(ts)\n\n\tif err != nil {\n\t\trm.Errors = append(rm.Errors, dm.NewError(err))\n\t} else {\n\t\trm.Data = t\n\t}\n\n\treturn &rm, nil\n}"}
{"input": "package appdir\n\nimport (\n\t\"path/filepath\"\n)\n\nfunc general(app string) string {\n\treturn InHomeDir(filepath.Join(\"Library/Application Support\", app))\n}\n\n\n\nfunc logs(app string) string ", "output": "{\n\treturn InHomeDir(filepath.Join(\"Library/Logs\", app))\n}"}
{"input": "package protobuf\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\ntype t1 [32]byte\ntype t2 struct {\n\tX, Y t1\n\tSl   []bool\n\tT3   t3\n\tT3s  [3]t3\n}\ntype t3 struct {\n\tI int\n\tF float64\n\tB bool\n}\n\nfunc TestCrash1(t *testing.T) {\n\tin := []byte(\"*\\x00\")\n\n\tvar i uint32\n\terr := Decode(in, &i)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, err.Error(), \"not a struct\")\n\n\tvar s t2\n\terr = Decode(in, &s)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, \"Error while decoding field {Name:T3s PkgPath: Type:[3]protobuf.t3 Tag: Offset:112 Index:[4] Anonymous:false}: append to non-slice\", err.Error())\n}\n\n\n\nfunc TestCrash2(t *testing.T) ", "output": "{\n\tin := []byte(\"\\n\\x00\")\n\n\tvar s t2\n\terr := Decode(in, &s)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, \"Error while decoding field {Name:X PkgPath: Type:protobuf.t1 Tag: Offset:0 Index:[0] Anonymous:false}: array length and buffer length differ\", err.Error())\n}"}
{"input": "package gen\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\n\n\n\nfunc RemovePackage(code []byte) []byte {\n\trPackage, _ := regexp.Compile(\"package collection\")\n\tresult := rPackage.ReplaceAll(code, make([]byte, 0))\n\n\treturn result\n}\n\nfunc ReplaceGrizzlyId(code []byte, customType string) []byte {\n\tgICollections, _ := regexp.Compile(\"GrizzlyId\")\n\tresult := gICollections.ReplaceAll(code, []byte(strings.Title(customType)))\n\n\treturn result\n}\n\nfunc ReplaceImports(code []byte) []byte {\n\trICollections, _ := regexp.Compile(\"(import \\\"sort\\\")\")\n\tresult := rICollections.ReplaceAll(code, []byte(\"\"))\n\n\treturn result\n}\n\nfunc InjectImports(code []byte, imports []string) (result []byte) {\n\tresult = code[:]\n\n\tfor _, i := range imports {\n\t\tresult = append([]byte(\"\\nimport \\\"\"+i+\"\\\"\\n\"), code...)\n\t}\n\n\treturn result\n}\n\nfunc ReplaceSearchCallback(code []byte, modelName string) []byte ", "output": "{\n\trSearchCallback, _ := regexp.Compile(\"SearchCallback\")\n\tresult := rSearchCallback.ReplaceAll(code, []byte(\"SearchCallback\"+strings.Title(modelName)))\n\n\treturn result\n}"}
{"input": "package experiment\n\n\ntype Config struct {\n\tPercentage  int\n\tPublisher   Publisher\n\tConcurrency bool\n}\n\n\ntype Publisher interface {\n\tPublish(Observation)\n}\n\n\ntype ConfigFunc func(*Config)\n\n\nfunc WithPercentage(p int) ConfigFunc {\n\treturn func(c *Config) {\n\t\tc.Percentage = p\n\t}\n}\n\n\nfunc WithPublisher(p Publisher) ConfigFunc {\n\treturn func(c *Config) {\n\t\tc.Publisher = p\n\t}\n}\n\n\nfunc WithConcurrency() ConfigFunc {\n\treturn func(c *Config) {\n\t\tc.Concurrency = true\n\t}\n}\n\n\n\n\nfunc WithDefaultConfig() ConfigFunc ", "output": "{\n\treturn func(c *Config) {\n\t\tc.Percentage = 0\n\t\tc.Concurrency = false\n\t\tc.Publisher = nil\n\t}\n}"}
{"input": "package libinit\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/u-root/u-root/pkg/ulog\"\n\t\"github.com/vishvananda/netlink\"\n)\n\n\nfunc NetInit() {\n\tif err := loopbackUp(); err != nil {\n\t\tulog.KernelLog.Printf(\"Failed to initialize loopback: %v\", err)\n\t}\n}\n\n\n\nfunc loopbackUp() error ", "output": "{\n\tlo, err := netlink.LinkByName(\"lo\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := netlink.LinkSetUp(lo); err != nil {\n\t\treturn fmt.Errorf(\"couldn't set link loopback up: %v\", err)\n\t}\n\treturn nil\n}"}
{"input": "package chart\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\tassert \"github.com/blendlabs/go-assert\"\n)\n\nfunc TestSequenceFloat64(t *testing.T) {\n\tassert := assert.New(t)\n\n\tasc := Sequence.Float64(1.0, 10.0)\n\tassert.Len(asc, 10)\n\n\tdesc := Sequence.Float64(10.0, 1.0)\n\tassert.Len(desc, 10)\n}\n\n\n\nfunc TestSequenceMarketQuarters(t *testing.T) {\n\tassert := assert.New(t)\n\ttoday := time.Date(2016, 07, 01, 12, 0, 0, 0, Date.Eastern())\n\tmh := Sequence.MarketHourQuarters(today, today, NYSEOpen, NYSEClose, Date.IsNYSEHoliday)\n\tassert.Len(mh, 4)\n\tassert.Equal(9, mh[0].Hour())\n\tassert.Equal(30, mh[0].Minute())\n\tassert.Equal(Date.Eastern(), mh[0].Location())\n\n\tassert.Equal(12, mh[1].Hour())\n\tassert.Equal(00, mh[1].Minute())\n\tassert.Equal(Date.Eastern(), mh[1].Location())\n\n\tassert.Equal(14, mh[2].Hour())\n\tassert.Equal(00, mh[2].Minute())\n\tassert.Equal(Date.Eastern(), mh[2].Location())\n}\n\nfunc TestSequenceMarketHours(t *testing.T) ", "output": "{\n\tassert := assert.New(t)\n\n\ttoday := time.Date(2016, 07, 01, 12, 0, 0, 0, Date.Eastern())\n\tmh := Sequence.MarketHours(today, today, NYSEOpen, NYSEClose, Date.IsNYSEHoliday)\n\tassert.Len(mh, 8)\n\tassert.Equal(Date.Eastern(), mh[0].Location())\n}"}
{"input": "package matrix\n\n\nfunc IsZeros(m Matrix) bool {\n\treturn !m.NonZeros().HasNext()\n}\n\n\nfunc IsSquare(m Matrix) bool {\n\treturn m.Rows() == m.Columns()\n}\n\n\nfunc IsDiagonal(m Matrix) bool {\n\tmatch := func(element float64, row, column int) bool {\n\t\treturn row == column || element == 0\n\t}\n\n\treturn isSpecialDiagonal(m, match)\n}\n\n\nfunc IsIdentity(m Matrix) bool {\n\tmatch := func(element float64, row, column int) bool {\n\t\tif row == column {\n\t\t\treturn element == 1\n\t\t} else {\n\t\t\treturn element == 0\n\t\t}\n\t}\n\n\treturn isSpecialDiagonal(m, match)\n}\n\n\nfunc IsScalar(m Matrix) bool {\n\tscalar := m.Get(0, 0)\n\n\tmatch := func(element float64, row, column int) bool {\n\t\tif row == column {\n\t\t\treturn element == scalar\n\t\t} else {\n\t\t\treturn element == 0\n\t\t}\n\t}\n\n\treturn isSpecialDiagonal(m, match)\n}\n\n\ntype matchFunc func(element float64, row, column int) bool\n\n\n\n\nfunc isSpecialDiagonal(m Matrix, match matchFunc) bool ", "output": "{\n\tif !IsSquare(m) {\n\t\treturn false\n\t}\n\n\telements := m.All()\n\n\tfor elements.HasNext() {\n\t\telement, row, column := elements.Get()\n\t\tif !match(element, row, column) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}"}
{"input": "package rule\n\ntype InvalidRuleError struct {\n\tRule Rule\n}\n\ntype IncompatibleTypesRuleError struct {\n\tRule Rule\n}\n\ntype InvalidExprError struct {\n\tExpr string\n}\n\nfunc (e InvalidRuleError) Error() string {\n\treturn \"invalid rule: \" + e.Rule.String()\n}\n\nfunc (e IncompatibleTypesRuleError) Error() string {\n\treturn \"incompatible types in rule: \" + e.Rule.String()\n}\n\n\n\ntype InvalidRuleFieldError string\n\nfunc (e InvalidRuleFieldError) Error() string {\n\treturn \"invalid rule field: \" + string(e)\n}\n\nfunc (e InvalidExprError) Error() string ", "output": "{\n\treturn \"invalid expression in rule: \" + e.Expr\n}"}
{"input": "package design\n\n\n\n\n\n\n\nimport (\n\t\"fmt\"\n)\n\ntype PhoneBrand interface {\n\tSetSoft(s Soft)\n\tRun()\n}\ntype Soft interface {\n\tRun()\n}\ntype Nokia struct {\n\ts Soft\n}\n\n\nfunc (n Nokia) Run() {\n\tfmt.Println(\"nokia\")\n\tn.s.Run()\n}\n\ntype Game struct {\n}\n\nfunc (g Game) Run() {\n\tfmt.Println(\"手机游戏\")\n}\n\nfunc (n *Nokia) SetSoft(s Soft) ", "output": "{\n\tn.s = s\n}"}
{"input": "package server\n\nimport (\n\t\"math/rand\"\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n\tlog \"github.com/macarrie/flemzerd/logging\"\n\t\"github.com/macarrie/flemzerd/notifiers\"\n\t\"github.com/macarrie/flemzerd/notifiers/impl/telegram\"\n)\n\nfunc performTelegramAuth(c *gin.Context) {\n\tn, err := notifier.GetNotifier(\"telegram\")\n\tif err != nil || n == nil {\n\t\tlog.Error(\"TELEGRAM NOTIFIER NOT FOUND\")\n\t\tc.JSON(http.StatusNotFound, err)\n\t\treturn\n\t}\n\n\tt := n.(*telegram.TelegramNotifier)\n\tif t.ChatID != 0 {\n\t\tlog.Error(\"CHAT ID NOT ZERO. EXIT STATUS NO CONTENT\")\n\t\tc.AbortWithStatus(http.StatusNoContent)\n\t\treturn\n\t}\n\n\tgo t.Auth()\n\tc.JSON(http.StatusOK, gin.H{})\n\treturn\n}\n\n\n\nfunc getTelegramAuthCode(c *gin.Context) {\n\tn, err := notifier.GetNotifier(\"telegram\")\n\tif err != nil || n == nil {\n\t\tc.JSON(http.StatusNotFound, err)\n\t\treturn\n\t}\n\n\tt := n.(*telegram.TelegramNotifier)\n\tif t.AuthCode == 0 {\n\t\tt.AuthCode = rand.Intn(1000000)\n\t}\n\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"auth_code\": t.AuthCode,\n\t})\n}\n\nfunc getTelegramChatID(c *gin.Context) ", "output": "{\n\tn, err := notifier.GetNotifier(\"telegram\")\n\tif err != nil || n == nil {\n\t\tc.JSON(http.StatusNotFound, err)\n\t\treturn\n\t}\n\n\tt := n.(*telegram.TelegramNotifier)\n\tvar chatID int64\n\tif t != nil {\n\t\tchatID = t.ChatID\n\t} else {\n\t\tchatID = 0\n\t}\n\tc.JSON(http.StatusOK, gin.H{\n\t\t\"chat_id\": chatID,\n\t})\n}"}
{"input": "package standarddeck\n\nimport (\n\t\"github.com/stensonb/playingcards/deck\"\n\t\"math/rand\"\n\t\"testing\"\n)\n\nconst standardDeckSize = 52\n\nfunc TestSize(t *testing.T) {\n\td := New()\n\tif d.Size() != standardDeckSize { \n\t\tt.Error(\"standard deck has wrong number of cards\")\n\t}\n\n}\n\n\n\nfunc TestCardsLeft(t *testing.T) {\n\tvar matrix = map[int]int{0: standardDeckSize,\n\t\tint(standardDeckSize / 2): int(standardDeckSize / 2),\n\t\tstandardDeckSize:          0,\n\t\tstandardDeckSize + 1:      0}\n\n\tfor k, v := range matrix {\n\t\td := New()\n\n\t\tfor i := 0; i < k; i++ {\n\t\t\td.NextCard()\n\t\t}\n\n\t\tactual := d.CardsLeft()\n\n\t\tif actual != v {\n\t\t\tt.Error(\"wrong number of cards left.  should be\", v, \", but received\", actual)\n\t\t}\n\t}\n\n}\n\n\n\n\nfunc TestShuffle(t *testing.T) {\n\n\td0 := New()\n\td1 := New()\n\n\td0.Shuffle(rand.New(rand.NewSource(1))) \n\n\tidentical := true\n\tfor i := 0; identical && i < d0.Size(); i++ {\n\t\tc0, _ := d0.NextCard()\n\t\tc1, _ := d1.NextCard()\n\t\tif !c0.Equals(c1) {\n\t\t\tidentical = false\n\t\t}\n\t}\n\n\tif identical {\n\t\tt.Error(\"decks are identical, even after shuffling...\")\n\t}\n}\n\nfunc TestNextCard(t *testing.T) ", "output": "{\n\td := New()\n\n\tfor i := 0; i < d.Size(); i++ {\n\t\t_, err := d.NextCard()\n\t\tif err != nil {\n\t\t\tt.Error(\"failed to get NextCard()\")\n\t\t}\n\t}\n\n\tdesiredError := deck.EmptyDeck{}\n\n\t_, err := d.NextCard()\n\tif err.Error() != desiredError.Error() {\n\t\tt.Error(\"wrong error (or nil) when the deck is empty\")\n\t}\n\n}"}
{"input": "package zap\n\n\n\ntype ZapPlugin struct{}\n\n\n\nfunc (*ZapPlugin) Version() uint32 {\n\treturn Version\n}\n\nfunc (*ZapPlugin) Type() string ", "output": "{\n\treturn Type\n}"}
{"input": "package model\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/mholt/binding\"\n)\n\n\ntype Assignment struct {\n\tID       string    `gorethink:\"id,omitempty\" json:\"id\"`\n\tName     string    `gorethink:\"name,omitempty\" json:\"name\"`\n\tClassID  string    `gorethink:\"classId,omitempty\" json:\"classId\"`\n\tTermID   string    `gorethink:\"termId,omitempty\" json:\"termId\"`\n\tGroupID  string    `gorethink:\"groupId,omitempty\" json:\"groupId\"`\n\tMaxScore int16     `gorethink:\"maxScore,omitempty\" json:\"maxScore\"`\n\tDueDate  time.Time `gorethink:\"dueDate,omitempty\" json:\"dueDate\"`\n\tTimeStamp\n}\n\n\nfunc (a *Assignment) FieldMap(req *http.Request) binding.FieldMap {\n\treturn binding.FieldMap{\n\t\t&a.ID:       \"id\",\n\t\t&a.Name:     \"name\",\n\t\t&a.GroupID:  \"groupId\",\n\t\t&a.ClassID:  \"classId\",\n\t\t&a.MaxScore: \"maxScore\",\n\t\t&a.TermID:   \"termId\",\n\t\t&a.DueDate:  \"dueDate\",\n\t}\n}\n\ntype AssignmentAPIRes struct {\n\tAssignment\n\tGroup AssignmentGroup `gorethink:\"group,omitempty\" json:\"group\"`\n}\n\n\n\nfunc (a Assignment) Validate(req *http.Request, errs binding.Errors) binding.Errors ", "output": "{\n\tif a.Name == \"\" {\n\t\terrs = append(errs, RequiredErr(\"name\"))\n\t}\n\tif a.ClassID == \"\" {\n\t\terrs = append(errs, RequiredErr(\"classId\"))\n\t}\n\tif a.TermID == \"\" {\n\t\terrs = append(errs, RequiredErr(\"termId\"))\n\t}\n\tif a.GroupID == \"\" {\n\t\terrs = append(errs, RequiredErr(\"groupId\"))\n\t}\n\tif a.MaxScore <= 0 {\n\t\terrs = append(errs, RequiredErr(\"maxScore\"))\n\t}\n\treturn errs\n}"}
{"input": "package text\n\nimport (\n\t\"strings\"\n)\n\n\n\n\nfunc Squash(str string) string ", "output": "{\n\treturn strings.Join(strings.Fields(str), \" \")\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n)\n\n\ntype Prototype interface {\n\tClone()\n}\n\ntype ConcretePrototype struct {\n\tname string\n}\n\n\n\nfunc (p *ConcretePrototype) String() string {\n\treturn \"ConcretePrototype [name=\" + p.name + \"]\"\n}\n\nfunc main() {\n\tprototype := &ConcretePrototype{\"prototype1\"}\n\tfmt.Println(prototype)\n\tfmt.Println(prototype.Clone())\n}\n\nfunc (p *ConcretePrototype) Clone() *ConcretePrototype ", "output": "{\n\treturn &ConcretePrototype{p.name}\n}"}
{"input": "package utils\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n)\n\n\n\nfunc GenUUID() (string, error) ", "output": "{\n\tuuid := make([]byte, 16)\n\tn, err := rand.Read(uuid)\n\tif n != len(uuid) || err != nil {\n\t\treturn \"\", err\n\t}\n\tuuid[8] = 0x80 \n\tuuid[4] = 0x40 \n\n\treturn hex.EncodeToString(uuid), nil\n}"}
{"input": "package websocket\n\ntype data struct {\n\tIndex int\n\tBody  []byte\n\tError error\n}\n\nfunc makeHeader(index int) (header [4]byte) {\n\theader[0] = byte(index >> 24 & 0xff)\n\theader[1] = byte(index >> 16 & 0xff)\n\theader[2] = byte(index >> 8 & 0xff)\n\theader[3] = byte(index & 0xff)\n\treturn\n}\n\n\n\nfunc parseHeader(header []byte) (index int, ok bool) ", "output": "{\n\tindex = int(header[0])<<24 | int(header[1])<<16 | int(header[2])<<8 | int(header[3])\n\tif ok = (header[0]&0x80 == 0); !ok {\n\t\tindex &= 0x7fffffff\n\t}\n\treturn\n}"}
{"input": "package scanner\n\nimport (\n\t\"github.com/carlcui/expressive/locator\"\n\t\"github.com/carlcui/expressive/token\"\n)\n\ntype MockScanner struct {\n\ttoks []*token.Token\n\tpos  int\n}\n\n\n\nfunc (scanner *MockScanner) Next() *token.Token {\n\tif scanner.pos >= len(scanner.toks) {\n\t\treturn token.IllegalToken(\"\", locator.CreateIndexLocation(scanner.pos))\n\t}\n\n\tcur := scanner.toks[scanner.pos]\n\tcur.Locator = &locator.IndexLocation{Index: scanner.pos}\n\n\tscanner.pos++\n\n\treturn cur\n}\n\nfunc (scanner *MockScanner) Init(toks []*token.Token) ", "output": "{\n\tscanner.toks = toks\n\tscanner.pos = 0\n}"}
{"input": "package posix\n\nimport (\n\t\"io/ioutil\"\n\t\"os/exec\"\n)\n\n\n\n\n\n\nfunc Shell(shellStdin string) (stdout, stderr string, err error) {\n\treturn Exec(\"sh\", \"\", shellStdin)\n}\n\n\nfunc RemoteShell(remoteHost, remoteShellStdin string) (stdout, stderr string, err error) {\n\treturn Exec(\"ssh\", \"\", remoteShellStdin, remoteHost, \"sh -il\")\n}\n\n\nfunc DownloadDir(remoteHost, remoteDir, sourceDir string) error {\n\t_, _, err := Exec(\"rsync\", \"\", \"\", \"-acrv\", \"--rsh=ssh\", remoteHost+\":\"+remoteDir+\"/\", sourceDir+\"/\")\n\treturn err\n}\n\n\n\nfunc UploadDir(remoteHost, sourceDir, remoteDir string) error {\n\t_, _, err := Exec(\"rsync\", \"\", \"\", \"-acrv\", \"--rsh=ssh\", sourceDir+\"/\", remoteHost+\":\"+remoteDir+\"/\")\n\treturn err\n}\n\nfunc Exec(prog, dir string, stdin string, argv ...string) (stdout, stderr string, err error) ", "output": "{\n\tcmd := exec.Command(prog, argv...)\n\tcmd.Dir = dir\n\n\tstdinWriter, err := cmd.StdinPipe()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tstdoutReader, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tstderrReader, err := cmd.StderrPipe()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tif err := cmd.Start(); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\t_, err = stdinWriter.Write([]byte(stdin))\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\terr = stdinWriter.Close()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tstdoutBuf, _ := ioutil.ReadAll(stdoutReader)\n\tstderrBuf, _ := ioutil.ReadAll(stderrReader)\n\n\treturn string(stdoutBuf), string(stderrBuf), cmd.Wait()\n}"}
{"input": "package graph\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"bldy.build/build/racy\"\n)\n\n\n\n\n\ntype ByName []*Node\n\nfunc (a ByName) Len() int      { return len(a) }\nfunc (a ByName) Swap(i, j int) { a[i], a[j] = a[j], a[i] }\nfunc (a ByName) Less(i, j int) bool {\n\treturn strings.Compare(a[i].Target.Name(), a[j].Target.Name()) > 0\n}\n\nfunc (n *Node) HashNode() []byte ", "output": "{\n\tif len(n.hash) > 0 {\n\t\treturn n.hash\n\t}\n\tn.hash = n.Target.Hash()\n\tvar bn ByName\n\tfor _, e := range n.Children {\n\t\tbn = append(bn, e)\n\t}\n\tsort.Sort(bn)\n\tfor _, e := range bn {\n\t\tn.hash = racy.XOR(e.HashNode(), n.hash)\n\t}\n\tn.Hash = fmt.Sprintf(\"%x\", n.hash)\n\treturn n.hash\n}"}
{"input": "package jobs\n\nimport (\n\t\"sync\"\n\n\t\"github.com/sirupsen/logrus\"\n\n\t\"go.mikenewswanger.com/kube-ci/kube-ci/jobs/notifiers\"\n)\n\n\ntype Step struct {\n\tName          string              `json:\"name\"`\n\tEventHandlers map[string]string   `json:\"event_handlers\"`\n\tNotifiers     []notifiers.Trigger `json:\"notifiers\"`\n\tTasks         []Task              `json:\"tasks\"`\n}\n\n\n\n\nfunc (s *Step) Execute(labels map[string]string) error ", "output": "{\n\tfields := logrus.Fields{\n\t\t\"step_name\": s.Name,\n\t}\n\n\tlogrus.WithFields(fields).Info(\"Starting Step\")\n\tvar wg = &sync.WaitGroup{}\n\tfor _, t := range s.Tasks {\n\t\twg.Add(1)\n\t\tgo func(t Task, wg *sync.WaitGroup) {\n\t\t\tt.Run(labels)\n\t\t\twg.Done()\n\t\t}(t, wg)\n\t}\n\twg.Wait()\n\tlogrus.WithFields(fields).Info(\"Step complete\")\n\treturn nil\n}"}
{"input": "package common\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/coreos/rkt/Godeps/_workspace/src/github.com/appc/spec/schema\"\n\t\"github.com/coreos/rkt/Godeps/_workspace/src/github.com/appc/spec/schema/types\"\n)\n\n\n\n\n\n\nfunc IsMountReadOnly(vol types.Volume, mountPoints []types.MountPoint) bool {\n\tif vol.ReadOnly != nil {\n\t\treturn *vol.ReadOnly\n\t}\n\n\treturn isMPReadOnly(mountPoints, vol.Name)\n}\n\n\nfunc GenerateMounts(ra *schema.RuntimeApp, volumes map[types.ACName]types.Volume) []schema.Mount {\n\tapp := ra.App\n\n\tmnts := make(map[string]schema.Mount)\n\tfor _, m := range ra.Mounts {\n\t\tmnts[m.Path] = m\n\t}\n\n\tfor _, mp := range app.MountPoints {\n\t\tif _, ok := mnts[mp.Path]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tvol, ok := volumes[mp.Name]\n\t\tif !ok {\n\t\t\temptyVol := types.Volume{\n\t\t\t\tName: mp.Name,\n\t\t\t\tKind: \"empty\",\n\t\t\t}\n\n\t\t\tfmt.Fprintf(os.Stderr, \"rkt: warning: no volume specified for mount point %q, implicitly creating an \\\"empty\\\" volume. This volume will be removed when the pod is garbage-collected.\\n\", mp.Name)\n\n\t\t\tvolumes[mp.Name] = emptyVol\n\t\t\tra.Mounts = append(ra.Mounts, schema.Mount{Volume: mp.Name, Path: mp.Path})\n\t\t} else {\n\t\t\tra.Mounts = append(ra.Mounts, schema.Mount{Volume: vol.Name, Path: mp.Path})\n\t\t}\n\t}\n\n\treturn ra.Mounts\n}\n\nfunc isMPReadOnly(mountPoints []types.MountPoint, name types.ACName) bool ", "output": "{\n\tfor _, mp := range mountPoints {\n\t\tif mp.Name == name {\n\t\t\treturn mp.ReadOnly\n\t\t}\n\t}\n\n\treturn false\n}"}
{"input": "package dockerpre012\n\nimport (\n\t\"k8s.io/kubernetes/pkg/api\"\n)\n\n\n\nfunc (*DockerImage) IsAnAPIObject() {}\n\nfunc init() ", "output": "{\n\tapi.Scheme.AddKnownTypes(\"pre012\",\n\t\t&DockerImage{},\n\t)\n}"}
{"input": "package coverageanalysis\n\ntype LineCoverage struct {\n\tHits   float64\n\tIgnore bool\n}\n\ntype FileReport struct {\n\tName               string\n\tFileDigest         string\n\tFileSource         string\n\tLineCoverages      []LineCoverage\n\tCoveragePercentage float64\n}\n\ntype CoverageReport struct {\n\tFileReports        []FileReport\n\tCoveragePercentage float64\n}\n\nfunc BuildCoverageReport(jsonObject map[string]interface{}) *CoverageReport {\n\treport := &CoverageReport{}\n\tsourceFiles := jsonObject[\"source_files\"].([]interface{})\n\tfor i := range sourceFiles {\n\t\tfileReport := BuildFileReport(sourceFiles[i].(map[string]interface{}))\n\t\treport.FileReports = append(report.FileReports, *fileReport)\n\t}\n\treturn report\n}\n\nfunc BuildFileReport(jsonObject map[string]interface{}) *FileReport {\n\treport := &FileReport{}\n\treport.Name = jsonObject[\"name\"].(string)\n\treport.FileDigest = jsonObject[\"source_digest\"].(string)\n\treport.FileSource = jsonObject[\"source\"].(string)\n\treport.LineCoverages = BuildAllLineCoverages(jsonObject[\"coverage\"].([]interface{}))\n\treturn report\n}\n\nfunc BuildAllLineCoverages(coverages []interface{}) []LineCoverage {\n\treport := []LineCoverage{}\n\tfor i := range coverages {\n\t\tc := BuildLineCoverage(coverages[i])\n\t\treport = append(report, *c)\n\t}\n\treturn report\n}\n\n\n\nfunc BuildLineCoverage(c interface{}) *LineCoverage ", "output": "{\n\tswitch c.(type) {\n\tcase float64:\n\t\treturn &LineCoverage{Ignore: false, Hits: c.(float64)}\n\tcase nil:\n\t\treturn &LineCoverage{Ignore: true, Hits: 0}\n\tdefault:\n\t\treturn &LineCoverage{Ignore: false, Hits: 0}\n\t}\n}"}
{"input": "package schema\n\n\n\n\nimport (\n\t\"net/http\"\n\n\tmiddleware \"github.com/go-openapi/runtime/middleware\"\n\n\tmodels \"github.com/semi-technologies/weaviate/entities/models\"\n)\n\n\ntype SchemaThingsPropertiesDeleteHandlerFunc func(SchemaThingsPropertiesDeleteParams, *models.Principal) middleware.Responder\n\n\nfunc (fn SchemaThingsPropertiesDeleteHandlerFunc) Handle(params SchemaThingsPropertiesDeleteParams, principal *models.Principal) middleware.Responder {\n\treturn fn(params, principal)\n}\n\n\ntype SchemaThingsPropertiesDeleteHandler interface {\n\tHandle(SchemaThingsPropertiesDeleteParams, *models.Principal) middleware.Responder\n}\n\n\nfunc NewSchemaThingsPropertiesDelete(ctx *middleware.Context, handler SchemaThingsPropertiesDeleteHandler) *SchemaThingsPropertiesDelete {\n\treturn &SchemaThingsPropertiesDelete{Context: ctx, Handler: handler}\n}\n\n\ntype SchemaThingsPropertiesDelete struct {\n\tContext *middleware.Context\n\tHandler SchemaThingsPropertiesDeleteHandler\n}\n\n\n\nfunc (o *SchemaThingsPropertiesDelete) ServeHTTP(rw http.ResponseWriter, r *http.Request) ", "output": "{\n\troute, rCtx, _ := o.Context.RouteInfo(r)\n\tif rCtx != nil {\n\t\tr = rCtx\n\t}\n\tvar Params = NewSchemaThingsPropertiesDeleteParams()\n\n\tuprinc, aCtx, err := o.Context.Authorize(r, route)\n\tif err != nil {\n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\tif aCtx != nil {\n\t\tr = aCtx\n\t}\n\tvar principal *models.Principal\n\tif uprinc != nil {\n\t\tprincipal = uprinc.(*models.Principal) \n\t}\n\n\tif err := o.Context.BindValidRequest(r, route, &Params); err != nil { \n\t\to.Context.Respond(rw, r, route.Produces, route, err)\n\t\treturn\n\t}\n\n\tres := o.Handler.Handle(Params, principal) \n\n\to.Context.Respond(rw, r, route.Produces, route, res)\n\n}"}
{"input": "package spaces\n\nimport (\n\t\"github.com/trasa/watchmud-message/direction\"\n\t\"sort\"\n)\n\n\ntype RoomExit struct {\n\tDirection direction.Direction\n\tRoom      *Room\n}\n\ntype roomExitHolder struct {\n\tdirs []RoomExit\n}\n\n\nfunc (re roomExitHolder) Len() int           { return len(re.dirs) }\n\nfunc (re roomExitHolder) Swap(i, j int)      { re.dirs[i], re.dirs[j] = re.dirs[j], re.dirs[i] }\n\n\n\n\nfunc (r *Room) GetRoomExits(limitToZone bool) []RoomExit {\n\tholder := roomExitHolder{}\n\tfor dir, dest := range r.directions {\n\t\tif !limitToZone || r.Zone == dest.Zone {\n\t\t\tholder.dirs = append(holder.dirs, RoomExit{dir, dest})\n\t\t}\n\t}\n\tsort.Sort(holder)\n\treturn holder.dirs\n}\n\nfunc (re roomExitHolder) Less(i, j int) bool ", "output": "{ return re.dirs[i].Direction < re.dirs[j].Direction }"}
{"input": "package Plugin\n\nimport \"github.com/MPjct/GoMP/MySQLProtocol\"\n\ntype Plugin_interface interface {\n\tinit(context MySQLProtocol.Context)\n\tread_handshake(context MySQLProtocol.Context)\n\tsend_handshake(context MySQLProtocol.Context)\n\tread_auth(context MySQLProtocol.Context)\n\tsend_auth(context MySQLProtocol.Context)\n\tread_auth_result(context MySQLProtocol.Context)\n\tsend_auth_result(context MySQLProtocol.Context)\n\tread_query(context MySQLProtocol.Context)\n\tsend_query(context MySQLProtocol.Context)\n\tread_query_result(context MySQLProtocol.Context)\n\tsend_query_result(context MySQLProtocol.Context)\n\tcleanup(context MySQLProtocol.Context)\n}\n\ntype Plugin struct {\n}\n\nfunc (plugin *Plugin) init(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) read_handshake(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) send_handshake(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) read_auth(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) send_auth(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) read_auth_result(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) send_auth_result(context MySQLProtocol.Context) {\n\treturn\n}\n\n\n\nfunc (plugin *Plugin) send_query(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) read_query_result(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) send_query_result(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) cleanup(context MySQLProtocol.Context) {\n\treturn\n}\n\nfunc (plugin *Plugin) read_query(context MySQLProtocol.Context) ", "output": "{\n\treturn\n}"}
{"input": "package handlers\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/byuoitav/device-monitoring/actions/gpio\"\n\t\"github.com/labstack/echo\"\n)\n\n\nfunc GetDividerState(ctx echo.Context) error {\n\tv := gpio.GetPins()\n\n\tresp := make(map[string][]string)\n\tfor i := range v {\n\t\tif v[i].Connected {\n\t\t\tresp[\"connected\"] = append(resp[\"connected\"], v[i].BlueberryPresets)\n\t\t} else {\n\t\t\tresp[\"disconnected\"] = append(resp[\"disconnected\"], v[i].BlueberryPresets)\n\t\t}\n\t}\n\n\treturn ctx.JSON(http.StatusOK, resp)\n}\n\n\n\n\nfunc PresetForHostname(ctx echo.Context) error ", "output": "{\n\thostname := ctx.Param(\"hostname\")\n\n\tv := gpio.GetPins()\n\n\tif len(v) == 0 || len(v) > 1 {\n\t\treturn ctx.String(http.StatusBadRequest, fmt.Sprintf(\"not supported in this room\"))\n\t}\n\n\treturn ctx.String(http.StatusOK, v[0].CurrentPreset(hostname))\n}"}
{"input": "package finance\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/shopspring/decimal\"\n)\n\n\nfunc toInt(value string) int {\n\ti, _ := strconv.Atoi(value)\n\treturn i\n}\n\n\nfunc toDecimal(value string) (d decimal.Decimal) {\n\n\tvalue = strings.Replace(value, \"%\", \"\", -1)\n\td, _ = decimal.NewFromString(value)\n\treturn\n}\n\nfunc toEventValue(value string) Value {\n\n\tif strings.Contains(value, \"/\") {\n\t\treturn Value{\n\t\t\tRatio: value,\n\t\t}\n\t}\n\treturn Value{\n\t\tDividend: toDecimal(value),\n\t}\n}\n\n\nfunc parseDashedDate(s string) (d time.Time, err error) {\n\n\tif !strings.ContainsAny(s, \"0123456789\") {\n\t\treturn\n\t}\n\n\td, err = time.Parse(\"2006-01-02\", s)\n\tif err != nil {\n\t\ts = parseMalformedDate(s)\n\t\td, err = time.Parse(\"2006-01-02\", s)\n\t\tif err != nil {\n\t\t\treturn time.Time{}, err\n\t\t}\n\t}\n\treturn\n}\n\nfunc parseMalformedDate(s string) string {\n\n\tif len(s) < 7 {\n\t\treturn s\n\t}\n\n\tchars := strings.Split(s, \"\")\n\tchars = chars[1:]\n\tchars = insert(chars, 4, \"-\")\n\tchars = insert(chars, 7, \"-\")\n\treturn strings.Join(chars[:], \"\")\n}\n\n\n\nfunc insert(s []string, i int, x string) []string ", "output": "{\n\n\ts = append(s, \"\")\n\tcopy(s[i+1:], s[i:])\n\ts[i] = x\n\treturn s\n}"}
{"input": "package thrift\n\nimport (\n\t\"net\"\n)\n\n\ntype socketConn struct {\n\tnet.Conn\n\n\tbuffer [1]byte\n}\n\nvar _ net.Conn = (*socketConn)(nil)\n\n\n\n\n\n\nfunc wrapSocketConn(conn net.Conn) *socketConn {\n\tif sc, ok := conn.(*socketConn); ok {\n\t\treturn sc\n\t}\n\n\treturn &socketConn{\n\t\tConn: conn,\n\t}\n}\n\n\n\n\n\n\n\n\nfunc (sc *socketConn) isValid() bool {\n\treturn sc != nil && sc.Conn != nil\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc (sc *socketConn) IsOpen() bool {\n\tif !sc.isValid() {\n\t\treturn false\n\t}\n\treturn sc.checkConn() == nil\n}\n\n\n\n\n\n\n\n\n\n\nfunc (sc *socketConn) Read(p []byte) (n int, err error) {\n\tif len(p) == 0 {\n\t\treturn 0, sc.read0()\n\t}\n\n\treturn sc.Conn.Read(p)\n}\n\nfunc createSocketConnFromReturn(conn net.Conn, err error) (*socketConn, error) ", "output": "{\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &socketConn{\n\t\tConn: conn,\n\t}, nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/unrolled/render\"\n)\n\n\nvar Render *render.Render\n\n\n\n\nfunc index(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Welcome to the home page!\")\n}\n\nfunc apiHandler(w http.ResponseWriter, r *http.Request) {\n\tRender.JSON(w, http.StatusOK, \"Welcome to the api hander page!\")\n}\n\nfunc apiKeyHandler(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\tfmt.Fprintf(w, \"Welcome to the api Key hander page! %s\", id)\n}\n\nfunc apiKeyDetailsHandler(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\tfmt.Fprintf(w, \"Welcome to the api Key Details hander page! %s\", id)\n}\n\nfunc webKeyHandler(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\tfmt.Fprintf(w, \"Welcome to the web Key hander page! %s\", id)\n}\n\nfunc notFound(w http.ResponseWriter, r *http.Request) {\n\thttp.Redirect(w, r, \"/\", http.StatusTemporaryRedirect)\n}\n\nfunc init() ", "output": "{\n\tRender = render.New(render.Options{\n\t\tIndentJSON: true,\n\t})\n}"}
{"input": "package main\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n\t\"text/template\"\n\n\t\"github.com/kyokomi/emoji\"\n)\n\nfunc getTitle(html []byte) string {\n\tr := regexp.MustCompile(\"<h1>(.*)</h1>\")\n\treturn strings.Replace(r.FindStringSubmatch(string(html))[1], \" \", \"\", -1)\n}\n\n\n\nfunc getCanvasMap(html []byte) map[string]string {\n\tr := regexp.MustCompile(\"<h1>(\\\\w|\\\\s)*</h1>\")\n\tindex := r.FindAllIndex(html, -1)\n\n\tm := map[string]string{}\n\tfor i := 0; i < len(index); i++ {\n\t\tif i == (len(index) - 1) {\n\t\t\tm[getTitle(html[index[i][0]:])] = getContent(html[index[i][0]:])\n\t\t} else {\n\t\t\tm[getTitle(html[index[i][0]:index[i+1][0]])] = getContent(html[index[i][0]:index[i+1][0]])\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc getParsedTemplate() *template.Template {\n\ttpl := template.New(\"\")\n\ttpl = template.Must(tpl.Parse(TEMPLATE_CANVAS))\n\ttpl = template.Must(tpl.Parse(TEMPLATE_SANITIZE))\n\ttpl = template.Must(tpl.Parse(TEMPLATE_STYLE_CANVAS))\n\ttpl = template.Must(tpl.Parse(TEMPLATE_STYLE_MARKDOWN))\n\treturn tpl\n}\n\nfunc emojify(html []byte) []byte {\n\treturn []byte(emoji.Sprint(string(html)))\n}\n\nfunc getContent(html []byte) string ", "output": "{\n\tr := regexp.MustCompile(\"<h1>(.*)</h1>\")\n\treturn strings.TrimSpace(r.ReplaceAllString(string(html), \"\"))\n}"}
{"input": "package overview\n\nimport (\n\t\"appengine\"\n\n\th \"github.com/czertbytes/pocket/pkg/http\"\n\tt \"github.com/czertbytes/pocket/pkg/types\"\n)\n\ntype Notificator struct {\n\tAppEngineContext appengine.Context\n\tRequestContext   *h.RequestContext\n}\n\nfunc NewNotificator(RequestContext *h.RequestContext) *Notificator {\n\treturn &Notificator{\n\t\tAppEngineContext: RequestContext.AppEngineContext,\n\t\tRequestContext:   RequestContext,\n\t}\n}\n\nfunc (self *Notificator) Create(overview *t.Overview) error {\n\treturn nil\n}\n\n\n\nfunc (self *Notificator) CreatePayment(payment *t.Payment) error {\n\treturn nil\n}\n\nfunc (self *Notificator) CreateParticipant(participant *t.User) error {\n\treturn nil\n}\n\nfunc (self *Notificator) Update(overview *t.Overview) error ", "output": "{\n\treturn nil\n}"}
{"input": "package user\n\n\n\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n\tgolangswaggerpaths \"path\"\n)\n\n\ntype CreateUsersWithListInputURL struct {\n\t_basePath string\n}\n\n\n\n\nfunc (o *CreateUsersWithListInputURL) WithBasePath(bp string) *CreateUsersWithListInputURL {\n\to.SetBasePath(bp)\n\treturn o\n}\n\n\n\n\nfunc (o *CreateUsersWithListInputURL) SetBasePath(bp string) {\n\to._basePath = bp\n}\n\n\nfunc (o *CreateUsersWithListInputURL) Build() (*url.URL, error) {\n\tvar _result url.URL\n\n\tvar _path = \"/users/createWithList\"\n\n\t_basePath := o._basePath\n\tif _basePath == \"\" {\n\t\t_basePath = \"/v2\"\n\t}\n\t_result.Path = golangswaggerpaths.Join(_basePath, _path)\n\n\treturn &_result, nil\n}\n\n\nfunc (o *CreateUsersWithListInputURL) Must(u *url.URL, err error) *url.URL {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif u == nil {\n\t\tpanic(\"url can't be nil\")\n\t}\n\treturn u\n}\n\n\nfunc (o *CreateUsersWithListInputURL) String() string {\n\treturn o.Must(o.Build()).String()\n}\n\n\n\n\n\nfunc (o *CreateUsersWithListInputURL) StringFull(scheme, host string) string {\n\treturn o.Must(o.BuildFull(scheme, host)).String()\n}\n\nfunc (o *CreateUsersWithListInputURL) BuildFull(scheme, host string) (*url.URL, error) ", "output": "{\n\tif scheme == \"\" {\n\t\treturn nil, errors.New(\"scheme is required for a full url on CreateUsersWithListInputURL\")\n\t}\n\tif host == \"\" {\n\t\treturn nil, errors.New(\"host is required for a full url on CreateUsersWithListInputURL\")\n\t}\n\n\tbase, err := o.Build()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbase.Scheme = scheme\n\tbase.Host = host\n\treturn base, nil\n}"}
{"input": "package network\n\n\n\n\nimport (\n\t\"k8s.io/kubernetes/pkg/api\"\n\tclient \"k8s.io/kubernetes/pkg/client/unversioned\"\n)\n\ntype fakeNetworkHost struct {\n\tkubeClient client.Interface\n}\n\nfunc NewFakeHost(kubeClient client.Interface) *fakeNetworkHost {\n\thost := &fakeNetworkHost{kubeClient: kubeClient}\n\treturn host\n}\n\n\n\nfunc (fnh *fakeNetworkHost) GetKubeClient() client.Interface {\n\treturn nil\n}\n\nfunc (fnh *fakeNetworkHost) GetPodByName(name, namespace string) (*api.Pod, bool) ", "output": "{\n\treturn nil, false\n}"}
{"input": "package kv_test\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/influxdata/influxdb\"\n\t\"github.com/influxdata/influxdb/kv\"\n\tinfluxdbtesting \"github.com/influxdata/influxdb/testing\"\n)\n\nfunc TestBoltOrganizationService(t *testing.T) {\n\tinfluxdbtesting.OrganizationService(initBoltOrganizationService, t)\n}\n\nfunc TestInmemOrganizationService(t *testing.T) {\n\tinfluxdbtesting.OrganizationService(initInmemOrganizationService, t)\n}\n\nfunc initBoltOrganizationService(f influxdbtesting.OrganizationFields, t *testing.T) (influxdb.OrganizationService, string, func()) {\n\ts, closeBolt, err := NewTestBoltStore()\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create new kv store: %v\", err)\n\t}\n\n\tsvc, op, closeSvc := initOrganizationService(s, f, t)\n\treturn svc, op, func() {\n\t\tcloseSvc()\n\t\tcloseBolt()\n\t}\n}\n\nfunc initInmemOrganizationService(f influxdbtesting.OrganizationFields, t *testing.T) (influxdb.OrganizationService, string, func()) {\n\ts, closeBolt, err := NewTestInmemStore()\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create new kv store: %v\", err)\n\t}\n\n\tsvc, op, closeSvc := initOrganizationService(s, f, t)\n\treturn svc, op, func() {\n\t\tcloseSvc()\n\t\tcloseBolt()\n\t}\n}\n\n\n\nfunc initOrganizationService(s kv.Store, f influxdbtesting.OrganizationFields, t *testing.T) (influxdb.OrganizationService, string, func()) ", "output": "{\n\tsvc := kv.NewService(s)\n\tsvc.OrgBucketIDs = f.OrgBucketIDs\n\tsvc.IDGenerator = f.IDGenerator\n\tsvc.TimeGenerator = f.TimeGenerator\n\tif f.TimeGenerator == nil {\n\t\tsvc.TimeGenerator = influxdb.RealTimeGenerator{}\n\t}\n\n\tctx := context.Background()\n\tif err := svc.Initialize(ctx); err != nil {\n\t\tt.Fatalf(\"error initializing organization service: %v\", err)\n\t}\n\n\tfor _, u := range f.Organizations {\n\t\tif err := svc.PutOrganization(ctx, u); err != nil {\n\t\t\tt.Fatalf(\"failed to populate organizations\")\n\t\t}\n\t}\n\n\treturn svc, kv.OpPrefix, func() {\n\t\tfor _, u := range f.Organizations {\n\t\t\tif err := svc.DeleteOrganization(ctx, u.ID); err != nil {\n\t\t\t\tt.Logf(\"failed to remove organizations: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n}"}
{"input": "package models\n\nimport \"github.com/go-swagger/go-swagger/strfmt\"\n\n\n\n\n\ntype AuthenticationResponse struct {\n\n\tEmployee Employee `json:\"employee,omitempty\"`\n\n\tExpert Expert `json:\"expert,omitempty\"`\n\n\tExpiresIn int64 `json:\"expiresIn,omitempty\"`\n\n\tServerTime int64 `json:\"serverTime,omitempty\"`\n\n\tStartup bool `json:\"startup,omitempty\"`\n\n\tToken string `json:\"token,omitempty\"`\n}\n\n\n\n\nfunc (m *AuthenticationResponse) Validate(formats strfmt.Registry) error ", "output": "{\n\treturn nil\n}"}
{"input": "package quranize\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc testNewQuran(t *testing.T, q Quran) {\n\texpected := 114\n\tactual := len(q.Suras)\n\tassert.Equal(t, expected, actual)\n}\n\nfunc TestNewQuranSimpleClean(t *testing.T) {\n\ttestNewQuran(t, NewQuranSimpleClean())\n}\n\nfunc TestNewQuranSimpleEnhanced(t *testing.T) {\n\ttestNewQuran(t, NewQuranSimpleEnhanced())\n}\n\nfunc TestNewIDIndonesian(t *testing.T) {\n\ttestNewQuran(t, NewIDIndonesian())\n}\n\nfunc TestNewIDMuntakhab(t *testing.T) {\n\ttestNewQuran(t, NewIDMuntakhab())\n}\n\n\n\nfunc TestGetAyaSuraNotFound(t *testing.T) {\n\t_, err := NewQuranSimpleClean().GetAya(0, 0)\n\tassert.Error(t, err)\n}\n\nfunc TestGetAyaAyaNotFound(t *testing.T) {\n\t_, err := NewQuranSimpleClean().GetAya(1, 0)\n\tassert.Error(t, err)\n}\n\nfunc TestGetSuraNameFound(t *testing.T) {\n\ttext, err := NewQuranSimpleClean().GetSuraName(1)\n\tassert.NoError(t, err)\n\tassert.NotEmpty(t, text)\n}\n\nfunc TestGetSuraNameNotFound(t *testing.T) {\n\t_, err := NewQuranSimpleClean().GetSuraName(0)\n\tassert.Error(t, err)\n}\n\nfunc TestGetAyaFound(t *testing.T) ", "output": "{\n\ttext, err := NewQuranSimpleClean().GetAya(1, 1)\n\tassert.NoError(t, err)\n\tassert.NotEmpty(t, text)\n}"}
{"input": "package resctrl\n\nimport (\n\tinfo \"github.com/google/cadvisor/info/v1\"\n\t\"github.com/google/cadvisor/stats\"\n\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/intelrdt\"\n)\n\ntype collector struct {\n\tresctrl intelrdt.Manager\n\tstats.NoopDestroy\n}\n\n\n\nfunc (c *collector) UpdateStats(stats *info.ContainerStats) error {\n\tstats.Resctrl = info.ResctrlStats{}\n\n\tresctrlStats, err := c.resctrl.GetStats()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnumberOfNUMANodes := len(*resctrlStats.MBMStats)\n\n\tstats.Resctrl.MemoryBandwidth = make([]info.MemoryBandwidthStats, 0, numberOfNUMANodes)\n\tstats.Resctrl.Cache = make([]info.CacheStats, 0, numberOfNUMANodes)\n\n\tfor _, numaNodeStats := range *resctrlStats.MBMStats {\n\t\tstats.Resctrl.MemoryBandwidth = append(stats.Resctrl.MemoryBandwidth,\n\t\t\tinfo.MemoryBandwidthStats{\n\t\t\t\tTotalBytes: numaNodeStats.MBMTotalBytes,\n\t\t\t\tLocalBytes: numaNodeStats.MBMLocalBytes,\n\t\t\t})\n\t}\n\n\tfor _, numaNodeStats := range *resctrlStats.CMTStats {\n\t\tstats.Resctrl.Cache = append(stats.Resctrl.Cache,\n\t\t\tinfo.CacheStats{LLCOccupancy: numaNodeStats.LLCOccupancy})\n\t}\n\n\treturn nil\n}\n\nfunc newCollector(id string, resctrlPath string) *collector ", "output": "{\n\tcollector := &collector{\n\t\tresctrl: intelrdt.NewManager(\n\t\t\t&configs.Config{\n\t\t\t\tIntelRdt: &configs.IntelRdt{},\n\t\t\t},\n\t\t\tid,\n\t\t\tresctrlPath,\n\t\t),\n\t}\n\n\treturn collector\n}"}
{"input": "package util\n\nimport (\n\t\"strings\"\n\n\t\"istio.io/istio/pkg/config/resource\"\n)\n\ntype ScopedFqdn string\n\n\nfunc (s ScopedFqdn) GetScopeAndFqdn() (string, string) {\n\tparts := strings.SplitN(string(s), \"/\", 2)\n\treturn parts[0], parts[1]\n}\n\n\nfunc NewScopedFqdn(scope string, namespace resource.Namespace, host string) ScopedFqdn {\n\tfqdn := ConvertHostToFQDN(namespace, host)\n\treturn ScopedFqdn(scope + \"/\" + fqdn)\n}\n\n\n\n\nfunc GetResourceNameFromHost(defaultNamespace resource.Namespace, host string) resource.FullName {\n\n\tname := GetFullNameFromFQDN(host)\n\n\tif name.Namespace == \"\" {\n\t\tname.Namespace = defaultNamespace\n\t\tname.Name = resource.LocalName(host)\n\t}\n\treturn name\n}\n\n\n\nfunc GetFullNameFromFQDN(fqdn string) resource.FullName {\n\tresult := fqdnPattern.FindAllStringSubmatch(fqdn, -1)\n\tif len(result) == 0 {\n\t\treturn resource.FullName{\n\t\t\tNamespace: \"\",\n\t\t\tName:      \"\",\n\t\t}\n\t}\n\treturn resource.FullName{\n\t\tNamespace: resource.Namespace(result[0][2]),\n\t\tName:      resource.LocalName(result[0][1]),\n\t}\n}\n\n\n\n\nfunc ConvertHostToFQDN(namespace resource.Namespace, host string) string ", "output": "{\n\tfqdn := host\n\tif !strings.HasPrefix(host, \"*\") &&\n\t\t!strings.Contains(host, \".\") {\n\t\tfqdn = host + \".\" + string(namespace) + \".\" + DefaultKubernetesDomain\n\t}\n\treturn fqdn\n}"}
{"input": "package _9_queue\n\nimport \"fmt\"\n\ntype CircularQueue struct {\n\tq        []interface{}\n\tcapacity int\n\thead     int\n\ttail     int\n}\n\nfunc NewCircularQueue(n int) *CircularQueue {\n\tif n == 0 {\n\t\treturn nil\n\t}\n\treturn &CircularQueue{make([]interface{}, n), n, 0, 0}\n}\n\n\nfunc (this *CircularQueue) IsEmpty() bool {\n\tif this.head == this.tail {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\nfunc (this *CircularQueue) IsFull() bool {\n\tif this.head == (this.tail+1)%this.capacity {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n\nfunc (this *CircularQueue) DeQueue() interface{} {\n\tif this.IsEmpty() {\n\t\treturn nil\n\t}\n\tv := this.q[this.head]\n\tthis.head = (this.head + 1) % this.capacity\n\treturn v\n}\n\nfunc (this *CircularQueue) String() string {\n\tif this.IsEmpty() {\n\t\treturn \"empty queue\"\n\t}\n\tresult := \"head\"\n\tvar i = this.head\n\tfor true {\n\t\tresult += fmt.Sprintf(\"<-%+v\", this.q[i])\n\t\ti = (i + 1) % this.capacity\n\t\tif i == this.tail {\n\t\t\tbreak\n\t\t}\n\t}\n\tresult += \"<-tail\"\n\treturn result\n}\n\nfunc (this *CircularQueue) EnQueue(v interface{}) bool ", "output": "{\n\tif this.IsFull() {\n\t\treturn false\n\t}\n\tthis.q[this.tail] = v\n\tthis.tail = (this.tail + 1) % this.capacity\n\treturn true\n}"}
{"input": "package pools \n\nimport (\n\t\"bytes\"\n\t\"sync\"\n)\n\n\n\nvar bytesBuffer = sync.Pool{\n\tNew: func() interface{} { return new(bytes.Buffer) },\n}\n\n\n\n\n\n\nfunc PutBuffer(buf *bytes.Buffer) {\n\tbytesBuffer.Put(buf)\n}\n\nfunc BytesBuffer() *bytes.Buffer ", "output": "{\n\tbuf := bytesBuffer.Get().(*bytes.Buffer)\n\tbuf.Reset()\n\treturn buf\n}"}
{"input": "package main\n\nimport (\n\tcompute \"google.golang.org/api/compute/v1\"\n\n\t\"github.com/golang/glog\"\n)\n\n\n\ntype HealthChecks struct {\n\tcloud SingleHealthCheck\n\tdefaultPath string\n}\n\n\n\n\n\n\n\nfunc NewHealthChecker(s SingleHealthCheck, name string, defaultPath string) (*HealthChecks, error) {\n\td := defaultPath\n\tif defaultPath != \"\" {\n\t\td = defaultHealthCheckPath\n\t}\n\thc := &HealthChecks{s, d}\n\tif err := hc.Add(name); err != nil {\n\t\treturn nil, err\n\t}\n\treturn hc, nil\n}\n\n\nfunc (h *HealthChecks) Add(name string) error {\n\thc, _ := h.Get(name)\n\tif hc == nil {\n\t\tglog.Infof(\"Creating health check %v\", name)\n\t\tif err := h.cloud.CreateHttpHealthCheck(\n\t\t\t&compute.HttpHealthCheck{\n\t\t\t\tName:        name,\n\t\t\t\tPort:        defaultPort,\n\t\t\t\tRequestPath: h.defaultPath,\n\t\t\t\tDescription: \"Default kubernetes L7 Loadbalancing health check.\",\n\t\t\t\tCheckIntervalSec: 1,\n\t\t\t\tTimeoutSec: 1,\n\t\t\t\tHealthyThreshold: 1,\n\t\t\t\tUnhealthyThreshold: 10,\n\t\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tglog.Infof(\"Health check %v already exists\", hc.Name)\n\t}\n\treturn nil\n}\n\n\nfunc (h *HealthChecks) Delete(name string) error {\n\treturn h.cloud.DeleteHttpHealthCheck(name)\n}\n\n\n\n\nfunc (h *HealthChecks) Get(name string) (*compute.HttpHealthCheck, error) ", "output": "{\n\treturn h.cloud.GetHttpHealthCheck(name)\n}"}
{"input": "package cli\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"strconv\"\n)\n\n\nfunc CheckError(err error) {\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}\n\n\nfunc CheckFatalError(err error) {\n\tif err != nil {\n\t\tCheckError(fmt.Errorf(\"Fatal error: %v\", err))\n\t}\n}\n\n\n\n\n\nfunc WritePid(pidfile string) {\n\tdirname := path.Dir(pidfile)\n\tif !FileExists(dirname) {\n\t\tCheckFatalError(fmt.Errorf(\"Directory \\\"%s\\\" doesn't exist\", dirname))\n\t}\n\n\tif FileExists(pidfile) {\n\t\tCheckFatalError(fmt.Errorf(\"File \\\"%s\\\" already exist\", pidfile))\n\t}\n\n\tpid := os.Getpid()\n\terr := ioutil.WriteFile(pidfile, []byte(strconv.Itoa(pid)), os.FileMode(0644))\n\tCheckFatalError(err)\n}\n\n\nfunc StopExecution(code int, pidfile string) {\n\tos.Remove(pidfile)\n\tos.Exit(code)\n}\n\nfunc FileExists(path string) bool ", "output": "{\n\t_, err := os.Stat(path)\n\n\tif err == nil {\n\t\treturn true\n\t}\n\n\tif os.IsNotExist(err) {\n\t\treturn false\n\t}\n\n\treturn false\n}"}
{"input": "package scheduling\n\nimport \"k8s.io/api/core/v1\"\n\n\ntype FakeVolumeBinderConfig struct {\n\tAllBound    bool\n\tFindReasons ConflictReasons\n\tFindErr     error\n\tAssumeErr   error\n\tBindErr     error\n}\n\n\n\n\n\n\ntype FakeVolumeBinder struct {\n\tconfig       *FakeVolumeBinderConfig\n\tAssumeCalled bool\n\tBindCalled   bool\n}\n\n\nfunc (b *FakeVolumeBinder) FindPodVolumes(pod *v1.Pod, node *v1.Node) (reasons ConflictReasons, err error) {\n\treturn b.config.FindReasons, b.config.FindErr\n}\n\n\nfunc (b *FakeVolumeBinder) AssumePodVolumes(assumedPod *v1.Pod, nodeName string) (bool, error) {\n\tb.AssumeCalled = true\n\treturn b.config.AllBound, b.config.AssumeErr\n}\n\n\nfunc (b *FakeVolumeBinder) BindPodVolumes(assumedPod *v1.Pod) error {\n\tb.BindCalled = true\n\treturn b.config.BindErr\n}\n\n\nfunc (b *FakeVolumeBinder) GetBindingsCache() PodBindingCache {\n\treturn nil\n}\n\n\nfunc (b *FakeVolumeBinder) DeletePodBindings(pod *v1.Pod) {}\n\nfunc NewFakeVolumeBinder(config *FakeVolumeBinderConfig) *FakeVolumeBinder ", "output": "{\n\treturn &FakeVolumeBinder{\n\t\tconfig: config,\n\t}\n}"}
{"input": "package api\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\n\nfunc InitServer() (*Server, error) {\n\tserver := &Server{}\n\n\tserver.setupRouter()\n\treturn server, nil\n\n}\n\n\nfunc (server *Server) setupRouter() {\n\n\trouter := gin.Default()\n\tv1 := router.Group(\"/api/v1\")\n\t{\n\t\tc := v1.Group(\"/convert\")\n\t\t{\n\t\t\tc.POST(\"/yaml/yaml\", Yaml2Yaml)\n\t\t}\n\n\t\td := v1.Group(\"/download\")\n\t\t{\n\t\t\td.GET(\"/:uuid/:filename\", ConvertedFile) \n\t\t\td.GET(\"/:uuid/\", ConvertedFilesArchive)  \n\t\t}\n\n\t\ts := v1.Group(\"/status\")\n\t\t{\n\t\t\ts.GET(\"/healthz\", Healthz)   \n\t\t\ts.GET(\"/settings\", Settings) \n\t\t}\n\t}\n\n\tserver.router = router\n}\n\n\n\n\n\nfunc errorResponse(err error) gin.H {\n\treturn gin.H{\"error\": err.Error()}\n}\n\nfunc (server *Server) Start(serverAddress string, serverPort string) error ", "output": "{\n\treturn server.router.Run(serverAddress + \":\" + serverPort)\n}"}
{"input": "package commands\n\nimport (\n\t\"fmt\"\n\n\tapi \"github.com/pagodabox/pagodabox-api-client\"\n\t\"github.com/pagodabox/pagodabox-cli/helpers\"\n\t\"github.com/pagodabox/pagodabox-cli/ui\"\n)\n\n\ntype AppListCommand struct{}\n\n\n\n\n\nfunc (c *AppListCommand) Run(fApp string, opts []string) {\n\n\tapps, err := api.GetApps()\n\tif err != nil {\n\t\tui.LogFatal(\"[commands.app_list] api.GetApps() failed\", err)\n\t}\n\n\troles, err := api.GetUserRoles()\n\tif err != nil {\n\t\tui.LogFatal(\"[commands.app_list] api.GetUserRoles() failed\", err)\n\t}\n\n\trolesMap := make(map[string]string)\n\tfor _, role := range roles {\n\t\trolesMap[role.AppID] = role.Permission\n\t}\n\n\tfmt.Println(`\nApps :                                                              * tinker app\n--------------------------------------------------------------------------------`)\n\n\tvar appFlation, appType string\n\n\tfor _, app := range apps {\n\n\t\tappFlation = helpers.DetermineAppFlation(app.Flation)\n\t\tappType = helpers.DetermineAppType(app.Free)\n\n\t\tfmt.Printf(\"%-35v   %12v   %12v   %12v\\n\", fmt.Sprintf(\"%v%v\", app.Name, appType), rolesMap[app.ID], appFlation, app.State)\n\t}\n\n\tfmt.Println(\"\")\n}\n\nfunc (c *AppListCommand) Help() ", "output": "{\n\tui.CPrint(`\nDescription:\n  Lists all of your applications.\n\n  name:\n    The name's of your applications.\n\n  role:\n    Your access level in relation to the app.\n\n    owner     : Full permissions\n    manager   : CANNOT delete the app or modify billing info\n    developer : CAN push, pull, and deploy code only.\n\n  state:\n  \tThe current state of the app.\n\n  \tcreated    - App exists, but has no code deployed\n    active     - App exists, and has been deployed to\n    asleep     - A sleeping 'tinker' app\n    inactive   - App is being/has been deleted\n    hibernated - App is disabled due to deliquency\n\nUsage:\n  pagoda list\n  pagoda app:list\n\n  ex. pagoda list\n\t`)\n}"}
{"input": "package client\n\nimport (\n\tauthorizationapi \"github.com/openshift/origin/pkg/authorization/api\"\n)\n\n\ntype SubjectAccessReviewsNamespacer interface {\n\tSubjectAccessReviews(namespace string) SubjectAccessReviewInterface\n}\n\n\ntype ClusterSubjectAccessReviews interface {\n\tClusterSubjectAccessReviews() SubjectAccessReviewInterface\n}\n\n\ntype SubjectAccessReviewInterface interface {\n\tCreate(policy *authorizationapi.SubjectAccessReview) (*authorizationapi.SubjectAccessReviewResponse, error)\n}\n\n\ntype subjectAccessReviews struct {\n\tr  *Client\n\tns string\n}\n\n\nfunc newSubjectAccessReviews(c *Client, namespace string) *subjectAccessReviews {\n\treturn &subjectAccessReviews{\n\t\tr:  c,\n\t\tns: namespace,\n\t}\n}\n\n\nfunc (c *subjectAccessReviews) Create(policy *authorizationapi.SubjectAccessReview) (result *authorizationapi.SubjectAccessReviewResponse, err error) {\n\tresult = &authorizationapi.SubjectAccessReviewResponse{}\n\terr = c.r.Post().Namespace(c.ns).Resource(\"subjectAccessReviews\").Body(policy).Do().Into(result)\n\treturn\n}\n\n\ntype clusterSubjectAccessReviews struct {\n\tr *Client\n}\n\n\n\n\n\nfunc (c *clusterSubjectAccessReviews) Create(policy *authorizationapi.SubjectAccessReview) (result *authorizationapi.SubjectAccessReviewResponse, err error) {\n\tresult = &authorizationapi.SubjectAccessReviewResponse{}\n\terr = c.r.Post().Resource(\"subjectAccessReviews\").Body(policy).Do().Into(result)\n\treturn\n}\n\nfunc newClusterSubjectAccessReviews(c *Client) *clusterSubjectAccessReviews ", "output": "{\n\treturn &clusterSubjectAccessReviews{\n\t\tr: c,\n\t}\n}"}
{"input": "package stat\n\n\n\ntype Histogram struct {\n\tmin, max float64\n\twidth    float64\n\tbin      []*Bin\n}\n\ntype Bin struct {\n\tX      float64 \n\tWeight float64\n}\n\n\nfunc NewHistogram(min, max float64, n int) *Histogram {\n\th := &Histogram{\n\t\tmin:   min,\n\t\tmax:   max,\n\t\twidth: (max - min) / float64(n),\n\t\tbin:   make([]*Bin, n),\n\t}\n\tif h.width < 0 {\n\t\tpanic(\"negative histogram bin width\")\n\t}\n\tfor i, _ := range h.bin {\n\t\th.bin[i] = &Bin{X: min + float64(i)*h.width}\n\t}\n\treturn h\n}\n\n\nfunc (h *Histogram) Width() float64 {\n\treturn h.width\n}\n\n\nfunc (h *Histogram) Put(x float64, weight float64) {\n\tif x <= h.min {\n\t\th.bin[0].Weight += weight\n\t\treturn\n\t}\n\tif x >= h.max {\n\t\th.bin[len(h.bin)-1].Weight += weight\n\t}\n\th.bin[min(len(h.bin)-1, int((x-h.min)/h.width))].Weight += weight\n}\n\n\n\n\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc (h *Histogram) Histogram() []*Bin ", "output": "{\n\treturn h.bin\n}"}
{"input": "package config\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\t\"gopkg.in/yaml.v2\"\n)\n\ntype Config struct {\n\tCsCluster struct {\n\t\tHost string\n\t\tPort int\n\t}\n\tRabbit struct {\n\t\tHost string\n\t}\n}\n\nvar File string\n\n\n\n\n\nfunc OpenConfig(configFile *string) *os.File {\n\tf, err := os.Open(*configFile)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn f\n}\n\n\nfunc ReadConfig(r io.Reader) (*Config, error) {\n\tdata, err := ioutil.ReadAll(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar c Config\n\tyaml.Unmarshal(data, &c)\n\treturn &c, nil\n}\n\nfunc ReadReturn(path string) (*Config, error) ", "output": "{\n\tf := OpenConfig(&path)\n\tc, err := ReadConfig(f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}"}
{"input": "package utub\n\nimport (\n\t\"strings\"\n\n\t\"gopkg.in/olebedev/go-duktape.v2\"\n)\n\ntype duktapeJSEngine struct{}\n\nfunc (js duktapeJSEngine) Name() string {\n\treturn \"Duktape\"\n}\n\nfunc (js duktapeJSEngine) Available() bool {\n\treturn true\n}\n\n\n\nfunc (js duktapeJSEngine) sanitizeJSPlayerCode(code string) string {\n\tcode = strings.Replace(code, `(?=:|,|]|}|$)`, `(?=:|,|\\]|\\}|$)`, 1)\n\treturn code\n}\n\nfunc (js duktapeJSEngine) Exec(code string) (string, error) ", "output": "{\n\tctx := duktape.New()\n\tdefer ctx.DestroyHeap()\n\n\terr := ctx.PevalString(code)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn ctx.SafeToString(-1), nil\n}"}
{"input": "package testing\n\nimport (\n\t\"fmt\"\n\n\truntimeapi \"k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1\"\n)\n\nfunc BuildContainerName(metadata *runtimeapi.ContainerMetadata, sandboxID string) string {\n\treturn fmt.Sprintf(\"%s_%s_%d\", sandboxID, metadata.Name, metadata.Attempt)\n}\n\nfunc BuildSandboxName(metadata *runtimeapi.PodSandboxMetadata) string {\n\treturn fmt.Sprintf(\"%s_%s_%s_%d\", metadata.Name, metadata.Namespace, metadata.Uid, metadata.Attempt)\n}\n\n\n\nfunc filterInLabels(filter, labels map[string]string) bool ", "output": "{\n\tfor k, v := range filter {\n\t\tif value, ok := labels[k]; ok {\n\t\t\tif value != v {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"gopkg.in/redis.v3\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nvar redisClient *Redis\n\ntype Redis struct {\n\t*redis.Client\n}\n\n\n\nfunc pingServer(w http.ResponseWriter, req *http.Request) {\n\tvar message string\n\n\tif count, err := redisClient.getCount(); err == nil {\n\t\tmessage = fmt.Sprintf(\"ping! %d\", count)\n\t} else {\n\t\tmessage = err.Error()\n\t}\n\tw.Write([]byte(message))\n}\n\nfunc main() {\n\turi := fmt.Sprintf(\"%s:6379\", os.Getenv(\"REDIS_HOST\"))\n\tredisClient = &Redis{\n\t\tredis.NewClient(&redis.Options{\n\t\t\tAddr:     uri,\n\t\t\tPassword: \"\", \n\t\t\tDB:       0,  \n\t\t}),\n\t}\n\n\thttp.HandleFunc(\"/\", pingServer)\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc (r Redis) getCount() (int64, error) ", "output": "{\n\tif err := redisClient.Incr(\"ping\").Err(); err != nil {\n\t\treturn -1, err\n\t}\n\n\tcount, err := redisClient.Get(\"ping\").Int64()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\treturn count, err\n}"}
{"input": "package graceful\n\nimport \"crypto/tls\"\n\n\n\n\nfunc cloneTLSConfig(cfg *tls.Config) *tls.Config ", "output": "{\n\tc := *cfg\n\treturn &c\n}"}
{"input": "package s0132\n\nimport (\n\t\"github.com/peterstace/project-euler/number\"\n)\n\n\n\nfunc SumPrimeFactors(numFactors int, k int) int {\n\tvar factorsFound int\n\tvar sum int\n\tnthPrime := number.MakeSieveBackedNthPrime()\n\tfor i := 0; factorsFound < numFactors; i++ {\n\t\tp := nthPrime(i)\n\t\tif repunit(k, p) == 0 {\n\t\t\tfactorsFound++\n\t\t\tsum += p\n\t\t}\n\t}\n\treturn sum\n}\n\n\nfunc repunit(k, m int) int {\n\tif k == 1 {\n\t\treturn 1\n\t}\n\tif k%2 == 0 {\n\t\thalf := repunit(k/2, m)\n\t\treturn (tenPow(k/2, m)*half + half) % m\n\t} else {\n\t\treturn (10*repunit(k-1, m) + 1) % m\n\t}\n}\n\n\nfunc tenPow(k, m int) int {\n\tif k == 0 {\n\t\treturn 1\n\t}\n\tif k%2 == 0 {\n\t\thalf := tenPow(k/2, m)\n\t\treturn (half * half) % m\n\t} else {\n\t\treturn (10 * tenPow(k-1, m)) % m\n\t}\n}\n\nfunc Answer() interface{} ", "output": "{\n\treturn SumPrimeFactors(40, 10e9)\n}"}
{"input": "package thrift\n\nimport \"io\"\n\ntype RichTransport struct {\n\tTTransport\n}\n\n\nfunc NewTRichTransport(trans TTransport) *RichTransport {\n\treturn &RichTransport{trans}\n}\n\nfunc (r *RichTransport) ReadByte() (c byte, err error) {\n\treturn readByte(r.TTransport)\n}\n\nfunc (r *RichTransport) WriteByte(c byte) error {\n\treturn writeByte(r.TTransport, c)\n}\n\nfunc (r *RichTransport) WriteString(s string) (n int, err error) {\n\treturn r.Write([]byte(s))\n}\n\nfunc (r *RichTransport) RemainingBytes() (num_bytes uint64) {\n\treturn r.TTransport.RemainingBytes()\n}\n\n\n\nfunc writeByte(w io.Writer, c byte) error {\n\tv := [1]byte{c}\n\t_, err := w.Write(v[0:1])\n\treturn err\n}\n\nfunc readByte(r io.Reader) (c byte, err error) ", "output": "{\n\tv := [1]byte{0}\n\tn, err := r.Read(v[0:1])\n\tif n > 0 && (err == nil || err == io.EOF) {\n\t\treturn v[0], nil\n\t}\n\tif n > 0 && err != nil {\n\t\treturn v[0], err\n\t}\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn v[0], nil\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nvar version string\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer logRequestInfo(r)\n\t\tfmt.Fprintf(w, GreetingMessage())\n\t})\n\n\thttp.HandleFunc(\"/ping\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer logRequestInfo(r)\n\t\tfmt.Fprintf(w, \"pong\")\n\t})\n\n\thttp.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer logRequestInfo(r)\n\t\tfmt.Fprintf(w, \"ok\")\n\t})\n\n\tlog.Fatal(http.ListenAndServe(\":8000\", nil))\n}\n\nfunc GetVersion() string {\n\treturn os.Getenv(\"VERSION\")\n}\n\n\n\nfunc logRequestInfo(r *http.Request) {\n\tlog.Printf(\"%s %s\", r.Method, r.URL)\n}\n\nfunc GreetingMessage() string ", "output": "{\n\treturn fmt.Sprintf(\"Running version %s\", GetVersion())\n}"}
{"input": "package pam\n\nimport (\n\t\"code.gitea.io/gitea/models/auth\"\n\t\"code.gitea.io/gitea/modules/json\"\n)\n\n\n\n\n\n\n\n\n\ntype Source struct {\n\tServiceName    string \n\tEmailDomain    string\n\tSkipLocalTwoFA bool `json:\",omitempty\"` \n\n\tauthSource *auth.Source\n}\n\n\nfunc (source *Source) FromDB(bs []byte) error {\n\treturn json.UnmarshalHandleDoubleEncode(bs, &source)\n}\n\n\nfunc (source *Source) ToDB() ([]byte, error) {\n\treturn json.Marshal(source)\n}\n\n\n\n\nfunc init() {\n\tauth.RegisterTypeConfig(auth.PAM, &Source{})\n}\n\nfunc (source *Source) SetAuthSource(authSource *auth.Source) ", "output": "{\n\tsource.authSource = authSource\n}"}
{"input": "package cli_test\n\nimport (\n\t\"flag\"\n\t\"testing\"\n\n\t\"github.com/zeroed/escli/Godeps/_workspace/src/github.com/codegangsta/cli\"\n)\n\nfunc TestCommandDoNotIgnoreFlags(t *testing.T) {\n\tapp := cli.NewApp()\n\tset := flag.NewFlagSet(\"test\", 0)\n\ttest := []string{\"blah\", \"blah\", \"-break\"}\n\tset.Parse(test)\n\n\tc := cli.NewContext(app, set, nil)\n\n\tcommand := cli.Command{\n\t\tName:        \"test-cmd\",\n\t\tAliases:     []string{\"tc\"},\n\t\tUsage:       \"this is for testing\",\n\t\tDescription: \"testing\",\n\t\tAction:      func(_ *cli.Context) {},\n\t}\n\terr := command.Run(c)\n\n\texpect(t, err.Error(), \"flag provided but not defined: -break\")\n}\n\n\n\nfunc TestCommandIgnoreFlags(t *testing.T) ", "output": "{\n\tapp := cli.NewApp()\n\tset := flag.NewFlagSet(\"test\", 0)\n\ttest := []string{\"blah\", \"blah\"}\n\tset.Parse(test)\n\n\tc := cli.NewContext(app, set, nil)\n\n\tcommand := cli.Command{\n\t\tName:            \"test-cmd\",\n\t\tAliases:         []string{\"tc\"},\n\t\tUsage:           \"this is for testing\",\n\t\tDescription:     \"testing\",\n\t\tAction:          func(_ *cli.Context) {},\n\t\tSkipFlagParsing: true,\n\t}\n\terr := command.Run(c)\n\n\texpect(t, err, nil)\n}"}
{"input": "package procfs\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"strings\"\n)\n\n\n\ntype ARPEntry struct {\n\tIPAddr net.IP\n\tHWAddr net.HardwareAddr\n\tDevice string\n}\n\n\n\nfunc (fs FS) GatherARPEntries() ([]ARPEntry, error) {\n\tdata, err := ioutil.ReadFile(fs.proc.Path(\"net/arp\"))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error reading arp %s: %s\", fs.proc.Path(\"net/arp\"), err)\n\t}\n\n\treturn parseARPEntries(data)\n}\n\n\n\nfunc parseARPEntry(columns []string) (ARPEntry, error) {\n\tip := net.ParseIP(columns[0])\n\tmac := net.HardwareAddr(columns[3])\n\n\tentry := ARPEntry{\n\t\tIPAddr: ip,\n\t\tHWAddr: mac,\n\t\tDevice: columns[5],\n\t}\n\n\treturn entry, nil\n}\n\nfunc parseARPEntries(data []byte) ([]ARPEntry, error) ", "output": "{\n\tlines := strings.Split(string(data), \"\\n\")\n\tentries := make([]ARPEntry, 0)\n\tvar err error\n\tconst (\n\t\texpectedDataWidth   = 6\n\t\texpectedHeaderWidth = 9\n\t)\n\tfor _, line := range lines {\n\t\tcolumns := strings.Fields(line)\n\t\twidth := len(columns)\n\n\t\tif width == expectedHeaderWidth || width == 0 {\n\t\t\tcontinue\n\t\t} else if width == expectedDataWidth {\n\t\t\tentry, err := parseARPEntry(columns)\n\t\t\tif err != nil {\n\t\t\t\treturn []ARPEntry{}, fmt.Errorf(\"failed to parse ARP entry: %s\", err)\n\t\t\t}\n\t\t\tentries = append(entries, entry)\n\t\t} else {\n\t\t\treturn []ARPEntry{}, fmt.Errorf(\"%d columns were detected, but %d were expected\", width, expectedDataWidth)\n\t\t}\n\n\t}\n\n\treturn entries, err\n}"}
{"input": "package container\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang/glog\"\n)\n\n\ntype ContainerGCPolicy struct {\n\tMinAge time.Duration\n\n\tMaxPerPodContainer int\n\n\tMaxContainers int\n}\n\n\n\n\ntype ContainerGC interface {\n\tGarbageCollect() error\n\tDeleteAllUnusedContainers() error\n}\n\n\ntype SourcesReadyProvider interface {\n\tAllReady() bool\n}\n\n\ntype realContainerGC struct {\n\truntime Runtime\n\n\tpolicy ContainerGCPolicy\n\n\tsourcesReadyProvider SourcesReadyProvider\n}\n\n\nfunc NewContainerGC(runtime Runtime, policy ContainerGCPolicy, sourcesReadyProvider SourcesReadyProvider) (ContainerGC, error) {\n\tif policy.MinAge < 0 {\n\t\treturn nil, fmt.Errorf(\"invalid minimum garbage collection age: %v\", policy.MinAge)\n\t}\n\n\treturn &realContainerGC{\n\t\truntime:              runtime,\n\t\tpolicy:               policy,\n\t\tsourcesReadyProvider: sourcesReadyProvider,\n\t}, nil\n}\n\nfunc (cgc *realContainerGC) GarbageCollect() error {\n\treturn cgc.runtime.GarbageCollect(cgc.policy, cgc.sourcesReadyProvider.AllReady(), false)\n}\n\n\n\nfunc (cgc *realContainerGC) DeleteAllUnusedContainers() error ", "output": "{\n\tglog.Infof(\"attempting to delete unused containers\")\n\treturn cgc.runtime.GarbageCollect(cgc.policy, cgc.sourcesReadyProvider.AllReady(), true)\n}"}
{"input": "package chaincode\n\nimport (\n\t\"sync\"\n\n\t\"github.com/hyperledger/fabric/protos/gossip\"\n)\n\n\ntype InstalledChaincode struct {\n\tName    string\n\tVersion string\n\tId      []byte\n}\n\n\ntype Metadata struct {\n\tName              string\n\tVersion           string\n\tPolicy            []byte\n\tId                []byte\n\tCollectionsConfig []byte\n}\n\n\ntype MetadataSet []Metadata\n\n\n\n\n\ntype MetadataMapping struct {\n\tsync.RWMutex\n\tmdByName map[string]Metadata\n}\n\n\nfunc NewMetadataMapping() *MetadataMapping {\n\treturn &MetadataMapping{\n\t\tmdByName: make(map[string]Metadata),\n\t}\n}\n\n\nfunc (m *MetadataMapping) Lookup(cc string) (Metadata, bool) {\n\tm.RLock()\n\tdefer m.RUnlock()\n\tmd, exists := m.mdByName[cc]\n\treturn md, exists\n}\n\n\nfunc (m *MetadataMapping) Update(ccMd Metadata) {\n\tm.Lock()\n\tdefer m.Unlock()\n\tm.mdByName[ccMd.Name] = ccMd\n}\n\n\nfunc (m *MetadataMapping) Aggregate() MetadataSet {\n\tm.RLock()\n\tdefer m.RUnlock()\n\tvar set MetadataSet\n\tfor _, md := range m.mdByName {\n\t\tset = append(set, md)\n\t}\n\treturn set\n}\n\nfunc (ccs MetadataSet) AsChaincodes() []*gossip.Chaincode ", "output": "{\n\tvar res []*gossip.Chaincode\n\tfor _, cc := range ccs {\n\t\tres = append(res, &gossip.Chaincode{\n\t\t\tName:    cc.Name,\n\t\t\tVersion: cc.Version,\n\t\t})\n\t}\n\treturn res\n}"}
{"input": "package server\n\nimport (\n\t\"fmt\"\n\t\"github.com/centurylinkcloud/clc-go-cli/base\"\n)\n\ntype Server struct {\n\tServerId   string\n\tServerName string\n}\n\n\n\nfunc (s *Server) InferID(cn base.Connection) error {\n\tif s.ServerName == \"\" {\n\t\treturn nil\n\t}\n\n\tID, err := IDByName(cn, s.ServerName)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.ServerId = ID\n\treturn nil\n}\n\nfunc (s *Server) GetNames(cn base.Connection, property string) ([]string, error) {\n\tif property != \"ServerName\" {\n\t\treturn nil, nil\n\t}\n\n\treturn GetNames(cn, \"all\")\n}\n\nfunc (s *Server) Validate() error ", "output": "{\n\tif (s.ServerId == \"\") == (s.ServerName == \"\") {\n\t\treturn fmt.Errorf(\"Exactly one of the server-id and server-name must be set.\")\n\t}\n\treturn nil\n}"}
{"input": "package balanced\n\nimport (\n\t\"encoding/json\"\n\t\"time\"\n)\n\ntype Customer struct {\n\tAddress        *Address               `json:\"address,omitempty\"`\n\tBusinessName   string                 `json:\"business_name,omitempty\"`\n\tCreatedAt      time.Time              `json:\"created_at,omitempty\"`\n\tDobMonth       int                    `json:\"dob_month,omitempty\"`\n\tDobYear        int                    `json:\"dob_year,omitempty\"`\n\tEin            string                 `json:\"ein,omitempty\"`\n\tEmail          string                 `json:\"email,omitempty\"`\n\tID             string                 `json:\"id,omitempty\"`\n\tMeta           map[string]interface{} `json:\"meta,omitempty\"`\n\tName           string                 `json:\"name,omitempty\"`\n\tPhone          string                 `json:\"phone,omitempty\"`\n\tSSNLast4       string                 `json:\"ssn_last4,omitempty\"`\n\tMerchantStatus string                 `json:\"merchant_status,omitempty\"`\n}\n\ntype customerResponse struct {\n\tCustomers []*Customer `json:\"customers\"`\n}\n\nfunc (c *Customer) path() string {\n\treturn \"/customers\"\n}\n\nfunc (c *Customer) getID() string {\n\treturn c.ID\n}\n\n\n\nfunc (c *Customer) singleResponse(data []byte) {\n\tparsedResponse := new(customerResponse)\n\tjson.Unmarshal(data, &parsedResponse)\n\t*c = *parsedResponse.Customers[0]\n}\n\nfunc (c *Customer) canDelete() bool {\n\treturn true\n}\n\nfunc (c *Customer) IsVerified() bool {\n\treturn c.MerchantStatus == \"underwritten\"\n}\n\nfunc (c *Customer) getOwnerPath() string ", "output": "{\n\treturn \"\"\n}"}
{"input": "package container\n\nimport (\n\t\"fmt\"\n\t\"github.com/bunbunjp/gotop/dataservice/memory\"\n\t\"github.com/bunbunjp/gotop/util\"\n\t\"github.com/gizak/termui\"\n)\n\n\ntype VirtualMemoryUsageContainer struct {\n\tvirtualGauge *termui.Gauge\n}\n\n\nfunc (v *VirtualMemoryUsageContainer) Initialize() {\n}\n\n\n\n\n\nfunc (v *VirtualMemoryUsageContainer) CreateUI() termui.GridBufferer {\n\n\tv.virtualGauge = termui.NewGauge()\n\tv.virtualGauge.Width = termui.TermWidth() / 4\n\tv.virtualGauge.Height = 10\n\tv.virtualGauge.LabelAlign = termui.AlignRight\n\n\treturn v.virtualGauge\n}\n\nfunc (v *VirtualMemoryUsageContainer) UpdateRender() ", "output": "{\n\tdata := memory.GetInstance()\n\n\tv.virtualGauge.Percent = int(data.LatestVirtualStat.UsedPercent)\n\tv.virtualGauge.BorderLabel = fmt.Sprintf(\"virtual usage (%.2fGB/%.2fGB)\",\n\t\tutil.Byte2GBi(data.LatestVirtualStat.Used),\n\t\tutil.Byte2GBi(data.LatestVirtualStat.Total))\n}"}
{"input": "package core\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/oracle/oci-go-sdk/common\"\n)\n\n\ntype ExportImageViaObjectStorageUriDetails struct {\n\n\tDestinationUri *string `mandatory:\"true\" json:\"destinationUri\"`\n}\n\nfunc (m ExportImageViaObjectStorageUriDetails) String() string {\n\treturn common.PointerString(m)\n}\n\n\n\n\nfunc (m ExportImageViaObjectStorageUriDetails) MarshalJSON() (buff []byte, e error) ", "output": "{\n\ttype MarshalTypeExportImageViaObjectStorageUriDetails ExportImageViaObjectStorageUriDetails\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"destinationType\"`\n\t\tMarshalTypeExportImageViaObjectStorageUriDetails\n\t}{\n\t\t\"objectStorageUri\",\n\t\t(MarshalTypeExportImageViaObjectStorageUriDetails)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}"}
{"input": "package sim\n\nimport (\n\t\"context\"\n\n\t\"github.com/sacloud/libsacloud/v2/sacloud\"\n)\n\n\n\nfunc (s *Service) FindWithContext(ctx context.Context, req *FindRequest) ([]*sacloud.SIM, error) {\n\tif err := req.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tparams, err := req.ToRequestParameter()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient := sacloud.NewSIMOp(s.caller)\n\tfound, err := client.Find(ctx, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn found.SIMs, nil\n}\n\nfunc (s *Service) Find(req *FindRequest) ([]*sacloud.SIM, error) ", "output": "{\n\treturn s.FindWithContext(context.Background(), req)\n}"}
{"input": "package impl\n\nimport (\n\t\"github.com/mokelab-go/fcm\"\n\t\"testing\"\n)\n\nconst (\n\ttestAPIKey = \"INPUT_YOUR_API_KEY\"\n\ttestRegID  = \"INPUT_YOUR_REG_ID\"\n)\n\n\n\nfunc Test_Send(t *testing.T) ", "output": "{\n\tclient := NewClient(testAPIKey)\n\tnotification := fcm.Notification{\n\t\tTitle: \"test\",\n\t\tBody:  \"hello\",\n\t}\n\tdata := fcm.Data{\n\t\t\"name\": \"moke\",\n\t}\n\t_, err := client.Send(notification, data, testRegID)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to send FCM message : %s\", err)\n\t}\n}"}
{"input": "package matchers\n\nimport (\n\t\"fmt\"\n\t\"github.com/cross-dev/script-server/Godeps/_workspace/src/github.com/onsi/gomega/format\"\n\t\"strings\"\n)\n\ntype ContainSubstringMatcher struct {\n\tSubstr string\n\tArgs   []interface{}\n}\n\nfunc (matcher *ContainSubstringMatcher) Match(actual interface{}) (success bool, err error) {\n\tactualString, ok := toString(actual)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"ContainSubstring matcher requires a string or stringer.  Got:\\n%s\", format.Object(actual, 1))\n\t}\n\n\treturn strings.Contains(actualString, matcher.stringToMatch()), nil\n}\n\n\n\nfunc (matcher *ContainSubstringMatcher) FailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, \"to contain substring\", matcher.stringToMatch())\n}\n\nfunc (matcher *ContainSubstringMatcher) NegatedFailureMessage(actual interface{}) (message string) {\n\treturn format.Message(actual, \"not to contain substring\", matcher.stringToMatch())\n}\n\nfunc (matcher *ContainSubstringMatcher) stringToMatch() string ", "output": "{\n\tstringToMatch := matcher.Substr\n\tif len(matcher.Args) > 0 {\n\t\tstringToMatch = fmt.Sprintf(matcher.Substr, matcher.Args...)\n\t}\n\treturn stringToMatch\n}"}
{"input": "package math\n\nimport \"math\"\n\n\n\n\n\n\n\n\nfunc Round(x float64) float64 ", "output": "{\n\tif math.IsNaN(x) || math.IsInf(x, 0) {\n\t\treturn x\n\t}\n\treturn math.Trunc(x + math.Copysign(.5, x))\n}"}
{"input": "package file\n\nimport (\n\t\"os/exec\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n\n\nfunc ExecWithEnv(cmd string, args []string, env []string) (string, string, error) {\n\tcommand := exec.Command(cmd, args...)\n\tcommand.Env = env\n\n\tcmdOut, _ := command.StdoutPipe()\n\tcmdErr, _ := command.StderrPipe()\n\n\terr := command.Start()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tstdOutput, err := ioutil.ReadAll(cmdOut)\n\terrOutput, err := ioutil.ReadAll(cmdErr)\n\n\treturn string(stdOutput), string(errOutput), err\n}\n\nfunc Exec(cmd string, args ...string) (string, string, error) ", "output": "{\n\treturn ExecWithEnv(cmd, args, os.Environ())\n}"}
{"input": "package util\n\ntype Progress struct {\n\terrs chan error\n\tdone chan struct{}\n}\n\nfunc NewProgress(total int) *Progress {\n\tp := &Progress{make(chan error), make(chan struct{})}\n\tgo func() {\n\t\tcompleted := 0\n\t\terrorCount := 0\n\t\tfor err := range p.errs {\n\t\t\tif err == nil {\n\t\t\t\tcompleted += 1\n\t\t\t} else {\n\t\t\t\terrorCount += 1\n\t\t\t\tif FlagQuiet {\n\t\t\t\t\tWarnf(\"%s\", err)\n\t\t\t\t} else {\n\t\t\t\t\tWarnf(\"\\r%s                                    \\n\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tratio := 100.0 * (float64(completed) / float64(total))\n\t\t\tVerbosef(\"\\r%d of %d jobs complete (%0.2f%% done, %d errors)\",\n\t\t\t\tcompleted, total, ratio, errorCount)\n\t\t}\n\t\tVerbosef(\"\\n\")\n\t\tp.done <- struct{}{}\n\t}()\n\treturn p\n}\n\n\n\nfunc (p *Progress) Close() {\n\tif p == nil {\n\t\treturn\n\t}\n\tclose(p.errs)\n\t<-p.done\n}\n\nfunc (p *Progress) JobDone(err error) ", "output": "{\n\tif p == nil {\n\t\treturn\n\t}\n\tp.errs <- err\n}"}
{"input": "package fake\n\nimport (\n\tv1 \"github.com/gravitational/workshop/crd/controller/pkg/generated/clientset/versioned/typed/nginxcontroller/v1\"\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n)\n\ntype FakeTrainingV1 struct {\n\t*testing.Fake\n}\n\n\n\n\n\nfunc (c *FakeTrainingV1) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakeTrainingV1) Nginxes(namespace string) v1.NginxInterface ", "output": "{\n\treturn &FakeNginxes{c, namespace}\n}"}
{"input": "package sabar\n\nimport (\n\t\"reflect\"\n)\n\n\ntype Err struct {\n\tCode int    \n\tMsg  string \n}\n\n\ntype UnAuthErr struct {\n\tErr\n}\n\n\ntype UnkownAccountErr struct {\n\tErr\n}\n\n\n\nfunc NewUnAuthErr(code int, msg string) UnAuthErr {\n\treturn UnAuthErr{\n\t\tCode: code,\n\t\tMsg:  msg,\n\t}\n}\n\nfunc NewUnkownAccountErr(code int, msg string) UnkownAccountErr {\n\treturn UnkownAccountErr{\n\t\tCode: code,\n\t\tMsg:  msg,\n\t}\n}\n\nfunc IsUnAuthErr(err error) bool {\n\tt := reflect.TypeOf(err)\n\tif t == UnAuthErr {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc IsUnkownAccountErr(err error) bool {\n\tt := reflect.TypeOf(err)\n\tif t == UnkownAccountErr {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (this Err) Error() string ", "output": "{\n\treturn fmt.Sprintf(\"Error:%d %s\", this.Code, this.Msg)\n}"}
{"input": "package app\n\nimport (\n\tflags \"github.com/jessevdk/go-flags\"\n)\n\n\ntype Args struct {\n\tConfigFile string `short:\"c\" long:\"config\" description:\"Config File\" default:\"/etc/ansible-service-broker/config.yaml\"`\n\tVersion    bool   `short:\"v\" long:\"version\" description:\"Print version information\"`\n}\n\n\n\n\nfunc CreateArgs() (Args, error) ", "output": "{\n\targs := Args{}\n\n\t_, err := flags.Parse(&args)\n\tif err != nil {\n\t\treturn args, err\n\t}\n\treturn args, nil\n}"}
{"input": "package chunkstream\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\ntype testChunk struct {\n\tdata     []byte\n\treleased bool\n}\n\nvar _ Chunk = (*testChunk)(nil)\n\nfunc tc(d ...byte) *testChunk {\n\treturn &testChunk{\n\t\tdata: d,\n\t}\n}\n\nfunc (c *testChunk) String() string {\n\tpieces := make([]string, len(c.data))\n\tfor i, d := range c.data {\n\t\tpieces[i] = fmt.Sprintf(\"0x%02x\", d)\n\t}\n\treturn fmt.Sprintf(\"{%s}\", strings.Join(pieces, \", \"))\n}\n\n\n\nfunc (c *testChunk) Len() int {\n\treturn len(c.data)\n}\n\nfunc (c *testChunk) Release() {\n\tif c.released {\n\t\tpanic(\"double-free\")\n\t}\n\tc.released = true\n}\n\nfunc TestChunkNode(t *testing.T) {\n\tConvey(`A chunkNode wrapping a testing Chunk implementation`, t, func() {\n\t\tc := tc(0, 1, 2)\n\t\tn := newChunkNode(c)\n\n\t\tConvey(`Should call Chunk methods.`, func() {\n\t\t\tSo(n.Bytes(), ShouldResemble, []byte{0, 1, 2})\n\t\t})\n\n\t\tConvey(`When released, releases the wrapped Chunk.`, func() {\n\t\t\tn.release()\n\t\t\tSo(c.released, ShouldBeTrue)\n\n\t\t\tConvey(`If released again, panics.`, func() {\n\t\t\t\tSo(func() { n.release() }, ShouldPanic)\n\t\t\t})\n\t\t})\n\t})\n}\n\nfunc (c *testChunk) Bytes() []byte ", "output": "{\n\treturn c.data\n}"}
{"input": "package rorm\n\ntype rorm struct {\n\tredisQuerier *RedisQuerier\n}\n\nfunc NewROrm() ROrmer {\n\treturn new(rorm).Using(\"default\")\n}\n\nfunc (r *rorm) QueryHash(key string) HashQuerySeter {\n\treturn &hashQuerySet{\n\t\tquerySet: &querySet{\n\t\t\trorm: r,\n\t\t\tkey:  key,\n\t\t},\n\t}\n}\n\nfunc (r *rorm) QueryKeys(key string) KeysQuerySeter {\n\treturn &keysQuerySet{\n\t\tquerySet: &querySet{\n\t\t\trorm: r,\n\t\t\tkey:  key,\n\t\t},\n\t}\n}\n\nfunc (r *rorm) QueryString(key string) StringQuerySeter {\n\treturn &stringQuerySet{\n\t\tquerySet: &querySet{\n\t\t\trorm: r,\n\t\t\tkey:  key,\n\t\t},\n\t}\n}\n\nfunc (r *rorm) QueryZSet(key string) ZSetQuerySeter {\n\treturn &zsetQuerySet{\n\t\tquerySet: &querySet{\n\t\t\trorm: r,\n\t\t\tkey:  key,\n\t\t},\n\t}\n}\n\nfunc (r *rorm) QuerySet(key string) SetQuerySeter {\n\treturn &setQuerySet{\n\t\tquerySet: &querySet{\n\t\t\trorm: r,\n\t\t\tkey:  key,\n\t\t},\n\t}\n}\n\nfunc (r rorm) Using(alias string) ROrmer {\n\tclient, ok := redisRegistry[alias]\n\tif !ok {\n\t\tpanic(\"using reids '\" + alias + \"' not exist.\")\n\t}\n\tr.redisQuerier = &RedisQuerier{\n\t\tClient: client,\n\t}\n\treturn &r\n}\n\n\n\nfunc (r *rorm) Querier() Querier ", "output": "{\n\treturn r.redisQuerier\n}"}
{"input": "package proto\n\nimport (\n\t\"io\"\n\n\t\"github.com/gogo/protobuf/proto\"\n)\n\n\n\n\n\ntype Encoder struct{ w io.Writer }\n\n\n\nfunc (e *Encoder) Encode(m interface{}) error {\n\tbs, err := proto.Marshal(m.(proto.Message))\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = e.w.Write(bs)\n\treturn err\n}\n\nfunc NewEncoder(w io.Writer) *Encoder ", "output": "{\n\treturn &Encoder{w: w}\n}"}
{"input": "package meld\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\n\t\"github.com/timpalpant/rummy/deck\"\n\t\"github.com/timpalpant/rummy/scoring\"\n)\n\n\n\n\ntype Meld []deck.Card\n\nfunc (m Meld) Value() int {\n\ttotal := 0\n\tfor _, card := range m {\n\t\ttotal += scoring.Value(card)\n\t}\n\n\treturn total\n}\n\n\n\nfunc (m Meld) IsRun() bool {\n\tif len(m) < 3 {\n\t\treturn false\n\t}\n\n\tsort.Sort(deck.BySuitAndRank(m))\n\tfor i, card := range m[:len(m)-1] {\n\t\tif !deck.Sequential(card, m[i+1]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (m Meld) String() string {\n\tcards := make([]string, len(m))\n\tfor i, c := range m {\n\t\tcards[i] = deck.CardString(c)\n\t}\n\n\treturn fmt.Sprintf(\"%v\", cards)\n}\n\n\n\nfunc CanRummy(card deck.Card, melds []Meld) bool {\n\tfor _, m := range melds {\n\t\tif m.IsSet() && m[0].Rank == card.Rank {\n\t\t\treturn true\n\t\t} else if deck.Sequential(card, m[0]) || deck.Sequential(m[len(m)-1], card) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (m Meld) IsSet() bool ", "output": "{\n\tif len(m) < 3 {\n\t\treturn false\n\t}\n\n\trank := m[0].Rank\n\tfor _, card := range m {\n\t\tif card.Rank != rank {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}"}
{"input": "package lib_gc_log\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\n\n\nvar (\n\tTrace   *log.Logger\n\tInfo    *log.Logger\n\tWarning *log.Logger\n\tError   *log.Logger\n)\n\nvar LogLevel LOG_LEVEL = TRACE\n\nfunc Init(\n\ttraceHandle io.Writer,\n\tinfoHandle io.Writer,\n\twarningHandle io.Writer,\n\terrorHandle io.Writer) {\n\n\tTrace = log.New(traceHandle,\n\t\t\"TRACE: \",\n\t\tlog.Ldate|log.Ltime|log.Lmicroseconds|log.Lshortfile)\n\n\tInfo = log.New(infoHandle,\n\t\t\"INFO: \",\n\t\tlog.Ldate|log.Ltime|log.Lmicroseconds|log.Lshortfile)\n\n\tWarning = log.New(warningHandle,\n\t\t\"WARNING: \",\n\t\tlog.Ldate|log.Ltime|log.Lmicroseconds|log.Lshortfile)\n\n\tError = log.New(errorHandle,\n\t\t\"ERROR: \",\n\t\tlog.Ldate|log.Ltime|log.Lmicroseconds|log.Lshortfile)\n}\n\nfunc init() ", "output": "{\n\tInit(os.Stdout, os.Stdout, os.Stdout, os.Stdout)\n}"}
{"input": "package scene\n\nimport (\n\t\"github.com/mikee385/GolangRayTracer/geometry\"\n\t\"github.com/mikee385/GolangRayTracer/material\"\n\t\"math\"\n)\n\ntype Sphere struct {\n\tcenter   geometry.Point3D\n\tradius   float32\n\tradius2  float32\n\tmaterial material.Material\n}\n\n\n\nfunc (sphere Sphere) Center() geometry.Point3D {\n\treturn sphere.center\n}\n\nfunc (sphere Sphere) Radius() float32 {\n\treturn sphere.radius\n}\n\nfunc (sphere Sphere) Intersect(ray geometry.Ray3D) (float32, bool) {\n\tvar sphereToRay = geometry.NewVector_BetweenPoints(ray.Origin, sphere.center)\n\tvar b = geometry.Dot(sphereToRay, ray.Direction.ToVector())\n\tif b < 0.0 {\n\t\treturn 0.0, false\n\t}\n\n\tvar d2 = geometry.Dot(sphereToRay, sphereToRay) - b*b\n\tif d2 > sphere.radius2 {\n\t\treturn 0.0, false\n\t}\n\n\tvar c = float32(math.Sqrt(float64(sphere.radius2 - d2)))\n\tvar t = b - c\n\tif t < 0 {\n\t\tt = b + c\n\t}\n\n\treturn t, true\n}\n\nfunc (sphere Sphere) Normal(point geometry.Point3D) geometry.Direction3D {\n\treturn geometry.NewDirection_BetweenPoints(sphere.center, point)\n}\n\nfunc (sphere Sphere) Material(point geometry.Point3D) material.Material {\n\treturn sphere.material\n}\n\nfunc NewSphere(center geometry.Point3D, radius float32, material material.Material) Sphere ", "output": "{\n\treturn Sphere{\n\t\tcenter:   center,\n\t\tradius:   radius,\n\t\tradius2:  radius * radius,\n\t\tmaterial: material,\n\t}\n}"}
{"input": "package scs\n\nimport (\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tsetStored        = \"STORED\"\n\tStatCmdSet       = \"cmd_set\"\n\tStatCmdSetHits   = \"set_hits\"\n\tStatCmdSetMisses = \"set_misses\"\n\tkeyLimit         = 249\n\tvalueLimit       = 8*1024 - 1 \n)\n\n\nfunc Set(s *Store, r io.Reader, w io.Writer, args string) {\n\terr := ValidateBytes(args, validArgBytes)\n\tif err != nil {\n\t\tWriteError(w, InvalidChars{err, \"in set arguments\"})\n\t\treturn\n\t}\n\tif len(args) > keyLimit {\n\t\tWriteError(w, ExceededKeyLengthLimit(len(args)))\n\t\treturn\n\t}\n\tdata, err := ReadToDelim(r, []byte(commandDelim))\n\tif err != nil {\n\t\ts.logFunc(err)\n\t\tWriteError(w, err)\n\t}\n\tdata = strings.TrimSuffix(data, commandDelim)\n\tif len(data) > valueLimit {\n\t\tWriteError(w, ExceededValueLengthLimit(len(data)))\n\t\treturn\n\t}\n\terr = s.Set(args, data)\n\tif err != nil {\n\t\tWriteError(w, err)\n\t\ts.SetStat(StatCmdSetMisses, Increment)\n\t} else {\n\t\tw.Write([]byte(setStored + commandDelim))\n\t\ts.SetStat(StatCmdSetHits, Increment)\n\t}\n\ts.SetStat(StatCmdSet, Increment)\n}\n\n\n\ntype ExceededKeyLengthLimit int\n\nfunc (e ExceededKeyLengthLimit) Error() string {\n\treturn \"key length (\" + strconv.Itoa(int(e)) + \") exceeded maxiumum allowed (\" + strconv.Itoa(keyLimit) + \")\"\n}\n\ntype ExceededValueLengthLimit int\n\n\n\nfunc (e ExceededValueLengthLimit) Error() string ", "output": "{\n\treturn \"value length (\" + strconv.Itoa(int(e)) + \") exceeded maxiumum allowed (\" + strconv.Itoa(valueLimit) + \")\"\n}"}
{"input": "package atomic\n\nimport (\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"sync/atomic\"\n)\n\n\ntype Uint32 struct {\n\t_ nocmp \n\n\tv uint32\n}\n\n\nfunc NewUint32(val uint32) *Uint32 {\n\treturn &Uint32{v: val}\n}\n\n\nfunc (i *Uint32) Load() uint32 {\n\treturn atomic.LoadUint32(&i.v)\n}\n\n\nfunc (i *Uint32) Add(delta uint32) uint32 {\n\treturn atomic.AddUint32(&i.v, delta)\n}\n\n\nfunc (i *Uint32) Sub(delta uint32) uint32 {\n\treturn atomic.AddUint32(&i.v, ^(delta - 1))\n}\n\n\nfunc (i *Uint32) Inc() uint32 {\n\treturn i.Add(1)\n}\n\n\nfunc (i *Uint32) Dec() uint32 {\n\treturn i.Sub(1)\n}\n\n\nfunc (i *Uint32) CAS(old, new uint32) (swapped bool) {\n\treturn atomic.CompareAndSwapUint32(&i.v, old, new)\n}\n\n\nfunc (i *Uint32) Store(val uint32) {\n\tatomic.StoreUint32(&i.v, val)\n}\n\n\n\n\n\nfunc (i *Uint32) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(i.Load())\n}\n\n\nfunc (i *Uint32) UnmarshalJSON(b []byte) error {\n\tvar v uint32\n\tif err := json.Unmarshal(b, &v); err != nil {\n\t\treturn err\n\t}\n\ti.Store(v)\n\treturn nil\n}\n\n\nfunc (i *Uint32) String() string {\n\tv := i.Load()\n\treturn strconv.FormatUint(uint64(v), 10)\n}\n\nfunc (i *Uint32) Swap(val uint32) (old uint32) ", "output": "{\n\treturn atomic.SwapUint32(&i.v, val)\n}"}
{"input": "package plus\n\n\n\ntype btree struct {\n\troot             node\n\tnodeSize, number uint64\n}\n\nfunc (tree *btree) insert(key Key) {\n\tif tree.root == nil {\n\t\tn := newLeafNode(tree.nodeSize)\n\t\tn.insert(tree, key)\n\t\ttree.number = 1\n\t\treturn\n\t}\n\n\tresult := tree.root.insert(tree, key)\n\tif result {\n\t\ttree.number++\n\t}\n\n\tif tree.root.needsSplit(tree.nodeSize) {\n\t\ttree.root = split(tree, nil, tree.root)\n\t}\n}\n\n\n\n\nfunc (tree *btree) Insert(keys ...Key) {\n\tfor _, key := range keys {\n\t\ttree.insert(key)\n\t}\n}\n\n\n\nfunc (tree *btree) Iter(key Key) Iterator {\n\tif tree.root == nil {\n\t\treturn nilIterator()\n\t}\n\n\treturn tree.root.find(key)\n}\n\nfunc (tree *btree) get(key Key) Key {\n\titer := tree.root.find(key)\n\tif !iter.Next() {\n\t\treturn nil\n\t}\n\n\tif iter.Value().Compare(key) == 0 {\n\t\treturn iter.Value()\n\t}\n\n\treturn nil\n}\n\n\n\n\nfunc (tree *btree) Get(keys ...Key) Keys {\n\tresults := make(Keys, 0, len(keys))\n\tfor _, k := range keys {\n\t\tresults = append(results, tree.get(k))\n\t}\n\n\treturn results\n}\n\n\nfunc (tree *btree) Len() uint64 {\n\treturn tree.number\n}\n\nfunc newBTree(nodeSize uint64) *btree {\n\treturn &btree{\n\t\tnodeSize: nodeSize,\n\t\troot:     newLeafNode(nodeSize),\n\t}\n}\n\nfunc keySearch(keys keys, key Key) int ", "output": "{\n\tlow, high := 0, len(keys)-1\n\tvar mid int\n\tfor low <= high {\n\t\tmid = (high + low) / 2\n\t\tswitch keys[mid].Compare(key) {\n\t\tcase 1:\n\t\t\tlow = mid + 1\n\t\tcase -1:\n\t\t\thigh = mid - 1\n\t\tcase 0:\n\t\t\treturn mid\n\t\t}\n\t}\n\treturn low\n}"}
{"input": "package web\n\nimport (\n\t\"github.com/smartystreets/acidic/contracts\"\n\t\"github.com/smartystreets/acidic/contracts/models\"\n\t\"github.com/smartystreets/detour\"\n)\n\ntype Controller struct {\n\tsender contracts.MessageSender\n}\n\nfunc NewController(sender contracts.MessageSender) *Controller {\n\treturn &Controller{sender: sender}\n}\n\n\n\nfunc (this *Controller) Store(input *models.StoreInput) detour.Renderer {\n\tdefer input.Close()\n\treturn this.handle(input.ToMessage())\n}\nfunc (this *Controller) Delete(input *models.DeleteInput) detour.Renderer {\n\treturn this.handle(input.ToMessage())\n}\n\nfunc (this *Controller) Commit(input *models.TransactionInput) detour.Renderer {\n\treturn this.handle(input.ToCommitMessage())\n}\nfunc (this *Controller) Abort(input *models.TransactionInput) detour.Renderer {\n\treturn this.handle(input.ToAbortMessage())\n}\n\nfunc (this *Controller) handle(message interface{}) detour.Renderer {\n\tresult := this.sender.Send(message)\n\treturn NewApplicationResultRenderer(result)\n}\n\nfunc (this *Controller) Load(input *models.LoadInput) detour.Renderer ", "output": "{\n\treturn this.handle(input.ToMessage())\n}"}
{"input": "package main\n\nimport (\n\t\"time\"\n\n\t\"github.com/kataras/iris\"\n)\n\nconst refreshEvery = 10 * time.Second\n\nfunc main() {\n\tapp := iris.New()\n\tapp.Use(iris.Cache304(refreshEvery))\n\n\n\n\tapp.Get(\"/\", greet)\n\tapp.Run(iris.Addr(\":8080\"))\n}\n\n\n\nfunc greet(ctx iris.Context) ", "output": "{\n\tctx.Header(\"X-Custom\", \"my  custom header\")\n\tctx.Writef(\"Hello World! %s\", time.Now())\n}"}
{"input": "package databasemanagement\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype UpdateDatabaseParametersResult struct {\n\n\tStatus map[string]DatabaseParameterUpdateStatus `mandatory:\"true\" json:\"status\"`\n}\n\n\n\nfunc (m UpdateDatabaseParametersResult) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package servicecatalog\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/kubernetes-incubator/service-catalog/pkg/apis/servicecatalog/v1beta1\"\n\t\"k8s.io/apimachinery/pkg/api/errors\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\n\nfunc (sdk *SDK) RetrieveBrokers() ([]v1beta1.ClusterServiceBroker, error) {\n\tbrokers, err := sdk.ServiceCatalog().ClusterServiceBrokers().List(v1.ListOptions{})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to list brokers (%s)\", err)\n\t}\n\n\treturn brokers.Items, nil\n}\n\n\nfunc (sdk *SDK) RetrieveBroker(name string) (*v1beta1.ClusterServiceBroker, error) {\n\tbroker, err := sdk.ServiceCatalog().ClusterServiceBrokers().Get(name, v1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get broker '%s' (%s)\", name, err)\n\t}\n\n\treturn broker, nil\n}\n\n\nfunc (sdk *SDK) RetrieveBrokerByClass(class *v1beta1.ClusterServiceClass,\n) (*v1beta1.ClusterServiceBroker, error) {\n\tbrokerName := class.Spec.ClusterServiceBrokerName\n\tbroker, err := sdk.ServiceCatalog().ClusterServiceBrokers().Get(brokerName, v1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn broker, nil\n}\n\n\n\n\nfunc (sdk *SDK) Sync(name string, retries int) error ", "output": "{\n\tfor j := 0; j < retries; j++ {\n\t\tcatalog, err := sdk.RetrieveBroker(name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcatalog.Spec.RelistRequests = catalog.Spec.RelistRequests + 1\n\n\t\t_, err = sdk.ServiceCatalog().ClusterServiceBrokers().Update(catalog)\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif !errors.IsConflict(err) {\n\t\t\treturn fmt.Errorf(\"could not sync service broker (%s)\", err)\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"could not sync service broker after %d tries\", retries)\n}"}
{"input": "package main\n\n\n\nfunc main() {\n}\n\n\n\nfunc Compute(indata []string, result chan<- []string, fork_size int) {\n\n\tsize_indata := len(indata)\n\n\tif size_indata <= fork_size {\n\t\tgo ComputeDirect(indata, result)\n\t\treturn\n\t}\n\n\tresult_fork_a := make(chan []string)\n\tresult_fork_b := make(chan []string)\n\n\tsplit_at := size_indata / 2\n\n\tgo Compute(indata[:split_at], result_fork_a, fork_size)\n\tgo Compute(indata[split_at:size_indata], result_fork_b, fork_size)\n\n\tvar subres []string\n\tresult <- append(append(subres, <-result_fork_a...), <-result_fork_b...)\n}\n\n\n\n\n\nfunc ComputeDirect(indata []string, result chan<- []string) ", "output": "{\n\n\tvar res []string\n\tfor i := 0; i < len(indata); i++ {\n\t\ttmp := \"\"\n\t\tfor j := (len(indata[i]) - 1); j > -1; j-- {\n\t\t\ttmp += string(indata[i][j])\n\t\t}\n\t\tres = append(res, tmp)\n\t}\n\tresult <- res\n}"}
{"input": "package web\n\nimport (\n\t\"github.com/majestrate/bdsmail/lib/db\"\n\t\"github.com/majestrate/bdsmail/lib/web/admin\"\n\t\"github.com/majestrate/bdsmail/lib/web/webmail\"\n\t\"net/http\"\n)\n\n\n\n\nfunc NewMiddleware(assetsdir string, dao db.DB) http.Handler ", "output": "{\n\tr := newRouter()\n\tr.Handle(\"/admin\", admin.New(dao))\n\tr.Handle(\"/mail\", webmail.New(dao))\n\tr.HandleDefault(http.FileServer(http.Dir(assetsdir)))\n\treturn r\n}"}
{"input": "package main\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"os/exec\"\n\t\"time\"\n)\n\ntype noneDeploy struct{}\n\nvar _ deployer = noneDeploy{}\n\nfunc (n noneDeploy) Up() error {\n\tlog.Print(\"Noop Up()\")\n\treturn nil\n}\n\nfunc (n noneDeploy) IsUp() error {\n\tlog.Print(\"Noop IsUp()\")\n\treturn nil\n}\n\nfunc (n noneDeploy) DumpClusterLogs(localPath, gcsPath string) error {\n\tlog.Print(\"Noop DumpClusterLogs()\")\n\treturn nil\n}\n\nfunc (n noneDeploy) TestSetup() error {\n\tlog.Print(\"Noop TestSetup()\")\n\treturn nil\n}\n\n\n\nfunc (n noneDeploy) GetClusterCreated(gcpProject string) (time.Time, error) {\n\treturn time.Time{}, errors.New(\"not implemented\")\n}\n\nfunc (n noneDeploy) KubectlCommand() (*exec.Cmd, error) {\n\tlog.Print(\"Noop KubectlCommand()\")\n\treturn nil, nil\n}\n\nfunc (n noneDeploy) Down() error ", "output": "{\n\tlog.Print(\"Noop Down()\")\n\treturn nil\n}"}
{"input": "package fake\n\nimport (\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n\tv1alpha2 \"k8s.io/kops/pkg/client/clientset_generated/clientset/typed/kops/v1alpha2\"\n)\n\ntype FakeKopsV1alpha2 struct {\n\t*testing.Fake\n}\n\nfunc (c *FakeKopsV1alpha2) Clusters(namespace string) v1alpha2.ClusterInterface {\n\treturn &FakeClusters{c, namespace}\n}\n\nfunc (c *FakeKopsV1alpha2) InstanceGroups(namespace string) v1alpha2.InstanceGroupInterface {\n\treturn &FakeInstanceGroups{c, namespace}\n}\n\n\n\nfunc (c *FakeKopsV1alpha2) SSHCredentials(namespace string) v1alpha2.SSHCredentialInterface {\n\treturn &FakeSSHCredentials{c, namespace}\n}\n\n\n\nfunc (c *FakeKopsV1alpha2) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakeKopsV1alpha2) Keysets(namespace string) v1alpha2.KeysetInterface ", "output": "{\n\treturn &FakeKeysets{c, namespace}\n}"}
{"input": "package jit\n\nconst SUPPORTED = true\n\n\n\nfunc (asm *Asm) epilogue() *Asm {\n\treturn asm.Bytes(0xc3) \n}\n\nfunc (asm *Asm) prologue() *Asm ", "output": "{\n\treturn asm.Bytes(0x48, 0x8b, 0x7c, 0x24, 0x08) \n}"}
{"input": "package proxy\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/AaronO/gogo-proxy\"\n)\n\nfunc TestRoundrobinEmpty(t *testing.T) {\n\tbalancer := proxy.Roundrobin()\n\n\tif _, err := balancer(nil); err == nil {\n\t\tt.Fatalf(\"Roundrobin should fail when given no hosts\")\n\t}\n}\n\n\n\nfunc TestRoundrobin(t *testing.T) {\n\tbalancer := proxy.Roundrobin(\"1\", \"2\", \"3\")\n\n\thosts := []string{}\n\n\tfor i := 0; i < 7; i++ {\n\t\thost, err := balancer(nil)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\thosts = append(hosts, host)\n\t}\n\n\tequal := reflect.DeepEqual(\n\t\thosts,\n\t\t[]string{\"1\", \"2\", \"3\", \"1\", \"2\", \"3\", \"1\"},\n\t)\n\n\tif !equal {\n\t\tt.Fatalf(\"Roundrobin did not generate expected hosts\")\n\t}\n}\n\nfunc TestRandomEmpty(t *testing.T) ", "output": "{\n\tbalancer := proxy.Random()\n\n\tif _, err := balancer(nil); err == nil {\n\t\tt.Fatalf(\"Random should fail when given no hosts\")\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/devfeel/dotweb\"\n\t\"github.com/devfeel/dotweb/cache\"\n\t\"github.com/devfeel/dotweb/framework/file\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tapp := dotweb.New()\n\n\tapp.SetLogPath(file.GetCurrentDirectory())\n\n\n\tInitRoute(app.HttpServer)\n\n\n\tapp.SetCache(cache.NewRuntimeCache())\n\n\terr := app.Cache().Set(\"g\", \"gv\", 20)\n\tif err != nil {\n\t\tfmt.Println(\"Cache Set \", err)\n\t}\n\n\tport := 8080\n\tfmt.Println(\"dotweb.StartServer => \" + strconv.Itoa(port))\n\terr = app.StartServer(port)\n\tfmt.Println(\"dotweb.StartServer error => \", err)\n}\n\ntype UserInfo struct {\n\tUserName string\n\tSex      int\n}\n\nfunc One(ctx dotweb.Context) error {\n\tg, err := ctx.Cache().GetString(\"g\")\n\tif err != nil {\n\t\tg = err.Error()\n\t}\n\t_, err = ctx.Cache().Incr(\"count\")\n\treturn ctx.WriteString(\"One [\" + g + \"] \" + fmt.Sprint(err))\n}\n\n\n\nfunc InitRoute(server *dotweb.HttpServer) {\n\tserver.Router().GET(\"/1\", One)\n\tserver.Router().GET(\"/2\", Two)\n}\n\nfunc Two(ctx dotweb.Context) error ", "output": "{\n\tg, err := ctx.Cache().GetString(\"g\")\n\tif err != nil {\n\t\tg = err.Error()\n\t}\n\t_, err = ctx.Cache().Incr(\"count\")\n\tc, _ := ctx.Cache().GetString(\"count\")\n\treturn ctx.WriteString(\"Two [\" + g + \"] [\" + c + \"] \" + fmt.Sprint(err))\n}"}
{"input": "package migrate\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n)\n\n\ntype Postgres struct {\n\tdb   *sql.DB\n\tlock *sql.Tx\n}\n\n\nfunc NewPostgres(db *sql.DB) *Postgres {\n\treturn &Postgres{db, nil}\n}\n\n\n\n\n\nfunc (p *Postgres) Lock() error {\n\tif p.lock != nil {\n\t\treturn errors.New(\"lock already acquired\")\n\t}\n\n\t_, err := p.db.Exec(\"CREATE TABLE IF NOT EXISTS schema_migrations_lock(lock boolean PRIMARY KEY);\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttx, err := p.db.Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = tx.Exec(\"LOCK TABLE schema_migrations_lock IN ACCESS EXCLUSIVE MODE NOWAIT\")\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn err\n\t}\n\n\tp.lock = tx\n\treturn nil\n}\n\n\nfunc (p *Postgres) Unlock() error {\n\tif p.lock == nil {\n\t\treturn errors.New(\"unable to unlock, lock not acquired\")\n\t}\n\terr := p.lock.Rollback()\n\tp.lock = nil\n\treturn err\n}\n\n\n\n\n\n\nfunc (p *Postgres) Apply(m Migration) error {\n\ttx, err := p.db.Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer tx.Rollback()\n\n\tif _, err := tx.Exec(\"SET timezone='UTC';\"); err != nil {\n\t\treturn err\n\t}\n\n\tif err = m.Migrate(tx); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := tx.Exec(\"INSERT INTO schema_migrations(identifier) VALUES ($1)\", m.ID()); err != nil {\n\t\treturn err\n\t}\n\treturn tx.Commit()\n}\n\nfunc (p *Postgres) Migrations() ([]string, error) ", "output": "{\n\t_, err := p.db.Exec(\"CREATE TABLE IF NOT EXISTS schema_migrations(identifier varchar(255) NOT NULL PRIMARY KEY, migrated_at timestamp WITH TIME ZONE NOT NULL DEFAULT (NOW() AT TIME ZONE 'UTC'));\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trows, err := p.db.Query(\"SELECT identifier FROM schema_migrations ORDER BY identifier\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar ids []string\n\tfor rows.Next() {\n\t\tvar id string\n\t\tif err := rows.Scan(&id); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tids = append(ids, id)\n\t}\n\treturn ids, rows.Err()\n}"}
{"input": "package comm\n\nimport (\n\t\"io/ioutil\"\n\t\"time\"\n\n\t\"github.com/hyperledger/fabric/common/crypto/tlsgen\"\n\t\"github.com/hyperledger/fabric/core/comm\"\n\t\"github.com/pkg/errors\"\n)\n\ntype genTLSCertFunc func() (*tlsgen.CertKeyPair, error)\n\n\ntype Config struct {\n\tCertPath       string\n\tKeyPath        string\n\tPeerCACertPath string\n\tTimeout        time.Duration\n}\n\n\n\n\nfunc (conf Config) ToSecureOptions(newSelfSignedTLSCert genTLSCertFunc) (comm.SecureOptions, error) {\n\tif conf.PeerCACertPath == \"\" {\n\t\treturn comm.SecureOptions{}, nil\n\t}\n\tcaBytes, err := loadFile(conf.PeerCACertPath)\n\tif err != nil {\n\t\treturn comm.SecureOptions{}, errors.WithStack(err)\n\t}\n\tvar keyBytes, certBytes []byte\n\tif conf.KeyPath == \"\" && conf.CertPath == \"\" {\n\t\ttlsCert, err := newSelfSignedTLSCert()\n\t\tif err != nil {\n\t\t\treturn comm.SecureOptions{}, err\n\t\t}\n\t\tkeyBytes, certBytes = tlsCert.Key, tlsCert.Cert\n\t} else {\n\t\tkeyBytes, err = loadFile(conf.KeyPath)\n\t\tif err != nil {\n\t\t\treturn comm.SecureOptions{}, errors.WithStack(err)\n\t\t}\n\t\tcertBytes, err = loadFile(conf.CertPath)\n\t\tif err != nil {\n\t\t\treturn comm.SecureOptions{}, errors.WithStack(err)\n\t\t}\n\t}\n\treturn comm.SecureOptions{\n\t\tKey:               keyBytes,\n\t\tCertificate:       certBytes,\n\t\tUseTLS:            true,\n\t\tServerRootCAs:     [][]byte{caBytes},\n\t\tRequireClientCert: true,\n\t}, nil\n}\n\n\n\nfunc loadFile(path string) ([]byte, error) ", "output": "{\n\tb, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"Failed opening file %s: %v\", path, err)\n\t}\n\treturn b, nil\n}"}
{"input": "package keytransform\n\nimport ds \"github.com/ipfs/go-datastore\"\n\n\ntype Pair struct {\n\tConvert KeyMapping\n\tInvert  KeyMapping\n}\n\n\n\nfunc (t *Pair) InvertKey(k ds.Key) ds.Key {\n\treturn t.Invert(k)\n}\n\nvar _ KeyTransform = (*Pair)(nil)\n\n\n\n\n\n\ntype PrefixTransform struct {\n\tPrefix ds.Key\n}\n\n\nfunc (p PrefixTransform) ConvertKey(k ds.Key) ds.Key {\n\treturn p.Prefix.Child(k)\n}\n\n\nfunc (p PrefixTransform) InvertKey(k ds.Key) ds.Key {\n\tif p.Prefix.String() == \"/\" {\n\t\treturn k\n\t}\n\n\tif !p.Prefix.IsAncestorOf(k) {\n\t\tpanic(\"expected prefix not found\")\n\t}\n\n\ts := k.String()[len(p.Prefix.String()):]\n\treturn ds.RawKey(s)\n}\n\nvar _ KeyTransform = (*PrefixTransform)(nil)\n\nfunc (t *Pair) ConvertKey(k ds.Key) ds.Key ", "output": "{\n\treturn t.Convert(k)\n}"}
{"input": "package engine\n\nimport (\n\t\"github.com/nicholaskh/pushd/engine/storage\"\n)\n\n\nfunc history(channel string, ts int64) (result []interface{}, err error) {\n\tresult = storage.MsgCache.GetRange(channel, ts)\n\n\treturn\n}\n\n\n\n\nfunc fullHistory(channel string, ts int64) (result []interface{}, err error) ", "output": "{\n\tresult, err = storage.FetchHistory(channel, ts)\n\n\treturn\n}"}
{"input": "package data\n\nimport (\n\t\"github.com/boltdb/bolt\"\n\t\"gopkg.in/mgo.v2/bson\"\n)\n\ntype Server struct {\n\tId         bson.ObjectId\n\tBalancerId bson.ObjectId\n\tLabel      string\n\tSettings   ServerSettings\n}\n\ntype ServerSettings struct {\n\tAddress      string\n\tWeight       int\n\tAvailability Availability\n}\n\nfunc ListServersByBalancer(bal *Balancer) ([]Server, error) {\n\tsrvs := []Server{}\n\terr := DB.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"servers\"))\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tsrv := Server{}\n\t\t\terr := bson.Unmarshal(v, &srv)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif srv.BalancerId.Hex() != bal.Id.Hex() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsrvs = append(srvs, srv)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn srvs, nil\n}\n\n\n\nfunc (s *Server) Balancer() (*Balancer, error) {\n\treturn GetBalancer(s.BalancerId)\n}\n\nfunc (s *Server) Put() error {\n\tif !s.Id.Valid() {\n\t\ts.Id = bson.NewObjectId()\n\t}\n\treturn DB.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"servers\"))\n\t\tp, err := bson.Marshal(s)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn b.Put([]byte(s.Id.Hex()), p)\n\t})\n}\n\nfunc GetServer(id bson.ObjectId) (*Server, error) ", "output": "{\n\tsrv := &Server{}\n\terr := DB.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"servers\"))\n\t\tv := b.Get([]byte(id.Hex()))\n\t\tif v == nil {\n\t\t\tsrv = nil\n\t\t\treturn nil\n\t\t}\n\t\terr := bson.Unmarshal(v, srv)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn srv, nil\n}"}
{"input": "package internet_test\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"testing\"\n\n\t\"v2ray.com/core/common\"\n\t\"v2ray.com/core/transport/internet\"\n)\n\n\n\nfunc TestRegisterListenerController(t *testing.T) ", "output": "{\n\tvar gotFd uintptr\n\n\tcommon.Must(internet.RegisterListenerController(func(network string, addr string, fd uintptr) error {\n\t\tgotFd = fd\n\t\treturn nil\n\t}))\n\n\tconn, err := internet.ListenSystemPacket(context.Background(), &net.UDPAddr{\n\t\tIP: net.IPv4zero,\n\t}, nil)\n\tcommon.Must(err)\n\tcommon.Must(conn.Close())\n\n\tif gotFd == 0 {\n\t\tt.Error(\"expected none-zero fd, but actually 0\")\n\t}\n}"}
{"input": "package structural\n\nimport (\n\t\"fmt\"\n)\n\n\ntype CarModel struct {\n}\n\n\nfunc NewCarModel() *CarModel {\n\treturn &CarModel{}\n}\n\n\nfunc (c *CarModel) SetModel() {\n\tfmt.Fprintf(outputWriter, \" CarModel - SetModel\\n\")\n}\n\n\ntype CarEngine struct {\n}\n\n\nfunc NewCarEngine() *CarEngine {\n\treturn &CarEngine{}\n}\n\n\nfunc (c *CarEngine) SetEngine() {\n\tfmt.Fprintf(outputWriter, \" CarEngine - SetEngine\\n\")\n}\n\n\ntype CarBody struct {\n}\n\n\n\n\n\nfunc (c *CarBody) SetBody() {\n\tfmt.Fprintf(outputWriter, \" CarBody - SetBody\\n\")\n}\n\n\ntype CarAccessories struct {\n}\n\n\nfunc NewCarAccessories() *CarAccessories {\n\treturn &CarAccessories{}\n}\n\n\nfunc (c *CarAccessories) SetAccessories() {\n\tfmt.Fprintf(outputWriter, \" CarAccessories - SetAccessories\\n\")\n}\n\n\ntype CarFacade struct {\n\taccessories *CarAccessories\n\tbody        *CarBody\n\tengine      *CarEngine\n\tmodel       *CarModel\n}\n\n\nfunc NewCarFacade() *CarFacade {\n\treturn &CarFacade{\n\t\taccessories: NewCarAccessories(),\n\t\tbody:        NewCarBody(),\n\t\tengine:      NewCarEngine(),\n\t\tmodel:       NewCarModel(),\n\t}\n}\n\n\nfunc (c *CarFacade) CreateCompleteCar() {\n\tfmt.Fprintf(outputWriter, \"******** Creating a Car **********\\n\")\n\tc.model.SetModel()\n\tc.engine.SetEngine()\n\tc.body.SetBody()\n\tc.accessories.SetAccessories()\n\tfmt.Fprintf(outputWriter, \"******** Car creation is completed. **********\\n\")\n}\n\nfunc NewCarBody() *CarBody ", "output": "{\n\treturn &CarBody{}\n}"}
{"input": "package image\n\n\ntype JPG struct {\n\tRaw  []byte\n\tname string\n}\n\n\nfunc (j *JPG) Name() string {\n\treturn j.name\n}\n\n\n\n\nfunc (j *JPG) Data(req Request) []byte ", "output": "{\n\treturn j.Raw\n}"}
{"input": "package group\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\tlog \"github.com/Sirupsen/logrus\"\n\t\"github.com/juliengk/go-utils\"\n\t\"github.com/kassisol/hbm/cli/command\"\n\t\"github.com/kassisol/hbm/storage\"\n\t\"github.com/spf13/cobra\"\n)\n\nfunc newFindCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse:   \"find [name]\",\n\t\tShort: \"Verify if group exists in the whitelist\",\n\t\tLong:  findDescription,\n\t\tRun:   runFind,\n\t}\n\n\treturn cmd\n}\n\n\n\nvar findDescription = `\nVerify if group exists in the whitelist\n\n`\n\nfunc runFind(cmd *cobra.Command, args []string) ", "output": "{\n\tdefer utils.RecoverFunc()\n\n\ts, err := storage.NewDriver(\"sqlite\", command.AppPath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer s.End()\n\n\tif len(args) < 1 || len(args) > 1 {\n\t\tcmd.Usage()\n\t\tos.Exit(-1)\n\t}\n\n\tresult := s.FindGroup(args[0])\n\n\tfmt.Println(result)\n}"}
{"input": "package zk\n\nimport \"github.com/go-kit/kit/log\"\n\n\ntype Registrar struct {\n\tclient  Client\n\tservice Service\n\tlogger  log.Logger\n}\n\n\n\ntype Service struct {\n\tPath string \n\tName string \n\tData []byte \n\tnode string \n}\n\n\n\n\n\n\nfunc (r *Registrar) Register() {\n\tif err := r.client.Register(&r.service); err != nil {\n\t\tr.logger.Log(\"err\", err)\n\t} else {\n\t\tr.logger.Log(\"action\", \"register\")\n\t}\n}\n\n\nfunc (r *Registrar) Deregister() {\n\tif err := r.client.Deregister(&r.service); err != nil {\n\t\tr.logger.Log(\"err\", err)\n\t} else {\n\t\tr.logger.Log(\"action\", \"deregister\")\n\t}\n}\n\nfunc NewRegistrar(client Client, service Service, logger log.Logger) *Registrar ", "output": "{\n\treturn &Registrar{\n\t\tclient:  client,\n\t\tservice: service,\n\t\tlogger: log.NewContext(logger).With(\n\t\t\t\"service\", service.Name,\n\t\t\t\"path\", service.Path,\n\t\t\t\"data\", string(service.Data),\n\t\t),\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\tosexec \"os/exec\"\n\t\"path/filepath\"\n)\n\n\nfunc exec(args ...string) error {\n\tcmd := osexec.Command(args[0], args[1:]...)\n\tout, err := cmd.CombinedOutput()\n\tswitch err := err.(type) {\n\tcase nil:\n\t\treturn nil\n\tcase *osexec.ExitError:\n\t\treturn fmt.Errorf(\"failed to run %q:\\n%v\", args, string(out))\n\tdefault:\n\t\treturn err\n\t}\n}\n\n\nfunc execVerbose(args ...string) error {\n\tcmd := osexec.Command(args[0], args[1:]...)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\treturn cmd.Run()\n}\n\n\n\n\n\nfunc execComposeVerbose(dir string, args ...string) error {\n\treturn execVerbose(append(\n\t\t[]string{\"docker-compose\", \"--ansi=never\", \"-f\", filepath.Join(dir, \"docker-compose.yml\")},\n\t\targs...)...)\n}\n\n\nfunc execDocker(args ...string) error {\n\treturn exec(append([]string{\"docker\"}, args...)...)\n}\n\nfunc execCompose(dir string, args ...string) error ", "output": "{\n\treturn exec(append(\n\t\t[]string{\"docker-compose\", \"--ansi=never\", \"-f\", filepath.Join(dir, \"docker-compose.yml\")},\n\t\targs...)...)\n}"}
{"input": "package syncutil\n\nimport (\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"golang.org/x/net/context\"\n)\n\n\n\n\ntype TimedMutex struct {\n\tmu       *Mutex    \n\tlockedAt time.Time \n\tisLocked int32     \n\n\tcb TimingFn\n}\n\n\n\n\ntype TimingFn func(heldFor time.Duration)\n\n\n\n\nfunc ThresholdLogger(\n\tctx context.Context,\n\twarnDuration time.Duration,\n\tprintf func(context.Context, string, ...interface{}),\n\trecord TimingFn,\n) TimingFn {\n\treturn func(heldFor time.Duration) {\n\t\trecord(heldFor)\n\t\tif heldFor > warnDuration {\n\t\t\tpc, _, _, ok := runtime.Caller(2)\n\t\t\tfun := \"?\"\n\t\t\tif ok {\n\t\t\t\tif f := runtime.FuncForPC(pc); f != nil {\n\t\t\t\t\tfun = f.Name()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\n\t\t\t\tctx, \"mutex held by %s for %s (>%s):\\n%s\",\n\t\t\t\tfun, heldFor, warnDuration, debug.Stack(),\n\t\t\t)\n\t\t}\n\t}\n}\n\n\n\n\n\nfunc MakeTimedMutex(cb TimingFn) TimedMutex {\n\treturn TimedMutex{\n\t\tcb: cb,\n\t\tmu: &Mutex{},\n\t}\n}\n\n\nfunc (tm *TimedMutex) Lock() {\n\ttm.mu.Lock()\n\tatomic.StoreInt32(&tm.isLocked, 1)\n\ttm.lockedAt = time.Now()\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (tm *TimedMutex) AssertHeld() {\n\tisLocked := atomic.LoadInt32(&tm.isLocked)\n\tif isLocked == 0 {\n\t\tpanic(\"mutex is not locked\")\n\t}\n}\n\nfunc (tm *TimedMutex) Unlock() ", "output": "{\n\tlockedAt := tm.lockedAt\n\tatomic.StoreInt32(&tm.isLocked, 0)\n\ttm.mu.Unlock()\n\tif tm.cb != nil {\n\t\ttm.cb(time.Since(lockedAt))\n\t}\n}"}
{"input": "package daemon\n\n\n\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/go-openapi/runtime\"\n\n\tstrfmt \"github.com/go-openapi/strfmt\"\n\n\t\"github.com/cilium/cilium/api/v1/models\"\n)\n\n\ntype GetMapReader struct {\n\tformats strfmt.Registry\n}\n\n\n\n\n\nfunc NewGetMapOK() *GetMapOK {\n\treturn &GetMapOK{}\n}\n\n\ntype GetMapOK struct {\n\tPayload *models.BPFMapList\n}\n\nfunc (o *GetMapOK) Error() string {\n\treturn fmt.Sprintf(\"[GET /map][%d] getMapOK  %+v\", 200, o.Payload)\n}\n\nfunc (o *GetMapOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {\n\n\to.Payload = new(models.BPFMapList)\n\n\tif err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (o *GetMapReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) ", "output": "{\n\tswitch response.Code() {\n\n\tcase 200:\n\t\tresult := NewGetMapOK()\n\t\tif err := result.readResponse(response, consumer, o.formats); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn result, nil\n\n\tdefault:\n\t\treturn nil, runtime.NewAPIError(\"unknown error\", response, response.Code())\n\t}\n}"}
{"input": "package main\n\nimport \"github.com/samuel/go-thrift/parser\"\n\n\ntype Include struct {\n\tkey  string\n\tfile string\n\tpkg  string\n}\n\n\nfunc (i *Include) Import() string {\n\treturn *packagePrefix + i.Package()\n}\n\n\n\n\nfunc createIncludes(parsed *parser.Thrift, all map[string]parseState) map[string]*Include {\n\tincludes := make(map[string]*Include)\n\tfor k, v := range parsed.Includes {\n\t\tincluded := all[v]\n\t\tincludes[k] = &Include{\n\t\t\tkey:  k,\n\t\t\tfile: v,\n\t\t\tpkg:  included.namespace,\n\t\t}\n\t}\n\treturn includes\n}\n\nfunc (i *Include) Package() string ", "output": "{\n\treturn i.pkg\n}"}
{"input": "package engi\n\ntype glyph struct {\n\tregion   *Region\n\txoffset  float32\n\tyoffset  float32\n\txadvance float32\n}\n\ntype Font struct {\n\tglyphs map[rune]*glyph\n}\n\nfunc NewGridFont(texture *Texture, cellWidth, cellHeight int) *Font {\n\ti := 0\n\tglyphs := make(map[rune]*glyph)\n\n\tfor y := 0; y < int(texture.Height())/cellHeight; y++ {\n\t\tfor x := 0; x < int(texture.Width())/cellWidth; x++ {\n\t\t\tg := &glyph{xadvance: float32(cellWidth)}\n\t\t\tg.region = NewRegion(texture, x*cellWidth, y*cellHeight, cellWidth, cellHeight)\n\t\t\tglyphs[rune(i)] = g\n\t\t\ti += 1\n\t\t}\n\t}\n\n\treturn &Font{glyphs}\n}\n\nfunc (f *Font) Remap(mapping string) {\n\tglyphs := make(map[rune]*glyph)\n\n\ti := 0\n\tfor _, v := range mapping {\n\t\tglyphs[v] = f.glyphs[rune(i)]\n\t\ti++\n\t}\n\n\tf.glyphs = glyphs\n}\n\n\n\nfunc (f *Font) Print(batch *Batch, text string, x, y float32, color uint32) {\n\txx := x\n\tfor _, r := range text {\n\t\tif g, ok := f.glyphs[r]; ok {\n\t\t\tbatch.Draw(g.region, xx+g.xoffset, y+g.yoffset, 0, 0, 1, 1, 0, color, 1)\n\t\t\txx += g.xadvance\n\t\t}\n\t}\n}\n\nfunc (f *Font) Put(batch *Batch, r rune, x, y float32, color uint32) ", "output": "{\n\tif g, ok := f.glyphs[r]; ok {\n\t\tbatch.Draw(g.region, x+g.xoffset, y+g.yoffset, 0, 0, 1, 1, 0, color, 1)\n\t}\n}"}
{"input": "package iso20022\n\n\ntype ATMCustomerProfile4 struct {\n\n\tRetrievalMode *ATMCustomerProfile1Code `xml:\"RtrvlMd\"`\n\n\tProfileReference *Max35Text `xml:\"PrflRef,omitempty\"`\n\n\tCustomerIdentification *Max35Text `xml:\"CstmrId,omitempty\"`\n}\n\n\n\nfunc (a *ATMCustomerProfile4) SetProfileReference(value string) {\n\ta.ProfileReference = (*Max35Text)(&value)\n}\n\nfunc (a *ATMCustomerProfile4) SetCustomerIdentification(value string) {\n\ta.CustomerIdentification = (*Max35Text)(&value)\n}\n\nfunc (a *ATMCustomerProfile4) SetRetrievalMode(value string) ", "output": "{\n\ta.RetrievalMode = (*ATMCustomerProfile1Code)(&value)\n}"}
{"input": "package query\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n)\n\nfunc toJson(v interface{}) ([]byte, error) {\n\treturn json.Marshal(v)\n}\n\nfunc wrapper(name string, v interface{}) map[string]interface{} {\n\tquery := map[string]interface{}{\n\t\tname: v,\n\t}\n\treturn query\n}\n\n\n\nfunc convertable(value reflect.Value) bool {\n\tswitch value.Kind() {\n\tcase reflect.Slice:\n\t\treturn value.Len() > 0\n\tcase reflect.Ptr:\n\t\treturn !value.IsNil()\n\t}\n\treturn true\n}\n\nfunc convertStruct(x interface{}) interface{} {\n\tquery := make(map[string]interface{})\n\n\tt := reflect.ValueOf(x).Type()\n\tv := reflect.ValueOf(x)\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tfield := t.Field(i)\n\t\tvalue := v.FieldByName(field.Name)\n\t\ttag := field.Tag.Get(\"json\")\n\t\tif tag == \"-\" {\n\t\t\tcontinue\n\t\t}\n\t\tif convertable(value) {\n\t\t\tquery[tag] = convert(value)\n\t\t}\n\t}\n\n\treturn query\n\n}\n\nfunc convert(value reflect.Value) interface{} ", "output": "{\n\tswitch value.Kind() {\n\tcase reflect.Slice:\n\t\tvar res []interface{}\n\t\tfor i := 0; i < value.Len(); i++ {\n\t\t\tres = append(res, convert(value.Index(i)))\n\t\t}\n\t\treturn res\n\tcase reflect.Ptr:\n\t\tif !value.IsNil() {\n\t\t\treturn convert(value.Elem())\n\t\t}\n\tcase reflect.String:\n\t\treturn value.String()\n\tcase reflect.Float64:\n\t\treturn value.Float()\n\tcase reflect.Int:\n\t\treturn value.Int()\n\tcase reflect.Bool:\n\t\treturn value.Bool()\n\t}\n\treturn value.Interface()\n}"}
{"input": "package log\n\nimport (\n\tl \"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/metrics\"\n)\n\nconst (\n\tCallDepth = 1\n)\n\nvar (\n\tlogBaseAddr = false\n)\n\n\ntype Logger = l.Logger\n\n\nfunc NewBaseAddressLogger(baseAddr string, ctx ...interface{}) l.Logger {\n\tif logBaseAddr {\n\t\treturn l.New(append([]interface{}{\"base\", baseAddr}, ctx...)...)\n\t}\n\n\treturn l.New(ctx...)\n}\n\n\nfunc New(ctx ...interface{}) Logger {\n\treturn l.New(ctx)\n}\n\n\n\nfunc EnableBaseAddress() {\n\tlogBaseAddr = true\n}\n\n\n\n\n\nfunc Error(msg string, ctx ...interface{}) {\n\tmetrics.GetOrRegisterCounter(\"error\", nil).Inc(1)\n\tl.Output(msg, l.LvlError, CallDepth, ctx...)\n}\n\n\nfunc Crit(msg string, ctx ...interface{}) {\n\tmetrics.GetOrRegisterCounter(\"crit\", nil).Inc(1)\n\tl.Output(msg, l.LvlCrit, CallDepth, ctx...)\n}\n\n\nfunc Info(msg string, ctx ...interface{}) {\n\tmetrics.GetOrRegisterCounter(\"info\", nil).Inc(1)\n\tl.Output(msg, l.LvlInfo, CallDepth, ctx...)\n}\n\n\nfunc Debug(msg string, ctx ...interface{}) {\n\tmetrics.GetOrRegisterCounter(\"debug\", nil).Inc(1)\n\tl.Output(msg, l.LvlDebug, CallDepth, ctx...)\n}\n\n\nfunc Trace(msg string, ctx ...interface{}) {\n\tmetrics.GetOrRegisterCounter(\"trace\", nil).Inc(1)\n\tl.Output(msg, l.LvlTrace, CallDepth, ctx...)\n}\n\n\nfunc GetHandler() l.Handler {\n\treturn l.Root().GetHandler()\n}\n\nfunc Warn(msg string, ctx ...interface{}) ", "output": "{\n\tmetrics.GetOrRegisterCounter(\"warn\", nil).Inc(1)\n\tl.Output(msg, l.LvlWarn, CallDepth, ctx...)\n}"}
{"input": "package crank\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype TimeoutTracker struct {\n\ttimeouts            map[*Process]time.Time\n\tticker              *time.Ticker\n\ttimeoutNotification chan *Process\n\tstopAction          chan bool\n\tmutex               *sync.Mutex\n}\n\nfunc NewTimeoutTracker() *TimeoutTracker {\n\treturn &TimeoutTracker{\n\t\ttimeouts:            make(map[*Process]time.Time),\n\t\tticker:              time.NewTicker(100 * time.Millisecond),\n\t\ttimeoutNotification: make(chan *Process),\n\t\tstopAction:          make(chan bool),\n\t\tmutex:               &sync.Mutex{},\n\t}\n}\n\nfunc (self *TimeoutTracker) Add(p *Process, timeout time.Duration) {\n\tif timeout <= 0 {\n\t\treturn\n\t}\n\tself.mutex.Lock()\n\tself.timeouts[p] = time.Now().Add(timeout)\n\tself.mutex.Unlock()\n}\n\nfunc (self *TimeoutTracker) Remove(p *Process) {\n\tself.mutex.Lock()\n\tdelete(self.timeouts, p)\n\tself.mutex.Unlock()\n}\n\nfunc (self *TimeoutTracker) Run() {\n\tfor {\n\t\tselect {\n\t\tcase t := <-self.ticker.C:\n\t\t\tself.expireOld(t)\n\t\tcase <-self.stopAction:\n\t\t\tself.ticker.Stop()\n\t\t\treturn\n\t\t}\n\t}\n}\n\n\n\nfunc (self *TimeoutTracker) expireOld(now time.Time) {\n\tself.mutex.Lock()\n\tfor p, timeout := range self.timeouts {\n\t\tif timeout.Before(now) {\n\t\t\tdelete(self.timeouts, p)\n\t\t\tself.timeoutNotification <- p\n\t\t}\n\t}\n\tself.mutex.Unlock()\n}\n\nfunc (self *TimeoutTracker) Stop() ", "output": "{\n\tself.stopAction <- true\n}"}
{"input": "package apigateway\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype ExecutionLogPolicy struct {\n\n\tIsEnabled *bool `mandatory:\"false\" json:\"isEnabled\"`\n\n\tLogLevel ExecutionLogPolicyLogLevelEnum `mandatory:\"false\" json:\"logLevel,omitempty\"`\n}\n\n\n\n\ntype ExecutionLogPolicyLogLevelEnum string\n\n\nconst (\n\tExecutionLogPolicyLogLevelInfo  ExecutionLogPolicyLogLevelEnum = \"INFO\"\n\tExecutionLogPolicyLogLevelWarn  ExecutionLogPolicyLogLevelEnum = \"WARN\"\n\tExecutionLogPolicyLogLevelError ExecutionLogPolicyLogLevelEnum = \"ERROR\"\n)\n\nvar mappingExecutionLogPolicyLogLevel = map[string]ExecutionLogPolicyLogLevelEnum{\n\t\"INFO\":  ExecutionLogPolicyLogLevelInfo,\n\t\"WARN\":  ExecutionLogPolicyLogLevelWarn,\n\t\"ERROR\": ExecutionLogPolicyLogLevelError,\n}\n\n\nfunc GetExecutionLogPolicyLogLevelEnumValues() []ExecutionLogPolicyLogLevelEnum {\n\tvalues := make([]ExecutionLogPolicyLogLevelEnum, 0)\n\tfor _, v := range mappingExecutionLogPolicyLogLevel {\n\t\tvalues = append(values, v)\n\t}\n\treturn values\n}\n\nfunc (m ExecutionLogPolicy) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package awstasks\n\nimport (\n\t\"encoding/json\"\n\n\t\"k8s.io/kops/upup/pkg/fi\"\n)\n\n\n\n\ntype realIAMInstanceProfile IAMInstanceProfile\n\n\nfunc (o *IAMInstanceProfile) UnmarshalJSON(data []byte) error {\n\tvar jsonName string\n\tif err := json.Unmarshal(data, &jsonName); err == nil {\n\t\to.Name = &jsonName\n\t\treturn nil\n\t}\n\n\tvar r realIAMInstanceProfile\n\tif err := json.Unmarshal(data, &r); err != nil {\n\t\treturn err\n\t}\n\t*o = IAMInstanceProfile(r)\n\treturn nil\n}\n\nvar _ fi.HasLifecycle = &IAMInstanceProfile{}\n\n\nfunc (o *IAMInstanceProfile) GetLifecycle() *fi.Lifecycle {\n\treturn o.Lifecycle\n}\n\nvar _ fi.HasName = &IAMInstanceProfile{}\n\n\nfunc (o *IAMInstanceProfile) GetName() *string {\n\treturn o.Name\n}\n\n\n\n\n\nfunc (o *IAMInstanceProfile) String() string {\n\treturn fi.TaskAsString(o)\n}\n\nfunc (o *IAMInstanceProfile) SetName(name string) ", "output": "{\n\to.Name = &name\n}"}
{"input": "package cdn\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient {\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}\n\nfunc New(subscriptionID string) BaseClient ", "output": "{\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}"}
{"input": "package models\n\nimport (\n\t\"github.com/astaxie/beego/orm\"\n\t_ \"github.com/mattn/go-sqlite3\"\n\t\"log\"\n\t\"strings\"\n)\n\n\ntype User struct {\n\tId       int64\n\tUsername string\n\tNickname string\n\tPassword string\n\tSex       string\n\tIdentity  string \n\tNative    string \n\tNation    string \n\tNumber    string \n\tEducation string \n\tPhone     string\n\tEmail     string\n\tAddress   string \n\tResident  string \n\tBirthday   string\n\tJointime   string\n\tCompany    string \n\tPosition   string \n\tGroup      string \n\tBranch     string \n\tCategory   string \n\tLinkman    string \n\tIntroducer string \n\tFeature    string `orm:\"size(1000)\"` \n\tComment    string `orm:\"size(1000)\"` \n\tPhoto      string \n\n}\n\n\n\n\n\n\nfunc CheckAccount(name, pwd1 string) bool ", "output": "{\n\to := orm.NewOrm()\n\tuser := &User{Nickname: name}\n\n\n\terr := o.Read(user, \"Nickname\")\n\tlog.Println(user)\n\tif err != nil {\n\t\tlog.Print(err)\n\t\treturn false\n\t}\n\tpwd := user.Password\n\tok := strings.EqualFold(pwd, pwd1)\n\treturn ok\n}"}
{"input": "package cbo\n\ntype Net struct {\n\tEndpoints EndpointSet\n\n\tonReplace []func(new *Net)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (n *Net) SuggestedName() string {\n\tif len(n.Endpoints) == 0 {\n\t\treturn \"\"\n\t}\n\n\tnameOccurs := map[string]int{}\n\tfor e := range n.Endpoints {\n\t\tnameOccurs[e.Name]++\n\t}\n\n\tfor _, n := range priorityNetNames {\n\t\tif nameOccurs[n] > 0 {\n\t\t\treturn n\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\n\n\n\n\n\n\n\n\nfunc (n *Net) OnReplace(cb func(new *Net)) {\n\tn.onReplace = append(n.onReplace, cb)\n}\n\nvar priorityNetNames = []string{\n\t\"GND\",\n\t\"AGND\",\n\t\"PGND\",\n\n\t\"+3V3\",\n\t\"-3V3\",\n\t\"+1V8\",\n\t\"-1V8\",\n\t\"+5V\",\n\t\"-5V\",\n\t\"+12V\",\n\t\"-12V\",\n\t\"+9V\",\n\t\"-9V\",\n\t\"+6V\",\n\t\"-6V\",\n\t\"+24V\",\n\t\"-24V\",\n\n\t\"V+\",\n\t\"VCC\",\n\t\"VDD\",\n\t\"V-\",\n\t\"VSS\",\n\t\"VEE\",\n\n\t\"MOSI\",\n\t\"MISO\",\n\t\"SCLK\",\n\t\"SCK\",\n\t\"SDA\",\n\t\"RX\",\n\t\"TX\",\n\t\"DTR\",\n\t\"DCD\",\n\t\"DSR\",\n\t\"RTS\",\n\t\"RTR\",\n\t\"CTS\",\n}\n\nfunc (n *Net) Connect(e *Endpoint) ", "output": "{\n\tif e.Net != nil {\n\t\tmn := e.Net\n\t\totherEs := mn.Endpoints.List()\n\t\tfor _, otherE := range otherEs {\n\t\t\tn.Endpoints.Add(otherE)\n\t\t\totherE.Net = n\n\t\t\tmn.Endpoints.Remove(otherE)\n\t\t}\n\n\t\tfor _, cb := range mn.onReplace {\n\t\t\tcb(n)\n\n\t\t\tn.onReplace = append(n.onReplace, cb)\n\t\t}\n\t\treturn\n\t}\n\n\tn.Endpoints.Add(e)\n\te.Net = n\n}"}
{"input": "package vcl\n\n\n\n\nimport (\n\t. \"github.com/ying32/govcl/vcl/api\"\n\t. \"github.com/ying32/govcl/vcl/types\"\n)\n\ntype (\n\tNSObject uintptr\n\n\tNSWindow uintptr\n\n\tNSURL uintptr\n)\n\n\nfunc HandleToPlatformHandle(h HWND) NSObject {\n\treturn NSObject(h)\n}\n\nfunc (f *TForm) PlatformWindow() NSWindow {\n\tr, _, _ := NSWindow_FromForm.Call(f.instance)\n\treturn NSWindow(r)\n}\n\nfunc (n NSWindow) TitleVisibility() NSWindowTitleVisibility {\n\tr, _, _ := NSWindow_titleVisibility.Call(uintptr(n))\n\treturn NSWindowTitleVisibility(r)\n}\n\nfunc (n NSWindow) SetTitleVisibility(flag NSWindowTitleVisibility) {\n\tNSWindow_setTitleVisibility.Call(uintptr(n), uintptr(flag))\n}\n\n\n\nfunc (n NSWindow) SetTitleBarAppearsTransparent(flag bool) {\n\tNSWindow_setTitlebarAppearsTransparent.Call(uintptr(n), GoBoolToDBool(flag))\n}\n\nfunc (n NSWindow) SetRepresentedURL(url NSURL) {\n\tNSWindow_setRepresentedURL.Call(uintptr(n), uintptr(url))\n}\n\nfunc (n NSWindow) StyleMask() uint {\n\tr, _, _ := NSWindow_styleMask.Call(uintptr(n))\n\treturn uint(r)\n}\n\nfunc (n NSWindow) SetStyleMask(mask uint) {\n\tNSWindow_setStyleMask.Call(uintptr(n), uintptr(mask))\n}\n\nfunc (n NSWindow) TitleBarAppearsTransparent() bool ", "output": "{\n\tr, _, _ := NSWindow_titlebarAppearsTransparent.Call(uintptr(n))\n\treturn DBoolToGoBool(r)\n}"}
{"input": "package fwserver\n\nimport (\n\t\"github.com/spf13/cobra\"\n)\n\n\n\n\nfunc NewFirewallServerCommand() *cobra.Command ", "output": "{\n\tbase := &cobra.Command{\n\t\tUse:   \"fwserver\",\n\t\tShort: \"Commands related to the Firewall Server parts\",\n\t\tLong: `Manages the Firewall Server parts of a Qaclana Web Application Firewall cluster.\nA Firewall Server is the component to which the Firewall Instances connect to. This should be\nstarted after a backend is available, but this is not required: a connection will be started\nlater if a backend isn't available.\n\t\t`,\n\t}\n\n\tbase.AddCommand(NewStartFirewallServerCommand())\n\n\treturn base\n}"}
{"input": "package env\n\nimport (\n\t\"net/http\"\n)\n\nvar envInstance = env{\n\thandlers: []Handler{},\n}\n\ntype env struct {\n\thandlers []Handler\n}\n\n\n\nfunc GetHandlers() []Handler {\n\treturn envInstance.handlers\n}\n\ntype Handler struct {\n\tURLPrefix string\n\tHandler   http.Handler\n}\n\nfunc RegisterHandler(handler Handler) ", "output": "{\n\tenvInstance.handlers = append(envInstance.handlers, handler)\n}"}
{"input": "package main \nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n}\n\n\ntype MyFloat float64\n\n\n\nfunc main() {\n\tf := MyFloat(-math.Sqrt2)\n\tfmt.Println(f.Abs())\n}\n\nfunc (f MyFloat) Abs() float64 ", "output": "{\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}"}
{"input": "package dps\n\nimport (\n\t\"errors\"\n\t\"go2o/src/core/domain/interface/promotion\"\n)\n\ntype promotionService struct {\n\t_rep promotion.IPromotionRep\n}\n\nfunc NewPromotionService(r promotion.IPromotionRep) *promotionService {\n\treturn &promotionService{\n\t\t_rep: r,\n\t}\n}\n\n\n\nfunc (this *promotionService) SaveCoupon(partnerId int, e *promotion.ValueCoupon) (int, error) {\n\tprom := this._rep.GetPromotion(partnerId)\n\tvar coupon promotion.ICoupon\n\tif e.Id > 0 {\n\t\tcoupon = prom.GetCoupon(e.Id)\n\t\tif coupon == nil {\n\t\t\treturn 0, errors.New(\"优惠券不存在\")\n\t\t}\n\t\terr := coupon.SetValue(e)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t} else {\n\t\tcoupon = prom.CreateCoupon(e)\n\t}\n\treturn coupon.Save()\n}\n\nfunc (this *promotionService) BindCoupons(partnerId int, id int, members []string) error {\n\tcoupon := this.GetCoupon(partnerId, id)\n\treturn coupon.Binds(members)\n}\n\nfunc (this *promotionService) GetCoupon(partnerId int, id int) promotion.ICoupon ", "output": "{\n\t_prom := this._rep.GetPromotion(partnerId)\n\treturn _prom.GetCoupon(id)\n}"}
{"input": "package mapping\n\nimport \"fmt\"\n\ntype mapType uint8\n\nconst (\n\tmapTypeString mapType = iota\n\tmapTypeInt\n)\n\nfunc (mt *mapType) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\tvar ts string\n\terr := unmarshal(&ts)\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch ts {\n\tcase \"int\":\n\t\t*mt = mapTypeInt\n\tcase \"string\":\n\t\t*mt = mapTypeString\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown type: %s (allowed values: int, string)\", ts)\n\t}\n\treturn nil\n}\n\n\n\nfunc InterfaceMap(i map[string]string) (om map[string]interface{}) ", "output": "{\n\tom = make(map[string]interface{})\n\tfor k, v := range i {\n\t\tom[k] = v\n\t}\n\treturn\n}"}
{"input": "package BrickMosaic\n\n\n\n\n\n\ntype AnchorPoint int\n\nconst (\n\tUpperLeft AnchorPoint = iota\n\tUpperRight\n\tLowerRight\n\tLowerLeft\n)\n\nfunc (a AnchorPoint) String() string {\n\tswitch a {\n\tcase UpperLeft:\n\t\treturn \"UpperLeft\"\n\tcase UpperRight:\n\t\treturn \"UpperRight\"\n\tcase LowerRight:\n\t\treturn \"LowerRight\"\n\tcase LowerLeft:\n\t\treturn \"LowerLeft\"\n\t}\n\tpanic(\"shouldn't reach here\")\n}\n\n\n\nfunc TranslateAbsoluteOrigin(absLoc Location, p MosaicPiece, pt AnchorPoint) Location {\n\tif pt == UpperLeft {\n\t\treturn absLoc\n\t} else if pt == UpperRight {\n\t\treturn absLoc.Add(Location{Col: -p.Cols() + 1})\n\t} else if pt == LowerRight {\n\t\treturn absLoc.Add(Location{Row: -p.Rows() + 1, Col: -p.Cols() + 1})\n\t} else if pt == LowerLeft {\n\t\treturn absLoc.Add(Location{Row: -p.Rows() + 1})\n\t}\n\tpanic(\"Shouldn't reach here\")\n}\n\nfunc Translate(locs []Location, pt AnchorPoint) []Location ", "output": "{\n\tif pt == UpperLeft {\n\t\treturn locs\n\t}\n\tif pt == UpperRight {\n\t\tvar points []Location\n\t\tfor _, p := range locs {\n\t\t\tpoints = append(points, Location{Row: p.Row, Col: -p.Col})\n\t\t}\n\t\treturn points\n\t}\n\tif pt == LowerRight {\n\t\tvar points []Location\n\t\tfor _, p := range locs {\n\t\t\tpoints = append(points, Location{Row: -p.Row, Col: -p.Col})\n\t\t}\n\t\treturn points\n\t}\n\tif pt == LowerLeft {\n\t\tvar points []Location\n\t\tfor _, p := range locs {\n\t\t\tpoints = append(points, Location{Row: -p.Row, Col: p.Col})\n\t\t}\n\t\treturn points\n\t}\n\tpanic(\"Shouldn't reach here\")\n}"}
{"input": "package tasks_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/RichardKnop/machinery/v2/tasks\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestTaskStateIsCompleted(t *testing.T) ", "output": "{\n\tt.Parallel()\n\n\ttaskState := &tasks.TaskState{\n\t\tTaskUUID: \"taskUUID\",\n\t\tState:    tasks.StatePending,\n\t}\n\n\tassert.False(t, taskState.IsCompleted())\n\n\ttaskState.State = tasks.StateReceived\n\tassert.False(t, taskState.IsCompleted())\n\n\ttaskState.State = tasks.StateStarted\n\tassert.False(t, taskState.IsCompleted())\n\n\ttaskState.State = tasks.StateSuccess\n\tassert.True(t, taskState.IsCompleted())\n\n\ttaskState.State = tasks.StateFailure\n\tassert.True(t, taskState.IsCompleted())\n}"}
{"input": "package app\n\nimport (\n\t\"./errors\"\n\t\"./models\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype app struct {\n\tinputFileName  string\n\tresultFilePath string\n}\n\nvar (\n\tErrs   *myErrors.Error\n\tClient *models.Client\n\tFile   *models.File\n)\n\nfunc New() app {\n\treturn make(app)\n}\n\n\n\nfunc (a *app) Start() {\n\ta.init()\n\tFile.Name = a.inputFileName\n\tfmt.Print(\"Open file \" + File.Name + \"... \")\n\tErrs.Check(File.Open())\n\tfmt.Println(\"OK\")\n\tdefer File.Basic.Close()\n\tfmt.Print(\"Read file \" + File.Name + \"... \")\n\tErrs.Check(File.Read())\n\tfmt.Println(\"OK\")\n\tfmt.Println(\"Sending file \" + File.Name + \" as \" + File.Name + \"... \")\n\tClient.Connect()\n\tClient.SendFile(File)\n\tfmt.Println(\"OK\")\n}\n\nfunc (a *app) init() ", "output": "{\n\ta.Errs.Init()\n\ta.Client.Init()\n\ta.File.Init()\n\tif len(os.Args) < 2 {\n\t\ta.Errs.Check(nil, 2, \"\")\n\t}\n\ta.inputFileName = os.Args[1]\n\ta.resultFilePath = os.Args[2]\n}"}
{"input": "package fuse\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"golang.org/x/net/context\"\n)\n\n\ntype MountConfig struct {\n\tOpContext context.Context\n\n\tFSName string\n\n\tReadOnly bool\n\n\tErrorLogger *log.Logger\n\n\tDebugLogger *log.Logger\n\n\tDisableWritebackCaching bool\n\n\tEnableVnodeCaching bool\n\n\tOptions map[string]string\n}\n\n\n\nfunc (c *MountConfig) toMap() (opts map[string]string) {\n\tisDarwin := runtime.GOOS == \"darwin\"\n\topts = make(map[string]string)\n\n\topts[\"default_permissions\"] = \"\"\n\n\tfsname := c.FSName\n\tif runtime.GOOS == \"linux\" && fsname == \"\" {\n\t\tfsname = \"some_fuse_file_system\"\n\t}\n\n\tif fsname != \"\" {\n\t\topts[\"fsname\"] = fsname\n\t}\n\n\tif c.ReadOnly {\n\t\topts[\"ro\"] = \"\"\n\t}\n\n\tif isDarwin && !c.EnableVnodeCaching {\n\t\topts[\"novncache\"] = \"\"\n\t}\n\n\tif isDarwin {\n\t\topts[\"noappledouble\"] = \"\"\n\t}\n\n\tfor k, v := range c.Options {\n\t\topts[k] = v\n\t}\n\n\treturn\n}\n\n\n\n\nfunc (c *MountConfig) toOptionsString() string {\n\tvar components []string\n\tfor k, v := range c.toMap() {\n\t\tk = escapeOptionsKey(k)\n\n\t\tcomponent := k\n\t\tif v != \"\" {\n\t\t\tcomponent = fmt.Sprintf(\"%s=%s\", k, v)\n\t\t}\n\n\t\tcomponents = append(components, component)\n\t}\n\n\treturn strings.Join(components, \",\")\n}\n\nfunc escapeOptionsKey(s string) (res string) ", "output": "{\n\tres = s\n\tres = strings.Replace(res, `\\`, `\\\\`, -1)\n\tres = strings.Replace(res, `,`, `\\,`, -1)\n\treturn\n}"}
{"input": "package pydio\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nvar (\n\tfakeXML  []byte\n\tfakeXML2 []byte\n)\n\nfunc init() {\n\tsecret = \"TestingSecret\"\n\n\tfakeXML = []byte(`\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<tree>\n\t\t<user groupPath=\"test\" id=\"test\">\n\t\t\t<active_repo id=\"1\" write=\"1\" read=\"1\"/>\n\t\t\t<repositories>\n\t\t\t\t<repo id=\"test\" acl=\"r\"></repo>\n\t\t\t</repositories>\n\t\t</user>\n\t</tree>\n\t`)\n}\n\ntype Query struct {\n\tUser User `xml:\"user\"`\n}\n\n\n\nfunc TestUser(t *testing.T) ", "output": "{\n\tConvey(\"Unmarshaling user\", t, func() {\n\t\tvar q Query\n\n\t\terr := xml.Unmarshal(fakeXML, &q)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tSo(q.User, ShouldResemble, *fakeUser)\n\t\tSo(q.User.Repos[0].IsReadable(), ShouldEqual, true)\n\t})\n\n\tConvey(\"Unmarshaling user 2\", t, func() {\n\t\tvar q Query\n\n\t\tdec := xml.NewDecoder(bytes.NewReader(fakeXML))\n\t\tdec.Strict = false\n\n\t\terr := dec.Decode(&q)\n\t\tSo(err, ShouldBeNil)\n\n\t\tSo(q.User, ShouldResemble, *fakeUser)\n\t})\n}"}
{"input": "package lints\n\n\n\n\n\nimport (\n\t\"github.com/zmap/zcrypto/x509\"\n\t\"github.com/zmap/zlint/util\"\n)\n\ntype caKeyCertSignNotSet struct{}\n\nfunc (l *caKeyCertSignNotSet) Initialize() error {\n\treturn nil\n}\n\n\n\nfunc (l *caKeyCertSignNotSet) Execute(c *x509.Certificate) *LintResult {\n\tif c.KeyUsage&x509.KeyUsageCertSign != 0 {\n\t\treturn &LintResult{Status: Pass}\n\t} else {\n\t\treturn &LintResult{Status: Error}\n\t}\n}\n\nfunc init() {\n\tRegisterLint(&Lint{\n\t\tName:          \"e_ca_key_cert_sign_not_set\",\n\t\tDescription:   \"Root CA Certificate: Bit positions for keyCertSign and cRLSign MUST be set.\",\n\t\tCitation:      \"BRs: 7.1.2.1\",\n\t\tSource:        CABFBaselineRequirements,\n\t\tEffectiveDate: util.CABEffectiveDate,\n\t\tLint:          &caKeyCertSignNotSet{},\n\t})\n}\n\nfunc (l *caKeyCertSignNotSet) CheckApplies(c *x509.Certificate) bool ", "output": "{\n\treturn c.IsCA && util.IsExtInCert(c, util.KeyUsageOID)\n}"}
{"input": "package bearertoken\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\t\"go.uber.org/zap\"\n)\n\n\n\n\n\n\nfunc PropagationHandler(logger *zap.Logger, h http.Handler) http.Handler ", "output": "{\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tctx := r.Context()\n\t\tauthHeaderValue := r.Header.Get(\"Authorization\")\n\t\tif authHeaderValue == \"\" {\n\t\t\tauthHeaderValue = r.Header.Get(\"X-Forwarded-Access-Token\")\n\t\t}\n\t\tif authHeaderValue != \"\" {\n\t\t\theaderValue := strings.Split(authHeaderValue, \" \")\n\t\t\ttoken := \"\"\n\t\t\tif len(headerValue) == 2 {\n\t\t\t\tif headerValue[0] == \"Bearer\" {\n\t\t\t\t\ttoken = headerValue[1]\n\t\t\t\t}\n\t\t\t} else if len(headerValue) == 1 {\n\t\t\t\ttoken = authHeaderValue\n\t\t\t} else {\n\t\t\t\tlogger.Warn(\"Invalid authorization header value, skipping token propagation\")\n\t\t\t}\n\t\t\th.ServeHTTP(w, r.WithContext(ContextWithBearerToken(ctx, token)))\n\t\t} else {\n\t\t\th.ServeHTTP(w, r.WithContext(ctx))\n\t\t}\n\t})\n}"}
{"input": "package db\n\nimport (\n\t\"database/sql\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\ntype Connection struct {\n\tdb *sql.DB\n}\n\n\n\nfunc (c *Connection) Connect() *sql.DB {\n\treturn c.db\n}\n\nfunc (c *Connection) Begin() (*sql.Tx, error) {\n\treturn c.db.Begin()\n}\n\nfunc NewConnection(db *sql.DB) *Connection ", "output": "{\n\treturn &Connection{\n\t\tdb: db,\n\t}\n}"}
{"input": "package utils\n\nimport (\n\t\"crypto/sha256\"\n\t\"crypto/subtle\"\n\t\"crypto/x509\"\n\t\"encoding/hex\"\n\t\"strings\"\n\n\t\"github.com/gravitational/trace\"\n)\n\n\nfunc CalculateSKPI(cert *x509.Certificate) string {\n\tsum := sha256.Sum256(cert.RawSubjectPublicKeyInfo)\n\treturn \"sha256:\" + hex.EncodeToString(sum[:])\n}\n\n\n\n\nfunc CheckSKPI(pin string, cert *x509.Certificate) error ", "output": "{\n\tparts := strings.Split(pin, \":\")\n\tif len(parts) != 2 {\n\t\treturn trace.BadParameter(\"invalid format for SKPI hash\")\n\t}\n\tif parts[0] != \"sha256\" {\n\t\treturn trace.BadParameter(\"only sha256 supported by SKPI hash\")\n\t}\n\n\tif subtle.ConstantTimeCompare([]byte(CalculateSKPI(cert)), []byte(pin)) != 1 {\n\t\treturn trace.BadParameter(\"SKPI values do not match\")\n\t}\n\n\treturn nil\n}"}
{"input": "package consumer\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestGetOffset(t *testing.T) {\n\tconsumer := getConsumer(t)\n\toffset, err := consumer.Offset(\"test\", 0, \"test-consumergroup-b\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfmt.Println(\"get offset: \", offset)\n}\n\nfunc TestConsumeAll(t *testing.T) {\n\tconsumer := getConsumer(t)\n\tfor partition := int32(0); partition < 3; partition++ {\n\t\tvalues, err := consumer.Consume(\"test\", partition, 0)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfmt.Println(\"Partition\", partition)\n\t\tfor _, value := range values {\n\t\t\tfmt.Println(string(value))\n\t\t}\n\t\tfmt.Println()\n\t}\n}\n\nfunc TestCommitOffset(t *testing.T) {\n\tconsumer := getConsumer(t)\n\terr := consumer.Commit(\"test\", 0, \"test-consumergroup-b\", 2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n\n\nfunc getConsumer(t *testing.T) *C ", "output": "{\n\tconsumer, err := New(DefaultConfig(\n\t\t\"docker:32776\",\n\t\t\"docker:32777\",\n\t\t\"docker:32778\",\n\t\t\"docker:32779\",\n\t\t\"docker:32780\",\n\t))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn consumer\n}"}
{"input": "package common\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n)\n\n\n\n\nconst PackerKeyEnv = \"PACKER_KEY_INTERVAL\"\n\n\n\nconst PackerKeyDefault = 100 * time.Millisecond\n\n\n\n\n\n\nfunc ChooseString(vals ...string) string {\n\tfor _, el := range vals {\n\t\tif el != \"\" {\n\t\t\treturn el\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\n\n\n\nfunc DownloadableURL(original string) (string, error) {\n\n\tsupported := []string{\"file\", \"http\", \"https\", \"ftp\", \"smb\"}\n\tfound := false\n\tfor _, s := range supported {\n\t\tif strings.HasPrefix(strings.ToLower(original), s+\"://\") {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif found {\n\t\toriginal = filepath.ToSlash(original)\n\n\t\turi, err := url.Parse(original)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\turi.Scheme = strings.ToLower(uri.Scheme)\n\n\t\treturn uri.String(), nil\n\t}\n\n\t_, err := os.Stat(original)\n\tif err == nil {\n\t\toriginal, err = filepath.Abs(filepath.FromSlash(original))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\toriginal, err = filepath.EvalSymlinks(original)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\toriginal = filepath.Clean(original)\n\t\toriginal = filepath.ToSlash(original)\n\t}\n\n\n\treturn \"file://\" + original, nil\n}\n\nfunc ScrubConfig(target interface{}, values ...string) string ", "output": "{\n\tconf := fmt.Sprintf(\"Config: %+v\", target)\n\tfor _, value := range values {\n\t\tif value == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tconf = strings.Replace(conf, value, \"<Filtered>\", -1)\n\t}\n\treturn conf\n}"}
{"input": "package trafficmanager\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\n\n\n\nfunc Version() string {\n\treturn version.Number\n}\n\nfunc UserAgent() string ", "output": "{\n\treturn \"Azure-SDK-For-Go/\" + Version() + \" trafficmanager/2018-02-01-preview\"\n}"}
{"input": "package api\n\nimport (\n\t\"interfaces\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nvar InMemoryStoreBucketName = []byte(\"InMemoryStore\")\n\nfunc NewInMemoryStore(db *bolt.DB) *InMemoryStore {\n\tdb.Update(func(tx *bolt.Tx) error {\n\t\t_, err := tx.CreateBucketIfNotExists(InMemoryStoreBucketName)\n\t\treturn err\n\t})\n\n\treturn &InMemoryStore{\n\t\tdb: db,\n\t}\n}\n\ntype InMemoryStore struct {\n\tdb *bolt.DB\n}\n\nfunc (s *InMemoryStore) Set(\n\tkey string,\n\tobj interfaces.MsgpackMarshaller,\n) error {\n\tdata, err := obj.MarshalMsgpack()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger.Println(\"InMemoryStore: set, length data\", len(data))\n\n\treturn s.db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket(InMemoryStoreBucketName)\n\t\treturn b.Put([]byte(key), data)\n\t})\n}\n\nfunc (s *InMemoryStore) Get(\n\tkey string,\n\tobj interfaces.MsgpackMarshaller,\n) error {\n\tvar data []byte\n\terr := s.db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket(InMemoryStoreBucketName)\n\t\tdata = b.Get([]byte(key))\n\t\treturn nil\n\t})\n\n\tif len(data) == 0 {\n\t\treturn nil\n\t}\n\n\tlogger.Println(\"InMemoryStore: get, length data\", len(data))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn obj.UnmarshalMsgpack(data)\n}\n\n\n\nfunc (s *InMemoryStore) Del(\n\tkey string,\n) error ", "output": "{\n\treturn s.db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket(InMemoryStoreBucketName)\n\t\treturn b.Delete([]byte(key))\n\t})\n}"}
{"input": "package crypto\n\nimport (\n  \"bytes\"\n  \"crypto/hmac\"\n  \"crypto/md5\"\n  \"crypto/sha1\"\n  \"encoding/base64\"\n  )\n\n\n\nfunc Encrypt(data []byte) []byte {\n  for index, b := range data {\n    data[index] = rot13(b)\n  }\n  return data\n}\n\nfunc Decrypt(data []byte) []byte {\n  for index, b := range data {\n    data[index] = rot13(b)\n  }\n  return data\n}\n\n\n\nfunc GetMD5HashBase64(stuff []byte) string {\n  return base64.StdEncoding.EncodeToString(GetMD5Hash(stuff))\n}\n\nfunc GetMD5Hash(stuff []byte) []byte {\n  md5Hash := md5.New()\n  md5Hash.Write(stuff)\n  return md5Hash.Sum(nil)\n}\n\nfunc GetSHA1HmacBase64(secretKey, stringToSign string) string {\n  return base64.StdEncoding.EncodeToString(GetSHA1Hmac(secretKey, stringToSign))\n}\n\nfunc GetSHA1Hmac(secretKey, stringToSign string) []byte {\n  mac := hmac.New(sha1.New, bytes.NewBufferString(secretKey).Bytes())\n  bytesToSign := bytes.NewBufferString(stringToSign).Bytes()\n  mac.Write(bytesToSign)\n  return mac.Sum(nil)\n}\n\nfunc rot13(b byte) byte ", "output": "{\n  if 'a' <= b && b <= 'z' {\n    b = 'a' + ((b-'a')+13)%26\n  }\n  if 'A' <= b && b <= 'Z' {\n    b = 'A' + ((b-'A')+13)%26\n  }\n  return b\n}"}
{"input": "package httpRender\n\nimport \"net/http\"\n\n\n\nfunc (t *renderImpl) Redirect(status int, location string) ", "output": "{\n\tif !t.expectWritten(false) {\n\t\treturn\n\t}\n\tt.written = true\n\n\tif !t.expectStatus(0) {\n\t\treturn\n\t}\n\tt.status = status\n\n\thttp.Redirect(t.w, t.req, location, status)\n}"}
{"input": "package cloudcontroller\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\n\ntype Request struct {\n\t*http.Request\n\n\tbody io.ReadSeeker\n}\n\nfunc (r *Request) ResetBody() error {\n\tif r.body == nil {\n\t\treturn nil\n\t}\n\n\t_, err := r.body.Seek(0, 0)\n\treturn err\n}\n\n\n\nfunc NewRequest(request *http.Request, body io.ReadSeeker) *Request ", "output": "{\n\treturn &Request{\n\t\tRequest: request,\n\t\tbody:    body,\n\t}\n}"}
{"input": "package pastis\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\n\ntype FilterChain struct {\n\tFilters []Filter         \n\tIndex   int              \n\tTarget  http.HandlerFunc \n}\n\nfunc (f *FilterChain) Copy() FilterChain {\n\treturn FilterChain{f.Filters, f.Index, f.Target}\n}\n\n\n\nfunc (f *FilterChain) NextFilter(rw http.ResponseWriter, request *http.Request) {\n\tif f.Index < len(f.Filters) {\n\t\tf.Index++\n\t\tf.Filters[f.Index-1](rw, request, f)\n\t} else {\n\t\tf.Target(rw, request)\n\t}\n}\n\n\nfunc (f *FilterChain) dispatchRequestHandler() http.HandlerFunc {\n\treturn func(rw http.ResponseWriter, request *http.Request) {\n\t\tf.Index = 0\n\t\tif len(f.Filters) > 0 {\n\t\t\tf.NextFilter(rw, request)\n\t\t} else {\n\t\t\tf.Target(rw, request)\n\t\t}\n\t}\n}\n\n\ntype Filter func(http.ResponseWriter, *http.Request, *FilterChain)\n\n\n\n\nfunc LoggingFilter(w http.ResponseWriter, request *http.Request, chain *FilterChain) ", "output": "{\n\tnow := time.Now()\n\tchain.NextFilter(w, request)\n\tlog.Printf(\"[HTTP] %s %s [%v]\\n\", request.Method, request.URL, time.Now().Sub(now))\n}"}
{"input": "package model\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"bytes\"\n)\n\ntype StandupItems struct {\n\tHelps        []Entry            `json:\"Help\"`\n\tInterestings []Entry  \t\t\t`json:\"Interesting\"`\n\tFaces        []Entry            `json:\"New face\"`\n\tEvents       []Entry        \t`json:\"Event\"`\n}\n\nfunc (items StandupItems) FacesString() string {\n\treturn toString(\"NEW FACES\", items.Faces)\n}\n\nfunc (items StandupItems) InterestingsString() string {\n\treturn toString(\"INTERESTINGS\", items.Interestings)\n}\n\nfunc (items StandupItems) HelpsString() string {\n\treturn toString(\"HELPS\", items.Helps)\n}\n\nfunc (items StandupItems) EventsString() string {\n\treturn toString(\"EVENTS\", items.Events)\n}\n\nfunc toString(typeName string, entries []Entry) string {\n\tvar buffer bytes.Buffer\n\tbuffer.WriteString(typeName + \"\\n\\n\")\n\tfor _, entry := range entries {\n\t\tbuffer.WriteString(entry.String() + \"\\n \\n\")\n\t}\n\treturn strings.TrimSuffix(buffer.String(), \"\\n \\n\")\n}\n\nfunc (items StandupItems) String() string {\n\treturn fmt.Sprintf(\">>>— — —\\n \\n \\n \\n%v\\n \\n \\n \\n%v\\n \\n \\n \\n%v\\n \\n \\n \\n%v\\n \\n \\n \\n— — —\\n:clap:\", items.FacesString(), items.HelpsString(), items.InterestingsString(), items.EventsString())\n}\n\n\n\nfunc (items StandupItems) Empty() bool ", "output": "{\n\treturn len(items.Faces) == 0 && len(items.Events) == 0 && len(items.Helps) == 0 && len(items.Interestings) == 0\n}"}
{"input": "package deny\n\nimport (\n\t\"errors\"\n\t\"io\"\n\n\t\"k8s.io/kubernetes/pkg/admission\"\n\t\"k8s.io/kubernetes/pkg/client\"\n)\n\nfunc init() {\n\tadmission.RegisterPlugin(\"AlwaysDeny\", func(client client.Interface, config io.Reader) (admission.Interface, error) {\n\t\treturn NewAlwaysDeny(), nil\n\t})\n}\n\n\n\ntype alwaysDeny struct{}\n\n\n\nfunc (alwaysDeny) Handles(operation admission.Operation) bool {\n\treturn true\n}\n\n\nfunc NewAlwaysDeny() admission.Interface {\n\treturn new(alwaysDeny)\n}\n\nfunc (alwaysDeny) Admit(a admission.Attributes) (err error) ", "output": "{\n\treturn admission.NewForbidden(a, errors.New(\"Admission control is denying all modifications\"))\n}"}
{"input": "package core\n\nimport (\n\t\"fmt\"\n)\n\ntype BuiltInClass struct {\n\tname   Instance\n\tsupers []Class\n\tslots  []Instance\n}\n\n\n\nfunc (p BuiltInClass) Supers() []Class {\n\treturn p.supers\n}\n\nfunc (p BuiltInClass) Slots() []Instance {\n\treturn p.slots\n}\n\nfunc (p BuiltInClass) Initform(arg Instance) (v Instance, ok bool) {\n\treturn nil, false\n}\n\nfunc (p BuiltInClass) Initarg(arg Instance) (v Instance, ok bool) {\n\treturn arg, true\n}\n\nfunc (BuiltInClass) Class() Class {\n\treturn BuiltInClassClass\n}\n\nfunc (p BuiltInClass) String() string {\n\treturn fmt.Sprint(p.name)\n}\n\nfunc NewBuiltInClass(name string, super Class, slots ...string) Class ", "output": "{\n\tslotNames := []Instance{}\n\tfor _, slot := range slots {\n\t\tslotNames = append(slotNames, NewSymbol(slot))\n\t}\n\treturn BuiltInClass{NewSymbol(name), []Class{super}, slotNames}\n}"}
{"input": "package controllers\n\nimport (\n\tboshlog \"github.com/cloudfoundry/bosh-utils/logger\"\n\tmartrend \"github.com/martini-contrib/render\"\n\n\t\"github.com/cppforlife/turbulence/incident\"\n\t\"github.com/cppforlife/turbulence/scheduledinc\"\n)\n\ntype HomeController struct {\n\tincidentsRepo          incident.Repo\n\tscheduledIncidentsRepo scheduledinc.Repo\n\n\thomeTmpl  string\n\terrorTmpl string\n\n\tlogTag string\n\tlogger boshlog.Logger\n}\n\nfunc NewHomeController(\n\tincidentsRepo incident.Repo,\n\tscheduledIncidentsRepo scheduledinc.Repo,\n\tlogger boshlog.Logger,\n) HomeController {\n\treturn HomeController{\n\t\tincidentsRepo:          incidentsRepo,\n\t\tscheduledIncidentsRepo: scheduledIncidentsRepo,\n\n\t\thomeTmpl:  \"home/home\",\n\t\terrorTmpl: \"error\",\n\n\t\tlogTag: \"HomeController\",\n\t\tlogger: logger,\n\t}\n}\n\ntype HomePage struct {\n\tIncidents          incident.IncidentsResp\n\tScheduledIncidents scheduledinc.Responses\n}\n\n\n\nfunc (c HomeController) Home(r martrend.Render) ", "output": "{\n\tis, err := c.incidentsRepo.ListAll()\n\tif err != nil {\n\t\tr.HTML(500, c.errorTmpl, err)\n\t\treturn\n\t}\n\n\tsis, err := c.scheduledIncidentsRepo.ListAll()\n\tif err != nil {\n\t\tr.HTML(500, c.errorTmpl, err)\n\t\treturn\n\t}\n\n\tpage := HomePage{\n\t\tIncidents:          incident.NewResponses(is),\n\t\tScheduledIncidents: scheduledinc.NewResponses(sis),\n\t}\n\n\tr.HTML(200, c.homeTmpl, page)\n}"}
{"input": "package rpc_test\n\nimport (\n\t\"testing\"\n\n\tgc \"gopkg.in/check.v1\"\n)\n\n\n\nfunc Test(t *testing.T) ", "output": "{\n\tgc.TestingT(t)\n}"}
{"input": "package pttw\n\nimport (\n\t\"github.com/assertgo/assert\"\n\t\"testing\"\n\t\"bytes\"\n)\n\nfunc TestWriterShouldWriteSlice(t *testing.T) {\n\tassert := assert.New(t)\n\tbuffer := bytes.Buffer{}\n\tWrite([]float64{1}, &buffer)\n\tassert.That(true).IsEqualTo(true)\n\tassert.That(buffer.String()).IsEqualTo(\"1\\n\")\n}\n\n\n\nfunc TestWriterShouldWriteSliceDelimitedWithSpaces(t *testing.T) ", "output": "{\n\tassert := assert.New(t)\n\tbuffer := bytes.Buffer{}\n\tWrite([]float64{1, 2}, &buffer)\n\tassert.That(true).IsEqualTo(true)\n\tassert.That(buffer.String()).IsEqualTo(\"1 2\\n\")\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/mreithub/goref\"\n)\n\nfunc indexHTML(w http.ResponseWriter, r *http.Request) {\n\tref := goref.Ref(\"/\")\n\tdefer ref.Deref()\n\n\tw.Write([]byte(`<h1>Index</h1>\n  <a href=\"/delayed.html\">delayed.html</a><br />\n  <a href=\"/goref.json\">goref.json</a>`))\n}\n\n\n\nfunc gorefJSON(w http.ResponseWriter, r *http.Request) {\n\tref := goref.Ref(\"/goref.json\")\n\tdefer ref.Deref()\n\n\tdata, _ := json.MarshalIndent(goref.GetSnapshot().Data, \"\", \"  \")\n\n\tw.Header().Add(\"Content-type\", \"application/json\")\n\tw.Write(data)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", indexHTML)\n\thttp.HandleFunc(\"/delayed.html\", delayedHTML)\n\thttp.HandleFunc(\"/goref.json\", gorefJSON)\n\n\thttp.ListenAndServe(\"localhost:1234\", nil)\n}\n\nfunc delayedHTML(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tref := goref.Ref(\"/delayed.html\")\n\tdefer ref.Deref()\n\n\ttime.Sleep(200 * time.Millisecond)\n\tmsg := fmt.Sprintf(\"The time is %s\", time.Now().String())\n\tw.Write([]byte(msg))\n}"}
{"input": "package armrecoveryservicessiterecovery_test\n\nimport (\n\t\"context\"\n\t\"log\"\n\n\t\"github.com/Azure/azure-sdk-for-go/sdk/azidentity\"\n\t\"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/recoveryservices/armrecoveryservicessiterecovery\"\n)\n\n\nfunc ExampleReplicationEligibilityResultsClient_List() {\n\tcred, err := azidentity.NewDefaultAzureCredential(nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to obtain a credential: %v\", err)\n\t}\n\tctx := context.Background()\n\tclient := armrecoveryservicessiterecovery.NewReplicationEligibilityResultsClient(\"<resource-group-name>\",\n\t\t\"<subscription-id>\", cred, nil)\n\tres, err := client.List(ctx,\n\t\t\"<virtual-machine-name>\",\n\t\tnil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"Response result: %#v\\n\", res.ReplicationEligibilityResultsClientListResult)\n}\n\n\n\n\nfunc ExampleReplicationEligibilityResultsClient_Get() ", "output": "{\n\tcred, err := azidentity.NewDefaultAzureCredential(nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to obtain a credential: %v\", err)\n\t}\n\tctx := context.Background()\n\tclient := armrecoveryservicessiterecovery.NewReplicationEligibilityResultsClient(\"<resource-group-name>\",\n\t\t\"<subscription-id>\", cred, nil)\n\tres, err := client.Get(ctx,\n\t\t\"<virtual-machine-name>\",\n\t\tnil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"Response result: %#v\\n\", res.ReplicationEligibilityResultsClientGetResult)\n}"}
{"input": "package probers\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/letsencrypt/boulder/cmd\"\n)\n\nvar (\n\tRegistry = make(map[string]Configurer)\n)\n\n\ntype Prober interface {\n\tName() string\n\n\tKind() string\n\n\tProbe(time.Duration) (bool, time.Duration)\n}\n\n\ntype Configurer interface {\n\tUnmarshalSettings([]byte) (Configurer, error)\n\n\tMakeProber() (Prober, error)\n}\n\n\n\n\n\ntype Settings map[string]interface{}\n\n\n\n\n\n\n\n\n\nfunc Register(kind string, c Configurer) {\n\tname := strings.Trim(strings.ToLower(kind), \" \")\n\tif _, exists := Registry[name]; exists {\n\t\tcmd.Fail(fmt.Sprintf(\n\t\t\t\"problem registering configurer %s: name collision\", kind))\n\t}\n\tRegistry[name] = c\n}\n\nfunc GetConfigurer(kind string) (Configurer, error) ", "output": "{\n\tname := strings.Trim(strings.ToLower(kind), \" \")\n\tif _, ok := Registry[name]; ok {\n\t\treturn Registry[name], nil\n\t}\n\treturn nil, fmt.Errorf(\"%s is not a registered Prober type\", kind)\n}"}
{"input": "package things\n\n\n\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n\tgolangswaggerpaths \"path\"\n\t\"strings\"\n\n\t\"github.com/go-openapi/strfmt\"\n)\n\n\ntype ThingsReferencesDeleteURL struct {\n\tID           strfmt.UUID\n\tPropertyName string\n\n\t_basePath string\n\t_ struct{}\n}\n\n\n\n\nfunc (o *ThingsReferencesDeleteURL) WithBasePath(bp string) *ThingsReferencesDeleteURL {\n\to.SetBasePath(bp)\n\treturn o\n}\n\n\n\n\nfunc (o *ThingsReferencesDeleteURL) SetBasePath(bp string) {\n\to._basePath = bp\n}\n\n\n\n\n\nfunc (o *ThingsReferencesDeleteURL) Must(u *url.URL, err error) *url.URL {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif u == nil {\n\t\tpanic(\"url can't be nil\")\n\t}\n\treturn u\n}\n\n\nfunc (o *ThingsReferencesDeleteURL) String() string {\n\treturn o.Must(o.Build()).String()\n}\n\n\nfunc (o *ThingsReferencesDeleteURL) BuildFull(scheme, host string) (*url.URL, error) {\n\tif scheme == \"\" {\n\t\treturn nil, errors.New(\"scheme is required for a full url on ThingsReferencesDeleteURL\")\n\t}\n\tif host == \"\" {\n\t\treturn nil, errors.New(\"host is required for a full url on ThingsReferencesDeleteURL\")\n\t}\n\n\tbase, err := o.Build()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbase.Scheme = scheme\n\tbase.Host = host\n\treturn base, nil\n}\n\n\nfunc (o *ThingsReferencesDeleteURL) StringFull(scheme, host string) string {\n\treturn o.Must(o.BuildFull(scheme, host)).String()\n}\n\nfunc (o *ThingsReferencesDeleteURL) Build() (*url.URL, error) ", "output": "{\n\tvar _result url.URL\n\n\tvar _path = \"/things/{id}/references/{propertyName}\"\n\n\tid := o.ID.String()\n\tif id != \"\" {\n\t\t_path = strings.Replace(_path, \"{id}\", id, -1)\n\t} else {\n\t\treturn nil, errors.New(\"id is required on ThingsReferencesDeleteURL\")\n\t}\n\n\tpropertyName := o.PropertyName\n\tif propertyName != \"\" {\n\t\t_path = strings.Replace(_path, \"{propertyName}\", propertyName, -1)\n\t} else {\n\t\treturn nil, errors.New(\"propertyName is required on ThingsReferencesDeleteURL\")\n\t}\n\n\t_basePath := o._basePath\n\tif _basePath == \"\" {\n\t\t_basePath = \"/v1\"\n\t}\n\t_result.Path = golangswaggerpaths.Join(_basePath, _path)\n\n\treturn &_result, nil\n}"}
{"input": "package get_cocoa\n\nimport (\n\t\"log\"\n\n\t\"github.com/gonum/plot\"\n\t\"github.com/gonum/plot/plotter\"\n\t\"github.com/gonum/plot/plotutil\"\n\t\"github.com/gonum/plot/vg\"\n)\n\ntype PlotStruct struct {\n\tX float64\n\tY float64\n}\n\n\n\nfunc Plot(series plotter.XYs) ", "output": "{\n\tp, err := plot.New()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tp.Title.Text = \"Time Series\"\n\tp.X.Label.Text = \"Day #\"\n\tp.Y.Label.Text = \"Price\"\n\n\terr = plotutil.AddLinePoints(p,\n\t\t\"Close\", series,\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := p.Save(12*vg.Inch, 6*vg.Inch, \"price.png\"); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"input": "package poll\n\nimport \"syscall\"\n\n\n\n\nfunc SendFile(fd *FD, src syscall.Handle, n int64) (int64, error) ", "output": "{\n\tif err := fd.writeLock(); err != nil {\n\t\treturn 0, err\n\t}\n\tdefer fd.writeUnlock()\n\n\to := &fd.wop\n\to.qty = uint32(n)\n\to.handle = src\n\tdone, err := wsrv.ExecIO(o, func(o *operation) error {\n\t\treturn syscall.TransmitFile(o.fd.Sysfd, o.handle, o.qty, 0, &o.o, nil, syscall.TF_WRITE_BEHIND)\n\t})\n\treturn int64(done), err\n}"}
{"input": "package geometry\n\nimport (\n\t\"fmt\"\n)\n\ntype Ray struct {\n\tstart, direction *Vector2\n}\n\nfunc NewRayFromFloat(direction float64) *Ray {\n\treturn NewRayFromVector2(NewVector2FromDirection(direction))\n}\n\nfunc NewRayFromVector2(direction *Vector2) *Ray {\n\treturn NewRayFromVector2Vector2(new(Vector2), direction)\n}\n\nfunc NewRayFromVector2Float(start *Vector2, direction float64) *Ray {\n\treturn NewRayFromVector2Vector2(start, NewVector2FromDirection(direction))\n}\n\nfunc NewRayFromVector2Vector2(start, direction *Vector2) *Ray {\n\tif start == nil || direction == nil || direction.IsZero() {\n\t\tpanic(\"Ray cannot be created from nil arguments or zero direction\")\n\t}\n\tr := new(Ray)\n\tr.start = start\n\tr.direction = direction\n\treturn r\n}\n\nfunc (r *Ray) GetStart() *Vector2 {\n\treturn r.start\n}\n\n\n\nfunc (r *Ray) GetDirectionFloat() float64 {\n\treturn r.direction.GetDirection()\n}\n\nfunc (r *Ray) SetDirectionFloat(direction float64) {\n\tr.direction = NewVector2FromDirection(direction)\n}\n\nfunc (r *Ray) GetDirectionVector2() *Vector2 {\n\treturn r.direction\n}\n\nfunc (r *Ray) SetDirectionVector2(direction *Vector2) {\n\tif direction == nil || direction.IsZero() {\n\t\tpanic(\"Ray direction cannot be created from nil argument or be zero\")\n\t}\n\tr.direction = direction\n}\n\nfunc (r *Ray) String() string {\n\treturn fmt.Sprintf(\"Ray[Start=%v|Direction=%v]\", r.start, r.direction)\n}\n\nfunc (r *Ray) SetStart(start *Vector2) ", "output": "{\n\tif start == nil {\n\t\tpanic(\"Cannot set Ray to have a nil start point\")\n\t}\n\tr.start = start\n}"}
{"input": "package libytc\n\nimport (\n\t\"fmt\"\n\t\"log\"\n)\n\ntype UnknownUpdate struct {\n\tpayload string\n\tchain   string\n\tType    string\n}\n\nfunc NewUnknownUpdate(payload string, chain string, Type string) (t *UnknownUpdate) {\n\tt = new(UnknownUpdate)\n\tt.payload = payload\n\tt.chain = chain\n\tt.Type = Type\n\treturn\n}\n\nfunc (t *UnknownUpdate) Verify(i interface{}) (err error) {\n\tlog.Fatal(\"Cannot Verify Unknown Update\")\n\treturn\n}\n\nfunc (t *UnknownUpdate) Apply(i interface{}) {\n\tlog.Fatal(\"Cannot Apply Unknown Update\")\n\treturn\n}\n\nfunc (t *UnknownUpdate) Chain() string {\n\treturn t.chain\n}\n\nfunc (t *UnknownUpdate) String() string {\n\treturn fmt.Sprint(t)\n}\n\n\n\nfunc (t *UnknownUpdate) MarshallJSON(b []byte, err error) ", "output": "{\n\tb = []byte(t.payload)\n\treturn\n}"}
{"input": "package uiconv\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/zap\"\n)\n\n\n\nfunc TestModule_TraceNonExistent(t *testing.T) {\n\tinputFile := \"fixtures/trace_non_existent.json\"\n\toutputFile := \"fixtures/trace_non_existent_ui_anonymized.json\"\n\tdefer os.Remove(outputFile)\n\n\tconfig := Config{\n\t\tCapturedFile: inputFile,\n\t\tUIFile:       outputFile,\n\t\tTraceID:      \"2be38093ead7a083\",\n\t}\n\terr := Extract(config, zap.NewNop())\n\trequire.Contains(t, err.Error(), \"cannot open captured file\")\n}\n\nfunc TestModule_TraceOutputFileError(t *testing.T) {\n\tinputFile := \"fixtures/trace_success.json\"\n\toutputFile := \"fixtures/trace_success_ui_anonymized.json\"\n\tdefer os.Remove(outputFile)\n\n\tconfig := Config{\n\t\tCapturedFile: inputFile,\n\t\tUIFile:       outputFile,\n\t\tTraceID:      \"2be38093ead7a083\",\n\t}\n\n\terr := os.Chmod(\"fixtures\", 0550)\n\trequire.NoError(t, err)\n\tdefer os.Chmod(\"fixtures\", 0755)\n\n\terr = Extract(config, zap.NewNop())\n\trequire.Contains(t, err.Error(), \"cannot create output file\")\n}\n\nfunc TestModule_TraceSuccess(t *testing.T) ", "output": "{\n\tinputFile := \"fixtures/trace_success.json\"\n\toutputFile := \"fixtures/trace_success_ui_anonymized.json\"\n\tdefer os.Remove(outputFile)\n\n\tconfig := Config{\n\t\tCapturedFile: inputFile,\n\t\tUIFile:       outputFile,\n\t\tTraceID:      \"2be38093ead7a083\",\n\t}\n\terr := Extract(config, zap.NewNop())\n\trequire.NoError(t, err)\n\n\tvar trace UITrace\n\tloadJSON(t, outputFile, &trace)\n\n\tfor i := range trace.Data {\n\t\tfor j := range trace.Data[i].Spans {\n\t\t\tassert.Equal(t, \"span.kind\", trace.Data[i].Spans[j].Tags[0].Key)\n\t\t}\n\t}\n}"}
{"input": "package install\n\nimport (\n\t\"k8s.io/apimachinery/pkg/apimachinery/announced\"\n\t\"k8s.io/apimachinery/pkg/apimachinery/registered\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/kubernetes/pkg/api/legacyscheme\"\n\t\"k8s.io/kubernetes/pkg/apis/batch\"\n\t\"k8s.io/kubernetes/pkg/apis/batch/v1\"\n\t\"k8s.io/kubernetes/pkg/apis/batch/v1beta1\"\n\t\"k8s.io/kubernetes/pkg/apis/batch/v2alpha1\"\n\n\t_ \"k8s.io/kubernetes/pkg/apis/extensions/install\"\n)\n\nfunc init() {\n\tInstall(legacyscheme.GroupFactoryRegistry, legacyscheme.Registry, legacyscheme.Scheme)\n}\n\n\n\n\nfunc Install(groupFactoryRegistry announced.APIGroupFactoryRegistry, registry *registered.APIRegistrationManager, scheme *runtime.Scheme) ", "output": "{\n\tif err := announced.NewGroupMetaFactory(\n\t\t&announced.GroupMetaFactoryArgs{\n\t\t\tGroupName:                  batch.GroupName,\n\t\t\tVersionPreferenceOrder:     []string{v1.SchemeGroupVersion.Version, v1beta1.SchemeGroupVersion.Version, v2alpha1.SchemeGroupVersion.Version},\n\t\t\tAddInternalObjectsToScheme: batch.AddToScheme,\n\t\t},\n\t\tannounced.VersionToSchemeFunc{\n\t\t\tv1.SchemeGroupVersion.Version:       v1.AddToScheme,\n\t\t\tv1beta1.SchemeGroupVersion.Version:  v1beta1.AddToScheme,\n\t\t\tv2alpha1.SchemeGroupVersion.Version: v2alpha1.AddToScheme,\n\t\t},\n\t).Announce(groupFactoryRegistry).RegisterAndEnable(registry, scheme); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"input": "package kubernetes\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/davecgh/go-spew/spew\"\n\t\"k8s.io/apimachinery/pkg/api/meta\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n)\n\n\n\n\nfunc PrintObject(object runtime.Object) (s string) ", "output": "{\n\n\tif object == nil {\n\t\treturn \"<nil kubernetes object>\"\n\t}\n\n\taccessor, err := meta.Accessor(object)\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"<invalid object: %s\", err)\n\t}\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\ts = fmt.Sprintf(\"print object paniced: %v; print accessor: %s\", r, spew.Sdump(accessor, object))\n\t\t}\n\n\t}()\n\n\treturn fmt.Sprintf(\"<%s %s>\", object.GetObjectKind().GroupVersionKind(), accessor.GetName())\n}"}
{"input": "package wicore\n\nimport \"fmt\"\n\nconst _BorderType_name = \"BorderNoneBorderSingleBorderDouble\"\n\nvar _BorderType_index = [...]uint8{0, 10, 22, 34}\n\n\n\nconst _CommandCategory_name = \"UnknownCategoryWindowCategoryCommandsCategoryEditorCategoryDebugCategory\"\n\nvar _CommandCategory_index = [...]uint8{0, 15, 29, 45, 59, 72}\n\nfunc (i CommandCategory) String() string {\n\tif i < 0 || i+1 >= CommandCategory(len(_CommandCategory_index)) {\n\t\treturn fmt.Sprintf(\"CommandCategory(%d)\", i)\n\t}\n\treturn _CommandCategory_name[_CommandCategory_index[i]:_CommandCategory_index[i+1]]\n}\n\nconst _DockingType_name = \"DockingUnknownDockingFillDockingFloatingDockingLeftDockingRightDockingTopDockingBottom\"\n\nvar _DockingType_index = [...]uint8{0, 14, 25, 40, 51, 63, 73, 86}\n\nfunc (i DockingType) String() string {\n\tif i < 0 || i+1 >= DockingType(len(_DockingType_index)) {\n\t\treturn fmt.Sprintf(\"DockingType(%d)\", i)\n\t}\n\treturn _DockingType_name[_DockingType_index[i]:_DockingType_index[i+1]]\n}\n\nconst _KeyboardMode_name = \"NormalInsertAllMode\"\n\nvar _KeyboardMode_index = [...]uint8{0, 6, 12, 19}\n\nfunc (i KeyboardMode) String() string {\n\ti -= 1\n\tif i < 0 || i+1 >= KeyboardMode(len(_KeyboardMode_index)) {\n\t\treturn fmt.Sprintf(\"KeyboardMode(%d)\", i+1)\n\t}\n\treturn _KeyboardMode_name[_KeyboardMode_index[i]:_KeyboardMode_index[i+1]]\n}\n\nfunc (i BorderType) String() string ", "output": "{\n\tif i < 0 || i+1 >= BorderType(len(_BorderType_index)) {\n\t\treturn fmt.Sprintf(\"BorderType(%d)\", i)\n\t}\n\treturn _BorderType_name[_BorderType_index[i]:_BorderType_index[i+1]]\n}"}
{"input": "package faregate\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc Must(c <-chan struct{}, err error) <-chan struct{} {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn c\n}\n\n\n\nfunc Example() ", "output": "{\n\trnd := rand.New(rand.NewSource(42))\n\n\tfg, err := New(RefreshInterval(time.Second), TokenCount(100), ConcurrencyLevel(1))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer fg.Close()\n\n\tfor {\n\t\tq := rnd.Intn(10)\n\t\t<-Must(fg.Acquire(uint64(q)))\n\t\tfmt.Println(\"acquired\", q)\n\t}\n}"}
{"input": "package logging\n\nimport (\n\t\"log\"\n\n\t\"github.com/hashicorp/nomad/client/allocdir\"\n\tcstructs \"github.com/hashicorp/nomad/client/driver/structs\"\n\t\"github.com/hashicorp/nomad/nomad/structs\"\n)\n\n\ntype LogCollectorContext struct {\n\tTaskName string\n\n\tAllocDir *allocdir.AllocDir\n\n\tLogConfig *structs.LogConfig\n\n\tPortUpperBound uint\n\n\tPortLowerBound uint\n}\n\n\n\ntype SyslogCollectorState struct {\n\tIsolationConfig *cstructs.IsolationConfig\n\tAddr            string\n}\n\n\n\ntype LogCollector interface {\n\tLaunchCollector(ctx *LogCollectorContext) (*SyslogCollectorState, error)\n\tExit() error\n\tUpdateLogConfig(logConfig *structs.LogConfig) error\n}\n\n\n\ntype SyslogCollector struct {\n}\n\n\nfunc NewSyslogCollector(logger *log.Logger) *SyslogCollector {\n\treturn &SyslogCollector{}\n}\n\n\n\nfunc (s *SyslogCollector) LaunchCollector(ctx *LogCollectorContext) (*SyslogCollectorState, error) {\n\treturn nil, nil\n}\n\n\nfunc (s *SyslogCollector) Exit() error {\n\treturn nil\n}\n\n\n\n\nfunc (s *SyslogCollector) UpdateLogConfig(logConfig *structs.LogConfig) error ", "output": "{\n\treturn nil\n}"}
{"input": "package console\n\nimport (\n\t\"github.com/cgrates/cgrates/engine\"\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\nfunc init() {\n\tc := &CmdGetAttributes{\n\t\tname:      \"attributes\",\n\t\trpcMethod: utils.APIerSv1GetAttributeProfile,\n\t\trpcParams: &utils.TenantID{},\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}\n\n\ntype CmdGetAttributes struct {\n\tname      string\n\trpcMethod string\n\trpcParams *utils.TenantID\n\t*CommandExecuter\n}\n\nfunc (self *CmdGetAttributes) Name() string {\n\treturn self.name\n}\n\nfunc (self *CmdGetAttributes) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\nfunc (self *CmdGetAttributes) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &utils.TenantID{}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *CmdGetAttributes) PostprocessRpcParams() error {\n\treturn nil\n}\n\n\n\nfunc (self *CmdGetAttributes) RpcResult() interface{} ", "output": "{\n\tvar atr engine.AttributeProfile\n\treturn &atr\n}"}
{"input": "package tokbox\n\nimport (\n\t\"golang.org/x/net/context\"\n\t\"net/http\"\n)\n\n\n\nfunc client(ctx *context.Context) *http.Client ", "output": "{\n\treturn &http.Client{}\n}"}
{"input": "package set\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype Set struct {\n\titems map[interface{}]struct{}\n}\n\nvar blank = struct{}{}\n\nfunc NewHashset() *Set {\n\treturn &Set{items: make(map[interface{}]struct{})}\n}\n\nfunc (set *Set) Add(items ...interface{}) {\n\tfor _, item := range items {\n\t\tset.items[item] = blank\n\t}\n}\n\n\n\nfunc (set *Set) Contains(items ...interface{}) bool {\n\tfor _, item := range items {\n\t\tif _, contains := set.items[item]; !contains {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (set *Set) Empty() bool {\n\treturn len(set.items) == 0\n}\n\nfunc (set *Set) Size() int {\n\treturn len(set.items)\n}\n\nfunc (set *Set) Clear() {\n\tset.items = make(map[interface{}]struct{})\n}\n\nfunc (set *Set) Values() []interface{} {\n\tvalues := make([]interface{}, set.Size())\n\tcount := 0\n\tfor item := range set.items {\n\t\tvalues[count] = item\n\t\tcount++\n\t}\n\treturn values\n}\n\nfunc (set *Set) ToStringArray() []string {\n\titems := make([]string, 0, len(set.items))\n\tfor k := range set.items {\n\t\titems = append(items, fmt.Sprintf(\"%v\", k))\n\t}\n\treturn items\n}\n\nfunc (set *Set) String() string {\n\tstr := \"[\"\n\tstr += strings.Join(set.ToStringArray(), \", \")\n\treturn str + \"]\"\n}\n\nfunc ToInterfaces(size int, h func(i int) interface{}) (list []interface{}) {\n\tfor i := 0; i < size; i++ {\n\t\tlist = append(list, h(i))\n\t}\n\treturn\n}\n\nfunc (set *Set) Remove(items ...interface{}) ", "output": "{\n\tfor _, item := range items {\n\t\tdelete(set.items, item)\n\t}\n}"}
{"input": "package executorinfo\n\nimport (\n\t\"container/list\"\n\t\"errors\"\n\n\t\"github.com/mesos/mesos-go/mesosproto\"\n)\n\n\n\ntype Cache struct {\n\tmaxEntries int\n\tll         *list.List\n\tcache      map[string]*list.Element \n}\n\ntype entry struct {\n\thostname string\n\tinfo     *mesosproto.ExecutorInfo\n}\n\n\n\nfunc NewCache(maxEntries int) (*Cache, error) {\n\tif maxEntries <= 0 {\n\t\treturn nil, errors.New(\"invalid maxEntries value\")\n\t}\n\n\treturn &Cache{\n\t\tmaxEntries: maxEntries,\n\t\tll:         list.New(), \n\t\tcache:      make(map[string]*list.Element),\n\t}, nil\n}\n\n\nfunc (c *Cache) Add(hostname string, e *mesosproto.ExecutorInfo) {\n\tif ee, ok := c.cache[hostname]; ok {\n\t\tc.ll.MoveToFront(ee)\n\t\tee.Value.(*entry).info = e\n\t\treturn\n\t}\n\tel := c.ll.PushFront(&entry{hostname, e})\n\tc.cache[hostname] = el\n\tif c.ll.Len() > c.maxEntries {\n\t\tc.RemoveOldest()\n\t}\n}\n\n\n\n\n\nfunc (c *Cache) Remove(hostname string) {\n\tif el, hit := c.cache[hostname]; hit {\n\t\tc.removeElement(el)\n\t}\n}\n\n\nfunc (c *Cache) RemoveOldest() {\n\toldest := c.ll.Back()\n\tif oldest != nil {\n\t\tc.removeElement(oldest)\n\t}\n}\n\nfunc (c *Cache) removeElement(el *list.Element) {\n\tc.ll.Remove(el)\n\tkv := el.Value.(*entry)\n\tdelete(c.cache, kv.hostname)\n}\n\nfunc (c *Cache) Get(hostname string) (e *mesosproto.ExecutorInfo, ok bool) ", "output": "{\n\tif el, hit := c.cache[hostname]; hit {\n\t\tc.ll.MoveToFront(el)\n\t\treturn el.Value.(*entry).info, true\n\t}\n\treturn\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\ntype stackEntry interface {\n\tString() string\n\tType() string\n}\n\ntype lenable interface {\n\tLength() int\n}\n\ntype Boolean bool\ntype Integer int\ntype Double float64\ntype Dict map[string]stackEntry\ntype Array []stackEntry\ntype String string\n\n\ntype quotation []word\n\nfunc (s String) String() string {\n\treturn \"<<\" + string(s) + \">>\"\n}\nfunc (b Boolean) String() string {\n\tif bool(b) {\n\t\treturn \"t\"\n\t}\n\treturn \"f\"\n}\n\nfunc (i Integer) String() string {\n\treturn strconv.Itoa(int(i))\n}\n\nfunc (d Double) String() string {\n\treturn fmt.Sprint(float64(d))\n}\n\nfunc (q quotation) String() string {\n\treturn fmt.Sprint([]word(q))\n}\n\nfunc (dict Dict) String() string {\n\treturn fmt.Sprint(map[string]stackEntry(dict))\n}\n\nfunc (a Array) String() string {\n\treturn fmt.Sprint([]stackEntry(a))\n}\n\nfunc (i Integer) Type() string {\n\treturn \"Integer\"\n}\n\nfunc (d Double) Type() string {\n\treturn \"Double\"\n}\n\nfunc (q quotation) Type() string {\n\treturn \"Quotation\"\n}\n\nfunc (a Array) Type() string {\n\treturn \"Vector\"\n}\n\nfunc (dict Dict) Type() string {\n\treturn \"Dictionary\"\n}\n\nfunc (b Boolean) Type() string {\n\treturn \"Boolean\"\n}\n\n\n\nfunc (dict Dict) Length() int {\n\treturn len(dict)\n}\n\nfunc (a Array) Length() int {\n\treturn len(a)\n}\n\nfunc (s String) Type() string ", "output": "{\n\treturn \"String\"\n}"}
{"input": "package fake\n\nimport (\n\trest \"k8s.io/client-go/rest\"\n\ttesting \"k8s.io/client-go/testing\"\n\n\tv1beta1 \"kubevirt.io/client-go/generated/containerized-data-importer/clientset/versioned/typed/core/v1beta1\"\n)\n\ntype FakeCdiV1beta1 struct {\n\t*testing.Fake\n}\n\n\n\nfunc (c *FakeCdiV1beta1) CDIConfigs() v1beta1.CDIConfigInterface {\n\treturn &FakeCDIConfigs{c}\n}\n\nfunc (c *FakeCdiV1beta1) DataImportCrons(namespace string) v1beta1.DataImportCronInterface {\n\treturn &FakeDataImportCrons{c, namespace}\n}\n\nfunc (c *FakeCdiV1beta1) DataSources(namespace string) v1beta1.DataSourceInterface {\n\treturn &FakeDataSources{c, namespace}\n}\n\nfunc (c *FakeCdiV1beta1) DataVolumes(namespace string) v1beta1.DataVolumeInterface {\n\treturn &FakeDataVolumes{c, namespace}\n}\n\nfunc (c *FakeCdiV1beta1) ObjectTransfers() v1beta1.ObjectTransferInterface {\n\treturn &FakeObjectTransfers{c}\n}\n\nfunc (c *FakeCdiV1beta1) StorageProfiles() v1beta1.StorageProfileInterface {\n\treturn &FakeStorageProfiles{c}\n}\n\n\n\nfunc (c *FakeCdiV1beta1) RESTClient() rest.Interface {\n\tvar ret *rest.RESTClient\n\treturn ret\n}\n\nfunc (c *FakeCdiV1beta1) CDIs() v1beta1.CDIInterface ", "output": "{\n\treturn &FakeCDIs{c}\n}"}
{"input": "package stack\n\nimport \"errors\"\n\ntype Stack []interface{}\n\nfunc (stack Stack) Len() int {\n\treturn len(stack)\n}\n\n\n\nfunc (stack Stack) IsEmpty() bool {\n\treturn len(stack) == 0\n}\n\nfunc (stack *Stack) Push(e interface{}) {\n\t*stack = append(*stack, e)\n}\n\nfunc (stack Stack) Top() (interface{}, error) {\n\tif len(stack) == 0 {\n\t\treturn nil, errors.New(\"stack is empty\")\n\t}\n\treturn stack[len(stack)-1], nil\n}\n\nfunc (stack *Stack) Pop() (interface{}, error) {\n\tstk := *stack\t\n\tif len(stk) == 0 {\n\t\treturn nil, errors.New(\"stack is empty\")\n\t}\n\ttop := stk[len(stk)-1]\n\t*stack = stk[:len(stk)-1] \n\treturn top, nil\n}\n\nfunc (stack Stack) Cap() int ", "output": "{\n\treturn cap(stack)\n}"}
{"input": "package main\n\nimport \"github.com/augustoroman/serial_lcd\"\n\ntype FakeLcd struct{}\n\nfunc (f FakeLcd) SetBG(r, g, b uint8) error      { return nil }\nfunc (f FakeLcd) SetOn(On bool) error            { return nil }\nfunc (f FakeLcd) SetBrightness(b uint8) error    { return nil }\nfunc (f FakeLcd) SetContrast(c uint8) error      { return nil }\nfunc (f FakeLcd) SetAutoscroll(On bool) error    { return nil }\n\nfunc (f FakeLcd) Clear() error                   { return nil }\nfunc (f FakeLcd) Home() error                    { return nil }\nfunc (f FakeLcd) MoveTo(col, row uint8) error    { return nil }\nfunc (f FakeLcd) MoveForward() error             { return nil }\nfunc (f FakeLcd) MoveBack() error                { return nil }\nfunc (f FakeLcd) Write(b []byte) (int, error)    { return len(b), nil }\n\nfunc (f FakeLcd) CreateCustomChar(spot uint8, c serial_lcd.Char) error { return nil }\n\nfunc (f FakeLcd) SetSize(cols, rows uint8) error ", "output": "{ return nil }"}
{"input": "package logsearcher\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype invalidFilenameFormatErr string\n\n\n\nfunc ListFolders(dir string, ch chan string) {\n\tif !strings.HasSuffix(dir, \"/\") {\n\t\tdir = dir + \"/\"\n\t}\n\tdirLength := len(dir)\n\n\tvar previousErr error\n\n\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tpreviousErr = err\n\t\t\tclose(ch)\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\tch <- path[dirLength:]\n\t\t}\n\t\treturn nil\n\t})\n\tif previousErr == nil {\n\t\tclose(ch)\n\t}\n}\n\nfunc ListFiles(dir string, ch chan string) error {\n\tif !strings.HasSuffix(dir, \"/\") {\n\t\tdir = dir + \"/\"\n\t}\n\tdirLength := len(dir)\n\n\tvar previousErr error\n\n\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\tif previousErr != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err != nil {\n\t\t\tpreviousErr = err\n\t\t\tclose(ch)\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() {\n\t\t\tif !strings.HasPrefix(path, dir) {\n\t\t\t\tclose(ch)\n\t\t\t\treturn invalidFilenameFormatErr(fmt.Sprintf(\"Expected file %v to start with %v\", path, dir))\n\t\t\t}\n\t\t\tch <- path[dirLength:]\n\t\t}\n\t\treturn nil\n\t})\n\tif previousErr == nil {\n\t\tclose(ch)\n\t}\n\treturn previousErr\n}\n\nfunc (e invalidFilenameFormatErr) Error() string ", "output": "{\n\treturn string(e)\n}"}
{"input": "package decoration \n\nimport (\n\t\"sort\"\n\t\"sync\"\n)\n\n\n\nvar EmptyDecoration = Decoration{}\n\nvar registry struct {\n\tsync.Mutex\n\ttable map[string]Decoration\n}\n\n\nconst registryApproxSize = 8\n\n\n\n\n\nfunc RegisterDecorationName(name string, decor Decoration) {\n\tregistry.Lock()\n\tregistry.table[name] = decor\n\tregistry.Unlock()\n}\n\n\n\nfunc RegisteredDecorationNames() []string {\n\tregistry.Lock()\n\tdefer registry.Unlock()\n\ta := make([]string, len(registry.table))\n\ti := 0\n\tfor k := range registry.table {\n\t\ta[i] = k\n\t\ti++\n\t}\n\tsort.Strings(a)\n\treturn a\n}\n\n\n\n\nfunc Named(n string) Decoration {\n\tregistry.Lock()\n\td, ok := registry.table[n]\n\tregistry.Unlock()\n\tif ok {\n\t\treturn d\n\t}\n\treturn EmptyDecoration\n}\n\nfunc init() ", "output": "{\n\tregistry.Lock()\n\tregistry.table = make(map[string]Decoration, registryApproxSize)\n\tregistry.Unlock()\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pcdummy/go-bidirpc\"\n\t\"github.com/pcdummy/go-bidirpc/gobrpc\"\n\t\"log\"\n\t\"net\"\n)\n\ntype EchoArgs struct {\n\tEchoMe string `bson:\"echoMe\"`\n}\n\ntype EchoReply struct {\n\tResult string\n}\n\ntype Arith struct {\n\tcount int\n\tp     *bidirpc.Protocol\n}\n\n\n\nfunc (t *Arith) Echo(args *EchoArgs, reply *EchoReply) error {\n\tfmt.Println(\"Echo from Server:\", args.EchoMe)\n\n\treply.Result = args.EchoMe\n\treturn nil\n}\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"localhost:9990\")\n\tif err != nil {\n\t\tlog.Fatal(\"dialing:\", err)\n\t}\n\n\tclient := gobrpc.NewClient(conn)\n\tclient.Register(new(Arith))\n\tdefer client.Close()\n\n\tvar reply EchoReply\n\terr = client.Call(\"Arith.Echo\", &EchoArgs{EchoMe: \"Hello world!\"}, &reply)\n\n\tif err != nil {\n\t\tlog.Fatal(\"error:\", err)\n\t}\n\n\tfmt.Printf(\"Reply is: %s\\n\", reply.Result)\n}\n\nfunc (t *Arith) SetProtocol(p *bidirpc.Protocol) ", "output": "{\n\tt.p = p\n}"}
{"input": "package common\n\nimport \"math/big\"\n\ntype _N_ [_S_]byte\n\nfunc BytesTo_N_(b []byte) _N_ {\n\tvar h _N_\n\th.SetBytes(b)\n\treturn h\n}\n\nfunc BigTo_N_(b *big.Int) _N_  { return BytesTo_N_(b.Bytes()) }\nfunc HexTo_N_(s string) _N_    { return BytesTo_N_(FromHex(s)) }\n\n\n\n\nfunc (h _N_) Str() string   { return string(h[:]) }\nfunc (h _N_) Bytes() []byte { return h[:] }\nfunc (h _N_) Big() *big.Int { return Bytes2Big(h[:]) }\nfunc (h _N_) Hex() string   { return \"0x\" + Bytes2Hex(h[:]) }\n\n\nfunc (h *_N_) SetBytes(b []byte) {\n\tif len(b) > len(h) {\n\t\tb = b[len(b)-_S_:]\n\t}\n\n\tfor i := len(b) - 1; i >= 0; i-- {\n\t\th[_S_-len(b)+i] = b[i]\n\t}\n}\n\n\nfunc (h *_N_) SetString(s string) { h.SetBytes([]byte(s)) }\n\n\nfunc (h *_N_) Set(other _N_) {\n\tfor i, v := range other {\n\t\th[i] = v\n\t}\n}\n\nfunc StringTo_N_(s string) _N_ ", "output": "{ return BytesTo_N_([]byte(s)) }"}
{"input": "package fitasks\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"k8s.io/kops/upup/pkg/fi\"\n)\n\n\n\nfunc TestKeypairDeps(t *testing.T) ", "output": "{\n\tca := &Keypair{\n\t\tName: fi.String(\"ca\"),\n\t}\n\tcert := &Keypair{\n\t\tName:   fi.String(\"cert\"),\n\t\tSigner: ca,\n\t}\n\n\ttasks := make(map[string]fi.Task)\n\ttasks[\"ca\"] = ca\n\ttasks[\"cert\"] = cert\n\n\tdeps := fi.FindTaskDependencies(tasks)\n\n\tif strings.Join(deps[\"ca\"], \",\") != \"\" {\n\t\tt.Errorf(\"unexpected dependencies for ca: %v\", deps[\"ca\"])\n\t}\n\n\tif strings.Join(deps[\"cert\"], \",\") != \"ca\" {\n\t\tt.Errorf(\"unexpected dependencies for cert: %v\", deps[\"cert\"])\n\t}\n}"}
{"input": "package net_sniff\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/bettercap/bettercap/session\"\n\n\t\"github.com/evilsocket/islazy/tui\"\n\t\"github.com/google/gopacket/layers\"\n)\n\n\n\nfunc vPort(p interface{}) string {\n\tsp := fmt.Sprintf(\"%d\", p)\n\tif tcp, ok := p.(layers.TCPPort); ok {\n\t\tif name, found := layers.TCPPortNames[tcp]; found {\n\t\t\tsp = tui.Yellow(name)\n\t\t}\n\t} else if udp, ok := p.(layers.UDPPort); ok {\n\t\tif name, found := layers.UDPPortNames[udp]; found {\n\t\t\tsp = tui.Yellow(name)\n\t\t}\n\t}\n\n\treturn sp\n}\n\nvar maxUrlSize = 80\n\nfunc vURL(u string) string {\n\tul := len(u)\n\tif ul > maxUrlSize {\n\t\tu = fmt.Sprintf(\"%s...\", u[0:maxUrlSize-3])\n\t}\n\treturn u\n}\n\nfunc vIP(ip net.IP) string ", "output": "{\n\tif session.I.Interface.IP.Equal(ip) {\n\t\treturn tui.Dim(\"local\")\n\t} else if session.I.Gateway.IP.Equal(ip) {\n\t\treturn \"gateway\"\n\t}\n\n\taddress := ip.String()\n\thost := session.I.Lan.GetByIp(address)\n\tif host != nil {\n\t\tif host.Hostname != \"\" {\n\t\t\treturn host.Hostname\n\t\t}\n\t}\n\n\treturn address\n}"}
{"input": "package dto\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/bborbe/assert\"\n)\n\nfunc TestBackupDateTime(t *testing.T) {\n\tdate := BackupDate(\"2016-10-25T00:01:51\")\n\ttime, err := date.Time()\n\tif err := AssertThat(err, NilValue()); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := AssertThat(time.String(), Is(\"2016-10-25 00:01:51 +0000 UTC\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestFormatDurationDays(t *testing.T) {\n\td, err := time.ParseDuration(\"128h\")\n\tif err := AssertThat(err, NilValue()); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := AssertThat(FormatDuration(d), Is(\"5d\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n\n\nfunc TestFormatDurationMinutes(t *testing.T) {\n\td, err := time.ParseDuration(\"59m30s\")\n\tif err := AssertThat(err, NilValue()); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := AssertThat(FormatDuration(d), Is(\"59m\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestFormatDurationHours(t *testing.T) ", "output": "{\n\td, err := time.ParseDuration(\"8h59m\")\n\tif err := AssertThat(err, NilValue()); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := AssertThat(FormatDuration(d), Is(\"8h\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n}"}
{"input": "package test\n\nimport (\n\t\"os\"\n\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nvar Tmpdir string\n\n\n\nfunc init() ", "output": "{\n\tvar err error\n\tTmpdir, err = os.MkdirTemp(\"\", \"cilium_envoy_go_test\")\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to create a temporaty directory for testing\")\n\t}\n}"}
{"input": "package manifestparser\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\n\tyaml \"gopkg.in/yaml.v2\"\n)\n\ntype Application struct {\n\tName string `yaml:\"name\"`\n}\n\ntype Parser struct {\n\tPathToManifest string\n\n\tApplications []Application\n\n\trawManifest []byte\n}\n\nfunc NewParser() *Parser {\n\treturn new(Parser)\n}\n\n\n\nfunc (parser Parser) AppNames() []string {\n\tvar names []string\n\tfor _, app := range parser.Applications {\n\t\tnames = append(names, app.Name)\n\t}\n\treturn names\n}\n\nfunc (parser Parser) RawManifest(_ string) ([]byte, error) {\n\treturn parser.rawManifest, nil\n}\n\nfunc (parser *Parser) Parse(manifestPath string) error ", "output": "{\n\tbytes, err := ioutil.ReadFile(manifestPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tparser.rawManifest = bytes\n\n\tvar raw struct {\n\t\tApplications []Application `yaml:\"applications\"`\n\t}\n\n\terr = yaml.Unmarshal(bytes, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tparser.Applications = raw.Applications\n\n\tif len(parser.Applications) == 0 {\n\t\treturn errors.New(\"must have at least one application\")\n\t}\n\n\tfor _, application := range parser.Applications {\n\t\tif application.Name == \"\" {\n\t\t\treturn errors.New(\"Found an application with no name specified\")\n\t\t}\n\t}\n\n\treturn nil\n}"}
{"input": "package identitymapper\n\nimport (\n\tuserapi \"github.com/openshift/origin/pkg/user/apis/user/v1\"\n)\n\ntype UserToGroupMapper interface {\n\tGroupsFor(username string) ([]*userapi.Group, error)\n}\n\ntype NoopGroupMapper struct{}\n\n\n\nfunc (n NoopGroupMapper) GroupsFor(username string) ([]*userapi.Group, error) ", "output": "{\n\treturn []*userapi.Group{}, nil\n}"}
{"input": "package conf\n\nimport (\n\t\"errors\"\n\t\"github.com/spf13/viper\"\n)\n\nfunc ReadConfig(filename string) error {\n\n\tviper.SetConfigFile(filename)\n\terr := viper.ReadInConfig()\n\tif err != nil {\n\t\treturn errors.New(err.Error() + (\"Fatal error in config file.\"))\n\t}\n\treturn nil\n}\n\nfunc GetStringValue(key string) string {\n\treturn viper.GetString(key)\n}\n\nfunc GetBoolValue(key string) bool {\n\treturn viper.GetBool(key)\n}\n\n\n\nfunc GetStringArrayValue(key string) []string {\n\treturn viper.GetStringSlice(key)\n}\n\nfunc GetStringMapString(key string) map[string]string {\n\treturn viper.GetStringMapString(key)\n}\n\nfunc GetIntValue(key string) int ", "output": "{\n\treturn viper.GetInt(key)\n}"}
{"input": "package caaa\n\nimport (\n\t\"encoding/xml\"\n\n\t\"github.com/fgrid/iso20022\"\n)\n\ntype Document01600102 struct {\n\tXMLName xml.Name                              `xml:\"urn:iso:std:iso:20022:tech:xsd:caaa.016.001.02 Document\"`\n\tMessage *AcceptorCurrencyConversionRequestV02 `xml:\"AccptrCcyConvsReq\"`\n}\n\n\n\n\n\ntype AcceptorCurrencyConversionRequestV02 struct {\n\n\tHeader *iso20022.Header10 `xml:\"Hdr\"`\n\n\tCurrencyConversionRequest *iso20022.AcceptorCurrencyConversionRequest2 `xml:\"CcyConvsReq\"`\n\n\tSecurityTrailer *iso20022.ContentInformationType11 `xml:\"SctyTrlr\"`\n}\n\nfunc (a *AcceptorCurrencyConversionRequestV02) AddHeader() *iso20022.Header10 {\n\ta.Header = new(iso20022.Header10)\n\treturn a.Header\n}\n\nfunc (a *AcceptorCurrencyConversionRequestV02) AddCurrencyConversionRequest() *iso20022.AcceptorCurrencyConversionRequest2 {\n\ta.CurrencyConversionRequest = new(iso20022.AcceptorCurrencyConversionRequest2)\n\treturn a.CurrencyConversionRequest\n}\n\nfunc (a *AcceptorCurrencyConversionRequestV02) AddSecurityTrailer() *iso20022.ContentInformationType11 {\n\ta.SecurityTrailer = new(iso20022.ContentInformationType11)\n\treturn a.SecurityTrailer\n}\n\nfunc (d *Document01600102) AddMessage() *AcceptorCurrencyConversionRequestV02 ", "output": "{\n\td.Message = new(AcceptorCurrencyConversionRequestV02)\n\treturn d.Message\n}"}
{"input": "package adapter\n\nimport (\n\t\"time\"\n\n\t\"github.com/andygrunwald/go-gerrit\"\n\t\"github.com/sirupsen/logrus\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\n\t\"k8s.io/test-infra/prow/config\"\n\t\"k8s.io/test-infra/prow/pjutil\"\n)\n\n\nfunc presubmitContexts(failed sets.String, presubmits []config.Presubmit, logger *logrus.Entry) (sets.String, sets.String) {\n\tallContexts := sets.String{}\n\tfor _, presubmit := range presubmits {\n\t\tallContexts.Insert(presubmit.Name) \n\t}\n\tfailedContexts := allContexts.Intersection(failed)\n\treturn failedContexts, allContexts\n}\n\n\nfunc currentMessages(change gerrit.ChangeInfo, since time.Time) []string {\n\tvar messages []string\n\twant := change.Revisions[change.CurrentRevision].Number\n\tfor _, have := range change.Messages {\n\t\tif have.RevisionNumber != want {\n\t\t\tcontinue\n\t\t}\n\t\tif !have.Date.Time.After(since) {\n\t\t\tcontinue\n\t\t}\n\t\tmessages = append(messages, have.Message)\n\t}\n\treturn messages\n}\n\n\n\n\n\n\nfunc messageFilter(messages []string, failingContexts, allContexts sets.String, logger *logrus.Entry) pjutil.Filter ", "output": "{\n\tvar filters []pjutil.Filter\n\tcontextGetter := func() (sets.String, sets.String, error) {\n\t\treturn failingContexts, allContexts, nil\n\t}\n\tfor _, message := range messages {\n\t\tfilter, err := pjutil.PresubmitFilter(false, contextGetter, message, logger)\n\t\tif err != nil {\n\t\t\tlogger.WithError(err).WithField(\"message\", message).Warn(\"failed to create presubmit filter\")\n\t\t\tcontinue\n\t\t}\n\t\tfilters = append(filters, filter)\n\t}\n\treturn pjutil.AggregateFilter(filters)\n}"}
{"input": "package log\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n)\n\nfunc Info(f string, v ...interface{}) string {\n\ts := fmt.Sprintf(f, v...)\n\tlog.Printf(s)\n\treturn s\n}\n\nfunc Err(f string, v ...interface{}) string {\n\ts := fmt.Sprintf(f, v...)\n\tlog.Printf(s)\n\treturn s\n}\n\n\n\nfunc Marshal(v interface{}) string ", "output": "{\n\n\tj, err := json.MarshalIndent(v, \"\", \"    \")\n\tif err != nil {\n\t\te := \"Err: json.MarshalIndent()\"\n\t\tlog.Printf(e)\n\t\treturn \"\"\n\t}\n\n\ts := string(j)\n\n\tlog.Printf(s)\n\n\treturn s\n}"}
{"input": "package redis\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\n\t\"github.com/iris-framework/iris/adaptors/sessions/sessiondb/redis/service\"\n)\n\n\ntype Database struct {\n\tredis *service.Service\n}\n\n\nfunc New(cfg ...service.Config) *Database {\n\treturn &Database{redis: service.New(cfg...)}\n}\n\n\nfunc (d *Database) Config() *service.Config {\n\treturn d.redis.Config\n}\n\n\nfunc (d *Database) Load(sid string) map[string]interface{} {\n\tvalues := make(map[string]interface{})\n\n\tif !d.redis.Connected { \n\t\td.redis.Connect()\n\t\t_, err := d.redis.PingPong()\n\t\tif err != nil {\n\t\t\tif err != nil {\n\t\t\t}\n\t\t}\n\t}\n\tval, err := d.redis.GetBytes(sid)\n\tif err == nil {\n\t\tDeserializeBytes(val, &values)\n\t}\n\n\treturn values\n\n}\n\n\nfunc serialize(values map[string]interface{}) []byte {\n\tval, err := SerializeBytes(values)\n\tif err != nil {\n\t\tprintln(\"On redisstore.serialize: \" + err.Error())\n\t}\n\n\treturn val\n}\n\n\nfunc (d *Database) Update(sid string, newValues map[string]interface{}) {\n\tif len(newValues) == 0 {\n\t\tgo d.redis.Delete(sid)\n\t} else {\n\t\tgo d.redis.Set(sid, serialize(newValues)) \n\t}\n\n}\n\n\nfunc SerializeBytes(m interface{}) ([]byte, error) {\n\tbuf := new(bytes.Buffer)\n\tenc := gob.NewEncoder(buf)\n\terr := enc.Encode(m)\n\tif err == nil {\n\t\treturn buf.Bytes(), nil\n\t}\n\treturn nil, err\n}\n\n\n\n\nfunc DeserializeBytes(b []byte, m interface{}) error ", "output": "{\n\tdec := gob.NewDecoder(bytes.NewBuffer(b))\n\treturn dec.Decode(m) \n}"}
{"input": "package grim\n\n\n\n\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n\n\n\nfunc getTimeStamp() string ", "output": "{\n\treturn fmt.Sprintf(\"%v\", time.Now().UnixNano())\n}"}
{"input": "package middleware\n\nimport (\n\t\"github.com/armab/drone/shared/model\"\n\t\"github.com/zenazn/goji/web\"\n)\n\n\n\nfunc UserToC(c *web.C, user *model.User) {\n\tc.Env[\"user\"] = user\n}\n\n\n\nfunc RepoToC(c *web.C, repo *model.Repo) {\n\tc.Env[\"repo\"] = repo\n}\n\n\n\nfunc RoleToC(c *web.C, role *model.Perm) {\n\tc.Env[\"role\"] = role\n}\n\n\n\n\n\n\n\n\n\nfunc ToRepo(c *web.C) *model.Repo {\n\tvar v = c.Env[\"repo\"]\n\tif v == nil {\n\t\treturn nil\n\t}\n\tr, ok := v.(*model.Repo)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn r\n}\n\n\n\n\nfunc ToRole(c *web.C) *model.Perm {\n\tvar v = c.Env[\"role\"]\n\tif v == nil {\n\t\treturn nil\n\t}\n\tp, ok := v.(*model.Perm)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn p\n}\n\nfunc ToUser(c *web.C) *model.User ", "output": "{\n\tvar v = c.Env[\"user\"]\n\tif v == nil {\n\t\treturn nil\n\t}\n\tu, ok := v.(*model.User)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn u\n}"}
{"input": "package api\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\ntype HttpsRedirectingFileHandler interface {\n\thttp.Handler\n\tfileHandler() http.Handler\n}\n\ntype httpsHandler struct {\n\tinternalHandler http.Handler\n}\n\nfunc NewHttpsRedirectFileHandler(dir http.Dir) HttpsRedirectingFileHandler {\n\thandler := &httpsHandler{}\n\thandler.internalHandler = http.FileServer(dir)\n\treturn handler\n}\n\nfunc redirect(w http.ResponseWriter, req *http.Request) {\n\ttarget := \"https://\" + req.Host + req.URL.Path\n\tif len(req.URL.RawQuery) > 0 {\n\t\ttarget += \"?\" + req.URL.RawQuery\n\t}\n\tlog.Printf(\"redirect to: %s\", target)\n\thttp.Redirect(w, req, target,\n\t\thttp.StatusTemporaryRedirect)\n}\n\n\n\nfunc (h *httpsHandler) fileHandler() http.Handler {\n\treturn h.internalHandler\n}\n\nfunc (h *httpsHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tif !isXForwardedHTTPS(req) {\n\t\tredirect(w, req)\n\t} else {\n\t\th.fileHandler().ServeHTTP(w, req)\n\t}\n}\n\nfunc isXForwardedHTTPS(request *http.Request) bool ", "output": "{\n\txForwardedProto := request.Header.Get(\"X-Forwarded-Proto\")\n\n\treturn len(xForwardedProto) > 0 && xForwardedProto == \"https\"\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", mainHandle)\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tlog.Fatal(\"Listen and serve:\", err)\n\t}\n}\n\n\ntype reply struct {\n\tLanguage string `json:\"language\"`\n\tOs       string `json:\"software\"`\n\tIP       string `json:\"ipaddress\"`\n}\n\n\nfunc mainHandle(w http.ResponseWriter, r *http.Request) {\n\theader := r.Header\n\th := fmt.Sprintf(\"%v\", header)\n\taddr := r.RemoteAddr\n\n\tos := parseOs(h)\n\tl := parseLang(h)\n\tip := parseIP(addr)\n\n\treply := reply{Language: l, Os: os, IP: ip}\n\n\tout, err := json.MarshalIndent(reply, \"\", \"    \")\n\tif err != nil {\n\t\tfmt.Println(\"Cannot produce json\", err)\n\t\treturn\n\t}\n\n\tfmt.Fprintf(w, \"%s\\n\", out)\n}\n\n\n\n\n\n\nfunc parseIP(addr string) string {\n\tip := strings.Split(addr, \":\")[0]\n\treturn ip\n}\n\n\nfunc parseLang(h string) string {\n\ttag := strings.Index(h, \"Accept-Language:\")\n\tstart := strings.Index(h[tag:], \"[\")\n\tstart += tag + 1\n\n\tend := strings.Index(h[start:], \"]\")\n\tend += start\n\n\tl := h[start:end]\n\n\treturn strings.Split(l, \";\")[0]\n}\n\n\n\n\nfunc parseOs(h string) string ", "output": "{\n\ttag := strings.Index(h, \"User-Agent\")\n\tstart := strings.Index(h[tag:], \"(\")\n\tstart += tag + 1 \n\n\tend := strings.Index(h[start:], \")\")\n\tend += start\n\n\treturn h[start:end]\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype ListShapesRequest struct {\n\n\tCompartmentId *string `mandatory:\"true\" contributesTo:\"query\" name:\"compartmentId\"`\n\n\tAvailabilityDomain *string `mandatory:\"false\" contributesTo:\"query\" name:\"availabilityDomain\"`\n\n\tLimit *int `mandatory:\"false\" contributesTo:\"query\" name:\"limit\"`\n\n\tPage *string `mandatory:\"false\" contributesTo:\"query\" name:\"page\"`\n\n\tImageId *string `mandatory:\"false\" contributesTo:\"query\" name:\"imageId\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\n\n\n\nfunc (request ListShapesRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request ListShapesRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request ListShapesRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype ListShapesResponse struct {\n\n\tRawResponse *http.Response\n\n\tItems []Shape `presentIn:\"body\"`\n\n\tOpcNextPage *string `presentIn:\"header\" name:\"opc-next-page\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response ListShapesResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response ListShapesResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request ListShapesRequest) String() string ", "output": "{\n\treturn common.PointerString(request)\n}"}
{"input": "package command\n\nimport (\n\t\"github.com/cisco/elsy/helpers\"\n\t\"github.com/codegangsta/cli\"\n)\n\n\n\nfunc CmdDockerCompose(c *cli.Context) error ", "output": "{\n\treturn helpers.RunCommand(helpers.DockerComposeCommand(c.Args()...))\n}"}
{"input": "package main\n\nimport \"fmt\"\n\ntype OSError int\n\nfunc (e *OSError) Error() string {\n\treturn fmt.Sprintf(\"error #%d\", *e)\n}\n\n\n\nfunc main() {\n\tif _, err := FileExists(\"/no/such/file\"); err != nil {\n\t\tfmt.Printf(\"error: %s\\n\", err)\n\t} else {\n\t\tfmt.Println(\"OK\")\n\t}\n}\n\nfunc FileExists(path string) (bool, error) ", "output": "{\n\tvar err *OSError\n\treturn false, err \n}"}
{"input": "package datamandirect\n\nimport (\n\t\"context\"\n\n\t\"github.com/jacksontj/dataman/query\"\n\t\"github.com/jacksontj/dataman/routernode\"\n\t\"github.com/jacksontj/dataman/storagenode\"\n)\n\nfunc NewDatasourceInstanceTransport(dsi *storagenode.DatasourceInstance) *DatasourceInstanceTransport {\n\treturn &DatasourceInstanceTransport{dsi}\n}\n\ntype DatasourceInstanceTransport struct {\n\tdsi *storagenode.DatasourceInstance\n}\n\n\n\nfunc (d *DatasourceInstanceTransport) DoStreamQuery(ctx context.Context, q *query.Query) (*query.ResultStream, error) {\n\treturn d.dsi.HandleStreamQuery(ctx, q), nil\n}\n\nfunc NewRouterTransport(node *routernode.RouterNode) *RouterTransport {\n\treturn &RouterTransport{node}\n}\n\ntype RouterTransport struct {\n\tnode *routernode.RouterNode\n}\n\nfunc (r *RouterTransport) DoQuery(ctx context.Context, q *query.Query) (*query.Result, error) {\n\treturn r.node.HandleQuery(ctx, q), nil\n}\n\nfunc (r *RouterTransport) DoStreamQuery(ctx context.Context, q *query.Query) (*query.ResultStream, error) {\n\treturn r.node.HandleStreamQuery(ctx, q), nil\n}\n\nfunc (d *DatasourceInstanceTransport) DoQuery(ctx context.Context, q *query.Query) (*query.Result, error) ", "output": "{\n\treturn d.dsi.HandleQuery(ctx, q), nil\n}"}
{"input": "package blockscore\n\nimport \"testing\"\n\n\n\nvar watchlistParams = WatchlistParams{\n\tCandidateID: \"\",\n\tMatchType:   \"person\",\n}\n\nfunc TestWatchlistSearch(t *testing.T) {\n\tcandidates, err := Candidates.List()\n\twatchlistParams.CandidateID = candidates[0].ID\n\n\t_, err = Watchlists.Search(&watchlistParams)\n\n\tif err != nil {\n\t\tt.Errorf(\"Expected successful Watchlist search, got Error %s\", err.Error())\n\t\treturn\n\t}\n}\n\nfunc init() ", "output": "{\n\tif err := SetKeyEnv(); err != nil {\n\t\tpanic(err)\n\t}\n}"}
{"input": "package util\n\nimport (\n\t\"strings\"\n)\n\n\n\n\n\nfunc EscapeQualifiedNameForDisk(in string) string {\n\treturn strings.Replace(in, \"/\", \"~\", -1)\n}\n\n\n\n\n\n\nfunc UnescapeQualifiedNameForDisk(in string) string ", "output": "{\n\treturn strings.Replace(in, \"~\", \"/\", -1)\n}"}
{"input": "package webaccelerator\n\nimport (\n\t\"github.com/sacloud/usacloud/pkg/cli\"\n\t\"github.com/sacloud/usacloud/pkg/cmd/cflag\"\n\t\"github.com/sacloud/usacloud/pkg/cmd/core\"\n)\n\nvar listCommand = &core.Command{\n\tName:               \"list\",\n\tAliases:            []string{\"ls\", \"find\", \"select\"},\n\tCategory:           \"basic\",\n\tOrder:              10,\n\tServiceFuncAltName: \"Find\",\n\tNoProgress:         true,\n\n\tColumnDefs: defaultColumnDefs,\n\n\tParameterInitializer: func() interface{} {\n\t\treturn newListParameter()\n\t},\n\n\tFunc: listFunc,\n}\n\ntype listParameter struct {\n\tcflag.CommonParameter      `cli:\",squash\" mapconv:\"-\"`\n\tcflag.LimitOffsetParameter `cli:\",squash\" mapconv:\",squash\"`\n\tcflag.OutputParameter      `cli:\",squash\" mapconv:\"-\"`\n}\n\nfunc listFunc(ctx cli.Context, parameter interface{}) ([]interface{}, error) {\n\treturn listAllFunc(ctx, parameter)\n}\n\nfunc newListParameter() *listParameter {\n\treturn &listParameter{}\n}\n\n\n\nfunc init() ", "output": "{\n\tResource.AddCommand(listCommand)\n}"}
{"input": "package analytics\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\n\n\ntype Logger interface {\n\n\tLogf(format string, args ...interface{})\n\n\tErrorf(format string, args ...interface{})\n}\n\n\n\nfunc StdLogger(logger *log.Logger) Logger {\n\treturn stdLogger{\n\t\tlogger: logger,\n\t}\n}\n\ntype stdLogger struct {\n\tlogger *log.Logger\n}\n\nfunc (l stdLogger) Logf(format string, args ...interface{}) {\n\tl.logger.Printf(\"INFO: \"+format, args...)\n}\n\n\n\nfunc newDefaultLogger() Logger {\n\treturn StdLogger(log.New(os.Stderr, \"segment \", log.LstdFlags))\n}\n\nfunc (l stdLogger) Errorf(format string, args ...interface{}) ", "output": "{\n\tl.logger.Printf(\"ERROR: \"+format, args...)\n}"}
{"input": "package gtk_mock\n\nimport \"github.com/twstrike/coyim/Godeps/_workspace/src/github.com/twstrike/gotk3adapter/gtki\"\n\ntype MockTextView struct {\n\tMockContainer\n}\n\nfunc (*MockTextView) SetEditable(v1 bool) {\n}\n\nfunc (*MockTextView) SetCursorVisible(v1 bool) {\n}\n\nfunc (*MockTextView) SetBuffer(v1 gtki.TextBuffer) {\n}\n\nfunc (*MockTextView) GetBuffer() (gtki.TextBuffer, error) {\n\treturn nil, nil\n}\n\nfunc (*MockTextView) ForwardDisplayLine(gtki.TextIter) bool {\n\treturn false\n}\n\n\n\nfunc (*MockTextView) ForwardDisplayLineEnd(gtki.TextIter) bool {\n\treturn false\n}\n\nfunc (*MockTextView) BackwardDisplayLineStart(gtki.TextIter) bool {\n\treturn false\n}\n\nfunc (*MockTextView) StartsDisplayLine(gtki.TextIter) bool {\n\treturn false\n}\n\nfunc (*MockTextView) MoveVisually(gtki.TextIter, int) bool {\n\treturn false\n}\n\nfunc (*MockTextView) BackwardDisplayLine(gtki.TextIter) bool ", "output": "{\n\treturn false\n}"}
{"input": "package v1beta3\n\nimport (\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/api\"\n)\n\n\n\nfunc init() ", "output": "{\n\tapi.Scheme.AddKnownTypes(\"v1beta3\",\n\t\t&User{},\n\t\t&UserList{},\n\t\t&Identity{},\n\t\t&IdentityList{},\n\t\t&UserIdentityMapping{},\n\t)\n}"}
{"input": "package openstack\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/gophercloud/gophercloud/openstack/imageservice/v2/images\"\n)\n\nfunc (c *openstackCloud) GetImage(name string) (*images.Image, error) {\n\treturn getImage(c, name)\n}\n\n\n\nfunc getImage(c OpenstackCloud, name string) (*images.Image, error) ", "output": "{\n\topts := images.ListOpts{Name: name}\n\tpager := images.List(c.ImageClient(), opts)\n\tpage, err := pager.AllPages()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list images: %v\", err)\n\t}\n\n\ti, err := images.ExtractImages(page)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to extract images: %v\", err)\n\t}\n\n\tswitch len(i) {\n\tcase 1:\n\t\treturn &i[0], nil\n\tcase 0:\n\t\treturn nil, fmt.Errorf(\"no image found with name %v\", name)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"multiple images found with name %v\", name)\n\t}\n}"}
{"input": "package options\n\nimport (\n\t\"runtime\"\n\t\"time\"\n\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/kubernetes/pkg/kubelet/config\"\n\tkubetypes \"k8s.io/kubernetes/pkg/kubelet/types\"\n)\n\nconst (\n\tdefaultPodSandboxImageName    = \"k8s.gcr.io/pause\"\n\tdefaultPodSandboxImageVersion = \"3.2\"\n)\n\nvar (\n\tdefaultPodSandboxImage = defaultPodSandboxImageName +\n\t\t\":\" + defaultPodSandboxImageVersion\n)\n\n\n\n\n\nfunc NewContainerRuntimeOptions() *config.ContainerRuntimeOptions ", "output": "{\n\tdockerEndpoint := \"\"\n\tif runtime.GOOS != \"windows\" {\n\t\tdockerEndpoint = \"unix:///var/run/docker.sock\"\n\t}\n\n\treturn &config.ContainerRuntimeOptions{\n\t\tContainerRuntime:           kubetypes.DockerContainerRuntime,\n\t\tRedirectContainerStreaming: false,\n\t\tDockerEndpoint:             dockerEndpoint,\n\t\tDockershimRootDirectory:    \"/var/lib/dockershim\",\n\t\tPodSandboxImage:            defaultPodSandboxImage,\n\t\tImagePullProgressDeadline:  metav1.Duration{Duration: 1 * time.Minute},\n\n\t\tCNIBinDir:   \"/opt/cni/bin\",\n\t\tCNIConfDir:  \"/etc/cni/net.d\",\n\t\tCNICacheDir: \"/var/lib/cni/cache\",\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\n\t\"github.com/playlist-media/clu/config\"\n)\n\n\n\nfunc getConfig() *config.Config ", "output": "{\n\tif cfg != nil {\n\t\treturn cfg\n\t}\n\n\tpwd, err := os.Getwd()\n\tif err != nil {\n\t\tprintFatal(fmt.Sprintf(\"Error: could not determine working directory (%s)\", err.Error()))\n\t}\n\n\tconfigLocation := path.Join(pwd, \"config\", \"clu.yaml\")\n\tcfg, err = config.NewConfigFromFile(configLocation)\n\tif err != nil {\n\t\tprintFatal(fmt.Sprintf(\"Error: could not parse the config file (./config/clu.yaml) (%s)\\n\", err.Error()))\n\t}\n\n\treturn cfg\n}"}
{"input": "package ui\n\nimport (\n\t\"github.com/studentkittens/eulenfunk/display\"\n)\n\n\n\n\ntype Menu struct {\n\tName string\n\n\tEntries []Entry\n\n\tCursor int\n\n\tlw *display.LineWriter\n}\n\n\n\n\n\nfunc (mn *Menu) scrollToNextSelectable(up bool) {\n\tfor mn.Cursor >= 0 && mn.Cursor < len(mn.Entries) && !mn.Entries[mn.Cursor].Selectable() {\n\t\tif up {\n\t\t\tmn.Cursor++\n\t\t} else {\n\t\t\tmn.Cursor--\n\t\t}\n\t}\n\n\tif mn.Cursor < 0 {\n\t\tmn.Cursor = 0\n\t}\n\n\tif mn.Cursor >= len(mn.Entries) {\n\t\tmn.Cursor = len(mn.Entries) - 1\n\t}\n}\n\n\nfunc (mn *Menu) Scroll(move int) {\n\tmn.Cursor += move\n\n\tup := move >= 0\n\tmn.scrollToNextSelectable(up)\n\n\tif !mn.Entries[mn.Cursor].Selectable() {\n\t\tmn.scrollToNextSelectable(!up)\n\t}\n}\n\n\nfunc (mn *Menu) Display(width int) error {\n\tfor pos, ClickEntry := range mn.Entries {\n\t\tline := ClickEntry.Render(width, pos == mn.Cursor)\n\t\tif err := mn.lw.Line(mn.Name, pos, line); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n\nfunc (mn *Menu) Click() error {\n\tif len(mn.Entries) == 0 {\n\t\treturn nil\n\t}\n\n\treturn mn.Entries[mn.Cursor].Action()\n}\n\nfunc NewMenu(name string, lw *display.LineWriter) (*Menu, error) ", "output": "{\n\treturn &Menu{\n\t\tName: name,\n\t\tlw:   lw,\n\t}, nil\n}"}
{"input": "package egoscale\n\nimport (\n\t\"encoding/json\"\n\t\"net/url\"\n)\n\nfunc (exo *Client) PollAsyncJob(jobid string) (*QueryAsyncJobResultResponse, error) {\n\tparams := url.Values{}\n\n\tparams.Set(\"jobid\", jobid)\n\n\tresp, err := exo.Request(\"queryAsyncJobResult\", params)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r QueryAsyncJobResultResponse\n\n\tif err := json.Unmarshal(resp, &r); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &r, nil\n}\n\n\n\nfunc (exo *Client) AsyncToVirtualMachine(resp QueryAsyncJobResultResponse) (*DeployVirtualMachineResponse, error) ", "output": "{\n\tvar r DeployVirtualMachineWrappedResponse\n\n\tif err := json.Unmarshal(resp.Jobresult, &r); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &r.Wrapped, nil\n}"}
{"input": "package assetmap\n\nimport \"testing\"\n\n\n\nfunc TestAssetMap(t *testing.T) ", "output": "{\n\tassetMap := NewAssetMap(\"test/assets.json\", false)\n\tassets := map[string]string{\n\t\t\"css/web-ui.css\":   \"css/web-ui-ac825658e28365c2.css\",\n\t\t\"js/web-ui.js\":     \"js/web-ui-158a0a39012fb9dd.js\",\n\t\t\"js/web-ui.min.js\": \"js/web-ui-140a0b39012fa9f4.min.js\",\n\t}\n\tfor asset, expected := range assets {\n\t\tp, e := assetMap.AssetPath(asset)\n\t\tif e != nil {\n\t\t\tt.Errorf(\"error getting asset: %v. error=%v\", asset, e)\n\t\t}\n\t\tif p != expected {\n\t\t\tt.Errorf(\"unexpected asset path for asset: %v. expected=%v, got:%v\", asset, expected, p)\n\t\t}\n\t}\n}"}
{"input": "package image\n\nimport (\n\t\"sort\"\n\n\t\"github.com/Symantec/Dominator/lib/verstr\"\n)\n\ntype directoryList []Directory\n\n\n\nfunc (list directoryList) Less(i, j int) bool {\n\treturn verstr.Less(list[i].Name, list[j].Name)\n}\n\nfunc (list directoryList) Swap(i, j int) {\n\tlist[i], list[j] = list[j], list[i]\n}\n\nfunc sortDirectories(directories []Directory) {\n\tsort.Sort(directoryList(directories))\n}\n\nfunc (list directoryList) Len() int ", "output": "{\n\treturn len(list)\n}"}
{"input": "package sort\n\nimport (\n\t\"sort\"\n\t\"testing\"\n)\n\n\n\nfunc TestQuickSimple(t *testing.T) ", "output": "{\n\tdata := ints\n\ta := data[:]\n\ta = quickSimple(a)\n\tif !sort.IsSorted(sort.IntSlice(a)) {\n\t\tt.Errorf(\"sorted %v\", ints)\n\t\tt.Errorf(\"   got %v\", data)\n\t}\n}"}
{"input": "package nodes\n\nimport (\n\t\"github.com/docker/libcontainer\"\n\t\"github.com/docker/libcontainer/devices\"\n)\n\n\n\nfunc CreateDeviceNodes(rootfs string, nodesToCreate []*devices.Device) error ", "output": "{\n\treturn libcontainer.ErrUnsupported\n}"}
{"input": "package mountinfo\n\nimport \"strings\"\n\n\n\n\n\n\n\n\n\n\n\ntype FilterFunc func(*Info) (skip, stop bool)\n\n\n\n\n\n\n\n\nfunc PrefixFilter(prefix string) FilterFunc {\n\treturn func(m *Info) (bool, bool) {\n\t\tskip := !strings.HasPrefix(m.Mountpoint+\"/\", prefix+\"/\")\n\t\treturn skip, false\n\t}\n}\n\n\nfunc SingleEntryFilter(mp string) FilterFunc {\n\treturn func(m *Info) (bool, bool) {\n\t\tif m.Mountpoint == mp {\n\t\t\treturn false, true \n\t\t}\n\t\treturn true, false \n\t}\n}\n\n\n\n\n\n\nfunc ParentsFilter(path string) FilterFunc {\n\treturn func(m *Info) (bool, bool) {\n\t\tskip := !strings.HasPrefix(path, m.Mountpoint)\n\t\treturn skip, false\n\t}\n}\n\n\n\n\nfunc FSTypeFilter(fstype ...string) FilterFunc ", "output": "{\n\treturn func(m *Info) (bool, bool) {\n\t\tfor _, t := range fstype {\n\t\t\tif m.FSType == t {\n\t\t\t\treturn false, false \n\t\t\t}\n\t\t}\n\t\treturn true, false \n\t}\n}"}
{"input": "package api\n\n\ntype UserInfo interface {\n\tGetName() string\n\tGetUID() string\n\tGetScope() string\n\tGetExtra() map[string]string\n}\n\n\n\ntype UserIdentityInfo interface {\n\tGetUserName() string\n\tGetProviderName() string\n\tGetExtra() map[string]string\n}\n\n\ntype UserIdentityMapper interface {\n\tUserFor(identityInfo UserIdentityInfo) (UserInfo, error)\n}\n\ntype Client interface {\n\tGetId() string\n\tGetSecret() string\n\tGetRedirectUri() string\n\tGetUserData() interface{}\n}\n\ntype Grant struct {\n\tClient      Client\n\tScope       string\n\tExpiration  int64\n\tRedirectURI string\n}\n\ntype DefaultUserInfo struct {\n\tName  string\n\tUID   string\n\tScope string\n\tExtra map[string]string\n}\n\nfunc (i *DefaultUserInfo) GetName() string {\n\treturn i.Name\n}\n\nfunc (i *DefaultUserInfo) GetUID() string {\n\treturn i.UID\n}\n\n\n\nfunc (i *DefaultUserInfo) GetExtra() map[string]string {\n\treturn i.Extra\n}\n\ntype DefaultUserIdentityInfo struct {\n\tUserName     string\n\tProviderName string\n\tExtra        map[string]string\n}\n\n\nfunc NewDefaultUserIdentityInfo(username string) DefaultUserIdentityInfo {\n\treturn DefaultUserIdentityInfo{\n\t\tUserName: username,\n\t\tExtra:    make(map[string]string),\n\t}\n}\n\nfunc (i *DefaultUserIdentityInfo) GetUserName() string {\n\treturn i.UserName\n}\n\nfunc (i *DefaultUserIdentityInfo) GetProviderName() string {\n\treturn i.ProviderName\n}\n\nfunc (i *DefaultUserIdentityInfo) GetExtra() map[string]string {\n\treturn i.Extra\n}\n\nfunc (i *DefaultUserInfo) GetScope() string ", "output": "{\n\treturn i.Scope\n}"}
{"input": "package systemd\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/dotcloud/docker/pkg/libcontainer/cgroups\"\n)\n\n\n\nfunc Apply(c *cgroups.Cgroup, pid int) (cgroups.ActiveCgroup, error) {\n\treturn nil, fmt.Errorf(\"Systemd not supported\")\n}\n\nfunc GetPids(c *cgroups.Cgroup) ([]int, error) {\n\treturn nil, fmt.Errorf(\"Systemd not supported\")\n}\n\nfunc Freeze(c *cgroups.Cgroup, state cgroups.FreezerState) error {\n\treturn fmt.Errorf(\"Systemd not supported\")\n}\n\nfunc UseSystemd() bool ", "output": "{\n\treturn false\n}"}
{"input": "package sacloud\n\n\ntype propPrivateHostPlan struct {\n\tPlan *ProductPrivateHost `json:\",omitempty\"` \n}\n\n\nfunc (p *propPrivateHostPlan) GetPrivateHostPlan() *ProductPrivateHost {\n\treturn p.Plan\n}\n\n\nfunc (p *propPrivateHostPlan) SetPrivateHostPlan(plan *ProductPrivateHost) {\n\tp.Plan = plan\n}\n\n\nfunc (p *propPrivateHostPlan) SetPrivateHostPlanByID(planID ID) {\n\tif p.Plan == nil {\n\t\tp.Plan = &ProductPrivateHost{}\n\t}\n\tp.Plan.Resource = NewResource(planID)\n}\n\n\nfunc (p *propPrivateHostPlan) GetCPU() int {\n\tif p.Plan == nil {\n\t\treturn -1\n\t}\n\n\treturn p.Plan.GetCPU()\n}\n\n\nfunc (p *propPrivateHostPlan) GetMemoryMB() int {\n\tif p.Plan == nil {\n\t\treturn -1\n\t}\n\n\treturn p.Plan.GetMemoryMB()\n}\n\n\n\n\nfunc (p *propPrivateHostPlan) GetMemoryGB() int ", "output": "{\n\tif p.Plan == nil {\n\t\treturn -1\n\t}\n\n\treturn p.Plan.GetMemoryGB()\n}"}
{"input": "package parser\n\nimport \"bytes\"\n\n\ntype ReturningClause interface {\n\tNodeFormatter\n\tstatementType() StatementType\n\treturningClause()\n}\n\nvar _ ReturningClause = &ReturningExprs{}\nvar _ ReturningClause = &ReturningNothing{}\nvar _ ReturningClause = &NoReturningClause{}\n\n\ntype ReturningExprs SelectExprs\n\n\nfunc (r *ReturningExprs) Format(buf *bytes.Buffer, f FmtFlags) {\n\tbuf.WriteString(\" RETURNING \")\n\tFormatNode(buf, f, SelectExprs(*r))\n}\n\n\nvar returningNothingClause = &ReturningNothing{}\n\n\ntype ReturningNothing struct{}\n\n\nfunc (*ReturningNothing) Format(buf *bytes.Buffer, f FmtFlags) {\n\tbuf.WriteString(\" RETURNING NOTHING\")\n}\n\n\n\nvar AbsentReturningClause = &NoReturningClause{}\n\n\ntype NoReturningClause struct{}\n\n\nfunc (*NoReturningClause) Format(buf *bytes.Buffer, f FmtFlags) {}\n\n\nfunc (*ReturningExprs) statementType() StatementType    { return Rows }\nfunc (*ReturningNothing) statementType() StatementType  { return Rows }\n\n\nfunc (*ReturningExprs) returningClause()    {}\nfunc (*ReturningNothing) returningClause()  {}\nfunc (*NoReturningClause) returningClause() {}\n\n\n\nfunc HasReturningClause(clause ReturningClause) bool {\n\t_, ok := clause.(*NoReturningClause)\n\treturn !ok\n}\n\nfunc (*NoReturningClause) statementType() StatementType ", "output": "{ return RowsAffected }"}
{"input": "package vulnerabilityscanning\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype DeleteHostScanTargetRequest struct {\n\n\tHostScanTargetId *string `mandatory:\"true\" contributesTo:\"path\" name:\"hostScanTargetId\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request DeleteHostScanTargetRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\n\n\n\nfunc (request DeleteHostScanTargetRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\nfunc (request DeleteHostScanTargetRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype DeleteHostScanTargetResponse struct {\n\n\tRawResponse *http.Response\n\n\tOpcWorkRequestId *string `presentIn:\"header\" name:\"opc-work-request-id\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response DeleteHostScanTargetResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response DeleteHostScanTargetResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request DeleteHostScanTargetRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) ", "output": "{\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}"}
{"input": "package main\n\nimport \"fmt\"\n\nconst (\n\ta = iota\n\tb\n\tc\n\td\n\te\n)\n\nvar x = []int{1, 2, 3}\n\nfunc f(x int, len *byte) {\n\t*len = byte(x)\n}\n\nfunc whatis(x interface{}) string {\n\tswitch xx := x.(type) {\n\tdefault:\n\t\treturn fmt.Sprint(\"default \", xx)\n\tcase int, int8, int16, int32:\n\t\treturn fmt.Sprint(\"signed \", xx)\n\tcase int64:\n\t\treturn fmt.Sprint(\"signed64 \", int64(xx))\n\tcase uint, uint8, uint16, uint32:\n\t\treturn fmt.Sprint(\"unsigned \", xx)\n\tcase uint64:\n\t\treturn fmt.Sprint(\"unsigned64 \", uint64(xx))\n\tcase nil:\n\t\treturn fmt.Sprint(\"nil \", xx)\n\t}\n\tpanic(\"not reached\")\n}\n\n\n\nfunc check(x interface{}, s string) {\n\tw := whatis(x)\n\tif w != s {\n\t\tfmt.Println(\"whatis\", x, \"=>\", w, \"!=\", s)\n\t\tpanic(\"fail\")\n\t}\n\n\tw = whatis1(x)\n\tif w != s {\n\t\tfmt.Println(\"whatis1\", x, \"=>\", w, \"!=\", s)\n\t\tpanic(\"fail\")\n\t}\n}\n\nfunc main() {\n\tcheck(1, \"signed 1\")\n\tcheck(uint(1), \"unsigned 1\")\n\tcheck(int64(1), \"signed64 1\")\n\tcheck(uint64(1), \"unsigned64 1\")\n\tcheck(1.5, \"default 1.5\")\n\tcheck(nil, \"nil <nil>\")\n}\n\nfunc whatis1(x interface{}) string ", "output": "{\n\txx := x\n\tswitch xx.(type) {\n\tdefault:\n\t\treturn fmt.Sprint(\"default \", xx)\n\tcase int, int8, int16, int32:\n\t\treturn fmt.Sprint(\"signed \", xx)\n\tcase int64:\n\t\treturn fmt.Sprint(\"signed64 \", xx.(int64))\n\tcase uint, uint8, uint16, uint32:\n\t\treturn fmt.Sprint(\"unsigned \", xx)\n\tcase uint64:\n\t\treturn fmt.Sprint(\"unsigned64 \", xx.(uint64))\n\tcase nil:\n\t\treturn fmt.Sprint(\"nil \", xx)\n\t}\n\tpanic(\"not reached\")\n}"}
{"input": "package main\n\nimport (\n\tzmq \"github.com/pebbe/zmq3\"\n\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\nconst (\n\tCHUNK_SIZE = 250000\n)\n\n\n\n\n\n\n\nfunc server_thread() {\n\tfile, err := os.Open(\"testdata\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\trouter, _ := zmq.NewSocket(zmq.ROUTER)\n\trouter.SetRcvhwm(0)\n\trouter.SetSndhwm(0)\n\trouter.Bind(\"tcp:*:6000\")\n\tfor {\n\t\tidentity, err := router.Recv(0)\n\t\tif err != nil {\n\t\t\tbreak \n\t\t}\n\n\t\tcommand, _ := router.Recv(0)\n\t\tif command != \"fetch\" {\n\t\t\tpanic(\"command != \\\"fetch\\\"\")\n\t\t}\n\n\t\tchunk := make([]byte, CHUNK_SIZE)\n\t\tfor {\n\t\t\tn, _ := io.ReadFull(file, chunk)\n\t\t\trouter.SendMessage(identity, chunk[:n])\n\t\t\tif n == 0 {\n\t\t\t\tbreak \n\t\t\t}\n\t\t}\n\t}\n\tfile.Close()\n}\n\n\n\n\n\nfunc main() {\n\tpipe := make(chan string)\n\n\tgo server_thread()\n\tgo client_thread(pipe)\n\t<-pipe\n}\n\nfunc client_thread(pipe chan<- string) ", "output": "{\n\tdealer, _ := zmq.NewSocket(zmq.DEALER)\n\tdealer.Connect(\"tcp:127.0.0.1:6000\")\n\n\tdealer.Send(\"fetch\", 0)\n\ttotal := 0  \n\tchunks := 0 \n\n\tfor {\n\t\tframe, err := dealer.RecvBytes(0)\n\t\tif err != nil {\n\t\t\tbreak \n\t\t}\n\t\tchunks++\n\t\tsize := len(frame)\n\t\ttotal += size\n\t\tif size == 0 {\n\t\t\tbreak \n\t\t}\n\t}\n\tfmt.Printf(\"%v chunks received, %v bytes\\n\", chunks, total)\n\tpipe <- \"OK\"\n}"}
{"input": "package event\n\nimport \"fmt\"\n\n\n\n\ntype Gauge struct {\n\tName  string\n\tValue int64\n}\n\n\nfunc (e *Gauge) Update(e2 Event) error {\n\tif e.Type() != e2.Type() {\n\t\treturn fmt.Errorf(\"statsd event type conflict: %s vs %s \", e.String(), e2.String())\n\t}\n\te.Value = e2.Payload().(int64)\n\treturn nil\n}\n\n\nfunc (e Gauge) Payload() interface{} {\n\treturn e.Value\n}\n\n\nfunc (e Gauge) Stats() []string {\n\tif e.Value < 0 {\n\t\treturn []string{\n\t\t\tfmt.Sprintf(\"%s:%d|g\", e.Name, 0),\n\t\t\tfmt.Sprintf(\"%s:%d|g\", e.Name, e.Value),\n\t\t}\n\t}\n\treturn []string{fmt.Sprintf(\"%s:%+d|g\", e.Name, e.Value)}\n}\n\n\nfunc (e Gauge) Key() string {\n\treturn e.Name\n}\n\n\nfunc (e *Gauge) SetKey(key string) {\n\te.Name = key\n}\n\n\nfunc (e Gauge) Type() int {\n\treturn EventGauge\n}\n\n\n\n\n\nfunc (e Gauge) String() string {\n\treturn fmt.Sprintf(\"{Type: %s, Key: %s, Value: %d}\", e.TypeString(), e.Name, e.Value)\n}\n\nfunc (e Gauge) TypeString() string ", "output": "{\n\treturn \"Gauge\"\n}"}
{"input": "package core\n\nfunc newChallenge(challengeType string, token string) Challenge {\n\tif token == \"\" {\n\t\ttoken = NewToken()\n\t}\n\treturn Challenge{\n\t\tType:   challengeType,\n\t\tStatus: StatusPending,\n\t\tToken:  token,\n\t}\n}\n\n\n\nfunc HTTPChallenge01(token string) Challenge {\n\treturn newChallenge(ChallengeTypeHTTP01, token)\n}\n\n\n\n\n\n\n\nfunc DNSChallenge01(token string) Challenge {\n\treturn newChallenge(ChallengeTypeDNS01, token)\n}\n\n\n\nfunc TLSALPNChallenge01(token string) Challenge {\n\treturn newChallenge(ChallengeTypeTLSALPN01, token)\n}\n\nfunc TLSSNIChallenge01(token string) Challenge ", "output": "{\n\treturn newChallenge(ChallengeTypeTLSSNI01, token)\n}"}
{"input": "package route\n\nimport (\n\t\"regexp\"\n\n\t\"github.com/volatile/core\"\n)\n\n\ntype pat struct {\n\tregexp      *regexp.Regexp\n\tnamedParams map[string]int\n}\n\n\nfunc newPat(pattern string) *pat {\n\tp := &pat{\n\t\tregexp: regexp.MustCompile(pattern),\n\t}\n\n\tnamedParams := p.regexp.SubexpNames()[1:]\n\tif len(namedParams) > 0 {\n\t\tp.namedParams = make(map[string]int)\n\t\tfor i, v := range namedParams {\n\t\t\tif v != \"\" {\n\t\t\t\tp.namedParams[v] = i\n\t\t\t}\n\t\t}\n\t}\n\n\treturn p\n}\n\nfunc (p *pat) match(c *core.Context) bool {\n\treturn p.regexp.MatchString(c.Request.URL.Path)\n}\n\n\n\nfunc (p *pat) parseParams(c *core.Context) map[string]string ", "output": "{\n\tif len(p.namedParams) > 0 {\n\t\tparams := make(map[string]string)\n\t\tparamsValues := p.regexp.FindStringSubmatch(c.Request.URL.String())[1:]\n\t\tfor k, v := range p.namedParams {\n\t\t\tparams[k] = paramsValues[v]\n\t\t}\n\t\treturn params\n\t}\n\treturn nil\n}"}
{"input": "package queue\n\nimport \"fmt\"\n\ntype Queue struct {\n\tElems []interface{}\n\tTop    int\n\tBottom int\n\tMaxlen int\n\tFull   bool\n}\n\n\nfunc New(maxLen int) *Queue {\n\tq := &Queue{\n\t\tElems: make([]interface{}, maxLen),\n\t\tTop: 0,\n\t\tBottom: 0,\n\t\tMaxlen: maxLen,\n\t}\n\n\tfmt.Printf(\"Queue: %d\\n\", q.Maxlen)\n\treturn q\n}\n\nfunc (q *Queue) EnQueue(e interface{}) {\n\n\tif q.Maxlen == q.Bottom - q.Top {\n\t\tq.Bottom = q.Top\n\t\tq.Full = true\n\t}\n\tq.Elems[q.Bottom] = e\n\tq.Bottom++\n\n}\n\n\n\nfunc (q *Queue) Len() int {\n\treturn len(q.Elems)\n}\n\nfunc (q *Queue) DeQueue() ", "output": "{\n\n\tif q.Bottom > q.Top {\n\t\tq.Top++\n\t}\n\n}"}
{"input": "package main\n\nimport \"fmt\"\n\nvar resume chan int\n\nfunc integers() chan int {\n\tyield := make(chan int)\n\tcount := 0\n\tgo func() {\n\t\tfor {\n\t\t\tyield <- count\n\t\t\tcount++\n\t\t}\n\t}()\n\treturn yield\n}\n\nfunc generateInteger() int {\n\treturn <-resume\n}\n\n\n\nfunc tryLazyEvaluation() ", "output": "{\n\tresume = integers()\n\tfmt.Println(generateInteger()) \n\tfmt.Println(generateInteger()) \n\tfmt.Println(generateInteger()) \n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSAmazonMQBroker_MaintenanceWindow struct {\n\n\tDayOfWeek string `json:\"DayOfWeek,omitempty\"`\n\n\tTimeOfDay string `json:\"TimeOfDay,omitempty\"`\n\n\tTimeZone string `json:\"TimeZone,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\n\n\n\n\nfunc (r *AWSAmazonMQBroker_MaintenanceWindow) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSAmazonMQBroker_MaintenanceWindow) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\nfunc (r *AWSAmazonMQBroker_MaintenanceWindow) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSAmazonMQBroker_MaintenanceWindow) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSAmazonMQBroker_MaintenanceWindow) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSAmazonMQBroker_MaintenanceWindow) AWSCloudFormationType() string ", "output": "{\n\treturn \"AWS::AmazonMQ::Broker.MaintenanceWindow\"\n}"}
{"input": "package iso20022\n\n\ntype AccountManagementConfirmation3 struct {\n\n\tConfirmationType *AccountManagementType2Code `xml:\"ConfTp\"`\n\n\tAccountApplicationIdentification *Max35Text `xml:\"AcctApplId,omitempty\"`\n\n\tClientReference *Max35Text `xml:\"ClntRef,omitempty\"`\n\n\tCounterpartyReference *AdditionalReference6 `xml:\"CtrPtyRef,omitempty\"`\n\n\tExistingAccountIdentification *Max35Text `xml:\"ExstgAcctId,omitempty\"`\n}\n\nfunc (a *AccountManagementConfirmation3) SetConfirmationType(value string) {\n\ta.ConfirmationType = (*AccountManagementType2Code)(&value)\n}\n\n\n\nfunc (a *AccountManagementConfirmation3) SetClientReference(value string) {\n\ta.ClientReference = (*Max35Text)(&value)\n}\n\nfunc (a *AccountManagementConfirmation3) AddCounterpartyReference() *AdditionalReference6 {\n\ta.CounterpartyReference = new(AdditionalReference6)\n\treturn a.CounterpartyReference\n}\n\nfunc (a *AccountManagementConfirmation3) SetExistingAccountIdentification(value string) {\n\ta.ExistingAccountIdentification = (*Max35Text)(&value)\n}\n\nfunc (a *AccountManagementConfirmation3) SetAccountApplicationIdentification(value string) ", "output": "{\n\ta.AccountApplicationIdentification = (*Max35Text)(&value)\n}"}
{"input": "package identity\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype UpdateAuthTokenRequest struct {\n\n\tUserId *string `mandatory:\"true\" contributesTo:\"path\" name:\"userId\"`\n\n\tAuthTokenId *string `mandatory:\"true\" contributesTo:\"path\" name:\"authTokenId\"`\n\n\tUpdateAuthTokenDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request UpdateAuthTokenRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request UpdateAuthTokenRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request UpdateAuthTokenRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\n\n\n\ntype UpdateAuthTokenResponse struct {\n\n\tRawResponse *http.Response\n\n\tAuthToken `presentIn:\"body\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n}\n\nfunc (response UpdateAuthTokenResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response UpdateAuthTokenResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request UpdateAuthTokenRequest) RetryPolicy() *common.RetryPolicy ", "output": "{\n\treturn request.RequestMetadata.RetryPolicy\n}"}
{"input": "package handler\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/kataras/iris/v12/context\"\n\t\"github.com/kataras/iris/v12/core/memstore\"\n\t\"github.com/kataras/iris/v12/macro\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype ParamErrorHandler = func(*context.Context, int, error) \n\n\n\n\n\nfunc CanMakeHandler(tmpl macro.Template) (needsMacroHandler bool) {\n\tif len(tmpl.Params) == 0 {\n\t\treturn\n\t}\n\n\tfor _, p := range tmpl.Params {\n\t\tif p.CanEval() {\n\t\t\tneedsMacroHandler = true\n\n\t\t\tif p.HandleError != nil {\n\t\t\t\tif _, ok := p.HandleError.(ParamErrorHandler); !ok {\n\t\t\t\t\tpanic(fmt.Sprintf(\"HandleError must be a type of func(iris.Context, int, error) but got: %T\", p.HandleError))\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn\n}\n\n\n\n\nfunc MakeHandler(tmpl macro.Template) context.Handler {\n\tfilter := MakeFilter(tmpl)\n\n\treturn func(ctx *context.Context) {\n\t\tif !filter(ctx) {\n\t\t\tif ctx.GetCurrentRoute().StatusErrorCode() == ctx.GetStatusCode() {\n\t\t\t\tctx.Next()\n\t\t\t} else {\n\t\t\t\tctx.StopExecution()\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tctx.Next()\n\t}\n}\n\n\n\n\n\nfunc MakeFilter(tmpl macro.Template) context.Filter ", "output": "{\n\tif !CanMakeHandler(tmpl) {\n\t\treturn nil\n\t}\n\n\treturn func(ctx *context.Context) bool {\n\t\tfor _, p := range tmpl.Params {\n\t\t\tif !p.CanEval() {\n\t\t\t\tcontinue \n\t\t\t}\n\n\t\t\tentry, found := ctx.Params().Store.GetEntryAt(p.Index)\n\t\t\tif !found {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tvalue, passed := p.Eval(entry.String())\n\t\t\tif !passed {\n\t\t\t\tctx.StatusCode(p.ErrCode) \n\t\t\t\tif value != nil && p.HandleError != nil {\n\t\t\t\t\tp.HandleError.(ParamErrorHandler)(ctx, p.Index, value.(error))\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tctx.Params().Store[p.Index] = memstore.Entry{\n\t\t\t\tKey:      p.Name,\n\t\t\t\tValueRaw: value,\n\t\t\t}\n\n\t\t}\n\n\t\treturn true\n\t}\n}"}
{"input": "package archive\n\nimport (\n\t\"context\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t. \"github.com/smartystreets/goconvey/convey\"\n\t\"testing\"\n)\n\nfunc Test_RoundEndConf(t *testing.T) {\n\tvar (\n\t\tc   = context.TODO()\n\t\terr error\n\t)\n\tConvey(\"RoundEndConf\", t, WithDao(func(d *Dao) {\n\t\t_, err = d.RoundEndConf(c)\n\t\tSo(err, ShouldBeNil)\n\t}))\n}\n\n\n\nfunc Test_RoundTypeConf(t *testing.T) {\n\tvar (\n\t\tc   = context.TODO()\n\t\terr error\n\t\tsub map[int16]struct{}\n\t)\n\tConvey(\"RoundTypeConf\", t, WithDao(func(d *Dao) {\n\t\tsub, err = d.RoundTypeConf(c)\n\t\tSo(err, ShouldBeNil)\n\t\tSo(sub, ShouldNotBeNil)\n\t}))\n}\n\nfunc Test_AuditTypesConf(t *testing.T) {\n\tvar (\n\t\tc   = context.TODO()\n\t\terr error\n\t\tsub map[int16]struct{}\n\t)\n\tConvey(\"AuditTypesConf\", t, WithDao(func(d *Dao) {\n\t\tsub, err = d.AuditTypesConf(c)\n\t\tSo(err, ShouldBeNil)\n\t\tSo(sub, ShouldNotBeNil)\n\t}))\n}\nfunc Test_ThresholdConf(t *testing.T) {\n\tvar (\n\t\tc   = context.TODO()\n\t\terr error\n\t\tsub map[int16]int\n\t)\n\tConvey(\"ThresholdConf\", t, WithDao(func(d *Dao) {\n\t\tsub, err = d.ThresholdConf(c)\n\t\tSo(err, ShouldBeNil)\n\t\tSo(sub, ShouldNotBeNil)\n\t}))\n}\n\nfunc Test_FansConf(t *testing.T) ", "output": "{\n\tvar (\n\t\tc   = context.TODO()\n\t\terr error\n\t\tsub int64\n\t)\n\tConvey(\"FansConf\", t, WithDao(func(d *Dao) {\n\t\tsub, err = d.FansConf(c)\n\t\tSo(err, ShouldBeNil)\n\t\tSo(sub, ShouldNotBeEmpty)\n\t}))\n}"}
{"input": "package crypto\n\nimport (\n\t\"github.com/openblockchain/obc-peer/openchain/crypto/utils\"\n\t\"math/big\"\n)\n\nfunc (node *nodeImpl) sign(signKey interface{}, msg []byte) ([]byte, error) {\n\tnode.log.Debug(\"Signing message [%s].\", utils.EncodeBase64(msg))\n\treturn utils.ECDSASign(signKey, msg)\n}\n\nfunc (node *nodeImpl) signWithEnrollmentKey(msg []byte) ([]byte, error) {\n\tnode.log.Debug(\"Signing message [%s].\", utils.EncodeBase64(msg))\n\treturn utils.ECDSASign(node.enrollPrivKey, msg)\n}\n\nfunc (node *nodeImpl) ecdsaSignWithEnrollmentKey(msg []byte) (*big.Int, *big.Int, error) {\n\tnode.log.Debug(\"Signing message direct [%s].\", utils.EncodeBase64(msg))\n\treturn utils.ECDSASignDirect(node.enrollPrivKey, msg)\n}\n\n\n\nfunc (node *nodeImpl) verifyWithEnrollmentCert(msg, signature []byte) (bool, error) {\n\tnode.log.Debug(\"Verifing signature [%s] against message [%s].\",\n\t\tutils.EncodeBase64(signature),\n\t\tutils.EncodeBase64(msg),\n\t)\n\n\treturn utils.ECDSAVerify(node.enrollCert.PublicKey, msg, signature)\n}\n\nfunc (node *nodeImpl) verify(verKey interface{}, msg, signature []byte) (bool, error) ", "output": "{\n\tnode.log.Debug(\"Verifing signature [%s] against message [%s].\",\n\t\tutils.EncodeBase64(signature),\n\t\tutils.EncodeBase64(msg),\n\t)\n\n\treturn utils.ECDSAVerify(verKey, msg, signature)\n}"}
{"input": "package gojay\n\nimport (\n\t\"io\"\n\t\"sync\"\n)\n\n\n\n\nfunc (s stream) NewEncoder(w io.Writer) *StreamEncoder {\n\tenc := BorrowEncoder(w)\n\treturn &StreamEncoder{Encoder: enc, nConsumer: 1, done: make(chan struct{}, 1), mux: &sync.RWMutex{}}\n}\n\n\n\n\n\n\n\n\nfunc (s stream) borrowEncoder(w io.Writer) *StreamEncoder {\n\tstreamEnc := streamEncPool.Get().(*StreamEncoder)\n\tstreamEnc.isPooled = 0\n\tstreamEnc.w = w\n\tstreamEnc.Encoder.err = nil\n\treturn streamEnc\n}\n\nfunc (s stream) BorrowEncoder(w io.Writer) *StreamEncoder ", "output": "{\n\tstreamEnc := streamEncPool.Get().(*StreamEncoder)\n\tstreamEnc.w = w\n\tstreamEnc.Encoder.err = nil\n\tstreamEnc.done = make(chan struct{}, 1)\n\tstreamEnc.Encoder.buf = streamEnc.buf[:0]\n\tstreamEnc.nConsumer = 1\n\tstreamEnc.isPooled = 0\n\treturn streamEnc\n}"}
{"input": "package configuration\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nconst (\n\tfilePermissions = 0600\n\tdirPermissions  = 0700\n)\n\ntype Persistor interface {\n\tDelete()\n\tLoad(DataInterface) error\n\tSave(DataInterface) error\n}\n\ntype DataInterface interface {\n\tJsonMarshalV3() ([]byte, error)\n\tJsonUnmarshalV3([]byte) error\n}\n\ntype DiskPersistor struct {\n\tfilePath string\n}\n\nfunc NewDiskPersistor(path string) (dp DiskPersistor) {\n\treturn DiskPersistor{\n\t\tfilePath: path,\n\t}\n}\n\n\n\nfunc (dp DiskPersistor) Load(data DataInterface) error {\n\terr := dp.read(data)\n\tif err != nil {\n\t\terr = dp.write(data)\n\t}\n\treturn err\n}\n\nfunc (dp DiskPersistor) Save(data DataInterface) (err error) {\n\treturn dp.write(data)\n}\n\nfunc (dp DiskPersistor) read(data DataInterface) error {\n\terr := os.MkdirAll(filepath.Dir(dp.filePath), dirPermissions)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tjsonBytes, err := ioutil.ReadFile(dp.filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = data.JsonUnmarshalV3(jsonBytes)\n\treturn err\n}\n\nfunc (dp DiskPersistor) write(data DataInterface) error {\n\tbytes, err := data.JsonMarshalV3()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = ioutil.WriteFile(dp.filePath, bytes, filePermissions)\n\treturn err\n}\n\nfunc (dp DiskPersistor) Delete() ", "output": "{\n\tos.Remove(dp.filePath)\n}"}
{"input": "package beacon\n\nimport \"net\"\n\ntype Multicast struct {\n\tconn   *net.UDPConn\n\taddr   *net.UDPAddr\n\tinbox  chan []byte\n\toutbox chan recv\n}\n\nfunc NewMulticast(addr string) (*Multicast, error) {\n\tgaddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn, err := net.ListenMulticastUDP(\"udp\", nil, gaddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tb := &Multicast{\n\t\tconn:   conn,\n\t\taddr:   gaddr,\n\t\tinbox:  make(chan []byte),\n\t\toutbox: make(chan recv, 16),\n\t}\n\n\tgo genericReader(b.conn, b.outbox)\n\tgo b.writer()\n\n\treturn b, nil\n}\n\n\n\nfunc (b *Multicast) Recv() ([]byte, net.Addr) {\n\trecv := <-b.outbox\n\treturn recv.data, recv.src\n}\n\nfunc (b *Multicast) writer() {\n\tfor bs := range b.inbox {\n\t\tintfs, err := net.Interfaces()\n\t\tif err != nil {\n\t\t\tl.Warnln(\"multicast interfaces:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tfor _, intf := range intfs {\n\t\t\tif intf.Flags&net.FlagUp != 0 && intf.Flags&net.FlagMulticast != 0 {\n\t\t\t\taddr := *b.addr\n\t\t\t\taddr.Zone = intf.Name\n\t\t\t\t_, err = b.conn.WriteTo(bs, &addr)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif debug {\n\t\t\t\t\t\tl.Debugln(err, \"on write to\", addr)\n\t\t\t\t\t}\n\t\t\t\t} else if debug {\n\t\t\t\t\tl.Debugf(\"sent %d bytes to %s\", len(bs), addr.String())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (b *Multicast) Send(data []byte) ", "output": "{\n\tb.inbox <- data\n}"}
{"input": "package main\n\nimport \"fmt\"\n\ntype Channel struct {\n\tusers []User\n\tjoin  chan User\n\tpart  chan User\n}\n\n\n\nfunc NewChannel() *Channel {\n\treturn &Channel{\n\t\tusers: make([]User, 0),\n\t\tjoin:  make(chan User),\n\t\tpart:  make(chan User),\n\t}\n}\n\n\nfunc (c *Channel) listen() {\n\tfor {\n\t\tselect {\n\t\tcase j := <-c.join:\n\t\t\tc.addUser(j)\n\t\tcase p := <-c.part:\n\t\t\tc.removeUser(p)\n\t\t}\n\t}\n}\n\n\n\n\n\nfunc (c *Channel) removeUser(user User) {\n\tfor i, u := range c.users {\n\t\tif u.Nickname() == user.Nickname() {\n\t\t\tc.users = append(c.users[:i], c.users[i+1:]...)\n\t\t}\n\t}\n}\n\n\n\nfunc (c *Channel) addUser(user User) {\n\tc.users = append(c.users, user)\n}\n\n\nfunc (c *Channel) Users() []User {\n\treturn c.users\n}\n\nfunc (c *Channel) sendToChannel(msg Message) ", "output": "{\n\tfor _, user := range c.users {\n\t\tuser.ChannelOut() <- fmt.Sprintf(\"%s: %s\", msg.client.Nickname()+msg.msg)\n\t}\n}"}
{"input": "package chipmunk\n\nimport (\n\t\"github.com/dataarts/chipmunk/transform\"\n\t\"github.com/dataarts/chipmunk/vect\"\n)\n\ntype CircleShape struct {\n\tShape *Shape\n\tPosition vect.Vect\n\tRadius vect.Float\n\tTc vect.Vect\n}\n\n\nfunc NewCircle(pos vect.Vect, radius float32) *Shape {\n\tshape := newShape()\n\tcircle := &CircleShape{\n\t\tPosition: pos,\n\t\tRadius:   vect.Float(radius),\n\t\tShape:    shape,\n\t}\n\tshape.ShapeClass = circle\n\treturn shape\n}\n\n\nfunc (circle *CircleShape) ShapeType() ShapeType {\n\treturn ShapeType_Circle\n}\n\nfunc (circle *CircleShape) Moment(mass float32) vect.Float {\n\treturn (vect.Float(mass) * (0.5 * (circle.Radius * circle.Radius))) + vect.LengthSqr(circle.Position)\n}\n\n\nfunc (circle *CircleShape) update(xf transform.Transform) AABB {\n\tcenter := xf.TransformVect(circle.Position)\n\tcircle.Tc = center\n\trv := vect.Vect{circle.Radius, circle.Radius}\n\n\treturn AABB{\n\t\tvect.Sub(center, rv),\n\t\tvect.Add(center, rv),\n\t}\n}\n\n\n\n\n\nfunc (circle *CircleShape) TestPoint(point vect.Vect) bool {\n\td := vect.Sub(point, circle.Tc)\n\n\treturn vect.Dot(d, d) <= circle.Radius*circle.Radius\n}\n\nfunc (circle *CircleShape) Clone(s *Shape) ShapeClass ", "output": "{\n\tclone := *circle\n\tclone.Shape = s\n\treturn &clone\n}"}
{"input": "package value\n\nimport \"fmt\"\n\ntype Undefined struct {\n\tarr *Array\n}\n\nfunc (u *Undefined) Scalar() (v *Scalar, ok bool) {\n\tif u.arr != nil {\n\t\treturn nil, false\n\t}\n\treturn &Scalar{}, true\n}\n\nfunc (u *Undefined) Array() (a *Array, ok bool) {\n\tif u.arr == nil {\n\t\tu.arr = NewArray()\n\t}\n\treturn u.arr, true\n}\n\n\n\nfunc (u *Undefined) String() string {\n\tif u.arr != nil {\n\t\treturn u.arr.String()\n\t}\n\treturn \"undefined\"\n}\n\nfunc (u *Undefined) Len() int {\n\tif u.arr != nil {\n\t\treturn u.arr.Len()\n\t}\n\treturn 0\n}\nfunc (u *Undefined) Encode() string {\n\tif u.arr != nil {\n\t\treturn u.Encode()\n\t}\n\treturn \"undefined\"\n}\n\nfunc (u *Undefined) Format(s fmt.State, verb rune) {\n\tif u.arr != nil {\n\t\tu.arr.Format(s, verb)\n\t\treturn\n\t}\n\tswitch verb {\n\tcase 'v', 'V':\n\t\tfmt.Fprint(s, \"undefined\")\n\t\treturn\n\t}\n\tfmt.Fprintf(s, formatVerb(s, verb), nil)\n}\n\nfunc (u *Undefined) Cmp(v Value) (cmp int, ok bool) ", "output": "{\n\tif u.arr != nil {\n\t\treturn u.arr.Cmp(v)\n\t}\n\tvar eq bool\n\tswitch v := v.(type) {\n\tcase *Scalar:\n\t\tok = true\n\t\tswitch v.typ {\n\t\tcase String:\n\t\t\teq = v.string == \"\"\n\t\tcase Bool, Number:\n\t\t\teq = v.number == 0\n\t\t}\n\tcase *Array:\n\t\teq = v.Len() == 0\n\t}\n\tif eq {\n\t\treturn 0, ok\n\t}\n\treturn -1, ok\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"testing\"\n)\n\nconst (\n\tmetricCount = 4\n)\n\nvar (\n\tfluentdJson = Message{1, 4, 456, 0}\n)\n\ntype Message struct {\n\tup                    int\n\tbufferQueueLength     int\n\tbufferTotalQueuedSize float64\n\tretryCount            int\n}\n\n\n\nfunc TestFluentdStatus(t *testing.T) {\n\tdata, err := json.Marshal(fluentdJson)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tos.Exit(1)\n\t}\n\n\tcheckFluentdStatus(t, data, metricCount)\n}\n\nfunc checkFluentdStatus(t *testing.T, status []byte, metricCount int) ", "output": "{\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(status))\n\t})\n\tserver := httptest.NewServer(handler)\n\n\te := NewExporter(server.URL)\n\tch := make(chan prometheus.Metric)\n\n\tgo func() {\n\t\tdefer close(ch)\n\t\te.Collect(ch)\n\t}()\n\n\tm := <-ch\n\tif m == nil {\n\t\tt.Error(\"expected metric but got nil\")\n\t}\n\n\tif <-ch != nil {\n\t\tt.Error(\"expected closed channel\")\n\t}\n}"}
{"input": "package util\n\n\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n)\n\n\n\nfunc StringFromWebJson(url string) string {\n\n\tresponse, err := http.Get(url)\n\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tbytes, err := ioutil.ReadAll(response.Body)\n\n\tif err != err {\n\t\tlog.Fatalln(err)\n\t}\n\n\treturn string(bytes)\n}\n\nfunc DownloadFromUrl(url string, path string) ", "output": "{\n\ttokens := strings.Split(url, \"/\")\n\tfileName := tokens[len(tokens)-1]\n\n\toutput, err := os.Create(path + \"/\" + fileName)\n\tif err != nil {\n\t\tlog.Fatalln(\"Error while creating\", fileName, \"-\", err)\n\t\treturn\n\t}\n\tdefer output.Close()\n\n\tresponse, err := http.Get(url)\n\tif err != nil {\n\t\tlog.Fatalln(\"Error while downloading\", url, \"-\", err)\n\t\treturn\n\t}\n\tdefer response.Body.Close()\n\n\tn, err := io.Copy(output, response.Body)\n\tif err != nil {\n\t\tlog.Fatalln(\"Error while downloading\", url, \"-\", err)\n\t\treturn\n\t}\n\tlog.Println(\"Finsihed downloading \", fileName, n, \"bytes downloaded.\")\n}"}
{"input": "package networks\n\nimport (\n\t\"github.com/gophercloud/gophercloud\"\n\t\"github.com/gophercloud/gophercloud/pagination\"\n)\n\n\n\n\n\nfunc Get(client *gophercloud.ServiceClient, id string) (r GetResult) {\n\t_, r.Err = client.Get(getURL(client, id), &r.Body, nil)\n\treturn\n}\n\nfunc List(client *gophercloud.ServiceClient) pagination.Pager ", "output": "{\n\treturn pagination.NewPager(client, listURL(client), func(r pagination.PageResult) pagination.Page {\n\t\treturn NetworkPage{pagination.SinglePageBase(r)}\n\t})\n}"}
{"input": "package httpmw\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestWrap(t *testing.T) {\n\tnop := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tw := func(char byte) WrapperFunc {\n\t\treturn func(h http.Handler) http.Handler {\n\t\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.Write([]byte{char})\n\t\t\t\th.ServeHTTP(w, r)\n\t\t\t})\n\t\t}\n\t}\n\n\tcases := []struct {\n\t\th    http.Handler\n\t\tcode int\n\t\tbody string\n\t}{\n\t\t{Wrap(StatusHandler(123)), 123, \"\"},\n\t\t{Wrap(nop, w('a')), 200, \"a\"},\n\t\t{Wrap(nop, w('a'), w('b')), 200, \"ab\"},\n\t\t{Wrap(nop, w('a'), w('b'), w('c')), 200, \"abc\"},\n\t}\n\tfor i, c := range cases {\n\t\trw := httptest.NewRecorder()\n\t\treq, _ := http.NewRequest(\"\", \"/\", nil)\n\t\tc.h.ServeHTTP(rw, req)\n\n\t\tassert.Equal(t, c.code, rw.Code, \"%d: status code\", i)\n\t\tassert.Equal(t, c.body, rw.Body.String(), \"%d: body\", i)\n\t}\n}\n\n\n\nfunc TestStatusHandler(t *testing.T) ", "output": "{\n\tw := httptest.NewRecorder()\n\tr, _ := http.NewRequest(\"\", \"/\", nil)\n\n\th := StatusHandler(204)\n\th.ServeHTTP(w, r)\n\tassert.Equal(t, 204, w.Code, \"status\")\n}"}
{"input": "package gorma\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/goadesign/goa/dslengine\"\n)\n\n\nfunc (a *StorageGroupDefinition) Validate() *dslengine.ValidationErrors {\n\tfmt.Println(\"Validating Group\")\n\tverr := new(dslengine.ValidationErrors)\n\tif a.Name == \"\" {\n\t\tverr.Add(a, \"storage group name not defined\")\n\t}\n\ta.IterateStores(func(store *RelationalStoreDefinition) error {\n\t\tverr.Merge(store.Validate())\n\t\treturn nil\n\t})\n\n\treturn verr.AsError()\n}\n\n\nfunc (a *RelationalStoreDefinition) Validate() *dslengine.ValidationErrors {\n\tfmt.Println(\"Validating Store\")\n\tverr := new(dslengine.ValidationErrors)\n\tif a.Name == \"\" {\n\t\tverr.Add(a, \"store name not defined\")\n\t}\n\tif a.Parent == nil {\n\t\tverr.Add(a, \"missing storage group parent\")\n\t}\n\ta.IterateModels(func(model *RelationalModelDefinition) error {\n\t\tverr.Merge(model.Validate())\n\t\treturn nil\n\t})\n\n\treturn verr.AsError()\n}\n\n\n\n\n\nfunc (field *RelationalFieldDefinition) Validate() *dslengine.ValidationErrors {\n\tfmt.Println(\"Validing Field\")\n\tverr := new(dslengine.ValidationErrors)\n\n\tif field.Parent == nil {\n\t\tverr.Add(field, \"missing relational model parent\")\n\t}\n\tif field.FieldName == \"\" {\n\t\tverr.Add(field, \"field name not defined\")\n\t}\n\treturn verr.AsError()\n}\n\nfunc (a *RelationalModelDefinition) Validate() *dslengine.ValidationErrors ", "output": "{\n\tfmt.Println(\"Validating Model\")\n\tverr := new(dslengine.ValidationErrors)\n\tif a.ModelName == \"\" {\n\t\tverr.Add(a, \"model name not defined\")\n\t}\n\tif a.Parent == nil {\n\t\tverr.Add(a, \"missing relational store parent\")\n\t}\n\ta.IterateFields(func(field *RelationalFieldDefinition) error {\n\t\tverr.Merge(field.Validate())\n\t\treturn nil\n\t})\n\n\treturn verr.AsError()\n}"}
{"input": "package env\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n)\n\n\n\n\n\n\n\nfunc EnvOrDefaultInt(key string, def int) int {\n\tval := os.Getenv(key)\n\tif val == \"\" {\n\t\treturn def\n\t}\n\ti, err := strconv.Atoi(val)\n\tif err != nil {\n\t\tlog.Printf(\"Expected integer value for %v env variable, but got %v. Defaulting to %v\", key, val, def)\n\t\treturn def\n\t}\n\treturn i\n}\n\n\n\nfunc EnvOrDefaultBool(key string, def bool) bool {\n\tval := os.Getenv(key)\n\tif val == \"\" {\n\t\treturn def\n\t}\n\tb, err := strconv.ParseBool(val)\n\tif err != nil {\n\t\tlog.Printf(\"Expected boolean value for %v env variable, but got %v. Defaulting to %v\", key, val, def)\n\t\treturn def\n\t}\n\treturn b\n}\n\nfunc EnvOrDefaultStr(key string, def string) string ", "output": "{\n\tval := os.Getenv(key)\n\tif val == \"\" {\n\t\treturn def\n\t}\n\treturn val\n}"}
{"input": "package goja\n\nimport (\n\t\"fmt\"\n\t\"github.com/go-sourcemap/sourcemap\"\n\t\"sort\"\n\t\"strings\"\n)\n\ntype Position struct {\n\tLine, Col int\n}\n\ntype SrcFile struct {\n\tname string\n\tsrc  string\n\n\tlineOffsets       []int\n\tlastScannedOffset int\n\tsourceMap         *sourcemap.Consumer\n}\n\nfunc NewSrcFile(name, src string, sourceMap *sourcemap.Consumer) *SrcFile {\n\treturn &SrcFile{\n\t\tname:      name,\n\t\tsrc:       src,\n\t\tsourceMap: sourceMap,\n\t}\n}\n\nfunc (f *SrcFile) Position(offset int) Position {\n\tvar line int\n\tif offset > f.lastScannedOffset {\n\t\tline = f.scanTo(offset)\n\t} else {\n\t\tline = sort.Search(len(f.lineOffsets), func(x int) bool { return f.lineOffsets[x] > offset }) - 1\n\t}\n\n\tvar lineStart int\n\tif line >= 0 {\n\t\tlineStart = f.lineOffsets[line]\n\t}\n\n\trow := line + 2\n\tcol := offset - lineStart + 1\n\n\tif f.sourceMap != nil {\n\t\tif _, _, row, col, ok := f.sourceMap.Source(row, col); ok {\n\t\t\treturn Position{\n\t\t\t\tLine: row,\n\t\t\t\tCol:  col,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Position{\n\t\tLine: row,\n\t\tCol:  col,\n\t}\n}\n\n\n\nfunc (p Position) String() string {\n\treturn fmt.Sprintf(\"%d:%d\", p.Line, p.Col)\n}\n\nfunc (f *SrcFile) scanTo(offset int) int ", "output": "{\n\to := f.lastScannedOffset\n\tfor o < offset {\n\t\tp := strings.Index(f.src[o:], \"\\n\")\n\t\tif p == -1 {\n\t\t\tf.lastScannedOffset = len(f.src)\n\t\t\treturn len(f.lineOffsets) - 1\n\t\t}\n\t\to = o + p + 1\n\t\tf.lineOffsets = append(f.lineOffsets, o)\n\t}\n\tf.lastScannedOffset = o\n\n\tif o == offset {\n\t\treturn len(f.lineOffsets) - 1\n\t}\n\n\treturn len(f.lineOffsets) - 2\n}"}
{"input": "package types\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype MountPoint struct {\n\tName     ACName `json:\"name\"`\n\tPath     string `json:\"path\"`\n\tReadOnly bool   `json:\"readOnly,omitempty\"`\n}\n\n\n\n\n\n\n\n\n\nfunc MountPointFromString(mp string) (*MountPoint, error) {\n\tvar mount MountPoint\n\n\tmp = \"name=\" + mp\n\tv, err := url.ParseQuery(strings.Replace(mp, \",\", \"&\", -1))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor key, val := range v {\n\t\tif len(val) > 1 {\n\t\t\treturn nil, fmt.Errorf(\"label %s with multiple values %q\", key, val)\n\t\t}\n\n\t\tswitch key {\n\t\tcase \"name\":\n\t\t\tacn, err := NewACName(val[0])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tmount.Name = *acn\n\t\tcase \"path\":\n\t\t\tmount.Path = val[0]\n\t\tcase \"readOnly\":\n\t\t\tro, err := strconv.ParseBool(val[0])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tmount.ReadOnly = ro\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unknown mountpoint parameter %q\", key)\n\t\t}\n\t}\n\terr = mount.assertValid()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &mount, nil\n}\n\nfunc (mount MountPoint) assertValid() error ", "output": "{\n\tif mount.Name.Empty() {\n\t\treturn errors.New(\"name must be set\")\n\t}\n\tif len(mount.Path) == 0 {\n\t\treturn errors.New(\"path must be set\")\n\t}\n\treturn nil\n}"}
{"input": "package logger\n\nimport (\n\t\"time\"\n)\n\n\ntype TermColors struct{}\n\nfunc (TermColors) Reset() string     { return \"\\x1b[0m\" }\nfunc (TermColors) Bold() string      { return \"\\x1b[1m\" }\nfunc (TermColors) Underline() string { return \"\\x1b[4m\" }\nfunc (TermColors) Black() string     { return \"\\x1b[30m\" }\nfunc (TermColors) Red() string       { return \"\\x1b[31m\" }\nfunc (TermColors) Green() string     { return \"\\x1b[32m\" }\n\nfunc (TermColors) Blue() string      { return \"\\x1b[34m\" }\nfunc (TermColors) Magenta() string   { return \"\\x1b[35m\" }\nfunc (TermColors) Cyan() string      { return \"\\x1b[36m\" }\nfunc (TermColors) White() string     { return \"\\x1b[37m\" }\n\ntype Extras map[string]interface{}\n\ntype LogEvent struct {\n\tLevel       LogLevel\n\tHost        string\n\tMessage     string\n\tLongMessage string\n\tTimestamp   time.Time\n\tExtras      Extras\n\tTermColors\n}\n\nfunc (event *LogEvent) LevelColor() string {\n\tswitch event.Level {\n\tcase Emergency, Alert, Critical, Error:\n\t\treturn event.Red() + event.Bold()\n\tcase Warning, Notice:\n\t\treturn event.Red()\n\tcase Info, Debug:\n\t\treturn event.Blue()\n\t}\n\treturn \"\"\n}\n\nfunc (event *LogEvent) TimeRFC3339() string {\n\treturn event.Timestamp.Format(time.RFC3339)\n}\n\nfunc (TermColors) Yellow() string    ", "output": "{ return \"\\x1b[33m\" }"}
{"input": "package srv\n\nimport \"fmt\"\n\ntype Command struct{}\n\nfunc NewCommand() *Command {\n\treturn &Command{}\n}\n\n\n\nfunc (c *Command) Description() string {\n\treturn \"publish Dispatcher servers\"\n}\n\nfunc (c *Command) Help() string {\n\treturn `usage: melange srv [command]\n\nServer will handle the publishing of Dispatcher servers for users.\n\nList of commands:\n\n\tpublish\t\twalk through publishing a server to Melange\n`\n}\n\nfunc (c *Command) Run(options []string) ", "output": "{\n\tif len(options) == 0 {\n\t\tfmt.Println(c.Help())\n\t\treturn\n\t}\n\n\tcommand := options[0]\n\textra := options[1:]\n\n\tswitch command {\n\tcase \"publish\":\n\t\tc.RunPublish(extra)\n\t}\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n\t\"net/http\"\n)\n\n\ntype UpdateDedicatedVmHostRequest struct {\n\n\tDedicatedVmHostId *string `mandatory:\"true\" contributesTo:\"path\" name:\"dedicatedVmHostId\"`\n\n\tUpdateDedicatedVmHostDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tOpcRetryToken *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-retry-token\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request UpdateDedicatedVmHostRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request UpdateDedicatedVmHostRequest) HTTPRequest(method, path string) (http.Request, error) {\n\treturn common.MakeDefaultHTTPRequestWithTaggedStruct(method, path, request)\n}\n\n\nfunc (request UpdateDedicatedVmHostRequest) RetryPolicy() *common.RetryPolicy {\n\treturn request.RequestMetadata.RetryPolicy\n}\n\n\ntype UpdateDedicatedVmHostResponse struct {\n\n\tRawResponse *http.Response\n\n\tDedicatedVmHost `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response UpdateDedicatedVmHostResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\n\n\nfunc (response UpdateDedicatedVmHostResponse) HTTPResponse() *http.Response ", "output": "{\n\treturn response.RawResponse\n}"}
{"input": "package elastic\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/olivere/elastic/uritemplates\"\n)\n\ntype IndexExistsService struct {\n\tclient *Client\n\tindex  string\n}\n\nfunc NewIndexExistsService(client *Client) *IndexExistsService {\n\tbuilder := &IndexExistsService{\n\t\tclient: client,\n\t}\n\treturn builder\n}\n\n\n\nfunc (b *IndexExistsService) Do() (bool, error) {\n\tpath, err := uritemplates.Expand(\"/{index}\", map[string]string{\n\t\t\"index\": b.index,\n\t})\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tres, err := b.client.PerformRequest(\"HEAD\", path, nil, nil)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif res.StatusCode == 200 {\n\t\treturn true, nil\n\t} else if res.StatusCode == 404 {\n\t\treturn false, nil\n\t}\n\treturn false, fmt.Errorf(\"elastic: got HTTP code %d when it should have been either 200 or 404\", res.StatusCode)\n}\n\nfunc (b *IndexExistsService) Index(index string) *IndexExistsService ", "output": "{\n\tb.index = index\n\treturn b\n}"}
{"input": "package v1\n\nimport (\n\t\"net/http\"\n\n\tv1 \"k8s.io/api/discovery/v1\"\n\t\"k8s.io/client-go/kubernetes/scheme\"\n\trest \"k8s.io/client-go/rest\"\n)\n\ntype DiscoveryV1Interface interface {\n\tRESTClient() rest.Interface\n\tEndpointSlicesGetter\n}\n\n\ntype DiscoveryV1Client struct {\n\trestClient rest.Interface\n}\n\nfunc (c *DiscoveryV1Client) EndpointSlices(namespace string) EndpointSliceInterface {\n\treturn newEndpointSlices(c, namespace)\n}\n\n\n\n\nfunc NewForConfig(c *rest.Config) (*DiscoveryV1Client, error) {\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\thttpClient, err := rest.HTTPClientFor(&config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewForConfigAndClient(&config, httpClient)\n}\n\n\n\nfunc NewForConfigAndClient(c *rest.Config, h *http.Client) (*DiscoveryV1Client, error) {\n\tconfig := *c\n\tif err := setConfigDefaults(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tclient, err := rest.RESTClientForConfigAndClient(&config, h)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &DiscoveryV1Client{client}, nil\n}\n\n\n\nfunc NewForConfigOrDie(c *rest.Config) *DiscoveryV1Client {\n\tclient, err := NewForConfig(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n\n\nfunc New(c rest.Interface) *DiscoveryV1Client {\n\treturn &DiscoveryV1Client{c}\n}\n\n\n\n\n\nfunc (c *DiscoveryV1Client) RESTClient() rest.Interface {\n\tif c == nil {\n\t\treturn nil\n\t}\n\treturn c.restClient\n}\n\nfunc setConfigDefaults(config *rest.Config) error ", "output": "{\n\tgv := v1.SchemeGroupVersion\n\tconfig.GroupVersion = &gv\n\tconfig.APIPath = \"/apis\"\n\tconfig.NegotiatedSerializer = scheme.Codecs.WithoutConversion()\n\n\tif config.UserAgent == \"\" {\n\t\tconfig.UserAgent = rest.DefaultKubernetesUserAgent()\n\t}\n\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\nvar cmdRestoreSnapshot = &Command{\n\tRun:   runRestoreSnapshot,\n\tUsage: \"restore-snapshot [-f] <repo> <snapshot>\",\n\tShort: \"restore snapshot\",\n\tLong: `\nRestores the specified snapshot.\n\nExample:\n\n  $ es restore-snapshot my_backup snapshot1\n  $ es restore-snapshot -f my_backup snapshot1\n`,\n\tApiUrl: \"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-snapshots.html#_restore\",\n}\n\n\n\nfunc runRestoreSnapshot(cmd *Command, args []string) ", "output": "{\n\tif len(args) < 2 {\n\t\tcmd.printUsage()\n\t\tos.Exit(1)\n\t}\n\n\trepo := args[0]\n\tsnapshot := args[1]\n\n\tvar response struct {\n\t\tOk     bool   `json:\"ok,omitempty\"`\n\t\tAck    bool   `json:\"acknowledged,omitempty\"`\n\t\tError  string `json:\"error,omitempty\"`\n\t\tStatus int    `json:\"status,omitempty\"`\n\t}\n\tdata := getJsonFromStdin()\n\treq := ESReq(\"POST\", \"/_snapshot/\"+repo+\"/\"+snapshot+\"/_restore\")\n\tif data != nil {\n\t\treq.SetBodyJson(data)\n\t}\n\treq.Do(&response)\n\tif len(response.Error) > 0 {\n\t\tlog.Fatalf(\"Error: %v (%v)\\n\", response.Error, response.Status)\n\t}\n}"}
{"input": "package match\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\n\nfunc Match(t *testing.T, value interface{}) *Matcher {\n\treturn &Matcher{\n\t\tt:     t,\n\t\tvalue: value,\n\t}\n}\n\n\nfunc IsNil(t *testing.T, value interface{}) *Matcher {\n\treturn Match(t, value).IsNil()\n}\n\n\nfunc IsNotNil(t *testing.T, value interface{}) *Matcher {\n\treturn Match(t, value).IsNotNil()\n}\n\n\nfunc Equals(t *testing.T, value, other interface{}) *Matcher {\n\treturn Match(t, value).Equals(other)\n}\n\n\nfunc NotEquals(t *testing.T, value, other interface{}) *Matcher {\n\treturn Match(t, value).NotEquals(other)\n}\n\n\nfunc LessThan(t *testing.T, value, other interface{}) *Matcher {\n\treturn Match(t, value).LessThan(other)\n}\n\n\nfunc GreaterThan(t *testing.T, value, other interface{}) *Matcher {\n\treturn Match(t, value).GreaterThan(other)\n}\n\n\nfunc Contains(t *testing.T, value, other interface{}) *Matcher {\n\treturn Match(t, value).Contains(other)\n}\n\n\n\n\n\nfunc KindOf(t *testing.T, value interface{}, kind reflect.Kind) *Matcher {\n\treturn Match(t, value).KindOf(kind)\n}\n\nfunc Matches(t *testing.T, value interface{}, pattern string) *Matcher ", "output": "{\n\treturn Match(t, value).Matches(pattern)\n}"}
{"input": "package instructions\n\n\n\nfunc isSecretMountsSupported() bool ", "output": "{\n\treturn true\n}"}
{"input": "package wait\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n\n\n\n\n\nfunc Predicate(pred func() bool, timeout time.Duration) error {\n\tconst pollInterval = 20 * time.Millisecond\n\n\texitTimer := time.After(timeout)\n\tfor {\n\t\t<-time.After(pollInterval)\n\n\t\tselect {\n\t\tcase <-exitTimer:\n\t\t\treturn fmt.Errorf(\"predicate not satisfied after time out\")\n\t\tdefault:\n\t\t}\n\n\t\tif pred() {\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\nfunc Invariant(statement func() bool, timeout time.Duration) error {\n\tconst pollInterval = 20 * time.Millisecond\n\n\texitTimer := time.After(timeout)\n\tfor {\n\t\t<-time.After(pollInterval)\n\n\t\tif !statement() {\n\t\t\treturn fmt.Errorf(\"invariant broken before time out\")\n\t\t}\n\n\t\tselect {\n\t\tcase <-exitTimer:\n\t\t\treturn nil\n\t\tdefault:\n\t\t}\n\t}\n}\n\n\n\n\nfunc InvariantNoError(f func() error, timeout time.Duration) error {\n\tvar predErr error\n\tpred := func() bool {\n\t\tif err := f(); err != nil {\n\t\t\tpredErr = err\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tif err := Invariant(pred, timeout); err != nil {\n\t\treturn predErr\n\t}\n\n\treturn nil\n}\n\nfunc NoError(f func() error, timeout time.Duration) error ", "output": "{\n\tvar predErr error\n\tpred := func() bool {\n\t\tif err := f(); err != nil {\n\t\t\tpredErr = err\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tif err := Predicate(pred, timeout); err != nil {\n\t\treturn predErr\n\t}\n\n\treturn nil\n}"}
{"input": "package perfcounters\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\t\"time\"\n)\n\n\n\ntype RateOfCountsPerSecond32 struct {\n\tlastTime     *time.Time\n\tlastCount    int32\n\tcurrentCount int32\n\tmu           sync.Mutex\n}\n\n\n\nfunc (self *RateOfCountsPerSecond32) Increment() {\n\tself.Add(1)\n}\n\nfunc (self *RateOfCountsPerSecond32) Add(value int32) {\n\tself.mu.Lock()\n\tdefer self.mu.Unlock()\n\n\tself.currentCount += value\n\n\tif self.lastTime == nil {\n\t\tlastTime := time.Now()\n\t\tself.lastTime = &lastTime\n\t}\n}\n\nfunc (self *RateOfCountsPerSecond32) CalculatedValue() float64 {\n\tself.mu.Lock()\n\tdefer self.mu.Unlock()\n\n\tcurrentTime := time.Now()\n\n\tif self.lastTime == nil {\n\t\tself.lastTime = &currentTime\n\t\treturn 0\n\t}\n\n\tlastTime := self.lastTime\n\tlastCount := self.lastCount\n\tcurrentCount := self.currentCount\n\n\tdiff := currentTime.Sub(*lastTime)\n\n\tcalculatedValue := float64(currentCount-lastCount) / diff.Seconds()\n\n\tif math.IsNaN(calculatedValue) || math.IsInf(calculatedValue, 1) || math.IsInf(calculatedValue, -1) {\n\t\tcalculatedValue = 0.0\n\t}\n\n\tself.lastCount = currentCount\n\tself.lastTime = &currentTime\n\n\treturn calculatedValue\n}\n\nfunc (self *RateOfCountsPerSecond32) String() string {\n\treturn fmt.Sprintf(\"%.3f\", self.CalculatedValue())\n}\n\nfunc NewRateOfCountsPerSecond32() *RateOfCountsPerSecond32 ", "output": "{\n\n\treturn &RateOfCountsPerSecond32{\n\t\tlastTime:     nil,\n\t\tlastCount:    0,\n\t\tcurrentCount: 0,\n\t}\n}"}
{"input": "package kubelet\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/golang/glog\"\n\t\"k8s.io/kubernetes/pkg/api\"\n\t\"k8s.io/kubernetes/pkg/types\"\n\t\"k8s.io/kubernetes/pkg/volume\"\n\tvolumetypes \"k8s.io/kubernetes/pkg/volume/util/types\"\n)\n\n\n\nfunc (kl *Kubelet) ListVolumesForPod(podUID types.UID) (map[string]volume.Volume, bool) {\n\tvolumesToReturn := make(map[string]volume.Volume)\n\tpodVolumes := kl.volumeManager.GetMountedVolumesForPod(\n\t\tvolumetypes.UniquePodName(podUID))\n\tfor outerVolumeSpecName, volume := range podVolumes {\n\t\tvolumesToReturn[outerVolumeSpecName] = volume.Mounter\n\t}\n\n\treturn volumesToReturn, len(volumesToReturn) > 0\n}\n\n\n\n\n\n\n\n\nfunc (kl *Kubelet) newVolumeMounterFromPlugins(spec *volume.Spec, pod *api.Pod, opts volume.VolumeOptions) (volume.Mounter, error) {\n\tplugin, err := kl.volumePluginMgr.FindPluginBySpec(spec)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't use volume plugins for %s: %v\", spec.Name(), err)\n\t}\n\tphysicalMounter, err := plugin.NewMounter(spec, pod, opts)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to instantiate mounter for volume: %s using plugin: %s with a root cause: %v\", spec.Name(), plugin.GetPluginName(), err)\n\t}\n\tglog.V(10).Infof(\"Using volume plugin %q to mount %s\", plugin.GetPluginName(), spec.Name())\n\treturn physicalMounter, nil\n}\n\nfunc (kl *Kubelet) podVolumesExist(podUID types.UID) bool ", "output": "{\n\tif mountedVolumes :=\n\t\tkl.volumeManager.GetMountedVolumesForPod(\n\t\t\tvolumetypes.UniquePodName(podUID)); len(mountedVolumes) > 0 {\n\t\treturn true\n\t}\n\n\treturn false\n}"}
{"input": "package marshaller\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\tkrautreporter \"github.com/metalmatze/krautreporter-api\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestImage(t *testing.T) {\n\ti := []*krautreporter.Image{}\n\n\tb, err := json.Marshal(FromImages(i))\n\tassert.Nil(t, err)\n\tassert.JSONEq(t, `{\"data\":[]}`, string(b))\n\n\ti = append(i, &krautreporter.Image{ID: 123, Width: 256, Src: \"/foo.jpg\"})\n\tb, err = json.Marshal(FromImages(i))\n\tassert.Nil(t, err)\n\tassert.JSONEq(t, `{\"data\":[{\"id\":123,\"width\":256,\"src\":\"https://krautreporter.de/foo.jpg\"}]}`, string(b))\n}\n\nfunc TestMarshallImage(t *testing.T) ", "output": "{\n\ti := &krautreporter.Image{ID: 123, Width: 256, Src: \"/foo.jpg\"}\n\n\tb, err := json.Marshal(marshallImage(i))\n\tassert.Nil(t, err)\n\tassert.JSONEq(t, `{\"id\":123,\"width\":256,\"src\":\"https://krautreporter.de/foo.jpg\"}`, string(b))\n}"}
{"input": "package misc\n\nimport \"jvmgo/ch11/native\"\nimport \"jvmgo/ch11/rtda\"\n\nfunc init() {\n\tnative.Register(\"sun/misc/URLClassPath\", \"getLookupCacheURLs\", \"(Ljava/lang/ClassLoader;)[Ljava/net/URL;\", getLookupCacheURLs)\n}\n\n\n\n\n\nfunc getLookupCacheURLs(frame *rtda.Frame) ", "output": "{\n\tframe.OperandStack().PushRef(nil)\n}"}
{"input": "package endian\n\nimport (\n\t\"encoding/binary\"\n\t\"unsafe\"\n)\n\n\nvar Endian binary.ByteOrder\nvar bigEndian bool\n\nfunc IsBigEndian() bool {\n\treturn bigEndian\n}\n\nfunc IsLittleEndian() bool {\n\treturn !bigEndian\n}\n\n\n\n\nconst INT_SIZE int = int(unsafe.Sizeof(0))\n\n\nfunc getEndian() (ret bool) {\n\tvar i int = 0x1\n\tbs := (*[INT_SIZE]byte)(unsafe.Pointer(&i))\n\tif bs[0] == 0 {\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n\n}\n\nfunc init() ", "output": "{\n\tif getEndian() {\n\t\tEndian = binary.BigEndian\n\t\tbigEndian = true\n\t} else {\n\t\tEndian = binary.LittleEndian\n\t\tbigEndian = false\n\t}\n}"}
{"input": "package main\n\nimport \"fmt\"\n\ntype reception struct {\n\tnext iDepartment\n}\n\n\n\nfunc (r *reception) setNext(next iDepartment) {\n\tr.next = next\n}\n\nfunc (r *reception) execute(p *patient) ", "output": "{\n\tif p.registrationDone {\n\t\tfmt.Println(\"Patient registration already done\")\n\t\tr.next.execute(p)\n\t\treturn\n\t}\n\tfmt.Println(\"Reception registering patient\")\n\tp.registrationDone = true\n\tr.next.execute(p)\n}"}
{"input": "package unary\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/net/context\"\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\nfunc BasicAuthUnary(\n    ctx context.Context,\n    req interface{},\n    info *grpc.UnaryServerInfo,\n    handler grpc.UnaryHandler,\n) (interface{}, error) {\n    \n    md, ok := metadata.FromContext(ctx)\n    _ = ok\n\n    \n    isValid, err := ValidateBasicCredentials(md[\"authorization\"])\n    if err != nil {\n        return nil, grpc.Errorf(codes.Internal, \"falied to validate Authorization.\")\n    }\n\n    if isValid {\n        \n        return handler(ctx, req)\n    } else {\n        return nil, grpc.Errorf(codes.Unauthenticated, \"authentication required.\")\n    }\n}\n\n\n\nfunc ValidateBasicCredentials(authorization []string) (isValid bool, err error) ", "output": "{\n    fmt.Println(\"Validating the Authorization in headers...\")\n    \n    return true, nil\n}"}
{"input": "package utils\n\nimport (\n\t\"encoding/base64\"\n\n\t\"github.com/corvinusz/echo-xorm/pkg/errors\"\n\n\t\"github.com/go-xorm/xorm\"\n\t\"github.com/labstack/echo/v4\"\n\t\"golang.org/x/crypto/sha3\"\n)\n\nconst (\n\tTxLevelReadCommitted = iota + 1\n\tTxLevelRepeatableRead\n\tTxLevelSerializable\n)\n\n\nfunc GetSHA3Hash(data string) string {\n\th := make([]byte, 64)\n\tsha3.ShakeSum256(h, []byte(data))\n\treturn base64.StdEncoding.EncodeToString(h)\n}\n\n\nfunc GetEvent(c echo.Context) string {\n\treturn c.Request().Method + \" \" + c.Path()\n}\n\n\n\n\n\n\n\n\nfunc RollbackTransaction(tx *xorm.Session, err error) error {\n\terb := tx.Rollback()\n\tif erb != nil {\n\t\tif err != nil {\n\t\t\terb = errors.NewWithPrefix(erb, err.Error())\n\t\t}\n\t\treturn errors.NewWithPrefix(erb, \"database error\")\n\t}\n\treturn err\n}\n\nfunc BeginTransaction(orm *xorm.Engine) (*xorm.Session, error) ", "output": "{\n\ttx := orm.NewSession()\n\terr := tx.Begin()\n\tif err != nil {\n\t\ttx.Close()\n\t\treturn nil, errors.NewWithPrefix(err, \"database error\")\n\t}\n\n\treturn tx, nil\n}"}
{"input": "package xml2json\n\nimport (\n\t\"strings\"\n)\n\n\ntype Node struct {\n\tChildren              map[string]Nodes\n\tData                  string\n\tChildrenAlwaysAsArray bool\n}\n\n\ntype Nodes []*Node\n\n\n\n\n\nfunc (n *Node) IsComplex() bool {\n\treturn len(n.Children) > 0\n}\n\n\nfunc (n *Node) GetChild(path string) *Node {\n\tresult := n\n\tnames := strings.Split(path, \".\")\n\tfor _, name := range names {\n\t\tchildren, exists := result.Children[name]\n\t\tif !exists {\n\t\t\treturn nil\n\t\t}\n\t\tif len(children) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tresult = children[0]\n\t}\n\treturn result\n}\n\nfunc (n *Node) AddChild(s string, c *Node) ", "output": "{\n\tif n.Children == nil {\n\t\tn.Children = map[string]Nodes{}\n\t}\n\n\tn.Children[s] = append(n.Children[s], c)\n}"}
{"input": "package vrtcal\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/prebid/prebid-server/openrtb_ext\"\n)\n\n\n\n\n\n\n\n\nfunc TestValidParams(t *testing.T) {\n\tvalidator, err := openrtb_ext.NewBidderParamsValidator(\"../../static/bidder-params\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to fetch the json-schemas. %v\", err)\n\t}\n\n\tfor _, validParam := range validParams {\n\t\tif err := validator.Validate(openrtb_ext.BidderVrtcal, json.RawMessage(validParam)); err != nil {\n\t\t\tt.Errorf(\"Schema rejected Vrtcal params: %s\", validParam)\n\t\t}\n\t}\n}\n\n\n\n\nvar validParams = []string{}\n\nvar invalidParams = []string{}\n\nfunc TestInvalidParams(t *testing.T) ", "output": "{\n\tvalidator, err := openrtb_ext.NewBidderParamsValidator(\"../../static/bidder-params\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to fetch the json-schemas. %v\", err)\n\t}\n\n\tfor _, invalidParam := range invalidParams {\n\t\tif err := validator.Validate(openrtb_ext.BidderVrtcal, json.RawMessage(invalidParam)); err == nil {\n\t\t\tt.Errorf(\"Schema allowed unexpected params: %s\", invalidParam)\n\t\t}\n\t}\n}"}
{"input": "package core\n\nimport \"go/ast\"\n\nfunc resolveIdent(n *ast.Ident, c *Context) bool {\n\tif n.Obj == nil || n.Obj.Kind != ast.Var {\n\t\treturn true\n\t}\n\tif node, ok := n.Obj.Decl.(ast.Node); ok {\n\t\treturn TryResolve(node, c)\n\t}\n\treturn false\n}\n\nfunc resolveAssign(n *ast.AssignStmt, c *Context) bool {\n\tfor _, arg := range n.Rhs {\n\t\tif !TryResolve(arg, c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc resolveCompLit(n *ast.CompositeLit, c *Context) bool {\n\tfor _, arg := range n.Elts {\n\t\tif !TryResolve(arg, c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\n\nfunc resolveCallExpr(n *ast.CallExpr, c *Context) bool {\n\treturn false\n}\n\n\n\n\nfunc TryResolve(n ast.Node, c *Context) bool {\n\tswitch node := n.(type) {\n\tcase *ast.BasicLit:\n\t\treturn true\n\n\tcase *ast.CompositeLit:\n\t\treturn resolveCompLit(node, c)\n\n\tcase *ast.Ident:\n\t\treturn resolveIdent(node, c)\n\n\tcase *ast.AssignStmt:\n\t\treturn resolveAssign(node, c)\n\n\tcase *ast.CallExpr:\n\t\treturn resolveCallExpr(node, c)\n\n\tcase *ast.BinaryExpr:\n\t\treturn resolveBinExpr(node, c)\n\t}\n\n\treturn false\n}\n\nfunc resolveBinExpr(n *ast.BinaryExpr, c *Context) bool ", "output": "{\n\treturn (TryResolve(n.X, c) && TryResolve(n.Y, c))\n}"}
{"input": "package martini_gorelic\n\nimport (\n\t\"fmt\"\n\t\"github.com/go-martini/martini\"\n\tmetrics \"github.com/yvasiyarov/go-metrics\"\n\t\"github.com/yvasiyarov/gorelic\"\n\t\"time\"\n)\n\nvar agent *gorelic.Agent\n\nfunc Handler(c martini.Context) {\n\tstartTime := time.Now()\n\tc.Next()\n\tagent.HTTPTimer.UpdateSince(startTime)\n}\n\n\n\nfunc InitNewrelicAgent(license string, appname string, verbose bool) error ", "output": "{\n\n\tif license == \"\" {\n\t\treturn fmt.Errorf(\"Please specify NewRelic license\")\n\t}\n\n\tagent = gorelic.NewAgent()\n\tagent.NewrelicLicense = license\n\n\tagent.HTTPTimer = metrics.NewTimer()\n\tagent.CollectHTTPStat = true\n\tagent.Verbose = verbose\n\n\tagent.NewrelicName = appname\n\tagent.Run()\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n)\n\n\n\nfunc testPostMessage(t *testing.T, requestURL, from, body string) {\n\tpostValues := url.Values{\n\t\t\"from\": {from},\n\t\t\"body\": {body},\n\t}\n\tres, err := http.PostForm(requestURL, postValues)\n\tif err != nil {\n\t\tt.Fatalf(\"Error occured: %s\", err)\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode != http.StatusOK {\n\t\tt.Logf(\"URL[%s]\", requestURL)\n\t\tt.Logf(\"Parameter:from[%s], body[%s]\", from, body)\n\t\tt.Errorf(\"res.StatusCode => %d, want %d\", res.StatusCode, http.StatusOK)\n\t}\n}\n\nfunc testGetMessages(t *testing.T, requestURL string) string {\n\tres, err := http.Get(requestURL)\n\tif err != nil {\n\t\tt.Fatalf(\"Error occured: %s\", err)\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode != http.StatusOK {\n\t\tt.Logf(\"URL[%s]\", requestURL)\n\t\tt.Errorf(\"res.StatusCode => %d, want %d\", res.StatusCode, http.StatusOK)\n\t}\n\n\tresMsg, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tt.Fatalf(\"Responce read error occured: %s\", err)\n\t}\n\n\treturn string(resMsg)\n}\n\nfunc TestServe(t *testing.T) ", "output": "{\n\tserver := httptest.NewServer(SetupHandler())\n\tdefer server.Close()\n\n\ttestPostMessage(t, server.URL+\"/drawer1/messages/new\", \"john\", \"testmsg1\")\n\ttestPostMessage(t, server.URL+\"/drawer2/messages/new\", \"smith\", \"testmsg2\")\n\ttestPostMessage(t, server.URL+\"/messages/new\", \"admin\", \"broadcast\")\n\n\tjsonMessages := testGetMessages(t, server.URL+\"/drawer1/messages\")\n\tif !strings.Contains(jsonMessages, \"testmsg1\") {\n\t\tt.Errorf(\"Drower1 must has %s, but does not.\", \"testmsg1\")\n\t}\n\tif !strings.Contains(jsonMessages, \"broadcast\") {\n\t\tt.Errorf(\"Drower1 must has %s, but does not.\", \"broadcast\")\n\t}\n}"}
{"input": "package caaa\n\nimport (\n\t\"encoding/xml\"\n\n\t\"github.com/fgrid/iso20022\"\n)\n\ntype Document00600103 struct {\n\tXMLName xml.Name                         `xml:\"urn:iso:std:iso:20022:tech:xsd:caaa.006.001.03 Document\"`\n\tMessage *AcceptorCancellationResponseV03 `xml:\"AccptrCxlRspn\"`\n}\n\nfunc (d *Document00600103) AddMessage() *AcceptorCancellationResponseV03 {\n\td.Message = new(AcceptorCancellationResponseV03)\n\treturn d.Message\n}\n\n\ntype AcceptorCancellationResponseV03 struct {\n\n\tHeader *iso20022.Header7 `xml:\"Hdr\"`\n\n\tCancellationResponse *iso20022.AcceptorCancellationResponse3 `xml:\"CxlRspn\"`\n\n\tSecurityTrailer *iso20022.ContentInformationType8 `xml:\"SctyTrlr\"`\n}\n\n\n\nfunc (a *AcceptorCancellationResponseV03) AddCancellationResponse() *iso20022.AcceptorCancellationResponse3 {\n\ta.CancellationResponse = new(iso20022.AcceptorCancellationResponse3)\n\treturn a.CancellationResponse\n}\n\nfunc (a *AcceptorCancellationResponseV03) AddSecurityTrailer() *iso20022.ContentInformationType8 {\n\ta.SecurityTrailer = new(iso20022.ContentInformationType8)\n\treturn a.SecurityTrailer\n}\n\nfunc (a *AcceptorCancellationResponseV03) AddHeader() *iso20022.Header7 ", "output": "{\n\ta.Header = new(iso20022.Header7)\n\treturn a.Header\n}"}
{"input": "package api\n\nimport (\n\t\"github.com/lukevers/gelato/json\"\n\t\"net/http\"\n)\n\n\n\n\n\n\n\n\n\n\n\nfunc HandlePlayers(w http.ResponseWriter, r *http.Request) {\n\tstat, err := server.Query.Full()\n\n\tstatus := 200\n\tif err != nil {\n\t\tstatus = 500\n\t}\n\n\tjson.WriteJson(json.JsonWriter{\n\t\tRw:     Wr(w, r),\n\t\tStatus: status,\n\t\tError:  err,\n\t\tBody: struct {\n\t\t\tNumPlayers    int\n\t\t\tMaxPlayers    int\n\t\t\tOnlinePlayers []string\n\t\t}{\n\t\t\tstat.NumPlayers,\n\t\t\tstat.MaxPlayers,\n\t\t\tstat.Players,\n\t\t},\n\t})\n}\n\n\n\n\n\n\n\n\n\n\n\nfunc HandleOnlinePlayers(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tstat, err := server.Query.Full()\n\n\tstatus := 200\n\tif err != nil {\n\t\tstatus = 500\n\t}\n\n\tjson.WriteJson(json.JsonWriter{\n\t\tRw:     Wr(w, r),\n\t\tStatus: status,\n\t\tError:  err,\n\t\tBody: struct {\n\t\t\tOnlinePlayers []string\n\t\t}{\n\t\t\tstat.Players,\n\t\t},\n\t})\n}"}
{"input": "package melting\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"reflect\"\n)\n\n\n\ntype nameFilter struct {\n\texclude string\n}\n\nfunc (f *nameFilter) Filter(srcField, destField reflect.StructField, src, dest reflect.Value) bool {\n\treturn f.exclude != srcField.Name\n}\n\nfunc ExampleMeltWithFilter() {\n\ttype Source struct {\n\t\tF1 int\n\t\tF2 string\n\t}\n\ttype Dest struct {\n\t\tF1 int\n\t\tF2 string\n\t\tF3 float32\n\t}\n\n\ts := Source{F1: 3, F2: \"a\"}\n\td := Dest{F1: 4, F2: \"b\", F3: 3.1}\n\n\terr := MeltWithFilter(s, &d, &nameFilter{\"F2\"})\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot assign source to dest, error %v\", err)\n\t}\n\n\tfmt.Printf(\"Source%v\\nDest%v\\n\", s, d)\n\n}\n\nfunc Example() ", "output": "{\n\ttype Source struct {\n\t\tF1 int\n\t\tF2 string\n\t}\n\ttype Dest struct {\n\t\tF1 int\n\t\tF3 float32\n\t\tF2 string\n\t}\n\n\ts := Source{F1: 3, F2: \"a\"}\n\td := Dest{F1: 4, F2: \"b\", F3: 3.1}\n\n\terr := Melt(s, &d)\n\tif err != nil {\n\t\tlog.Fatalf(\"cannot assign source to dest, error %v\", err)\n\t}\n\n\tfmt.Printf(\"Source%v\\nDest%v\\n\", s, d)\n\n}"}
{"input": "package testing\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\n\t\"k8s.io/apiserver/pkg/admission/plugin/webhook/config\"\n)\n\ntype serviceResolver struct {\n\tbase url.URL\n}\n\n\n\n\n\nfunc (f serviceResolver) ResolveEndpoint(namespace, name string) (*url.URL, error) {\n\tif namespace == \"failResolve\" {\n\t\treturn nil, fmt.Errorf(\"couldn't resolve service location\")\n\t}\n\tu := f.base\n\treturn &u, nil\n}\n\nfunc NewServiceResolver(base url.URL) config.ServiceResolver ", "output": "{\n\treturn &serviceResolver{base}\n}"}
{"input": "package testing\n\nimport \"k8s.io/kubernetes/pkg/util/iptables\"\n\n\ntype fake struct{}\n\nfunc NewFake() *fake {\n\treturn &fake{}\n}\n\nfunc (*fake) EnsureChain(table iptables.Table, chain iptables.Chain) (bool, error) {\n\treturn true, nil\n}\n\nfunc (*fake) FlushChain(table iptables.Table, chain iptables.Chain) error {\n\treturn nil\n}\n\nfunc (*fake) DeleteChain(table iptables.Table, chain iptables.Chain) error {\n\treturn nil\n}\n\nfunc (*fake) EnsureRule(position iptables.RulePosition, table iptables.Table, chain iptables.Chain, args ...string) (bool, error) {\n\treturn true, nil\n}\n\nfunc (*fake) DeleteRule(table iptables.Table, chain iptables.Chain, args ...string) error {\n\treturn nil\n}\n\nfunc (*fake) IsIpv6() bool {\n\treturn false\n}\n\nfunc (*fake) Save(table iptables.Table) ([]byte, error) {\n\treturn make([]byte, 0), nil\n}\n\n\n\nfunc (*fake) Restore(table iptables.Table, data []byte, flush iptables.FlushFlag, counters iptables.RestoreCountersFlag) error {\n\treturn nil\n}\n\nfunc (*fake) RestoreAll(data []byte, flush iptables.FlushFlag, counters iptables.RestoreCountersFlag) error {\n\treturn nil\n}\nfunc (*fake) AddReloadFunc(reloadFunc func()) {}\n\nfunc (*fake) Destroy() {}\n\nvar _ = iptables.Interface(&fake{})\n\nfunc (*fake) SaveAll() ([]byte, error) ", "output": "{\n\treturn make([]byte, 0), nil\n}"}
{"input": "package k1\n\nimport (\n\t\"io\"\n\n\t\"github.com/xjdrew/kone/tcpip\"\n)\n\ntype PacketFilter interface {\n\tFilter(wr io.Writer, p tcpip.IPv4Packet)\n}\n\ntype PacketFilterFunc func(wr io.Writer, p tcpip.IPv4Packet)\n\nfunc (f PacketFilterFunc) Filter(wr io.Writer, p tcpip.IPv4Packet) {\n\tf(wr, p)\n}\n\n\n\nfunc icmpFilterFunc(wr io.Writer, ipPacket tcpip.IPv4Packet) ", "output": "{\n\ticmpPacket := tcpip.ICMPPacket(ipPacket.Payload())\n\tif icmpPacket.Type() == tcpip.ICMPRequest && icmpPacket.Code() == 0 {\n\t\tlogger.Debugf(\"icmp echo request: %s -> %s\", ipPacket.SourceIP(), ipPacket.DestinationIP())\n\t\ticmpPacket.SetType(tcpip.ICMPEcho)\n\t\tsrcIP := ipPacket.SourceIP()\n\t\tdstIP := ipPacket.DestinationIP()\n\t\tipPacket.SetSourceIP(dstIP)\n\t\tipPacket.SetDestinationIP(srcIP)\n\n\t\ticmpPacket.ResetChecksum()\n\t\tipPacket.ResetChecksum()\n\t\twr.Write(ipPacket)\n\t} else {\n\t\tlogger.Debugf(\"icmp: %s -> %s\", ipPacket.SourceIP(), ipPacket.DestinationIP())\n\t}\n}"}
{"input": "package admission\n\nimport (\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/auth/user\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/runtime\"\n)\n\ntype attributesRecord struct {\n\tkind        string\n\tnamespace   string\n\tname        string\n\tresource    string\n\tsubresource string\n\toperation   Operation\n\tobject      runtime.Object\n\tuserInfo    user.Info\n}\n\nfunc NewAttributesRecord(object runtime.Object, kind, namespace, name, resource, subresource string, operation Operation, userInfo user.Info) Attributes {\n\treturn &attributesRecord{\n\t\tkind:        kind,\n\t\tnamespace:   namespace,\n\t\tname:        name,\n\t\tresource:    resource,\n\t\tsubresource: subresource,\n\t\toperation:   operation,\n\t\tobject:      object,\n\t\tuserInfo:    userInfo,\n\t}\n}\n\nfunc (record *attributesRecord) GetKind() string {\n\treturn record.kind\n}\n\n\n\nfunc (record *attributesRecord) GetName() string {\n\treturn record.name\n}\n\nfunc (record *attributesRecord) GetResource() string {\n\treturn record.resource\n}\n\nfunc (record *attributesRecord) GetSubresource() string {\n\treturn record.subresource\n}\n\nfunc (record *attributesRecord) GetOperation() Operation {\n\treturn record.operation\n}\n\nfunc (record *attributesRecord) GetObject() runtime.Object {\n\treturn record.object\n}\n\nfunc (record *attributesRecord) GetUserInfo() user.Info {\n\treturn record.userInfo\n}\n\nfunc (record *attributesRecord) GetNamespace() string ", "output": "{\n\treturn record.namespace\n}"}
{"input": "package testserver\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n)\n\n\nfunc CreateAndStartServer(response string) *httptest.Server {\n\treturn createHTTPServer(createDefaultFuncMap(response))\n}\n\nfunc createHTTPServer(handlers map[string]func(rw http.ResponseWriter, _ *http.Request)) *httptest.Server {\n\tmux := http.NewServeMux()\n\tfor k, v := range handlers {\n\t\tmux.HandleFunc(k, http.HandlerFunc(v))\n\t}\n\n\tserver := httptest.NewUnstartedServer(mux)\n\n\tl, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\tpanic(\"Could not create listener for test: \" + err.Error())\n\t}\n\tserver.Listener = l\n\tserver.Start()\n\treturn server\n}\n\n\n\nfunc createDefaultFuncMap(statsToReturn string) map[string]func(rw http.ResponseWriter, _ *http.Request) ", "output": "{\n\treturn map[string]func(rw http.ResponseWriter, _ *http.Request){\n\t\t\"/stats\": func(rw http.ResponseWriter, _ *http.Request) {\n\t\t\t_, err := rw.Write([]byte(statsToReturn))\n\t\t\tif err != nil {\n\t\t\t\tpanic(\"Could not write response: \" + err.Error())\n\t\t\t}\n\t\t},\n\t}\n}"}
{"input": "package engi\n\ntype Responder interface {\n\tRender()\n\tResize(width, height int)\n\tPreload()\n\tSetup()\n\tClose()\n\tUpdate(dt float32)\n\tMouse(x, y float32, action Action)\n\tScroll(amount float32)\n\tKey(key Key, modifier Modifier, action Action)\n\tType(char rune)\n\tAddEntity(e *Entity)\n\tBatch() *Batch\n\tNew()\n}\n\ntype Game struct{}\n\nfunc (g *Game) Preload()                          {}\nfunc (g *Game) Setup()                            {}\nfunc (g *Game) Close()                            {}\nfunc (g *Game) Update(dt float32)                 {}\nfunc (g *Game) Render()                           {}\nfunc (g *Game) Resize(w, h int)                   {}\nfunc (g *Game) Mouse(x, y float32, action Action) {}\nfunc (g *Game) Scroll(amount float32)             {}\n\nfunc (g *Game) Type(char rune) {}\n\nfunc (g *Game) Key(key Key, modifier Modifier, action Action) ", "output": "{\n\tif key == Escape {\n\t\tExit()\n\t}\n}"}
{"input": "package aws\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype Keys struct {\n\tAccessKey string\n\tSecretKey string\n}\n\n\nfunc LoadKeysFromFile(filePath string) (k *Keys) {\n\tk = &Keys{}\n\tif f, e := os.Open(filePath); e == nil {\n\t\tscanner := bufio.NewScanner(f)\n\t\tif scanner.Scan() {\n\t\t\tk.AccessKey = strings.TrimSpace(scanner.Text())\n\t\t}\n\t\tif scanner.Scan() {\n\t\t\tk.SecretKey = strings.TrimSpace(scanner.Text())\n\t\t}\n\t\tf.Close()\n\t}\n\tif k.AccessKey == \"\" || k.SecretKey == \"\" {\n\t\tk = nil\n\t}\n\treturn\n}\n\n\n\n\n\n\n\nfunc LoadKeys() (k *Keys) ", "output": "{\n\tk = &Keys{\n\t\tAccessKey: os.Getenv(\"AWS_ACCESS_KEY\"),\n\t\tSecretKey: os.Getenv(\"AWS_SECRET_KEY\"),\n\t}\n\tif k.AccessKey == \"\" {\n\t\tk = nil\n\t\tdirs := []string{\".\"}\n\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir == \"\" {\n\t\t\thomeDir = os.Getenv(\"HOMEPATH\") \n\t\t}\n\t\tif homeDir != \"\" {\n\t\t\tdirs = append(dirs, homeDir)\n\t\t}\n\t\tfor _, dir := range dirs {\n\t\t\tif d, e := filepath.Abs(dir); e == nil {\n\t\t\t\tk = LoadKeysFromFile(filepath.Join(d, \".awssecret\"))\n\t\t\t\tif k != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\t\"text/template\"\n)\n\nfunc init() {\n\thttp.Handle(\"/view\", appHandler(viewRecord))\n}\n\n\n\n\n\n\n\ntype appHandler func(http.ResponseWriter, *http.Request) error\n\nfunc (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif err := fn(w, r); err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t}\n}\n\n\n\ntype ap struct{}\n\nfunc (ap) NewContext(*http.Request) *ctx { return nil }\n\ntype ctx struct{}\n\nfunc (*ctx) Errorf(string, ...interface{}) {}\n\nvar appengine ap\n\ntype ds struct{}\n\nfunc (ds) NewKey(*ctx, string, string, int, *int) string { return \"\" }\nfunc (ds) Get(*ctx, string, *Record) error               { return nil }\n\nvar datastore ds\n\ntype Record struct{}\n\nvar viewTemplate *template.Template\n\nfunc main() {}\n\nfunc viewRecord(w http.ResponseWriter, r *http.Request) error ", "output": "{\n\tc := appengine.NewContext(r)\n\tkey := datastore.NewKey(c, \"Record\", r.FormValue(\"id\"), 0, nil)\n\trecord := new(Record)\n\tif err := datastore.Get(c, key, record); err != nil {\n\t\treturn err\n\t}\n\treturn viewTemplate.Execute(w, record)\n}"}
{"input": "package ivy\n\nimport (\n\t\"bytes\"\n)\n\ntype bufferPool struct {\n\tlist chan *bytes.Buffer\n}\n\n\n\nfunc (p *bufferPool) Put(b *bytes.Buffer) {\n\tb.Reset()\n\tselect {\n\tcase p.list <- b:\n\tdefault:\n\t}\n}\n\nfunc (p *bufferPool) Get() *bytes.Buffer {\n\tselect {\n\tcase b := <-p.list:\n\t\treturn b\n\tdefault:\n\t\treturn &bytes.Buffer{}\n\t}\n}\n\nfunc newBufferPool(poolSize int) *bufferPool ", "output": "{\n\tb := &bufferPool{\n\t\tlist: make(chan *bytes.Buffer, poolSize),\n\t}\n\n\treturn b\n}"}
{"input": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nvar cmdLogin = &Command{\n\tRun:   runLogin,\n\tUsage: \"login\",\n\tShort: \"Log in to a CIC server\",\n\tLong: `\nLog in to a CIC server\n\nExamples:\n\n  cic login server user password\n\n`,\n}\n\n\n\nvar cmdLogout = &Command{\n\tRun:   runLogout,\n\tUsage: \"logout <account>\",\n\tShort: \"Log out from CIC\",\n\tLong: `\nLog out from CIC\n\nExamples:\n\n  cic logout\n`,\n}\n\nfunc runLogout(cmd *Command, args []string) {\n\n\tConfig.Delete(\"current\", \"username\")\n\tConfig.Delete(\"current\", \"session\")\n\tConfig.Delete(\"current\", \"cookie\")\n\tConfig.Delete(\"current\", \"token\")\n\tConfig.Delete(\"current\", \"server\")\n\tConfig.Delete(\"current\", \"userid\")\n}\n\nfunc LoginAndSave(server string, username string, password string) (err error) {\n\n\tConfig.Delete(\"current\", \"username\")\n\tConfig.Delete(\"current\", \"session\")\n\tConfig.Delete(\"current\", \"cookie\")\n\tConfig.Delete(\"current\", \"token\")\n\tConfig.Delete(\"current\", \"server\")\n\tConfig.Delete(\"current\", \"userid\")\n\n\tserver, token, session, cookie, err := Login(server, username, password)\n\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\tConfig.Save(\"current\", \"username\", username)\n\tConfig.Save(\"current\", \"session\", session)\n\tConfig.Save(\"current\", \"cookie\", cookie)\n\tConfig.Save(\"current\", \"token\", token)\n\tConfig.Save(\"current\", \"server\", server)\n\tConfig.Save(\"current\", \"userid\", username)\n\n\treturn\n}\n\nfunc runLogin(cmd *Command, args []string) ", "output": "{\n\tvar server, username, password string\n\n\tif len(args) == 3 {\n\t\tserver = args[0]\n\t\tusername = args[1]\n\t\tpassword = args[2]\n\t} else {\n\t\tin := bufio.NewReader(os.Stdin)\n\t\tfmt.Print(\"Server: \")\n\n\t\tserver, _ = in.ReadString('\\n')\n\n\t\tfmt.Print(\"User: \")\n\t\tusername, _ = in.ReadString('\\n')\n\n\t\tfmt.Print(\"Password: \")\n\t\tpassword, _ = in.ReadString('\\n')\n\t}\n\n    fmt.Println(\"connecting to \" + server + \" as \" + username)\n\n\n\terr := LoginAndSave(server, username, password)\n\tfmt.Print(\"login and save complete\")\n\tif err != nil {\n\t\tErrorAndExit(err.Error())\n\t}\n\tfmt.Println(\"Login Successful\")\n}"}
{"input": "package syscall\n\nimport (\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"google.golang.org/grpc/grpclog\"\n)\n\nvar once sync.Once\n\nfunc log() {\n\tonce.Do(func() {\n\t\tgrpclog.Info(\"CPU time info is unavailable on non-linux or appengine environment.\")\n\t})\n}\n\n\n\n\n\n\ntype Rusage struct{}\n\n\nfunc GetRusage() (rusage *Rusage) {\n\tlog()\n\treturn nil\n}\n\n\n\nfunc CPUTimeDiff(first *Rusage, latest *Rusage) (float64, float64) {\n\tlog()\n\treturn 0, 0\n}\n\n\nfunc SetTCPUserTimeout(conn net.Conn, timeout time.Duration) error {\n\tlog()\n\treturn nil\n}\n\n\n\nfunc GetTCPUserTimeout(conn net.Conn) (int, error) {\n\tlog()\n\treturn -1, nil\n}\n\nfunc GetCPUTime() int64 ", "output": "{\n\tlog()\n\treturn 0\n}"}
{"input": "package hellomessage\n\nimport \"myitcv.io/react\"\n\ntype HelloMessageElem struct {\n\treact.Element\n}\n\nfunc (h *HelloMessageElem) RendersDiv(*react.DivElem) {}\n\nfunc (h *HelloMessageElem) noop() {\n\tvar v HelloMessageDef\n\tr := v.Render()\n\n\tv.RendersDiv(r)\n}\n\n\n\nfunc buildHelloMessageElem(props HelloMessageProps, children ...react.Element) *HelloMessageElem {\n\treturn &HelloMessageElem{\n\t\tElement: react.CreateElement(buildHelloMessage, props, children...),\n\t}\n}\n\nfunc (h HelloMessageDef) RendersElement() react.Element {\n\treturn h.Render()\n}\n\n\n\nfunc (h HelloMessageProps) IsProps() {}\n\n\nfunc (h HelloMessageDef) Props() HelloMessageProps {\n\tuprops := h.ComponentDef.Props()\n\treturn uprops.(HelloMessageProps)\n}\n\nfunc (h HelloMessageProps) EqualsIntf(val react.Props) bool {\n\treturn h == val.(HelloMessageProps)\n}\n\nvar _ react.Props = HelloMessageProps{}\n\nfunc buildHelloMessage(cd react.ComponentDef) react.Component ", "output": "{\n\treturn HelloMessageDef{ComponentDef: cd}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\n\n\nfunc main() {\n\thttp.HandleFunc(\"/\", HelloServer)\n\terr := http.ListenAndServe(\"localhost:8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe: \", err.Error())\n\t}\n}\n\nfunc HelloServer(w http.ResponseWriter, req *http.Request) ", "output": "{\n\tfmt.Println(\"Inside HelloServer handler\")\n\tfmt.Fprintf(w, \"Hello,\"+req.URL.Path[1:])\n}"}
{"input": "package terraform\n\nimport (\n\t\"github.com/hashicorp/terraform/config/module\"\n)\n\n\n\n\ntype ImportGraphBuilder struct {\n\tImportTargets []*ImportTarget\n\n\tModule *module.Tree\n\n\tProviders []string\n}\n\n\n\n\n\n\nfunc (b *ImportGraphBuilder) Steps() []GraphTransformer {\n\tmod := b.Module\n\tif mod == nil {\n\t\tmod = module.NewEmptyTree()\n\t}\n\n\tproviderFactory := func(name string, path []string) GraphNodeProvider {\n\t\treturn &NodeApplyableProvider{\n\t\t\tNameValue: name,\n\t\t\tPathValue: path,\n\t\t}\n\t}\n\n\tsteps := []GraphTransformer{\n\t\t&ConfigTransformerOld{Module: mod},\n\n\t\t&ImportStateTransformer{Targets: b.ImportTargets},\n\n\t\t&MissingProviderTransformer{Providers: b.Providers, Factory: providerFactory},\n\t\t&ProviderTransformer{},\n\t\t&DisableProviderTransformerOld{},\n\t\t&PruneProviderTransformer{},\n\t\t&AttachProviderConfigTransformer{Module: mod},\n\n\t\t&ImportProviderValidateTransformer{},\n\n\t\t&RootTransformer{},\n\n\t\t&TransitiveReductionTransformer{},\n\t}\n\n\treturn steps\n}\n\nfunc (b *ImportGraphBuilder) Build(path []string) (*Graph, error) ", "output": "{\n\treturn (&BasicGraphBuilder{\n\t\tSteps:    b.Steps(),\n\t\tValidate: true,\n\t\tName:     \"ImportGraphBuilder\",\n\t}).Build(path)\n}"}
{"input": "package aws\n\nimport \"container/list\"\n\ntype Handlers struct {\n\tValidate         HandlerList\n\tBuild            HandlerList\n\tSign             HandlerList\n\tSend             HandlerList\n\tValidateResponse HandlerList\n\tUnmarshal        HandlerList\n\tUnmarshalMeta    HandlerList\n\tUnmarshalError   HandlerList\n\tRetry            HandlerList\n\tAfterRetry       HandlerList\n}\n\nfunc (h *Handlers) copy() Handlers {\n\treturn Handlers{\n\t\tValidate:         h.Validate.copy(),\n\t\tBuild:            h.Build.copy(),\n\t\tSign:             h.Sign.copy(),\n\t\tSend:             h.Send.copy(),\n\t\tValidateResponse: h.ValidateResponse.copy(),\n\t\tUnmarshal:        h.Unmarshal.copy(),\n\t\tUnmarshalError:   h.UnmarshalError.copy(),\n\t\tUnmarshalMeta:    h.UnmarshalMeta.copy(),\n\t\tRetry:            h.Retry.copy(),\n\t\tAfterRetry:       h.AfterRetry.copy(),\n\t}\n}\n\n\nfunc (h *Handlers) Clear() {\n\th.Validate.Init()\n\th.Build.Init()\n\th.Send.Init()\n\th.Sign.Init()\n\th.Unmarshal.Init()\n\th.UnmarshalMeta.Init()\n\th.UnmarshalError.Init()\n\th.ValidateResponse.Init()\n\th.Retry.Init()\n\th.AfterRetry.Init()\n}\n\ntype HandlerList struct {\n\tlist.List\n}\n\nfunc (l HandlerList) copy() HandlerList {\n\tvar n HandlerList\n\tfor e := l.Front(); e != nil; e = e.Next() {\n\t\th := e.Value.(func(*Request))\n\t\tn.PushBack(h)\n\t}\n\treturn n\n}\n\n\n\nfunc (l *HandlerList) Run(r *Request) ", "output": "{\n\tfor e := l.Front(); e != nil; e = e.Next() {\n\t\th := e.Value.(func(*Request))\n\t\th(r)\n\t}\n}"}
{"input": "package mparser\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"path/filepath\"\n\n\t\"github.com/gomarkdown/markdown/ast\"\n\t\"github.com/gomarkdown/markdown/parser\"\n)\n\nvar UnsafeInclude parser.Flags = 1 << 3\n\n\n\n\n\n\n\n\n\n\n\nfunc (i Initial) ReadInclude(from, file string, address []byte) []byte {\n\tpath := i.path(from, file)\n\n\tif i.Flags&UnsafeInclude == 0 {\n\t\tif ok := i.pathAllowed(path); !ok {\n\t\t\tlog.Printf(\"Failure to read: %q: path is not on or below %q\", path, i.i)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tlog.Printf(\"Failure to read: %q (from %q)\", err, filepath.Join(from, \"*\"))\n\t\treturn nil\n\t}\n\n\tdata, err = parseAddress(address, data)\n\tif err != nil {\n\t\tlog.Printf(\"Failure to parse address for %q: %q (from %q)\", path, err, filepath.Join(from, \"*\"))\n\t\treturn nil\n\t}\n\tif len(data) == 0 {\n\t\treturn data\n\t}\n\tif data[len(data)-1] != '\\n' {\n\t\tdata = append(data, '\\n')\n\t}\n\treturn data\n}\n\nfunc Hook(data []byte) (ast.Node, []byte, int) ", "output": "{\n\tn, b, i := TitleHook(data)\n\tif n != nil {\n\t\treturn n, b, i\n\t}\n\n\treturn ReferenceHook(data)\n}"}
{"input": "package strategy_test\n\nimport (\n\t\"testing\"\n\n\t\"zntr.io/typogenerator/strategy\"\n)\n\n\n\nfunc TestTransposition(t *testing.T) ", "output": "{\n\tout, err := strategy.Transposition.Generate(\"zemithar\", \"\")\n\tif err != nil {\n\t\tt.Fail()\n\t\tt.Fatal(\"Error should not occurs !\", err)\n\t}\n\n\tif len(out) == 0 {\n\t\tt.FailNow()\n\t}\n\n\tif len(out) != 7 {\n\t\tt.FailNow()\n\t}\n}"}
{"input": "package depsync\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\n\t\"github.com/go-kit/kit/endpoint\"\n)\n\nfunc (s *DEPSyncService) SyncNow(_ context.Context) error {\n\ts.syncer.SyncNow()\n\treturn nil\n}\n\ntype syncNowResponse struct{}\ntype syncNowRequest struct{}\n\nfunc MakeSyncNowEndpoint(s Service) endpoint.Endpoint {\n\treturn func(ctx context.Context, _ interface{}) (interface{}, error) {\n\t\ts.SyncNow(ctx)\n\t\treturn syncNowResponse{}, nil\n\t}\n}\n\nfunc decodeEmptyRequest(ctx context.Context, r *http.Request) (interface{}, error) {\n\treturn nil, nil\n}\n\nfunc encodeEmptyResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {\n\treturn nil\n}\n\n\n\nfunc (e Endpoints) SyncNow(ctx context.Context) error {\n\t_, err := e.SyncNowEndpoint(ctx, nil)\n\treturn err\n}\n\nfunc decodeEmptyResponse(ctx context.Context, r *http.Response) (interface{}, error) ", "output": "{\n\treturn nil, nil\n}"}
{"input": "package condition\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/arl/evolve\"\n)\n\n\n\ntype TargetFitness struct {\n\tFitness float64\n\tNatural bool\n}\n\n\n\n\n\n\nfunc (tf TargetFitness) String() string {\n\treturn fmt.Sprintf(\"Reached target fitness of %f\", tf.Fitness)\n}\n\nfunc (tf TargetFitness) IsSatisfied(stats *evolve.PopulationStats) bool ", "output": "{\n\tif tf.Natural {\n\t\treturn stats.BestFitness >= tf.Fitness\n\t}\n\treturn stats.BestFitness <= tf.Fitness\n}"}
{"input": "package tpl\n\nimport (\n\t\"html/template\"\n\t\"sync\"\n)\n\n\n\n\n\n\ntype cachingContext struct {\n\tbaseDir string\n\tmut   *sync.Mutex\n\tcache map[filesMapKey]*template.Template\n\tfuncs template.FuncMap\n}\n\nfunc (c *cachingContext) Prepare(tplFiles Files) (*template.Template, error) {\n\tc.mut.Lock()\n\tdefer c.mut.Unlock()\n\tmk := tplFiles.mapKey()\n\ttpl, ok := c.cache[mk]\n\tif !ok {\n\t\tabsPaths := tplFiles.absPaths(c.baseDir)\n\t\tt, err := template.New(tplFiles.First()).Funcs(c.funcs).ParseFiles(absPaths...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttpl = t\n\t}\n\treturn tpl, nil\n}\n\nfunc NewCachingContext(baseDir string, funcs template.FuncMap) Context ", "output": "{\n\treturn &cachingContext{\n\t\tbaseDir: baseDir,\n\t\tmut:     new(sync.Mutex),\n\t\tcache:   make(map[filesMapKey]*template.Template),\n\t\tfuncs:   funcs,\n\t}\n}"}
{"input": "package endpoint\n\n\n\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-openapi/runtime\"\n\n\t\"github.com/cilium/cilium/api/v1/models\"\n)\n\n\nconst GetEndpointOKCode int = 200\n\n\ntype GetEndpointOK struct {\n\n\tPayload []*models.Endpoint `json:\"body,omitempty\"`\n}\n\n\n\n\n\nfunc (o *GetEndpointOK) WithPayload(payload []*models.Endpoint) *GetEndpointOK {\n\to.Payload = payload\n\treturn o\n}\n\n\nfunc (o *GetEndpointOK) SetPayload(payload []*models.Endpoint) {\n\to.Payload = payload\n}\n\n\nfunc (o *GetEndpointOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {\n\n\trw.WriteHeader(200)\n\tpayload := o.Payload\n\tif payload == nil {\n\t\tpayload = make([]*models.Endpoint, 0, 50)\n\t}\n\n\tif err := producer.Produce(rw, payload); err != nil {\n\t\tpanic(err) \n\t}\n}\n\n\nconst GetEndpointNotFoundCode int = 404\n\n\ntype GetEndpointNotFound struct {\n}\n\n\nfunc NewGetEndpointNotFound() *GetEndpointNotFound {\n\n\treturn &GetEndpointNotFound{}\n}\n\n\nfunc (o *GetEndpointNotFound) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {\n\n\trw.Header().Del(runtime.HeaderContentType) \n\n\trw.WriteHeader(404)\n}\n\nfunc NewGetEndpointOK() *GetEndpointOK ", "output": "{\n\n\treturn &GetEndpointOK{}\n}"}
{"input": "package tests\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestSetWorkingDir(t *testing.T) ", "output": "{\n\tworkingDir := setUpTest(t)\n\tdefer cleanUpTest(workingDir)\n\n\tconst wd = \"/root\"\n\n\terr := runACBuildNoHist(workingDir, \"set-working-dir\", wd)\n\tif err != nil {\n\t\tt.Fatalf(\"%v\\n\", err)\n\t}\n\tman := emptyManifestWithApp()\n\tman.App.WorkingDirectory = wd\n\n\tcheckManifest(t, workingDir, man)\n\tcheckEmptyRootfs(t, workingDir)\n}"}
{"input": "package resource\n\nimport (\n\t\"github.com/gbl08ma/sqalx\"\n\t\"github.com/yarf-framework/yarf\"\n)\n\n\ntype AuthTest struct {\n\tresource\n}\n\n\nfunc (r *AuthTest) WithNode(node sqalx.Node) *AuthTest {\n\tr.node = node\n\treturn r\n}\n\n\n\n\n\nfunc (r *AuthTest) Get(c *yarf.Context) error {\n\tpair, err := r.AuthenticateClient(c)\n\tif err != nil {\n\t\tRenderUnauthorized(c)\n\t\treturn nil\n\t}\n\n\tRenderData(c, struct {\n\t\tResult string `msgpack:\"result\" json:\"result\"`\n\t\tKey    string `msgpack:\"key\" json:\"key\"`\n\t}{\n\t\tResult: \"ok\",\n\t\tKey:    pair.Key,\n\t}, \"no-cache, no-store, must-revalidate\")\n\treturn nil\n}\n\nfunc (r *AuthTest) WithHashKey(key []byte) *AuthTest ", "output": "{\n\tr.hashKey = key\n\treturn r\n}"}
{"input": "package l3plugin\n\nimport (\n\t\"go.ligato.io/cn-infra/v2/config\"\n\t\"go.ligato.io/cn-infra/v2/logging\"\n\n\t\"go.ligato.io/vpp-agent/v3/plugins/kvscheduler\"\n\t\"go.ligato.io/vpp-agent/v3/plugins/linux/ifplugin\"\n\t\"go.ligato.io/vpp-agent/v3/plugins/linux/nsplugin\"\n\t\"go.ligato.io/vpp-agent/v3/plugins/netalloc\"\n)\n\n\nvar DefaultPlugin = *NewPlugin()\n\n\nfunc NewPlugin(opts ...Option) *L3Plugin {\n\tp := &L3Plugin{}\n\n\tp.PluginName = \"linux-l3plugin\"\n\tp.KVScheduler = &kvscheduler.DefaultPlugin\n\tp.NsPlugin = &nsplugin.DefaultPlugin\n\tp.AddrAlloc = &netalloc.DefaultPlugin\n\tp.IfPlugin = &ifplugin.DefaultPlugin\n\n\tfor _, o := range opts {\n\t\to(p)\n\t}\n\n\tif p.Log == nil {\n\t\tp.Log = logging.ForPlugin(p.String())\n\t}\n\tif p.Cfg == nil {\n\t\tp.Cfg = config.ForPlugin(p.String(),\n\t\t\tconfig.WithCustomizedFlag(config.FlagName(p.String()), \"linux-l3plugin.conf\"),\n\t\t)\n\t}\n\n\treturn p\n}\n\n\ntype Option func(*L3Plugin)\n\n\n\n\nfunc UseDeps(f func(*Deps)) Option ", "output": "{\n\treturn func(p *L3Plugin) {\n\t\tf(&p.Deps)\n\t}\n}"}
{"input": "package google\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/net/context\"\n\t\"golang.org/x/oauth2\"\n)\n\n\nvar appengineTokenFunc func(c context.Context, scopes ...string) (token string, expiry time.Time, err error)\n\n\n\n\n\n\n\nfunc AppEngineTokenSource(ctx context.Context, scope ...string) oauth2.TokenSource {\n\tif appengineTokenFunc == nil {\n\t\tpanic(\"google: AppEngineTokenSource can only be used on App Engine.\")\n\t}\n\tscopes := append([]string{}, scope...)\n\tsort.Strings(scopes)\n\treturn &appEngineTokenSource{\n\t\tctx:    ctx,\n\t\tscopes: scopes,\n\t\tkey:    strings.Join(scopes, \" \"),\n\t}\n}\n\n\nvar (\n\taeTokensMu sync.Mutex\n\taeTokens   = make(map[string]*tokenLock) \n)\n\ntype tokenLock struct {\n\tmu sync.Mutex \n\tt  *oauth2.Token\n}\n\ntype appEngineTokenSource struct {\n\tctx    context.Context\n\tscopes []string\n\tkey    string \n}\n\n\n\nfunc (ts *appEngineTokenSource) Token() (*oauth2.Token, error) ", "output": "{\n\tif appengineTokenFunc == nil {\n\t\tpanic(\"google: AppEngineTokenSource can only be used on App Engine.\")\n\t}\n\n\taeTokensMu.Lock()\n\ttok, ok := aeTokens[ts.key]\n\tif !ok {\n\t\ttok = &tokenLock{}\n\t\taeTokens[ts.key] = tok\n\t}\n\taeTokensMu.Unlock()\n\n\ttok.mu.Lock()\n\tdefer tok.mu.Unlock()\n\tif tok.t.Valid() {\n\t\treturn tok.t, nil\n\t}\n\taccess, exp, err := appengineTokenFunc(ts.ctx, ts.scopes...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttok.t = &oauth2.Token{\n\t\tAccessToken: access,\n\t\tExpiry:      exp,\n\t}\n\treturn tok.t, nil\n}"}
{"input": "package externalversions\n\nimport (\n\t\"fmt\"\n\tv1 \"k8s.io/apiextensions-apiserver/examples/client-go/pkg/apis/cr/v1\"\n\tschema \"k8s.io/apimachinery/pkg/runtime/schema\"\n\tcache \"k8s.io/client-go/tools/cache\"\n)\n\n\n\ntype GenericInformer interface {\n\tInformer() cache.SharedIndexInformer\n\tLister() cache.GenericLister\n}\n\ntype genericInformer struct {\n\tinformer cache.SharedIndexInformer\n\tresource schema.GroupResource\n}\n\n\n\n\n\nfunc (f *genericInformer) Lister() cache.GenericLister {\n\treturn cache.NewGenericLister(f.Informer().GetIndexer(), f.resource)\n}\n\n\n\nfunc (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) {\n\tswitch resource {\n\tcase v1.SchemeGroupVersion.WithResource(\"examples\"):\n\t\treturn &genericInformer{resource: resource.GroupResource(), informer: f.Cr().V1().Examples().Informer()}, nil\n\n\t}\n\n\treturn nil, fmt.Errorf(\"no informer found for %v\", resource)\n}\n\nfunc (f *genericInformer) Informer() cache.SharedIndexInformer ", "output": "{\n\treturn f.informer\n}"}
{"input": "package passwordreset\n\ntype PasswordReset struct {\n\tID        string\n\tReference string\n\tPartnerID string\n}\n\n\n\nfunc New(id string, reference string, partnerid string) *PasswordReset ", "output": "{\n\treturn &PasswordReset{\n\t\tID:        id,\n\t\tReference: reference,\n\t\tPartnerID: partnerid,\n\t}\n}"}
{"input": "package binance\n\nimport (\n\t\"time\"\n)\n\n\n\nfunc recvWindow(d time.Duration) int64 {\n\treturn int64(d) / int64(time.Millisecond)\n}\n\nfunc unixMillis(t time.Time) int64 ", "output": "{\n\treturn t.UnixNano() / int64(time.Millisecond)\n}"}
{"input": "package returns\n\nimport (\n\t\"go/ast\"\n\t\"go/types\"\n)\n\n\n\n\n\nfunc funcHasSingleReturnVal(typeInfo *types.Info, e *ast.CallExpr) bool ", "output": "{\n\tif id, ok := e.Fun.(*ast.Ident); ok && id.Obj != nil {\n\t\tif fn, ok := id.Obj.Decl.(*ast.FuncDecl); ok {\n\t\t\treturn len(fn.Type.Results.List) == 1\n\t\t}\n\t}\n\n\tif typeInfo != nil {\n\t\ttyp := typeInfo.TypeOf(e)\n\t\tif _, ok := typ.(*types.Tuple); ok {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\treturn false\n}"}
{"input": "package volumeserver\n\nimport (\n\t\"code.cloudfoundry.org/lager\"\n\t\"github.com/concourse/concourse/atc/db\"\n\t\"github.com/concourse/concourse/atc/gc\"\n)\n\ntype Server struct {\n\tlogger     lager.Logger\n\trepository db.VolumeRepository\n\tdestroyer  gc.Destroyer\n}\n\n\n\nfunc NewServer(\n\tlogger lager.Logger,\n\tvolumeRepository db.VolumeRepository,\n\tdestroyer gc.Destroyer,\n) *Server ", "output": "{\n\treturn &Server{\n\t\tlogger:     logger,\n\t\trepository: volumeRepository,\n\t\tdestroyer:  destroyer,\n\t}\n}"}
{"input": "package image\n\nimport (\n\t\"sort\"\n\n\t\"github.com/Symantec/Dominator/lib/verstr\"\n)\n\ntype directoryList []Directory\n\nfunc (list directoryList) Len() int {\n\treturn len(list)\n}\n\nfunc (list directoryList) Less(i, j int) bool {\n\treturn verstr.Less(list[i].Name, list[j].Name)\n}\n\n\n\nfunc sortDirectories(directories []Directory) {\n\tsort.Sort(directoryList(directories))\n}\n\nfunc (list directoryList) Swap(i, j int) ", "output": "{\n\tlist[i], list[j] = list[j], list[i]\n}"}
{"input": "package goparser\n\nimport (\n\t\"go/ast\"\n\t\"testing\"\n)\n\nfunc testCmtAgainstExpt(t *testing.T, text, expected string) {\n\tcmt := ast.Comment{\n\t\tText: text,\n\t}\n\n\tresult := CmtToStr(&cmt)\n\n\tif expected != result {\n\t\tt.Errorf(\"Result doesn't match expectation\")\n\t\tt.Errorf(\"Expected:\\n%s\", expected)\n\t\tt.Errorf(\"Get:\\n%s\", result)\n\t}\n}\n\n\nfunc TestCmtToStr1(t *testing.T) {\n\ttestCmtAgainstExpt(t,\n\t\t\"//\\n\"+\n\t\t\t\" // testing line 1\\n\"+\n\t\t\t\"//testing line 2\\n\"+\n\t\t\t\"// testing line 3\",\n\t\t\"testing line 1\\n\"+\n\t\t\t\"testing line 2\\n\"+\n\t\t\t\"testing line 3\\n\")\n}\n\n\nfunc TestCmtToStr2(t *testing.T) {\n\ttestCmtAgainstExpt(t,\n\t\t\"/**\\n\"+\n\t\t\t\" * testing line 1\\n\"+\n\t\t\t\"* testing line 2\\n\"+\n\t\t\t\" * testing line 3\\n\"+\n\t\t\t\" */\",\n\t\t\" testing line 1\\n\"+\n\t\t\t\" testing line 2\\n\"+\n\t\t\t\" testing line 3\\n\")\n}\n\n\n\n\nfunc TestCmtToStr3(t *testing.T) ", "output": "{\n\ttestCmtAgainstExpt(t,\n\t\t\"/*\\n\"+\n\t\t\t\" testing line 1\\n\"+\n\t\t\t\" testing line 2\\n\"+\n\t\t\t\"  testing line 3\\n\"+\n\t\t\t\"*/\",\n\t\t\" testing line 1\\n\"+\n\t\t\t\" testing line 2\\n\"+\n\t\t\t\"  testing line 3\\n\")\n}"}
{"input": "package spi\n\n\nfunc NewGroup(group *GroupInfo) Group {\n\treturn group\n}\n\n\nfunc (g *GroupInfo) GetName() string {\n\treturn g.Name\n}\n\n\nfunc (g *GroupInfo) GetChildren() ([]Group, error) {\n\treturn nil, nil\n}\n\n\n\n\nfunc (g *GroupInfo) GetParent() string ", "output": "{\n\treturn g.ParentID\n}"}
{"input": "package stack\n\nimport (\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/filters\"\n\t\"github.com/docker/docker/api/types/swarm\"\n\t\"github.com/docker/docker/cli/compose/convert\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/docker/opts\"\n)\n\nfunc getStackFilter(namespace string) filters.Args {\n\tfilter := filters.NewArgs()\n\tfilter.Add(\"label\", convert.LabelNamespace+\"=\"+namespace)\n\treturn filter\n}\n\nfunc getStackFilterFromOpt(namespace string, opt opts.FilterOpt) filters.Args {\n\tfilter := opt.Value()\n\tfilter.Add(\"label\", convert.LabelNamespace+\"=\"+namespace)\n\treturn filter\n}\n\n\n\nfunc getServices(\n\tctx context.Context,\n\tapiclient client.APIClient,\n\tnamespace string,\n) ([]swarm.Service, error) {\n\treturn apiclient.ServiceList(\n\t\tctx,\n\t\ttypes.ServiceListOptions{Filters: getStackFilter(namespace)})\n}\n\nfunc getStackNetworks(\n\tctx context.Context,\n\tapiclient client.APIClient,\n\tnamespace string,\n) ([]types.NetworkResource, error) {\n\treturn apiclient.NetworkList(\n\t\tctx,\n\t\ttypes.NetworkListOptions{Filters: getStackFilter(namespace)})\n}\n\nfunc getAllStacksFilter() filters.Args ", "output": "{\n\tfilter := filters.NewArgs()\n\tfilter.Add(\"label\", convert.LabelNamespace)\n\treturn filter\n}"}
{"input": "package oauth2Utils\n\nvar predefinedOauthClients_ByClientId = map[string]*OAuth2Client_NonDb{}\nvar predefinedOauthClients_ById = map[int64]*OAuth2Client_NonDb{}\n\ntype OAuth2Client_NonDb struct {\n\tId                int64 \n\tClientId          string\n\tClientSecret      string\n\tRedirectUri       string\n\tClientDisplayName string\n\n}\n\nfunc GetClientUsingClientId(clientId string) (*OAuth2Client_NonDb, bool) {\n\tif client, ok := predefinedOauthClients_ByClientId[clientId]; ok {\n\t\treturn client, true\n\t} else {\n\t\treturn nil, false\n\t}\n}\n\n\n\nvar tmpIdIncrement int64 = 1\n\nfunc AddPredefinedOAuthClient(client *OAuth2Client_NonDb) {\n\tclient.Id = tmpIdIncrement\n\tpredefinedOauthClients_ByClientId[client.ClientId] = client\n\tpredefinedOauthClients_ById[client.Id] = client\n\ttmpIdIncrement++\n}\n\nfunc GetClientUsingId(id int64) (*OAuth2Client_NonDb, bool) ", "output": "{\n\tif client, ok := predefinedOauthClients_ById[id]; ok {\n\t\treturn client, true\n\t} else {\n\t\treturn nil, false\n\t}\n}"}
{"input": "package yaml\n\nimport (\n\t\"github.com/pinpt/dialect/pkg\"\n\t\"github.com/pinpt/dialect/pkg/types\"\n)\n\ntype YAMLExaminer struct {\n}\n\nfunc (e *YAMLExaminer) Examine(language string, filename string, line *types.DialectLine) error {\n\tpkg.SingleSymbolProcessor(\"#\", line)\n\treturn nil\n}\n\nfunc (e *YAMLExaminer) NewExaminer() types.DialectExaminer {\n\tex := new(YAMLExaminer)\n\treturn ex\n}\n\n\n\nfunc init() ", "output": "{\n\ttypes.RegisterExaminer(\"YAML\", &YAMLExaminer{})\n}"}
{"input": "package console\n\nimport (\n\tv1 \"github.com/cgrates/cgrates/apier/v1\"\n\t\"github.com/cgrates/cgrates/engine\"\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\nfunc init() {\n\tc := &CmdSetDispatcherProfile{\n\t\tname:      \"dispatchers_profile_set\",\n\t\trpcMethod: utils.APIerSv1SetDispatcherProfile,\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}\n\n\ntype CmdSetDispatcherProfile struct {\n\tname      string\n\trpcMethod string\n\trpcParams *v1.DispatcherWithCache\n\t*CommandExecuter\n}\n\nfunc (self *CmdSetDispatcherProfile) Name() string {\n\treturn self.name\n}\n\nfunc (self *CmdSetDispatcherProfile) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\nfunc (self *CmdSetDispatcherProfile) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &v1.DispatcherWithCache{\n\t\t\tDispatcherProfile: new(engine.DispatcherProfile),\n\t\t\tOpts:              make(map[string]interface{}),\n\t\t}\n\t}\n\treturn self.rpcParams\n}\n\n\n\nfunc (self *CmdSetDispatcherProfile) RpcResult() interface{} {\n\tvar s string\n\treturn &s\n}\n\nfunc (self *CmdSetDispatcherProfile) PostprocessRpcParams() error ", "output": "{\n\treturn nil\n}"}
{"input": "package backend\n\nimport (\n\t\"net/http\"\n)\n\nconst (\n\tCONSENT_SAMPLE_PATH = \"/\" + CATEGORY_SAMPLE_TEMPLATES + \"/consent/\"\n)\n\n\n\nfunc submitConsentXHR(w http.ResponseWriter, r *http.Request) {\n\tSendJsonResponse(w, map[string]bool{\n\t\t\"promptIfUnknown\": true,\n\t})\n}\n\nfunc InitAmpConsent() ", "output": "{\n\tRegisterHandler(CONSENT_SAMPLE_PATH+\"getConsent\", onlyPost(submitConsentXHR))\n}"}
{"input": "package alert\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/opsgenie/opsgenie-go-sdk-v2/client\"\n\t\"github.com/pkg/errors\"\n)\n\ntype DeleteAttachmentRequest struct {\n\tclient.BaseRequest\n\tIdentifierType  AlertIdentifier\n\tIdentifierValue string\n\tAttachmentId    string\n\tUser            string\n}\n\nfunc (r *DeleteAttachmentRequest) Validate() error {\n\tif r.AttachmentId == \"\" {\n\t\treturn errors.New(\"AttachmentId can not be empty\")\n\t}\n\n\tif r.IdentifierValue == \"\" {\n\t\treturn errors.New(\"Identifier can not be empty\")\n\t}\n\treturn nil\n}\n\n\n\nfunc (r *DeleteAttachmentRequest) Method() string {\n\treturn http.MethodDelete\n}\n\nfunc (r *DeleteAttachmentRequest) RequestParams() map[string]string {\n\n\tparams := make(map[string]string)\n\n\tif r.IdentifierType == ALIAS {\n\t\tparams[\"alertIdentifierType\"] = \"alias\"\n\n\t} else if r.IdentifierType == TINYID {\n\t\tparams[\"alertIdentifierType\"] = \"tiny\"\n\n\t} else {\n\t\tparams[\"alertIdentifierType\"] = \"id\"\n\n\t}\n\n\tif r.User != \"\" {\n\t\tparams[\"user\"] = r.User\n\t}\n\n\treturn params\n}\n\nfunc (r *DeleteAttachmentRequest) ResourcePath() string ", "output": "{\n\n\treturn \"/v2/alerts/\" + r.IdentifierValue + \"/attachments/\" + r.AttachmentId\n}"}
{"input": "package engine\n\nimport (\n\t\"github.com/stretchr/testify/require\"\n\t\"testing\"\n)\n\nfunc TestEngineChef(t *testing.T) {\n\teng := new(engineChef)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}\n\nfunc TestEngineGeneric(t *testing.T) {\n\teng := new(engineGeneric)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}\n\n\n\nfunc TestEngineNode(t *testing.T) {\n\teng := new(engineNode)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}\n\nfunc TestEnginePython(t *testing.T) {\n\teng := new(enginePython)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}\n\nfunc TestEngineRuby(t *testing.T) {\n\teng := new(engineRuby)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}\n\nfunc TestEngineGolang(t *testing.T) ", "output": "{\n\teng := new(engineGolang)\n\trequire.Implements(t, (*Interface)(nil), eng, \"should implement the Engine interface\")\n}"}
{"input": "package mediaservices\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tAPIVersion = \"2015-10-01\"\n\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype ManagementClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tAPIVersion     string\n\tSubscriptionID string\n}\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) ManagementClient {\n\treturn ManagementClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tAPIVersion:     APIVersion,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}\n\nfunc New(subscriptionID string) ManagementClient ", "output": "{\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}"}
{"input": "package data\n\nimport (\n\t\"crypto/sha1\"\n\t\"fmt\"\n\t\"io\"\n)\n\n\ntype Fortune struct {\n\tID   string `json:\"id\"`\n\tData string `json:\"data\"`\n}\n\n\nfunc NewFortune(data string) Fortune {\n\treturn Fortune{ID: ComputeID(data), Data: data}\n}\n\n\n\n\nfunc ComputeID(data string) string ", "output": "{\n\tsha := sha1.New()\n\tio.WriteString(sha, data)\n\tbytes := sha.Sum(nil)\n\tid := fmt.Sprintf(\"%x\", bytes)\n\treturn id[0:7]\n}"}
{"input": "package linux\n\nimport (\n\t\"golang.org/x/sys/unix\"\n\t\"syscall\"\n)\n\n\n\n\n\n\nfunc SetAffinity(cpus []int) error {\n\tvar cpuSet unix.CPUSet\n\tcpuSet.Zero()\n\tfor _, c := range cpus {\n\t\tcpuSet.Set(c)\n\t}\n\treturn unix.SchedSetaffinity(unix.Getpid(), &cpuSet)\n}\n\nfunc OSVersion() (osVersion string, err error) ", "output": "{\n\tvar un syscall.Utsname\n\terr = syscall.Uname(&un)\n\tif err != nil {\n\t\treturn\n\t}\n\tcharsToString := func(ca []int8) string {\n\t\ts := make([]byte, len(ca))\n\t\tvar lens int\n\t\tfor ; lens < len(ca); lens++ {\n\t\t\tif ca[lens] == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts[lens] = uint8(ca[lens])\n\t\t}\n\t\treturn string(s[0:lens])\n\t}\n\tosVersion = charsToString(un.Sysname[:]) + \" \" + charsToString(un.Release[:]) + \".\" + charsToString(un.Machine[:])\n\treturn\n}"}
{"input": "package uaa\n\nimport (\n\t\"sort\"\n\n\tbosherr \"github.com/cloudfoundry/bosh-utils/errors\"\n)\n\ntype Prompt struct {\n\tKey   string \n\tType  string \n\tLabel string \n}\n\ntype PromptAnswer struct {\n\tKey   string \n\tValue string\n}\n\nfunc (p Prompt) IsPassword() bool { return p.Type == \"password\" }\n\ntype PromptsResp struct {\n\tPrompts map[string][]string \n}\n\nfunc (u UAAImpl) Prompts() ([]Prompt, error) {\n\tresp, err := u.client.Prompts()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar prompts []Prompt\n\n\tfor key, pair := range resp.Prompts {\n\t\tprompts = append(prompts, Prompt{\n\t\t\tKey:   key,\n\t\t\tType:  pair[0],\n\t\t\tLabel: pair[1],\n\t\t})\n\t}\n\n\tsort.Sort(PromptSorting(prompts))\n\n\treturn prompts, nil\n}\n\nfunc (c Client) Prompts() (PromptsResp, error) {\n\tvar resp PromptsResp\n\n\terr := c.clientRequest.Get(\"/login\", &resp)\n\tif err != nil {\n\t\treturn resp, bosherr.WrapError(err, \"Requesting UAA prompts\")\n\t}\n\n\treturn resp, nil\n}\n\ntype PromptSorting []Prompt\n\nfunc (s PromptSorting) Len() int           { return len(s) }\n\nfunc (s PromptSorting) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\nfunc (s PromptSorting) Less(i, j int) bool ", "output": "{ return s[i].Type > s[j].Type }"}
{"input": "package mockhttputil\n\nimport (\n\tgomock \"github.com/golang/mock/gomock\"\n\thttp \"net/http\"\n\treflect \"reflect\"\n)\n\n\ntype MockRoundTripper struct {\n\tctrl     *gomock.Controller\n\trecorder *MockRoundTripperMockRecorder\n}\n\n\ntype MockRoundTripperMockRecorder struct {\n\tmock *MockRoundTripper\n}\n\n\nfunc NewMockRoundTripper(ctrl *gomock.Controller) *MockRoundTripper {\n\tmock := &MockRoundTripper{ctrl: ctrl}\n\tmock.recorder = &MockRoundTripperMockRecorder{mock}\n\treturn mock\n}\n\n\nfunc (m *MockRoundTripper) EXPECT() *MockRoundTripperMockRecorder {\n\treturn m.recorder\n}\n\n\n\n\n\nfunc (mr *MockRoundTripperMockRecorder) RoundTrip(arg0 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RoundTrip\", reflect.TypeOf((*MockRoundTripper)(nil).RoundTrip), arg0)\n}\n\nfunc (m *MockRoundTripper) RoundTrip(arg0 *http.Request) (*http.Response, error) ", "output": "{\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"RoundTrip\", arg0)\n\tret0, _ := ret[0].(*http.Response)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}"}
{"input": "package tempconv\n\nimport \"testing\"\n\nfunc TestCToF(t *testing.T) {\n\tvar c Celsius = 37\n\tf := CToF(c)\n\tif f != Fahrenheit(98.6) {\n\t\tt.Errorf(`CToF(%g) == %g failed`, c, f)\n\t}\n}\n\nfunc TestFToC(t *testing.T) {\n\tvar f Fahrenheit = 95\n\tc := FToC(f)\n\tif c != Celsius(35) {\n\t\tt.Errorf(`FToC(%g) == %g failed`, f, c)\n\t}\n}\n\nfunc TestCToK(t *testing.T) {\n\tvar c Celsius = 37\n\tk := CToK(c)\n\tif k != Kelvin(310.15) {\n\t\tt.Errorf(`CToK(%g) == %g failed`, c, k)\n\t}\n}\n\n\n\nfunc TestKToC(t *testing.T) ", "output": "{\n\tvar k Kelvin = 1000\n\tc := KToC(k)\n\tif c != Celsius(726.85) {\n\t\tt.Errorf(`KToC(%g) == %g failed`, k, c)\n\t}\n}"}
{"input": "package http2\n\nimport \"net/textproto\"\n\nfunc traceHasWroteHeaderField(trace *clientTrace) bool { return false }\n\nfunc traceWroteHeaderField(trace *clientTrace, k, v string) {}\n\n\n\nfunc traceGot1xxResponseFunc(trace *clientTrace) func(int, textproto.MIMEHeader) error ", "output": "{\n\treturn nil\n}"}
{"input": "package iso20022\n\n\ntype CardPaymentTransaction42 struct {\n\n\tSaleReferenceIdentification *Max35Text `xml:\"SaleRefId,omitempty\"`\n\n\tTransactionIdentification *TransactionIdentifier1 `xml:\"TxId\"`\n\n\tRecipientTransactionIdentification *Max35Text `xml:\"RcptTxId,omitempty\"`\n\n\tReconciliationIdentification *Max35Text `xml:\"RcncltnId,omitempty\"`\n\n\tInterchangeData *Max140Text `xml:\"IntrchngData,omitempty\"`\n\n\tTransactionDetails *CardPaymentTransactionDetails22 `xml:\"TxDtls\"`\n}\n\nfunc (c *CardPaymentTransaction42) SetSaleReferenceIdentification(value string) {\n\tc.SaleReferenceIdentification = (*Max35Text)(&value)\n}\n\nfunc (c *CardPaymentTransaction42) AddTransactionIdentification() *TransactionIdentifier1 {\n\tc.TransactionIdentification = new(TransactionIdentifier1)\n\treturn c.TransactionIdentification\n}\n\n\n\nfunc (c *CardPaymentTransaction42) SetReconciliationIdentification(value string) {\n\tc.ReconciliationIdentification = (*Max35Text)(&value)\n}\n\nfunc (c *CardPaymentTransaction42) SetInterchangeData(value string) {\n\tc.InterchangeData = (*Max140Text)(&value)\n}\n\nfunc (c *CardPaymentTransaction42) AddTransactionDetails() *CardPaymentTransactionDetails22 {\n\tc.TransactionDetails = new(CardPaymentTransactionDetails22)\n\treturn c.TransactionDetails\n}\n\nfunc (c *CardPaymentTransaction42) SetRecipientTransactionIdentification(value string) ", "output": "{\n\tc.RecipientTransactionIdentification = (*Max35Text)(&value)\n}"}
{"input": "package run\n\nimport (\n\t\"github.com/lesfurets/git-octopus/test\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n)\n\n\n\nfunc TestConflictState(t *testing.T) {\n\tcontext, _ := CreateTestContext()\n\trepo := context.Repo\n\tdefer test.Cleanup(repo)\n\n\twriteFile(repo, \"foo\", \"line 1\", \"\")\n\trepo.Git(\"add\", \".\")\n\trepo.Git(\"commit\", \"-m\", \"added foo\")\n\n\twriteFile(repo, \"foo\", \"line 1\", \"line 2\")\n\trepo.Git(\"commit\", \"-a\", \"-m\", \"edited foo\")\n\n\trepo.Git(\"checkout\", \"-b\", \"a_branch\", \"HEAD^\")\n\n\twriteFile(repo, \"foo\", \"line 1\", \"line 2 bis\")\n\trepo.Git(\"commit\", \"-a\", \"-m\", \"edited foo in parallel to master\")\n\n\trepo.Git(\"checkout\", \"master\")\n\texpected, _ := repo.Git(\"rev-parse\", \"HEAD\")\n\n\terr := Run(context, \"-n\", \"a_branch\")\n\n\tassert.NotNil(t, err)\n\tactual, _ := repo.Git(\"rev-parse\", \"HEAD\")\n\tassert.Equal(t, expected, actual)\n\n\tstatus, _ := repo.Git(\"status\", \"--porcelain\")\n\tassert.Empty(t, status)\n}\n\nfunc TestFastForward(t *testing.T) ", "output": "{\n\tcontext, _ := CreateTestContext()\n\trepo := context.Repo\n\tdefer test.Cleanup(repo)\n\n\trepo.Git(\"checkout\", \"-b\", \"new_branch\")\n\twriteFile(repo, \"foo\", \"bar\")\n\trepo.Git(\"add\", \"foo\")\n\trepo.Git(\"commit\", \"-m\", \"added foo\")\n\n\trepo.Git(\"checkout\", \"master\")\n\n\texpected, _ := repo.Git(\"rev-parse\", \"HEAD\")\n\n\tRun(context, \"-n\", \"new_branch\")\n\n\tactual, _ := repo.Git(\"rev-parse\", \"HEAD\")\n\tassert.Equal(t, expected, actual)\n\n\tstatus, _ := repo.Git(\"status\", \"--porcelain\")\n\tassert.Empty(t, status)\n}"}
{"input": "package dockerfile\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/docker/docker/pkg/system\"\n)\n\n\n\nfunc normaliseWorkdir(current string, requested string) (string, error) {\n\tif requested == \"\" {\n\t\treturn \"\", fmt.Errorf(\"cannot normalise nothing\")\n\t}\n\n\tcurrent = filepath.FromSlash(current)\n\trequested = filepath.FromSlash(requested)\n\n\tif len(current) == 0 || system.IsAbs(requested) {\n\t\tif (requested[0] == os.PathSeparator) ||\n\t\t\t(len(requested) > 1 && string(requested[1]) != \":\") ||\n\t\t\t(len(requested) == 1) {\n\t\t\trequested = filepath.Join(`C:\\`, requested)\n\t\t}\n\t} else {\n\t\trequested = filepath.Join(current, requested)\n\t}\n\treturn (strings.ToUpper(string(requested[0])) + requested[1:]), nil\n}\n\n\n\nfunc errNotJSON(command, original string) error ", "output": "{\n\textra := \"\"\n\toriginal = filepath.FromSlash(strings.ToLower(strings.Replace(strings.ToLower(original), strings.ToLower(command)+\" \", \"\", -1)))\n\tif len(regexp.MustCompile(`\"[a-z]:\\\\.*`).FindStringSubmatch(original)) > 0 &&\n\t\t!strings.Contains(original, `\\\\`) &&\n\t\tstrings.Contains(original, \"[\") &&\n\t\tstrings.Contains(original, \"]\") {\n\t\textra = fmt.Sprintf(`. It looks like '%s' includes a file path without an escaped back-slash. JSON requires back-slashes to be escaped such as [\"c:\\\\path\\\\to\\\\file.exe\", \"/parameter\"]`, original)\n\t}\n\treturn fmt.Errorf(\"%s requires the arguments to be in JSON form%s\", command, extra)\n}"}
{"input": "package parser\n\nimport (\n\t\"github.com/dop251/goja/ast\"\n)\n\ntype _scope struct {\n\touter           *_scope\n\tallowIn         bool\n\tinIteration     bool\n\tinSwitch        bool\n\tinFunction      bool\n\tdeclarationList []ast.Declaration\n\n\tlabels []string\n}\n\nfunc (self *_parser) openScope() {\n\tself.scope = &_scope{\n\t\touter:   self.scope,\n\t\tallowIn: true,\n\t}\n}\n\nfunc (self *_parser) closeScope() {\n\tself.scope = self.scope.outer\n}\n\nfunc (self *_scope) declare(declaration ast.Declaration) {\n\tself.declarationList = append(self.declarationList, declaration)\n}\n\n\n\nfunc (self *_scope) hasLabel(name string) bool ", "output": "{\n\tfor _, label := range self.labels {\n\t\tif label == name {\n\t\t\treturn true\n\t\t}\n\t}\n\tif self.outer != nil && !self.inFunction {\n\t\treturn self.outer.hasLabel(name)\n\t}\n\treturn false\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSECSService_NetworkConfiguration struct {\n\n\tAwsvpcConfiguration *AWSECSService_AwsVpcConfiguration `json:\"AwsvpcConfiguration,omitempty\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSECSService_NetworkConfiguration) AWSCloudFormationType() string {\n\treturn \"AWS::ECS::Service.NetworkConfiguration\"\n}\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\n\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSECSService_NetworkConfiguration) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSECSService_NetworkConfiguration) SetDependsOn(dependencies []string) ", "output": "{\n\tr._dependsOn = dependencies\n}"}
{"input": "package main\n\nimport (\n\t\"net\"\n\t\"os\"\n\t\"fmt\"\n\t\"time\"\n\t\"log\"\n)\n\nfunc IsPortOpen(connectionType, addr string) bool {\n\n\ttcpAddr, err := net.ResolveTCPAddr(connectionType, addr)\n\tif err == nil {\n\t\t_, err = net.DialTCP(connectionType, nil, tcpAddr)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t} else {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n\n\nfunc main() {\n\n\tif len(os.Args) < 2 {\n\t\tfmt.Fprintf(os.Stderr, \"Usage: %s host:port [timeout - 100ms, 5s, 1m]\\n\", os.Args[0])\n\t\tos.Exit(1)\n\t}\n\tservice := os.Args[1]\n\n\tduration := \"5s\"\n\tif len(os.Args) > 2 {\n\t\tduration = os.Args[2]\n\t}\n\n\tfmt.Printf(\"Timeout %v\\n\", duration)\n\n\tisOpenCh := make(chan bool)\n\tgo IsPortOpenWithTimeout(isOpenCh, \"tcp\", service, duration)\n\n\tfmt.Printf(\"Check if %s is listening ...\", service)\n\tisOpenResult := <-isOpenCh\n\tfmt.Printf(\"Port Open? %v\\n\", isOpenResult)\n\n}\n\nfunc IsPortOpenWithTimeout(isOpenCh chan bool, connectionType, addr, timeout string) ", "output": "{\n\n\tduration, durationParseErr   := time.ParseDuration(timeout)\n\tif durationParseErr != nil {\n\t\tlog.Fatal(durationParseErr)\n\t}\n\tsleepInterval := 100 * time.Millisecond\n\ttheTimer      := time.NewTimer(duration)\n\n\tfor {\n\t\tselect {\n\t\t\tcase <-theTimer.C:\n\t\t\t\tisOpenCh <- false\n\t\t\tdefault :\n\t\t\t\tif (IsPortOpen(connectionType, addr)) {\n\t\t\t\t\tisOpenCh <- true\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(sleepInterval)\n\t\t}\n\t}\n\n}"}
{"input": "package bunyan\n\nimport \"fmt\"\n\n\ntype Logger struct {\n\tsink   Sink\n\trecord Record\n}\n\n\nfunc NewLogger(target Sink) *Logger {\n\treturn &Logger{target, NewRecord()}\n}\n\n\n\nfunc (l *Logger) Write(record Record) error {\n\trecord.TemplateMerge(l.record)\n\treturn l.sink.Write(record)\n}\n\n\n\nfunc (l *Logger) Include(info Info) Log {\n\treturn NewLogger(InfoSink(l, info))\n}\n\n\n\nfunc (l *Logger) Record(key string, value interface{}) Log {\n\tbuilder := NewLogger(l)\n\tbuilder.record[key] = value\n\treturn builder\n}\n\n\n\n\n\n\n\nfunc (l *Logger) Child() Log {\n\treturn NewLogger(l)\n}\n\nfunc (l *Logger) Tracef(msg string, args ...interface{}) { l.send(TRACE, msg, args...) }\nfunc (l *Logger) Debugf(msg string, args ...interface{}) { l.send(DEBUG, msg, args...) }\nfunc (l *Logger) Infof(msg string, args ...interface{})  { l.send(INFO, msg, args...) }\nfunc (l *Logger) Warnf(msg string, args ...interface{})  { l.send(WARN, msg, args...) }\nfunc (l *Logger) Errorf(msg string, args ...interface{}) { l.send(ERROR, msg, args...) }\nfunc (l *Logger) Fatalf(msg string, args ...interface{}) { l.send(FATAL, msg, args...) }\n\nfunc (l *Logger) send(level Level, msg string, args ...interface{}) {\n\trecord := NewRecord()\n\trecord.SetMessagef(level, msg, args...)\n\te := l.Write(record)\n\n\tif e != nil {\n\t\tpanic(e)\n\t}\n}\n\nfunc (l *Logger) Recordf(key, value string, args ...interface{}) Log ", "output": "{\n\treturn l.Record(key, fmt.Sprintf(value, args...))\n}"}
{"input": "package log\n\nimport (\n\t\"log\"\n\t\"os\"\n)\n\nfunc init() {\n\tFileLogger()\n}\n\nfunc StdoutLogger() {\n\tlog.SetOutput(os.Stdout)\n}\n\n\nfunc Trace(v ...interface{}) {\n\tlog.SetPrefix(\"[SDETool][Trace]\")\n\tlog.Println(v)\n\tlog.SetPrefix(\"[SDETool]\")\n}\n\nfunc FileLogger() ", "output": "{\n\tos.Remove(\"log.txt\")\n\tf, _ := os.OpenFile(\"log.txt\", os.O_CREATE|os.O_WRONLY, 0777)\n\tlog.SetOutput(f)\n\tlog.SetPrefix(\"[SDETool]\")\n\tlog.SetFlags(log.Lshortfile)\n}"}
{"input": "package openweathermap\n\nimport \"testing\"\n\n \n\nfunc TestDailyFmtFormatCity(t *testing.T) {\n\tname, country, days, key := \"Name\", \"US\", 3, \"4\"\n\n\tvar test dailyFmt = \"%s %s %d %s\"\n\n\texpected := \"Name US 3 4\"\n\n\tif actual := test.FormatCity(name, country, days, key); expected != actual {\n\t\tt.Errorf(\"Expected formatted string to be \\\"%s\\\" but was \\\"%s\\\"\",\n\t\t\texpected, actual)\n\t} \n}\n\nfunc TestDailyFmtFormatLoc(t *testing.T) ", "output": "{\n\tlat, lon, days, key := 1.0, 2.0, 3, \"4\"\n\n\tvar test dailyFmt = \"%f %f %d %s\"\n\n\texpected := \"1.000000 2.000000 3 4\"\n\n\tif actual := test.FormatLoc(lat, lon, days, key); expected != actual {\n\t\tt.Errorf(\"Expected formatted string to be \\\"%s\\\" but was \\\"%s\\\"\",\n\t\t\texpected, actual)\n\t} \n}"}
{"input": "package netlog\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\n\ntype TopicAtomicMap struct {\n\tmu  sync.Mutex\n\tval atomic.Value\n}\n\ntype _TopicMap map[string]*Topic\n\n\nfunc NewTopicAtomicMap() *TopicAtomicMap {\n\tam := &TopicAtomicMap{}\n\tam.val.Store(make(_TopicMap, 0))\n\treturn am\n}\n\n\n\n\n\n\n\nfunc (am *TopicAtomicMap) GetAll() map[string]*Topic {\n\treturn am.val.Load().(_TopicMap)\n}\n\n\nfunc (am *TopicAtomicMap) Len() int {\n\treturn len(am.val.Load().(_TopicMap))\n}\n\n\nfunc (am *TopicAtomicMap) Set(key string, value *Topic) {\n\tam.mu.Lock()\n\tdefer am.mu.Unlock()\n\n\tm1 := am.val.Load().(_TopicMap)\n\tm2 := make(_TopicMap, len(m1)+1)\n\tfor k, v := range m1 {\n\t\tm2[k] = v\n\t}\n\n\tm2[key] = value\n\tam.val.Store(m2)\n\treturn\n}\n\n\nfunc (am *TopicAtomicMap) Delete(key string) {\n\tam.mu.Lock()\n\tdefer am.mu.Unlock()\n\n\tm1 := am.val.Load().(_TopicMap)\n\t_, ok := m1[key]\n\tif !ok {\n\t\treturn\n\t}\n\n\tm2 := make(_TopicMap, len(m1)-1)\n\tfor k, v := range m1 {\n\t\tif k != key {\n\t\t\tm2[k] = v\n\t\t}\n\t}\n\n\tam.val.Store(m2)\n\treturn\n}\n\nfunc (am *TopicAtomicMap) Get(key string) (value *Topic, ok bool) ", "output": "{\n\tvalue, ok = am.val.Load().(_TopicMap)[key]\n\treturn value, ok\n}"}
{"input": "package controllers\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/lkkadiri/goboot/models\"\n)\n\ntype (\n\tUserController struct {\n\t\tdbConn *gorm.DB\n\t}\n)\n\n\nfunc NewUserController(db *gorm.DB) *UserController {\n\treturn &UserController{db}\n}\n\n\nfunc (uc UserController) GetAllUsers(w http.ResponseWriter, r *http.Request) {\n\tu := []models.User{}\n\tuc.dbConn.Find(&u)\n\tuj, _ := json.Marshal(u)\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(200)\n\tfmt.Fprintf(w, \"%s\", uj)\n}\n\n\n\n\n\nfunc (uc UserController) CreateUser(w http.ResponseWriter, r *http.Request) {\n\tu := &models.User{}\n\tjson.NewDecoder(r.Body).Decode(u)\n\tuc.dbConn.Create(u)\n\tuj, _ := json.Marshal(u)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(200)\n\tfmt.Fprintf(w, \"%s\", uj)\n}\n\n\nfunc (uc UserController) RemoveUser(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tuserID, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\tfmt.Fprintf(w, \"Cannot parse user id\")\n\t}\n\tu := &models.User{}\n\tuc.dbConn.Delete(u, userID)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(200)\n}\n\nfunc (uc UserController) GetUser(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tvars := mux.Vars(r)\n\tuserID, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\tfmt.Fprintf(w, \"Cannot parse user id\")\n\t}\n\n\tu := &models.User{}\n\tuc.dbConn.Find(u, userID)\n\tuj, _ := json.Marshal(u)\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(200)\n\tfmt.Fprintf(w, \"%s\", uj)\n}"}
{"input": "package pgeo\n\nimport (\n\t\"database/sql/driver\"\n)\n\n\ntype NullCircle struct {\n\tCircle\n\tValid bool `json:\"valid\"`\n}\n\n\n\n\n\nfunc (c *NullCircle) Scan(src interface{}) error {\n\tif src == nil {\n\t\tc.Circle, c.Valid = NewCircle(Point{}, 0), false\n\t\treturn nil\n\t}\n\n\tc.Valid = true\n\treturn scanCircle(&c.Circle, src)\n}\n\n\nfunc (c *NullCircle) Randomize(nextInt func() int64, fieldType string, shouldBeNull bool) {\n\tif shouldBeNull {\n\t\tc.Valid = false\n\t\treturn\n\t}\n\n\tc.Valid = true\n\tc.Circle = randCircle(nextInt)\n}\n\nfunc (c NullCircle) Value() (driver.Value, error) ", "output": "{\n\tif !c.Valid {\n\t\treturn nil, nil\n\t}\n\n\treturn valueCircle(c.Circle)\n}"}
{"input": "package iso20022\n\n\ntype StatisticsByPredefinedTimePeriods2 struct {\n\n\tHighestPriceValue12Months *PriceValue5 `xml:\"HghstPricVal12Mnths,omitempty\"`\n\n\tLowestPriceValue12Months *PriceValue5 `xml:\"LwstPricVal12Mnths,omitempty\"`\n\n\tOneYearPriceChange *PriceValueChange1 `xml:\"OneYrPricChng,omitempty\"`\n\n\tThreeYearPriceChange *PriceValueChange1 `xml:\"ThreeYrPricChng,omitempty\"`\n\n\tFiveYearPriceChange *PriceValueChange1 `xml:\"FiveYrPricChng,omitempty\"`\n}\n\nfunc (s *StatisticsByPredefinedTimePeriods2) AddHighestPriceValue12Months() *PriceValue5 {\n\ts.HighestPriceValue12Months = new(PriceValue5)\n\treturn s.HighestPriceValue12Months\n}\n\n\n\nfunc (s *StatisticsByPredefinedTimePeriods2) AddOneYearPriceChange() *PriceValueChange1 {\n\ts.OneYearPriceChange = new(PriceValueChange1)\n\treturn s.OneYearPriceChange\n}\n\nfunc (s *StatisticsByPredefinedTimePeriods2) AddThreeYearPriceChange() *PriceValueChange1 {\n\ts.ThreeYearPriceChange = new(PriceValueChange1)\n\treturn s.ThreeYearPriceChange\n}\n\nfunc (s *StatisticsByPredefinedTimePeriods2) AddFiveYearPriceChange() *PriceValueChange1 {\n\ts.FiveYearPriceChange = new(PriceValueChange1)\n\treturn s.FiveYearPriceChange\n}\n\nfunc (s *StatisticsByPredefinedTimePeriods2) AddLowestPriceValue12Months() *PriceValue5 ", "output": "{\n\ts.LowestPriceValue12Months = new(PriceValue5)\n\treturn s.LowestPriceValue12Months\n}"}
{"input": "package ipns\n\nimport (\n\tcontext \"gx/ipfs/QmZy2y8t9zQH2a1b8q2ZSLKp17ATuJoCNxxyMFG5qFExpt/go-net/context\"\n\n\t\"github.com/ipfs/go-ipfs/core\"\n\tmdag \"github.com/ipfs/go-ipfs/merkledag\"\n\tnsys \"github.com/ipfs/go-ipfs/namesys\"\n\tpath \"github.com/ipfs/go-ipfs/path\"\n\tft \"github.com/ipfs/go-ipfs/unixfs\"\n\tci \"gx/ipfs/QmUWER4r4qMvaCnX5zREcfyiWN7cXN9g3a7fkRqNz8qWPP/go-libp2p-crypto\"\n)\n\n\n\n\n\nfunc InitializeKeyspace(n *core.IpfsNode, key ci.PrivKey) error ", "output": "{\n\temptyDir := &mdag.Node{Data: ft.FolderPBData()}\n\tnodek, err := n.DAG.Add(emptyDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tctx, cancel := context.WithCancel(n.Context())\n\tdefer cancel()\n\n\terr = n.Pinning.Pin(ctx, emptyDir, false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = n.Pinning.Flush()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpub := nsys.NewRoutingPublisher(n.Routing, n.Repo.Datastore())\n\tif err := pub.Publish(ctx, key, path.FromKey(nodek)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"}
{"input": "package esme\n\nimport (\n\t\"github.com/sacloud/libsacloud/v2/helper/validate\"\n\t\"github.com/sacloud/libsacloud/v2/sacloud/types\"\n)\n\ntype ReadRequest struct {\n\tID types.ID `request:\"-\" validate:\"required\"`\n}\n\n\n\nfunc (req *ReadRequest) Validate() error ", "output": "{\n\treturn validate.Struct(req)\n}"}
{"input": "package util\n\nimport (\n\t\"os\"\n)\n\n\n\nfunc GetFileSize(filename string) (uint64, error) ", "output": "{\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tsize, err := file.Seek(0, os.SEEK_END)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn uint64(size), nil\n}"}
{"input": "package goku\n\nimport (\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype TestReader struct{}\n\nfunc (self TestReader) Read() ([]Message, error) {\n\ttime.Sleep(10 * time.Millisecond)\n\treturn []Message{\"Hello\"}, nil\n}\n\ntype TestWriter struct {\n\tmsgs []Message\n}\n\nfunc (self *TestWriter) Write(msgs []Message) error {\n\tfor _, msg := range msgs {\n\t\tself.msgs = append(self.msgs, msg)\n\t}\n\treturn nil\n}\n\nfunc TestNewQueueSetupReader(t *testing.T) {\n\tt.Parallel()\n\n\tq := NewQueue(&TestReader{}, nil)\n\n\tselect {\n\tcase <-q.Sender():\n\t\tbreak\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"Timeout expired\")\n\t}\n}\n\n\n\nfunc TestNewQueueSetsupWriter(t *testing.T) ", "output": "{\n\tt.Parallel()\n\n\twriter := &TestWriter{}\n\tq := NewQueue(nil, writer)\n\n\tq.Receiver() <- \"Hello\"\n\tq.Receiver() <- \"World\"\n\n\truntime.Gosched()\n\n\tif count := len(writer.msgs); count != 2 {\n\t\tt.Errorf(\"messages written == %d, want 2\", count)\n\t}\n}"}
{"input": "package aws\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/service/apigateway\"\n\t\"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema\"\n)\n\n\n\nfunc dataSourceAwsApiGatewayResourceRead(d *schema.ResourceData, meta interface{}) error {\n\tconn := meta.(*AWSClient).apigatewayconn\n\n\trestApiId := d.Get(\"rest_api_id\").(string)\n\ttarget := d.Get(\"path\").(string)\n\tparams := &apigateway.GetResourcesInput{RestApiId: aws.String(restApiId)}\n\n\tvar match *apigateway.Resource\n\tlog.Printf(\"[DEBUG] Reading API Gateway Resources: %s\", params)\n\terr := conn.GetResourcesPages(params, func(page *apigateway.GetResourcesOutput, lastPage bool) bool {\n\t\tfor _, resource := range page.Items {\n\t\t\tif aws.StringValue(resource.Path) == target {\n\t\t\t\tmatch = resource\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn !lastPage\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error describing API Gateway Resources: %s\", err)\n\t}\n\n\tif match == nil {\n\t\treturn fmt.Errorf(\"no Resources with path %q found for rest api %q\", target, restApiId)\n\t}\n\n\td.SetId(aws.StringValue(match.Id))\n\td.Set(\"path_part\", match.PathPart)\n\td.Set(\"parent_id\", match.ParentId)\n\n\treturn nil\n}\n\nfunc dataSourceAwsApiGatewayResource() *schema.Resource ", "output": "{\n\treturn &schema.Resource{\n\t\tRead: dataSourceAwsApiGatewayResourceRead,\n\t\tSchema: map[string]*schema.Schema{\n\t\t\t\"rest_api_id\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tRequired: true,\n\t\t\t},\n\t\t\t\"path\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tRequired: true,\n\t\t\t},\n\t\t\t\"path_part\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tComputed: true,\n\t\t\t},\n\t\t\t\"parent_id\": {\n\t\t\t\tType:     schema.TypeString,\n\t\t\t\tComputed: true,\n\t\t\t},\n\t\t},\n\t}\n}"}
{"input": "package ircbotint\n\nimport (\n    \"strings\"\n    \"fmt\"\n    \"net/http\"\n    \"io/ioutil\"\n)\n\nvar httpUrl string\n\n\n\n\n\n\n\nfunc CallHttp(param1, param2 string) (string, error) {\n    var r *http.Response\n    var err error\n    var s string\n    var ba []byte\n\n    if len(param2) > 0 {\n        s = fmt.Sprintf(\"%s%s/%s\", httpUrl, param1, param2)\n    } else {\n        s = fmt.Sprintf(\"%s%s\", httpUrl, param1)\n    }\n\n    r, err = http.Get(s)\n    if err != nil {\n        return \"\", err\n    }\n\n    ba, err = ioutil.ReadAll(r.Body)\n    r.Body.Close()\n\n    if err != nil {\n        return \"\", err\n    }\n\n    s = string(ba)\n\n    return s, nil\n}\n\nfunc SetHttpUrl(url string) ", "output": "{\n    url = strings.Trim(url, \"/\")\n    url = fmt.Sprintf(\"%s/\", url)\n    httpUrl = url\n}"}
{"input": "package cdrom\n\nimport (\n\t\"flag\"\n\n\t\"github.com/vmware/govmomi/govc/cli\"\n\t\"github.com/vmware/govmomi/govc/flags\"\n\t\"golang.org/x/net/context\"\n)\n\ntype eject struct {\n\t*flags.VirtualMachineFlag\n\n\tdevice string\n}\n\nfunc init() {\n\tcli.Register(\"device.cdrom.eject\", &eject{})\n}\n\nfunc (cmd *eject) Register(f *flag.FlagSet) {\n\tf.StringVar(&cmd.device, \"device\", \"\", \"CD-ROM device name\")\n}\n\nfunc (cmd *eject) Process() error { return nil }\n\nfunc (cmd *eject) Description() string {\n\treturn `Eject media from CD-ROM device.\n\nIf device is not specified, the first CD-ROM device is used.`\n}\n\n\n\nfunc (cmd *eject) Run(f *flag.FlagSet) error ", "output": "{\n\tvm, err := cmd.VirtualMachine()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif vm == nil {\n\t\treturn flag.ErrHelp\n\t}\n\n\tdevices, err := vm.Device(context.TODO())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc, err := devices.FindCdrom(cmd.device)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn vm.EditDevice(context.TODO(), devices.EjectIso(c))\n}"}
{"input": "package kintone\n\nimport (\n\t\"encoding/json\"\n)\n\n\ntype Cursor struct {\n\tId         string `json:\"id\"`\n\tTotalCount string `json:\"totalCount\"`\n}\ntype GetRecordsCursorResponse struct {\n\tRecords []*Record `json:\"records\"`\n\tNext    bool      `json:\"next\"`\n}\n\n\n\nfunc DecodeGetRecordsCursorResponse(b []byte) (rc *GetRecordsCursorResponse, err error) {\n\tvar t struct {\n\t\tNext bool `json:\"next\"`\n\t}\n\terr = json.Unmarshal(b, &t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlistRecord, err := DecodeRecords(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgetRecordsCursorResponse := &GetRecordsCursorResponse{Records: listRecord, Next: t.Next}\n\treturn getRecordsCursorResponse, nil\n}\n\nfunc decodeCursor(b []byte) (c *Cursor, err error) ", "output": "{\n\terr = json.Unmarshal(b, &c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}"}
{"input": "package rpc\n\nimport (\n\t\"strings\"\n)\n\nfunc makeMethodName(prot string, method string) string {\n\tif prot == \"\" {\n\t\treturn method\n\t}\n\treturn prot + \".\" + method\n}\n\nfunc splitMethodName(n string) (string, string) {\n\ti := strings.LastIndex(n, \".\")\n\tif i == -1 {\n\t\treturn \"\", n\n\t}\n\treturn n[:i], n[i+1:]\n}\n\nfunc runInBg(f func() error) chan error {\n\tdone := make(chan error)\n\tgo func() {\n\t\tdone <- f()\n\t}()\n\treturn done\n}\n\n\n\nfunc wrapError(f WrapErrorFunc, e error) interface{} ", "output": "{\n\tif f != nil {\n\t\treturn f(e)\n\t}\n\tif e == nil {\n\t\treturn nil\n\t}\n\treturn e.Error()\n}"}
{"input": "package windows\n\nimport (\n\t\"github.com/docker/libnetwork/driverapi\"\n\t\"github.com/docker/libnetwork/types\"\n)\n\nconst networkType = \"windows\"\n\n\n\ntype driver struct{}\n\n\nfunc Init(dc driverapi.DriverCallback) error {\n\tc := driverapi.Capability{\n\t\tScope: driverapi.LocalScope,\n\t}\n\treturn dc.RegisterDriver(networkType, &driver{}, c)\n}\n\nfunc (d *driver) Config(option map[string]interface{}) error {\n\treturn nil\n}\n\nfunc (d *driver) CreateNetwork(id types.UUID, option map[string]interface{}) error {\n\treturn nil\n}\n\nfunc (d *driver) DeleteNetwork(nid types.UUID) error {\n\treturn nil\n}\n\nfunc (d *driver) CreateEndpoint(nid, eid types.UUID, epInfo driverapi.EndpointInfo, epOptions map[string]interface{}) error {\n\treturn nil\n}\n\n\n\nfunc (d *driver) EndpointOperInfo(nid, eid types.UUID) (map[string]interface{}, error) {\n\treturn make(map[string]interface{}, 0), nil\n}\n\n\nfunc (d *driver) Join(nid, eid types.UUID, sboxKey string, jinfo driverapi.JoinInfo, options map[string]interface{}) error {\n\treturn nil\n}\n\n\nfunc (d *driver) Leave(nid, eid types.UUID) error {\n\treturn nil\n}\n\nfunc (d *driver) Type() string {\n\treturn networkType\n}\n\nfunc (d *driver) DeleteEndpoint(nid, eid types.UUID) error ", "output": "{\n\treturn nil\n}"}
{"input": "package inject\n\n\n\nfunc With(t Any) Option {\n\treturn ScopeOf(t).Chain(func(x Any) Option {\n\t\treturn x.(IModule).GetInstance(t)\n\t})\n}\n\nfunc WithIn(t Any, module Any) Option {\n\treturn ModuleOf(module).Chain(func(x Any) Option {\n\t\treturn x.(IModule).GetInstance(t)\n\t})\n}\n\nfunc As(t Any) Option ", "output": "{\n\treturn CurrentScope().Fold(\n\t\tfunc(x Any) Option {\n\t\t\tinstance := x.(IModule).GetInstance(t)\n\t\t\treturn instance.Fold(\n\t\t\t\tfunc(x Any) Option {\n\t\t\t\t\treturn instance\n\t\t\t\t},\n\t\t\t\tfunc() Option {\n\t\t\t\t\treturn With(t)\n\t\t\t\t},\n\t\t\t)\n\t\t},\n\t\tfunc() Option {\n\t\t\treturn With(t)\n\t\t},\n\t)\n}"}
{"input": "package canvas\n\nimport \"math/rand\"\n\n\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\n\nfunc max(x, y int) int {\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}\n\n\n\n\nfunc random() float64 ", "output": "{\n\treturn rand.Float64()\n}"}
{"input": "package main\n\n\n\n\nimport (\n\t\"github.com/dchest/captcha\"\n\t\"database/sql\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst (\n\tCAPTCHAGracePeriod = time.Minute * 10\n)\n\ntype CAPTCHAStore struct{}\n\n\n\n\n\n\n\nfunc (CAPTCHAStore) Get(id string, clear bool) (digits []byte) {\n\tbid := []byte(id)\n\trow := Db.QueryRow(`SELECT solution\nFROM captcha\nWHERE id = ? AND expiration > ?;`, bid, time.Now())\n\terr := row.Scan(&digits)\n\tif err == sql.ErrNoRows {\n\t\treturn nil\n\t} else if err != nil {\n\t\tl.Err(\"Error retrieving CAPTCHA:\", err)\n\t\treturn nil\n\t}\n\n\tif clear {\n\t\t_, err = Db.Exec(`DELETE FROM captcha\nWHERE id = ?;`, bid)\n\t\tif err != nil {\n\t\t\tl.Err(\"Error deleting CAPTCHA:\", err)\n\t\t}\n\t}\n\treturn\n}\n\n\n\nfunc ClearExpiredCAPTCHA() {\n\t_, err := Db.Exec(`DELETE FROM captcha\nWHERE expiration <= ?;`, time.Now())\n\tif err != nil {\n\t\tl.Err(\"Error deleting expired CAPTCHAs:\", err)\n\t}\n}\n\n\n\n\n\n\nfunc VerifyCAPTCHA(req *http.Request) error {\n\tsolution := req.FormValue(\"captcha\")\n\tindex := strings.Index(solution, \":\")\n\tif index < 0 {\n\t\treturn InvalidCAPTCHAFormat\n\t}\n\tif !captcha.VerifyString(solution[:index], solution[index+1:]) {\n\t\treturn IncorrectCAPTCHA\n\t}\n\treturn nil\n}\n\nfunc (CAPTCHAStore) Set(id string, digits []byte) ", "output": "{\n\t_, err := Db.Exec(`INSERT INTO captcha\n(id, solution, expiration)\nVALUES(?, ?, ?);`,\n\t\t[]byte(id), digits, time.Now().Add(CAPTCHAGracePeriod))\n\tif err != nil {\n\t\tl.Err(\"Error registering CAPTCHA:\", err)\n\t}\n}"}
{"input": "package hsapi\n\n\n\nfunc NewAllCards() AllCardsConfig {\n\treturn AllCardsConfig{}\n}\n\n\n\nfunc NewCardBacks() CardBacksConfig {\n\treturn CardBacksConfig{}\n}\n\n\n\nfunc NewCardSearch(name string) CardSearchConfig {\n\treturn CardSearchConfig{\n\t\tName: name,\n\t}\n}\n\n\n\nfunc NewCardsBySet(set Set) CardsBySetConfig {\n\treturn CardsBySetConfig{\n\t\tSet: set,\n\t}\n}\n\n\n\n\n\n\n\nfunc NewCardsByFaction(faction Faction) CardsByFactionConfig {\n\treturn CardsByFactionConfig{\n\t\tFaction: faction,\n\t}\n}\n\n\n\nfunc NewCardsByQuality(quality Quality) CardsByQualityConfig {\n\treturn CardsByQualityConfig{\n\t\tQuality: quality,\n\t}\n}\n\n\n\nfunc NewCardsByRace(race Race) CardsByRaceConfig {\n\treturn CardsByRaceConfig{\n\t\tRace: race,\n\t}\n}\n\n\n\nfunc NewCardsByType(typ Type) CardsByTypeConfig {\n\treturn CardsByTypeConfig{\n\t\tType: typ,\n\t}\n}\n\n\n\nfunc NewGetCard(id string) GetCardConfig {\n\treturn GetCardConfig{\n\t\tName: id,\n\t}\n}\n\n\n\nfunc NewInfo() InfoConfig {\n\treturn InfoConfig{}\n}\n\n\n\nfunc NewCardImage(cardID string) CardImageConfig {\n\treturn CardImageConfig{\n\t\tCardID: cardID,\n\t\tGold:   false,\n\t\tLocale: EnUS,\n\t}\n}\n\n\n\n\nfunc NewCardSound(cardID string, soundType SoundType) CardSoundConfig {\n\treturn CardSoundConfig{\n\t\tCardID:    cardID,\n\t\tType:      soundType,\n\t\tExtension: MP3,\n\t\tLocale:    EnUS,\n\t}\n}\n\nfunc NewCardsByClass(class Class) CardsByClassConfig ", "output": "{\n\treturn CardsByClassConfig{\n\t\tClass: class,\n\t}\n}"}
{"input": "package sdl\n\nimport (\n\t\"os\"\n)\n\n\n\nfunc init() ", "output": "{\n\tif os.Getenv(\"SDL_VIDEODRIVER\") == \"\" {\n\t\tos.Setenv(\"SDL_VIDEODRIVER\", \"x11\")\n\t}\n}"}
{"input": "package request\n\nimport (\n\t\"errors\"\n\t\"github.com/vx-labs/go-rest-api\"\n\t\"github.com/vx-labs/go-rest-api/opts\"\n)\n\ntype APIRequest struct {\n\taction   api.Verb\n\tpayload  interface{}\n\tresponse interface{}\n\tresource api.ClientResource\n\topts     opts.Values\n\theaders  map[string][]string\n}\n\nfunc (r *APIRequest) Payload() interface{} {\n\treturn r.payload\n}\nfunc (r *APIRequest) Response() interface{} {\n\treturn r.response\n}\nfunc (r *APIRequest) Action() api.Verb {\n\treturn r.action\n}\nfunc (r *APIRequest) Headers() map[string][]string {\n\treturn r.headers\n}\nfunc (r *APIRequest) Resource() api.ClientResource {\n\treturn r.resource\n}\n\n\nfunc (r *APIRequest) WithHeader(name, value string) api.ClientRequest {\n\tif _, found := r.headers[name]; !found {\n\t\tr.headers[name] = []string{value}\n\t\treturn r\n\t}\n\tr.headers[name] = append(r.headers[name], value)\n\treturn r\n}\n\nfunc (r *APIRequest) Options() opts.Values {\n\treturn r.opts\n}\n\nfunc (r *APIRequest) Validate() error {\n\tif r.action > 5 {\n\t\treturn errors.New(\"invalid API verb\")\n\t}\n\treturn nil\n}\n\nfunc New(action api.Verb, payload interface{}, response interface{}, resource api.ClientResource) api.ClientRequest {\n\treturn &APIRequest{\n\t\taction:   action,\n\t\tpayload:  payload,\n\t\tresponse: response,\n\t\tresource: resource,\n\t\topts:     opts.New(),\n\t}\n}\n\nfunc (r *APIRequest) WithOptions(opts opts.Values) api.ClientRequest ", "output": "{\n\tr.opts = opts\n\treturn r\n}"}
{"input": "package iso20022\n\n\ntype ReturnReasonInformation9 struct {\n\n\tOriginator *PartyIdentification32 `xml:\"Orgtr,omitempty\"`\n\n\tReason *ReturnReason5Choice `xml:\"Rsn,omitempty\"`\n\n\tAdditionalInformation []*Max105Text `xml:\"AddtlInf,omitempty\"`\n}\n\nfunc (r *ReturnReasonInformation9) AddOriginator() *PartyIdentification32 {\n\tr.Originator = new(PartyIdentification32)\n\treturn r.Originator\n}\n\n\n\nfunc (r *ReturnReasonInformation9) AddAdditionalInformation(value string) {\n\tr.AdditionalInformation = append(r.AdditionalInformation, (*Max105Text)(&value))\n}\n\nfunc (r *ReturnReasonInformation9) AddReason() *ReturnReason5Choice ", "output": "{\n\tr.Reason = new(ReturnReason5Choice)\n\treturn r.Reason\n}"}
{"input": "package machineactions\n\nimport (\n\t\"gopkg.in/juju/names.v2\"\n\n\t\"github.com/juju/juju/apiserver/common\"\n\t\"github.com/juju/juju/apiserver/facade\"\n\t\"github.com/juju/juju/apiserver/params\"\n\t\"github.com/juju/juju/state\"\n)\n\nfunc init() {\n\tcommon.RegisterStandardFacade(\"MachineActions\", 1, newFacade)\n}\n\nfunc newFacade(st *state.State, res facade.Resources, auth facade.Authorizer) (*Facade, error) {\n\treturn NewFacade(backendShim{st}, res, auth)\n}\n\ntype backendShim struct {\n\tst *state.State\n}\n\nfunc (shim backendShim) ActionByTag(tag names.ActionTag) (state.Action, error) {\n\treturn shim.st.ActionByTag(tag)\n}\n\n\n\nfunc (shim backendShim) TagToActionReceiverFn(findEntity func(names.Tag) (state.Entity, error)) func(string) (state.ActionReceiver, error) {\n\treturn common.TagToActionReceiverFn(findEntity)\n}\n\nfunc (shim backendShim) ConvertActions(ar state.ActionReceiver, fn common.GetActionsFn) ([]params.ActionResult, error) {\n\treturn common.ConvertActions(ar, fn)\n}\n\nfunc (shim backendShim) FindEntity(tag names.Tag) (state.Entity, error) ", "output": "{\n\treturn shim.st.FindEntity(tag)\n}"}
{"input": "package main\n\nimport (\n\t\"time\"\n)\n\n\n\nfunc startServerMonitor() {\n\ttimer := time.NewTimer(time.Second * 30)\n\n\tselect {\n\tcase <-timer.C:\n\t\tDataManager().CheckServerTTL()\n\t}\n}\n\nfunc serverMonitorInit() ", "output": "{\n\tgo startServerMonitor()\n}"}
{"input": "package some\n\nimport (\n\t\"github.com/laher/someutils\"\n\t\"github.com/laher/uggo\"\n\t\"io\"\n\t\"os\"\n)\n\nfunc init() {\n\tsomeutils.RegisterPipable(func() someutils.CliPipable { return new(SomeTee) })\n}\n\n\ntype SomeTee struct {\n\tisAppend bool\n\tflag     int\n\targs     []string\n}\n\n\nfunc (tee *SomeTee) Name() string {\n\treturn \"tee\"\n}\n\n\n\n\nfunc (tee *SomeTee) ParseFlags(call []string, errPipe io.Writer) (error, int) {\n\tflagSet := uggo.NewFlagSetDefault(\"tee\", \"[OPTION]... [FILE]...\", someutils.VERSION)\n\tflagSet.SetOutput(errPipe)\n\tflagSet.AliasedBoolVar(&tee.isAppend, []string{\"a\", \"append\"}, false, \"Append instead of overwrite\")\n\n\terr, code := flagSet.ParsePlus(call[1:])\n\tif err != nil {\n\t\treturn err, code\n\t}\n\n\ttee.args = flagSet.Args()\n\treturn nil, 0\n}\n\n\n\n\n\nfunc NewTee() *SomeTee {\n\treturn new(SomeTee)\n}\n\n\nfunc Tee(args ...string) *SomeTee {\n\ttee := NewTee()\n\ttee.args = args\n\treturn tee\n}\n\n\nfunc TeeCli(call []string) (error, int) {\n\n\tutil := new(SomeTee)\n\treturn someutils.StdInvoke((util), call)\n}\n\nfunc (tee *SomeTee) Invoke(invocation *someutils.Invocation) (error, int) ", "output": "{\n\tinvocation.ErrPipe.Drain()\n\tinvocation.AutoHandleSignals()\n\tflag := os.O_CREATE\n\tif tee.isAppend {\n\t\tflag = flag | os.O_APPEND\n\t}\n\twriteables := uggo.ToWriteableOpeners(tee.args, flag, 0666)\n\tfiles, err := uggo.OpenAll(writeables)\n\tif err != nil {\n\t\treturn err, 1\n\t}\n\twriters := []io.Writer{invocation.MainPipe.Out}\n\tfor _, file := range files {\n\t\twriters = append(writers, file)\n\t}\n\tmultiwriter := io.MultiWriter(writers...)\n\t_, err = io.Copy(multiwriter, invocation.MainPipe.In)\n\tif err != nil {\n\t\treturn err, 1\n\t}\n\tfor _, file := range files {\n\t\terr = file.Close()\n\t\tif err != nil {\n\t\t\treturn err, 1\n\t\t}\n\t}\n\treturn nil, 0\n\n}"}
{"input": "package archive\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\n\t\"github.com/containers/storage/pkg/system\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc statDifferent(oldStat *system.StatT, newStat *system.StatT) bool {\n\tif oldStat.Mode() != newStat.Mode() ||\n\t\toldStat.UID() != newStat.UID() ||\n\t\toldStat.GID() != newStat.GID() ||\n\t\toldStat.Rdev() != newStat.Rdev() ||\n\t\t(oldStat.Mode()&unix.S_IFDIR != unix.S_IFDIR &&\n\t\t\t(!sameFsTimeSpec(oldStat.Mtim(), newStat.Mtim()) || (oldStat.Size() != newStat.Size()))) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (info *FileInfo) isDir() bool {\n\treturn info.parent == nil || info.stat.Mode()&unix.S_IFDIR != 0\n}\n\n\n\nfunc hasHardlinks(fi os.FileInfo) bool {\n\treturn fi.Sys().(*syscall.Stat_t).Nlink > 1\n}\n\nfunc getIno(fi os.FileInfo) uint64 ", "output": "{\n\treturn fi.Sys().(*syscall.Stat_t).Ino\n}"}
{"input": "package fileutil\n\nimport (\n\t\"os\"\n\t\"syscall\"\n)\n\ntype unixLock struct {\n\tf *os.File\n}\n\nfunc (l *unixLock) Release() error {\n\tif err := l.set(false); err != nil {\n\t\treturn err\n\t}\n\treturn l.f.Close()\n}\n\n\n\nfunc newLock(fileName string) (Releaser, error) {\n\tf, err := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE, 0666)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tl := &unixLock{f}\n\terr = l.set(true)\n\tif err != nil {\n\t\tf.Close()\n\t\treturn nil, err\n\t}\n\treturn l, nil\n}\n\nfunc (l *unixLock) set(lock bool) error ", "output": "{\n\tflock := syscall.Flock_t{\n\t\tType:   syscall.F_UNLCK,\n\t\tStart:  0,\n\t\tLen:    0,\n\t\tWhence: 1,\n\t}\n\tif lock {\n\t\tflock.Type = syscall.F_WRLCK\n\t}\n\treturn syscall.FcntlFlock(l.f.Fd(), syscall.F_SETLK, &flock)\n}"}
{"input": "package fileconsul\n\nimport (\n\t\"testing\"\n)\n\nfunc TestConstructClient(t *testing.T) {\n\t_, err := NewClient(&ClientConfig{\n\t\tConsulAddr: \"localhost:8500\",\n\t\tConsulDC:   \"dc1\",\n\t})\n\tif err != nil {\n\t\tt.Skipf(\"err: %v\", err)\n\t}\n}\n\n\n\nfunc TestConsulAgentInfo(t *testing.T) {\n\tclient, err := NewClient(&ClientConfig{\n\t\tConsulAddr: \"localhost:8500\",\n\t\tConsulDC:   \"dc1\",\n\t})\n\tif err != nil {\n\t\tt.Skipf(\"err: %v\", err)\n\t}\n\n\t_, err = client.ConsulAgentInfo()\n\tif err != nil {\n\t\tt.Skipf(\"err: %v\", err)\n\t}\n}\n\nfunc TestPutGetDeleteKV(t *testing.T) ", "output": "{\n\tclient, err := NewClient(&ClientConfig{\n\t\tConsulAddr: \"localhost:8500\",\n\t\tConsulDC:   \"dc1\",\n\t})\n\tif err != nil {\n\t\tt.Skipf(\"err: %v\", err)\n\t}\n\n\terr = client.PutKV(\"foo/bar/bazz\", []byte(\"123\"))\n\tif err != nil {\n\t\tt.Skipf(\"err: %v\", err)\n\t}\n\n\t_, err = client.GetKV(\"foo/bar/bazz\")\n\tif err != nil {\n\t\tt.Skipf(\"err: %v\", err)\n\t}\n\n\t_, err = client.ListKV(\"foo\")\n\tif err != nil {\n\t\tt.Skipf(\"err: %v\", err)\n\t}\n\n\terr = client.DeleteKV(\"foo/bar/bazz\")\n\tif err != nil {\n\t\tt.Skipf(\"err: %v\", err)\n\t}\n}"}
{"input": "package mqcontrollers\n\nimport (\n\t\"github.com/byrnedo/apibase/natsio\"\n\tr \"github.com/byrnedo/apibase/routes\"\n\t\"github.com/nats-io/nats\"\n)\n\ntype HealthcheckController struct {\n\troutes  []*r.NatsRoute\n\tnatsCon *natsio.Nats\n}\n\nfunc (c *HealthcheckController) GetRoutes() []*r.NatsRoute {\n\treturn c.routes\n}\n\n\n\nfunc (c *HealthcheckController) Healthcheck(m *nats.Msg) {\n}\n\nfunc NewHealthcheckController(nc *natsio.Nats) (hc *HealthcheckController) ", "output": "{\n\thc = &HealthcheckController{}\n\thc.natsCon = nc\n\thc.routes = []*r.NatsRoute{\n\t\tr.NewNatsRoute(\"user.healthcheck\", hc.Healthcheck),\n\t}\n\treturn\n}"}
{"input": "package vcs\n\nimport (\n\t\"io/ioutil\"\n\t\"os/exec\"\n\t\"path\"\n\t\"strings\"\n)\n\ntype Git struct {\n\tname   string\n\tfound  bool\n\tfolder string\n}\n\nfunc (g *Git) Check() {\n\tfolder, found := findFolder(\".git\")\n\n\tg.name = \"git\"\n\n\tif found {\n\t\tg.found = true\n\t\tg.folder = folder\n\t}\n}\n\n\n\nfunc (g *Git) Path() string {\n\treturn g.folder\n}\n\nfunc (g *Git) Found() bool {\n\treturn g.found\n}\n\nfunc (g *Git) Branch() string {\n\tfilename := path.Join(g.folder, \".git\", \"HEAD\")\n\tdata, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\tparts := strings.Split(string(data), \"/\")\n\n\treturn strings.TrimSpace(parts[len(parts)-1])\n}\n\nfunc (g *Git) Modifications() string {\n\tcmd := exec.Command(\"git\", \"diff\", \"--no-ext-diff\", \"--quiet\", \"--exit-code\")\n\terr := cmd.Run()\n\tif err != nil {\n\t\treturn \"+\"\n\t}\n\n\treturn \"\"\n}\n\nfunc (g *Git) NewFiles() string {\n\tcmd := exec.Command(\"git\", \"ls-files\", \"--others\", \"--exclude-standard\")\n\tout, err := cmd.Output()\n\tif err == nil && len(out) == 0 {\n\t\treturn \"\"\n\t}\n\n\treturn \"?\"\n}\n\nfunc (g *Git) Name() string ", "output": "{\n\treturn g.name\n}"}
{"input": "package unittest\n\nimport (\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/Huawei/dockyard/utils\"\n)\n\n\nfunc TestMetaEncrypt(t *testing.T) {\n\tvar item utils.MetaItem\n\n\titem.SetEncryption(utils.EncryptRSA)\n\tassert.Equal(t, true, item.GetEncryption() == utils.EncryptRSA, \"Fail to set/get entrypt method\")\n}\n\n\nfunc TestMetaItemGenerate(t *testing.T) {\n\t_, path, _, _ := runtime.Caller(0)\n\tdir := filepath.Join(filepath.Dir(path), \"testdata\")\n\n\ttestContentFile := filepath.Join(dir, \"hello.txt\")\n\ttestHashFile := filepath.Join(dir, \"hello.hash\")\n\tcontentByte, _ := ioutil.ReadFile(testContentFile)\n\thashByte, _ := ioutil.ReadFile(testHashFile)\n\tmetaItem := utils.GenerateMetaItem(\"hello.txt\", contentByte)\n\tassert.Equal(t, metaItem.GetHash(), strings.TrimSpace(string(hashByte)), \"Fail to get correct hash value\")\n}\n\n\n\n\nfunc TestMetaTime(t *testing.T) ", "output": "{\n\ttest1 := \"test1\"\n\ttest1Byte := []byte(\"test1 byte\")\n\tmetaItem1 := utils.GenerateMetaItem(test1, test1Byte)\n\tmetaItem2 := metaItem1\n\tassert.Equal(t, metaItem1, metaItem2, \"Fail to compare metaItem, should be the same\")\n\n\tmetaItem2.SetCreated(metaItem2.GetCreated().Add(time.Hour * 1))\n\tcmp := metaItem1.Compare(metaItem2)\n\tassert.Equal(t, cmp < 0, true, \"Fail to compare metaItem, should be smaller\")\n\n\tassert.Equal(t, metaItem2.IsExpired(), false, \"Fail to get expired information\")\n\tmetaItem2.SetExpired(time.Now().Add(time.Hour * (-1)))\n\tassert.Equal(t, metaItem2.IsExpired(), true, \"Fail to get expired information\")\n}"}
{"input": "package security\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\t\"github.com/cockroachdb/cockroach/util\"\n\t\"golang.org/x/crypto/bcrypt\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\n\n\n\n\nconst bcryptCost = bcrypt.DefaultCost\n\n\n\n\n\nfunc promptForPassword() ([]byte, error) {\n\toldState, err := terminal.MakeRaw(0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() {\n\t\t_ = terminal.Restore(0, oldState)\n\t}()\n\n\tfmt.Print(\"Enter password: \")\n\tone, err := terminal.ReadPassword(0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfmt.Print(\"\\nConfirm password: \")\n\ttwo, err := terminal.ReadPassword(0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfmt.Print(\"\\n\")\n\tif !bytes.Equal(one, two) {\n\t\treturn nil, util.Errorf(\"password mismatch\")\n\t}\n\treturn []byte(one), nil\n}\n\n\n\n\n\n\nfunc PromptForPasswordAndHash() ([]byte, error) {\n\tpassword, err := promptForPassword()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(password) == 0 {\n\t\treturn nil, util.Errorf(\"password cannot be empty\")\n\t}\n\treturn HashPassword(password)\n}\n\nfunc HashPassword(raw []byte) ([]byte, error) ", "output": "{\n\treturn bcrypt.GenerateFromPassword(raw, bcryptCost)\n}"}
{"input": "package models\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/astaxie/beego/orm\"\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nconst (\n\tWORKER_STATUS_IDLE = 0\n\tWORKER_STATUS_BUSY = 1\n\tWORKER_STATUS_DIE  = 2\n)\n\n\ntype Worker struct {\n\tId         int64  `orm:\"pk;auto\"`\n\tIp         string `orm:\"size(1024)\"`\n\tLastUpdate time.Time\n\tStatus     int\n}\n\n\nfunc GetAllWorkers() []*Worker {\n\to := orm.NewOrm()\n\n\tvar workers []*Worker\n\tnum, err := o.QueryTable(\"worker\").All(&workers)\n\tfmt.Printf(\"Returned Rows Num: %s, %s\", num, err)\n\treturn workers\n}\n\n\n\n\nfunc GetAllWorkersWithStatus(status int) []*Worker ", "output": "{\n\to := orm.NewOrm()\n\n\tvar workers []*Worker\n\tnum, err := o.QueryTable(\"worker\").Filter(\"status\", status).All(&workers)\n\tfmt.Printf(\"Returned Rows Num: %s, %s\", num, err)\n\treturn workers\n}"}
{"input": "package console\n\nimport (\n\t\"github.com/cgrates/cgrates/utils\"\n\t\"strings\"\n)\n\nfunc init() {\n\tc := &CmdApierPing{\n\t\tname: \"ping\",\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}\n\n\ntype CmdApierPing struct {\n\tname      string\n\trpcMethod string\n\trpcParams *StringWrapper\n\t*CommandExecuter\n}\n\ntype ArgsPing struct {\n\tMethodName string\n}\n\nfunc (self *CmdApierPing) Name() string {\n\treturn self.name\n}\n\nfunc (self *CmdApierPing) RpcMethod() string {\n\tswitch strings.ToLower(self.rpcParams.Item) {\n\tcase utils.SuppliersLow:\n\t\treturn utils.SupplierSv1Ping\n\tcase utils.AttributesLow:\n\t\treturn utils.AttributeSv1Ping\n\tcase utils.ChargerSLow:\n\t\treturn utils.ChargerSv1Ping\n\tcase utils.ResourcesLow:\n\t\treturn utils.ResourceSv1Ping\n\tcase utils.StatServiceLow:\n\t\treturn utils.StatSv1Ping\n\tcase utils.ThresholdsLow:\n\t\treturn utils.ThresholdSv1Ping\n\tcase utils.SessionsLow:\n\t\treturn utils.SessionSv1Ping\n\tcase utils.LoaderSLow:\n\t\treturn utils.LoaderSv1Ping\n\tcase utils.DispatcherSLow:\n\t\treturn utils.DispatcherSv1Ping\n\tcase utils.AnalyzerSLow:\n\t\treturn utils.AnalyzerSv1Ping\n\tdefault:\n\t}\n\treturn self.rpcMethod\n}\n\nfunc (self *CmdApierPing) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &StringWrapper{}\n\t}\n\n\treturn self.rpcParams\n}\n\nfunc (self *CmdApierPing) PostprocessRpcParams() error {\n\treturn nil\n}\n\n\n\nfunc (self *CmdApierPing) RpcResult() interface{} ", "output": "{\n\tvar s string\n\treturn &s\n}"}
{"input": "package proc\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype errorOnce struct {\n\tonce  sync.Once\n\terr   chan error\n\tabort <-chan struct{}\n}\n\n\n\nfunc NewErrorOnce(abort <-chan struct{}) ErrorOnce {\n\treturn &errorOnce{\n\t\terr:   make(chan error, 1),\n\t\tabort: abort,\n\t}\n}\n\nfunc (b *errorOnce) Err() <-chan error {\n\treturn b.err\n}\n\nfunc (b *errorOnce) Reportf(msg string, args ...interface{}) {\n\tb.Report(fmt.Errorf(msg, args...))\n}\n\nfunc (b *errorOnce) Report(err error) {\n\tb.once.Do(func() {\n\t\tselect {\n\t\tcase b.err <- err:\n\t\tdefault:\n\t\t}\n\t})\n}\n\n\n\nfunc (b *errorOnce) forward(errIn <-chan error) {\n\tif errIn == nil {\n\t\tb.Report(nil)\n\t\treturn\n\t}\n\tselect {\n\tcase err, _ := <-errIn:\n\t\tb.Report(err)\n\tcase <-b.abort:\n\t\tselect {\n\t\tcase err, _ := <-errIn:\n\t\t\tb.Report(err)\n\t\tdefault:\n\t\t\tb.Report(errProcessTerminated)\n\t\t}\n\t}\n}\n\nfunc (b *errorOnce) WaitFor(d time.Duration) (error, bool) {\n\tt := time.NewTimer(d)\n\tselect {\n\tcase err, _ := <-b.err:\n\t\tt.Stop()\n\t\treturn err, true\n\tcase <-t.C:\n\t\treturn nil, false\n\t}\n}\n\nfunc (b *errorOnce) Send(errIn <-chan error) ErrorOnce ", "output": "{\n\tgo b.forward(errIn)\n\treturn b\n}"}
{"input": "package utils\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\n\t\"github.com/spf13/cobra\"\n)\n\nvar (\n\tcommit    = \"\"\n\tdate      = \"\"\n\tgoversion = \"\"\n)\n\n\nvar VersionCmd = &cobra.Command{\n\tUse:   \"version\",\n\tShort: \"Show current version\",\n\tLong:  `Show current version`,\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tversion()\n\t},\n}\n\n\n\n\nfunc FullVersion() string {\n\tversion := History.CurrentVersion().String()\n\tif commit != \"\" {\n\t\tversion += \"+commit.\" + commit\n\t}\n\tif date != \"\" {\n\t\tversion += \"+date.\" + date\n\t}\n\treturn version\n}\n\nfunc version() ", "output": "{\n\tif commit != \"\" {\n\t\tfmt.Println(\"Git Commit:\", commit)\n\t}\n\tfmt.Println(\"Version:\", FullVersion())\n\tfmt.Println(\"Architecture:\", runtime.GOARCH)\n\tif goversion != \"\" {\n\t\tfmt.Println(\"Go Version:\", goversion)\n\t}\n\tfmt.Println(\"Operating System:\", runtime.GOOS)\n\tif goPath := os.Getenv(\"GOPATH\"); goPath != \"\" {\n\t\tfmt.Printf(\"GOPATH=%s\\n\", goPath)\n\t}\n\tfmt.Printf(\"GOROOT=%s\\n\", runtime.GOROOT())\n}"}
{"input": "package lints\n\n\n\n\n\nimport (\n\t\"github.com/zmap/zcrypto/x509\"\n\t\"github.com/zmap/zlint/util\"\n)\n\ntype caKeyCertSignNotSet struct{}\n\nfunc (l *caKeyCertSignNotSet) Initialize() error {\n\treturn nil\n}\n\nfunc (l *caKeyCertSignNotSet) CheckApplies(c *x509.Certificate) bool {\n\treturn c.IsCA && util.IsExtInCert(c, util.KeyUsageOID)\n}\n\n\n\nfunc init() {\n\tRegisterLint(&Lint{\n\t\tName:          \"e_ca_key_cert_sign_not_set\",\n\t\tDescription:   \"Root CA Certificate: Bit positions for keyCertSign and cRLSign MUST be set.\",\n\t\tCitation:      \"BRs: 7.1.2.1\",\n\t\tSource:        CABFBaselineRequirements,\n\t\tEffectiveDate: util.CABEffectiveDate,\n\t\tLint:          &caKeyCertSignNotSet{},\n\t})\n}\n\nfunc (l *caKeyCertSignNotSet) Execute(c *x509.Certificate) *LintResult ", "output": "{\n\tif c.KeyUsage&x509.KeyUsageCertSign != 0 {\n\t\treturn &LintResult{Status: Pass}\n\t} else {\n\t\treturn &LintResult{Status: Error}\n\t}\n}"}
{"input": "package nosql\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n\t\"net/http\"\n)\n\n\n\n\n\n\ntype UpdateRowRequest struct {\n\n\tTableNameOrId *string `mandatory:\"true\" contributesTo:\"path\" name:\"tableNameOrId\"`\n\n\tUpdateRowDetails `contributesTo:\"body\"`\n\n\tIfMatch *string `mandatory:\"false\" contributesTo:\"header\" name:\"if-match\"`\n\n\tOpcRequestId *string `mandatory:\"false\" contributesTo:\"header\" name:\"opc-request-id\"`\n\n\tRequestMetadata common.RequestMetadata\n}\n\nfunc (request UpdateRowRequest) String() string {\n\treturn common.PointerString(request)\n}\n\n\nfunc (request UpdateRowRequest) HTTPRequest(method, path string, binaryRequestBody *common.OCIReadSeekCloser, extraHeaders map[string]string) (http.Request, error) {\n\n\treturn common.MakeDefaultHTTPRequestWithTaggedStructAndExtraHeaders(method, path, request, extraHeaders)\n}\n\n\nfunc (request UpdateRowRequest) BinaryRequestBody() (*common.OCIReadSeekCloser, bool) {\n\n\treturn nil, false\n\n}\n\n\n\n\n\ntype UpdateRowResponse struct {\n\n\tRawResponse *http.Response\n\n\tUpdateRowResult `presentIn:\"body\"`\n\n\tEtag *string `presentIn:\"header\" name:\"etag\"`\n\n\tOpcRequestId *string `presentIn:\"header\" name:\"opc-request-id\"`\n}\n\nfunc (response UpdateRowResponse) String() string {\n\treturn common.PointerString(response)\n}\n\n\nfunc (response UpdateRowResponse) HTTPResponse() *http.Response {\n\treturn response.RawResponse\n}\n\nfunc (request UpdateRowRequest) RetryPolicy() *common.RetryPolicy ", "output": "{\n\treturn request.RequestMetadata.RetryPolicy\n}"}
{"input": "package persist\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\n\ntype Database struct {\n\tuser     string\n\tpassword string\n\tdatabase string\n\thost     string\n}\n\n\n\n\n\nfunc (db Database) TestConnection() error {\n\tcon, err := db.getConnection()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer con.Close()\n\n\terr = con.Ping()\n\treturn err\n}\n\nfunc (db Database) getConnection() (*sql.DB, error) {\n\tcon, err := sql.Open(\"mysql\", fmt.Sprintf(\"%v:%v@tcp(%v:3306)/%v?parseTime=true\", db.user, db.password, db.host, db.database))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn con, nil\n}\n\n\nfunc (db Database) GetConnectionString() string {\n\treturn fmt.Sprintf(\"Data Source=%s;Database=%s;User ID=%s;Password=%s;Old Guids=true;\", db.host, db.database, db.user, db.password)\n}\n\nfunc NewDatabase(username string, password string, database string, host string) Database ", "output": "{\n\treturn Database{username, password, database, host}\n}"}
{"input": "package models\n\n\n\n\nimport (\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n)\n\n\n\n\ntype IdentityEndpoints struct {\n\n\tIdentity *Identity `json:\"identity,omitempty\"`\n\n\tRefCount int64 `json:\"refCount,omitempty\"`\n}\n\n\n\n\nfunc (m *IdentityEndpoints) validateIdentity(formats strfmt.Registry) error {\n\n\tif swag.IsZero(m.Identity) { \n\t\treturn nil\n\t}\n\n\tif m.Identity != nil {\n\t\tif err := m.Identity.Validate(formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"identity\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n\nfunc (m *IdentityEndpoints) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\nfunc (m *IdentityEndpoints) UnmarshalBinary(b []byte) error {\n\tvar res IdentityEndpoints\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *IdentityEndpoints) Validate(formats strfmt.Registry) error ", "output": "{\n\tvar res []error\n\n\tif err := m.validateIdentity(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}"}
{"input": "package cloudatcost\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype CloudProService struct {\n\tclient *Client\n}\n\nfunc (s *CloudProService) Resources() (*CloudProResourcesData, *http.Response, error) {\n\tu := fmt.Sprintf(\"/api/v1/cloudpro/resources.php?key=%s&login=%s\", s.client.Option.Key, s.client.Option.Login)\n\n\treq, err := s.client.NewRequest(\"GET\", u, nil)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trr := new(CloudProResourcesResponse)\n\tresp, err := s.client.Do(req, rr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\treturn &rr.Data, resp, err\n}\n\nfunc (s *CloudProService) Create(opt *CreateServerOptions) (*CloudProServerResponse, *http.Response, error) {\n\tu := \"/api/v1/cloudpro/build.php\"\n\n\tparameters := url.Values{}\n\tparameters.Add(\"key\", s.client.Option.Key)\n\tparameters.Add(\"login\", s.client.Option.Login)\n\tparameters.Add(\"cpu\", opt.Cpu)\n\tparameters.Add(\"os\", opt.OS)\n\tparameters.Add(\"ram\", opt.Ram)\n\tparameters.Add(\"storage\", opt.Storage)\n\tparameters.Add(\"datacenter\", opt.Datacenter)\n\n\treq, err := s.client.NewFormRequest(\"POST\", u, parameters)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsr := new(CloudProServerResponse)\n\tresp, err := s.client.Do(req, sr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\treturn sr, resp, err\n}\n\n\n\nfunc (s *CloudProService) Delete(sid string) (*CloudProServerResponse, *http.Response, error) ", "output": "{\n\tu := \"/api/v1/cloudpro/delete.php\"\n\n\tparameters := url.Values{}\n\tparameters.Add(\"key\", s.client.Option.Key)\n\tparameters.Add(\"login\", s.client.Option.Login)\n\tparameters.Add(\"sid\", sid)\n\n\treq, err := s.client.NewFormRequest(\"POST\", u, parameters)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsr := new(CloudProServerResponse)\n\tresp, err := s.client.Do(req, sr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\treturn sr, resp, err\n}"}
{"input": "package u\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync/atomic\"\n)\n\n\ntype FileWalkEntry struct {\n\tDir      string\n\tFileInfo os.FileInfo\n}\n\n\nfunc (e *FileWalkEntry) Path() string {\n\treturn filepath.Join(e.Dir, e.FileInfo.Name())\n}\n\n\ntype FileWalk struct {\n\tstartDir    string\n\tFilesChan   chan *FileWalkEntry\n\taskedToStop int32\n}\n\n\nfunc (ft *FileWalk) Stop() {\n\tatomic.StoreInt32(&ft.askedToStop, 1)\n\tfor range ft.FilesChan {\n\t}\n}\n\nfunc fileWalkWorker(ft *FileWalk) {\n\ttoVisit := []string{ft.startDir}\n\tdefer close(ft.FilesChan)\n\n\tfor len(toVisit) > 0 {\n\t\tshouldStop := atomic.LoadInt32(&ft.askedToStop)\n\t\tif shouldStop > 0 {\n\t\t\treturn\n\t\t}\n\t\tdir := toVisit[0]\n\t\ttoVisit = StringsRemoveFirst(toVisit)\n\n\t\tfiles, err := ioutil.ReadDir(dir)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, fi := range files {\n\t\t\tpath := filepath.Join(dir, fi.Name())\n\t\t\tmode := fi.Mode()\n\t\t\tif mode.IsDir() {\n\t\t\t\ttoVisit = append(toVisit, path)\n\t\t\t} else if mode.IsRegular() {\n\t\t\t\tfte := &FileWalkEntry{\n\t\t\t\t\tDir:      dir,\n\t\t\t\t\tFileInfo: fi,\n\t\t\t\t}\n\t\t\t\tft.FilesChan <- fte\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\nfunc StartFileWalk(startDir string) *FileWalk ", "output": "{\n\tch := make(chan *FileWalkEntry, 1024*64)\n\tft := &FileWalk{\n\t\tstartDir:  startDir,\n\t\tFilesChan: ch,\n\t}\n\tgo fileWalkWorker(ft)\n\treturn ft\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSEMRInstanceFleetConfig_SpotProvisioningSpecification struct {\n\n\tBlockDurationMinutes int `json:\"BlockDurationMinutes,omitempty\"`\n\n\tTimeoutAction string `json:\"TimeoutAction,omitempty\"`\n\n\tTimeoutDurationMinutes int `json:\"TimeoutDurationMinutes\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) AWSCloudFormationType() string {\n\treturn \"AWS::EMR::InstanceFleetConfig.SpotProvisioningSpecification\"\n}\n\n\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) SetDependsOn(dependencies []string) {\n\tr._dependsOn = dependencies\n}\n\n\n\n\n\n\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSEMRInstanceFleetConfig_SpotProvisioningSpecification) Metadata() map[string]interface{} ", "output": "{\n\treturn r._metadata\n}"}
{"input": "package upcrm\n\nimport (\n\t\"time\"\n\n\t\"go-common/app/admin/main/up/model/upcrmmodel\"\n)\n\n\nfunc (d *Dao) QueryUpRank(rankType int, date time.Time) (result []upcrmmodel.UpRank, err error) {\n\terr = d.crmdb.Model(&upcrmmodel.UpRank{}).Where(\"type=? and generate_date=?\", rankType, date.Format(upcrmmodel.TimeFmtDate)).Find(&result).Error\n\treturn\n}\n\n\n\n\n\nfunc (d *Dao) GetUpRankLatestDate() (date time.Time, err error) {\n\tvar rankInfo = upcrmmodel.UpRank{}\n\terr = d.crmdb.Model(&rankInfo).Select(\"generate_date\").Order(\"generate_date desc\").Limit(1).Find(&rankInfo).Error\n\tif err == nil {\n\t\tdate, err = time.Parse(time.RFC3339, rankInfo.GenerateDate)\n\t}\n\treturn\n}\n\nfunc (d *Dao) QueryUpRankAll(date time.Time) (result []upcrmmodel.UpRank, err error) ", "output": "{\n\terr = d.crmdb.Model(&upcrmmodel.UpRank{}).Where(\"generate_date=?\", date.Format(upcrmmodel.TimeFmtDate)).Find(&result).Error\n\treturn\n}"}
{"input": "package apis\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/url\"\n)\n\n\n\n\ntype URL url.URL\n\n\nfunc ParseURL(u string) (*URL, error) {\n\tif u == \"\" {\n\t\treturn nil, nil\n\t}\n\tpu, err := url.Parse(u)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn (*URL)(pu), nil\n}\n\n\n\n\n\n\n\n\n\nfunc (u *URL) UnmarshalJSON(b []byte) error {\n\tvar ref string\n\tif err := json.Unmarshal(b, &ref); err != nil {\n\t\treturn err\n\t}\n\tr, err := ParseURL(ref)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*u = *r\n\treturn nil\n}\n\n\nfunc (u *URL) String() string {\n\tif u == nil {\n\t\treturn \"\"\n\t}\n\tuu := url.URL(*u)\n\treturn uu.String()\n}\n\nfunc (u URL) MarshalJSON() ([]byte, error) ", "output": "{\n\tb := fmt.Sprintf(\"%q\", u.String())\n\treturn []byte(b), nil\n}"}
{"input": "package main\n\nimport (\n\t\"emersyx.net/emersyx/api\"\n\t\"github.com/BurntSushi/toml\"\n\tgoirc \"github.com/fluffle/goirc/client\"\n)\n\n\n\ntype ircGateway struct {\n\tapi.PeripheralBase\n\tapi      *goirc.Conn\n\tconfig   *goirc.Config\n\tmessages chan api.Event\n}\n\n\nfunc NewPeripheral(opts api.PeripheralOptions) (api.Peripheral, error) {\n\tvar err error\n\n\tgw := new(ircGateway)\n\tgw.InitializeBase(opts)\n\n\tgw.messages = make(chan api.Event)\n\n\tgw.config = goirc.NewConfig(\"placeholder\")\n\n\tgw.config.Me.Ident = \"emersyx\"\n\tgw.config.Me.Name = \"emersyx\"\n\tgw.config.Version = \"emersyx\"\n\tgw.config.SSL = false\n\tgw.config.QuitMessage = \"bye\"\n\n\tgw.config.NewNick = func(n string) string { return n + \"^\" }\n\n\tconfig := new(ircGatewayConfig)\n\tif _, err = toml.DecodeFile(opts.ConfigPath, config); err != nil {\n\t\treturn nil, err\n\t}\n\tif err = config.validate(); err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.apply(gw)\n\n\tgw.api = goirc.Client(gw.config)\n\n\tgw.initCallbacks()\n\n\tgw.connect()\n\n\treturn gw, nil\n}\n\n\n\n\nfunc (gw *ircGateway) initCallbacks() ", "output": "{\n\tgw.api.HandleFunc(goirc.PRIVMSG, channelCallback(gw))\n\tgw.api.HandleFunc(goirc.JOIN, channelCallback(gw))\n\tgw.api.HandleFunc(goirc.QUIT, channelCallback(gw))\n\tgw.api.HandleFunc(goirc.PART, channelCallback(gw))\n}"}
{"input": "package cli\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n\ntype Float64Flag struct {\n\tName   string\n\tValue  float64\n\tUsage  string\n\tEnvVar string\n\tHide   bool\n}\n\n\n\n\n\nfunc (f Float64Flag) Apply(set *flag.FlagSet) {\n\tif f.EnvVar != \"\" {\n\t\tfor _, envVar := range strings.Split(f.EnvVar, \",\") {\n\t\t\tenvVar = strings.TrimSpace(envVar)\n\t\t\tif envVal := os.Getenv(envVar); envVal != \"\" {\n\t\t\t\tenvValFloat, err := strconv.ParseFloat(envVal, 10)\n\t\t\t\tif err == nil {\n\t\t\t\t\tf.Value = float64(envValFloat)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\teachName(f.Name, func(name string) {\n\t\tset.Float64(name, f.Value, f.Usage)\n\t})\n}\n\nfunc (f Float64Flag) getName() string {\n\treturn f.Name\n}\n\nfunc (f Float64Flag) isNotHidden() bool {\n\treturn !f.Hide\n}\n\nfunc (f Float64Flag) String() string ", "output": "{\n\treturn withEnvHint(f.EnvVar, fmt.Sprintf(\"%s \\\"%v\\\"\\t%v\", prefixedNames(f.Name), f.Value, f.Usage))\n}"}
{"input": "package stack\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\n\t\"github.com/appcelerator/amp/docker/cli/cli/command/bundlefile\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/pflag\"\n)\n\n\n\nfunc addBundlefileFlag(opt *string, flags *pflag.FlagSet) {\n\tflags.StringVar(opt, \"bundle-file\", \"\", \"Path to a Distributed Application Bundle file\")\n\tflags.SetAnnotation(\"bundle-file\", \"experimental\", nil)\n}\n\nfunc addRegistryAuthFlag(opt *bool, flags *pflag.FlagSet) {\n\tflags.BoolVar(opt, \"with-registry-auth\", false, \"Send registry authentication details to Swarm agents\")\n}\n\nfunc loadBundlefile(stderr io.Writer, namespace string, path string) (*bundlefile.Bundlefile, error) {\n\tdefaultPath := fmt.Sprintf(\"%s.dab\", namespace)\n\n\tif path == \"\" {\n\t\tpath = defaultPath\n\t}\n\tif _, err := os.Stat(path); err != nil {\n\t\treturn nil, errors.Errorf(\n\t\t\t\"Bundle %s not found. Specify the path with --file\",\n\t\t\tpath)\n\t}\n\n\tfmt.Fprintf(stderr, \"Loading bundle from %s\\n\", path)\n\treader, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer reader.Close()\n\n\tbundle, err := bundlefile.LoadFile(reader)\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"Error reading %s: %v\\n\", path, err)\n\t}\n\treturn bundle, err\n}\n\nfunc addComposefileFlag(opt *string, flags *pflag.FlagSet) ", "output": "{\n\tflags.StringVarP(opt, \"compose-file\", \"c\", \"\", \"Path to a Compose file\")\n\tflags.SetAnnotation(\"compose-file\", \"version\", []string{\"1.25\"})\n}"}
{"input": "package client\n\nimport \"fmt\"\n\ntype Position struct {\n\tcommitPosition  int64\n\tpreparePosition int64\n}\n\nvar Position_Start = &Position{0, 0}\nvar Position_End = &Position{-1, -1}\n\nfunc NewPosition(commitPosition int64, preparePosition int64) *Position {\n\tif commitPosition < preparePosition {\n\t\tpanic(fmt.Sprintf(\"The commit position cannot be less than the prepare position (%d < %d)\", commitPosition,\n\t\t\tpreparePosition))\n\t}\n\treturn &Position{commitPosition, preparePosition}\n}\n\n\n\nfunc (p *Position) PreparePosition() int64 {\n\treturn p.preparePosition\n}\n\nfunc (p *Position) Equals(p2 *Position) bool {\n\treturn p.commitPosition == p2.commitPosition && p.preparePosition == p2.preparePosition\n}\n\nfunc (p *Position) GreaterThan(p2 *Position) bool {\n\treturn p.commitPosition > p2.commitPosition ||\n\t\t(p.commitPosition == p2.commitPosition && p.preparePosition > p2.preparePosition)\n}\n\nfunc (p *Position) GreaterThanOrEquals(p2 *Position) bool {\n\treturn p.GreaterThan(p2) || p.Equals(p2)\n}\n\nfunc (p *Position) CommitPosition() int64 ", "output": "{\n\treturn p.commitPosition\n}"}
{"input": "package builders\n\nimport (\n\t\"time\"\n\n\t\"github.com/docker/docker/api/types\"\n)\n\n\n\nfunc Container(name string, builders ...func(container *types.Container)) *types.Container {\n\tcontainer := &types.Container{\n\t\tID:      \"container_id\",\n\t\tNames:   []string{\"/\" + name},\n\t\tCommand: \"top\",\n\t\tImage:   \"busybox:latest\",\n\t\tStatus:  \"Up 1 second\",\n\t\tCreated: time.Now().Unix(),\n\t}\n\n\tfor _, builder := range builders {\n\t\tbuilder(container)\n\t}\n\n\treturn container\n}\n\n\nfunc WithLabel(key, value string) func(*types.Container) {\n\treturn func(c *types.Container) {\n\t\tif c.Labels == nil {\n\t\t\tc.Labels = map[string]string{}\n\t\t}\n\t\tc.Labels[key] = value\n\t}\n}\n\n\nfunc WithName(name string) func(*types.Container) {\n\treturn func(c *types.Container) {\n\t\tc.Names = append(c.Names, \"/\"+name)\n\t}\n}\n\n\nfunc WithPort(privateport, publicport uint16, builders ...func(*types.Port)) func(*types.Container) {\n\treturn func(c *types.Container) {\n\t\tif c.Ports == nil {\n\t\t\tc.Ports = []types.Port{}\n\t\t}\n\t\tport := &types.Port{\n\t\t\tPrivatePort: privateport,\n\t\t\tPublicPort:  publicport,\n\t\t}\n\t\tfor _, builder := range builders {\n\t\t\tbuilder(port)\n\t\t}\n\t\tc.Ports = append(c.Ports, *port)\n\t}\n}\n\n\n\n\n\nfunc TCP(p *types.Port) {\n\tp.Type = \"tcp\"\n}\n\n\nfunc UDP(p *types.Port) {\n\tp.Type = \"udp\"\n}\n\nfunc IP(ip string) func(*types.Port) ", "output": "{\n\treturn func(p *types.Port) {\n\t\tp.IP = ip\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/beyang/hgo/changelog\"\n\t\"github.com/beyang/hgo/revlog\"\n\t\"github.com/beyang/hgo/store\"\n)\n\nvar cmdManifest = &Command{\n\tUsageLine: \"manifest [-R dir] [-r rev]\",\n\tShort:     \"show the project's manifest\",\n\tLong:      ``,\n}\n\nfunc init() {\n\taddStdFlags(cmdManifest)\n\taddRevFlag(cmdManifest)\n\tcmdManifest.Run = runManifest\n}\n\nfunc runManifest(cmd *Command, w io.Writer, args []string) {\n\topenRepository(args)\n\trs := getRevisionSpec()\n\tb := revlog.NewFileBuilder()\n\tc, err := getChangeset(rs, b)\n\tif err != nil {\n\t\tfatalf(\"%s\", err)\n\t}\n\tmm, err := getManifest(int(c.Linkrev), c.ManifestNode, b)\n\tif err != nil {\n\t\tfatalf(\"%s\", err)\n\t}\n\tfor i := range mm {\n\t\tfmt.Fprintln(w, mm[i].FileName)\n\t}\n}\n\n\n\nfunc getManifest(linkrev int, id revlog.NodeId, b *revlog.FileBuilder) (m store.Manifest, err error) {\n\tst := repo.NewStore()\n\tmlog, err := st.OpenManifests()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tr, err := mlog.LookupRevision(linkrev, id)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tm, err = store.BuildManifest(r, b)\n\treturn\n}\n\nfunc getChangeset(rs revlog.RevisionSpec, b *revlog.FileBuilder) (c *changelog.Entry, err error) ", "output": "{\n\tst := repo.NewStore()\n\tclIndex, err := st.OpenChangeLog()\n\tif err != nil {\n\t\treturn\n\t}\n\tr, err := rs.Lookup(clIndex)\n\tif err != nil {\n\t\treturn\n\t}\n\tc, err = changelog.BuildEntry(r, b)\n\tif err == nil {\n\t\tc.Rec = r\n\t}\n\treturn\n}"}
{"input": "package registry\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/blevesearch/bleve/analysis\"\n)\n\nfunc RegisterTokenizer(name string, constructor TokenizerConstructor) {\n\t_, exists := tokenizers[name]\n\tif exists {\n\t\tpanic(fmt.Errorf(\"attempted to register duplicate tokenizer named '%s'\", name))\n\t}\n\ttokenizers[name] = constructor\n}\n\ntype TokenizerConstructor func(config map[string]interface{}, cache *Cache) (analysis.Tokenizer, error)\ntype TokenizerRegistry map[string]TokenizerConstructor\ntype TokenizerCache map[string]analysis.Tokenizer\n\nfunc (c TokenizerCache) TokenizerNamed(name string, cache *Cache) (analysis.Tokenizer, error) {\n\ttokenizer, cached := c[name]\n\tif cached {\n\t\treturn tokenizer, nil\n\t}\n\ttokenizerConstructor, registered := tokenizers[name]\n\tif !registered {\n\t\treturn nil, fmt.Errorf(\"no tokenizer with name or type '%s' registered\", name)\n\t}\n\ttokenizer, err := tokenizerConstructor(nil, cache)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error building tokenizer '%s': %v\", name, err)\n\t}\n\tc[name] = tokenizer\n\treturn tokenizer, nil\n}\n\n\n\nfunc TokenizerTypesAndInstances() ([]string, []string) {\n\temptyConfig := map[string]interface{}{}\n\temptyCache := NewCache()\n\ttypes := make([]string, 0)\n\tinstances := make([]string, 0)\n\tfor name, cons := range tokenizers {\n\t\t_, err := cons(emptyConfig, emptyCache)\n\t\tif err == nil {\n\t\t\tinstances = append(instances, name)\n\t\t} else {\n\t\t\ttypes = append(types, name)\n\t\t}\n\t}\n\treturn types, instances\n}\n\nfunc (c TokenizerCache) DefineTokenizer(name string, typ string, config map[string]interface{}, cache *Cache) (analysis.Tokenizer, error) ", "output": "{\n\t_, cached := c[name]\n\tif cached {\n\t\treturn nil, fmt.Errorf(\"tokenizer named '%s' already defined\", name)\n\t}\n\ttokenizerConstructor, registered := tokenizers[typ]\n\tif !registered {\n\t\treturn nil, fmt.Errorf(\"no tokenizer type '%s' registered\", typ)\n\t}\n\ttokenizer, err := tokenizerConstructor(config, cache)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error building tokenizer '%s': %v\", name, err)\n\t}\n\tc[name] = tokenizer\n\treturn tokenizer, nil\n}"}
{"input": "package runcmd\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\n\t\"github.com/visualfc/gotools/pkg/command\"\n)\n\nvar Command = &command.Command{\n\tRun:       runCmd,\n\tUsageLine: \"runcmd [-w work_path] <program_name> [arguments...]\",\n\tShort:     \"run program\",\n\tLong:      `run program and arguments`,\n}\n\nvar execWorkPath string\nvar execWaitEnter bool\n\n\n\nfunc runCmd(cmd *command.Command, args []string) error {\n\tif len(args) == 0 {\n\t\tcmd.Usage()\n\t\treturn os.ErrInvalid\n\t}\n\tif execWorkPath == \"\" {\n\t\tvar err error\n\t\texecWorkPath, err = os.Getwd()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfileName := args[0]\n\n\tfilePath, err := exec.LookPath(fileName)\n\tif err != nil {\n\t\tfilePath, err = exec.LookPath(\"./\" + fileName)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Println(\"Starting Process\", filePath, strings.Join(args[1:], \" \"), \"...\")\n\n\tcommand := exec.Command(filePath, args[1:]...)\n\tcommand.Dir = execWorkPath\n\tcommand.Stdin = os.Stdin\n\tcommand.Stdout = os.Stdout\n\tcommand.Stderr = os.Stderr\n\n\terr = command.Run()\n\n\tif err != nil {\n\t\tfmt.Println(\"\\nEnd Process\", err)\n\t} else {\n\t\tfmt.Println(\"\\nEnd Process\", \"exit status 0\")\n\t}\n\n\texitWaitEnter()\n\treturn nil\n}\n\nfunc exitWaitEnter() {\n\tif !execWaitEnter {\n\t\treturn\n\t}\n\tfmt.Println(\"\\nPress enter key to continue\")\n\tvar s = [256]byte{}\n\tos.Stdin.Read(s[:])\n}\n\nfunc init() ", "output": "{\n\tCommand.Flag.StringVar(&execWorkPath, \"w\", \"\", \"work path\")\n\tCommand.Flag.BoolVar(&execWaitEnter, \"e\", true, \"wait enter and continue\")\n}"}
{"input": "package util\n\nconst (\n\tDefaultPerPage = 20\n)\n\n\n\nfunc (p *Pagination) SimplePage() (from int64, to int64) {\n\tif p.CurPage == 0 || p.PerPage == 0 {\n\t\tp.CurPage, p.PerPage = 1, DefaultPerPage\n\t}\n\tfrom = (p.CurPage-1)*p.PerPage + 1\n\tto = from + p.PerPage - 1\n\treturn\n}\n\n\n\n\n\n\nfunc (p *Pagination) VagueOffsetLimit() (offset int64, limit int64) {\n\tfrom, to := p.SimplePage()\n\tif to == 0 || from == 0 {\n\t\treturn 0, 0\n\t}\n\treturn from - 1, to - from + 1\n}\n\n\nfunc (p *Pagination) OffsetLimit(total int64) (offset int64, limit int64) {\n\tfrom, to := p.Page(total)\n\tif to == 0 || from == 0 {\n\t\treturn 0, 0\n\t}\n\treturn from - 1, to - from + 1\n}\n\n\ntype Pagination struct {\n\tCurPage int64\n\tPerPage int64\n}\n\nfunc (p *Pagination) Page(total int64) (from int64, to int64) ", "output": "{\n\tif p.CurPage == 0 {\n\t\tp.CurPage = 1\n\t}\n\tif p.PerPage == 0 {\n\t\tp.PerPage = DefaultPerPage\n\t}\n\n\tif total == 0 || total < p.PerPage*(p.CurPage-1) {\n\t\treturn\n\t}\n\tif total <= p.PerPage {\n\t\treturn 1, total\n\t}\n\tfrom = (p.CurPage-1)*p.PerPage + 1\n\tif (total - from + 1) < p.PerPage {\n\t\treturn from, total\n\t}\n\treturn from, from + p.PerPage - 1\n}"}
{"input": "package crypto\n\nimport (\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n)\n\n\n\nfunc TestCrypto(t *testing.T) ", "output": "{\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Crypto Suite\")\n}"}
{"input": "package jiffybox\n\nimport (\n\t\"strconv\"\n\t\"time\"\n)\n\ntype Backup struct {\n\tServerId int\n\tKey      string\n\tId       string `json:\"id\"`\n\tCreated  int64  `json:\"created\"`\n}\n\nfunc (backup *Backup) CreatedAt() time.Time {\n\treturn time.Unix(backup.Created, 0)\n}\n\ntype BackupsResponse struct {\n\tMessage []*Message                    `json:\"message\"`\n\tResult  map[string]map[string]*Backup `json:\"result\"`\n}\n\n\n\nfunc (client *Client) Backups() (backups []*Backup, e error) {\n\trsp := &BackupsResponse{}\n\te = client.LoadResource(\"backups\", rsp)\n\tif e != nil {\n\t\treturn backups, e\n\t}\n\tfor server, backupsHash := range rsp.Result {\n\t\tfor key, backup := range backupsHash {\n\t\t\tbackup.ServerId, _ = strconv.Atoi(server)\n\t\t\tbackup.Key = key\n\t\t\tbackups = append(backups, backup)\n\t\t}\n\t}\n\treturn backups, e\n}\n\ntype BackupsForServerResponse struct {\n\tMessage []*Message         `json:\"message\"`\n\tResult  map[string]*Backup `json:\"result\"`\n}\n\nfunc (client *Client) BackupsForServer(id int) (backups []*Backup, e error) {\n\trsp := BackupsForServerResponse{}\n\te = client.LoadResource(client.BaseUrl()+\"/backups/\"+strconv.Itoa(id), rsp)\n\tif e != nil {\n\t\treturn backups, e\n\t}\n\tfor key, backup := range rsp.Result {\n\t\tbackup.ServerId = id\n\t\tbackup.Key = key\n\t\tbackups = append(backups, backup)\n\t}\n\treturn backups, e\n}\n\nfunc (client *Client) CreateBackup(id int) error ", "output": "{\n\thttpResponse, e := client.PostForm(\"backups/\"+strconv.Itoa(id), nil)\n\tdefer httpResponse.Response.Body.Close()\n\tif e != nil {\n\t\treturn e\n\t}\n\tdefer httpResponse.Response.Body.Close()\n\trsp := &ErrorResponse{}\n\te = client.unmarshal(httpResponse.Content, rsp)\n\tif e != nil {\n\t\treturn e\n\t}\n\treturn nil\n}"}
{"input": "package main\n\nimport (\n\t\"bufio\"\n\t\"flag\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n\n\nfunc main() {\n\tvar path, method string\n\tflag.StringVar(&path, \"f\", \"\", \"Specify the file name or path name to be processed\")\n\tflag.StringVar(&method, \"m\", \"unescape\", \"Specify the operation: \\\"escape\\\" or \\\"unescape\\\"\")\n\tflag.Parse()\n\n\tvar convert = func(string) string { return \"\" }\n\tswitch method {\n\tcase \"escape\":\n\t\tconvert = url.QueryEscape\n\tcase \"unescape\":\n\t\tconvert = unescape\n\tdefault:\n\t\tfmt.Println(\"Unknown operation:\", method)\n\t\treturn\n\t}\n\n\tpargs := flag.Args()\n\tif len(pargs) != 0 {\n\t\tpath = pargs[0]\n\t}\n\n\tif len(path) == 0 {\n\t\tstdin := bufio.NewReader(os.Stdin)\n\t\tvar line string\n\t\tvar err error\n\n\t\tfor {\n\t\t\tif line, err = stdin.ReadString('\\n'); err == nil {\n\t\t\t\tfmt.Println(convert(strings.TrimSuffix(line, \"\\r\\n\")))\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif _, err := os.Stat(path); err != nil {\n\t\t\tfmt.Printf(\"File or path \\\"%s\\\" doesn't exist.\\n\", path)\n\t\t\treturn\n\t\t}\n\n\t\thead, tail := filepath.Split(path)\n\t\tnewpath := filepath.Join(head, convert(tail))\n\t\tif newpath != path {\n\t\t\tos.Rename(path, newpath)\n\t\t\tfmt.Println(path, \"->\", newpath)\n\t\t}\n\t}\n}\n\nfunc unescape(s string) string ", "output": "{\n\tnormname, err := url.QueryUnescape(s)\n\tif err == nil {\n\t\treturn normname\n\t} else {\n\t\tfmt.Println(err)\n\t\treturn s\n\t}\n}"}
{"input": "package dockertools\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\tdocker \"github.com/fsouza/go-dockerclient\"\n\tkubecontainer \"k8s.io/kubernetes/pkg/kubelet/container\"\n\tkubetypes \"k8s.io/kubernetes/pkg/kubelet/types\"\n)\n\n\n\n\nfunc mapStatus(status string) kubecontainer.ContainerStatus {\n\tswitch {\n\tcase strings.HasPrefix(status, \"Up\"):\n\t\treturn kubecontainer.ContainerStatusRunning\n\tcase strings.HasPrefix(status, \"Exited\"):\n\t\treturn kubecontainer.ContainerStatusExited\n\tdefault:\n\t\treturn kubecontainer.ContainerStatusUnknown\n\t}\n}\n\n\nfunc toRuntimeContainer(c *docker.APIContainers) (*kubecontainer.Container, error) {\n\tif c == nil {\n\t\treturn nil, fmt.Errorf(\"unable to convert a nil pointer to a runtime container\")\n\t}\n\n\tdockerName, hash, err := getDockerContainerNameInfo(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &kubecontainer.Container{\n\t\tID:      kubetypes.DockerID(c.ID).ContainerID(),\n\t\tName:    dockerName.ContainerName,\n\t\tImage:   c.Image,\n\t\tHash:    hash,\n\t\tCreated: c.Created,\n\t\tStatus:  mapStatus(c.Status),\n\t}, nil\n}\n\n\n\n\nfunc toRuntimeImage(image *docker.APIImages) (*kubecontainer.Image, error) ", "output": "{\n\tif image == nil {\n\t\treturn nil, fmt.Errorf(\"unable to convert a nil pointer to a runtime image\")\n\t}\n\n\treturn &kubecontainer.Image{\n\t\tID:   image.ID,\n\t\tTags: image.RepoTags,\n\t\tSize: image.VirtualSize,\n\t}, nil\n}"}
{"input": "package main\n\nimport (\n\t\"github.com/facchinm/go-serial\"\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc infoHandler(c *gin.Context) {\n\tc.JSON(200, gin.H{\n\t\t\"version\": version,\n\t\t\"http\":    \"http://\" + *requestAddress + port,\n\t\t\"https\":   \"https://\" + *requestAddress + portSSL,\n\t\t\"ws\":      \"ws://\" + *requestAddress + port,\n\t\t\"wss\":     \"wss://\"+*requestAddress + portSSL,\n\t\t\"company\": \"nuoding\",\n\t})\n}\n\n\n\nfunc pauseHandler(c *gin.Context) ", "output": "{\n\tgo func() {\n\t\tports, _ := serial.GetPortsList()\n\t\tfor _, element := range ports {\n\t\t\tspClose(element)\n\t\t}\n\t\t*hibernate = true\n\t\trestart(\"\")\n\t}()\n\tc.JSON(200, nil)\n}"}
{"input": "package assert\n\nimport (\n\t\"io/ioutil\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t_ \"github.com/ToQoz/gopwt/translatedassert\" \n)\n\ntype testingInterface interface {\n\tError(args ...interface{})\n\tSkip(args ...interface{})\n}\n\n\n\nfunc OK(t *testing.T, ok bool, messages ...string) {\n\t_ok(t, ok, callerLine(1), messages...)\n}\n\nfunc _ok(t testingInterface, ok bool, callerLine string, messages ...string) {\n\tif ok {\n\t\treturn\n\t}\n\n\tmsg := `[FAIL Assertion] ` + callerLine + `\n\nPlease call gopwt.Empower() in your TestMain(t *testing.M). It give you power.\nIf you need more information, see http://github.com/ToQoz/gopwt\n`\n\n\tif len(messages) > 0 {\n\t\tmsg += \"\\nAssertionMessage:\\n\"\n\t\tfor _, m := range messages {\n\t\t\tmsg += \"\\t- \" + m\n\t\t}\n\t}\n\n\tt.Error(msg)\n}\n\n\n\n\nfunc Require(t *testing.T, ok bool, messages ...string) {\n\t_require(t, ok, callerLine(1), messages...)\n}\n\n\n\nfunc callerLine(skip int) string {\n\t_, file, lnum, ok := runtime.Caller(skip + 1)\n\n\tif !ok {\n\t\treturn \"\"\n\t}\n\n\tb, err := ioutil.ReadFile(file)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\ts := strings.Split(string(b), \"\\n\")\n\tif len(s) <= lnum-1 {\n\t\treturn \"\"\n\t}\n\n\treturn strings.Trim(strings.Trim(s[lnum-1], \" \\n\\t\"), \"\\r\\n\")\n}\n\nfunc _require(t testingInterface, ok bool, callerLine string, messages ...string) ", "output": "{\n\tif ok {\n\t\treturn\n\t}\n\n\tmsg := `[FAIL Assertion] ` + callerLine + `\n\nPlease call gopwt.Empower() in your TestMain(t *testing.M). It give you power.\nIf you need more information, see http://github.com/ToQoz/gopwt\n`\n\n\tif len(messages) > 0 {\n\t\tmsg += \"\\nAssertionMessage:\\n\"\n\t\tfor _, m := range messages {\n\t\t\tmsg += \"\\t- \" + m\n\t\t}\n\t}\n\n\tt.Error(msg)\n\tt.Skip(\"skip by gopwt/assert.Require\")\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc findProcess(name string) bool {\n\tname = fmt.Sprintf(\"[%c]%s\", name[0], name[1:])\n\tc := exec.Command(\"bash\", \"-c\", fmt.Sprintf(\"ps -eo command | grep %s\", strconv.Quote(name)))\n\toutput, err := c.CombinedOutput()\n\tif err == nil {\n\t\tSo(string(output), ShouldNotEqual, \"\")\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n\nfunc TestStopCommand(t *testing.T) ", "output": "{\n\tConvey(\"Stop command should clean up all program\", t, func() {\n\t\tp := NewProcess(Program{\n\t\t\tName:        \"sleep\",\n\t\t\tCommand:     \"(echo hello; sleep 17&); exit 1\",\n\t\t\tStopTimeout: 1,\n\t\t})\n\t\tp.startCommand()\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tp.stopCommand()\n\t\tSo(p.cmd, ShouldBeNil)\n\t\texists := findProcess(\"sleep 17\")\n\t\tSo(exists, ShouldBeFalse)\n\t})\n}"}
{"input": "package s3afero\n\nimport (\n\t\"crypto/md5\"\n\t\"io\"\n\t\"path/filepath\"\n\n\t\"github.com/spf13/afero\"\n)\n\n\n\nfunc hashFile(fs afero.Fs, path string) (hash []byte, err error) ", "output": "{\n\tf, err := fs.Open(filepath.FromSlash(path))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\th := md5.New()\n\tio.Copy(h, f)\n\treturn h.Sum(nil), nil\n}"}
{"input": "package character\n\ntype Histogram struct {\n\tcounts [256]uint16\n}\n\nfunc StringHistogram(text string) *Histogram {\n\thistogram := &Histogram{}\n\tfor i := 0; i < len(text); i++ {\n\t\thistogram.Add(Char(text[i]))\n\t}\n\treturn histogram\n}\n\n\n\nfunc (h *Histogram) Count(char Char) int {\n\treturn int(h.counts[char])\n}\n\nfunc (h *Histogram) Add(char Char) ", "output": "{\n\th.counts[char]++\n}"}
{"input": "package ast\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype StructTypeSpecTestSuite struct {\n\tsuite.Suite\n}\n\nfunc TestStructTypeSpecTestSuite(t *testing.T) {\n\tsuite.Run(t, new(StructTypeSpecTestSuite))\n}\n\n\n\nfunc (s *StructTypeSpecTestSuite) TestName() ", "output": "{\n\tspec, err := FindJSONStructFor(\"github.com/marcel/jitjson/fixtures/media\", \"Album\")\n\ts.Nil(err)\n\n\ts.Equal(\"Album\", spec.Name())\n}"}
{"input": "package cli\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/alexyer/ghost/client\"\n)\n\n\n\nfunc ObtainClient(host string, port int) (*client.GhostClient, error) {\n\taddr := fmt.Sprintf(\"%s:%d\", host, port)\n\treturn connect(addr, \"tcp\")\n}\n\n\nfunc ObtainUnixSocketClient(socket string) (*client.GhostClient, error) {\n\treturn connect(socket, \"unix\")\n}\n\n\n\nfunc connect(addr, network string) (*client.GhostClient, error) ", "output": "{\n\tc := client.New(&client.Options{\n\t\tAddr:    addr,\n\t\tNetwork: network,\n\t})\n\n\tif _, err := c.Ping(); err != nil {\n\t\treturn nil, errors.New(fmt.Sprintf(\"cli-ghost: cannot obtain connection to %s\", addr))\n\t}\n\n\tlog.Printf(\"Connection to %s is successfull.\", addr)\n\treturn c, nil\n}"}
{"input": "package geom\n\nimport \"math\"\n\n\ntype Vertex struct {\n\tX, Y float64\n}\n\n\ntype Vertices []Vertex\n\n\nfunc (l Vertices) Convert() (data []float32) {\n\n\tdata = make([]float32, len(l)*2)\n\tfor i, v := range l {\n\t\tindex := i * 2\n\t\tdata[index] = float32(v.X)\n\t\tdata[index+1] = float32(v.Y)\n\t}\n\treturn\n}\n\n\n\n\n\ntype Lexographically []Vertex\n\nfunc (a Lexographically) Len() int      { return len(a) }\nfunc (a Lexographically) Swap(i, j int) { a[i], a[j] = a[j], a[i] }\nfunc (a Lexographically) Less(i, j int) bool {\n\tif a[i].X == a[j].X {\n\t\treturn a[i].Y < a[j].Y\n\t}\n\treturn a[i].X < a[j].X\n}\n\nfunc (c Vertex) SideOfLine(a Vertex, b Vertex) int ", "output": "{\n\n\tcross := float64((b.X-a.X)*(c.Y-a.Y) - (b.Y-a.Y)*(c.X-a.X))\n\n\tif cross == 0 {\n\t\treturn 0\n\t}\n\tif math.Signbit(cross) {\n\t\treturn 1\n\t}\n\treturn -1\n\n}"}
{"input": "package fdlimit\n\nimport \"syscall\"\n\n\n\n\n\n\n\n\n\n\n\nfunc Current() (int, error) {\n\tvar limit syscall.Rlimit\n\tif err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &limit); err != nil {\n\t\treturn 0, err\n\t}\n\treturn int(limit.Cur), nil\n}\n\n\n\nfunc Maximum() (int, error) {\n\tvar limit syscall.Rlimit\n\tif err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &limit); err != nil {\n\t\treturn 0, err\n\t}\n\treturn int(limit.Max), nil\n}\n\nfunc Raise(max uint64) error ", "output": "{\n\tvar limit syscall.Rlimit\n\tif err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &limit); err != nil {\n\t\treturn err\n\t}\n\tlimit.Cur = limit.Max\n\tif limit.Cur > int64(max) {\n\t\tlimit.Cur = int64(max)\n\t}\n\tif err := syscall.Setrlimit(syscall.RLIMIT_NOFILE, &limit); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package cmd\n\nimport (\n\t\"github.com/minio/minio/pkg/bucket/lifecycle\"\n)\n\nconst (\n\tDisabled = \"Disabled\"\n)\n\n\ntype LifecycleSys struct{}\n\n\nfunc (sys *LifecycleSys) Get(bucketName string) (lc *lifecycle.Lifecycle, err error) {\n\tif globalIsGateway {\n\t\tobjAPI := newObjectLayerWithoutSafeModeFn()\n\t\tif objAPI == nil {\n\t\t\treturn nil, errServerNotInitialized\n\t\t}\n\n\t\treturn nil, BucketLifecycleNotFound{Bucket: bucketName}\n\t}\n\n\treturn globalBucketMetadataSys.GetLifecycleConfig(bucketName)\n}\n\n\n\n\nfunc NewLifecycleSys() *LifecycleSys ", "output": "{\n\treturn &LifecycleSys{}\n}"}
{"input": "package aws\n\nimport (\n\t\"github.com/aws/aws-sdk-go/aws/ec2metadata\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n)\n\ntype MetaDataClient struct {\n\tsvc *ec2metadata.EC2Metadata\n}\n\nfunc NewMetaDataClient() *MetaDataClient {\n\treturn &MetaDataClient{svc: ec2metadata.New(session.New())}\n}\n\nfunc NewMetaDataClientFromSession(s *session.Session) *MetaDataClient {\n\treturn &MetaDataClient{svc: ec2metadata.New(s)}\n}\n\n\n\nfunc (c *MetaDataClient) GetRegion() (string, error) {\n\treturn c.svc.Region()\n}\n\nfunc (c *MetaDataClient) GetInstanceID() (string, error) ", "output": "{\n\treturn c.svc.GetMetadata(\"instance-id\")\n}"}
{"input": "package devicemapper\n\n\nimport \"C\"\n\n\nconst LibraryDeferredRemovalSupport = true\n\n\n\nfunc dmTaskGetInfoWithDeferredFct(task *cdmTask, info *Info) int {\n\tCinfo := C.struct_dm_info{}\n\tdefer func() {\n\t\tinfo.Exists = int(Cinfo.exists)\n\t\tinfo.Suspended = int(Cinfo.suspended)\n\t\tinfo.LiveTable = int(Cinfo.live_table)\n\t\tinfo.InactiveTable = int(Cinfo.inactive_table)\n\t\tinfo.OpenCount = int32(Cinfo.open_count)\n\t\tinfo.EventNr = uint32(Cinfo.event_nr)\n\t\tinfo.Major = uint32(Cinfo.major)\n\t\tinfo.Minor = uint32(Cinfo.minor)\n\t\tinfo.ReadOnly = int(Cinfo.read_only)\n\t\tinfo.TargetCount = int32(Cinfo.target_count)\n\t\tinfo.DeferredRemove = int(Cinfo.deferred_remove)\n\t}()\n\treturn int(C.dm_task_get_info((*C.struct_dm_task)(task), &Cinfo))\n}\n\nfunc dmTaskDeferredRemoveFct(task *cdmTask) int ", "output": "{\n\treturn int(C.dm_task_deferred_remove((*C.struct_dm_task)(task)))\n}"}
{"input": "package dns\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient {\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}\n\nfunc New(subscriptionID string) BaseClient ", "output": "{\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}"}
{"input": "package pet\n\n\n\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n\tgolangswaggerpaths \"path\"\n)\n\n\ntype UpdatePetURL struct {\n\t_basePath string\n}\n\n\n\n\nfunc (o *UpdatePetURL) WithBasePath(bp string) *UpdatePetURL {\n\to.SetBasePath(bp)\n\treturn o\n}\n\n\n\n\nfunc (o *UpdatePetURL) SetBasePath(bp string) {\n\to._basePath = bp\n}\n\n\nfunc (o *UpdatePetURL) Build() (*url.URL, error) {\n\tvar _result url.URL\n\n\tvar _path = \"/pets\"\n\n\t_basePath := o._basePath\n\tif _basePath == \"\" {\n\t\t_basePath = \"/v2\"\n\t}\n\t_result.Path = golangswaggerpaths.Join(_basePath, _path)\n\n\treturn &_result, nil\n}\n\n\nfunc (o *UpdatePetURL) Must(u *url.URL, err error) *url.URL {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif u == nil {\n\t\tpanic(\"url can't be nil\")\n\t}\n\treturn u\n}\n\n\nfunc (o *UpdatePetURL) String() string {\n\treturn o.Must(o.Build()).String()\n}\n\n\n\n\n\nfunc (o *UpdatePetURL) StringFull(scheme, host string) string {\n\treturn o.Must(o.BuildFull(scheme, host)).String()\n}\n\nfunc (o *UpdatePetURL) BuildFull(scheme, host string) (*url.URL, error) ", "output": "{\n\tif scheme == \"\" {\n\t\treturn nil, errors.New(\"scheme is required for a full url on UpdatePetURL\")\n\t}\n\tif host == \"\" {\n\t\treturn nil, errors.New(\"host is required for a full url on UpdatePetURL\")\n\t}\n\n\tbase, err := o.Build()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbase.Scheme = scheme\n\tbase.Host = host\n\treturn base, nil\n}"}
{"input": "package bitcoin\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestKeys(t *testing.T) ", "output": "{\n\tvar prv *PrivateKey\n\tfor i := 0; i < 32; i++ {\n\t\tprv = GenerateKeys(i&1 == 1)\n\t\tb := prv.Bytes()\n\t\tif _, err := PrivateKeyFromBytes(b); err != nil {\n\t\t\tt.Fatal(\"PrivateKeyFromBytes failed\")\n\t\t}\n\t\tb = prv.PublicKey.Bytes()\n\t\tif _, err := PublicKeyFromBytes(b); err != nil {\n\t\t\tt.Fatal(\"PublicKeyFromBytes failed\")\n\t\t}\n\t\tpnt := prv.Q\n\t\ttst := MultBase(prv.D)\n\t\tif !(pnt.IsOnCurve() && pnt.Equals(tst)) {\n\t\t\tt.Fatal(\"public point failed\")\n\t\t}\n\t}\n}"}
{"input": "package network\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc UserAgent() string {\n\treturn \"Azure-SDK-For-Go/\" + Version() + \" network/2017-10-01\"\n}\n\n\n\n\nfunc Version() string ", "output": "{\n\treturn version.Number\n}"}
{"input": "package util\n\nimport (\n\t\"gopkg.in/cheggaaa/pb.v1\"\n\t\"io\"\n)\n\n\n\ntype writeCounter struct {\n\tcurrent int64 \n\ttotal   int64 \n\tbar     *pb.ProgressBar\n}\n\nfunc newWriteCounter(total int64) *writeCounter {\n\treturn &writeCounter{\n\t\ttotal: total,\n\t\tbar:   pb.StartNew(int(total)),\n\t}\n}\n\n\n\n\nfunc (wc *writeCounter) Write(p []byte) (int, error) {\n\tn := len(p)\n\twc.current += int64(n)\n\twc.bar.Set(int(wc.current))\n\tif wc.current >= wc.total-1 {\n\t\twc.bar.FinishPrint(\"download complete\")\n\t}\n\treturn n, nil\n}\n\n\n\nfunc ReaderWithProgress(r io.Reader, total int64) io.Reader ", "output": "{\n\treturn io.TeeReader(r, newWriteCounter(total))\n}"}
{"input": "package version_test\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"regexp\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/speedflow/speedflow/pkg/version\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestVersionDateSuccess(t *testing.T) {\n\tversion.RawDate = \"1987-01-16T09:00:00Z\"\n\n\td, err := version.Date()\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, d.Year(), 1987)\n\tassert.Equal(t, d.Month(), time.January)\n\tassert.Equal(t, d.Day(), 16)\n}\n\nfunc TestPrintVersionJSON(t *testing.T) {\n\tvar r *regexp.Regexp\n\tw := &bytes.Buffer{}\n\n\tversion.Print(w, \"json\")\n\tr = regexp.MustCompile(`{\"version\":\"dev\",\"commit\":\"n/a\",\"date\":\"[0-9T:Z-]+\"}`)\n\tassert.Regexp(t, r, w.String())\n}\n\nfunc TestPrintVersionYAML(t *testing.T) {\n\tvar r *regexp.Regexp\n\tw := &bytes.Buffer{}\n\n\tversion.Print(w, \"yaml\")\n\tr = regexp.MustCompile(`version: dev\\ncommit: n/a\\ndate: \"[0-9T:Z-]+\"\\n`)\n\tassert.Regexp(t, r, w.String())\n}\n\nfunc TestPrintVersionText(t *testing.T) {\n\tvar r *regexp.Regexp\n\tw := &bytes.Buffer{}\n\n\tversion.Print(w, \"\")\n\tr = regexp.MustCompile(`Version:\\s+dev\\nCommit:\\s+n/a\\nBuild date:\\s+[0-9T:Z-]+\\n`)\n\tassert.Regexp(t, r, w.String())\n}\n\nfunc TestVersionDateFailed(t *testing.T) ", "output": "{\n\tversion.RawDate = \"n/a\"\n\n\texpectedErr := \"unable to parse date: n/a\"\n\t_, err := version.Date()\n\n\tassert.Error(t, err, expectedErr)\n\tassert.Equal(t, expectedErr, err.Error())\n\n\tvar expectedErrType = err.(*version.DateParseError)\n\tassert.True(t, errors.As(err, &expectedErrType))\n\tassert.Equal(\n\t\tt,\n\t\texpectedErrType.Unwrap().Error(),\n\t\t\"parsing time \\\"n/a\\\" as \\\"2006-01-02T15:04:05Z07:00\\\": cannot parse \\\"n/a\\\" as \\\"2006\\\"\",\n\t)\n}"}
{"input": "package resttools\n\nimport (\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/iancoleman/strcase\"\n\t\"google.golang.org/protobuf/encoding/protojson\"\n)\n\n\n\n\n\nfunc ToJSON() *protojson.MarshalOptions {\n\tcopy := *JSONMarshaler.current\n\treturn &copy\n}\n\n\n\n\nfunc FromJSON() *protojson.UnmarshalOptions {\n\treturn &protojson.UnmarshalOptions{}\n}\n\n\n\nvar JSONMarshaler JSONMarshalOptions\n\n\n\n\ntype JSONMarshalOptions struct {\n\tcurrent, saved *protojson.MarshalOptions\n\tmu             sync.Mutex\n}\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (jm *JSONMarshalOptions) Restore() {\n\tjm.current = jm.saved\n\tjm.saved = nil\n\tjm.mu.Unlock()\n}\n\n\nfunc ToDottedLowerCamel(fieldPath string) string {\n\tparts := strings.Split(fieldPath, \".\")\n\tfor idx, segment := range parts {\n\t\tparts[idx] = strcase.ToLowerCamel(segment)\n\t}\n\treturn strings.Join(parts, \".\")\n}\n\nfunc init() {\n\tJSONMarshaler.current = &protojson.MarshalOptions{\n\t\tMultiline:       true,\n\t\tAllowPartial:    false,\n\t\tUseEnumNumbers:  false,\n\t\tEmitUnpopulated: true,\n\t\tUseProtoNames:   false, \n\t}\n\n}\n\nfunc (jm *JSONMarshalOptions) Replace(opt *protojson.MarshalOptions) ", "output": "{\n\tjm.mu.Lock()\n\tif opt == nil {\n\t\topt = jm.current\n\t}\n\tjm.saved = jm.current\n\tjm.current = opt\n}"}
{"input": "package xeth\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n)\n\n\n\ntype whisperFilter struct {\n\tid  int      \n\tref *Whisper \n\n\tcache  []WhisperMessage         \n\tskip   map[common.Hash]struct{} \n\tupdate time.Time                \n\n\tlock sync.RWMutex \n}\n\n\nfunc newWhisperFilter(id int, ref *Whisper) *whisperFilter {\n\treturn &whisperFilter{\n\t\tid:  id,\n\t\tref: ref,\n\n\t\tupdate: time.Now(),\n\t\tskip:   make(map[common.Hash]struct{}),\n\t}\n}\n\n\n\nfunc (w *whisperFilter) messages() []WhisperMessage {\n\tw.lock.Lock()\n\tdefer w.lock.Unlock()\n\n\tw.cache = nil\n\tw.update = time.Now()\n\n\tw.skip = make(map[common.Hash]struct{})\n\tmessages := w.ref.Messages(w.id)\n\tfor _, message := range messages {\n\t\tw.skip[message.ref.Hash] = struct{}{}\n\t}\n\treturn messages\n}\n\n\nfunc (w *whisperFilter) insert(messages ...WhisperMessage) {\n\tw.lock.Lock()\n\tdefer w.lock.Unlock()\n\n\tfor _, message := range messages {\n\t\tif _, ok := w.skip[message.ref.Hash]; !ok {\n\t\t\tw.cache = append(w.cache, messages...)\n\t\t}\n\t}\n}\n\n\nfunc (w *whisperFilter) retrieve() (messages []WhisperMessage) {\n\tw.lock.Lock()\n\tdefer w.lock.Unlock()\n\n\tmessages, w.cache = w.cache, nil\n\tw.update = time.Now()\n\n\treturn\n}\n\n\n\n\n\nfunc (w *whisperFilter) activity() time.Time ", "output": "{\n\tw.lock.RLock()\n\tdefer w.lock.RUnlock()\n\n\treturn w.update\n}"}
{"input": "package dexcom\n\nimport (\n\t\"math\"\n)\n\n\n\nfunc marshalUint16(n uint16) []byte {\n\treturn []byte{byte(n & 0xFF), byte(n >> 8)}\n}\n\n\nfunc marshalInt16(n int16) []byte {\n\treturn marshalUint16(uint16(n))\n}\n\nfunc marshalUint32(n uint32) []byte {\n\treturn append(marshalUint16(uint16(n&0xFFFF)), marshalUint16(uint16(n>>16))...)\n}\n\nfunc marshalInt32(n int32) []byte {\n\treturn marshalUint32(uint32(n))\n}\n\nfunc unmarshalUint16(v []byte) uint16 {\n\treturn uint16(v[0]) | uint16(v[1])<<8\n}\n\n\nfunc unmarshalInt16(v []byte) int16 {\n\treturn int16(unmarshalUint16(v))\n}\n\nfunc unmarshalUint32(v []byte) uint32 {\n\treturn uint32(unmarshalUint16(v[0:2])) | uint32(unmarshalUint16(v[2:4]))<<16\n}\n\nfunc unmarshalInt32(v []byte) int32 {\n\treturn int32(unmarshalUint32(v))\n}\n\nfunc unmarshalUint64(v []byte) uint64 {\n\treturn uint64(unmarshalUint32(v[0:4])) | uint64(unmarshalUint32(v[4:8]))<<32\n}\n\n\n\nfunc unmarshalFloat64(v []byte) float64 ", "output": "{\n\treturn math.Float64frombits(unmarshalUint64(v))\n}"}
{"input": "package iproute2\n\nimport \"testing\"\n\n\n\nfunc TestExistingBridge(t *testing.T) {\n\tb, err := NewBridge(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create bridge: err='%s'\", err.Error())\n\t}\n\tdefer b.Delete()\n\n\tif _, err := NewBridge(\"test\"); err != nil {\n\t\tt.Fatalf(\"Failed to find existing bridge: err='%s'\", err.Error())\n\t}\n}\n\nfunc TestListSlaves(t *testing.T) {\n\tb, err := NewBridge(\"br-test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create bridge: err='%s'\", err.Error())\n\t}\n\tdefer b.Delete()\n\n\tnt, err := NewTap(\"tap-test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create tap: err='%s'\", err.Error())\n\t}\n\tdefer nt.Delete()\n\n\tif err := nt.SetMaster(b); err != nil {\n\t\tt.Errorf(\"Failed to set master: err='%s'\", err.Error())\n\t}\n\n\tif l, err := b.ListSlaves(); err != nil {\n\t\tt.Errorf(\"Failed to list slaves: err='%s'\", err.Error())\n\t} else if len(l) != 1 {\n\t\tt.Errorf(\"Wrong the number of slaves: want='%d', have='%d'\", 1, len(l))\n\t} else if l[0] != nt.Name() {\n\t\tt.Errorf(\"Got wrong link about index: want='%s', have='%s'\", nt.Name(), l[0])\n\t}\n}\n\nfunc TestBridge(t *testing.T) ", "output": "{\n\tb, err := NewBridge(\"test\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create bridge: err='%s'\", err.Error())\n\t}\n\n\tif err := b.Up(); err != nil {\n\t\tt.Errorf(\"Failed to up bridge: err='%s'\", err.Error())\n\t}\n\n\tif err := b.SetAddress(\"10.255.255.1/24\"); err != nil {\n\t\tt.Errorf(\"Failed to set address: err='%s'\", err.Error())\n\t}\n\n\tif _, err := b.GetIPv4(); err != nil {\n\t\tt.Errorf(\"Failed to get address: err='%s'\", err.Error())\n\t}\n\n\tif err := b.Delete(); err != nil {\n\t\tt.Errorf(\"Failed to delete bridge: err='%s'\", err.Error())\n\t}\n}"}
{"input": "package unibyte\n\nimport \"unicode\"\n\n\nfunc IsLower(b byte) bool {\n\treturn b >= 'a' && b <= 'z'\n}\n\n\nfunc IsUpper(b byte) bool {\n\treturn b >= 'A' && b <= 'Z'\n}\n\n\n\n\n\nfunc IsSpaceQuote(b byte) bool {\n\treturn IsSpace(b) || b == '\"' || b == '\\''\n}\n\n\nfunc IsSpace(b byte) bool {\n\treturn unicode.IsSpace(rune(b))\n}\n\n\nfunc ToLower(b byte) byte {\n\tif IsUpper(b) {\n\t\tb = b - 'A' + 'a'\n\t}\n\n\treturn b\n}\n\n\nfunc ToUpper(b byte) byte {\n\tif IsLower(b) {\n\t\tb = b - 'a' + 'A'\n\t}\n\n\treturn b\n}\n\n\nfunc ToLowerString(b byte) string {\n\tif IsUpper(b) {\n\t\tb = b - 'A' + 'a'\n\t}\n\n\treturn string(b)\n}\n\n\nfunc ToUpperString(b byte) string {\n\tif IsLower(b) {\n\t\tb = b - 'a' + 'A'\n\t}\n\n\treturn string(b)\n}\n\nfunc IsLetter(b byte) bool ", "output": "{\n\treturn IsLower(b) || IsUpper(b)\n}"}
{"input": "package zookeeper\n\nimport (\n\t\"h12.io/realtest/container\"\n)\n\nconst (\n\tinternalPort = 2181\n)\n\nvar (\n\tcontainerName = container.ContainerName{Name: \"realtest-zookeeper-a34ea1a3e95244de8f278c79e9b2cb94\"}\n)\n\ntype ZooKeeper struct {\n\tc *container.Container\n}\n\nfunc New() (*ZooKeeper, error) {\n\tc, err := containerName.FindOrCreate(\"h12w/zookeeper:latest\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &ZooKeeper{\n\t\tc: c,\n\t}, nil\n}\n\nfunc (s *ZooKeeper) Addr() string {\n\treturn s.c.Addr(internalPort)\n}\n\n\n\nfunc (s *ZooKeeper) IP() string {\n\treturn s.c.IP\n}\n\nfunc (s *ZooKeeper) Name() string {\n\treturn containerName.Name\n}\n\nfunc (s *ZooKeeper) ID() string ", "output": "{\n\treturn s.c.ID\n}"}
{"input": "package homedir \n\nimport (\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestGet(t *testing.T) {\n\thome := Get()\n\tif home == \"\" {\n\t\tt.Fatal(\"returned home directory is empty\")\n\t}\n\n\tif !filepath.IsAbs(home) {\n\t\tt.Fatalf(\"returned path is not absolute: %s\", home)\n\t}\n}\n\n\n\nfunc TestGetShortcutString(t *testing.T) ", "output": "{\n\tshortcut := GetShortcutString()\n\tif shortcut == \"\" {\n\t\tt.Fatal(\"returned shortcut string is empty\")\n\t}\n}"}
{"input": "package main\n\nimport (\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"github.com/go-xorm/xorm\"\n\t\"fmt\"\n\t\"os\"\n)\n\nvar engine *xorm.Engine\n\n\n\n\nfunc RepoFindBuild(id int) Build {\n\treturn Build{}\n}\n\n\nfunc RepoCreateBuild(t Build) Build {\n\tif _, err := engine.Insert(&t); err != nil{\n\t\tpanic(err)\n\t}\n\tvar repository Repository\n\n\thas, err := engine.Where(\"Name = ?\", t.RepositoryName).Desc(\"Id\").Get(&repository)\n\n\tif(err != nil){\n\t\tpanic(err)\n\t}\n\n\tif(has)\t{\n\t\tengine.Update(&Repository{ Name:t.RepositoryName, Url:t.RepositoryUrl, Status: t.Status }, &Repository{Name:t.RepositoryName})\n\t} else {\n\t\tengine.Insert(&Repository{ Name:t.RepositoryName, Url:t.RepositoryUrl, Status: t.Status })\n\t}\n\n\treturn t\n}\n\nfunc RepoShowAllBuilds(size int) Builds{\n\tbuilds := make([]Build, 0)\n\tvar err = engine.Desc(\"Id\").Limit(size).Find(&builds)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\treturn builds\n}\n\nfunc RepoShowAllRepos() Repositories{\n\trepos := make([]Repository, 0)\n\tvar err = engine.Asc(\"Status\").Asc(\"Name\").Limit(500).Find(&repos)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\treturn repos\n}\n\nfunc init() ", "output": "{\n\tvar err error\n\tvar dataSource = os.Getenv(\"MYSQL_CONNECTION\")\n\tengine, err = xorm.NewEngine(\"mysql\", dataSource)\n\tif(err != nil){\n\t\tpanic(err)\n\t}\n\n}"}
{"input": "package tracker\n\nimport (\n\t\"testing\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\n\n\nfunc Test(t *testing.T) ", "output": "{\n\tTestingT(t)\n}"}
{"input": "package elements\n\nimport \"github.com/fileformats/graphics/jt/model\"\n\n\n\n\n\n\ntype PropertyTable struct {\n\tVersionNumber int16\n\tPropertiesCount int32\n\tProperties map[int32]ElementPropertyTable\n}\n\nfunc (n *PropertyTable) Read(c *model.Context) error {\n\tc.LogGroup(\"NodePropertyTable\")\n\tdefer c.LogGroupEnd()\n\n\tn.Properties = map[int32]ElementPropertyTable{}\n\n\tn.VersionNumber = c.Data.Int16()\n\tc.Log(\"VersionNumber: %d\", n.VersionNumber)\n\n\tn.PropertiesCount = c.Data.Int32()\n\tc.Log(\"PropertiesCount: %d\", n.PropertiesCount)\n\n\tfor i := 0; i < int(n.PropertiesCount); i++ {\n\t\tobjectId := c.Data.Int32()\n\t\ttable := ElementPropertyTable{map[int32]int32{}}\n\t\t(&table).Read(c)\n\n\t\tn.Properties[objectId] = table\n\t}\n\n\n\treturn c.Data.GetError()\n}\n\n\n\ntype ElementPropertyTable struct {\n\tValues map[int32]int32\n}\n\n\n\nfunc (n *ElementPropertyTable) Read(c *model.Context) error ", "output": "{\n\tif n.Values == nil {\n\t\tn.Values = map[int32]int32{}\n\t}\n\tfor {\n\t\tobjectId := c.Data.Int32()\n\t\tif objectId  == 0 || c.Data.GetError() != nil {\n\t\t\tbreak\n\t\t}\n\t\tn.Values[objectId] = c.Data.Int32()\n\t}\n\treturn c.Data.GetError()\n}"}
{"input": "package copy\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\t\"testing\"\n)\n\n\n\nfunc setup(m *testing.M) ", "output": "{\n\tos.MkdirAll(\"test/data.copy\", os.ModePerm)\n\tos.Symlink(\"test/data/case01\", \"test/data/case03/case01\")\n\tos.Chmod(\"test/data/case07/dir_0555\", 0555)\n\tos.Chmod(\"test/data/case07/file_0444\", 0444)\n\tsyscall.Mkfifo(\"test/data/case11/foo/bar\", 0555)\n}"}
{"input": "package crypto\n\nimport (\n\t\"errors\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n)\n\n\n\nfunc LoadRSAPublicKey(key []byte) (*rsa.PublicKey, error) {\n\tparsed_key, err := LoadPublicKey(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar rsa_public_key *rsa.PublicKey\n\tvar ok bool = false\n\trsa_public_key, ok = parsed_key.(*rsa.PublicKey)\n\tif !ok {\n\t\treturn nil, errors.New(\"invalid RSA public key.\")\n\t}\n\n\treturn rsa_public_key, nil\n}\n\nfunc CreateRSAPrivateKeyPEM(prvkey *rsa.PrivateKey) ([]byte, error) {\n\tder := x509.MarshalPKCS1PrivateKey(prvkey)\n\tdata := pem.EncodeToMemory(\n\t\t&pem.Block{\n\t\t\tType: \"RSA PRIVATE KEY\",\n\t\t\tBytes: der,\n\t\t},\n\t)\n\n\treturn data, nil\n}\n\nfunc CreateRSAPublicKeyPEM(pubkey *rsa.PublicKey) ([]byte, error) {\n\tder, err := x509.MarshalPKIXPublicKey(pubkey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata := pem.EncodeToMemory(\n\t\t&pem.Block{\n\t\t\tType: \"RSA PUBLIC KEY\",\n\t\t\tBytes: der,\n\t\t},\n\t)\n\n\treturn data, nil\n}\n\nfunc LoadRSAPrivateKey(key []byte) (*rsa.PrivateKey, error) ", "output": "{\n\tparsed_key, err := LoadPrivateKey(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar rsa_private_key *rsa.PrivateKey\n\tvar ok bool = false\n\trsa_private_key, ok = parsed_key.(*rsa.PrivateKey)\n\tif !ok {\n\t\treturn nil, errors.New(\"invalid RSA private key.\")\n\t}\n\n\treturn rsa_private_key, nil\n}"}
{"input": "package main\n\nimport \"testing\"\n\nfunc TestSum(t *testing.T) {\n\ttype args struct {\n\t\tnumbers []int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"foo\",\n\t\t\targs: args{\n\t\t\t\tnumbers: []int{1, 2},\n\t\t\t},\n\t\t\twant: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Sum(tt.args.numbers...); got != tt.want {\n\t\t\t\tt.Errorf(\"Sum() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n\n\nfunc BenchmarkSumParallel(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tSumParallel(foo...)\n\t}\n}\n\nfunc BenchmarkSum(b *testing.B) ", "output": "{\n\tfor i := 0; i < b.N; i++ {\n\t\tSum(foo...)\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/docker/distribution/reference\"\n\n\tvoucher \"github.com/grafeas/voucher/v2\"\n)\n\n\n\n\n\nfunc LookupAndVerify(args []string) {\n\tvar err error\n\n\tctx, cancel := newContext()\n\tdefer cancel()\n\n\tclient, err := getVoucherClient(ctx)\n\tif nil != err {\n\t\terrorf(\"creating client failed: %s\", err)\n\t\tos.Exit(1)\n\t}\n\n\tcanonicalRef, err := lookupCanonical(ctx, args[0])\n\tif nil != err {\n\t\terrorf(\"getting canonical reference failed: %s\", err)\n\t\tos.Exit(1)\n\t}\n\n\terr = verifyImage(ctx, client, getCheck(), canonicalRef)\n\tif nil != err {\n\t\terrorf(\"verifying image with voucher failed: %s\", err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc verifyImage(ctx context.Context, client voucher.Interface, check string, canonicalRef reference.Canonical) error ", "output": "{\n\tfmt.Printf(\"Verifying image with Voucher: %s\\n\", canonicalRef.String())\n\n\tvoucherResp, err := client.Verify(ctx, check, canonicalRef)\n\tif nil != err {\n\t\treturn fmt.Errorf(\"verifying image failed: %s\", err)\n\t}\n\n\tfmt.Println(formatResponse(&voucherResp))\n\n\tif !voucherResp.Success {\n\t\treturn errImageCheckFailed\n\t}\n\n\treturn nil\n}"}
{"input": "package role\n\nimport (\n\t\"github.com/watermint/toolbox/domain/dropbox/api/dbx_auth\"\n\t\"github.com/watermint/toolbox/domain/dropbox/api/dbx_conn\"\n\t\"github.com/watermint/toolbox/domain/dropbox/model/mo_user\"\n\t\"github.com/watermint/toolbox/domain/dropbox/service/sv_adminrole\"\n\t\"github.com/watermint/toolbox/domain/dropbox/service/sv_member\"\n\t\"github.com/watermint/toolbox/infra/control/app_control\"\n\t\"github.com/watermint/toolbox/infra/recipe/rc_exec\"\n\t\"github.com/watermint/toolbox/infra/recipe/rc_recipe\"\n)\n\ntype Clear struct {\n\tPeer  dbx_conn.ConnScopedTeam\n\tEmail string\n}\n\nfunc (z *Clear) Preset() {\n\tz.Peer.SetScopes(\n\t\tdbx_auth.ScopeMembersRead,\n\t\tdbx_auth.ScopeMembersWrite,\n\t)\n}\n\nfunc (z *Clear) Exec(c app_control.Control) error {\n\tmember, err := sv_member.New(z.Peer.Context()).ResolveByEmail(z.Email)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = sv_adminrole.New(z.Peer.Context()).UpdateRole(mo_user.NewUserSelectorByTeamMemberId(member.TeamMemberId), []string{})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (z *Clear) Test(c app_control.Control) error ", "output": "{\n\treturn rc_exec.ExecMock(c, &Clear{}, func(r rc_recipe.Recipe) {\n\t\tm := r.(*Clear)\n\t\tm.Email = \"jo@example.com\"\n\t})\n}"}
{"input": "package gopm_index\n\nimport (\n    \"encoding/json\"\n)\n\ntype PackageMeta struct {\n    Name         string   `json:\"name\"`\n    Description  string   `json:\"description\"`\n    Category     string   `json:\"category\"`\n    Keywords     []string `json:\"keywords\"`\n    Author       []string `json:\"author\"`\n    Contributors []string `json:\"contributors\"`\n    Repositories []string `json:\"repositories\"`\n    Bugs         string   `json:\"bugs\"`\n}\n\n\nfunc (meta *PackageMeta) ToJson() (content []byte, err error) {\n    content, err = json.Marshal(meta)\n    return\n}\n\n\n\nfunc (meta *PackageMeta) FromJson(content []byte) error ", "output": "{\n    return json.Unmarshal(content, meta)\n}"}
{"input": "package api_server\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\tparams \"github.com/kubeflow/pipelines/backend/api/go_http_client/visualization_client/visualization_service\"\n\tmodel \"github.com/kubeflow/pipelines/backend/api/go_http_client/visualization_model\"\n)\n\ntype VisualizationArguments struct {\n\tfail bool\n}\n\ntype VisualizationClientFake struct{}\n\n\n\nfunc (c *VisualizationClientFake) Create(params *params.CreateVisualizationParams) (\n\t*model.APIVisualization, error) {\n\tvar arguments VisualizationArguments\n\terr := json.Unmarshal([]byte(params.Body.Arguments), &arguments)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif arguments.fail {\n\t\treturn nil, fmt.Errorf(ClientErrorString)\n\t}\n\treturn params.Body, nil\n}\n\nfunc NewVisualizationClientFake() *VisualizationClientFake ", "output": "{\n\treturn &VisualizationClientFake{}\n}"}
{"input": "package console\n\nimport (\n\tv1 \"github.com/cgrates/cgrates/apier/v1\"\n\t\"github.com/cgrates/cgrates/engine\"\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\n\n\n\ntype CmdSetDispatcherHost struct {\n\tname      string\n\trpcMethod string\n\trpcParams *v1.DispatcherHostWithCache\n\t*CommandExecuter\n}\n\nfunc (self *CmdSetDispatcherHost) Name() string {\n\treturn self.name\n}\n\nfunc (self *CmdSetDispatcherHost) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\nfunc (self *CmdSetDispatcherHost) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &v1.DispatcherHostWithCache{\n\t\t\tDispatcherHost: new(engine.DispatcherHost),\n\t\t\tOpts:           make(map[string]interface{}),\n\t\t}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *CmdSetDispatcherHost) PostprocessRpcParams() error {\n\treturn nil\n}\n\nfunc (self *CmdSetDispatcherHost) RpcResult() interface{} {\n\tvar s string\n\treturn &s\n}\n\nfunc init() ", "output": "{\n\tc := &CmdSetDispatcherHost{\n\t\tname:      \"dispatchers_host_set\",\n\t\trpcMethod: utils.APIerSv1SetDispatcherHost,\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}"}
{"input": "package document\n\ntype IndexingOptions int\n\nconst (\n\tIndexField IndexingOptions = 1 << iota\n\tStoreField\n\tIncludeTermVectors\n)\n\nfunc (o IndexingOptions) IsIndexed() bool {\n\treturn o&IndexField != 0\n}\n\nfunc (o IndexingOptions) IsStored() bool {\n\treturn o&StoreField != 0\n}\n\n\n\nfunc (o IndexingOptions) String() string {\n\trv := \"\"\n\tif o.IsIndexed() {\n\t\trv += \"INDEXED\"\n\t}\n\tif o.IsStored() {\n\t\tif rv != \"\" {\n\t\t\trv += \", \"\n\t\t}\n\t\trv += \"STORE\"\n\t}\n\tif o.IncludeTermVectors() {\n\t\tif rv != \"\" {\n\t\t\trv += \", \"\n\t\t}\n\t\trv += \"TV\"\n\t}\n\treturn rv\n}\n\nfunc (o IndexingOptions) IncludeTermVectors() bool ", "output": "{\n\treturn o&IncludeTermVectors != 0\n}"}
{"input": "package se\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/kemokemo/kuronan-dash/assets/music\"\n)\n\nfunc TestMain(m *testing.M) {\n\terr := music.LoadAudioContext()\n\tif err != nil {\n\t\tfmt.Println(\"failed to LoadAudioContext:\", err)\n\t\treturn\n\t}\n\n\terr = LoadSE()\n\tif err != nil {\n\t\tfmt.Println(\"failed to LoadSE:\", err)\n\t\treturn\n\t}\n\tdefer func() {\n\t\te := CloseSE()\n\t\tfmt.Println(\"failed to CloseSE:\", e)\n\t}()\n\n\tos.Exit(m.Run())\n}\n\n\n\nfunc TestPlayer(t *testing.T) ", "output": "{\n\ttests := []struct {\n\t\tname   string\n\t\tplayer *Player\n\t}{\n\t\t{\"Jump\", Jump},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.player == nil {\n\t\t\t\tt.Errorf(\"SE Player '%v' is nil, loading error\", tt.name)\n\t\t\t}\n\t\t})\n\t}\n}"}
{"input": "package search\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/animenotifier/arn\"\n\t\"github.com/animenotifier/arn/stringutils\"\n)\n\n\n\n\nfunc Threads(originalTerm string, maxLength int) []*arn.Thread ", "output": "{\n\tterm := strings.ToLower(stringutils.RemoveSpecialCharacters(originalTerm))\n\tresults := make([]*arn.Thread, 0, maxLength)\n\n\tfor thread := range arn.StreamThreads() {\n\t\tif thread.ID == originalTerm {\n\t\t\treturn []*arn.Thread{thread}\n\t\t}\n\n\t\ttext := strings.ToLower(thread.Text)\n\n\t\tif strings.Contains(text, term) {\n\t\t\tresults = append(results, thread)\n\t\t\tcontinue\n\t\t}\n\n\t\ttext = strings.ToLower(thread.Title)\n\n\t\tif strings.Contains(text, term) {\n\t\t\tresults = append(results, thread)\n\t\t\tcontinue\n\t\t}\n\t}\n\n\tsort.Slice(results, func(i, j int) bool {\n\t\treturn results[i].Created > results[j].Created\n\t})\n\n\tif len(results) >= maxLength {\n\t\tresults = results[:maxLength]\n\t}\n\n\treturn results\n}"}
{"input": "package client\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/docker/engine-api/types\"\n)\n\n\nfunc (cli *Client) ContainerExecCreate(config types.ExecConfig) (types.ContainerExecCreateResponse, error) {\n\tvar response types.ContainerExecCreateResponse\n\tresp, err := cli.post(\"/containers/\"+config.Container+\"/exec\", nil, config, nil)\n\tif err != nil {\n\t\treturn response, err\n\t}\n\tdefer ensureReaderClosed(resp)\n\terr = json.NewDecoder(resp.body).Decode(&response)\n\treturn response, err\n}\n\n\nfunc (cli *Client) ContainerExecStart(execID string, config types.ExecStartCheck) error {\n\tresp, err := cli.post(\"/exec/\"+execID+\"/start\", nil, config, nil)\n\tensureReaderClosed(resp)\n\treturn err\n}\n\n\n\n\n\nfunc (cli *Client) ContainerExecAttach(execID string, config types.ExecConfig) (types.HijackedResponse, error) {\n\theaders := map[string][]string{\"Content-Type\": {\"application/json\"}}\n\treturn cli.postHijacked(\"/exec/\"+execID+\"/start\", nil, config, headers)\n}\n\n\n\n\nfunc (cli *Client) ContainerExecInspect(execID string) (types.ContainerExecInspect, error) ", "output": "{\n\tvar response types.ContainerExecInspect\n\tresp, err := cli.get(\"/exec/\"+execID+\"/json\", nil, nil)\n\tif err != nil {\n\t\treturn response, err\n\t}\n\tdefer ensureReaderClosed(resp)\n\n\terr = json.NewDecoder(resp.body).Decode(&response)\n\treturn response, err\n}"}
{"input": "package math\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"strconv\"\n)\n\ntype CT_Integer2 struct {\n\tValAttr int64\n}\n\nfunc NewCT_Integer2() *CT_Integer2 {\n\tret := &CT_Integer2{}\n\tret.ValAttr = -2\n\treturn ret\n}\n\nfunc (m *CT_Integer2) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tstart.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: \"m:val\"},\n\t\tValue: fmt.Sprintf(\"%v\", m.ValAttr)})\n\te.EncodeToken(start)\n\te.EncodeToken(xml.EndElement{Name: start.Name})\n\treturn nil\n}\n\nfunc (m *CT_Integer2) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n\tm.ValAttr = -2\n\tfor _, attr := range start.Attr {\n\t\tif attr.Name.Local == \"val\" {\n\t\t\tparsed, err := strconv.ParseInt(attr.Value, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tm.ValAttr = parsed\n\t\t}\n\t}\n\tfor {\n\t\ttok, err := d.Token()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing CT_Integer2: %s\", err)\n\t\t}\n\t\tif el, ok := tok.(xml.EndElement); ok && el.Name == start.Name {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\n\nfunc (m *CT_Integer2) Validate() error {\n\treturn m.ValidateWithPath(\"CT_Integer2\")\n}\n\n\n\n\nfunc (m *CT_Integer2) ValidateWithPath(path string) error ", "output": "{\n\tif m.ValAttr < -2 {\n\t\treturn fmt.Errorf(\"%s/m.ValAttr must be >= -2 (have %v)\", path, m.ValAttr)\n\t}\n\tif m.ValAttr > 2 {\n\t\treturn fmt.Errorf(\"%s/m.ValAttr must be <= 2 (have %v)\", path, m.ValAttr)\n\t}\n\treturn nil\n}"}
{"input": "package models\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/matematik7/gongo/authorization\"\n\t\"github.com/matematik7/gongo/files\"\n)\n\nvar location *time.Location\n\n\n\ntype DiaryEntry struct {\n\tgorm.Model\n\tTitle      string             `valid:\"required\"`\n\tText       string             `gorm:\"type:text\" valid:\"required\"`\n\tAuthor     authorization.User `valid:\"-\"`\n\tAuthorID   uint               `valid:\"required\"`\n\tComments   []Comment          `valid:\"-\"`\n\tMapEntry   MapEntry           `valid:\"-\"`\n\tMapEntryID uint\n\tImages     []files.Image `gorm:\"many2many:diary_image\"`\n\tPublished  bool\n\n\tNumComments uint `gorm:\"-\"`\n\tViewed      bool `gorm:\"-\"`\n\tNewComments bool `gorm:\"-\"`\n}\n\n\nfunc (de *DiaryEntry) AfterFind() error {\n\tde.CreatedAt = de.CreatedAt.In(location)\n\tde.UpdatedAt = de.UpdatedAt.In(location)\n\n\treturn nil\n}\n\ntype Comment struct {\n\tgorm.Model\n\tDiaryEntryID uint\n\tComment      string             `gorm:\"type:text\" valid:\"required\"`\n\tAuthor       authorization.User `valid:\"-\"`\n\tAuthorID     uint\n}\n\nfunc (c *Comment) AfterFind() error {\n\tc.CreatedAt = c.CreatedAt.In(location)\n\n\treturn nil\n}\n\ntype EntryUserRead struct {\n\tgorm.Model\n\tDiaryEntryID uint\n\tUserID       uint\n}\n\ntype Workout struct {\n\tID          string\n\tDescription string\n}\n\nfunc init() ", "output": "{\n\tvar err error\n\tlocation, err = time.LoadLocation(\"Europe/Ljubljana\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}"}
{"input": "package term\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc IsANSI(f *os.File) bool {\n\treturn IsTerminal(f)\n}\n\n\nfunc IsTerminal(f *os.File) bool {\n\tcmd := exec.Command(\"test\", \"-t\", \"0\")\n\tcmd.Stdin = f\n\treturn cmd.Run() == nil\n}\n\nfunc MakeRaw(f *os.File) error {\n\treturn stty(f, \"-icanon\", \"-echo\").Run()\n}\n\nfunc Restore(f *os.File) error {\n\treturn stty(f, \"icanon\", \"echo\").Run()\n}\n\nfunc Cols() (int, error) {\n\tcols, err := tput(\"cols\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn strconv.Atoi(cols)\n}\n\n\n\n\n\nfunc stty(f *os.File, args ...string) *exec.Cmd {\n\tc := exec.Command(\"stty\", args...)\n\tc.Stdin = f\n\treturn c\n}\n\nfunc tput(what string) (string, error) {\n\tc := exec.Command(\"tput\", what)\n\tc.Stderr = os.Stderr\n\tout, err := c.Output()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn strings.TrimSpace(string(out)), nil\n}\n\nfunc Lines() (int, error) ", "output": "{\n\tcols, err := tput(\"lines\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn strconv.Atoi(cols)\n}"}
{"input": "package forward\n\nimport \"github.com/asukakenji/go-benchmarks/math/bits/impl/onescount/pop1a\"\n\nconst (\n\tuintSize = 32 << (^uint(0) >> 32 & 1) \n\tis32Bit  = (^uint(0) >> 32 & 1) == 0\n)\n\nvar (\n\tonesCount func(uint) int\n)\n\n\n\nfunc onesCount32(x uint) int {\n\treturn pop1a.OnesCount32(uint32(x))\n}\n\nfunc onesCount64(x uint) int {\n\treturn pop1a.OnesCount64(uint64(x))\n}\n\n\nfunc OnesCountIfConstBool(x uint) int {\n\tif is32Bit {\n\t\treturn pop1a.OnesCount32(uint32(x))\n\t}\n\treturn pop1a.OnesCount64(uint64(x))\n}\n\n\nfunc OnesCountIfConstUint(x uint) int {\n\tif uintSize == 32 {\n\t\treturn pop1a.OnesCount32(uint32(x))\n\t}\n\treturn pop1a.OnesCount64(uint64(x))\n}\n\n\nfunc OnesCountSwitchConstUint(x uint) int {\n\tswitch uintSize {\n\tcase 32:\n\t\treturn pop1a.OnesCount32(uint32(x))\n\tcase 64:\n\t\treturn pop1a.OnesCount64(uint64(x))\n\tdefault:\n\t\tpanic(\"uint is neither 32-bit nor 64-bit\")\n\t}\n}\n\n\nfunc OnesCountFuncPointer(x uint) int {\n\treturn onesCount(x)\n}\n\nfunc init() ", "output": "{\n\tif is32Bit {\n\t\tonesCount = onesCount32\n\t} else {\n\t\tonesCount = onesCount64\n\t}\n}"}
{"input": "package b\n\nimport \"reflect\"\n\ntype X int\n\nfunc F1() string {\n\ttype x X\n\n\ts := struct {\n\t\t*x\n\t}{nil}\n\tv := reflect.TypeOf(s)\n\treturn v.Field(0).PkgPath\n}\n\n\n\nfunc F2() string ", "output": "{\n\ttype y X\n\n\ts := struct {\n\t\t*y\n\t}{nil}\n\tv := reflect.TypeOf(s)\n\treturn v.Field(0).PkgPath\n}"}
{"input": "package handler_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"io\"\n\t\"io/ioutil\"\n\n\t\"github.com/lucas-clemente/git-cr/git/repo\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"testing\"\n)\n\nfunc TestGitHandler(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Git Handler Suite\")\n}\n\n\ntype FixtureRepo struct {\n\tRevisions []repo.Revision\n\tPackfiles [][]byte\n}\n\nvar _ repo.Repo = &FixtureRepo{}\n\n\nfunc NewFixtureRepo() *FixtureRepo {\n\treturn &FixtureRepo{}\n}\n\n\n\n\n\nfunc (r *FixtureRepo) SaveNewRevision(rev repo.Revision, packfile io.Reader) error {\n\tr.Revisions = append(r.Revisions, rev)\n\tdata, err := ioutil.ReadAll(packfile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tr.Packfiles = append(r.Packfiles, data)\n\treturn nil\n}\n\n\nfunc (r *FixtureRepo) ReadPackfile(toRev int) (io.ReadCloser, error) {\n\treturn ioutil.NopCloser(bytes.NewBuffer(r.Packfiles[toRev])), nil\n}\n\n\nfunc (r *FixtureRepo) SaveNewRevisionB64(rev repo.Revision, b64 string) {\n\tpack, err := base64.StdEncoding.DecodeString(b64)\n\tif err != nil {\n\t\tpanic(\"invalid base64 in FixtureRepo.AddPackfile\")\n\t}\n\tif err := r.SaveNewRevision(rev, bytes.NewBuffer(pack)); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (r *FixtureRepo) GetRevisions() ([]repo.Revision, error) ", "output": "{\n\treturn r.Revisions, nil\n}"}
{"input": "package db\n\nimport (\n\t\"context\"\n\t\"github.com/oklog/ulid\"\n)\n\ntype Initiator int\n\nconst (\n\tInitiatorSystem Initiator = 1 << 0\n\tInitiatorUser   Initiator = 1 << 1\n\tMetaPrefix                = \"/minicloud/db/meta\"\n)\n\ntype RawValue struct {\n\tCreateRev, ModifyRev int64\n\tKey                  string\n\tData                 []byte\n}\n\ntype Connection interface {\n\tRawRead(ctx context.Context, key string) (*RawValue, error)\n\tRawReadPrefix(ctx context.Context, key string) ([]RawValue, error)\n\tRawWatchPrefix(ctx context.Context, prefix string) chan *RawValue\n\tNewTransaction() Transaction\n}\n\ntype Transaction interface {\n\tCommit(ctx context.Context) error\n\tCreate(ctx context.Context, entity Entity)\n\tUpdate(ctx context.Context, entity Entity)\n\tDelete(ctx context.Context, entity Entity)\n\tCreateMeta(ctx context.Context, key, content string)\n\tCheckMeta(ctx context.Context, key, content string)\n\tDeleteMeta(ctx context.Context, key string)\n\tAcquireLock(ctx context.Context, key string)\n\tReleaseLock(ctx context.Context, key string)\n}\n\ntype Entity interface {\n\tHeader() *EntityHeader\n\tEntityName() string\n}\n\ntype EntityHeader struct {\n\tSchemaVersion int64\n\tCreateRev     int64  `json:\"-\"`\n\tModifyRev     int64  `json:\"-\"`\n\tOriginal      Entity `json:\"-\"`\n\tId            ulid.ULID\n\tState         State\n}\n\n\n\nfunc (hdr *EntityHeader) Header() *EntityHeader ", "output": "{\n\treturn hdr\n}"}
{"input": "package packet_proxy\n\nimport (\n\t\"github.com/bettercap/bettercap/session\"\n)\n\ntype PacketProxy struct {\n\tsession.SessionModule\n}\n\nfunc NewPacketProxy(s *session.Session) *PacketProxy {\n\treturn &PacketProxy{\n\t\tSessionModule: session.NewSessionModule(\"packet.proxy\", s),\n\t}\n}\n\n\n\nfunc (mod PacketProxy) Description() string {\n\treturn \"Not supported on this OS\"\n}\n\nfunc (mod PacketProxy) Author() string {\n\treturn \"Simone Margaritelli <evilsocket@gmail.com>\"\n}\n\nfunc (mod *PacketProxy) Configure() (err error) {\n\treturn session.ErrNotSupported\n}\n\nfunc (mod *PacketProxy) Start() error {\n\treturn session.ErrNotSupported\n}\n\nfunc (mod *PacketProxy) Stop() error {\n\treturn session.ErrNotSupported\n}\n\nfunc (mod PacketProxy) Name() string ", "output": "{\n\treturn \"packet.proxy\"\n}"}
{"input": "package iso20022\n\n\ntype TotalTransactions2 struct {\n\n\tTotalEntries *NumberAndSumOfTransactions2 `xml:\"TtlNtries,omitempty\"`\n\n\tTotalCreditEntries *NumberAndSumOfTransactions1 `xml:\"TtlCdtNtries,omitempty\"`\n\n\tTotalDebitEntries *NumberAndSumOfTransactions1 `xml:\"TtlDbtNtries,omitempty\"`\n\n\tTotalEntriesPerBankTransactionCode []*TotalsPerBankTransactionCode2 `xml:\"TtlNtriesPerBkTxCd,omitempty\"`\n}\n\nfunc (t *TotalTransactions2) AddTotalEntries() *NumberAndSumOfTransactions2 {\n\tt.TotalEntries = new(NumberAndSumOfTransactions2)\n\treturn t.TotalEntries\n}\n\nfunc (t *TotalTransactions2) AddTotalCreditEntries() *NumberAndSumOfTransactions1 {\n\tt.TotalCreditEntries = new(NumberAndSumOfTransactions1)\n\treturn t.TotalCreditEntries\n}\n\nfunc (t *TotalTransactions2) AddTotalDebitEntries() *NumberAndSumOfTransactions1 {\n\tt.TotalDebitEntries = new(NumberAndSumOfTransactions1)\n\treturn t.TotalDebitEntries\n}\n\n\n\nfunc (t *TotalTransactions2) AddTotalEntriesPerBankTransactionCode() *TotalsPerBankTransactionCode2 ", "output": "{\n\tnewValue := new(TotalsPerBankTransactionCode2)\n\tt.TotalEntriesPerBankTransactionCode = append(t.TotalEntriesPerBankTransactionCode, newValue)\n\treturn newValue\n}"}
{"input": "package utp\n\nimport (\n\t\"time\"\n\n\t\"github.com/micro/go-micro/transport\"\n)\n\nfunc (u *utpClient) Send(m *transport.Message) error {\n\tif u.timeout > time.Duration(0) {\n\t\tu.conn.SetDeadline(time.Now().Add(u.timeout))\n\t}\n\tif err := u.enc.Encode(m); err != nil {\n\t\treturn err\n\t}\n\treturn u.encBuf.Flush()\n}\n\nfunc (u *utpClient) Recv(m *transport.Message) error {\n\tif u.timeout > time.Duration(0) {\n\t\tu.conn.SetDeadline(time.Now().Add(u.timeout))\n\t}\n\treturn u.dec.Decode(&m)\n}\n\n\n\nfunc (u *utpClient) Close() error ", "output": "{\n\treturn u.conn.Close()\n}"}
{"input": "package runtime\n\n\ntype TaskMonitor interface {\n\tMonitor(Task) error\n\tStop(Task) error\n}\n\n\nfunc NewMultiTaskMonitor(monitors ...TaskMonitor) TaskMonitor {\n\treturn &multiTaskMonitor{\n\t\tmonitors: monitors,\n\t}\n}\n\n\nfunc NewNoopMonitor() TaskMonitor {\n\treturn &noopTaskMonitor{}\n}\n\ntype noopTaskMonitor struct {\n}\n\nfunc (mm *noopTaskMonitor) Monitor(c Task) error {\n\treturn nil\n}\n\n\n\ntype multiTaskMonitor struct {\n\tmonitors []TaskMonitor\n}\n\nfunc (mm *multiTaskMonitor) Monitor(c Task) error {\n\tfor _, m := range mm.monitors {\n\t\tif err := m.Monitor(c); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (mm *multiTaskMonitor) Stop(c Task) error {\n\tfor _, m := range mm.monitors {\n\t\tif err := m.Stop(c); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (mm *noopTaskMonitor) Stop(c Task) error ", "output": "{\n\treturn nil\n}"}
{"input": "package os\n\nimport (\n\t\"syscall\"\n\t\"time\"\n)\n\n\n\nfunc fileInfoFromStat(st *syscall.Stat_t, name string) FileInfo {\n\tfs := &FileStat{\n\t\tname:    basename(name),\n\t\tsize:    int64(st.Size),\n\t\tmodTime: timestrucToTime(st.Mtime),\n\t\tSys:     st,\n\t}\n\tfs.mode = FileMode(st.Mode & 0777)\n\tswitch st.Mode & syscall.S_IFMT {\n\tcase syscall.S_IFBLK, syscall.S_IFCHR:\n\t\tfs.mode |= ModeDevice\n\tcase syscall.S_IFDIR:\n\t\tfs.mode |= ModeDir\n\tcase syscall.S_IFIFO:\n\t\tfs.mode |= ModeNamedPipe\n\tcase syscall.S_IFLNK:\n\t\tfs.mode |= ModeSymlink\n\tcase syscall.S_IFREG:\n\tcase syscall.S_IFSOCK:\n\t\tfs.mode |= ModeSocket\n\t}\n\tif st.Mode&syscall.S_ISGID != 0 {\n\t\tfs.mode |= ModeSetgid\n\t}\n\tif st.Mode&syscall.S_ISUID != 0 {\n\t\tfs.mode |= ModeSetuid\n\t}\n\treturn fs\n}\n\nfunc timestrucToTime(ts syscall.Timestruc) time.Time {\n\treturn time.Unix(int64(ts.Sec), int64(ts.Nsec))\n}\n\n\nfunc atime(fi FileInfo) time.Time {\n\treturn timestrucToTime(fi.(*FileStat).Sys.(*syscall.Stat_t).Atime)\n}\n\nfunc sameFile(fs1, fs2 *FileStat) bool ", "output": "{\n\tsys1 := fs1.Sys.(*syscall.Stat_t)\n\tsys2 := fs2.Sys.(*syscall.Stat_t)\n\treturn sys1.Dev == sys2.Dev && sys1.Ino == sys2.Ino\n}"}
{"input": "package getopt\n\n\n\n\n\n\n\n\nfunc Bool(name rune, helpvalue ...string) *bool {\n\tvar b bool\n\tCommandLine.Flag(&b, name, helpvalue...)\n\treturn &b\n}\n\n\n\nfunc (s *Set) Bool(name rune, helpvalue ...string) *bool {\n\tvar b bool\n\ts.Flag(&b, name, helpvalue...)\n\treturn &b\n}\n\nfunc (s *Set) BoolLong(name string, short rune, helpvalue ...string) *bool {\n\tvar p bool\n\ts.FlagLong(&p, name, short, helpvalue...)\n\treturn &p\n}\n\nfunc BoolLong(name string, short rune, helpvalue ...string) *bool ", "output": "{\n\tvar p bool\n\tCommandLine.FlagLong(&p, name, short, helpvalue...)\n\treturn &p\n}"}
{"input": "package policy\n\n\n\n\n\n\n\nimport (\n\t\"github.com/Azure/go-autorest/autorest\"\n)\n\nconst (\n\tDefaultBaseURI = \"https:management.azure.com\"\n)\n\n\ntype BaseClient struct {\n\tautorest.Client\n\tBaseURI        string\n\tSubscriptionID string\n}\n\n\nfunc New(subscriptionID string) BaseClient {\n\treturn NewWithBaseURI(DefaultBaseURI, subscriptionID)\n}\n\n\n\n\n\nfunc NewWithBaseURI(baseURI string, subscriptionID string) BaseClient ", "output": "{\n\treturn BaseClient{\n\t\tClient:         autorest.NewClientWithUserAgent(UserAgent()),\n\t\tBaseURI:        baseURI,\n\t\tSubscriptionID: subscriptionID,\n\t}\n}"}
{"input": "package group\n\nimport (\n\t\"net/http\"\n\n\t\"k8s.io/apiserver/pkg/authentication/authenticator\"\n\t\"k8s.io/apiserver/pkg/authentication/user\"\n)\n\n\ntype AuthenticatedGroupAdder struct {\n\tAuthenticator authenticator.Request\n}\n\n\n\n\n\n\nfunc (g *AuthenticatedGroupAdder) AuthenticateRequest(req *http.Request) (user.Info, bool, error) {\n\tu, ok, err := g.Authenticator.AuthenticateRequest(req)\n\tif err != nil || !ok {\n\t\treturn nil, ok, err\n\t}\n\n\tif u.GetName() == user.Anonymous {\n\t\treturn u, true, nil\n\t}\n\tfor _, group := range u.GetGroups() {\n\t\tif group == user.AllAuthenticated || group == user.AllUnauthenticated {\n\t\t\treturn u, true, nil\n\t\t}\n\t}\n\n\treturn &user.DefaultInfo{\n\t\tName:   u.GetName(),\n\t\tUID:    u.GetUID(),\n\t\tGroups: append(u.GetGroups(), user.AllAuthenticated),\n\t\tExtra:  u.GetExtra(),\n\t}, true, nil\n}\n\nfunc NewAuthenticatedGroupAdder(auth authenticator.Request) authenticator.Request ", "output": "{\n\treturn &AuthenticatedGroupAdder{auth}\n}"}
{"input": "package mongo\n\nimport (\n\t\"github.com/peteraba/d5/lib/util\"\n\t\"gopkg.in/mgo.v2\"\n)\n\nvar (\n\tsession *mgo.Session\n\tdb      *mgo.Database\n)\n\nfunc SetMgoSession(mgoSession *mgo.Session) {\n\tsession = mgoSession\n}\n\nfunc SetMgoDb(mgoDatabase *mgo.Database) {\n\tdb = mgoDatabase\n}\n\nfunc CreateMgoDbFromEnvs() *mgo.Database {\n\tdbHost, dbName := ParseDbEnvs()\n\n\tmgoDb, err := CreateMgoDb(dbHost, dbName)\n\n\tif err != nil {\n\t\tutil.LogFatalfMsg(err, \"MongoDB database could not be created: %v\", true)\n\t}\n\n\treturn mgoDb\n}\n\nfunc CreateMgoDb(dbHost, dbName string) (*mgo.Database, error) {\n\tsession, err := getMgoSession(dbHost)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn getMgoDb(session, dbName), nil\n}\n\n\n\nfunc getMgoDb(mgoSession *mgo.Session, dbName string) *mgo.Database {\n\tif db != nil {\n\t\treturn db\n\t}\n\n\tmgoSession = mgoSession.Clone()\n\n\tdb = mgoSession.DB(dbName)\n\n\treturn db\n}\n\nfunc getMgoSession(dbHost string) (*mgo.Session, error) ", "output": "{\n\tvar (\n\t\terr error\n\t)\n\n\tif session != nil {\n\t\treturn session, nil\n\t}\n\n\tsession, err = mgo.Dial(dbHost)\n\n\treturn session, err\n}"}
{"input": "package indexdb\n\nimport (\n\t\"fmt\"\n\t\"github.com/eleme/banshee/models\"\n\t\"github.com/eleme/banshee/util\"\n)\n\n\n\n\n\nfunc decode(value []byte, idx *models.Index) error {\n\tn, err := fmt.Sscanf(string(value), \"%d:%f:%f\", &idx.Stamp, &idx.Score, &idx.Average)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif n != 3 {\n\t\treturn ErrCorrupted\n\t}\n\treturn nil\n}\n\nfunc encode(idx *models.Index) []byte ", "output": "{\n\tscore := util.ToFixed(idx.Score, 5)\n\taverage := util.ToFixed(idx.Average, 5)\n\ts := fmt.Sprintf(\"%d:%s:%s\", idx.Stamp, score, average)\n\treturn []byte(s)\n}"}
{"input": "package lexparser\n\nimport (\n\t\"github.com/lfmexi/golalr/prattparser\"\n\t\"github.com/lfmexi/golalr/prattparser/symbols\"\n)\n\nfunc newSimpleExpression(t symbols.Token) prattparser.Expression {\n\treturn LexerExpression{nil, nil, t}\n}\n\nfunc newPrefixExpression(t symbols.Token, l prattparser.Expression) prattparser.Expression {\n\treturn LexerExpression{\n\t\tnil,\n\t\tl,\n\t\tt,\n\t}\n}\n\nfunc newOperatorExpression(left prattparser.Expression, right prattparser.Expression, t symbols.Token) prattparser.Expression {\n\treturn LexerExpression{\n\t\tleft,\n\t\tright,\n\t\tt,\n\t}\n}\n\n\n\nfunc newPostfixExpression(left prattparser.Expression, t symbols.Token) prattparser.Expression ", "output": "{\n\treturn LexerExpression{\n\t\tleft,\n\t\tnil,\n\t\tt,\n\t}\n}"}
{"input": "package dnsimple\n\nimport (\n\t\"fmt\"\n)\n\n\n\n\ntype DomainServiceSettings struct {\n\tSettings map[string]string `url:\"settings,omitempty\"`\n}\n\n\n\n\nfunc (s *ServicesService) AppliedServices(accountID string, domainIdentifier string, options *ListOptions) (*servicesResponse, error) {\n\tpath := versioned(domainServicesPath(accountID, domainIdentifier, \"\"))\n\tservicesResponse := &servicesResponse{}\n\n\tpath, err := addURLQueryOptions(path, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := s.client.get(path, servicesResponse)\n\tif err != nil {\n\t\treturn servicesResponse, err\n\t}\n\n\tservicesResponse.HttpResponse = resp\n\treturn servicesResponse, nil\n}\n\n\n\n\nfunc (s *ServicesService) ApplyService(accountID string, serviceIdentifier string, domainIdentifier string, settings DomainServiceSettings) (*serviceResponse, error) {\n\tpath := versioned(domainServicesPath(accountID, domainIdentifier, serviceIdentifier))\n\tserviceResponse := &serviceResponse{}\n\n\tresp, err := s.client.post(path, settings, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tserviceResponse.HttpResponse = resp\n\treturn serviceResponse, nil\n}\n\n\n\n\nfunc (s *ServicesService) UnapplyService(accountID string, serviceIdentifier string, domainIdentifier string) (*serviceResponse, error) {\n\tpath := versioned(domainServicesPath(accountID, domainIdentifier, serviceIdentifier))\n\tserviceResponse := &serviceResponse{}\n\n\tresp, err := s.client.delete(path, nil, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tserviceResponse.HttpResponse = resp\n\treturn serviceResponse, nil\n}\n\nfunc domainServicesPath(accountID string, domainIdentifier string, serviceIdentifier string) string ", "output": "{\n\tif serviceIdentifier != \"\" {\n\t\treturn fmt.Sprintf(\"/%v/domains/%v/services/%v\", accountID, domainIdentifier, serviceIdentifier)\n\t}\n\treturn fmt.Sprintf(\"/%v/domains/%v/services\", accountID, domainIdentifier)\n}"}
{"input": "package app\n\nimport (\n\t\"./errors\"\n\t\"./models\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype app struct {\n\tinputFileName  string\n\tresultFilePath string\n}\n\nvar (\n\tErrs   *myErrors.Error\n\tClient *models.Client\n\tFile   *models.File\n)\n\n\n\nfunc (a *app) init() {\n\ta.Errs.Init()\n\ta.Client.Init()\n\ta.File.Init()\n\tif len(os.Args) < 2 {\n\t\ta.Errs.Check(nil, 2, \"\")\n\t}\n\ta.inputFileName = os.Args[1]\n\ta.resultFilePath = os.Args[2]\n}\n\nfunc (a *app) Start() {\n\ta.init()\n\tFile.Name = a.inputFileName\n\tfmt.Print(\"Open file \" + File.Name + \"... \")\n\tErrs.Check(File.Open())\n\tfmt.Println(\"OK\")\n\tdefer File.Basic.Close()\n\tfmt.Print(\"Read file \" + File.Name + \"... \")\n\tErrs.Check(File.Read())\n\tfmt.Println(\"OK\")\n\tfmt.Println(\"Sending file \" + File.Name + \" as \" + File.Name + \"... \")\n\tClient.Connect()\n\tClient.SendFile(File)\n\tfmt.Println(\"OK\")\n}\n\nfunc New() app ", "output": "{\n\treturn make(app)\n}"}
{"input": "package app\n\nimport (\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/fragmenta/assets\"\n\t\"github.com/fragmenta/server/config\"\n\t\"github.com/fragmenta/server/log\"\n\t\"github.com/fragmenta/view\"\n\n\t\"github.com/bitcubate/cryptojournal/src/lib/helpers\"\n)\n\n\nfunc SetupAssets() {\n\tdefer log.Time(time.Now(), log.V{\"msg\": \"Finished loading assets\"})\n\n\tassetsCompiled := config.GetBool(\"assets_compiled\")\n\n\tappAssets = assets.New(assetsCompiled)\n\n\tif config.Production() {\n\t\terr := appAssets.Load()\n\t\tif err != nil {\n\t\t\tlog.Info(log.V{\"msg\": \"Compiling Asssets\"})\n\t\t\terr := appAssets.Compile(\"src\", \"public\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(log.V{\"a\": \"unable to compile assets\", \"error\": err})\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.Info(log.V{\"msg\": \"Compiling Asssets in dev mode\"})\n\t\terr := appAssets.Compile(\"src\", \"public\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(log.V{\"a\": \"unable to compile assets\", \"error\": err})\n\t\t}\n\t}\n\n\tview.Helpers[\"style\"] = appAssets.StyleLink\n\tview.Helpers[\"script\"] = appAssets.ScriptLink\n\n}\n\n\n\n\nfunc SetupView() ", "output": "{\n\tdefer log.Time(time.Now(), log.V{\"msg\": \"Finished loading templates\"})\n\n\tview.Helpers[\"markup\"] = helpers.Markup\n\tview.Helpers[\"timeago\"] = helpers.TimeAgo\n\tview.Helpers[\"root_url\"] = helpers.RootURL\n\tview.Helpers[\"getimg\"] = helpers.GetImg\n\n\n\tview.Production = config.Production()\n\terr := view.LoadTemplates()\n\tif err != nil {\n\t\tlog.Fatal(log.V{\"msg\": \"unable to read templates\", \"error\": err})\n\t\tos.Exit(1)\n\t}\n\n}"}
{"input": "package generators\n\nimport (\n\t\"path/filepath\"\n\t\"testing\"\n)\n\n\n\nfunc TestRemoveLastDir(t *testing.T) ", "output": "{\n\ttable := map[string]struct{ newPath, removedDir string }{\n\t\t\"a/b/c\": {\"a/c\", \"b\"},\n\t}\n\tfor slashInput, expect := range table {\n\t\tinput := filepath.FromSlash(slashInput)\n\n\t\tgotPath, gotRemoved := removeLastDir(input)\n\t\tif e, a := filepath.FromSlash(expect.newPath), gotPath; e != a {\n\t\t\tt.Errorf(\"%v: wanted %v, got %v\", input, e, a)\n\t\t}\n\t\tif e, a := filepath.FromSlash(expect.removedDir), gotRemoved; e != a {\n\t\t\tt.Errorf(\"%v: wanted %v, got %v\", input, e, a)\n\t\t}\n\t}\n}"}
{"input": "package msort\n\nimport \"testing\"\n\nfunc TestPriorityQueueItemsAreSorted(t *testing.T) {\n\tpq := NewPriorityQueue()\n\n\tpq.Push(\"z\")\n\tpq.Push(\"x\")\n\tpq.Push(\"y\")\n\n\tassertEqual(t, \"x\", pq.Pop())\n\tassertEqual(t, \"y\", pq.Pop())\n\tassertEqual(t, \"z\", pq.Pop())\n}\n\nfunc TestPriorityQueueIsEmptyOnInitilisation(t *testing.T) {\n\tpq := NewPriorityQueue()\n\n\tif !pq.IsEmpty() {\n\t\tt.Error(\"PriorityQueue is not empty when first initialised\")\n\t}\n}\n\n\n\nfunc TestPriorityQueueIsEmptyAfterAllItemsPopped(t *testing.T) {\n\tpq := NewPriorityQueue()\n\n\tpq.Push(\"a\")\n\tpq.Pop()\n\n\tif !pq.IsEmpty() {\n\t\tt.Error(\"PriorityQueue is not empty after all items popped\")\n\t}\n}\n\nfunc TestPriorityQueueReturnsEmptyStringWhenEmpty(t *testing.T) {\n\tpq := NewPriorityQueue()\n\n\titem := pq.Pop()\n\n\tif item != \"\" {\n\t\tt.Error(\"Empty PriorityQueue does not return a nil item when popped\")\n\t}\n}\n\nfunc assertEqual(t *testing.T, a interface{}, b interface{}) {\n\tif a != b {\n\t\tt.Errorf(\"%v != %v\", a, b)\n\t}\n}\n\nfunc TestPriorityQueueIsNotEmptyAfterPush(t *testing.T) ", "output": "{\n\tpq := NewPriorityQueue()\n\n\tpq.Push(\"a\")\n\n\tif pq.IsEmpty() {\n\t\tt.Error(\"PriorityQueue is empty with one item\")\n\t}\n}"}
{"input": "package encode\n\nimport \"testing\"\n\nfunc TestRunLengthEncode(t *testing.T) {\n\tfor _, test := range encodeTests {\n\t\tif actual := RunLengthEncode(test.input); actual != test.expected {\n\t\t\tt.Errorf(\"FAIL %s - RunLengthEncode(%s) = %q, expected %q.\",\n\t\t\t\ttest.description, test.input, actual, test.expected)\n\t\t}\n\t\tt.Logf(\"PASS RunLengthEncode - %s\", test.description)\n\t}\n}\n\nfunc TestRunLengthEncodeDecode(t *testing.T) {\n\tfor _, test := range encodeDecodeTests {\n\t\tif actual := RunLengthDecode(RunLengthEncode(test.input)); actual != test.expected {\n\t\t\tt.Errorf(\"FAIL %s - RunLengthDecode(RunLengthEncode(%s)) = %q, expected %q.\",\n\t\t\t\ttest.description, test.input, actual, test.expected)\n\t\t}\n\t\tt.Logf(\"PASS %s\", test.description)\n\t}\n}\n\nfunc TestRunLengthDecode(t *testing.T) ", "output": "{\n\tfor _, test := range decodeTests {\n\t\tif actual := RunLengthDecode(test.input); actual != test.expected {\n\t\t\tt.Errorf(\"FAIL %s - RunLengthDecode(%s) = %q, expected %q.\",\n\t\t\t\ttest.description, test.input, actual, test.expected)\n\t\t}\n\t\tt.Logf(\"PASS RunLengthDecode - %s\", test.description)\n\t}\n}"}
{"input": "package fileset\n\nimport(\n\t\"path/filepath\"\n)\n\n\n\n\n\n\n\nfunc filterEntryMap(entryMap EntryMap, patterns []string) (newEntryMap EntryMap) {\n\tnewEntryMap = make(EntryMap)\n\tfor k, v := range entryMap {\n\t\tmatch := false\n\t\tfor _, pattern := range patterns {\n\t\t\tresult, _ := filepath.Match(pattern, k)\n\t\t\tif result {\n\t\t\t\tmatch = true\n\t\t\t}\n\t\t}\n\t\tif match {\n\t\t\tnewEntryMap[k] = v\n\t\t}\n\t}\n\treturn\n}\n\nfunc (diff EntryMapDiff) Filter(patterns []string) (newDiff EntryMapDiff) ", "output": "{\n\tnewDiff.Added = filterEntryMap(diff.Added, patterns)\n\tnewDiff.Updated = filterEntryMap(diff.Updated, patterns)\n\tnewDiff.Removed = filterEntryMap(diff.Removed, patterns)\n\treturn\n}"}
{"input": "package gammapoisson\n\nimport (\n\t\"github.com/cpalone/sample/gamma\"\n\t\"github.com/cpalone/sample/poisson\"\n)\n\n\n\ntype GammaPoisson struct {\n\tA, B float64\n}\n\n\nfunc (g *GammaPoisson) Sample() int64 {\n\treturn poisson.Sample(gamma.Sample(g.A, g.B))\n}\n\n\n\n\nfunc Sample(A, B float64) int64 ", "output": "{\n\treturn poisson.Sample(gamma.Sample(A, B))\n}"}
{"input": "package socket\n\nimport \"sync\"\n\n\ntype PacketHandler interface {\n\tOnPacket(Packet)\n}\n\n\n\n\ntype EventHandler interface {\n\tOn(event string, fn interface{}) error\n}\n\n\ntype Handler interface {\n\tEventHandler\n\tPacketHandler\n}\n\ntype handler struct {\n\tmu     sync.RWMutex\n\tevents map[string]PacketHandler\n}\n\nfunc newHandler() Handler {\n\treturn &handler{\n\t\tevents: make(map[string]PacketHandler),\n\t}\n}\n\nfunc (h *handler) On(event string, fn interface{}) (err error) {\n\th.mu.Lock()\n\tdefer h.mu.Unlock()\n\th.events[event], err = newPacketHandler(fn)\n\treturn err\n}\n\n\n\nfunc (h *handler) OnPacket(p Packet) ", "output": "{\n\th.mu.RLock()\n\tc, ok := h.events[p.Event()]\n\th.mu.RUnlock()\n\n\tif ok {\n\t\tc.OnPacket(p)\n\t}\n}"}
{"input": "package pig\n\nimport (\n\t\"errors\"\n\n\t\"github.com/jkomoros/boardgame\"\n\t\"github.com/jkomoros/boardgame/base\"\n\t\"github.com/jkomoros/boardgame/behaviors\"\n)\n\n\ntype gameState struct {\n\tbase.SubState\n\tbehaviors.CurrentPlayerBehavior\n\tDie         boardgame.SizedStack `sizedstack:\"dice\"`\n\tTargetScore int\n}\n\n\ntype playerState struct {\n\tbase.SubState\n\tBusted     bool\n\tDone       bool\n\tDieCounted bool\n\tRoundScore int\n\tTotalScore int\n}\n\nfunc concreteStates(state boardgame.ImmutableState) (*gameState, []*playerState) {\n\tgame := state.ImmutableGameState().(*gameState)\n\n\tplayers := make([]*playerState, len(state.ImmutablePlayerStates()))\n\n\tfor i, player := range state.ImmutablePlayerStates() {\n\t\tplayers[i] = player.(*playerState)\n\t}\n\n\treturn game, players\n}\n\n\n\nfunc (p *playerState) ResetForTurn() {\n\tp.Done = false\n\tp.Busted = false\n\tp.RoundScore = 0\n\tp.DieCounted = true\n}\n\nfunc (p *playerState) ResetForTurnStart() error {\n\tp.ResetForTurn()\n\treturn nil\n}\n\nfunc (p *playerState) ResetForTurnEnd() error {\n\tif p.Done {\n\t\tp.TotalScore += p.RoundScore\n\t}\n\tp.ResetForTurn()\n\treturn nil\n}\n\nfunc (p *playerState) TurnDone() error ", "output": "{\n\tif !p.DieCounted {\n\t\treturn errors.New(\"the most recent die roll has not been counted\")\n\t}\n\n\tif !p.Busted && !p.Done {\n\t\treturn errors.New(\"they have not either busted or signaled that they are done\")\n\t}\n\n\treturn nil\n}"}
{"input": "package timing\n\nimport (\n\t\"go.dedis.ch/onet/log\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar startTimes = make(map[string]time.Time)\nvar mutex sync.Mutex\n\n\n\n\n\n\n\n\nfunc StopMeasure(name string) time.Duration {\n\tnow := time.Now()\n\n\tmutex.Lock()\n\n\tif start, ok := startTimes[name]; ok {\n\t\tduration := now.Sub(start)\n\t\tdelete(startTimes, name)\n\t\tmutex.Unlock()\n\n\t\treturn duration\n\t}\n\n\tmutex.Unlock()\n\treturn time.Duration(0)\n}\n\n\nfunc StopMeasureAndLog(name string) {\n\tduration := StopMeasure(name)\n\tlog.Lvl1(\"[StopMeasureAndLog] measured time for\", name, \":\", duration.Nanoseconds(), \"ns\")\n}\n\n\nfunc StopMeasureAndLogWithInfo(name, info string) {\n\tduration := StopMeasure(name)\n\tlog.Lvl1(\"[StopMeasureAndLog] measured time for\", name, \":\", duration.Nanoseconds(), \"ns, info:\", info)\n}\n\nfunc StartMeasure(name string) ", "output": "{\n\tmutex.Lock()\n\n\tif _, present := startTimes[name]; present {\n\t\tmutex.Unlock()\n\t} else {\n\t\tstartTimes[name] = time.Now()\n\t\tmutex.Unlock()\n\t}\n}"}
{"input": "package main\n\nfunc phiOverwrite_ssa() int {\n\tvar n int\n\tfor i := 0; i < 10; i++ {\n\t\tif i == 6 {\n\t\t\tbreak\n\t\t}\n\t\tn = i\n\t}\n\treturn n\n}\n\nfunc phiOverwrite() {\n\twant := 5\n\tgot := phiOverwrite_ssa()\n\tif got != want {\n\t\tprintln(\"phiOverwrite_ssa()=\", want, \", got\", got)\n\t\tfailed = true\n\t}\n}\n\nfunc phiOverwriteBig_ssa() int {\n\tvar a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z int\n\ta = 1\n\tfor idx := 0; idx < 26; idx++ {\n\t\ta, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z = b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, a\n\t}\n\treturn a*1 + b*2 + c*3 + d*4 + e*5 + f*6 + g*7 + h*8 + i*9 + j*10 + k*11 + l*12 + m*13 + n*14 + o*15 + p*16 + q*17 + r*18 + s*19 + t*20 + u*21 + v*22 + w*23 + x*24 + y*25 + z*26\n}\n\n\n\nvar failed = false\n\nfunc main() {\n\tphiOverwrite()\n\tphiOverwriteBig()\n\tif failed {\n\t\tpanic(\"failed\")\n\t}\n}\n\nfunc phiOverwriteBig() ", "output": "{\n\twant := 1\n\tgot := phiOverwriteBig_ssa()\n\tif got != want {\n\t\tprintln(\"phiOverwriteBig_ssa()=\", want, \", got\", got)\n\t\tfailed = true\n\t}\n}"}
{"input": "package util\n\n\n\nvar poolSize int = 128\n\n\n\n\n\n\n\n\n\ntype Pool struct {\n\tpool []interface{}      \n\tin   int                \n\tout  int                \n\tlen  int                \n\tNew  func() interface{} \n}\n\n\nfunc (p *Pool) initPool() {\n\tp.pool = make([]interface{}, poolSize)\n}\n\n\n\n\n\n\n\n\n\nfunc (p *Pool) Put(x interface{}) {\n\tif p.pool == nil {\n\t\tp.initPool()\n\t}\n\tif x == nil {\n\t\treturn\n\t}\n\tif p.len == poolSize {\n\t\treturn\n\t}\n\tp.pool[p.in] = x\n\tp.in++\n\tp.in &= poolSize - 1 \n\tp.len++\n}\n\nfunc (p *Pool) Get() interface{} ", "output": "{\n\tif p.pool == nil {\n\t\tp.initPool()\n\t}\n\tif p.len > 0 {\n\t\tv := p.pool[p.out]\n\t\tp.pool[p.out] = nil \n\t\tp.out++\n\t\tp.out &= poolSize - 1 \n\t\tp.len--\n\t\treturn v\n\t}\n\tif p.New != nil {\n\t\treturn p.New()\n\t}\n\treturn nil\n}"}
{"input": "package main\n\nimport \"fmt\"\n\n\n\n\nfunc main() {\n\tdata := []int{9, 1, 8, 2, 7, 3, 6, 4, 5}\n\tSelectionSort(data)\n\tfmt.Println(data)\n}\n\nfunc SelectionSort(arr []int) ", "output": "{\n\tsize := len(arr)\n\tvar i, j, max int\n\tfor i = 0; i < size-1; i++ {\n\t\tmax = 0\n\t\tfor j = 1; j < size-1-i; j++ {\n\t\t\tif arr[j] > arr[max] {\n\t\t\t\tmax = j\n\t\t\t}\n\t\t}\n\t\tarr[size-1-i], arr[max] = arr[max], arr[size-1-i]\n\t}\n}"}
{"input": "package tiles\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n\ntype Coordinate struct {\n\tLat, Lon float64\n}\n\n\nfunc (c Coordinate) Equals(that Coordinate) bool {\n\teq := floatEquals(c.Lat, that.Lat)\n\teq = eq && floatEquals(c.Lon, that.Lon)\n\treturn eq\n}\n\n\nfunc (c Coordinate) ToPixel(zoom int) Pixel {\n\tx := (c.Lon + 180) / 360.0\n\tsinLat := math.Sin(c.Lat * math.Pi / 180.0)\n\ty := 0.5 - math.Log((1+sinLat)/(1-sinLat))/(4*math.Pi)\n\tsize := float64(mapDimensions(zoom))\n\treturn Pixel{\n\t\tX: int(clip(x*size+0.5, 0, size-1)),\n\t\tY: int(clip(y*size+0.5, 0, size-1)),\n\t\tZ: zoom,\n\t}\n\n}\n\nfunc (c Coordinate) String() string {\n\treturn fmt.Sprintf(\"(%v, %v)\", c.Lat, c.Lon)\n}\n\n\n\n\n\nfunc ClippedCoords(lat, lon float64) Coordinate ", "output": "{\n\treturn Coordinate{\n\t\tLat: clip(lat, MinLat, MaxLat),\n\t\tLon: clip(lon, MinLon, MaxLon),\n\t}\n}"}
{"input": "package otr3\n\ntype policies int\n\ntype policy int\n\nconst (\n\tallowV2 policy = 2 << iota\n\tallowV3\n\trequireEncryption\n\tsendWhitespaceTag\n\twhitespaceStartAKE\n\terrorStartAKE\n)\n\nfunc (p *policies) isOTREnabled() bool {\n\treturn p.has(allowV2) || p.has(allowV3)\n}\n\nfunc (p *policies) has(c policy) bool {\n\treturn int(*p)&int(c) == int(c)\n}\n\nfunc (p *policies) add(c policy) {\n\t*p = policies(int(*p) | int(c))\n}\n\nfunc (p *policies) AllowV2() {\n\tp.add(allowV2)\n}\n\nfunc (p *policies) AllowV3() {\n\tp.add(allowV3)\n}\n\nfunc (p *policies) RequireEncryption() {\n\tp.add(requireEncryption)\n}\n\nfunc (p *policies) SendWhitespaceTag() {\n\tp.add(sendWhitespaceTag)\n}\n\nfunc (p *policies) WhitespaceStartAKE() {\n\tp.add(whitespaceStartAKE)\n}\n\n\n\nfunc (p *policies) ErrorStartAKE() ", "output": "{\n\tp.add(errorStartAKE)\n}"}
{"input": "package data\n\nimport (\n  \"github.com/twitchyliquid64/CNC/registry/syscomponents\"\n)\n\nvar trackerObj DatabaseComponent\n\ntype DatabaseComponent struct{\n  err error\n}\n\nfunc (d *DatabaseComponent)Name() string{\n  return \"Database\"\n}\n\nfunc (d *DatabaseComponent)IsNominal()bool{\n  return d.err == nil\n}\nfunc (d *DatabaseComponent)IsDisabled()bool{\n  return false\n}\nfunc (d *DatabaseComponent)IsFault()bool{\n  return d.err != nil\n}\nfunc (d *DatabaseComponent)Error()string{\n  if d.err == nil{\n    return \"\"\n  }\n  return d.err.Error()\n}\nfunc (d *DatabaseComponent)SetError(e error){\n  d.err = e\n}\n\nfunc trackingSetup(){\n  trackerObj = DatabaseComponent{}\n  syscomponents.Register(&trackerObj)\n}\n\nfunc tracking_notifyFault(err error){\n  syscomponents.SetError(trackerObj.Name(), err)\n}\n\nfunc (d *DatabaseComponent)IconStr() string", "output": "{\n  return \"list\"\n}"}
{"input": "package gws\n\nimport (\n\t\"github.com/graphql-go/graphql/language/ast\"\n\t\"github.com/graphql-go/graphql/language/kinds\"\n)\n\n\n\nfunc selectionSetsForOperationDefinitions(defs []*ast.OperationDefinition) []*ast.SelectionSet {\n\tsets := []*ast.SelectionSet{}\n\tfor _, def := range defs {\n\t\tif set := def.GetSelectionSet(); set != nil {\n\t\t\tsets = append(sets, set)\n\t\t}\n\t}\n\treturn sets\n}\n\nfunc getSubscriptionInfo(doc *ast.Document, vars map[string]interface{}) ([]string, map[string]interface{}) {\n\n\tvar names = make([]string, 0)\n\tvar args = make(map[string]interface{})\n\n\tdefs := operationDefinitionsWithOperation(doc, \"subscription\")\n\tsets := selectionSetsForOperationDefinitions(defs)\n\n\tfor _, set := range sets {\n\t\tif len(set.Selections) >= 1 {\n\t\t\tif field, ok := set.Selections[0].(*ast.Field); ok {\n\t\t\t\tnames = append(names, field.Name.Value)\n\t\t\t\tfor _, arg := range field.Arguments {\n\t\t\t\t\tkey := arg.Name.Value\n\t\t\t\t\tswitch o := arg.Value.GetValue().(type) {\n\t\t\t\t\tcase *ast.Name:\n\t\t\t\t\t\tif d, ok := vars[o.Value]; ok {\n\t\t\t\t\t\t\targs[key] = d\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\targs[key] = nil\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\targs[key] = o\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn names, args\n}\n\nfunc operationDefinitionsWithOperation(doc *ast.Document, op string) []*ast.OperationDefinition ", "output": "{\n\tdefs := []*ast.OperationDefinition{}\n\tfor _, node := range doc.Definitions {\n\t\tif node.GetKind() == kinds.OperationDefinition {\n\t\t\tif def, ok := node.(*ast.OperationDefinition); ok {\n\t\t\t\tif def.Operation == op {\n\t\t\t\t\tdefs = append(defs, def)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn defs\n}"}
{"input": "package registry\n\nimport (\n\t\"time\"\n\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/api/errors\"\n\n\t\"github.com/openshift/origin/pkg/auth/api\"\n\t\"github.com/openshift/origin/pkg/oauth/registry/accesstoken\"\n\t\"github.com/openshift/origin/pkg/oauth/scope\"\n)\n\ntype TokenAuthenticator struct {\n\tregistry accesstoken.Registry\n}\n\nfunc NewTokenAuthenticator(registry accesstoken.Registry) *TokenAuthenticator {\n\treturn &TokenAuthenticator{\n\t\tregistry: registry,\n\t}\n}\n\n\n\nfunc (a *TokenAuthenticator) AuthenticateToken(value string) (api.UserInfo, bool, error) ", "output": "{\n\ttoken, err := a.registry.GetAccessToken(value)\n\tif errors.IsNotFound(err) {\n\t\treturn nil, false, nil\n\t}\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tif token.CreationTimestamp.Time.Add(time.Duration(token.AuthorizeToken.ExpiresIn) * time.Second).Before(time.Now()) {\n\t\treturn nil, false, nil\n\t}\n\treturn &api.DefaultUserInfo{\n\t\tName:  token.AuthorizeToken.UserName,\n\t\tUID:   token.AuthorizeToken.UserUID,\n\t\tScope: scope.Join(token.AuthorizeToken.Scopes),\n\t}, true, nil\n}"}
{"input": "package influxdbclient\n\nimport \"github.com/influxdata/influxdb1-client/v2\"\nimport \"time\"\nimport \"encoding/json\"\n\n\n\n\n\ntype DataSet struct {\n\tName       string\n\tTimeStamps []time.Time\n\tTags       map[string]string\n\tDatas      map[string][]float64\n}\n\n\nfunc NewDataSet(length int, fields []string) *DataSet {\n\tds := DataSet{TimeStamps: make([]time.Time, length), Datas: make(map[string][]float64)}\n\n\tfor _, fieldname := range fields {\n\t\tds.Datas[fieldname] = make([]float64, length)\n\t}\n\treturn &ds\n}\n\n\n\n\nfunc ConvertToDataSet(res []client.Result) (dsets []*DataSet) ", "output": "{\n\tif len(res[0].Series) == 0 {\n\t\treturn\n\t}\n\n\tfor _, serie := range res[0].Series {\n\t\tds := NewDataSet(len(serie.Values), serie.Columns[1:])\n\n\t\tds.Name = serie.Name\n\t\tds.Tags = serie.Tags\n\t\tfor i, row := range serie.Values {\n\n\t\t\tt, _ := time.Parse(time.RFC3339, row[0].(string))\n\n\t\t\tds.TimeStamps[i] = t\n\n\t\t\tfor j, field := range row {\n\t\t\t\tif j == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfieldname := serie.Columns[j]\n\t\t\t\tif field != nil {\n\t\t\t\t\tval, _ := field.(json.Number).Float64()\n\t\t\t\t\tds.Datas[fieldname][i] = val\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdsets = append(dsets, ds)\n\t}\n\treturn\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\n\t\"github.com/hyperledger/fabric/core/chaincode/shim\"\n\tpb \"github.com/hyperledger/fabric/protos/peer\"\n)\n\n\ntype SimpleChaincode struct {\n}\n\n\n\n\n\nfunc (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface) pb.Response {\n\tfunction, args := stub.GetFunctionAndParameters()\n\tif function == \"query\" {\n\t\treturn t.query(stub, args)\n\t}\n\n\treturn shim.Error(\"Invalid invoke function name. Expecting \\\"query\\\"\")\n}\n\nfunc (t *SimpleChaincode) query(stub shim.ChaincodeStubInterface, args []string) pb.Response {\n\tvar A string \n\tvar Aval int \n\tvar err error\n\n\tif len(args) != 2 {\n\t\treturn shim.Error(\"Incorrect number of arguments. Expecting 2\")\n\t}\n\n\tA = args[0]\n\tAval, err = strconv.Atoi(args[1])\n\tif err != nil {\n\t\treturn shim.Error(\"Expecting integer value for asset holding\")\n\t}\n\tfmt.Printf(\"Aval = %d\\n\", Aval)\n\n\terr = stub.PutState(A, []byte(strconv.Itoa(Aval)))\n\tif err != nil {\n\t\tjsonResp := \"{\\\"Error\\\":\\\"Cannot put state within chaincode query\\\"}\"\n\t\treturn shim.Error(jsonResp)\n\t}\n\n\treturn shim.Success(nil)\n}\n\nfunc main() {\n\terr := shim.Start(new(SimpleChaincode))\n\tif err != nil {\n\t\tfmt.Printf(\"Error starting chaincode: %s\", err)\n\t}\n}\n\nfunc (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface) pb.Response ", "output": "{\n\tvar A string \n\tvar Aval int \n\tvar err error\n\t_, args := stub.GetFunctionAndParameters()\n\tif len(args) != 2 {\n\t\treturn shim.Error(\"Incorrect number of arguments. Expecting 2\")\n\t}\n\n\tA = args[0]\n\tAval, err = strconv.Atoi(args[1])\n\tif err != nil {\n\t\treturn shim.Error(\"Expecting integer value for asset holding\")\n\t}\n\tfmt.Printf(\"Aval = %d\\n\", Aval)\n\n\terr = stub.PutState(A, []byte(strconv.Itoa(Aval)))\n\tif err != nil {\n\t\treturn shim.Error(err.Error())\n\t}\n\n\treturn shim.Success(nil)\n}"}
{"input": "package xhandler\n\nimport (\n\t\"net/http\"\n\n\t\"golang.org/x/net/context\"\n)\n\n\ntype HandlerC interface {\n\tServeHTTPC(context.Context, http.ResponseWriter, *http.Request)\n}\n\n\n\n\ntype HandlerFuncC func(context.Context, http.ResponseWriter, *http.Request)\n\n\n\n\n\n\n\nfunc New(ctx context.Context, h HandlerC) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\th.ServeHTTPC(ctx, w, r)\n\t})\n}\n\nfunc (f HandlerFuncC) ServeHTTPC(ctx context.Context, w http.ResponseWriter, r *http.Request) ", "output": "{\n\tf(ctx, w, r)\n}"}
{"input": "package types\n\ntype UserOverviewId int64\ntype UserOverviewIds []UserOverviewId\ntype UserOverviewStatus int8\n\nfunc (self UserOverviewIds) AsInt64Arr() []int64 {\n\tids := make([]int64, len(self))\n\n\tfor i, id := range self {\n\t\tids[i] = int64(id)\n\t}\n\n\treturn ids\n}\n\nfunc ParseUserOverviewStatus(value int) UserOverviewStatus {\n\tswitch value {\n\tcase -1:\n\t\treturn UserOverviewStatusDeleted\n\tcase 1:\n\t\treturn UserOverviewStatusActive\n\tdefault:\n\t\treturn UserOverviewStatusUnknown\n\t}\n}\n\nfunc (self UserOverviewStatus) String() string {\n\tswitch self {\n\tcase UserOverviewStatusDeleted:\n\t\treturn \"deleted\"\n\tcase UserOverviewStatusActive:\n\t\treturn \"active\"\n\tdefault:\n\t\treturn \"unknown\"\n\t}\n}\n\nvar (\n\tUserOverviewStatusDeleted UserOverviewStatus = -1\n\tUserOverviewStatusUnknown UserOverviewStatus = 0\n\tUserOverviewStatusActive  UserOverviewStatus = 1\n)\n\ntype UserOverview struct {\n\tBaseEntity\n\tId              UserOverviewId     `json:\"id\" datastore:\"-\" siren:\"property\"`\n\tStatus          UserOverviewStatus `json:\"status\" datastore:\"status\" siren:\"property\"`\n\tStatusFormatted string             `json:\"status_formatted\" datastore:\"-\" siren:\"property\"`\n\n\tOverviewId OverviewId `json:\"overview_id\" datastore:\"overview_id\"`\n\tUserId     UserId     `json:\"user_id\" datastore:\"user_id\"`\n}\n\nfunc (self *UserOverview) SetFormattedValues() {\n\tself.SetTimes()\n\tself.SetStatusFormatted()\n}\n\n\n\ntype UserOverviews []UserOverview\n\nfunc (self *UserOverview) SetStatusFormatted() ", "output": "{\n\tself.StatusFormatted = self.Status.String()\n}"}
{"input": "package tick_test\n\nimport (\n\t\"testing\"\n)\n\n\n\nfunc TestKapacitorLoopback(t *testing.T) ", "output": "{\n\tpipe, _, from := StreamFrom()\n\tloop := from.KapacitorLoopback()\n\tloop.Database = \"mydb\"\n\tloop.RetentionPolicy = \"myrp\"\n\tloop.Measurement = \"meas\"\n\tloop.Tag(\"vocabulary\", \"volcano\")\n\tloop.Tag(\"season\", \"winter\")\n\n\twant := `stream\n    |from()\n    |kapacitorLoopback()\n        .database('mydb')\n        .retentionPolicy('myrp')\n        .measurement('meas')\n        .tag('season', 'winter')\n        .tag('vocabulary', 'volcano')\n`\n\tPipelineTickTestHelper(t, pipe, want)\n}"}
{"input": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/streadway/amqp\"\n)\n\n\n\nfunc TestMessageParsing(t *testing.T) ", "output": "{\n\theaders := make(amqp.Table, 0)\n\tvar ttl int32 = 13\n\theaders[\"ttl\"] = ttl\n\tbody := \"test message\"\n\tmessage := amqp.Delivery{\n\t\tRoutingKey: \"user.18\",\n\t\tBody:       []byte(body),\n\t\tHeaders:    headers,\n\t}\n\tparsed, _ := ParseMessage(message)\n\tif parsed.Message != body || parsed.UID != 18 || parsed.TTL != 13 {\n\t\tt.Fatalf(\"%v\", parsed)\n\t}\n\n}"}
{"input": "package sys\n\nimport \"github.com/e-XpertSolutions/f5-rest-client/f5\"\n\n\ntype SFlowConfigList struct {\n\tItems    []SFlowConfig `json:\"items\"`\n\tKind     string        `json:\"kind\"`\n\tSelfLink string        `json:\"selflink\"`\n}\n\n\ntype SFlowConfig struct {\n\tReference struct {\n\t\tLink string `json:\"link\"`\n\t} `json:\"reference\"`\n}\n\n\nconst SFlowEndpoint = \"/sflow\"\n\n\ntype SFlowResource struct {\n\tc *f5.Client\n}\n\n\nfunc (r *SFlowResource) ListAll() (*SFlowConfigList, error) {\n\tvar list SFlowConfigList\n\tif err := r.c.ReadQuery(BasePath+SFlowEndpoint, &list); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &list, nil\n}\n\n\nfunc (r *SFlowResource) Get(id string) (*SFlowConfig, error) {\n\tvar item SFlowConfig\n\tif err := r.c.ReadQuery(BasePath+SFlowEndpoint, &item); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &item, nil\n}\n\n\nfunc (r *SFlowResource) Create(item SFlowConfig) error {\n\tif err := r.c.ModQuery(\"POST\", BasePath+SFlowEndpoint, item); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\nfunc (r *SFlowResource) Edit(id string, item SFlowConfig) error {\n\tif err := r.c.ModQuery(\"PUT\", BasePath+SFlowEndpoint+\"/\"+id, item); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\n\n\nfunc (r *SFlowResource) Delete(id string) error ", "output": "{\n\tif err := r.c.ModQuery(\"DELETE\", BasePath+SFlowEndpoint+\"/\"+id, nil); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package net\n\nimport (\n\t\"io\"\n)\n\nconst (\n\tbufferSize = 4 * 1024\n)\n\n\nfunc ReaderToChan(stream chan<- []byte, reader io.Reader) error {\n\tfor {\n\t\tbuffer := make([]byte, bufferSize)\n\t\tnBytes, err := reader.Read(buffer)\n\t\tif nBytes > 0 {\n\t\t\tstream <- buffer[:nBytes]\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n\n\n\nfunc ChanToWriter(writer io.Writer, stream <-chan []byte) error ", "output": "{\n\tfor buffer := range stream {\n\t\t_, err := writer.Write(buffer)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"}
{"input": "package main\n\nimport \"fmt\"\n\n\n\n\n\n\n\n\nfunc main() {\n\tname := \"Diff 21\"\n\tfmt.Println(name, \"1:\", diff21(19))\n\tfmt.Println(name, \"2:\", diff21(10))\n\tfmt.Println(name, \"3:\", diff21(21))\n}\n\n\n\nfunc diff21(n int) int ", "output": "{\n\tif n > 21 {\n\t\treturn (n - 21) * 2\n\t}\n\n\treturn 21 - n\n}"}
{"input": "package geth\n\nimport (\n\t\"os\"\n\n\t\"github.com/matthieu/go-ethereum/log\"\n)\n\n\n\n\nfunc SetVerbosity(level int) ", "output": "{\n\tlog.Root().SetHandler(log.LvlFilterHandler(log.Lvl(level), log.StreamHandler(os.Stderr, log.TerminalFormat(false))))\n}"}
{"input": "package aws\n\nimport (\n\t\"time\"\n)\n\n\n\n\n\n\n\n\nfunc SleepWithContext(ctx Context, dur time.Duration) error ", "output": "{\n\tt := time.NewTimer(dur)\n\tdefer t.Stop()\n\n\tselect {\n\tcase <-t.C:\n\t\tbreak\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\t}\n\n\treturn nil\n}"}
{"input": "package models\n\n\n\n\nimport (\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n)\n\n\n\n\ntype IdentityEndpoints struct {\n\n\tIdentity *Identity `json:\"identity,omitempty\"`\n\n\tRefCount int64 `json:\"refCount,omitempty\"`\n}\n\n\nfunc (m *IdentityEndpoints) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateIdentity(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\n\n\n\nfunc (m *IdentityEndpoints) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\nfunc (m *IdentityEndpoints) UnmarshalBinary(b []byte) error {\n\tvar res IdentityEndpoints\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}\n\nfunc (m *IdentityEndpoints) validateIdentity(formats strfmt.Registry) error ", "output": "{\n\n\tif swag.IsZero(m.Identity) { \n\t\treturn nil\n\t}\n\n\tif m.Identity != nil {\n\t\tif err := m.Identity.Validate(formats); err != nil {\n\t\t\tif ve, ok := err.(*errors.Validation); ok {\n\t\t\t\treturn ve.ValidateName(\"identity\")\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}"}
{"input": "package search\n\nimport (\n  \"encoding/json\"\n  \"os\"\n)\n\nconst dataFile = \"data/data.json\"\n\ntype Feed struct {\n  Name  string  `json:\"site\"`\n  URI   string  `json:\"link\"`\n  Type  string  `json:\"type\"`\n}\n\n\n\nfunc RetriveFeeds() ([]*Feed, error)  ", "output": "{\n  file, err := os.Open(dataFile)\n  if err != nil {\n    return nil, err\n  }\n\n  defer file.Close()\n\n  var feeds []*Feed\n  err = json.NewDecoder(file).Decode(&feeds)\n\n  return feeds, err\n}"}
{"input": "package metric\n\nimport (\n\t\"reflect\"\n\t\"strconv\"\n\t\"unsafe\"\n)\n\n\nfunc parseIntBytes(b []byte, base int, bitSize int) (i int64, err error) {\n\ts := unsafeBytesToString(b)\n\treturn strconv.ParseInt(s, base, bitSize)\n}\n\n\nfunc parseFloatBytes(b []byte, bitSize int) (float64, error) {\n\ts := unsafeBytesToString(b)\n\treturn strconv.ParseFloat(s, bitSize)\n}\n\n\n\n\n\n\n\n\nfunc unsafeBytesToString(in []byte) string {\n\tsrc := *(*reflect.SliceHeader)(unsafe.Pointer(&in))\n\tdst := reflect.StringHeader{\n\t\tData: src.Data,\n\t\tLen:  src.Len,\n\t}\n\ts := *(*string)(unsafe.Pointer(&dst))\n\treturn s\n}\n\nfunc parseBoolBytes(b []byte) (bool, error) ", "output": "{\n\treturn strconv.ParseBool(unsafeBytesToString(b))\n}"}
{"input": "package grequests\n\nimport \"testing\"\n\nfunc TestErrorOpenFile(t *testing.T) {\n\tfd, err := FileUploadFromDisk(\"I am Not A File\")\n\tif err == nil {\n\t\tt.Error(\"We are not getting an error back from our non existent file: \")\n\t}\n\n\tif fd != nil {\n\t\tt.Error(\"We actually got back a pointer: \", fd)\n\t}\n}\n\nfunc TestGLOBFiles(t *testing.T) {\n\tfd, err := FileUploadFromGlob(\"testdata/*\")\n\n\tif err != nil {\n\t\tt.Error(\"Got an invalid GLOB: \", err)\n\t}\n\n\tif len(fd) != 2 {\n\t\tt.Error(\"Some how we have more than two files in our glob\", len(fd), fd)\n\t}\n}\n\nfunc TestInvalidGlob(t *testing.T) {\n\tif _, err := FileUploadFromGlob(\"[-]\"); err == nil {\n\t\tt.Error(\"Somehow the glob worked\")\n\t}\n}\n\nfunc TestNoGlobFiles(t *testing.T) {\n\tif _, err := FileUploadFromGlob(\"notapath\"); err == nil {\n\t\tt.Error(\"Somehow got a valid GLOB\")\n\t}\n}\n\n\n\nfunc TestGlobWithDir(t *testing.T) ", "output": "{\n\tfd, err := FileUploadFromGlob(\"*test*\")\n\n\tif err != nil {\n\t\tt.Error(\"Glob failed\", err)\n\t}\n\n\tfor _, f := range fd {\n\t\tif f.FileName == \"test_files\" {\n\t\t\tt.Error(f, \"is a dir (which cannot be uploaded)\")\n\t\t}\n\t}\n\n}"}
{"input": "package goetchtest\n\nimport . \"etch\"\n\nfunc TestPlainMailBox() {\n\tmb := NewPlainMailBox(42)\n\n\tif mb.GetMessageId() != 42 {\n\t\tError(\"Mailbox has wrong ID\\n\")\n\t}\n\n\tmsg := new(Message)\n\n\tsender := 23\n\n\tgo TestPut(mb, msg, sender)\n\n\telem := mb.Read()\n\n\tif elem == nil {\n\t\tError(\"got nil elem from Mailbox\\n\")\n\t} else {\n\t\tif elem.Msg != msg {\n\t\t\tError(\"got wrong elem from Mailbox\\n\")\n\t\t}\n\n\t\tif elem.Who != 23 {\n\t\t\tError(\"got wrong sender from Mailbox\\n\")\n\t\t}\n\t}\n\n\n\n\tLog(\"TestPlainMailBox done\\n\")\n}\n\n\n\n\nfunc TestPut(mb Mailbox, msg *Message, sender interface{}) ", "output": "{\n\tmb.Message(sender, msg)\n}"}
{"input": "package vision_test\n\nimport (\n\t\"context\"\n\n\tvision \"cloud.google.com/go/vision/apiv1\"\n\tvisionpb \"google.golang.org/genproto/googleapis/cloud/vision/v1\"\n)\n\nfunc ExampleNewImageAnnotatorClient() {\n\tctx := context.Background()\n\tc, err := vision.NewImageAnnotatorClient(ctx)\n\tif err != nil {\n\t}\n\t_ = c\n}\n\nfunc ExampleImageAnnotatorClient_BatchAnnotateImages() {\n\tctx := context.Background()\n\tc, err := vision.NewImageAnnotatorClient(ctx)\n\tif err != nil {\n\t}\n\n\treq := &visionpb.BatchAnnotateImagesRequest{\n\t}\n\tresp, err := c.BatchAnnotateImages(ctx, req)\n\tif err != nil {\n\t}\n\t_ = resp\n}\n\nfunc ExampleImageAnnotatorClient_BatchAnnotateFiles() {\n\tctx := context.Background()\n\tc, err := vision.NewImageAnnotatorClient(ctx)\n\tif err != nil {\n\t}\n\n\treq := &visionpb.BatchAnnotateFilesRequest{\n\t}\n\tresp, err := c.BatchAnnotateFiles(ctx, req)\n\tif err != nil {\n\t}\n\t_ = resp\n}\n\n\n\nfunc ExampleImageAnnotatorClient_AsyncBatchAnnotateFiles() {\n\tctx := context.Background()\n\tc, err := vision.NewImageAnnotatorClient(ctx)\n\tif err != nil {\n\t}\n\n\treq := &visionpb.AsyncBatchAnnotateFilesRequest{\n\t}\n\top, err := c.AsyncBatchAnnotateFiles(ctx, req)\n\tif err != nil {\n\t}\n\n\tresp, err := op.Wait(ctx)\n\tif err != nil {\n\t}\n\t_ = resp\n}\n\nfunc ExampleImageAnnotatorClient_AsyncBatchAnnotateImages() ", "output": "{\n\tctx := context.Background()\n\tc, err := vision.NewImageAnnotatorClient(ctx)\n\tif err != nil {\n\t}\n\n\treq := &visionpb.AsyncBatchAnnotateImagesRequest{\n\t}\n\top, err := c.AsyncBatchAnnotateImages(ctx, req)\n\tif err != nil {\n\t}\n\n\tresp, err := op.Wait(ctx)\n\tif err != nil {\n\t}\n\t_ = resp\n}"}
{"input": "package daemon\n\nimport (\n\tderr \"github.com/docker/docker/api/errors\"\n)\n\n\n\n\nfunc (daemon *Daemon) ContainerUnpause(name string) error ", "output": "{\n\tcontainer, err := daemon.Get(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := container.unpause(); err != nil {\n\t\treturn derr.ErrorCodeCantUnpause.WithArgs(name, err)\n\t}\n\n\treturn nil\n}"}
{"input": "package awsauth\n\nimport (\n\t\"bytes\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n)\n\n\nfunc SignatureV2(req *http.Request, Auth interface{}) (err error) {\n\tauth, _ := Auth.(map[string]string)\n\tqueryVals := req.URL.Query()\n\tqueryVals.Set(\"AWSAccessKeyId\", auth[\"AccessKey\"])\n\tqueryVals.Set(\"SignatureVersion\", \"2\")\n\tqueryVals.Set(\"SignatureMethod\", \"HmacSHA256\")\n\n\tqueryStr, err := canonicalQueryString(queryVals)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpath := req.URL.Path\n\tif path == \"\" {\n\t\tpath = \"/\"\n\t}\n\n\tpayload := new(bytes.Buffer)\n\tpayloadstring := checkrequestMethod(req.Method) + \"\\n\" + req.Host + \"\\n\" + path + \"\\n\" + queryStr\n\tfmt.Fprintf(payload, \"%s\", payloadstring)\n\thash := hmac.New(sha256.New, []byte(auth[\"SecretKey\"]))\n\thash.Write(payload.Bytes())\n\tsignature := make([]byte, base64.StdEncoding.EncodedLen(hash.Size()))\n\tbase64.StdEncoding.Encode(signature, hash.Sum(nil))\n\n\tqueryVals.Set(\"Signature\", string(signature))\n\treq.URL.RawQuery = queryVals.Encode()\n\treturn nil\n}\n\nfunc canonicalQueryString(queryString url.Values) (string, error) {\n\treturn strings.Replace(queryString.Encode(), \"+\", \"%20\", -1), nil\n}\n\n\n\nfunc checkrequestMethod(rawMethod string) (verb string) ", "output": "{\n\trawMethodverb := strings.SplitN(rawMethod, \" \", 2)\n\tswitch {\n\tcase len(rawMethodverb) == 0:\n\t\tverb = \"GET\"\n\tdefault:\n\t\tverb = rawMethodverb[0]\n\t}\n\treturn verb\n}"}
{"input": "package bunyan\n\nimport \"os\"\n\n\n\ntype Sink interface {\n\tWrite(record Record) error\n}\n\ntype funcSink struct {\n\twrite func(record Record) error\n}\n\nfunc (sink *funcSink) Write(record Record) error {\n\treturn sink.write(record)\n}\n\n\n\nfunc SinkFunc(write func(record Record) error) Sink {\n\treturn &funcSink{write}\n}\n\n\n\n\n\nfunc InfoSink(target Sink, info Info) Sink {\n\treturn SinkFunc(func(record Record) error {\n\t\trecord.SetIfNot(info.Key(), info.Value())\n\t\treturn target.Write(record)\n\t})\n}\n\n\nfunc StdoutSink() Sink {\n\treturn NewJsonSink(os.Stdout)\n}\n\n\nfunc FileSink(path string) Sink {\n\tconst flags = os.O_CREATE | os.O_APPEND | os.O_WRONLY\n\tfile, e := os.OpenFile(path, flags, 0666)\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\n\treturn NewJsonSink(file)\n}\n\nfunc NilSink() Sink ", "output": "{\n\treturn SinkFunc(func(record Record) error {\n\t\treturn nil \n\t})\n}"}
{"input": "package atomic\n\nimport \"sync/atomic\"\n\n\ntype String struct{ v atomic.Value }\n\n\nfunc NewString(str string) *String {\n\ts := &String{}\n\tif str != \"\" {\n\t\ts.Store(str)\n\t}\n\treturn s\n}\n\n\nfunc (s *String) Load() string {\n\tv := s.v.Load()\n\tif v == nil {\n\t\treturn \"\"\n\t}\n\treturn v.(string)\n}\n\n\n\n\n\n\nfunc (s *String) Store(str string) ", "output": "{\n\ts.v.Store(str)\n}"}
{"input": "package trace \n\nimport (\n\t\"context\"\n\t\"runtime\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"google.golang.org/grpc/metadata\"\n)\n\n\n\n\nfunc DefaultAuthScopes() []string {\n\treturn []string{\n\t\t\"https:www.googleapis.com/auth/cloud-platform\",\n\t\t\"https:www.googleapis.com/auth/trace.append\",\n\t\t\"https:www.googleapis.com/auth/trace.readonly\",\n\t}\n}\n\n\n\nfunc versionGo() string {\n\tconst develPrefix = \"devel +\"\n\n\ts := runtime.Version()\n\tif strings.HasPrefix(s, develPrefix) {\n\t\ts = s[len(develPrefix):]\n\t\tif p := strings.IndexFunc(s, unicode.IsSpace); p >= 0 {\n\t\t\ts = s[:p]\n\t\t}\n\t\treturn s\n\t}\n\n\tnotSemverRune := func(r rune) bool {\n\t\treturn strings.IndexRune(\"0123456789.\", r) < 0\n\t}\n\n\tif strings.HasPrefix(s, \"go1\") {\n\t\ts = s[2:]\n\t\tvar prerelease string\n\t\tif p := strings.IndexFunc(s, notSemverRune); p >= 0 {\n\t\t\ts, prerelease = s[:p], s[p:]\n\t\t}\n\t\tif strings.HasSuffix(s, \".\") {\n\t\t\ts += \"0\"\n\t\t} else if strings.Count(s, \".\") < 2 {\n\t\t\ts += \".0\"\n\t\t}\n\t\tif prerelease != \"\" {\n\t\t\ts += \"-\" + prerelease\n\t\t}\n\t\treturn s\n\t}\n\treturn \"UNKNOWN\"\n}\n\nconst versionClient = \"20181129\"\n\nfunc insertMetadata(ctx context.Context, mds ...metadata.MD) context.Context ", "output": "{\n\tout, _ := metadata.FromOutgoingContext(ctx)\n\tout = out.Copy()\n\tfor _, md := range mds {\n\t\tfor k, v := range md {\n\t\t\tout[k] = append(out[k], v...)\n\t\t}\n\t}\n\treturn metadata.NewOutgoingContext(ctx, out)\n}"}
{"input": "package msd\n\nimport (\n\t\"encoding/base64\"\n\t\"github.com/bluefw/blued/discoverd/api\"\n\t\"github.com/gin-gonic/gin\"\n\t\"log\"\n\t\"net/http\"\n)\n\ntype ServiceResource struct {\n\trepo   *DiscoverdRepo\n\tlogger *log.Logger\n}\n\nfunc NewServiceResource(dr *DiscoverdRepo, l *log.Logger) *ServiceResource {\n\treturn &ServiceResource{\n\t\trepo:   dr,\n\t\tlogger: l,\n\t}\n}\n\nfunc (sr *ServiceResource) RegMicroApp(c *gin.Context) {\n\tvar as api.MicroApp\n\tif err := c.Bind(&as); err != nil {\n\t\tc.JSON(http.StatusBadRequest, api.NewError(\"problem decoding body\"))\n\t\treturn\n\t}\n\n\tsr.repo.Register(&as)\n\tc.JSON(http.StatusCreated, nil)\n}\n\nfunc (sr *ServiceResource) GetRouterTable(c *gin.Context) {\n\taddr, err := base64.StdEncoding.DecodeString(c.Params.ByName(\"addr\"))\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, api.NewError(\"error decoding addr\"))\n\t\treturn\n\t}\n\trt := sr.repo.GetRouterTable(string(addr))\n\tc.JSON(http.StatusOK, rt)\n}\n\n\n\nfunc (sr *ServiceResource) Refresh(c *gin.Context) ", "output": "{\n\taddr, err := base64.StdEncoding.DecodeString(c.Params.ByName(\"addr\"))\n\tif err != nil {\n\t\tc.JSON(http.StatusBadRequest, api.NewError(\"error decoding addr\"))\n\t\treturn\n\t}\n\tappStatus := sr.repo.Refresh(string(addr))\n\tc.JSON(http.StatusAccepted, appStatus)\n}"}
{"input": "package csl\nimport (\n\t\"github.com/abieberbach/goplane/extra/logging\"\n\t\"fmt\"\n)\n\ntype CslPackage struct {\n\tName         string\n\tDependencies []string\n\tBaseDirectory string\n\tAircrafts    []*CslAircraft\n\tValid        bool\n}\n\nfunc (self *CslPackage) validate(allPackages *CslPackages) {\n\tself.checkDependencies(allPackages)\n\tif !self.Valid {\n\t\treturn\n\t}\n\tself.checkAircrafts(allPackages)\n\tif !self.Valid {\n\t\treturn\n\t}\n\tlogging.Infof(\"package \\\"%v\\\" is valid\", self.Name)\n}\n\nfunc (self *CslPackage) checkDependencies(allPackages *CslPackages) {\n\tfor _, dep := range self.Dependencies {\n\t\t_, found := allPackages.GetPackage(dep)\n\t\tif !found {\n\t\t\tself.invalidate(\"missing dependency package \\\"%v\\\"\", dep)\n\t\t}\n\t}\n}\n\nfunc (self *CslPackage) checkAircrafts(allPackages *CslPackages) {\n\tfor _, currentAircraft := range self.Aircrafts {\n\t\tok,validationMessage := currentAircraft.validate(allPackages)\n\t\tif !ok {\n\t\t\tself.invalidate(validationMessage)\n\t\t}\n\t}\n}\n\n\n\nfunc (self *CslPackage) invalidate(msg string, params... interface{}) ", "output": "{\n\tlogging.Warningf(\"invalid package \\\"%v\\\", reason: %v [base directory: %v]\", self.Name, fmt.Sprintf(msg, params...),self.BaseDirectory)\n\tself.Valid = false\n}"}
{"input": "package openshift\n\nimport (\n\t\"context\"\n\n\tocpsecurityv1api \"github.com/openshift/api/security/v1\"\n\tocpsecurityv1client \"github.com/openshift/client-go/security/clientset/versioned/typed/security/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\n\ntype SecurityContextConstraintsOps interface {\n\tListSecurityContextConstraints() (*ocpsecurityv1api.SecurityContextConstraintsList, error)\n\tGetSecurityContextConstraints(string) (*ocpsecurityv1api.SecurityContextConstraints, error)\n\tUpdateSecurityContextConstraints(*ocpsecurityv1api.SecurityContextConstraints) (*ocpsecurityv1api.SecurityContextConstraints, error)\n}\n\nfunc (c *Client) getOcpSecurityClient() ocpsecurityv1client.SecurityV1Interface {\n\treturn c.ocpSecurityClient.SecurityV1()\n}\n\n\nfunc (c *Client) ListSecurityContextConstraints() (result *ocpsecurityv1api.SecurityContextConstraintsList, err error) {\n\tif err := c.initClient(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.getOcpSecurityClient().SecurityContextConstraints().List(context.TODO(), metav1.ListOptions{})\n}\n\n\n\n\n\nfunc (c *Client) UpdateSecurityContextConstraints(securityContextConstraints *ocpsecurityv1api.SecurityContextConstraints) (result *ocpsecurityv1api.SecurityContextConstraints, err error) {\n\tif err := c.initClient(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.getOcpSecurityClient().SecurityContextConstraints().Update(context.TODO(), securityContextConstraints, metav1.UpdateOptions{})\n}\n\nfunc (c *Client) GetSecurityContextConstraints(name string) (result *ocpsecurityv1api.SecurityContextConstraints, err error) ", "output": "{\n\tif err := c.initClient(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.getOcpSecurityClient().SecurityContextConstraints().Get(context.TODO(), name, metav1.GetOptions{})\n}"}
{"input": "package sysfs\n\nimport (\n\t\"strings\"\n)\n\ntype Object string\n\n\n\nfunc (obj Object) Name() string {\n\treturn string(obj)[strings.LastIndex(string(obj), \"/\")+1:]\n}\n\nfunc (obj Object) SubObjects() []Object {\n\tpath := string(obj) + \"/\"\n\tobjects := make([]Object, 0)\n\tlsDirs(path, func(name string) {\n\t\tobjects = append(objects, Object(path+name))\n\t})\n\treturn objects\n}\n\nfunc (obj Object) SubObject(name string) Object {\n\treturn Object(string(obj) + \"/\" + name)\n}\n\nfunc (obj Object) Attributes() []Attribute {\n\tpath := string(obj) + \"/\"\n\tattribs := make([]Attribute, 0)\n\tlsFiles(path, func(name string) {\n\t\tattribs = append(attribs, Attribute{Path: path + name})\n\t})\n\treturn attribs\n}\n\nfunc (obj Object) Attribute(name string) *Attribute {\n\treturn &Attribute{Path: string(obj) + \"/\" + name}\n}\n\nfunc (obj Object) Exists() bool ", "output": "{\n\treturn dirExists(string(obj))\n}"}
{"input": "package console\n\nimport (\n\tv1 \"github.com/cgrates/cgrates/apier/v1\"\n\t\"github.com/cgrates/cgrates/engine\"\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\nfunc init() {\n\tc := &CmdSetRoute{\n\t\tname:      \"routes_profile_set\",\n\t\trpcMethod: utils.APIerSv1SetRouteProfile,\n\t\trpcParams: &v1.RouteWithAPIOpts{},\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}\n\ntype CmdSetRoute struct {\n\tname      string\n\trpcMethod string\n\trpcParams *v1.RouteWithAPIOpts\n\t*CommandExecuter\n}\n\nfunc (self *CmdSetRoute) Name() string {\n\treturn self.name\n}\n\n\n\nfunc (self *CmdSetRoute) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &v1.RouteWithAPIOpts{\n\t\t\tRouteProfile: new(engine.RouteProfile),\n\t\t\tAPIOpts:      map[string]interface{}{},\n\t\t}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *CmdSetRoute) PostprocessRpcParams() error {\n\treturn nil\n}\n\nfunc (self *CmdSetRoute) RpcResult() interface{} {\n\tvar s string\n\treturn &s\n}\n\nfunc (self *CmdSetRoute) RpcMethod() string ", "output": "{\n\treturn self.rpcMethod\n}"}
{"input": "package config\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/BurntSushi/toml\"\n\n\t\"github.com/netrack/netrack/config/environment\"\n)\n\n\ntype Config struct {\n\tID string `toml:\"instance_id\"`\n\n\tOFPEndpoint string `toml:\"openflow_endpoint\"`\n\n\tAPIEndpoint string `toml:\"api_endpoint\"`\n\n\tTLSEnable             bool   `toml:\"tls_enable\"`\n\tTLSInsecureSkipVerify bool   `toml:\"tls_insecure_skip_verify\"`\n\tTLSCertFile           string `toml:\"tls_x509_cert_file\"`\n\tTLSKeyFile            string `toml:\"tls_x509_key_file\"`\n\n\tDatabase map[string]DatabaseConfig `toml:\"database\"`\n}\n\n\n\n\ntype DatabaseConfig struct {\n\tUser     string `toml:\"user\"`\n\tPassword string `toml:\"password\"`\n\tDBName   string `toml:\"dbname\"`\n\tSSLMode  string `toml:\"sslmode\"`\n}\n\nfunc LoadFile(configPath string) (*Config, error) {\n\tvar config Config\n\t_, err := toml.DecodeFile(configPath, &config)\n\treturn &config, err\n}\n\nfunc (c *Config) ConnString() string ", "output": "{\n\tdbconfig := c.Database[environment.Env]\n\treturn fmt.Sprintf(\"user=%s password=%s dbname=%s sslmode=%s\",\n\t\tdbconfig.User, dbconfig.Password, dbconfig.DBName, dbconfig.SSLMode)\n}"}
{"input": "package userpass\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"golang.org/x/crypto/bcrypt\"\n\n\t\"github.com/hashicorp/vault/logical\"\n\t\"github.com/hashicorp/vault/logical/framework\"\n)\n\nfunc pathUserPassword(b *backend) *framework.Path {\n\treturn &framework.Path{\n\t\tPattern: \"users/\" + framework.GenericNameRegex(\"username\") + \"/password$\",\n\t\tFields: map[string]*framework.FieldSchema{\n\t\t\t\"username\": &framework.FieldSchema{\n\t\t\t\tType:        framework.TypeString,\n\t\t\t\tDescription: \"Username for this user.\",\n\t\t\t},\n\n\t\t\t\"password\": &framework.FieldSchema{\n\t\t\t\tType:        framework.TypeString,\n\t\t\t\tDescription: \"Password for this user.\",\n\t\t\t},\n\t\t},\n\n\t\tCallbacks: map[logical.Operation]framework.OperationFunc{\n\t\t\tlogical.UpdateOperation: b.pathUserPasswordUpdate,\n\t\t},\n\n\t\tHelpSynopsis:    pathUserPasswordHelpSyn,\n\t\tHelpDescription: pathUserPasswordHelpDesc,\n\t}\n}\n\n\n\nfunc (b *backend) updateUserPassword(req *logical.Request, d *framework.FieldData, userEntry *UserEntry) (error, error) {\n\tpassword := d.Get(\"password\").(string)\n\tif password == \"\" {\n\t\treturn fmt.Errorf(\"missing password\"), nil\n\t}\n\thash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserEntry.PasswordHash = hash\n\treturn nil, nil\n}\n\nconst pathUserPasswordHelpSyn = `\nReset user's password.\n`\n\nconst pathUserPasswordHelpDesc = `\nThis endpoint allows resetting the user's password.\n`\n\nfunc (b *backend) pathUserPasswordUpdate(ctx context.Context, req *logical.Request, d *framework.FieldData) (*logical.Response, error) ", "output": "{\n\tusername := d.Get(\"username\").(string)\n\n\tuserEntry, err := b.user(ctx, req.Storage, username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif userEntry == nil {\n\t\treturn nil, fmt.Errorf(\"username does not exist\")\n\t}\n\n\tuserErr, intErr := b.updateUserPassword(req, d, userEntry)\n\tif intErr != nil {\n\t\treturn nil, err\n\t}\n\tif userErr != nil {\n\t\treturn logical.ErrorResponse(userErr.Error()), logical.ErrInvalidRequest\n\t}\n\n\treturn nil, b.setUser(ctx, req.Storage, username, userEntry)\n}"}
{"input": "package validate\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar (\n\tlogMutex = &sync.Mutex{}\n)\n\n\n\nfunc TestDebug(t *testing.T) ", "output": "{\n\tif !enableLongTests {\n\t\tskipNotify(t)\n\t\tt.SkipNow()\n\t}\n\ttmpFile, _ := ioutil.TempFile(\"\", \"debug-test\")\n\ttmpName := tmpFile.Name()\n\tdefer func() {\n\t\tDebug = false\n\t\tlogMutex.Unlock()\n\t\tos.Remove(tmpName)\n\t}()\n\n\tlogMutex.Lock()\n\tDebug = true\n\tdebugOptions()\n\tdefer func() {\n\t\tvalidateLogger.SetOutput(os.Stdout)\n\t}()\n\n\tvalidateLogger.SetOutput(tmpFile)\n\n\tdebugLog(\"A debug\")\n\tDebug = false\n\ttmpFile.Close()\n\n\tflushed, _ := os.Open(tmpName)\n\tbuf := make([]byte, 500)\n\tflushed.Read(buf)\n\tvalidateLogger.SetOutput(os.Stdout)\n\tassert.Contains(t, string(buf), \"A debug\")\n}"}
{"input": "package engine\n\nimport (\n\t\"time\"\n\n\t\"github.com/aws/amazon-ecs-agent/agent/api\"\n)\n\n\n\ntype impossibleTransitionError struct {\n\tstate api.ContainerStatus\n}\n\nfunc (err *impossibleTransitionError) Error() string {\n\treturn \"Cannot transition to \" + err.state.String()\n}\nfunc (err *impossibleTransitionError) ErrorName() string { return \"ImpossibleStateTransitionError\" }\n\ntype DockerTimeoutError struct {\n\tduration   time.Duration\n\ttransition string\n}\n\nfunc (err *DockerTimeoutError) Error() string {\n\treturn \"Could not transition to \" + err.transition + \"; timed out after waiting \" + err.duration.String()\n}\nfunc (err *DockerTimeoutError) ErrorName() string { return \"DockerTimeoutError\" }\n\ntype ContainerVanishedError struct{}\n\n\nfunc (err ContainerVanishedError) ErrorName() string { return \"ContainerVanishedError\" }\n\ntype CannotXContainerError struct {\n\ttransition string\n\tmsg        string\n}\n\nfunc (err CannotXContainerError) Error() string { return err.msg }\nfunc (err CannotXContainerError) ErrorName() string {\n\treturn \"Cannot\" + err.transition + \"ContainerError\"\n}\n\ntype OutOfMemoryError struct{}\n\nfunc (err OutOfMemoryError) Error() string     { return \"Container killed due to memory usage\" }\nfunc (err OutOfMemoryError) ErrorName() string { return \"OutOfMemoryError\" }\n\n\ntype DockerStateError struct {\n\tdockerError string\n\tname        string\n}\n\nfunc NewDockerStateError(err string) DockerStateError {\n\treturn DockerStateError{\n\t\tdockerError: err,\n\t\tname:        \"DockerStateError\",\n\t}\n}\n\nfunc (err DockerStateError) Error() string {\n\treturn err.dockerError\n}\nfunc (err DockerStateError) ErrorName() string {\n\treturn err.name\n}\n\nfunc (err ContainerVanishedError) Error() string     ", "output": "{ return \"No container matching saved ID found\" }"}
{"input": "package bazel\n\n\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\tremoteexecution \"github.com/twitter/scoot/bazel/remoteexecution\"\n)\n\n\n\n\nfunc IsValidDigest(hash string, size int64) bool {\n\treturn len(hash) == 64 && size >= -1\n}\n\n\n\nfunc DigestStoreName(digest *remoteexecution.Digest) string {\n\tif digest != nil {\n\t\treturn fmt.Sprintf(\"%s-%s.%s\", StorePrefix, digest.GetHash(), StorePrefix)\n\t}\n\treturn \"\"\n}\n\n\n\n\n\nfunc DigestToStr(d *remoteexecution.Digest) string {\n\tif d == nil || d.GetHash() == \"\" {\n\t\treturn \"\"\n\t}\n\treturn fmt.Sprintf(\"%s/%d\", d.GetHash(), d.GetSizeBytes())\n}\n\nfunc EmptyDigest() *remoteexecution.Digest {\n\treturn &remoteexecution.Digest{\n\t\tHash:      EmptySha,\n\t\tSizeBytes: EmptySize,\n\t}\n}\n\nfunc IsEmptyDigest(d *remoteexecution.Digest) bool {\n\treturn d.GetHash() == EmptySha\n}\n\nfunc DigestsEqual(a, b *remoteexecution.Digest) bool {\n\treturn a.GetHash() == b.GetHash() && a.GetSizeBytes() == b.GetSizeBytes()\n}\n\nfunc DigestFromString(s string) (*remoteexecution.Digest, error) ", "output": "{\n\tparts := strings.Split(s, \"/\")\n\tif len(parts) != 2 {\n\t\treturn nil, fmt.Errorf(\"Invalid format, expected '<hash>/<size>'\")\n\t}\n\tsnap := fmt.Sprintf(\"%s-%s-%s\", SnapshotIDPrefix, parts[0], parts[1])\n\tif err := ValidateID(snap); err != nil {\n\t\treturn nil, err\n\t}\n\treturn DigestFromSnapshotID(snap)\n}"}
{"input": "package v2\n\nimport (\n\t\"code.cloudfoundry.org/cli/command\"\n\t\"code.cloudfoundry.org/cli/command/flag\"\n\t\"code.cloudfoundry.org/cli/command/translatableerror\"\n)\n\ntype UpdateServiceBrokerCommand struct {\n\tRequiredArgs    flag.ServiceBrokerArgs `positional-args:\"yes\"`\n\tusage           interface{}            `usage:\"CF_NAME update-service-broker SERVICE_BROKER USERNAME PASSWORD URL\"`\n\trelatedCommands interface{}            `related_commands:\"rename-service-broker, service-brokers\"`\n}\n\nfunc (UpdateServiceBrokerCommand) Setup(config command.Config, ui command.UI) error {\n\treturn nil\n}\n\n\n\nfunc (UpdateServiceBrokerCommand) Execute(args []string) error ", "output": "{\n\treturn translatableerror.UnrefactoredCommandError{}\n}"}
{"input": "package vm\n\ntype Base struct {\n}\n\nvar SupportedAPICalls = []string{\n\t\"/api.Instance/Start\",\n\t\"/api.Instance/Run\",\n\t\"/api.Instance/Stop\",\n\t\"/api.Instance/Reboot\",\n\t\"/api.Instance/Console\",\n\t\"/api.Instance/Log\",\n}\n\n\n\nfunc (*Base) IsSupportAPI(method string) bool ", "output": "{\n\tfor _, m := range SupportedAPICalls {\n\t\tif m == method {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"}
{"input": "package githubpotentials\n\nimport \"log\"\nimport \"github.com/artisresistance/githubpotentials/github\"\nimport \"time\"\nimport \"fmt\"\nimport \"io/ioutil\"\n\nconst searchItemsPerRequest = 100\nconst itemsPerRepo = 50\n\ntype clientMock struct {\n\tbegin        time.Time\n\tapiRemaining int\n\trepos        []github.Repository\n}\n\nfunc (m clientMock) repo(owner, name string) *github.Repository {\n\tfor _, repo := range m.repos {\n\t\tif repo.Owner == owner && repo.Name == name {\n\t\t\treturn &repo\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (m clientMock) SearchRepositories(query string, pages int, onFetch func([]github.Repository)) {\n\tfor i := 0; i < pages*searchItemsPerRequest; i += searchItemsPerRequest {\n\t\tm.apiRemaining--\n\t\tonFetch(m.repos[i : i+searchItemsPerRequest])\n\t}\n}\n\nfunc (m clientMock) ListCommits(owner, repo string, since time.Time, onFetch func([]github.Commit)) {\n\tcommits := make([]github.Commit, itemsPerRepo)\n\tfor i := 0; i < itemsPerRepo; i++ {\n\t\tcommits[i].CommitterID = i % 15\n\t}\n\tm.apiRemaining--\n\tonFetch(commits)\n}\n\nfunc (m clientMock) ListStargazers(owner, repo string, since time.Time, onFetch func([]github.Stargazer)) {\n\tsgs := make([]github.Stargazer, itemsPerRepo)\n\tfor i := 0; i < itemsPerRepo; i++ {\n\t\tsgs[i].StarredAt = time.Now()\n\t}\n\tm.apiRemaining--\n\tonFetch(sgs)\n}\n\nfunc (m clientMock) APIRates() (remaining int, reset time.Time, err error) {\n\treturn m.apiRemaining, m.begin.Add(time.Hour), nil\n}\n\n\n\nfunc newTestInstance() Potentials ", "output": "{\n\tmock := clientMock{apiRemaining: 5000}\n\tmock.repos = make([]github.Repository, 1000)\n\tfor i, repo := range mock.repos {\n\t\trepo.Name = fmt.Sprintf(\"%d\", i)\n\t\trepo.Owner = fmt.Sprintf(\"%d\", i%100)\n\t\trepo.Description = fmt.Sprintf(\"desc for %s/%s\", repo.Owner, repo.Name)\n\t\trepo.Homepage = fmt.Sprintf(\"homepage for %s/%s\", repo.Owner, repo.Name)\n\t\trepo.License = \"MIT\"\n\t}\n\treturn instance{\n\t\tlog:         log.New(ioutil.Discard, \"\", 0),\n\t\tclient:      mock,\n\t\tlastUpdated: time.Now(),\n\t}\n}"}
{"input": "package field\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strconv\"\n)\n\n\ntype Path struct {\n\tname   string \n\tindex  string \n\tparent *Path  \n}\n\n\nfunc NewPath(name string, moreNames ...string) *Path {\n\tr := &Path{name: name, parent: nil}\n\tfor _, anotherName := range moreNames {\n\t\tr = &Path{name: anotherName, parent: r}\n\t}\n\treturn r\n}\n\n\nfunc (p *Path) Root() *Path {\n\tfor ; p.parent != nil; p = p.parent {\n\t}\n\treturn p\n}\n\n\nfunc (p *Path) Child(name string, moreNames ...string) *Path {\n\tr := NewPath(name, moreNames...)\n\tr.Root().parent = p\n\treturn r\n}\n\n\n\nfunc (p *Path) Index(index int) *Path {\n\treturn &Path{index: strconv.Itoa(index), parent: p}\n}\n\n\n\nfunc (p *Path) Key(key string) *Path {\n\treturn &Path{index: key, parent: p}\n}\n\n\n\n\nfunc (p *Path) String() string ", "output": "{\n\tif p == nil {\n\t\treturn \"<nil>\"\n\t}\n\telems := []*Path{}\n\tfor ; p != nil; p = p.parent {\n\t\telems = append(elems, p)\n\t}\n\n\tbuf := bytes.NewBuffer(nil)\n\tfor i := range elems {\n\t\tp := elems[len(elems)-1-i]\n\t\tif p.parent != nil && len(p.name) > 0 {\n\t\t\tbuf.WriteString(\".\")\n\t\t}\n\t\tif len(p.name) > 0 {\n\t\t\tbuf.WriteString(p.name)\n\t\t} else {\n\t\t\tfmt.Fprintf(buf, \"[%s]\", p.index)\n\t\t}\n\t}\n\treturn buf.String()\n}"}
{"input": "package utils\n\nimport (\n\t\"os\"\n\t\"os/user\"\n\t\"path/filepath\"\n)\n\n\n\n\n\nfunc ConfigDir() string {\n\tconfigDir := os.Getenv(\"XDG_CONFIG_HOME\")\n\tif configDir != \"\" {\n\t\treturn configDir\n\t}\n\n\treturn filepath.Join(HomeDir(), \".config\")\n}\n\nfunc HomeDir() string ", "output": "{\n\thomeDir := os.Getenv(\"HOME\")\n\tif homeDir != \"\" {\n\t\treturn homeDir\n\t}\n\n\tcurrentUser, err := user.Current()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn currentUser.HomeDir\n}"}
{"input": "package relay\n\nimport (\n\t\"encoding/gob\"\n\t\"encoding/json\"\n\t\"io\"\n)\n\n\n\n\ntype Serializer interface {\n\tContentType() string\n\tRelayEncode(io.Writer, interface{}) error\n\tRelayDecode(io.Reader, interface{}) error\n}\n\n\ntype GOBSerializer struct{}\n\nfunc (*GOBSerializer) ContentType() string {\n\treturn \"binary/gob\"\n}\nfunc (*GOBSerializer) RelayEncode(w io.Writer, e interface{}) error {\n\tenc := gob.NewEncoder(w)\n\treturn enc.Encode(e)\n}\nfunc (*GOBSerializer) RelayDecode(r io.Reader, o interface{}) error {\n\tdec := gob.NewDecoder(r)\n\treturn dec.Decode(o)\n}\n\n\ntype JSONSerializer struct{}\n\n\n\nfunc (*JSONSerializer) RelayEncode(w io.Writer, e interface{}) error {\n\tenc := json.NewEncoder(w)\n\treturn enc.Encode(e)\n}\n\nfunc (*JSONSerializer) RelayDecode(r io.Reader, o interface{}) error {\n\tdec := json.NewDecoder(r)\n\treturn dec.Decode(o)\n}\n\nfunc (*JSONSerializer) ContentType() string ", "output": "{\n\treturn \"text/json\"\n}"}
{"input": "package test\n\nimport (\n\tcorev1 \"k8s.io/api/core/v1\"\n)\n\n\n\nfunc tweak(in *corev1.Pod, f func(copy *corev1.Pod)) *corev1.Pod {\n\tout := in.DeepCopy()\n\tf(out)\n\treturn out\n}\n\n\nfunc ensureSecurityContext(p *corev1.Pod) *corev1.Pod {\n\tp = p.DeepCopy()\n\tif p.Spec.SecurityContext == nil {\n\t\tp.Spec.SecurityContext = &corev1.PodSecurityContext{}\n\t}\n\tfor i := range p.Spec.Containers {\n\t\tif p.Spec.Containers[i].SecurityContext == nil {\n\t\t\tp.Spec.Containers[i].SecurityContext = &corev1.SecurityContext{}\n\t\t}\n\t}\n\tfor i := range p.Spec.InitContainers {\n\t\tif p.Spec.InitContainers[i].SecurityContext == nil {\n\t\t\tp.Spec.InitContainers[i].SecurityContext = &corev1.SecurityContext{}\n\t\t}\n\t}\n\treturn p\n}\n\n\nfunc ensureSELinuxOptions(p *corev1.Pod) *corev1.Pod {\n\tp = ensureSecurityContext(p)\n\tif p.Spec.SecurityContext.SELinuxOptions == nil {\n\t\tp.Spec.SecurityContext.SELinuxOptions = &corev1.SELinuxOptions{}\n\t}\n\tfor i := range p.Spec.Containers {\n\t\tif p.Spec.Containers[i].SecurityContext.SELinuxOptions == nil {\n\t\t\tp.Spec.Containers[i].SecurityContext.SELinuxOptions = &corev1.SELinuxOptions{}\n\t\t}\n\t}\n\tfor i := range p.Spec.InitContainers {\n\t\tif p.Spec.InitContainers[i].SecurityContext.SELinuxOptions == nil {\n\t\t\tp.Spec.InitContainers[i].SecurityContext.SELinuxOptions = &corev1.SELinuxOptions{}\n\t\t}\n\t}\n\treturn p\n}\n\n\n\n\nfunc ensureAnnotation(pod *corev1.Pod) *corev1.Pod ", "output": "{\n\tif pod.Annotations == nil {\n\t\tpod.Annotations = map[string]string{}\n\t}\n\treturn pod\n}"}
{"input": "package system\n\nimport (\n\t\"os/exec\"\n\t\"strings\"\n)\n\n\nvar DefaultSysSpec = SysSpec{\n\tOS: \"Microsoft Windows Server 2016\",\n\tKernelSpec: KernelSpec{\n\t\tVersions:  []string{`10\\.0\\.1439[3-9]`, `10\\.0\\.14[4-9][0-9]{2}`, `10\\.0\\.1[5-9][0-9]{3}`, `10\\.0\\.[2-9][0-9]{4}`, `10\\.[1-9]+\\.[0-9]+`}, \n\t\tRequired:  []KernelConfig{},\n\t\tOptional:  []KernelConfig{},\n\t\tForbidden: []KernelConfig{},\n\t},\n\tRuntimeSpec: RuntimeSpec{\n\t\tDockerSpec: &DockerSpec{\n\t\t\tVersion:     []string{`18\\.0[6,9]\\..*`, `19\\.03\\..*`},\n\t\t\tGraphDriver: []string{\"windowsfilter\"},\n\t\t},\n\t},\n}\n\n\ntype KernelValidatorHelperImpl struct{}\n\nvar _ KernelValidatorHelper = &KernelValidatorHelperImpl{}\n\n\n\n\nfunc (o *KernelValidatorHelperImpl) GetKernelReleaseVersion() (string, error) ", "output": "{\n\targs := []string{\"(Get-CimInstance Win32_OperatingSystem).Version\"}\n\treleaseVersion, err := exec.Command(\"powershell\", args...).Output()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn strings.TrimSpace(string(releaseVersion)), nil\n}"}
{"input": "package errors2\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\nconst (\n\tlvldbug = iota\n\tlvlinfo\n\tlvlerr\n\tlvlcrit\n)\n\ntype logMessage struct {\n\ttime    time.Time\n\tlevel   int\n\tmessage string\n}\n\ntype Logger struct {\n\tmessages []*logMessage\n\tTimer    Timer\n}\n\nfunc (l *Logger) Debug(message string) {\n\tl.log(&logMessage{time: time.Now(), level: lvldbug, message: message})\n}\n\n\n\nfunc (l *Logger) Error(message string) {\n\tl.log(&logMessage{time: time.Now(), level: lvlerr, message: message})\n}\n\nfunc (l *Logger) Critical(message string) {\n\tl.log(&logMessage{time: time.Now(), level: lvlcrit, message: message})\n}\n\nvar lock = &sync.Mutex{}\n\nfunc (l *Logger) log(message *logMessage) {\n\tlock.Lock()\n\tl.messages = append(l.messages, message)\n\tlock.Unlock()\n}\n\nfunc (l *Logger) Info(message string) ", "output": "{\n\tl.log(&logMessage{time: time.Now(), level: lvlinfo, message: message})\n}"}
{"input": "package main\n\n\n\n\nimport (\n\t\"vitess.io/vitess/go/stats/prometheusbackend\"\n\t\"vitess.io/vitess/go/vt/servenv\"\n)\n\n\n\nfunc init() ", "output": "{\n\tservenv.OnRun(func() {\n\t\tprometheusbackend.Init(\"vttablet\")\n\t})\n}"}
{"input": "package random\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/google/uuid\"\n)\n\nconst (\n\tmaxNameLength = 63\n)\n\ntype Interface interface {\n\tName() (string, error)\n}\n\ntype impl struct {\n\tsslCertificateNamePrefix string\n}\n\n\n\n\nfunc (r impl) Name() (string, error) {\n\tif uid, err := uuid.NewRandom(); err != nil {\n\t\treturn \"\", err\n\t} else {\n\t\tgeneratedName := fmt.Sprintf(\"%s%s\", r.sslCertificateNamePrefix, uid.String())\n\t\tmaxLength := maxNameLength\n\t\tif len(generatedName) < maxLength {\n\t\t\tmaxLength = len(generatedName)\n\t\t}\n\n\t\treturn generatedName[:maxLength], nil\n\t}\n}\n\nfunc New(sslCertificateNamePrefix string) Interface ", "output": "{\n\treturn impl{sslCertificateNamePrefix: sslCertificateNamePrefix}\n}"}
{"input": "package test\n\nimport (\n\t\"sync\"\n\n\tkapi \"github.com/GoogleCloudPlatform/kubernetes/pkg/api\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/labels\"\n\t\"github.com/GoogleCloudPlatform/kubernetes/pkg/watch\"\n\t\"github.com/openshift/origin/pkg/deploy/api\"\n)\n\ntype DeploymentConfigRegistry struct {\n\tErr               error\n\tDeploymentConfig  *api.DeploymentConfig\n\tDeploymentConfigs *api.DeploymentConfigList\n\tsync.Mutex\n}\n\nfunc NewDeploymentConfigRegistry() *DeploymentConfigRegistry {\n\treturn &DeploymentConfigRegistry{}\n}\n\nfunc (r *DeploymentConfigRegistry) ListDeploymentConfigs(ctx kapi.Context, label, field labels.Selector) (*api.DeploymentConfigList, error) {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\treturn r.DeploymentConfigs, r.Err\n}\n\nfunc (r *DeploymentConfigRegistry) GetDeploymentConfig(ctx kapi.Context, id string) (*api.DeploymentConfig, error) {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\treturn r.DeploymentConfig, r.Err\n}\n\nfunc (r *DeploymentConfigRegistry) CreateDeploymentConfig(ctx kapi.Context, image *api.DeploymentConfig) error {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\tr.DeploymentConfig = image\n\treturn r.Err\n}\n\nfunc (r *DeploymentConfigRegistry) UpdateDeploymentConfig(ctx kapi.Context, image *api.DeploymentConfig) error {\n\tr.Lock()\n\tdefer r.Unlock()\n\n\tr.DeploymentConfig = image\n\treturn r.Err\n}\n\n\n\nfunc (r *DeploymentConfigRegistry) WatchDeploymentConfigs(ctx kapi.Context, label, field labels.Selector, resourceVersion string) (watch.Interface, error) {\n\treturn nil, r.Err\n}\n\nfunc (r *DeploymentConfigRegistry) DeleteDeploymentConfig(ctx kapi.Context, id string) error ", "output": "{\n\tr.Lock()\n\tdefer r.Unlock()\n\n\treturn r.Err\n}"}
{"input": "package crm\n\nimport (\n\t. \"aliyun-openapi-go-sdk/core\"\n)\n\ntype QueryCustomerLabelRequest struct {\n\tRpcRequest\n\tLabelSeries string\n}\n\nfunc (r *QueryCustomerLabelRequest) SetLabelSeries(value string) {\n\tr.LabelSeries = value\n\tr.QueryParams.Set(\"LabelSeries\", value)\n}\nfunc (r *QueryCustomerLabelRequest) GetLabelSeries() string {\n\treturn r.LabelSeries\n}\n\n\n\ntype QueryCustomerLabelResponse struct {\n\tSuccess bool   `xml:\"Success\" json:\"Success\"`\n\tCode    string `xml:\"Code\" json:\"Code\"`\n\tMessage string `xml:\"Message\" json:\"Message\"`\n\tData    struct {\n\t\tCustomerLabel []struct {\n\t\t\tLabel       string `xml:\"Label\" json:\"Label\"`\n\t\t\tLabelSeries string `xml:\"LabelSeries\" json:\"LabelSeries\"`\n\t\t} `xml:\"CustomerLabel\" json:\"CustomerLabel\"`\n\t} `xml:\"Data\" json:\"Data\"`\n}\n\nfunc QueryCustomerLabel(req *QueryCustomerLabelRequest, accessId, accessSecret string) (*QueryCustomerLabelResponse, error) {\n\tvar pResponse QueryCustomerLabelResponse\n\tbody, err := ApiHttpRequest(accessId, accessSecret, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tApiUnmarshalResponse(req.GetFormat(), body, &pResponse)\n\treturn &pResponse, err\n}\n\nfunc (r *QueryCustomerLabelRequest) Init() ", "output": "{\n\tr.RpcRequest.Init()\n\tr.SetVersion(Version)\n\tr.SetAction(\"QueryCustomerLabel\")\n\tr.SetProduct(Product)\n}"}
{"input": "package app\n\nimport \"fmt\"\n\ntype AppError struct {\n\tErrorCode string `json:\"error_code\" bson:\"-\"`\n\tMessage   string `json:\"message\" bson:\"message\"`\n}\n\nfunc (e AppError) Error() string {\n\treturn fmt.Sprintf(\"%s - %s\", e.ErrorCode, e.Message)\n}\n\ntype Pagination struct {\n\tPage       int `json:\"page\"`\n\tPerPage    int `json:\"per_page\"`\n\tTotalCount int `json:\"total_count\"`\n\tTotalPage  int `json:\"total_page\"`\n}\n\nfunc (p *Pagination) SetTotalCount(total int) {\n\tp.TotalCount = total\n\tp.TotalPage = p.TotalCount / p.PerPage\n\tif p.TotalCount > 0 && p.TotalPage == 0 {\n\t\tp.TotalPage = 1\n\t} else {\n\t\tmod := p.TotalCount % p.PerPage\n\t\tif mod > 0 {\n\t\t\tp.TotalPage++\n\t\t}\n\t}\n}\n\n\n\ntype ApiPagiationResult struct {\n\tPagination Pagination  `json:\"meta\"`\n\tData       interface{} `json:\"data\"`\n}\n\ntype ApiCollectionResult struct {\n\tTotalCount int         `json:\"total_count\"`\n\tResult     interface{} `json:\"result\"`\n}\n\nfunc (p *Pagination) Skip() int ", "output": "{\n\treturn (p.Page - 1) * p.PerPage\n}"}
{"input": "package test\n\nimport (\n\tauthTest \"github.com/tidepool-org/platform/auth/test\"\n)\n\ntype RestrictedTokenRepository struct {\n\t*authTest.RestrictedTokenAccessor\n}\n\nfunc NewRestrictedTokenRepository() *RestrictedTokenRepository {\n\treturn &RestrictedTokenRepository{\n\t\tRestrictedTokenAccessor: authTest.NewRestrictedTokenAccessor(),\n\t}\n}\n\n\n\nfunc (r *RestrictedTokenRepository) Expectations() ", "output": "{\n\tr.RestrictedTokenAccessor.Expectations()\n}"}
{"input": "package collector\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/cadvisor/info/v1\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype fakeCollector struct {\n\tnextCollectionTime time.Time\n\terr                error\n\tcollectedFrom      int\n}\n\nfunc (fc *fakeCollector) Collect(metric map[string]v1.MetricVal) (time.Time, map[string]v1.MetricVal, error) {\n\tfc.collectedFrom++\n\treturn fc.nextCollectionTime, metric, fc.err\n}\n\n\n\nfunc (fc *fakeCollector) GetSpec() []v1.MetricSpec {\n\treturn []v1.MetricSpec{}\n}\n\nfunc TestCollect(t *testing.T) {\n\tcm := &GenericCollectorManager{}\n\n\tfirstTime := time.Now().Add(-time.Hour)\n\tsecondTime := time.Now().Add(time.Hour)\n\tf1 := &fakeCollector{\n\t\tnextCollectionTime: firstTime,\n\t}\n\tf2 := &fakeCollector{\n\t\tnextCollectionTime: secondTime,\n\t}\n\n\tassert := assert.New(t)\n\tassert.NoError(cm.RegisterCollector(f1))\n\tassert.NoError(cm.RegisterCollector(f2))\n\n\tnextTime, _, err := cm.Collect()\n\tassert.Equal(firstTime, nextTime)\n\tassert.NoError(err)\n\tassert.Equal(1, f1.collectedFrom)\n\tassert.Equal(1, f2.collectedFrom)\n\n\tf1.nextCollectionTime = time.Now().Add(2 * time.Hour)\n\n\tnextTime, _, err = cm.Collect()\n\tassert.Equal(secondTime, nextTime)\n\tassert.NoError(err)\n\tassert.Equal(2, f1.collectedFrom)\n\tassert.Equal(1, f2.collectedFrom)\n}\n\nfunc (fc *fakeCollector) Name() string ", "output": "{\n\treturn \"fake-collector\"\n}"}
{"input": "package core\n\nimport (\n\t\"fmt\"\n)\n\n\n\n\n\n\nfunc PodContainerKey(namespace, podName, containerName string) string {\n\treturn fmt.Sprintf(\"namespace:%s/pod:%s/container:%s\", namespace, podName, containerName)\n}\n\nfunc PodKey(namespace, podName string) string {\n\treturn fmt.Sprintf(\"namespace:%s/pod:%s\", namespace, podName)\n}\n\n\n\nfunc NodeKey(node string) string {\n\treturn fmt.Sprintf(\"node:%s\", node)\n}\n\nfunc NodeContainerKey(node, container string) string {\n\treturn fmt.Sprintf(\"node:%s/container:%s\", node, container)\n}\n\nfunc ClusterKey() string {\n\treturn \"cluster\"\n}\n\nfunc NamespaceKey(namespace string) string ", "output": "{\n\treturn fmt.Sprintf(\"namespace:%s\", namespace)\n}"}
{"input": "package safepackets\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\n\t\"github.com/mark-rushakoff/go_tftpd/packets\"\n)\n\ntype SafeError struct {\n\tCode    packets.ErrorCode\n\tMessage string\n}\n\nfunc NewFileNotFoundError() *SafeError {\n\treturn &SafeError{\n\t\tCode:    packets.FileNotFound,\n\t\tMessage: \"File not found\",\n\t}\n}\n\nfunc NewAccessViolationError(message string) *SafeError {\n\treturn &SafeError{\n\t\tCode:    packets.AccessViolation,\n\t\tMessage: message,\n\t}\n}\n\n\n\nfunc (e *SafeError) Equals(other *SafeError) bool {\n\treturn e.Code == other.Code && e.Message == other.Message\n}\n\nfunc (e *SafeError) Bytes() []byte {\n\tbuf := &bytes.Buffer{}\n\tbinary.Write(buf, binary.BigEndian, packets.ErrorOpcode)\n\tbinary.Write(buf, binary.BigEndian, e.Code)\n\tbuf.WriteString(e.Message)\n\tbuf.WriteByte(0)\n\treturn buf.Bytes()\n}\n\nfunc NewAncientAckError() *SafeError ", "output": "{\n\treturn &SafeError{\n\t\tCode:    packets.Undefined,\n\t\tMessage: \"Received unexpectedly old Ack\",\n\t}\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"sort\"\n\t\"strings\"\n)\n\ntype helloTransport interface {\n\tConnect(addr string) error\n\tClose() error\n\tRequest(req string) (reply string, err error)\n}\n\ntype transGenerator func() (helloTransport, error)\n\nvar transporter map[string]transGenerator = make(map[string]transGenerator)\n\n\n\nfunc transportList() []string {\n\tvar transports = make([]string, 0, len(transporter))\n\tfor id := range transporter {\n\t\ttransports = append(transports, id)\n\t}\n\tsort.StringSlice(transports).Sort()\n\treturn transports\n}\n\nfunc availableTransports() string {\n\tvar transports = transportList()\n\treturn strings.Join(transports, \",\")\n}\n\nfunc firstTransport() string {\n\tvar transports = transportList()\n\treturn transports[0]\n}\n\nfunc defaultAddr(addr string) string {\n\treturn fmt.Sprintf(\"%s://%s\", firstTransport(), addr)\n}\n\nfunc newTransport(addr string) (helloTransport, error) {\n\tvar uri, err = url.Parse(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif generate, ok := transporter[uri.Scheme]; ok {\n\t\treturn generate()\n\t}\n\treturn nil, fmt.Errorf(\"invalid transport %q\", uri.Scheme)\n}\n\nfunc registerTransport(id string, gen transGenerator) ", "output": "{\n\ttransporter[id] = gen\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/trivago/tgo/tlog\"\n)\n\n\n\ntype Modulator interface {\n\tModulate(msg *Message) ModulateResult\n}\n\n\n\ntype ModulatorArray []Modulator\n\n\n\n\ntype ScopedModulator interface {\n\tModulator\n\n\tSetLogScope(log tlog.LogScope)\n}\n\n\n\ntype ModulateResult int\n\nconst (\n\tModulateResultContinue = ModulateResult(iota)\n\tModulateResultFallback = ModulateResult(iota)\n\tModulateResultDiscard = ModulateResult(iota)\n)\n\n\n\n\n\nfunc (modulators ModulatorArray) Modulate(msg *Message) ModulateResult ", "output": "{\n\taction := ModulateResultContinue\n\tfor _, modulator := range modulators {\n\t\tswitch modRes := modulator.Modulate(msg); modRes {\n\t\tcase ModulateResultDiscard, ModulateResultFallback:\n\t\t\treturn modRes \n\t\t}\n\t}\n\treturn action\n}"}
{"input": "package cmd\n\n\nimport (\n\t\"fmt\"\n\t\"github.com/madhusudhancs/redis/cache\"\n\t\"strings\"\n)\n\nvar (\n\tcommands map[string]RunFunc\n)\n\nfunc init() {\n\tcommands = make(map[string]RunFunc)\n}\n\n\ntype Command struct {\n\tName    string\n\tOptions []string\n}\n\n\nfunc NewCommand(req string) (Command, error) {\n\tfields := strings.Fields(req)\n\n\tif len(fields) == 0 {\n\t\treturn Command{}, fmt.Errorf(\"Invalid command\")\n\t}\n\n\tcommand := Command{}\n\tcommand.Name = strings.ToUpper(fields[0])\n\tcommand.Options = fields[1:]\n\n\tfor i, option := range command.Options {\n\t\tcommand.Options[i] = strings.Replace(option, `\"`, \"\", -1)\n\t}\n\n\treturn command, nil\n}\n\ntype RunFunc func(options []string, cache *cache.Cache) ([]byte, bool)\n\n\n\n\n\nfunc ExecuteCmd(cmd Command, cache *cache.Cache) ([]byte, bool) {\n\trunFunc, ok := commands[cmd.Name]\n\tif !ok {\n\t\treturn GetErrMsg(fmt.Sprintf(\"ERR unknown command '%s'\", cmd.Name)), false\n\t}\n\n\treturn runFunc(cmd.Options, cache)\n}\n\nfunc Register(cmdName string, runFunc RunFunc) error ", "output": "{\n\tif _, ok := commands[cmdName]; ok {\n\t\treturn fmt.Errorf(\"command with name %s already registered\", cmdName)\n\t}\n\n\tcommands[cmdName] = runFunc\n\treturn nil\n}"}
{"input": "package day22\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n\n\nfunc TestScoreHand(t *testing.T) {\n\thand := []uint64{3, 2, 10, 6, 8, 5, 9, 4, 7, 1}\n\n\tscore := scoreHand(hand)\n\n\tassert.Equal(t, uint64(306), score)\n}\n\nfunc TestPlayRecursiveCombat(t *testing.T) {\n\tstartingHands := [][]uint64{\n\t\t{9, 2, 6, 3, 1},\n\t\t{5, 8, 4, 7, 10},\n\t}\n\n\tseenGames := map[string]int{}\n\tresultingHands, err := playRecursiveCombat(startingHands, seenGames)\n\n\texpectedResultingHands := [][]uint64{\n\t\t{},\n\t\t{7, 5, 6, 2, 4, 1, 10, 8, 9, 3},\n\t}\n\tassert.NoError(t, err)\n\tassert.Equal(t, expectedResultingHands, resultingHands)\n}\n\nfunc TestPlayCombat(t *testing.T) ", "output": "{\n\tstartingHands := [][]uint64{\n\t\t{9, 2, 6, 3, 1},\n\t\t{5, 8, 4, 7, 10},\n\t}\n\n\tresultingHands, err := playCombat(startingHands)\n\tassert.NoError(t, err)\n\n\texpectedResultingHands := [][]uint64{\n\t\t{},\n\t\t{3, 2, 10, 6, 8, 5, 9, 4, 7, 1},\n\t}\n\tassert.Equal(t, expectedResultingHands, resultingHands)\n}"}
{"input": "package tdigest\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n\nconst ErrWeightLessThanZero = Error(\"centroid weight cannot be less than zero\")\n\n\ntype Error string\n\nfunc (e Error) Error() string {\n\treturn string(e)\n}\n\n\ntype Centroid struct {\n\tMean   float64\n\tWeight float64\n}\n\n\n\n\nfunc (c *Centroid) Add(r Centroid) error {\n\tif r.Weight < 0 {\n\t\treturn ErrWeightLessThanZero\n\t}\n\tif c.Weight != 0 {\n\t\tc.Weight += r.Weight\n\t\tc.Mean += r.Weight * (r.Mean - c.Mean) / c.Weight\n\t} else {\n\t\tc.Weight = r.Weight\n\t\tc.Mean = r.Mean\n\t}\n\treturn nil\n}\n\n\ntype CentroidList []Centroid\n\n\nfunc (l *CentroidList) Clear() {\n\t*l = (*l)[:0]\n}\n\nfunc (l CentroidList) Len() int           { return len(l) }\nfunc (l CentroidList) Less(i, j int) bool { return l[i].Mean < l[j].Mean }\nfunc (l CentroidList) Swap(i, j int)      { l[i], l[j] = l[j], l[i] }\n\n\nfunc NewCentroidList(centroids []Centroid) CentroidList {\n\tl := CentroidList(centroids)\n\tsort.Sort(l)\n\treturn l\n}\n\nfunc (c *Centroid) String() string ", "output": "{\n\treturn fmt.Sprintf(\"{mean: %f weight: %f}\", c.Mean, c.Weight)\n}"}
{"input": "package mqtt\n\nimport (\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"io\"\n)\n\ntype ConnackMessage struct {\n\tFixedHeader\n\tReserved   uint8\n\tReturnCode uint8\n}\n\nfunc (self *ConnackMessage) decode(reader io.Reader) error {\n\tbinary.Read(reader, binary.BigEndian, &self.Reserved)\n\tbinary.Read(reader, binary.BigEndian, &self.ReturnCode)\n\n\treturn nil\n}\n\nfunc (self ConnackMessage) WriteTo(w io.Writer) (int64, error) {\n\tvar fsize = 2\n\tsize, err := self.FixedHeader.writeTo(fsize, w)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tbinary.Write(w, binary.BigEndian, self.Reserved)\n\tbinary.Write(w, binary.BigEndian, self.ReturnCode)\n\n\treturn int64(fsize) + size, nil\n}\n\n\n\nfunc (self *ConnackMessage) String() string ", "output": "{\n\tb, _ := json.Marshal(self)\n\treturn string(b)\n}"}
{"input": "package pty\n\nimport \"os\"\n\n\n\n\n\n\n\n\nfunc Getsize(t *os.File) (rows, cols int, err error) {\n\tws, err := GetsizeFull(t)\n\treturn int(ws.Rows), int(ws.Cols), err\n}\n\nfunc InheritSize(pty, tty *os.File) error ", "output": "{\n\tsize, err := GetsizeFull(pty)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := Setsize(tty, size); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"}
{"input": "package frames\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n\n\nfunc TestGridBasicOutput(t *testing.T) ", "output": "{\n\tx := NewFrame(\"GRID\", \"\", Version3).(*GRID)\n\tif x.GetName() != \"GRID\" {\n\t\tt.Error(\"Invalid name from GRID frame\")\n\t}\n\n\tx.Name = \"BOB\"\n\tif x.GetName() != \"BOB\" {\n\t\tt.Error(\"Invalid GRID Name setting\")\n\t}\n\n\tb := []byte(\"Bob\\x00\\x13\\x06\\x06\\x06\")\n\tx.ProcessData(len(b), b)\n\n\texpected := fmt.Sprintf(\"Group Reg Identifier\\n\\tOwner: Bob\\n\\tSymbol: %b\\n\", '\\x13')\n\tfound := x.DisplayContent()\n\tif found != expected {\n\t\tt.Errorf(\"Got [%s], Expected [%s]\", found, expected)\n\t}\n}"}
{"input": "package g3\n\nimport (\n\t\"math\"\n)\n\nconst (\n\tPi      = float32(math.Pi)\n\tMathMax = math.MaxFloat32\n)\n\nfunc Cos(x float32) float32 {\n\treturn float32(math.Cos(float64(x)))\n}\n\n\n\nfunc Sqrt(x float32) float32 {\n\treturn float32(math.Sqrt(float64(x)))\n}\n\nfunc Tan(x float32) float32 {\n\treturn float32(math.Tan(float64(x)))\n}\n\nfunc Deg2Rad(d float32) float32 {\n\treturn d * math.Pi / 180.0\n}\n\nfunc Max(a, b float32) float32 {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc Min(a, b float32) float32 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc MinMax(a, b float32) (min, max float32) {\n\tif a < b {\n\t\treturn a, b\n\t}\n\treturn b, a\n}\n\nfunc Clamp(a, min, max float32) float32 {\n\tif a < min {\n\t\treturn min\n\t}\n\tif a > max {\n\t\treturn max\n\t}\n\treturn a\n}\n\nfunc Sin(x float32) float32 ", "output": "{\n\treturn float32(math.Sin(float64(x)))\n}"}
{"input": "package steward\n\nimport (\n\t\"database/sql\"\n\n\t_ \"github.com/lib/pq\"\n)\n\nfunc createSchema(db *sql.DB) error {\n\n\terr := createFlagTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createAdvisoryTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createCapturedFlagTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createTeamTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createServiceTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createStatusTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createRoundTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = createRoundResultTable(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc OpenDatabase(path string) (db *sql.DB, err error) {\n\n\tdb, err = sql.Open(\"postgres\", path)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = createSchema(db)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\n\n\n\nfunc CleanDatabase(db *sql.DB) (err error) ", "output": "{\n\n\ttables := []string{\"team\", \"advisory\", \"captured_flag\", \"flag\",\n\t\t\"service\", \"status\", \"round\", \"round_result\"}\n\n\tfor _, table := range tables {\n\n\t\t_, err = db.Exec(\"DELETE FROM \" + table)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t_, err = db.Exec(\"ALTER SEQUENCE \" + table + \"_id_seq RESTART WITH 1;\")\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}"}
{"input": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/codegangsta/cli\"\n\t\"github.com/mailgun/log\"\n\t\"github.com/mailgun/pong/config\"\n\t\"github.com/mailgun/pong/model\"\n\t\"os\"\n\t\"os/signal\"\n)\n\nfunc main() {\n\tapp := cli.NewApp()\n\tapp.Name = \"pong\"\n\tapp.Usage = \"Command line tool that generates endpoints with different behavior for testing purposes\"\n\tapp.Flags = []cli.Flag{\n\t\tcli.StringFlag{Name: \"c, config\", Usage: \"Yaml file with endpoint specifications\"},\n\t}\n\tapp.Action = startService\n\tapp.Run(os.Args)\n}\n\n\n\nfunc startService(c *cli.Context) ", "output": "{\n\tservers, logConfig, err := config.ParseConfig(c.String(\"config\"))\n\tif err != nil {\n\t\tfmt.Println(\"Failed to load config file '%s' err:\", c.String(\"config\"), err)\n\t\treturn\n\t}\n\tlog.Init(logConfig)\n\tfor _, s := range servers {\n\t\tgo model.StartServer(s)\n\t}\n\tinChan := make(chan os.Signal, 1)\n\tsignal.Notify(inChan, os.Interrupt, os.Kill)\n\tlog.Infof(\"Got signal %s, exiting now\", <-inChan)\n}"}
{"input": "package v1\n\nimport (\n\tcommon \"github.com/kubeflow/common/pkg/apis/common/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n)\n\n\n\n\n\nfunc addDefaultingFuncs(scheme *runtime.Scheme) error {\n\treturn RegisterDefaults(scheme)\n}\n\n\nfunc setDefaultsTypeLauncher(spec *common.ReplicaSpec) {\n\tif spec != nil && spec.RestartPolicy == \"\" {\n\t\tspec.RestartPolicy = DefaultRestartPolicy\n\t}\n}\n\n\nfunc setDefaultsTypeWorker(spec *common.ReplicaSpec) {\n\tif spec != nil && spec.RestartPolicy == \"\" {\n\t\tspec.RestartPolicy = DefaultRestartPolicy\n\t}\n}\n\nfunc SetDefaults_MPIJob(mpiJob *MPIJob) {\n\tif mpiJob.Spec.CleanPodPolicy == nil {\n\t\tnone := common.CleanPodPolicyNone\n\t\tmpiJob.Spec.CleanPodPolicy = &none\n\t}\n\n\tsetDefaultsTypeLauncher(mpiJob.Spec.MPIReplicaSpecs[MPIReplicaTypeLauncher])\n\n\tsetDefaultsTypeWorker(mpiJob.Spec.MPIReplicaSpecs[MPIReplicaTypeWorker])\n}\n\nfunc Int32(v int32) *int32 ", "output": "{\n\treturn &v\n}"}
{"input": "package lnwire\n\nimport (\n\t\"crypto/sha256\"\n\t\"io\"\n)\n\n\n\n\n\ntype UpdateFailMalformedHTLC struct {\n\tChanID ChannelID\n\n\tID uint64\n\n\tShaOnionBlob [sha256.Size]byte\n\n\tFailureCode FailCode\n}\n\n\n\nvar _ Message = (*UpdateFailMalformedHTLC)(nil)\n\n\n\n\n\n\n\n\n\n\n\nfunc (c *UpdateFailMalformedHTLC) Encode(w io.Writer, pver uint32) error {\n\treturn WriteElements(w,\n\t\tc.ChanID,\n\t\tc.ID,\n\t\tc.ShaOnionBlob[:],\n\t\tc.FailureCode,\n\t)\n}\n\n\n\n\n\nfunc (c *UpdateFailMalformedHTLC) MsgType() MessageType {\n\treturn MsgUpdateFailMalformedHTLC\n}\n\n\n\n\n\n\nfunc (c *UpdateFailMalformedHTLC) MaxPayloadLength(uint32) uint32 {\n\treturn 74\n}\n\n\n\n\n\nfunc (c *UpdateFailMalformedHTLC) TargetChanID() ChannelID {\n\treturn c.ChanID\n}\n\nfunc (c *UpdateFailMalformedHTLC) Decode(r io.Reader, pver uint32) error ", "output": "{\n\treturn ReadElements(r,\n\t\t&c.ChanID,\n\t\t&c.ID,\n\t\tc.ShaOnionBlob[:],\n\t\t&c.FailureCode,\n\t)\n}"}
{"input": "package resources\n\nimport \"github.com/awslabs/goformation/cloudformation/policies\"\n\n\n\ntype AWSDynamoDBTable_TimeToLiveSpecification struct {\n\n\tAttributeName string `json:\"AttributeName,omitempty\"`\n\n\tEnabled bool `json:\"Enabled\"`\n\n\t_deletionPolicy policies.DeletionPolicy\n\n\t_dependsOn []string\n\n\t_metadata map[string]interface{}\n}\n\n\nfunc (r *AWSDynamoDBTable_TimeToLiveSpecification) AWSCloudFormationType() string {\n\treturn \"AWS::DynamoDB::Table.TimeToLiveSpecification\"\n}\n\n\n\nfunc (r *AWSDynamoDBTable_TimeToLiveSpecification) DependsOn() []string {\n\treturn r._dependsOn\n}\n\n\n\n\n\n\n\nfunc (r *AWSDynamoDBTable_TimeToLiveSpecification) Metadata() map[string]interface{} {\n\treturn r._metadata\n}\n\n\n\nfunc (r *AWSDynamoDBTable_TimeToLiveSpecification) SetMetadata(metadata map[string]interface{}) {\n\tr._metadata = metadata\n}\n\n\n\nfunc (r *AWSDynamoDBTable_TimeToLiveSpecification) SetDeletionPolicy(policy policies.DeletionPolicy) {\n\tr._deletionPolicy = policy\n}\n\nfunc (r *AWSDynamoDBTable_TimeToLiveSpecification) SetDependsOn(dependencies []string) ", "output": "{\n\tr._dependsOn = dependencies\n}"}
{"input": "package identity\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype cacheData struct {\n\tIdentity Identity `json:\"identity\"`\n}\n\n\ntype IdentityCache struct {\n\tFile string\n}\n\n\n\n\n\nfunc (ic *IdentityCache) GetIdentity() (identity Identity, err error) {\n\tif !ic.cacheExists() {\n\t\terr = errors.New(\"cache file does not exist\")\n\t\treturn\n\t}\n\n\tcache, err := ic.readCache()\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn cache.Identity, nil\n}\n\n\nfunc (ic *IdentityCache) StoreIdentity(identity Identity) error {\n\tcache := cacheData{\n\t\tIdentity: identity,\n\t}\n\n\treturn ic.writeCache(cache)\n}\n\nfunc (ic *IdentityCache) cacheExists() bool {\n\tif _, err := os.Stat(ic.File); os.IsNotExist(err) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (ic *IdentityCache) readCache() (cache *cacheData, err error) {\n\tdata, err := ioutil.ReadFile(ic.File)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = json.Unmarshal(data, &cache)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (ic *IdentityCache) writeCache(cache cacheData) (err error) {\n\tcacheString, err := json.Marshal(cache)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = ioutil.WriteFile(ic.File, cacheString, 0644)\n\treturn\n}\n\nfunc NewIdentityCache(dir string, jsonFile string) IdentityCacheInterface ", "output": "{\n\treturn &IdentityCache{\n\t\tFile: filepath.Join(dir, jsonFile),\n\t}\n}"}
{"input": "package tcp\n\nimport (\n\t\"fmt\"\n)\n\n\ntype probeError struct {\n\taddress string\n\ttimeout bool\n\tmessage string\n\tcause   error\n}\n\nfunc (pe *probeError) Address() string {\n\treturn pe.address\n}\n\nfunc (pe *probeError) Cause() error {\n\treturn pe.cause\n}\n\nfunc (pe *probeError) Timeout() bool {\n\treturn pe.timeout\n}\n\nfunc (pe *probeError) Error() string {\n\tmsg := fmt.Sprintf(\n\t\t\"%s (address=%s, timeout=%t)\",\n\t\tpe.message,\n\t\tpe.address,\n\t\tpe.timeout,\n\t)\n\tif pe.cause != nil {\n\t\tmsg = fmt.Sprintf(\"%s: %v\", msg, pe.cause)\n\t}\n\treturn msg\n}\n\n\n\nfunc (pe *probeError) String() string ", "output": "{\n\treturn pe.Error()\n}"}
{"input": "package kafka\n\nimport (\n\t\"encoding/binary\"\n\t\"hash/crc32\"\n)\n\ntype crc32Writer struct {\n\ttable  *crc32.Table\n\tbuffer [8]byte\n\tcrc32  uint32\n}\n\nfunc (w *crc32Writer) update(b []byte) {\n\tw.crc32 = crc32.Update(w.crc32, w.table, b)\n}\n\nfunc (w *crc32Writer) writeInt8(i int8) {\n\tw.buffer[0] = byte(i)\n\tw.update(w.buffer[:1])\n}\n\nfunc (w *crc32Writer) writeInt16(i int16) {\n\tbinary.BigEndian.PutUint16(w.buffer[:2], uint16(i))\n\tw.update(w.buffer[:2])\n}\n\n\n\nfunc (w *crc32Writer) writeInt64(i int64) {\n\tbinary.BigEndian.PutUint64(w.buffer[:8], uint64(i))\n\tw.update(w.buffer[:8])\n}\n\nfunc (w *crc32Writer) writeBytes(b []byte) {\n\tn := len(b)\n\tif b == nil {\n\t\tn = -1\n\t}\n\tw.writeInt32(int32(n))\n\tw.update(b)\n}\n\nfunc (w *crc32Writer) Write(b []byte) (int, error) {\n\tw.update(b)\n\treturn len(b), nil\n}\n\nfunc (w *crc32Writer) WriteString(s string) (int, error) {\n\tw.update([]byte(s))\n\treturn len(s), nil\n}\n\nfunc (w *crc32Writer) writeInt32(i int32) ", "output": "{\n\tbinary.BigEndian.PutUint32(w.buffer[:4], uint32(i))\n\tw.update(w.buffer[:4])\n}"}
{"input": "package maintenance\n\nimport \"github.com/Azure/azure-sdk-for-go/version\"\n\n\n\n\n\n\n\n\n\n\n\nfunc Version() string {\n\treturn version.Number\n}\n\nfunc UserAgent() string ", "output": "{\n\treturn \"Azure-SDK-For-Go/\" + Version() + \" maintenance/2018-06-01-preview\"\n}"}
{"input": "package ui\n\nfunc About() string {\n\treturn \"go-ui 0.1.1 <visualfc@gmail.com>\"\n}\n\nfunc Version() string {\n\treturn \"go-ui 0.1.1\"\n}\n\nfunc Main(fn func()) int {\n\tfnAppMain = fn\n\treturn theApp.AppMain()\n}\n\nfunc Run() int {\n\treturn theApp.Run()\n}\n\nfunc Exit(code int) {\n\ttheApp.Exit(code)\n}\n\nfunc CloseAllWindows() {\n\ttheApp.CloseAllWindows()\n}\n\n\n\nfunc App() *app ", "output": "{\n\treturn &theApp\n}"}
{"input": "package oauth2\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/ory-am/fosite\"\n\t\"golang.org/x/net/context\"\n)\n\ntype HandleHelper struct {\n\tAccessTokenStrategy AccessTokenStrategy\n\tAccessTokenStorage  AccessTokenStorage\n\tAccessTokenLifespan time.Duration\n}\n\nfunc (h *HandleHelper) IssueAccessToken(ctx context.Context, req *http.Request, requester fosite.AccessRequester, responder fosite.AccessResponder) error {\n\ttoken, signature, err := h.AccessTokenStrategy.GenerateAccessToken(ctx, requester)\n\tif err != nil {\n\t\treturn err\n\t} else if err := h.AccessTokenStorage.CreateAccessTokenSession(ctx, signature, requester); err != nil {\n\t\treturn err\n\t}\n\n\tresponder.SetAccessToken(token)\n\tresponder.SetTokenType(\"bearer\")\n\tresponder.SetExpiresIn(getExpiresIn(requester, fosite.AccessToken, h.AccessTokenLifespan, time.Now()))\n\tresponder.SetScopes(requester.GetGrantedScopes())\n\treturn nil\n}\n\n\n\nfunc getExpiresIn(r fosite.Requester, key fosite.TokenType, defaultLifespan time.Duration, now time.Time) time.Duration ", "output": "{\n\tif r.GetSession().GetExpiresAt(key).IsZero() {\n\t\treturn defaultLifespan\n\t}\n\treturn time.Duration(r.GetSession().GetExpiresAt(key).UnixNano() - now.UnixNano())\n}"}
{"input": "package stack\n\nimport (\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/filters\"\n\t\"github.com/docker/docker/api/types/swarm\"\n\t\"github.com/docker/docker/cli/compose/convert\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/docker/opts\"\n)\n\nfunc getStackFilter(namespace string) filters.Args {\n\tfilter := filters.NewArgs()\n\tfilter.Add(\"label\", convert.LabelNamespace+\"=\"+namespace)\n\treturn filter\n}\n\nfunc getStackFilterFromOpt(namespace string, opt opts.FilterOpt) filters.Args {\n\tfilter := opt.Value()\n\tfilter.Add(\"label\", convert.LabelNamespace+\"=\"+namespace)\n\treturn filter\n}\n\nfunc getAllStacksFilter() filters.Args {\n\tfilter := filters.NewArgs()\n\tfilter.Add(\"label\", convert.LabelNamespace)\n\treturn filter\n}\n\nfunc getServices(\n\tctx context.Context,\n\tapiclient client.APIClient,\n\tnamespace string,\n) ([]swarm.Service, error) {\n\treturn apiclient.ServiceList(\n\t\tctx,\n\t\ttypes.ServiceListOptions{Filters: getStackFilter(namespace)})\n}\n\n\n\nfunc getStackNetworks(\n\tctx context.Context,\n\tapiclient client.APIClient,\n\tnamespace string,\n) ([]types.NetworkResource, error) ", "output": "{\n\treturn apiclient.NetworkList(\n\t\tctx,\n\t\ttypes.NetworkListOptions{Filters: getStackFilter(namespace)})\n}"}
{"input": "package okta\n\nimport (\n\t\"fmt\"\n\t\"github.com/okta/okta-sdk-golang/okta/query\"\n\t\"time\"\n)\n\ntype GroupRuleResource resource\n\ntype GroupRule struct {\n\tEmbedded       interface{}          `json:\"_embedded,omitempty\"`\n\tActions        *GroupRuleAction     `json:\"actions,omitempty\"`\n\tAllGroupsValid *bool                `json:\"allGroupsValid,omitempty\"`\n\tConditions     *GroupRuleConditions `json:\"conditions,omitempty\"`\n\tCreated        *time.Time           `json:\"created,omitempty\"`\n\tId             string               `json:\"id,omitempty\"`\n\tLastUpdated    *time.Time           `json:\"lastUpdated,omitempty\"`\n\tName           string               `json:\"name,omitempty\"`\n\tStatus         string               `json:\"status,omitempty\"`\n\tType           string               `json:\"type,omitempty\"`\n}\n\n\nfunc (m *GroupRuleResource) DeleteRule(ruleId string, qp *query.Params) (*Response, error) {\n\turl := fmt.Sprintf(\"/api/v1/groups/rules/%v\", ruleId)\n\tif qp != nil {\n\t\turl = url + qp.String()\n\t}\n\treq, err := m.client.requestExecutor.NewRequest(\"DELETE\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := m.client.requestExecutor.Do(req, nil)\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\treturn resp, nil\n}\n\nfunc (m *GroupRuleResource) UpdateRule(ruleId string, body GroupRule) (*GroupRule, *Response, error) ", "output": "{\n\turl := fmt.Sprintf(\"/api/v1/groups/rules/%v\", ruleId)\n\treq, err := m.client.requestExecutor.NewRequest(\"PUT\", url, body)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar groupRule *GroupRule\n\tresp, err := m.client.requestExecutor.Do(req, &groupRule)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\treturn groupRule, resp, nil\n}"}
{"input": "package acme\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nconst (\n\tdnsTemplate = \"%s %d IN TXT \\\"%s\\\"\"\n)\n\n\ntype DNSProviderManual struct{}\n\n\nfunc NewDNSProviderManual() (*DNSProviderManual, error) {\n\treturn &DNSProviderManual{}, nil\n}\n\n\n\n\n\nfunc (*DNSProviderManual) CleanUp(domain, token, keyAuth string) error {\n\tfqdn, _, ttl := DNS01Record(domain, keyAuth)\n\tdnsRecord := fmt.Sprintf(dnsTemplate, fqdn, ttl, \"...\")\n\n\tauthZone, err := FindZoneByFqdn(fqdn, RecursiveNameservers)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogf(\"[INFO] acme: You can now remove this TXT record from your %s zone:\", authZone)\n\tlogf(\"[INFO] acme: %s\", dnsRecord)\n\treturn nil\n}\n\nfunc (*DNSProviderManual) Present(domain, token, keyAuth string) error ", "output": "{\n\tfqdn, value, ttl := DNS01Record(domain, keyAuth)\n\tdnsRecord := fmt.Sprintf(dnsTemplate, fqdn, ttl, value)\n\n\tauthZone, err := FindZoneByFqdn(fqdn, RecursiveNameservers)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogf(\"[INFO] acme: Please create the following TXT record in your %s zone:\", authZone)\n\tlogf(\"[INFO] acme: %s\", dnsRecord)\n\tlogf(\"[INFO] acme: Press 'Enter' when you are done\")\n\n\treader := bufio.NewReader(os.Stdin)\n\t_, _ = reader.ReadString('\\n')\n\treturn nil\n}"}
{"input": "package subnets\n\nimport \"net\"\n\nfunc equals(a *net.IPNet, b *net.IPNet) bool {\n\taOnes, aBits := a.Mask.Size()\n\tbOnes, bBits := b.Mask.Size()\n\treturn a.IP.Equal(b.IP) && (aOnes == bOnes) && (aBits == bBits)\n}\n\nfunc overlaps(a *net.IPNet, b *net.IPNet) bool {\n\treturn a.Contains(b.IP) || b.Contains(a.IP)\n}\n\n\n\nfunc clone(ip net.IP) net.IP {\n\tclone := make([]byte, len(ip))\n\tcopy(clone, ip)\n\treturn clone\n}\n\nfunc max(ipn *net.IPNet) net.IP {\n\tmask := ipn.Mask\n\tmin := clone(ipn.IP)\n\n\tif len(mask) != len(min) {\n\t\tpanic(\"length of mask is not compatible with length of network IP\")\n\t}\n\n\tmax := make([]byte, len(min))\n\tfor i, b := range mask {\n\t\tmax[i] = min[i] | ^b\n\t}\n\n\treturn net.IP(max).To16()\n}\n\nfunc next(ip net.IP) net.IP ", "output": "{\n\tnext := clone(ip)\n\tfor i := len(next) - 1; i >= 0; i-- {\n\t\tnext[i]++\n\t\tif next[i] != 0 {\n\t\t\treturn next\n\t\t}\n\t}\n\n\tpanic(\"overflowed maximum IP\")\n}"}
{"input": "package config\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/dnephin/configtf\"\n\tpth \"github.com/dnephin/configtf/path\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntype ComposeConfig struct {\n\tFiles []string\n\tProject string `config:\"required\"`\n\tStopGrace int\n\tDependent\n\tAnnotations\n}\n\n\nfunc (c *ComposeConfig) StopGraceString() string {\n\treturn strconv.Itoa(c.StopGrace)\n}\n\n\n\n\nfunc (c *ComposeConfig) String() string {\n\treturn fmt.Sprintf(\"Run Compose project %q from: %v\",\n\t\tc.Project, strings.Join(c.Files, \", \"))\n}\n\n\nfunc (c *ComposeConfig) Resolve(resolver Resolver) (Resource, error) {\n\tconf := *c\n\tvar err error\n\tconf.Files, err = resolver.ResolveSlice(c.Files)\n\tif err != nil {\n\t\treturn &conf, err\n\t}\n\tconf.Project, err = resolver.Resolve(c.Project)\n\treturn &conf, err\n}\n\nfunc composeFromConfig(name string, values map[string]interface{}) (Resource, error) {\n\tcompose := &ComposeConfig{Project: \"{unique}\", StopGrace: 5}\n\treturn compose, configtf.Transform(name, values, compose)\n}\n\nfunc init() {\n\tRegisterResource(\"compose\", composeFromConfig)\n}\n\nfunc (c *ComposeConfig) Validate(path pth.Path, config *Config) *pth.Error ", "output": "{\n\treturn nil\n}"}
{"input": "package core\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/oracle/oci-go-sdk/common\"\n)\n\n\ntype VolumeGroupSourceFromVolumeGroupDetails struct {\n\n\tVolumeGroupId *string `mandatory:\"true\" json:\"volumeGroupId\"`\n}\n\nfunc (m VolumeGroupSourceFromVolumeGroupDetails) String() string {\n\treturn common.PointerString(m)\n}\n\n\n\n\nfunc (m VolumeGroupSourceFromVolumeGroupDetails) MarshalJSON() (buff []byte, e error) ", "output": "{\n\ttype MarshalTypeVolumeGroupSourceFromVolumeGroupDetails VolumeGroupSourceFromVolumeGroupDetails\n\ts := struct {\n\t\tDiscriminatorParam string `json:\"type\"`\n\t\tMarshalTypeVolumeGroupSourceFromVolumeGroupDetails\n\t}{\n\t\t\"volumeGroupId\",\n\t\t(MarshalTypeVolumeGroupSourceFromVolumeGroupDetails)(m),\n\t}\n\n\treturn json.Marshal(&s)\n}"}
{"input": "package external\n\nimport (\n\t\"github.com/Aptomi/aptomi/pkg/external/secrets\"\n\t\"github.com/Aptomi/aptomi/pkg/external/users\"\n)\n\n\ntype Data struct {\n\tUserLoader   users.UserLoader\n\tSecretLoader secrets.SecretLoader\n}\n\n\n\n\nfunc NewData(userLoader users.UserLoader, secretLoader secrets.SecretLoader) *Data ", "output": "{\n\treturn &Data{\n\t\tUserLoader:   userLoader,\n\t\tSecretLoader: secretLoader,\n\t}\n}"}
{"input": "package redshift_test\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/awserr\"\n\t\"github.com/aws/aws-sdk-go/aws/request\"\n\t\"github.com/aws/aws-sdk-go/awstesting/integration\"\n\t\"github.com/aws/aws-sdk-go/service/redshift\"\n)\n\nvar _ aws.Config\nvar _ awserr.Error\nvar _ request.Request\n\n\nfunc TestInteg_01_DescribeClusters(t *testing.T) {\n\tctx, cancelFn := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancelFn()\n\n\tsess := integration.SessionWithDefaultRegion(\"us-west-2\")\n\tsvc := redshift.New(sess)\n\tparams := &redshift.DescribeClustersInput{\n\t\tClusterIdentifier: aws.String(\"fake-cluster\"),\n\t}\n\t_, err := svc.DescribeClustersWithContext(ctx, params, func(r *request.Request) {\n\t\tr.Handlers.Validate.RemoveByName(\"core.ValidateParametersHandler\")\n\t})\n\tif err == nil {\n\t\tt.Fatalf(\"expect request to fail\")\n\t}\n\taerr, ok := err.(awserr.RequestFailure)\n\tif !ok {\n\t\tt.Fatalf(\"expect awserr, was %T\", err)\n\t}\n\tif len(aerr.Code()) == 0 {\n\t\tt.Errorf(\"expect non-empty error code\")\n\t}\n\tif len(aerr.Message()) == 0 {\n\t\tt.Errorf(\"expect non-empty error message\")\n\t}\n\tif v := aerr.Code(); v == request.ErrCodeSerialization {\n\t\tt.Errorf(\"expect API error code got serialization failure\")\n\t}\n}\n\nfunc TestInteg_00_DescribeClusterVersions(t *testing.T) ", "output": "{\n\tctx, cancelFn := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancelFn()\n\n\tsess := integration.SessionWithDefaultRegion(\"us-west-2\")\n\tsvc := redshift.New(sess)\n\tparams := &redshift.DescribeClusterVersionsInput{}\n\t_, err := svc.DescribeClusterVersionsWithContext(ctx, params, func(r *request.Request) {\n\t\tr.Handlers.Validate.RemoveByName(\"core.ValidateParametersHandler\")\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"expect no error, got %v\", err)\n\t}\n}"}
{"input": "package models\n\n\n\n\nimport (\n\t\"context\"\n\n\t\"github.com/go-openapi/errors\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/go-openapi/validate\"\n)\n\n\n\n\ntype CompletedRequest struct {\n\n\tRedirectTo *string `json:\"redirect_to\"`\n}\n\n\nfunc (m *CompletedRequest) Validate(formats strfmt.Registry) error {\n\tvar res []error\n\n\tif err := m.validateRedirectTo(formats); err != nil {\n\t\tres = append(res, err)\n\t}\n\n\tif len(res) > 0 {\n\t\treturn errors.CompositeValidationError(res...)\n\t}\n\treturn nil\n}\n\nfunc (m *CompletedRequest) validateRedirectTo(formats strfmt.Registry) error {\n\n\tif err := validate.Required(\"redirect_to\", \"body\", m.RedirectTo); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\nfunc (m *CompletedRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {\n\treturn nil\n}\n\n\nfunc (m *CompletedRequest) MarshalBinary() ([]byte, error) {\n\tif m == nil {\n\t\treturn nil, nil\n\t}\n\treturn swag.WriteJSON(m)\n}\n\n\n\n\nfunc (m *CompletedRequest) UnmarshalBinary(b []byte) error ", "output": "{\n\tvar res CompletedRequest\n\tif err := swag.ReadJSON(b, &res); err != nil {\n\t\treturn err\n\t}\n\t*m = res\n\treturn nil\n}"}
{"input": "package image\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n\t\"os\"\n\n\t\"github.com/coreos/rkt/store/imagestore\"\n\t\"github.com/hashicorp/errwrap\"\n)\n\n\n\ntype ascFetcher interface {\n\tGet(location string) (readSeekCloser, error)\n}\n\n\n\ntype localAscFetcher struct{}\n\n\n\n\n\ntype remoteAscFetcher struct {\n\tF func(*url.URL, *os.File) error\n\tS *imagestore.Store\n}\n\nfunc (f *remoteAscFetcher) Get(location string) (readSeekCloser, error) {\n\troc, err := getTmpROC(f.S, location)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() { maybeClose(roc) }()\n\n\tu, err := url.Parse(location)\n\tif err != nil {\n\t\treturn nil, errwrap.Wrap(errors.New(\"invalid signature location\"), err)\n\t}\n\tif err := f.F(u, roc.File); err != nil {\n\t\treturn nil, err\n\t}\n\tretRoc := roc\n\troc = nil\n\treturn retRoc, nil\n}\n\n\ntype asc struct {\n\tLocation string\n\tFetcher ascFetcher\n}\n\n\n\nfunc (a *asc) Get() (readSeekCloser, error) {\n\tif a.Fetcher != nil {\n\t\treturn a.Fetcher.Get(a.Location)\n\t}\n\treturn nil, nil\n}\n\nfunc (*localAscFetcher) Get(location string) (readSeekCloser, error) ", "output": "{\n\treturn os.Open(location)\n}"}
{"input": "package cmd\n\nimport (\n\t\"fmt\"\n)\n\n\n\nfunc println(a ...interface{}) {\n\tif !quietFlag {\n\t\tfmt.Println(a...)\n\t}\n}\n\nfunc dprintf(format string, a ...interface{}) {\n\tif debugFlag {\n\t\tprintf(format, a...)\n\t}\n}\n\nfunc dprintln(a ...interface{}) {\n\tif debugFlag {\n\t\tprintln(a...)\n\t}\n}\n\nfunc vprintf(format string, a ...interface{}) {\n\tif verboseFlag {\n\t\tprintf(format, a...)\n\t}\n}\n\nfunc vprintln(a ...interface{}) {\n\tif verboseFlag {\n\t\tprintln(a...)\n\t}\n}\n\nfunc contains(strings []string, str string) bool {\n\tfor _, s := range strings {\n\t\tif s == str {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc printf(format string, a ...interface{}) ", "output": "{\n\tif !quietFlag {\n\t\tfmt.Printf(format, a...)\n\t}\n}"}
{"input": "package dodo\n\n\n\n\ntype propertyIndex struct {\n\tpropertyIndexMap map[string]map[string]int\n}\n\nfunc (p *propertyIndex) index(container, property string) *int {\n\n\tindexMap, exists := p.propertyIndexMap[container]\n\tif !exists {\n\t\treturn nil\n\t}\n\n\tindex, exists := indexMap[property]\n\tif !exists {\n\t\treturn nil\n\t}\n\n\treturn &index\n}\n\nfunc (p *propertyIndex) incrementIndex(container, property string) *int {\n\n\tindexMap, exists := p.propertyIndexMap[container]\n\tif !exists {\n\t\tindexMap = map[string]int{}\n\t\tp.propertyIndexMap[container] = indexMap\n\t}\n\n\tindex, exists := indexMap[property]\n\tif !exists {\n\t\tindex = 0\n\t\tindexMap[property] = index\n\t} else {\n\t\tindex++\n\t\tindexMap[property] = index\n\t}\n\n\treturn &index\n}\n\nfunc NewPropertyIndex() *propertyIndex ", "output": "{\n\n\treturn &propertyIndex{\n\t\tpropertyIndexMap: map[string]map[string]int{},\n\t}\n}"}
{"input": "package payload_test\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/RobotsAndPencils/buford/payload\"\n)\n\nfunc ExampleBrowser() {\n\tp := payload.Browser{\n\t\tAlert: payload.BrowserAlert{\n\t\t\tTitle:  \"Flight A998 Now Boarding\",\n\t\t\tBody:   \"Boarding has begun for Flight A998.\",\n\t\t\tAction: \"View\",\n\t\t},\n\t\tURLArgs: []string{\"boarding\", \"A998\"},\n\t}\n\n\tb, err := json.Marshal(p)\n\tif err != nil {\n\t}\n\tfmt.Printf(\"%s\", b)\n}\n\n\n\nfunc TestValidBrowser(t *testing.T) {\n\tp := payload.Browser{\n\t\tAlert: payload.BrowserAlert{\n\t\t\tTitle: \"Flight A998 Now Boarding\",\n\t\t\tBody:  \"Boarding has begun for Flight A998.\",\n\t\t},\n\t}\n\tif err := p.Validate(); err != nil {\n\t\tt.Errorf(\"Expected no error, got %v.\", err)\n\t}\n}\n\nfunc TestInvalidBrowser(t *testing.T) {\n\ttests := []*payload.Browser{\n\t\t{\n\t\t\tAlert: payload.BrowserAlert{Action: \"View\"},\n\t\t},\n\t\t{},\n\t\tnil,\n\t}\n\n\tfor _, p := range tests {\n\t\tif err := p.Validate(); err != payload.ErrIncomplete {\n\t\t\tt.Errorf(\"Expected err %v, got %v.\", payload.ErrIncomplete, err)\n\t\t}\n\t}\n}\n\nfunc TestBrowser(t *testing.T) ", "output": "{\n\tp := payload.Browser{\n\t\tAlert: payload.BrowserAlert{\n\t\t\tTitle:  \"Flight A998 Now Boarding\",\n\t\t\tBody:   \"Boarding has begun for Flight A998.\",\n\t\t\tAction: \"View\",\n\t\t},\n\t\tURLArgs: []string{\"boarding\", \"A998\"},\n\t}\n\texpected := []byte(`{\"aps\":{\"alert\":{\"title\":\"Flight A998 Now Boarding\",\"body\":\"Boarding has begun for Flight A998.\",\"action\":\"View\"},\"url-args\":[\"boarding\",\"A998\"]}}`)\n\ttestPayload(t, p, expected)\n}"}
{"input": "package integration\n\nimport (\n\t\"context\"\n\t\"testing\"\n)\n\n\n\nfunc TestUserSettings_List(t *testing.T) ", "output": "{\n\tresult, _, err := client.UserSettings.List(context.Background())\n\n\tif err != nil {\n\t\tt.Errorf(\"Could not get webhooks list: %v\", err)\n\t}\n\n\tif result.Success != true {\n\t\tt.Error(\"Got invalid result\")\n\t}\n}"}
{"input": "package ghttp\n\nimport \"github.com/gogf/gf/v2/os/gview\"\n\n\nfunc (r *Request) SetView(view *gview.View) {\n\tr.viewObject = view\n}\n\n\nfunc (r *Request) GetView() *gview.View {\n\tview := r.viewObject\n\tif view == nil {\n\t\tview = r.Server.config.View\n\t}\n\tif view == nil {\n\t\tview = gview.Instance()\n\t}\n\treturn view\n}\n\n\nfunc (r *Request) Assigns(data gview.Params) {\n\tif r.viewParams == nil {\n\t\tr.viewParams = make(gview.Params, len(data))\n\t}\n\tfor k, v := range data {\n\t\tr.viewParams[k] = v\n\t}\n}\n\n\n\n\nfunc (r *Request) Assign(key string, value interface{}) ", "output": "{\n\tif r.viewParams == nil {\n\t\tr.viewParams = make(gview.Params)\n\t}\n\tr.viewParams[key] = value\n}"}
{"input": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\n\t\"github.com/scgolang/dx7/sysex\"\n)\n\nfunc usage() {\n\tfmt.Fprintf(os.Stderr, \"Usage:\\n\")\n\tfmt.Fprintf(os.Stderr, \"  %s [OPTIONS] [FILE]\\n\", os.Args[0])\n\tfmt.Fprintf(os.Stderr, \"If FILE is not provided, sysex data will be read from stdin.\\n\")\n\tfmt.Fprintf(os.Stderr, \"OPTIONS\\n\")\n\tfmt.Fprintf(os.Stderr, \"  -format          xml|json\\n\")\n}\n\nfunc main() {\n\tformat := flag.String(\"format\", \"xml\", \"output format\")\n\tflag.Parse()\n\n\tif *format != \"xml\" && *format != \"json\" {\n\t\tusage()\n\t\tos.Exit(1)\n\t}\n\n\targs := flag.Args()\n\tswitch len(args) {\n\tcase 0:\n\t\tif err := run(os.Stdin, os.Stdout, *format); err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t}\n\tcase 1:\n\t\tr, err := os.Open(args[0])\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t}\n\t\tif err := run(r, os.Stdout, *format); err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t}\n\tdefault:\n\t\tusage()\n\t\tos.Exit(1)\n\t}\n}\n\n\n\n\nfunc run(r io.Reader, w io.Writer, format string) error ", "output": "{\n\tsyx, err := sysex.New(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch format {\n\tdefault:\n\t\treturn fmt.Errorf(\"Unrecognized format: %s\", format)\n\tcase \"xml\":\n\t\treturn xml.NewEncoder(w).Encode(syx)\n\tcase \"json\":\n\t\treturn json.NewEncoder(w).Encode(syx)\n\t}\n}"}
{"input": "package helpers\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"runtime\"\n)\n\nfunc GetFixturePath(name string) string {\n\t_, filename, _, _ := runtime.Caller(0)\n\n\tfixturePath := path.Join(path.Dir(filename), \"..\", \"fixtures\", name)\n\n\t_, err := os.Stat(fixturePath)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn fixturePath\n}\n\nfunc ReadFixtureBytes(name string) []byte {\n\tpath := GetFixturePath(name)\n\tcontents, err := ioutil.ReadFile(path)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn contents\n}\n\n\n\nfunc ReadFixtureString(name string) string ", "output": "{\n\treturn string(ReadFixtureBytes(name))\n}"}
{"input": "package engine\n\n\ntype Novel struct {\n\tName                  string     \n\tLastUpdateTime        string     \n\tAuthor                string     \n\tMenuURL               string     \n\tIconURL               string     \n\tNewestLastChapterName string     \n\tDescription           string     \n\tMenus                 []*Menu    \n\tChapters              []*Chapter \n}\n\n\ntype Menu struct {\n\tName string \n\tURL  string \n}\n\n\ntype Chapter struct {\n\tTitle   string \n\tContent string \n}\n\nfunc (novel *Novel) AddMenu(menu *Menu) {\n\tnovel.Menus = append(novel.Menus, menu)\n}\n\nfunc (novel *Novel) AddChapter(chapter *Chapter) {\n\tnovel.Chapters = append(novel.Chapters, chapter)\n}\n\nfunc NewMenu(name, url string) *Menu {\n\treturn &Menu{name, url}\n}\n\n\n\nfunc NewChapter(title, content string) *Chapter ", "output": "{\n\treturn &Chapter{title, content}\n}"}
{"input": "package protos\n\nimport (\n\t\"log\"\n\t\"runtime\"\n)\n\nimport (\n\t\"db/stats_tbl\"\n\t\"misc/packet\"\n)\n\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tfuncName, file, line, ok := runtime.Caller(1)\n\t\tif ok {\n\t\t\tlog.Printf(\"ERR:%v,[func:%v,file:%v,line:%v]\\n\", err, runtime.FuncForPC(funcName).Name(), file, line)\n\t\t}\n\n\t\tpanic(\"error occured in Stats Protocol Module\")\n\t}\n}\n\n\n\nfunc P_set_update_req(reader *packet.Packet) []byte {\n\ttbl, err := PKT_SET_UPDATE_REQ(reader)\n\tcheckErr(err)\n\tstats_tbl.SetUpdate(tbl.F_key, tbl.F_value, tbl.F_lang)\n\treturn nil\n}\n\nfunc P_set_adds_req(reader *packet.Packet) []byte ", "output": "{\n\ttbl, err := PKT_SET_ADDS_REQ(reader)\n\tcheckErr(err)\n\tstats_tbl.SetAdds(tbl.F_key, tbl.F_value, tbl.F_lang)\n\treturn nil\n}"}
{"input": "package permute\n\nimport \"fmt\"\n\n\n\nfunc ExampleSteinhausJohnsonTrotterEven() {\n\ti := 0\n\n\tA := []string{\"A\", \"B\", \"C\", \"D\"}\n\n\tp := NewPlainChangeFastGen(len(A))\n\tfmt.Printf(\"%2d:       %v\\n\", i, A)\n\n\tvar sw [2]int\n\tfor p.Next(&sw) {\n\t\ti++\n\t\tSwapStrings(sw, A)\n\t\tfmt.Printf(\"%2d: (%d,%d) %v\\n\", i, sw[0], sw[1], A)\n\t}\n\n}\n\nfunc ExampleSteinhausJohnsonTrotter() ", "output": "{\n\ti := 0\n\n\tA := []string{\"A\", \"B\", \"C\", \"D\"}\n\n\tp := NewPlainChangeGen(len(A))\n\tfmt.Printf(\"%2d:       %v\\n\", i, A)\n\n\tvar sw [2]int\n\tfor p.Next(&sw) {\n\t\ti++\n\t\tSwapStrings(sw, A)\n\t\tfmt.Printf(\"%2d: (%d,%d) %v\\n\", i, sw[0], sw[1], A)\n\t}\n\n}"}
{"input": "package cmd\n\n\ntype readDirOpts struct {\n\tcount int\n\tfollowDirSymlink bool\n}\n\n\nfunc readDir(dirPath string) (entries []string, err error) {\n\treturn readDirWithOpts(dirPath, readDirOpts{count: -1})\n}\n\n\n\n\nfunc readDirN(dirPath string, count int) (entries []string, err error) ", "output": "{\n\treturn readDirWithOpts(dirPath, readDirOpts{count: count})\n}"}
{"input": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/reinbach/golang-webapp-guide/template/template\"\n\t\"github.com/zenazn/goji\"\n\t\"github.com/zenazn/goji/web\"\n)\n\nvar (\n\ttemplates = []string{\"base.html\"}\n)\n\nfunc Home(c web.C, w http.ResponseWriter, r *http.Request) {\n\tctx := template.NewContext()\n\tctx.Add(\"HomePage\", true)\n\ttemplate.Render(c, w, r, append(templates, \"home.html\"), ctx)\n}\n\nfunc About(c web.C, w http.ResponseWriter, r *http.Request) {\n\tctx := template.NewContext()\n\tctx.Add(\"AboutPage\", true)\n\ttemplate.Render(c, w, r, append(templates, \"about.html\"), ctx)\n}\n\n\n\nfunc main() {\n\thttp.HandleFunc(template.STATIC_URL, template.StaticHandler)\n\tgoji.Get(\"/\", Home)\n\tgoji.Get(\"/about\", About)\n\tgoji.NotFound(NotFound)\n\n\tgoji.Serve()\n}\n\nfunc NotFound(c web.C, w http.ResponseWriter, r *http.Request) ", "output": "{\n\ttemplate.Render(c, w, r, append(templates, \"404.html\"),\n\t\ttemplate.NewContext())\n}"}
{"input": "package portgroup\n\nimport (\n\t\"context\"\n\t\"flag\"\n\n\t\"github.com/vmware/govmomi/govc/cli\"\n\t\"github.com/vmware/govmomi/govc/flags\"\n)\n\ntype remove struct {\n\t*flags.HostSystemFlag\n}\n\nfunc init() {\n\tcli.Register(\"host.portgroup.remove\", &remove{})\n}\n\nfunc (cmd *remove) Register(ctx context.Context, f *flag.FlagSet) {\n\tcmd.HostSystemFlag, ctx = flags.NewHostSystemFlag(ctx)\n\tcmd.HostSystemFlag.Register(ctx, f)\n}\n\nfunc (cmd *remove) Process(ctx context.Context) error {\n\tif err := cmd.HostSystemFlag.Process(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n\n\nfunc (cmd *remove) Run(ctx context.Context, f *flag.FlagSet) error {\n\tns, err := cmd.HostNetworkSystem()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ns.RemovePortGroup(ctx, f.Arg(0))\n}\n\nfunc (cmd *remove) Usage() string ", "output": "{\n\treturn \"NAME\"\n}"}
{"input": "package systray\n\n\nimport \"C\"\n\nimport (\n\t\"unsafe\"\n)\n\nfunc nativeLoop() {\n\tC.nativeLoop()\n}\n\n\n\n\n\n\nfunc SetIcon(iconBytes []byte) {\n\tcstr := (*C.char)(unsafe.Pointer(&iconBytes[0]))\n\tC.setIcon(cstr, (C.int)(len(iconBytes)))\n}\n\n\nfunc SetTitle(title string) {\n\tC.setTitle(C.CString(title))\n}\n\n\n\nfunc SetTooltip(tooltip string) {\n\tC.setTooltip(C.CString(tooltip))\n}\n\nfunc addOrUpdateMenuItem(item *MenuItem) {\n\tvar disabled C.short\n\tif item.disabled {\n\t\tdisabled = 1\n\t}\n\tvar checked C.short\n\tif item.checked {\n\t\tchecked = 1\n\t}\n\tC.add_or_update_menu_item(\n\n\t\tC.int(item.id),\n\t\tC.CString(item.title),\n\t\tC.CString(item.tooltip),\n\t\tdisabled,\n\t\tchecked,\n\t)\n}\n\n\nfunc systray_ready() {\n\tsystrayReady()\n}\n\n\nfunc systray_menu_item_selected(cID C.int) {\n\tsystrayMenuItemSelected(int32(cID))\n}\n\nfunc quit() ", "output": "{\n\tC.quit()\n}"}
{"input": "package log\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/juliengk/go-log/driver\"\n)\n\ntype Initialize func(options interface{}) (driver.Logger, error)\n\nvar initializers = make(map[string]Initialize)\n\nfunc supportedDriver() string {\n\tdrivers := make([]string, 0, len(initializers))\n\n\tfor d := range initializers {\n\t\tdrivers = append(drivers, string(d))\n\t}\n\n\tsort.Strings(drivers)\n\n\treturn strings.Join(drivers, \",\")\n}\n\n\n\nfunc RegisterDriver(driver string, init Initialize) {\n\tinitializers[driver] = init\n}\n\nfunc NewDriver(driver string, options interface{}) (driver.Logger, error) ", "output": "{\n\tif init, exists := initializers[driver]; exists {\n\t\treturn init(options)\n\t}\n\n\treturn nil, fmt.Errorf(\"The Logger Driver: %s is not supported. Supported drivers are %s\", driver, supportedDriver())\n}"}
{"input": "package lnwire\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\ntype NeighborAckMessage struct {\n\tRoutingMessageBase\n}\n\nfunc (msg *NeighborAckMessage) String() string {\n\treturn fmt.Sprintf(\"NeighborAckMessage{%v %v}\", msg.SenderID, msg.ReceiverID)\n}\n\n\n\nfunc (msg *NeighborAckMessage) Encode(w io.Writer, pver uint32) error{\n\treturn nil\n}\n\nfunc (msg *NeighborAckMessage) Decode(r io.Reader, pver uint32) error{\n\treturn nil\n}\n\nfunc (msg *NeighborAckMessage) MaxPayloadLength(uint32) uint32{\n\treturn 0\n}\n\nfunc (msg *NeighborAckMessage) Validate() error{\n\treturn nil\n}\n\nvar _ Message = (*NeighborAckMessage)(nil)\n\nfunc (msg *NeighborAckMessage) Command() uint32", "output": "{\n\treturn CmdNeighborAckMessage\n}"}
{"input": "package gomposer\n\nimport (\n\t\"os\"\n\n\t\"encoding/json\"\n)\n\ntype PackageReader struct {\n}\n\n\n\nfunc (pr PackageReader) Read(filename string) (ComposerPackage, error) ", "output": "{\n\n\tbuf, err := os.Open(filename)\n\n\toutput := ComposerPackage{}\n\tif err != nil {\n\t\treturn output, err\n\t}\n\n\tjson.NewDecoder(buf).Decode(&output)\n\n\treturn output, nil\n}"}
{"input": "package flags\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\n\n\ntype IniError struct {\n\tMessage string\n\n\tFile string\n\n\tLineNumber uint\n}\n\n\nfunc (x *IniError) Error() string {\n\treturn fmt.Sprintf(\"%s:%d: %s\",\n\t\tx.File,\n\t\tx.LineNumber,\n\t\tx.Message)\n}\n\n\ntype IniOptions uint\n\nconst (\n\tIniNone IniOptions = 0\n\n\tIniIncludeDefaults = 1 << iota\n\n\tIniCommentDefaults\n\n\tIniIncludeComments\n\n\tIniDefault = IniIncludeComments\n)\n\n\n\ntype IniParser struct {\n\tparser *Parser\n}\n\n\nfunc NewIniParser(p *Parser) *IniParser {\n\treturn &IniParser{\n\t\tparser: p,\n\t}\n}\n\n\n\n\n\nfunc IniParse(filename string, data interface{}) error {\n\tp := NewParser(data, Default)\n\treturn NewIniParser(p).ParseFile(filename)\n}\n\n\n\n\nfunc (i *IniParser) ParseFile(filename string) error {\n\ti.parser.storeDefaults()\n\n\tini, err := readIniFromFile(filename)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn i.parse(ini)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunc (i *IniParser) WriteFile(filename string, options IniOptions) error {\n\tfile, err := os.Create(filename)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer file.Close()\n\ti.Write(file, options)\n\n\treturn nil\n}\n\n\n\n\n\n\nfunc (i *IniParser) Write(writer io.Writer, options IniOptions) {\n\twriteIni(i, writer, options)\n}\n\nfunc (i *IniParser) Parse(reader io.Reader) error ", "output": "{\n\ti.parser.storeDefaults()\n\n\tini, err := readIni(reader, \"\")\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn i.parse(ini)\n}"}
{"input": "package buildings\n\ntype store struct {\n\tbasicBuilding\n\timprovementLvl int8\n\tsales          int\n\tprice          int\n}\n\n\nfunc (b *store) GetRevenue() int { return b.sales * b.price }\nfunc (b *store) GetRent() int    { return [4]int{1, 2, 3, 5}[b.improvementLvl] }\nfunc (b *store) GetInternalInt(name string) int {\n\tswitch name {\n\tcase \"improvementLvl\":\n\t\treturn int(b.improvementLvl)\n\tcase \"sales\":\n\t\treturn b.sales\n\tcase \"price\":\n\t\treturn b.price\n\tdefault:\n\t\treturn 0\n\t}\n}\nfunc (b *store) SetInternalInt(name string, val int) {\n\tswitch name {\n\tcase \"improvementLvl\":\n\t\tb.improvementLvl = int8(val)\n\tcase \"sales\":\n\t\tb.sales = val\n\tcase \"price\":\n\t\tb.price = val\n\t}\n}\nfunc (b *store) ToString(x, y int) string {\n\treturn \"store,\" + string(b.improvementLvl) + \",\" + string(b.sales) + \",\" + string(b.price) + \",\" + b.basicBuilding.ToString(x, y)\n}\n\nfunc (*store) GetType() string   ", "output": "{ return \"store\" }"}
{"input": "package examples\n\ntype Stack struct {\n\tstack []interface{}\n}\n\nfunc NewStack() *Stack {\n\treturn &Stack{make([]interface{}, 0)}\n}\n\n\n\nfunc (this *Stack) Pop() interface{} {\n\tlast := len(this.stack) - 1\n\tpopped := this.stack[last]\n\tthis.stack = this.stack[:last]\n\treturn popped\n}\n\nfunc (this *Stack) Empty() bool {\n\treturn len(this.stack) == 0\n}\n\nfunc (this *Stack) Push(obj interface{}) ", "output": "{\n\tthis.stack = append(this.stack, obj)\n}"}
{"input": "package like\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/smartystreets/goconvey/convey\"\n)\n\n\n\nfunc TestLikeRawLikeContent(t *testing.T) ", "output": "{\n\tconvey.Convey(\"RawLikeContent\", t, func(ctx convey.C) {\n\t\tvar (\n\t\t\tc   = context.Background()\n\t\t\tids = []int64{1, 2}\n\t\t)\n\t\tctx.Convey(\"When everything goes positive\", func(ctx convey.C) {\n\t\t\tres, err := d.RawLikeContent(c, ids)\n\t\t\tctx.Convey(\"Then err should be nil.res should not be nil.\", func(ctx convey.C) {\n\t\t\t\tctx.So(err, convey.ShouldBeNil)\n\t\t\t\tctx.So(res, convey.ShouldNotBeNil)\n\t\t\t})\n\t\t})\n\t})\n}"}
{"input": "package core\n\nimport (\n\t\"github.com/oracle/oci-go-sdk/common\"\n)\n\n\ntype ChangeBootVolumeCompartmentDetails struct {\n\n\tCompartmentId *string `mandatory:\"true\" json:\"compartmentId\"`\n}\n\n\n\nfunc (m ChangeBootVolumeCompartmentDetails) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package ltree\n\n\n\n\nfunc toBST(nums []int, start, end int) *TreeNode {\n\tif start > end {\n\t\treturn nil\n\t}\n\n\tmid := start + (end-start)/2\n\troot := &TreeNode{Val: nums[mid]}\n\troot.Left = toBST(nums, start, mid-1)\n\troot.Right = toBST(nums, mid+1, end)\n\treturn root\n}\n\nfunc sortedArrayToBST(nums []int) *TreeNode ", "output": "{\n\treturn toBST(nums, 0, len(nums)-1)\n}"}
{"input": "package handler\n\nimport (\n\t\"errors\"\n\n\t\"github.com/KyleBanks/s3fs/handler/command\"\n\t\"github.com/KyleBanks/s3fs/handler/command/context\"\n)\n\n\ntype S3Handler struct {\n\ts3 command.S3Client\n\tui indicator\n\n\tcon *context.Context\n}\n\n\nfunc (s S3Handler) Handle(cmd []string, out command.Outputter) error {\n\tif len(cmd) == 0 {\n\t\treturn nil\n\t}\n\n\te, err := s.commandFromArgs(cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif e.IsLongRunning() {\n\t\ts.ui.ShowLoader()\n\t}\n\n\terr = e.Execute(out)\n\n\tif e.IsLongRunning() {\n\t\ts.ui.HideLoader()\n\t}\n\n\treturn err\n}\n\n\n\n\n\nfunc NewS3(s3 command.S3Client, ui indicator) S3Handler {\n\treturn S3Handler{\n\t\ts3:  s3,\n\t\tui:  ui,\n\t\tcon: &context.Context{},\n\t}\n}\n\nfunc (s S3Handler) commandFromArgs(args []string) (ex command.Executor, err error) ", "output": "{\n\tswitch args[0] {\n\n\tcase command.CmdLs:\n\t\tex = command.NewLs(s.s3, s.con)\n\tcase command.CmdCd:\n\t\tex = command.NewCd(s.s3, s.con, args[1:])\n\tcase command.CmdGet:\n\t\tex = command.NewGet(s.s3, s.con, args[1:])\n\tcase command.CmdPut:\n\t\tex = command.NewPut(s.s3, s.con, args[1:])\n\tcase command.CmdPwd:\n\t\tex = command.NewPwd(s.con)\n\tcase command.CmdClear:\n\t\tex = command.NewClear()\n\tcase command.CmdExit:\n\t\tex = command.NewExit()\n\n\tdefault:\n\t\terr = errors.New(\"Unknown Command: \" + args[0])\n\t}\n\n\treturn ex, err\n}"}
{"input": "package health\n\nimport (\n\t\"context\"\n\n\t\"github.com/go-kit/kit/endpoint\"\n)\n\n\ntype Endpoints struct {\n\tShow endpoint.Endpoint\n}\n\n\nfunc NewEndpoints(s Service) *Endpoints {\n\treturn &Endpoints{\n\t\tShow: NewShowEndpoint(s),\n\t}\n}\n\n\nfunc (e *Endpoints) Use(m func(endpoint.Endpoint) endpoint.Endpoint) {\n\te.Show = m(e.Show)\n}\n\n\n\n\n\nfunc NewShowEndpoint(s Service) endpoint.Endpoint ", "output": "{\n\treturn func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\treturn s.Show(ctx)\n\t}\n}"}
{"input": "package fdlimit\n\nimport \"fmt\"\n\n\nconst hardlimit = 16384\n\n\n\nfunc Raise(max uint64) (uint64, error) {\n\tif max > hardlimit {\n\t\treturn hardlimit, fmt.Errorf(\"file descriptor limit (%d) reached\", hardlimit)\n\t}\n\treturn max, nil\n}\n\n\n\n\n\n\n\nfunc Maximum() (int, error) {\n\treturn Current()\n}\n\nfunc Current() (int, error) ", "output": "{\n\treturn hardlimit, nil\n}"}
{"input": "package config\n\nimport (\n\t\"k8s.io/perf-tests/clusterloader2/api\"\n)\n\n\ntype ClusterLoaderConfig struct {\n\tClusterConfig     ClusterConfig\n\tReportDir         string\n\tEnableExecService bool\n\tTestScenario      api.TestScenario\n\tPrometheusConfig  PrometheusConfig\n}\n\n\ntype ClusterConfig struct {\n\tKubeConfigPath             string\n\tNodes                      int\n\tProvider                   string\n\tEtcdInsecurePort           int\n\tMasterIPs                  []string\n\tMasterInternalIPs          []string\n\tMasterName                 string\n\tKubemarkRootKubeConfigPath string\n}\n\n\ntype PrometheusConfig struct {\n\tEnableServer       bool\n\tTearDownServer     bool\n\tScrapeEtcd         bool\n\tScrapeNodeExporter bool\n\tScrapeKubelets     bool\n\tScrapeKubeProxy    bool\n}\n\n\n\nfunc (c *ClusterConfig) GetMasterIp() string {\n\tif len(c.MasterIPs) > 0 {\n\t\treturn c.MasterIPs[0]\n\t}\n\treturn \"\"\n}\n\n\n\n\n\nfunc (c *ClusterConfig) GetMasterInternalIp() string ", "output": "{\n\tif len(c.MasterInternalIPs) > 0 {\n\t\treturn c.MasterInternalIPs[0]\n\t}\n\treturn \"\"\n}"}
{"input": "package v3action\n\n\ntype SortOrder string\n\nconst (\n\tAscending  SortOrder = \"Ascending\"\n\tDescending SortOrder = \"Descending\"\n)\n\n\ntype Warnings []string\n\n\ntype Actor struct {\n\tCloudControllerClient CloudControllerClient\n}\n\n\n\n\nfunc NewActor(client CloudControllerClient) Actor ", "output": "{\n\treturn Actor{\n\t\tCloudControllerClient: client,\n\t}\n}"}
{"input": "package util\n\nimport \"math\"\n\n\nfunc Max(vars []int64) (maxVar int64) {\n\tfor _, i := range vars {\n\t\tif i > maxVar {\n\t\t\tmaxVar = i\n\t\t}\n\t}\n\treturn\n}\n\n\nfunc Expectation(randomVars []float64) float64 {\n\tif len(randomVars) == 0 {\n\t\treturn 0\n\t}\n\n\tvar sum float64\n\tfor _, rv := range randomVars {\n\t\tsum += rv\n\t}\n\n\treturn sum / float64(len(randomVars))\n}\n\n\nfunc StdDeviation(randomVars []float64) float64 {\n\tif len(randomVars) == 0 {\n\t\treturn 0\n\t}\n\treturn math.Sqrt(Deviation(randomVars))\n}\n\n\nfunc Deviation(randomVars []float64) float64 {\n\tif len(randomVars) == 0 {\n\t\treturn 0\n\t}\n\tvar total float64\n\texpec := Expectation(randomVars)\n\tfor _, rv := range randomVars {\n\t\ttotal += math.Pow(rv-expec, 2.0)\n\t}\n\treturn total / float64(len(randomVars))\n}\n\n\n\n\nfunc Normallization(randomVars []int64) []float64 ", "output": "{\n\tif len(randomVars) == 0 {\n\t\treturn nil\n\t}\n\tmaxVal := Max(randomVars)\n\tif maxVal == 0 || maxVal == 1 {\n\t\treturn nil\n\t}\n\tres := make([]float64, 0, len(randomVars))\n\tfor _, rv := range randomVars {\n\t\tres = append(res, math.Log10(float64(rv))/math.Log10(float64(maxVal)))\n\t}\n\treturn res\n}"}
{"input": "package untyped\n\nimport (\n\t\"fmt\"\n\t\"go/constant\"\n\tr \"reflect\"\n\n\t\"github.com/cosmos72/gomacro/base/reflect\"\n\txr \"github.com/cosmos72/gomacro/xreflect\"\n)\n\n\ntype Kind r.Kind\n\nconst (\n\tNone    = Kind(r.Invalid)\n\tBool    = Kind(r.Bool)\n\tInt     = Kind(r.Int)\n\tRune    = Kind(r.Int32)\n\tFloat   = Kind(r.Float64)\n\tComplex = Kind(r.Complex128)\n\tString  = Kind(r.String)\n)\n\nfunc (k Kind) String() string {\n\tvar s string\n\tswitch k {\n\tcase None:\n\t\ts = \"nil\"\n\tcase Rune:\n\t\ts = \"rune\"\n\tdefault:\n\t\ts = r.Kind(k).String()\n\t}\n\treturn s\n}\n\nfunc (k Kind) Reflect() r.Kind {\n\treturn r.Kind(k)\n}\n\nfunc (k Kind) Category() r.Kind {\n\treturn reflect.Category(r.Kind(k))\n}\n\n\ntype Lit struct {\n\tKind       Kind \n\tVal        constant.Value\n\tbasicTypes *[]xr.Type\n}\n\nfunc MakeLit(kind Kind, val constant.Value, basicTypes *[]xr.Type) Lit {\n\treturn Lit{kind, val, basicTypes}\n}\n\n\n\n\nfunc MakeKind(ckind constant.Kind) Kind {\n\tret := None\n\tswitch ckind {\n\tcase constant.Bool:\n\t\tret = Bool\n\tcase constant.Int:\n\t\tret = Int \n\tcase constant.Float:\n\t\tret = Float\n\tcase constant.Complex:\n\t\tret = Complex\n\tcase constant.String:\n\t\tret = String\n\t}\n\treturn ret\n}\n\nfunc (untyp Lit) String() string ", "output": "{\n\tval := untyp.Val\n\tvar strobj interface{}\n\tif untyp.Kind == Rune && val.Kind() == constant.Int {\n\t\tif i, exact := constant.Int64Val(val); exact {\n\t\t\tif i >= 0 && i <= 0x10FFFF {\n\t\t\t\tstrobj = fmt.Sprintf(\"%q\", i)\n\t\t\t}\n\t\t}\n\t}\n\tif strobj == nil {\n\t\tstrobj = val.ExactString()\n\t}\n\treturn fmt.Sprintf(\"{%v %v}\", untyp.Kind, strobj)\n}"}
{"input": "package handlers\n\nimport (\n\t\"fmt\"\n\t\"github.com/Nebuleuse/Nebuleuse/core\"\n\t\"github.com/gorilla/context\"\n\t\"net/http\"\n\t\"time\"\n)\n\n\nfunc subscribeTo(w http.ResponseWriter, r *http.Request) {\n\tpipe := context.Get(r, \"pipe\").(string)\n\tchannel := context.Get(r, \"channel\").(string)\n\tsession := context.Get(r, \"session\").(*core.UserSession)\n\n\t\tcore.Listen(pipe, channel, session)\n\tEasyResponse(w, core.NebErrorNone, \"subscribed to \"+channel)\n}\n\n\n\nfunc unSubscribeTo(w http.ResponseWriter, r *http.Request) {\n\tpipe := context.Get(r, \"pipe\").(string)\n\tchannel := context.Get(r, \"channel\").(string)\n\tsession := context.Get(r, \"session\").(*core.UserSession)\n\n\tcore.StopListen(pipe, channel, session)\n\tEasyResponse(w, core.NebErrorNone, \"unSubscribed from \"+channel)\n}\n\n\nfunc sendMessage(w http.ResponseWriter, r *http.Request) {\n\tpipe := context.Get(r, \"pipe\").(string)\n\tchannel := context.Get(r, \"channel\").(string)\n\tmessage := context.Get(r, \"message\").(string)\n\n\tcore.Dispatch(pipe, channel, message)\n\tEasyResponse(w, core.NebErrorNone, \"Sent message (\"+channel+\")\"+message)\n}\n\n\n\n\nfunc getMessages(w http.ResponseWriter, r *http.Request) ", "output": "{\n\tsession := context.Get(r, \"session\").(*core.UserSession)\n\n\tif session == nil {\n\t\tEasyResponse(w, core.NebErrorDisconnected, \"No session found\")\n\t\treturn\n\t}\n\n\tif session.LongPolling {\n\t\tsession.TimedOut <- 1\n\t}\n\n\tsession.LongPolling = true\n\tsession.Heartbeat()\n\tselect {\n\tcase msg := <-session.Messages:\n\t\tcore.Info.Println(msg)\n\t\tfmt.Fprint(w, msg)\n\tcase <-session.TimedOut:\n\t\treturn\n\tcase <-time.After(time.Second * time.Duration(core.Cfg.GetSysConfigInt(\"LongpollingTimeout\"))):\n\t\tEasyResponse(w, core.NebErrorNone, \"longpoll timedout\")\n\t}\n\tsession.LongPolling = false\n}"}
{"input": "package iso20022\n\n\ntype MandateStatus1Choice struct {\n\n\tCode *ExternalMandateStatus1Code `xml:\"Cd\"`\n\n\tProprietary *Max35Text `xml:\"Prtry\"`\n}\n\n\n\nfunc (m *MandateStatus1Choice) SetProprietary(value string) {\n\tm.Proprietary = (*Max35Text)(&value)\n}\n\nfunc (m *MandateStatus1Choice) SetCode(value string) ", "output": "{\n\tm.Code = (*ExternalMandateStatus1Code)(&value)\n}"}
{"input": "package main\n\ntype StringSet map[string]struct{}\n\nfunc NewStringSet() StringSet {\n\treturn make(map[string]struct{})\n}\n\nfunc (s StringSet) Add(val string) bool {\n\tif _, ok := s[val]; ok {\n\t\treturn false\n\t}\n\n\ts[val] = struct{}{}\n\treturn true\n}\n\n\n\nfunc (s StringSet) Count() int {\n\treturn len(s)\n}\n\nfunc (s StringSet) ToList() []string {\n\tlist := make([]string, 0, s.Count())\n\n\tfor val, _ := range s {\n\t\tlist = append(list, val)\n\t}\n\n\treturn list\n}\n\nfunc (s StringSet) Remove(val string) bool ", "output": "{\n\tif _, ok := s[val]; ok {\n\t\tdelete(s, val)\n\t\treturn true\n\t}\n\n\treturn false\n}"}
{"input": "package console\n\nimport (\n\tv1 \"github.com/cgrates/cgrates/apier/v1\"\n\t\"github.com/cgrates/cgrates/engine\"\n\t\"github.com/cgrates/cgrates/utils\"\n)\n\nfunc init() {\n\tc := &CmdSetDispatcherProfile{\n\t\tname:      \"dispatchers_profile_set\",\n\t\trpcMethod: utils.APIerSv1SetDispatcherProfile,\n\t}\n\tcommands[c.Name()] = c\n\tc.CommandExecuter = &CommandExecuter{c}\n}\n\n\ntype CmdSetDispatcherProfile struct {\n\tname      string\n\trpcMethod string\n\trpcParams *v1.DispatcherWithCache\n\t*CommandExecuter\n}\n\nfunc (self *CmdSetDispatcherProfile) Name() string {\n\treturn self.name\n}\n\nfunc (self *CmdSetDispatcherProfile) RpcMethod() string {\n\treturn self.rpcMethod\n}\n\nfunc (self *CmdSetDispatcherProfile) RpcParams(reset bool) interface{} {\n\tif reset || self.rpcParams == nil {\n\t\tself.rpcParams = &v1.DispatcherWithCache{\n\t\t\tDispatcherProfile: new(engine.DispatcherProfile),\n\t\t\tOpts:              make(map[string]interface{}),\n\t\t}\n\t}\n\treturn self.rpcParams\n}\n\nfunc (self *CmdSetDispatcherProfile) PostprocessRpcParams() error {\n\treturn nil\n}\n\n\n\nfunc (self *CmdSetDispatcherProfile) RpcResult() interface{} ", "output": "{\n\tvar s string\n\treturn &s\n}"}
{"input": "package memory\n\nimport (\n\t\"bytes\"\n\n\t\"github.com/aykevl/dtsync/tree\"\n)\n\n\ntype fileCopier struct {\n\tbytes.Buffer\n\tcallback func(*bytes.Buffer) (tree.FileInfo, tree.FileInfo, error)\n}\n\n\nfunc newFileCopier(callback func(*bytes.Buffer) (tree.FileInfo, tree.FileInfo, error)) *fileCopier {\n\treturn &fileCopier{\n\t\tcallback: callback,\n\t}\n}\n\n\n\nfunc (fc *fileCopier) Finish() (tree.FileInfo, tree.FileInfo, error) {\n\treturn fc.callback(&fc.Buffer)\n}\n\n\n\nfunc (fc *fileCopier) Cancel() error {\n\treturn nil\n}\n\n\n\ntype fileCloser struct {\n\t*bytes.Buffer\n\tcallback func(*bytes.Buffer)\n}\n\n\nfunc newFileCloser(callback func(*bytes.Buffer)) *fileCloser {\n\treturn &fileCloser{\n\t\tBuffer:   &bytes.Buffer{},\n\t\tcallback: callback,\n\t}\n}\n\n\n\nfunc (fc *fileCloser) Close() error {\n\tfc.callback(fc.Buffer)\n\treturn nil\n}\n\n\n\ntype readCloseBuffer struct {\n\tbuf *bytes.Reader\n}\n\n\n\n\nfunc (b *readCloseBuffer) Read(p []byte) (int, error) {\n\treturn b.buf.Read(p)\n}\n\n\nfunc (b *readCloseBuffer) ReadAt(p []byte, off int64) (int, error) {\n\treturn b.buf.ReadAt(p, off)\n}\n\n\n\nfunc (b *readCloseBuffer) Close() error {\n\treturn nil\n}\n\nfunc newReadCloseBuffer(data []byte) *readCloseBuffer ", "output": "{\n\treturn &readCloseBuffer{bytes.NewReader(data)}\n}"}
{"input": "package pgp \n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"golang.org/x/crypto/openpgp\"\n\t\"golang.org/x/crypto/openpgp/armor\"\n\t\"io\"\n\t\"strings\"\n)\n\n\n\nfunc Verify(data string, signature string, keyring io.Reader) (valid bool, entity *openpgp.Entity, err error) {\n\tvalid = false\n\n\tsig := reArmorSignature(signature)\n\tsigReader := strings.NewReader(sig)\n\n\tsigBlock, err := armor.Decode(sigReader)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif sigBlock.Type != \"PGP SIGNATURE\" {\n\t\terr = fmt.Errorf(\"Wrong signature type '%s'\", sigBlock.Type)\n\t\tpanic(err)\n\t}\n\n\tsrcReader := strings.NewReader(data)\n\n\tring, err := openpgp.ReadKeyRing(keyring)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tentity, err = openpgp.CheckDetachedSignature(ring, srcReader, sigBlock.Body)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvalid = true\n\n\treturn\n}\n\n\n\n\n\nfunc reArmorSignature(line string) string ", "output": "{\n\tlastEq := strings.LastIndex(line, \"=\")\n\tif lastEq == -1 {\n\t\treturn \"\"\n\t}\n\tbuf := new(bytes.Buffer)\n\tfmt.Fprintf(buf, \"-----BEGIN PGP SIGNATURE-----\\n\\n\")\n\tpayload := line[0:lastEq]\n\tcrc := line[lastEq:]\n\tfor len(payload) > 0 {\n\t\tchunkLen := len(payload)\n\t\tif chunkLen > 64 {\n\t\t\tchunkLen = 64\n\t\t}\n\t\tfmt.Fprintf(buf, \"%s\\n\", payload[0:chunkLen])\n\t\tpayload = payload[chunkLen:]\n\t}\n\tfmt.Fprintf(buf, \"%s\\n-----END PGP SIGNATURE-----\", crc)\n\treturn buf.String()\n}"}
{"input": "package packr\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/gobuffalo/envy\"\n\t\"github.com/gobuffalo/packr/v2/plog\"\n)\n\nfunc construct(name string, path string) *Box {\n\treturn &Box{\n\t\tPath:\t\tpath,\n\t\tName:\t\tname,\n\t\tResolutionDir:\tresolutionDir(path),\n\t\tresolvers:\tresolversMap{},\n\t\tdirs:\t\tdirsMap{},\n\t}\n}\n\nfunc resolutionDirTestFilename(filename, og string) (string, bool) {\n\tng := filepath.Join(filepath.Dir(filename), og)\n\n\tcov := filepath.Join(\"_test\", \"_obj_test\")\n\tng = strings.Replace(ng, string(filepath.Separator)+cov, \"\", 1)\n\n\tif resolutionDirExists(ng, og) {\n\t\treturn ng, true\n\t}\n\n\tng = filepath.Join(envy.GoPath(), \"src\", ng)\n\tif resolutionDirExists(ng, og) {\n\t\treturn ng, true\n\t}\n\n\treturn og, false\n}\n\n\n\nfunc resolutionDir(og string) string {\n\tng, _ := filepath.Abs(og)\n\n\tif resolutionDirExists(ng, og) {\n\t\treturn ng\n\t}\n\n\t_, filename, _, _ := runtime.Caller(3)\n\tng, ok := resolutionDirTestFilename(filename, og)\n\tif ok {\n\t\treturn ng\n\t}\n\n\t_, filename, _, _ = runtime.Caller(4)\n\tng, ok = resolutionDirTestFilename(filename, og)\n\tif ok {\n\t\treturn ng\n\t}\n\n\treturn og\n}\n\nfunc resolutionDirExists(s, og string) bool ", "output": "{\n\t_, err := os.Stat(s)\n\tif err != nil {\n\t\treturn false\n\t}\n\tplog.Debug(\"packr\", \"resolutionDir\", \"original\", og, \"resolved\", s)\n\treturn true\n}"}
{"input": "package command\n\n\ntype Command interface {\n\tExecute() string\n}\n\n\ntype ToggleOnCommand struct {\n\treceiver *Receiver\n}\n\n\n\n\n\ntype ToggleOffCommand struct {\n\treceiver *Receiver\n}\n\n\nfunc (c *ToggleOffCommand) Execute() string {\n\treturn c.receiver.ToggleOff()\n}\n\n\ntype Receiver struct {\n}\n\n\nfunc (r *Receiver) ToggleOn() string {\n\treturn \"Toggle On\"\n}\n\n\nfunc (r *Receiver) ToggleOff() string {\n\treturn \"Toggle Off\"\n}\n\n\ntype Invoker struct {\n\tcommands []Command\n}\n\n\nfunc (i *Invoker) StoreCommand(command Command) {\n\ti.commands = append(i.commands, command)\n}\n\n\nfunc (i *Invoker) UnStoreCommand() {\n\tif len(i.commands) != 0 {\n\t\ti.commands = i.commands[:len(i.commands)-1]\n\t}\n}\n\n\nfunc (i *Invoker) Execute() string {\n\tvar result string\n\tfor _, command := range i.commands {\n\t\tresult += command.Execute() + \"\\n\"\n\t}\n\treturn result\n}\n\nfunc (c *ToggleOnCommand) Execute() string ", "output": "{\n\treturn c.receiver.ToggleOn()\n}"}
{"input": "package gnr\n\ntype Scene struct {\n\tCamera Camera\n\tObject Object\n}\n\n\n\nfunc (s *Scene) TracePixel(x, y uint64) []*InteractionResult ", "output": "{\n\tr := s.Camera.GetRayForPixel(x, y)\n\tr.Intensity = 1.0\n\tirs := s.Object.RayInteraction(r)\n\treturn InteractionResultSlice(irs).SortBy(InteractionResultDistance)\n}"}
{"input": "package bunyan\n\nimport \"fmt\"\n\n\ntype Logger struct {\n\tsink   Sink\n\trecord Record\n}\n\n\nfunc NewLogger(target Sink) *Logger {\n\treturn &Logger{target, NewRecord()}\n}\n\n\n\nfunc (l *Logger) Write(record Record) error {\n\trecord.TemplateMerge(l.record)\n\treturn l.sink.Write(record)\n}\n\n\n\n\n\n\n\nfunc (l *Logger) Record(key string, value interface{}) Log {\n\tbuilder := NewLogger(l)\n\tbuilder.record[key] = value\n\treturn builder\n}\n\n\n\nfunc (l *Logger) Recordf(key, value string, args ...interface{}) Log {\n\treturn l.Record(key, fmt.Sprintf(value, args...))\n}\n\n\n\nfunc (l *Logger) Child() Log {\n\treturn NewLogger(l)\n}\n\nfunc (l *Logger) Tracef(msg string, args ...interface{}) { l.send(TRACE, msg, args...) }\nfunc (l *Logger) Debugf(msg string, args ...interface{}) { l.send(DEBUG, msg, args...) }\nfunc (l *Logger) Infof(msg string, args ...interface{})  { l.send(INFO, msg, args...) }\nfunc (l *Logger) Warnf(msg string, args ...interface{})  { l.send(WARN, msg, args...) }\nfunc (l *Logger) Errorf(msg string, args ...interface{}) { l.send(ERROR, msg, args...) }\nfunc (l *Logger) Fatalf(msg string, args ...interface{}) { l.send(FATAL, msg, args...) }\n\nfunc (l *Logger) send(level Level, msg string, args ...interface{}) {\n\trecord := NewRecord()\n\trecord.SetMessagef(level, msg, args...)\n\te := l.Write(record)\n\n\tif e != nil {\n\t\tpanic(e)\n\t}\n}\n\nfunc (l *Logger) Include(info Info) Log ", "output": "{\n\treturn NewLogger(InfoSink(l, info))\n}"}
{"input": "package core\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/oracle/oci-go-sdk/v46/common\"\n)\n\n\ntype BootVolumeSourceDetails interface {\n}\n\ntype bootvolumesourcedetails struct {\n\tJsonData []byte\n\tType     string `json:\"type\"`\n}\n\n\nfunc (m *bootvolumesourcedetails) UnmarshalJSON(data []byte) error {\n\tm.JsonData = data\n\ttype Unmarshalerbootvolumesourcedetails bootvolumesourcedetails\n\ts := struct {\n\t\tModel Unmarshalerbootvolumesourcedetails\n\t}{}\n\terr := json.Unmarshal(data, &s.Model)\n\tif err != nil {\n\t\treturn err\n\t}\n\tm.Type = s.Model.Type\n\n\treturn err\n}\n\n\nfunc (m *bootvolumesourcedetails) UnmarshalPolymorphicJSON(data []byte) (interface{}, error) {\n\n\tif data == nil || string(data) == \"null\" {\n\t\treturn nil, nil\n\t}\n\n\tvar err error\n\tswitch m.Type {\n\tcase \"bootVolumeBackup\":\n\t\tmm := BootVolumeSourceFromBootVolumeBackupDetails{}\n\t\terr = json.Unmarshal(data, &mm)\n\t\treturn mm, err\n\tcase \"bootVolume\":\n\t\tmm := BootVolumeSourceFromBootVolumeDetails{}\n\t\terr = json.Unmarshal(data, &mm)\n\t\treturn mm, err\n\tcase \"bootVolumeReplica\":\n\t\tmm := BootVolumeSourceFromBootVolumeReplicaDetails{}\n\t\terr = json.Unmarshal(data, &mm)\n\t\treturn mm, err\n\tdefault:\n\t\treturn *m, nil\n\t}\n}\n\n\n\nfunc (m bootvolumesourcedetails) String() string ", "output": "{\n\treturn common.PointerString(m)\n}"}
{"input": "package v4\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n)\n\n\n\ntype rules []rule\n\n\n\ntype rule interface {\n\tIsValid(value string) bool\n}\n\n\n\nfunc (r rules) IsValid(value string) bool {\n\tfor _, rule := range r {\n\t\tif rule.IsValid(value) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\ntype mapRule map[string]struct{}\n\n\nfunc (m mapRule) IsValid(value string) bool {\n\t_, ok := m[value]\n\treturn ok\n}\n\n\ntype whitelist struct {\n\trule\n}\n\n\n\n\n\ntype blacklist struct {\n\trule\n}\n\n\nfunc (b blacklist) IsValid(value string) bool {\n\treturn !b.rule.IsValid(value)\n}\n\ntype patterns []string\n\n\n\nfunc (p patterns) IsValid(value string) bool {\n\tfor _, pattern := range p {\n\t\tif strings.HasPrefix(http.CanonicalHeaderKey(value), pattern) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n\ntype inclusiveRules []rule\n\n\nfunc (r inclusiveRules) IsValid(value string) bool {\n\tfor _, rule := range r {\n\t\tif !rule.IsValid(value) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (w whitelist) IsValid(value string) bool ", "output": "{\n\treturn w.rule.IsValid(value)\n}"}
{"input": "package main\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n\t\"text/template\"\n\n\t\"github.com/kyokomi/emoji\"\n)\n\nfunc getTitle(html []byte) string {\n\tr := regexp.MustCompile(\"<h1>(.*)</h1>\")\n\treturn strings.Replace(r.FindStringSubmatch(string(html))[1], \" \", \"\", -1)\n}\n\nfunc getContent(html []byte) string {\n\tr := regexp.MustCompile(\"<h1>(.*)</h1>\")\n\treturn strings.TrimSpace(r.ReplaceAllString(string(html), \"\"))\n}\n\nfunc getCanvasMap(html []byte) map[string]string {\n\tr := regexp.MustCompile(\"<h1>(\\\\w|\\\\s)*</h1>\")\n\tindex := r.FindAllIndex(html, -1)\n\n\tm := map[string]string{}\n\tfor i := 0; i < len(index); i++ {\n\t\tif i == (len(index) - 1) {\n\t\t\tm[getTitle(html[index[i][0]:])] = getContent(html[index[i][0]:])\n\t\t} else {\n\t\t\tm[getTitle(html[index[i][0]:index[i+1][0]])] = getContent(html[index[i][0]:index[i+1][0]])\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc getParsedTemplate() *template.Template {\n\ttpl := template.New(\"\")\n\ttpl = template.Must(tpl.Parse(TEMPLATE_CANVAS))\n\ttpl = template.Must(tpl.Parse(TEMPLATE_SANITIZE))\n\ttpl = template.Must(tpl.Parse(TEMPLATE_STYLE_CANVAS))\n\ttpl = template.Must(tpl.Parse(TEMPLATE_STYLE_MARKDOWN))\n\treturn tpl\n}\n\n\n\nfunc emojify(html []byte) []byte ", "output": "{\n\treturn []byte(emoji.Sprint(string(html)))\n}"}
{"input": "package model\n\nimport (\n\t\"k8s.io/autoscaler/cluster-autoscaler/cloudprovider/huaweicloud/huaweicloud-sdk-go-v3/core/utils\"\n\n\t\"strings\"\n)\n\n\ntype ResumeScalingGroupResponse struct {\n\tHttpStatusCode int `json:\"-\"`\n}\n\n\n\nfunc (o ResumeScalingGroupResponse) String() string ", "output": "{\n\tdata, err := utils.Marshal(o)\n\tif err != nil {\n\t\treturn \"ResumeScalingGroupResponse struct{}\"\n\t}\n\n\treturn strings.Join([]string{\"ResumeScalingGroupResponse\", string(data)}, \" \")\n}"}
{"input": "package store\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc interestingGoroutines() (gs []string) {\n\tbuf := make([]byte, 2<<20)\n\tbuf = buf[:runtime.Stack(buf, true)]\n\tfor _, g := range strings.Split(string(buf), \"\\n\\n\") {\n\t\tsl := strings.SplitN(g, \"\\n\", 2)\n\t\tif len(sl) != 2 {\n\t\t\tcontinue\n\t\t}\n\t\tstack := strings.TrimSpace(sl[1])\n\t\tif stack == \"\" ||\n\t\t\tstrings.Contains(stack, \"created by testing.RunTests\") ||\n\t\t\tstrings.Contains(stack, \"testing.Main(\") ||\n\t\t\tstrings.Contains(stack, \"runtime.goexit\") ||\n\t\t\tstrings.Contains(stack, \"github.com/coreos/rkt/store.interestingGoroutines\") ||\n\t\t\tstrings.Contains(stack, \"created by runtime.gc\") ||\n\t\t\tstrings.Contains(stack, \"runtime.MHeap_Scavenger\") {\n\t\t\tcontinue\n\t\t}\n\t\tgs = append(gs, stack)\n\t}\n\tsort.Strings(gs)\n\treturn\n}\n\n\nfunc TestMain(m *testing.M) {\n\tv := m.Run()\n\tif v == 0 && goroutineLeaked() {\n\t\tos.Exit(1)\n\t}\n\tos.Exit(v)\n}\n\n\n\nfunc goroutineLeaked() bool ", "output": "{\n\tif testing.Short() {\n\t\treturn false\n\t}\n\tgs := interestingGoroutines()\n\n\tn := 0\n\tstackCount := make(map[string]int)\n\tfor _, g := range gs {\n\t\tstackCount[g]++\n\t\tn++\n\t}\n\n\tif n == 0 {\n\t\treturn false\n\t}\n\tfmt.Fprintf(os.Stderr, \"Too many goroutines running after integration test(s).\\n\")\n\tfor stack, count := range stackCount {\n\t\tfmt.Fprintf(os.Stderr, \"%d instances of:\\n%s\\n\", count, stack)\n\t}\n\treturn true\n}"}
{"input": "package utils\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\n\n\n\n\nfunc AskForConfirmation(s string) bool {\n\treader := bufio.NewReader(os.Stdin)\n\n\tfor {\n\t\tfmt.Printf(\"%s [y/n]: \", s)\n\n\t\tresponse, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\texitWithError(err)\n\t\t}\n\n\t\tresponse = strings.ToLower(strings.TrimSpace(response))\n\n\t\tif response == \"y\" || response == \"yes\" {\n\t\t\treturn true\n\t\t} else if response == \"n\" || response == \"no\" {\n\t\t\treturn false\n\t\t}\n\t}\n}\n\n\n\n\n\nfunc exitWithError(err error) ", "output": "{\n\tfmt.Fprintf(os.Stderr, \"%v\\n\", err)\n\tos.Exit(1)\n}"}
{"input": "package cookie\n\nimport \"time\"\n\n\ntype Option func(*Options)\n\n\ntype Options struct {\n\tPath    string    \n\tDomain  string    \n\tExpires time.Time \n\n\tMaxAge   int\n\tSecure   bool\n\tHttpOnly bool\n}\n\n\n\n\n\nfunc Path(s string) Option {\n\treturn func(o *Options) {\n\t\to.Path = s\n\t}\n}\n\n\nfunc Domain(s string) Option {\n\treturn func(o *Options) {\n\t\to.Domain = s\n\t}\n}\n\n\nfunc Expires(t time.Time) Option {\n\treturn func(o *Options) {\n\t\to.Expires = t\n\t}\n}\n\n\nfunc MaxAge(i int) Option {\n\treturn func(o *Options) {\n\t\to.MaxAge = i\n\t}\n}\n\n\nfunc Secure(b bool) Option {\n\treturn func(o *Options) {\n\t\to.Secure = b\n\t}\n}\n\n\nfunc HttpOnly(b bool) Option {\n\treturn func(o *Options) {\n\t\to.HttpOnly = b\n\t}\n}\n\nfunc Parse(opts ...Option) Options ", "output": "{\n\topt := Options{}\n\tfor _, o := range opts {\n\t\to(&opt)\n\t}\n\treturn opt\n}"}
